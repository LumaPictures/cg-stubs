import MRenderItem  # type: ignore[import-not-found]
from _typeshed import Incomplete
from maya.api.OpenMaya import MBoundingBox, MCacheSchema, MColor, MDagPath, MDoubleArray, MEvaluationNode, MFloatArray, MFloatPoint, MImage, MMatrix, MMatrixArray, MObject, MPlug, MPointArray, MSelectionList, MSelectionMask, MUintArray, MUserData
from maya.api.OpenMayaUI import MUIDrawManager as MUIDrawManager  # type: ignore[attr-defined]
from typing import Any, ClassVar, Self, overload  # type: ignore[attr-defined]

ourdict: dict
py2dict: dict
key: str
val: str

class MColorManagementUtilities:
    @staticmethod
    def getColorTransformData(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def getColorTransformCacheIdForInputSpace(inputSpaceName: str) -> transformId: ...  # type: ignore[name-defined]
    @staticmethod
    def getColorTransformCacheIdForOutputTransform() -> transformId: ...  # type: ignore[name-defined]
    @staticmethod
    def isColorManagementEnabled() -> Boolean: ...  # type: ignore[name-defined]
    @staticmethod
    def isColorManagementAvailable() -> Boolean: ...  # type: ignore[name-defined]

class MComponentDataIndexing:
    kFaceVertex: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def indices(self) -> MUintArray: ...
    def componentType(self) -> MComponentType: ...  # type: ignore[name-defined]
    def setComponentType(self, MComponentType: Incomplete) -> Self: ...

class MComponentDataIndexingList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, MComponentDataIndexing: Incomplete) -> bool: ...
    def remove(self, index: Incomplete) -> bool: ...
    def clear(self) -> Self: ...

class MFrameContext:
    kWorldMtx: ClassVar[int] = ...
    kWorldTransposeMtx: ClassVar[int] = ...
    kWorldInverseMtx: ClassVar[int] = ...
    kWorldTranspInverseMtx: ClassVar[int] = ...
    kViewMtx: ClassVar[int] = ...
    kViewTransposeMtx: ClassVar[int] = ...
    kViewInverseMtx: ClassVar[int] = ...
    kViewTranspInverseMtx: ClassVar[int] = ...
    kProjectionMtx: ClassVar[int] = ...
    kProjectionTranposeMtx: ClassVar[int] = ...
    kProjectionInverseMtx: ClassVar[int] = ...
    kProjectionTranspInverseMtx: ClassVar[int] = ...
    kViewProjMtx: ClassVar[int] = ...
    kViewProjTranposeMtx: ClassVar[int] = ...
    kViewProjInverseMtx: ClassVar[int] = ...
    kViewProjTranspInverseMtx: ClassVar[int] = ...
    kWorldViewMtx: ClassVar[int] = ...
    kWorldViewTransposeMtx: ClassVar[int] = ...
    kWorldViewInverseMtx: ClassVar[int] = ...
    kWorldViewTranspInverseMtx: ClassVar[int] = ...
    kWorldViewProjMtx: ClassVar[int] = ...
    kWorldViewProjTransposeMtx: ClassVar[int] = ...
    kWorldViewProjInverseMtx: ClassVar[int] = ...
    kWorldViewProjTranspInverseMtx: ClassVar[int] = ...
    kViewPosition: ClassVar[int] = ...
    kViewDirection: ClassVar[int] = ...
    kViewUp: ClassVar[int] = ...
    kViewRight: ClassVar[int] = ...
    kViewportPixelSize: ClassVar[int] = ...
    kViewNearClipValue: ClassVar[int] = ...
    kViewFarClipValue: ClassVar[int] = ...
    kViewUnnormlizedNearClipValue: ClassVar[int] = ...
    kViewUnnormalizedFarClipValue: ClassVar[int] = ...
    kGouraudShaded: ClassVar[int] = ...
    kWireFrame: ClassVar[int] = ...
    kBoundingBox: ClassVar[int] = ...
    kTextured: ClassVar[int] = ...
    kDefaultMaterial: ClassVar[int] = ...
    kXrayJoint: ClassVar[int] = ...
    kXray: ClassVar[int] = ...
    kTwoSidedLighting: ClassVar[int] = ...
    kFlatShaded: ClassVar[int] = ...
    kShadeActiveOnly: ClassVar[int] = ...
    kXrayActiveComponents: ClassVar[int] = ...
    kBackfaceCulling: ClassVar[int] = ...
    kSmoothWireframe: ClassVar[int] = ...
    kSelectionHighlighting: ClassVar[int] = ...
    kNoLighting: ClassVar[int] = ...
    kAmbientLight: ClassVar[int] = ...
    kLightDefault: ClassVar[int] = ...
    kSelectedLights: ClassVar[int] = ...
    kSceneLights: ClassVar[int] = ...
    kCustomLights: ClassVar[int] = ...
    kAmbientOcclusion: ClassVar[int] = ...
    kMotionBlur: ClassVar[int] = ...
    kGammaCorrection: ClassVar[int] = ...
    kViewColorTransformEnabled: ClassVar[int] = ...
    kDepthOfField: ClassVar[int] = ...
    kAntiAliasing: ClassVar[int] = ...
    kUnsorted: ClassVar[int] = ...
    kObjectSorting: ClassVar[int] = ...
    kWeightedAverage: ClassVar[int] = ...
    kDepthPeeling: ClassVar[int] = ...
    kWireframeOnShadedFull: ClassVar[int] = ...
    kWireFrameOnShadedReduced: ClassVar[int] = ...
    kWireFrameOnShadedNone: ClassVar[int] = ...
    k3dViewport: ClassVar[int] = ...
    k2dViewport: ClassVar[int] = ...
    kImage: ClassVar[int] = ...
    kFogLinear: ClassVar[int] = ...
    kFogExp: ClassVar[int] = ...
    kFogExp2: ClassVar[int] = ...
    kExcludeNone: ClassVar[int] = ...
    kExcludeNurbsCurves: ClassVar[int] = ...
    kExcludeNurbsSurfaces: ClassVar[int] = ...
    kExcludeMeshes: ClassVar[int] = ...
    kExcludePlanes: ClassVar[int] = ...
    kExcludeLights: ClassVar[int] = ...
    kExcludeCameras: ClassVar[int] = ...
    kExcludeJoints: ClassVar[int] = ...
    kExcludeIkHandles: ClassVar[int] = ...
    kExcludeDeformers: ClassVar[int] = ...
    kExcludeDynamics: ClassVar[int] = ...
    kExcludeParticleInstancers: ClassVar[int] = ...
    kExcludeLocators: ClassVar[int] = ...
    kExcludeDimensions: ClassVar[int] = ...
    kExcludeSelectHandles: ClassVar[int] = ...
    kExcludePivots: ClassVar[int] = ...
    kExcludeTextures: ClassVar[int] = ...
    kExcludeGrid: ClassVar[int] = ...
    kExcludeCVs: ClassVar[int] = ...
    kExcludeHulls: ClassVar[int] = ...
    kExcludeStrokes: ClassVar[int] = ...
    kExcludeSubdivSurfaces: ClassVar[int] = ...
    kExcludeFluids: ClassVar[int] = ...
    kExcludeFollicles: ClassVar[int] = ...
    kExcludeHairSystems: ClassVar[int] = ...
    kExcludeImagePlane: ClassVar[int] = ...
    kExcludeNCloths: ClassVar[int] = ...
    kExcludeNRigids: ClassVar[int] = ...
    kExcludeDynamicConstraints: ClassVar[int] = ...
    kExcludeManipulators: ClassVar[int] = ...
    kExcludeNParticles: ClassVar[int] = ...
    kExcludeMotionTrails: ClassVar[int] = ...
    kExcludeHoldOuts: ClassVar[int] = ...
    kExcludePluginShapes: ClassVar[int] = ...
    kExcludeHUD: ClassVar[int] = ...
    kExcludeClipGhosts: ClassVar[int] = ...
    kExcludeGreasePencils: ClassVar[int] = ...
    kExcludeControllers: ClassVar[int] = ...
    kExcludeAll: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def semanticToMatrixType(string: str) -> int: ...
    def getMatrix(self, int: int) -> MMatrix: ...
    @staticmethod
    def semanticToTupleType(string: str) -> int: ...
    def getTuple(self, int: int) -> MDoubleArray: ...
    def getViewportDimensions(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getGlobalLineWidth(self) -> float: ...
    def getCurrentCameraPath(self) -> MDagPath: ...
    def getCurrentColorRenderTarget(self) -> MRenderTarget: ...
    def getCurrentDepthRenderTarget(self) -> MRenderTarget: ...
    def objectTypeExclusions(self) -> float: ...
    def classificationExclusions(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getDisplayStyle(self) -> int: ...
    def getLightingMode(self) -> int: ...
    def getLightLimit(self) -> int: ...
    def getPostEffectEnabled(self, int: int) -> bool: ...
    def getTransparencyAlgorithm(self) -> int: ...
    @staticmethod
    def inUserInteraction() -> bool: ...
    @staticmethod
    def userChangingViewContext() -> bool: ...
    @staticmethod
    def wireOnShadedMode() -> int: ...
    @staticmethod
    def shadeTemplates() -> bool: ...
    def renderingDestination(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getEnvironmentParameters(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getDOFParameters(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getBackgroundParameters(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getHwFogParameters(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getRenderOverrideInformation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MLightParameterInformation:
    kInvalid: ClassVar[int] = ...
    kBoolean: ClassVar[int] = ...
    kInteger: ClassVar[int] = ...
    kFloat: ClassVar[int] = ...
    kFloat2: ClassVar[int] = ...
    kFloat3: ClassVar[int] = ...
    kFloat4: ClassVar[int] = ...
    kFloat4x4Row: ClassVar[int] = ...
    kFloat4x4Col: ClassVar[int] = ...
    kTexture2: ClassVar[int] = ...
    kSampler: ClassVar[int] = ...
    kTextureCube: ClassVar[int] = ...
    kNoSemantic: ClassVar[int] = ...
    kLightEnabled: ClassVar[int] = ...
    kWorldPosition: ClassVar[int] = ...
    kWorldDirection: ClassVar[int] = ...
    kIntensity: ClassVar[int] = ...
    kColor: ClassVar[int] = ...
    kEmitsDiffuse: ClassVar[int] = ...
    kEmitsSpecular: ClassVar[int] = ...
    kDecayRate: ClassVar[int] = ...
    kDropoff: ClassVar[int] = ...
    kCosConeAngle: ClassVar[int] = ...
    kStartShadowParameters: ClassVar[int] = ...
    kIrradianceIn: ClassVar[int] = ...
    kShadowMap: ClassVar[int] = ...
    kShadowSamp: ClassVar[int] = ...
    kShadowBias: ClassVar[int] = ...
    kShadowMapSize: ClassVar[int] = ...
    kShadowViewProj: ClassVar[int] = ...
    kShadowColor: ClassVar[int] = ...
    kGlobalShadowOn: ClassVar[int] = ...
    kShadowOn: ClassVar[int] = ...
    kShadowDirty: ClassVar[int] = ...
    kDepthRange: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def parameterList(self) -> listofstring: ...  # type: ignore[name-defined]
    def parameterType(self, string: str) -> int: ...
    def parameterSemantic(self, string: str) -> int: ...
    def parameterNames(self, int: int) -> listofstring: ...  # type: ignore[name-defined]
    def arrayParameterCount(self, string: str) -> int: ...
    def getParameter(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getParameterTextureHandle(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def lightType(self) -> str: ...
    def lightPath(self) -> MDagPath: ...

class MPassContext:
    kColorPassSemantic: ClassVar[str] = ...
    kShadowPassSemantic: ClassVar[str] = ...
    kDepthPassSemantic: ClassVar[str] = ...
    kNormalDepthPassSemantic: ClassVar[str] = ...
    kOpaqueGeometrySemantic: ClassVar[str] = ...
    kPreUIGeometrySemantic: ClassVar[str] = ...
    kPostUIGeometrySemantic: ClassVar[str] = ...
    kUIGeometrySemantic: ClassVar[str] = ...
    kOpaqueUISemantic: ClassVar[str] = ...
    kTransparentUISemantic: ClassVar[str] = ...
    kXrayUISemantic: ClassVar[str] = ...
    kTransparentGeometrySemantic: ClassVar[str] = ...
    kCullBackSemantic: ClassVar[str] = ...
    kCullFrontSemantic: ClassVar[str] = ...
    kMaterialOverrideSemantic: ClassVar[str] = ...
    kTransparentPeelSemantic: ClassVar[str] = ...
    kTransparentPeelAndAvgSemantic: ClassVar[str] = ...
    kTransparentWeightedAvgSemantic: ClassVar[str] = ...
    kUserPassSemantic: ClassVar[str] = ...
    kBeginRenderSemantic: ClassVar[str] = ...
    kBeginSceneRenderSemantic: ClassVar[str] = ...
    kEndSceneRenderSemantic: ClassVar[str] = ...
    kEndRenderSemantic: ClassVar[str] = ...
    kSelectionPassSemantic: ClassVar[str] = ...
    kDOFPassSemantic: ClassVar[str] = ...
    kMotionVectorPassSemantic: ClassVar[str] = ...
    kPEPatternPassSemantic: ClassVar[str] = ...
    kNonPEPatternPassSemantic: ClassVar[str] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def passIdentifier(self) -> str: ...
    def passSemantics(self) -> listofstring: ...  # type: ignore[name-defined]
    def hasShaderOverride(self) -> bool: ...
    def shaderOverrideInstance(self) -> MShaderInstance: ...

class MDrawContext(MFrameContext):
    kFilteredToLightLimit: ClassVar[int] = ...
    kFilteredIgnoreLightLimit: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def getFrameStamp(self) -> float: ...
    def getSceneBox(self) -> MBoundingBox: ...
    def getFrustumBox(self) -> MBoundingBox: ...
    def getRenderTargetSize(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getDepthRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def viewDirectionAlongNegZ(self) -> bool: ...
    def numberOfActiveLights(self, lightFilter: Incomplete = ...) -> int: ...
    def getLightInformation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getLightParameterInformation(self, lightNumber: Incomplete, lightFilter: Incomplete = ...) -> MLightParameterInformation: ...
    def getStateManager(self) -> MStateManager: ...
    def getPassContext(self) -> MPassContext: ...
    def copyCurrentColorRenderTarget(self, string: str) -> MRenderTarget: ...
    def copyCurrentDepthRenderTarget(self, string: str) -> MRenderTarget: ...
    def copyCurrentColorRenderTargetToTexture(self) -> MTexture: ...
    def copyCurrentDepthRenderTargetToTexture(self) -> MTexture: ...

class MDrawRegistry:
    @staticmethod
    def deregisterComponentConverter(renderItemName: Incomplete) -> None: ...
    @staticmethod
    def deregisterDrawOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterGeometryOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterImagePlaneOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterIndexBufferMutator(primitiveType: Incomplete) -> None: ...
    @staticmethod
    def deregisterPrimitiveGenerator(primitiveType: Incomplete) -> None: ...
    @staticmethod
    def deregisterShaderOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterShadingNodeOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterSubSceneOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterSurfaceShadingNodeOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete) -> None: ...
    @staticmethod
    def deregisterVertexBufferGenerator(bufferName: Incomplete) -> None: ...
    @staticmethod
    def deregisterVertexBufferMutator(bufferName: Incomplete) -> None: ...
    @staticmethod
    def registerComponentConverter(renderItemName: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerDrawOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerGeometryOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerImagePlaneOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerIndexBufferMutator(primitiveType: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerPrimitiveGenerator(primitiveType: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerShaderOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerShadingNodeOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerSubSceneOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerSurfaceShadingNodeOverrideCreator(drawClassification: Incomplete, registrantId: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerVertexBufferGenerator(bufferName: Incomplete, creator: Incomplete) -> None: ...
    @staticmethod
    def registerVertexBufferMutator(bufferName: Incomplete, creator: Incomplete) -> None: ...

class MFragmentManager:
    kVertexShader: ClassVar[int] = ...
    kPixelShader: ClassVar[int] = ...
    kGeometryShader: ClassVar[int] = ...
    kHullShader: ClassVar[int] = ...
    kHullConstantShader: ClassVar[int] = ...
    kDomainShader: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addFragmentGraphFromBuffer(self, buffer: Incomplete) -> str: ...
    def addFragmentGraphFromFile(self, fileName: Incomplete) -> str: ...
    def addFragmentPath(self, path: Incomplete) -> bool: ...
    def addShadeFragmentFromBuffer(self, buffer: Incomplete, hidden: Incomplete) -> str: ...
    def addShadeFragmentFromFile(self, fileName: Incomplete, hidden: Incomplete) -> str: ...
    def fragmentList(self) -> listofstring: ...  # type: ignore[name-defined]
    def getEffectOutputDirectory(self) -> str: ...
    @overload
    def getFragmentXML(self, fragmentName: Incomplete) -> str: ...
    @overload
    def getFragmentXML(self, shadingNode: Incomplete, includeUpstreamNodes: Incomplete = ..., objectContext: Incomplete = ...) -> str: ...
    def getIntermediateGraphOutputDirectory(self) -> str: ...
    def hasFragment(self, string: str) -> bool: ...
    def removeFragment(self, fragmentName: Incomplete) -> bool: ...
    def setEffectOutputDirectory(self, string: str) -> Self: ...
    def setIntermediateGraphOutputDirectory(self, string: str) -> Self: ...
    def addAutomaticShaderStageInput(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def removeAutomaticShaderStageInput(self, int: int, string: str) -> bool: ...
    def addDomainShaderInputNameMapping(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def removeDomainShaderInputNameMapping(self, string: str) -> bool: ...
    def findDomainShaderInputName(self, string: str) -> str: ...
    def getColorManagementFragmentInfo(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MGeometryExtractor:
    kPolyGeom_Normal: ClassVar[int] = ...
    kPolyGeom_NotSharing: ClassVar[int] = ...
    kPolyGeom_BaseMesh: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def minimumBufferSize(primitiveCount: int, primitive: int, primitiveStride: int = ...) -> int: ...
    def populateIndexBuffer(self, data: buffer, primitiveCount: int, indexDesc: MIndexBufferDescriptor) -> Self: ...  # type: ignore[name-defined]
    def populateVertexBuffer(self, data: buffer, vertexCount: int, bufferDesc: MVertexBufferDescriptor) -> Self: ...  # type: ignore[name-defined]
    def primitiveCount(self, indexDesc: MIndexBufferDescriptor) -> int: ...
    def vertexCount(self) -> int: ...

class MGeometry:
    kInvalidType: ClassVar[int] = ...
    kFloat: ClassVar[int] = ...
    kDouble: ClassVar[int] = ...
    kChar: ClassVar[int] = ...
    kUnsignedChar: ClassVar[int] = ...
    kInt16: ClassVar[int] = ...
    kUnsignedInt16: ClassVar[int] = ...
    kInt32: ClassVar[int] = ...
    kUnsignedInt32: ClassVar[int] = ...
    kInvalidSemantic: ClassVar[int] = ...
    kPosition: ClassVar[int] = ...
    kNormal: ClassVar[int] = ...
    kTexture: ClassVar[int] = ...
    kColor: ClassVar[int] = ...
    kTangent: ClassVar[int] = ...
    kBitangent: ClassVar[int] = ...
    kTangentWithSign: ClassVar[int] = ...
    kInvalidPrimitive: ClassVar[int] = ...
    kPoints: ClassVar[int] = ...
    kLines: ClassVar[int] = ...
    kLineStrip: ClassVar[int] = ...
    kTriangles: ClassVar[int] = ...
    kTriangleStrip: ClassVar[int] = ...
    kAdjacentTriangles: ClassVar[int] = ...
    kAdjacentTriangleStrip: ClassVar[int] = ...
    kAdjacentLines: ClassVar[int] = ...
    kAdjacentLineStrip: ClassVar[int] = ...
    kPatch: ClassVar[int] = ...
    kWireframe: ClassVar[int] = ...
    kShaded: ClassVar[int] = ...
    kTextured: ClassVar[int] = ...
    kBoundingBox: ClassVar[int] = ...
    kSelectionOnly: ClassVar[int] = ...
    kSelectionHighlighting: ClassVar[int] = ...
    kAll: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addIndexBuffer(self, MIndexBuffer: Incomplete) -> bool: ...
    def addVertexBuffer(self, MVertexBuffer: Incomplete) -> bool: ...
    def createIndexBuffer(self, int: int) -> MIndexBuffer: ...
    def createVertexBuffer(self, MVertexBufferDescriptor: Incomplete) -> MVertexBuffer: ...
    @staticmethod
    def dataTypeString(int: int) -> str: ...
    def deleteIndexBuffer(self, int: int) -> bool: ...
    def deleteVertexBuffer(self, int: int) -> bool: ...
    @staticmethod
    def drawModeString(int: int) -> str: ...
    def indexBuffer(self, int: int) -> MIndexBuffer: ...
    def indexBufferCount(self) -> int: ...
    @staticmethod
    def primitiveString(int: int) -> str: ...
    @staticmethod
    def semanticString(int: int) -> str: ...
    def vertexBuffer(self, int: int) -> MVertexBuffer: ...
    def vertexBufferCount(self) -> int: ...

class MVertexBufferDescriptor:
    name: Incomplete
    semantic: Incomplete
    semanticName: Incomplete
    dataType: Incomplete
    dataTypeSize: Incomplete
    dimension: Incomplete
    offset: Incomplete
    stride: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MVertexBufferDescriptorList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, MVertexBufferDescriptor: Incomplete) -> bool: ...
    def clear(self) -> Self: ...
    def remove(self, index: Incomplete) -> bool: ...

class MVertexBuffer:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def acquire(self, size: int, writeOnly: bool) -> float: ...
    def commit(self, long: Incomplete) -> Self: ...
    def descriptor(self) -> MVertexBufferDescriptor: ...
    def hasCustomResourceHandle(self) -> bool: ...
    @overload
    def lockResourceHandle(self) -> Self: ...
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def map(self) -> float: ...
    def resourceHandle(self) -> float: ...
    def setResourceHandle(self, long: Incomplete, int: int) -> Self: ...
    def unload(self) -> Self: ...
    def unlockResourceHandle(self) -> Self: ...
    def unmap(self) -> Self: ...
    def update(self, buffer: long, destOffset: Incomplete, numVerts: int, truncateIfSmaller: bool) -> Self: ...  # type: ignore[name-defined]
    def vertexCount(self) -> int: ...

class MVertexBufferArray:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, MVertexBuffer: Incomplete, name: Incomplete) -> Self: ...
    def clear(self) -> Self: ...
    def getBuffer(self, string: str) -> MVertexBuffer: ...
    def getName(self, int: int) -> str: ...

class MIndexBufferDescriptor:
    kVertexPoint: ClassVar[int] = ...
    kEdgeLine: ClassVar[int] = ...
    kTriangleEdge: ClassVar[int] = ...
    kTriangle: ClassVar[int] = ...
    kFaceCenter: ClassVar[int] = ...
    kEditPoint: ClassVar[int] = ...
    kControlVertex: ClassVar[int] = ...
    kHullEdgeLine: ClassVar[int] = ...
    kHullTriangle: ClassVar[int] = ...
    kHullFaceCenter: ClassVar[int] = ...
    kHullEdgeCenter: ClassVar[int] = ...
    kHullUV: ClassVar[int] = ...
    kSubDivEdge: ClassVar[int] = ...
    kTangent: ClassVar[int] = ...
    kCustom: ClassVar[int] = ...
    name: Incomplete
    indexType: Incomplete
    primitive: Incomplete
    primitiveStride: Incomplete
    component: Incomplete
    dataType: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MIndexBufferDescriptorList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, MIndexBufferDescriptor: Incomplete) -> bool: ...
    def clear(self) -> Self: ...
    def remove(self, index: Incomplete) -> bool: ...

class MIndexBuffer:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def acquire(self, size: int, writeOnly: bool) -> float: ...
    def commit(self, long: Incomplete) -> Self: ...
    def dataType(self) -> int: ...
    def hasCustomResourceHandle(self) -> bool: ...
    @overload
    def lockResourceHandle(self) -> Self: ...
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def lockResourceHandle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def map(self) -> float: ...
    def resourceHandle(self) -> float: ...
    def setResourceHandle(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def size(self) -> int: ...
    def unload(self) -> Self: ...
    def unlockResourceHandle(self) -> Self: ...
    def unmap(self) -> Self: ...
    def update(self, buffer: long, destOffset: Incomplete, numIndices: int, truncateIfSmaller: bool) -> Self: ...  # type: ignore[name-defined]

class MGeometryIndexMapping:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def component(self, int: int) -> MObject: ...
    def dagPath(self, int: int) -> MDagPath: ...
    def geometryCount(self) -> int: ...
    def indexLength(self, int: int) -> int: ...
    def indexStart(self, int: int) -> int: ...

class MRenderItem:  # type: ignore[no-redef]
    sDormantFilledDepthPriority: ClassVar[int] = ...
    sDormantWireDepthPriority: ClassVar[int] = ...
    sHiliteWireDepthPriority: ClassVar[int] = ...
    sActiveWireDepthPriority: ClassVar[int] = ...
    sActiveLineDepthPriority: ClassVar[int] = ...
    sDormantPointDepthPriority: ClassVar[int] = ...
    sActivePointDepthPriority: ClassVar[int] = ...
    sSelectionDepthPriority: ClassVar[int] = ...
    MaterialSceneItem: ClassVar[int] = ...
    NonMaterialSceneItem: ClassVar[int] = ...
    DecorationItem: ClassVar[int] = ...
    InternalItem: ClassVar[int] = ...
    InternalMaterialItem: ClassVar[int] = ...
    InternalTexturedMaterialItem: ClassVar[int] = ...
    InternalUnsupportedMaterialItem: ClassVar[int] = ...
    OverrideNonMaterialItem: ClassVar[int] = ...
    IgnoreDefaultMaterialMode: ClassVar[int] = ...
    DrawOnlyWhenDefaultMaterialActive: ClassVar[int] = ...
    SkipWhenDefaultMaterialActive: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def associateWithIndexBuffer(self, MIndexBuffer: Incomplete) -> bool: ...
    def availableShaderParameters(self) -> listofstring: ...  # type: ignore[name-defined]
    def boundingBox(self, space: Space = ...) -> MBoundingBox: ...  # type: ignore[name-defined]
    def setBoundingBox(self, bounds: MBoundingBox) -> Self: ...
    def castsShadows(self) -> bool: ...
    def wantConsolidation(self) -> bool: ...
    def getDefaultMaterialHandling(self) -> MRenderItem.DefaultMaterialFiltering: ...
    def isCompatibleWithMayaInstancer(self) -> bool: ...
    def component(self) -> MObject: ...
    def shadingComponent(self) -> MObject: ...
    def setAllowIsolateSelectCopy(self, bool: Incomplete) -> Self: ...
    def allowIsolateSelectCopy(self) -> bool: ...
    def isIsolateSelectCopy(self) -> bool: ...
    @overload
    @staticmethod
    def create(name: Incomplete, type: int, primitive: int) -> MRenderItem: ...
    @overload
    @staticmethod
    def create(item: MRenderItem) -> MRenderItem: ...
    def customData(self) -> MUserData: ...
    def getCustomData(self) -> MUserData: ...
    def depthPriority(self) -> int: ...
    @staticmethod
    def destroy(item: Incomplete) -> None: ...
    def drawMode(self) -> int: ...
    def enable(self, bool: Incomplete) -> Self: ...
    def excludedFromPostEffects(self) -> bool: ...
    def excludedFromDefaultMaterialOverride(self) -> bool: ...
    def geometry(self) -> MGeometry: ...
    def getShader(self) -> MShaderInstance: ...
    def getShaderParameters(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def isConsolidated(self) -> bool: ...
    def isEnabled(self) -> bool: ...
    def isShaderFromNode(self) -> bool: ...
    def name(self) -> str: ...
    def primitive(self) -> int: ...
    def primitiveAndStride(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setPrimitive(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def receivesShadows(self) -> bool: ...
    def requiredVertexBuffers(self) -> MVertexBufferDescriptorList: ...
    def selectionMask(self) -> MSelectionMask: ...
    def setCastsShadows(self, bool: Incomplete) -> Self: ...
    def setWantConsolidation(self, bool: Incomplete) -> Self: ...
    def setDefaultMaterialHandling(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setCompatibleWithMayaInstancer(self, bool: Incomplete) -> Self: ...
    def setCustomData(self, MUserData: Incomplete) -> Self: ...
    def setDepthPriority(self, int: int) -> Self: ...
    def setDrawMode(self, int: int) -> Self: ...
    def setExcludedFromPostEffects(self, bool: Incomplete) -> Self: ...
    def setExcludedFromDefaultMaterialOverride(self, bool: Incomplete) -> Self: ...
    def setMatrix(self, MMatrix: Incomplete) -> bool: ...
    def setReceivesShadows(self, bool: Incomplete) -> Self: ...
    def setSelectionMask(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setShader(self, shader: MShaderInstance, customStreamName: str = ...) -> bool: ...
    def setShaderFromNode(self, shaderNode: MObject, shapePath: MDagPath, linkLostCb: callable = ..., linkLostUserData: MUserData = ..., nonTextured: bool = ...) -> Self: ...  # type: ignore[valid-type]
    def setTreatAsTransparent(self, bool: Incomplete) -> Self: ...
    def setWantSubSceneConsolidation(self, bool: Incomplete) -> Self: ...
    def sourceDagPath(self) -> MDagPath: ...
    def sourceIndexMapping(self) -> MGeometryIndexMapping: ...
    def type(self) -> int: ...
    def wantSubSceneConsolidation(self) -> bool: ...
    def objectTypeExclusionFlag(self) -> float: ...
    def setObjectTypeExclusionFlag(self, long: Incomplete) -> Self: ...

class MRenderItemList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, MVertexBufferDescriptor: Incomplete) -> bool: ...
    def clear(self) -> Self: ...
    @overload
    def indexOf(self, name: str) -> int: ...
    @overload
    def indexOf(self, name: str, type: int) -> int: ...
    @overload
    def indexOf(self, name: str, primitive: int, mode: int) -> int: ...
    def remove(self, index: Incomplete) -> bool: ...

class MGeometryRequirements:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addIndexingRequirement(self, MIndexBufferDescriptor: Incomplete) -> Self: ...
    def addVertexRequirement(self, MVertexBufferDescriptor: Incomplete) -> Self: ...
    def indexingRequirements(self) -> MIndexBufferDescriptorList: ...
    def vertexRequirements(self) -> MVertexBufferDescriptorList: ...

class MGeometryUtilities:
    kDefaultSphere: ClassVar[int] = ...
    kDefaultPlane: ClassVar[int] = ...
    kDefaultCube: ClassVar[int] = ...
    kActive: ClassVar[int] = ...
    kLive: ClassVar[int] = ...
    kDormant: ClassVar[int] = ...
    kInvisible: ClassVar[int] = ...
    kHilite: ClassVar[int] = ...
    kTemplate: ClassVar[int] = ...
    kActiveTemplate: ClassVar[int] = ...
    kActiveComponent: ClassVar[int] = ...
    kLead: ClassVar[int] = ...
    kIntermediateObject: ClassVar[int] = ...
    kActiveAffected: ClassVar[int] = ...
    kNoStatus: ClassVar[int] = ...
    @staticmethod
    def acquireReferenceGeometry(shape: int, requirements: MGeometryRequirements) -> MGeometry: ...
    @staticmethod
    def displayStatus(path: MDagPath) -> DisplayStatus: ...  # type: ignore[name-defined]
    @staticmethod
    def releaseReferenceGeometry(geometry: MGeometry) -> None: ...
    @staticmethod
    def wireframeColor(path: MDagPath) -> MColor: ...

class MPxComponentConverter:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addIntersection(self, intersection: MIntersection) -> Self: ...
    def component(self) -> MObject: ...
    def initialize(self, renderItem: MRenderItem) -> Self: ...
    def selectionMask(self) -> MSelectionMask: ...

class MPxDrawOverride:
    def __init__(self, obj: Incomplete, callback: Incomplete, isAlwaysDirty: Incomplete = ...) -> Any: ...  # type: ignore[misc]
    def addUIDrawables(self, objPath: MDagPath, drawManager: MUIDrawManager, frameContext: MFrameContext, data: MUserData) -> Self: ...
    def boundingBox(self, objPath: MDagPath, cameraPath: MDagPath) -> MBoundingBox: ...
    def disableInternalBoundingBoxDraw(self) -> bool: ...
    def excludedFromPostEffects(self) -> bool: ...
    def isTransparent(self) -> bool: ...
    def hasUIDrawables(self) -> bool: ...
    def isBounded(self, objPath: MDagPath, cameraPath: MDagPath) -> bool: ...
    def prepareForDraw(self, objPath: MDagPath, cameraPath: MDagPath, frameContext: MFrameContext, oldData: MUserData) -> MUserData: ...
    def refineSelectionPath(self, selectInfo: MSelectionInfo, hitItem: MRenderItem, path: MDagPath, components: MObject, objectMask: MSelectionMask) -> bool: ...
    def supportedDrawAPIs(self) -> DrawAPI: ...  # type: ignore[name-defined]
    def transform(self, objPath: MDagPath, cameraPath: MDagPath) -> MMatrix: ...
    def wantUserSelection(self) -> bool: ...
    def userSelect(self, selectInfo: MSelectionInfo, drawContext: Incomplete, objPath: MDagPath, data: MUserData, selectionList: MSelectionList, worldSpaceHitPts: MPointArray) -> bool: ...
    def updateSelectionGranularity(self, path: Incomplete, selectionContext: Incomplete) -> Self: ...
    @staticmethod
    def pointSnappingActive() -> bool: ...
    def traceCallSequence(self) -> bool: ...
    def handleTraceMessage(self, message: Incomplete) -> Self: ...

class MPxGeometryOverride:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addUIDrawables(self, path: MDagPath, drawManager: MUIDrawManager, frameContext: MFrameContext) -> Self: ...
    def cleanUp(self) -> Self: ...
    def hasUIDrawables(self) -> bool: ...
    def isIndexingDirty(self, item: MRenderItem) -> bool: ...
    def isStreamDirty(self, desc: MVertexBufferDescriptor) -> bool: ...
    @staticmethod
    def pointSnappingActive() -> bool: ...
    def populateGeometry(self, requirements: MGeometryRequirements, renderItems: MRenderItemList, data: MGeometry) -> Self: ...
    def refineSelectionPath(self, selectInfo: MSelectionInfo, hitItem: MRenderItem, path: MDagPath, components: MObject, objectMask: MSelectionMask) -> bool: ...
    def supportedDrawAPIs(self) -> DrawAPI: ...  # type: ignore[name-defined]
    def configCache(self, evalNode: MEvaluationNode, schema: MCacheSchema) -> None: ...
    def updateDG(self) -> Self: ...
    def updateRenderItems(self, path: MDagPath, list: MRenderItemList) -> Self: ...
    def requiresUpdateRenderItems(self, path: MDagPath) -> bool: ...
    def requiresGeometryUpdate(self) -> bool: ...
    def supportsEvaluationManagerParallelUpdate(self) -> bool: ...
    def supportsVP2CustomCaching(self) -> bool: ...
    def updateSelectionGranularity(self, path: Incomplete, selectionContext: Incomplete) -> Self: ...
    def traceCallSequence(self) -> bool: ...
    def handleTraceMessage(self, message: Incomplete) -> Self: ...
    def getFrameContext(self) -> MFrameContext: ...

class MPxImagePlaneOverride:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def supportedDrawAPIs(self) -> DrawAPI: ...  # type: ignore[name-defined]

class MPxIndexBufferMutator:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def mutateIndexing(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MPxPrimitiveGenerator:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def computeIndexCount(self, object: MObject, component: MObject) -> int: ...
    def generateIndexing(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MInitContext:
    shader: Incomplete
    dagPath: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MInitFeedback:
    customData: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MPxShaderOverride:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def activateKey(self, context: Incomplete, key: Incomplete) -> Self: ...
    def addGeometryRequirement(self, MVertexBufferDescriptor: Incomplete) -> Self: ...
    def addGeometryRequirements(self, MVertexBufferDescriptorList: Incomplete) -> Self: ...
    def addIndexingRequirement(self, MIndexBufferDescriptor: Incomplete) -> Self: ...
    def addShaderSignature(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def boundingBoxExtraScale(self) -> float: ...
    def draw(self, context: MDrawContext, renderItemList: MRenderItemList) -> bool: ...
    def drawGeometry(self, MDrawContext: Incomplete) -> Self: ...
    def endUpdate(self) -> Self: ...
    def handlesConsolidatedGeometry(self) -> bool: ...
    def handlesDraw(self, context: Incomplete) -> bool: ...
    @overload
    def initialize(self, shader: Incomplete) -> str: ...
    @overload
    def initialize(self, initContext: Incomplete, initFeedback: Incomplete) -> str: ...
    def initialize2(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def isTransparent(self) -> bool: ...
    def nonTexturedShaderInstance(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def overridesDrawState(self) -> bool: ...
    def overridesNonMaterialItems(self) -> bool: ...
    def rebuildAlways(self) -> bool: ...
    def setGeometryRequirements(self, MShaderInstance: Incomplete) -> Self: ...
    def shaderInstance(self) -> MShaderInstance: ...
    def supportedDrawAPIs(self) -> DrawAPI: ...  # type: ignore[name-defined]
    def supportsAdvancedTransparency(self) -> bool: ...
    def terminateKey(self, context: Incomplete, key: Incomplete) -> Self: ...
    def updateDG(self, object: Incomplete) -> Self: ...
    def updateDevice(self) -> Self: ...

class MAttributeParameterMapping:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def allowConnection(self) -> bool: ...
    def allowRename(self) -> bool: ...
    def attributeName(self) -> str: ...
    def parameterName(self) -> str: ...
    def resolvedParameterName(self) -> str: ...

class MAttributeParameterMappingList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, MAttributeParameterMapping: Incomplete) -> Self: ...
    def clear(self) -> Self: ...
    def findByAttributeName(self, attributeName: Incomplete) -> MAttributeParameterMapping: ...
    def findByParameterName(self, parameterName: Incomplete) -> MAttributeParameterMapping: ...

class MPxShadingNodeOverride:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def allowConnections(self) -> bool: ...
    def fragmentName(self) -> str: ...
    def getCustomMappings(self, mappings: MAttributeParameterMappingList) -> Self: ...
    def outputForConnection(self, sourcePlug: MPlug, destinationPlug: MPlug) -> str: ...
    def supportedDrawAPIs(self) -> DrawAPI: ...  # type: ignore[name-defined]
    def updateDG(self) -> Self: ...
    @overload
    def updateShader(self, shader: MShaderInstance, mappings: MAttributeParameterMappingList) -> Self: ...
    @overload
    def updateShader(self) -> Any: ...
    def valueChangeRequiresFragmentRebuild(self, plug: MPlug) -> bool: ...

class MSubSceneContainerIterator:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def destroy(self) -> Self: ...
    def next(self) -> MRenderItem: ...
    def reset(self) -> Self: ...

class MSubSceneContainer:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def add(self, item: MRenderItem) -> bool: ...
    def clear(self) -> Self: ...
    def count(self) -> int: ...
    def find(self, name: str) -> MRenderItem: ...
    def getIterator(self) -> MSubSceneContainerIterator: ...
    def remove(self, name: str) -> bool: ...

class MPxSubSceneOverride:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def areUIDrawablesDirty(self) -> bool: ...
    def hasUIDrawables(self) -> bool: ...
    def addUIDrawables(self, drawManager: Incomplete, frameContext: Incomplete) -> int: ...
    def setAllowTransparentInstances(self, renderItem: Incomplete, transform: Incomplete) -> int: ...
    def addInstanceTransform(self, renderItem: MRenderItem, transform: MMatrix) -> int: ...
    def furtherUpdateRequired(self, frameContext: MFrameContext) -> bool: ...
    def getSelectionPath(self, renderItem: MRenderItem, dagPath: MDagPath) -> bool: ...
    def getInstancedSelectionPath(self, renderItem: MRenderItem, intersection: MIntersection, dagPath: MDagPath) -> bool: ...
    @staticmethod
    def pointSnappingActive() -> bool: ...
    def removeAllInstances(self, renderItem: MRenderItem) -> Self: ...
    def removeExtraInstanceData(self, renderItem: MRenderItem, parameterName: str) -> Self: ...
    def removeInstance(self, renderItem: MRenderItem, instanceId: int) -> Self: ...
    def requiresUpdate(self, container: MSubSceneContainer, frameContext: MFrameContext) -> bool: ...
    def setExtraInstanceData(self, renderItem: MRenderItem, parameterName: str, data: MFloatArray, instanceId: int = ...) -> Self: ...
    def setGeometryForRenderItem(self, renderItem: MRenderItem, vertexBuffers: MVertexBufferArray, indexBuffer: MIndexBuffer = ..., objectBox: MBoundingBox = ...) -> Self: ...
    def setInstanceTransformArray(self, renderItem: MRenderItem, matrixArray: MMatrixArray) -> Self: ...
    def supportedDrawAPIs(self) -> DrawAPI: ...  # type: ignore[name-defined]
    def update(self, container: MSubSceneContainer, frameContext: MFrameContext) -> Self: ...
    def updateInstanceTransform(self, renderItem: MRenderItem, instanceId: int, transform: MMatrix) -> Self: ...
    def updateSelectionGranularity(self, path: Incomplete, selectionContext: Incomplete) -> Self: ...

class MPxSurfaceShadingNodeOverride(MPxShadingNodeOverride):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def bumpAttribute(self) -> str: ...
    def primaryColorParameter(self) -> str: ...
    def transparencyParameter(self) -> str: ...

class MPxVertexBufferGenerator:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def createVertexStream(self, object: MObject, vertexBuffer: MVertexBuffer, targetIndexing: MComponentDataIndexing, sharedIndexing: MComponentDataIndexing, sourceStreams: MVertexBufferArray) -> Self: ...
    def getSourceIndexing(self, object: MObject, sourceIndexing: MComponentDataIndexing) -> Self: ...
    def getSourceStreams(self, object: MObject, sourceStreams: Incomplete) -> Self: ...

class MPxVertexBufferMutator:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def modifyVertexStream(self, object: MObject, vertexBuffer: MVertexBuffer, targetIndexing: MComponentDataIndexing) -> Self: ...

class MRenderTargetDescription:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def name(self) -> str: ...
    def width(self) -> int: ...
    def height(self) -> int: ...
    def multiSampleCount(self) -> int: ...
    def rasterFormat(self) -> int: ...
    def arraySliceCount(self) -> int: ...
    def isCubeMap(self) -> bool: ...
    def allowsUnorderedAccess(self) -> bool: ...
    def setName(self, string: str) -> Self: ...
    def setWidth(self, int: int) -> Self: ...
    def setHeight(self, int: int) -> Self: ...
    def setMultiSampleCount(self, int: int) -> Self: ...
    def setRasterFormat(self, int: int) -> Self: ...
    def setArraySliceCount(self, int: int) -> Self: ...
    def setIsCubeMap(self, bool: Incomplete) -> Self: ...
    def setAllowsUnorderedAccess(self, bool: Incomplete) -> Self: ...
    def compatibleWithDescription(self, MRenderTargetDescription: Incomplete) -> bool: ...

class MRenderTarget:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def updateDescription(self, MRenderTargetDescription: Incomplete) -> Self: ...
    def targetDescription(self) -> MRenderTargetDescription: ...
    def resourceHandle(self) -> float: ...
    def rawData(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def freeRawData(long: Incomplete) -> None: ...

class MRenderTargetManager:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def acquireRenderTarget(self, MRenderTargetDescription: Incomplete) -> MRenderTarget: ...
    def acquireRenderTargetFromScreen(self, string: str) -> MRenderTarget: ...
    def formatSupportsSRGBWrite(self, int: int) -> bool: ...
    def releaseRenderTarget(self, MRenderTarget: Incomplete) -> Self: ...

class MRenderProfile:
    kMayaSoftware: ClassVar[int] = ...
    kMayaOpenGL: ClassVar[int] = ...
    kMayaD3D: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addRenderer(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def hasRenderer(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def numberOfRenderers(self) -> int: ...

class MRenderUtilities:
    kPerspectiveCamera: ClassVar[int] = ...
    kOrthogonalCameraWithMargin: ClassVar[int] = ...
    kOrthogonalCameraCloseUp: ClassVar[int] = ...
    kDefaultLights: ClassVar[int] = ...
    kSwatchLight: ClassVar[int] = ...
    kAmbientLight: ClassVar[int] = ...
    @overload
    @staticmethod
    def acquireSwatchDrawContext() -> MDrawContext: ...
    @overload
    @staticmethod
    def acquireSwatchDrawContext(colorTarget: MRenderTarget) -> MDrawContext: ...
    @overload
    @staticmethod
    def acquireSwatchDrawContext(colorTarget: MRenderTarget, depthTarget: MRenderTarget) -> MDrawContext: ...
    @overload
    @staticmethod
    def acquireUVTextureDrawContext() -> MDrawContext: ...
    @overload
    @staticmethod
    def acquireUVTextureDrawContext(colorTarget: MRenderTarget) -> MDrawContext: ...
    @overload
    @staticmethod
    def acquireUVTextureDrawContext(colorTarget: MRenderTarget, depthTarget: MRenderTarget) -> MDrawContext: ...
    @staticmethod
    def blitTargetToGL(target: MRenderTarget, region: None, unfiltered: bool) -> None: ...
    @staticmethod
    def blitTargetToImage(target: MRenderTarget, image: MImage) -> None: ...
    @staticmethod
    def drawSimpleMesh(context: MDrawContext, vertexBuffer: MVertexBuffer, indexBuffer: MIndexBuffer, primitiveType: int, start: int, count: int) -> None: ...
    @overload
    @staticmethod
    def releaseDrawContext(context: MDrawContext) -> None: ...
    @overload
    @staticmethod
    def releaseDrawContext(context: MDrawContext, releaseTargets: bool) -> None: ...
    @staticmethod
    def renderMaterialViewerGeometry(shape: str, shaderNode: MObject, image: MImage, cameraMode: int = ..., lightRig: int = ...) -> None: ...
    @staticmethod
    def swatchBackgroundColor() -> MColor: ...

class MSelectionContext:
    kNone: ClassVar[int] = ...
    kObject: ClassVar[int] = ...
    kComponent: ClassVar[int] = ...
    kFace: ClassVar[int] = ...
    kEdge: ClassVar[int] = ...
    kVertex: ClassVar[int] = ...
    selectionLevel: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MIntersection:
    barycentricCoordinates: Incomplete
    edgeInterpolantValue: Incomplete
    index: Incomplete
    intersectionPoint: Incomplete
    instanceID: Incomplete
    selectionLevel: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MSelectionInfo:
    alignmentMatrix: Incomplete
    isRay: Incomplete
    isSingleSelection: Incomplete
    localRay: Incomplete
    selectClosest: Incomplete
    selectOnHilitedOnly: Incomplete
    selectRect: Incomplete
    cursorPoint: Incomplete
    pointSnapping: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def selectForHilite(self, mask: MSelectionMask) -> bool: ...
    def selectable(self, mask: MSelectionMask) -> bool: ...
    def selectableComponent(self, displayed: bool, mask: MSelectionMask) -> bool: ...

class MShaderCompileMacro:
    name: Incomplete
    definition: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MTextureAssignment:
    texture: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MRenderTargetAssignment:
    target: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MShaderInstance:
    kInvalid: ClassVar[int] = ...
    kBoolean: ClassVar[int] = ...
    kInteger: ClassVar[int] = ...
    kFloat: ClassVar[int] = ...
    kFloat2: ClassVar[int] = ...
    kFloat3: ClassVar[int] = ...
    kFloat4: ClassVar[int] = ...
    kFloat4x4Row: ClassVar[int] = ...
    kFloat4x4Col: ClassVar[int] = ...
    kTexture1: ClassVar[int] = ...
    kTexture2: ClassVar[int] = ...
    kTexture3: ClassVar[int] = ...
    kTextureCube: ClassVar[int] = ...
    kSampler: ClassVar[int] = ...
    kPixelShader: ClassVar[int] = ...
    kNormalShader: ClassVar[int] = ...
    kNormalShader2: ClassVar[int] = ...
    kVertexShader: ClassVar[int] = ...
    kGeometryShader: ClassVar[int] = ...
    kGlossShader: ClassVar[int] = ...
    kGlossShader2: ClassVar[int] = ...
    kRotationAngleShader: ClassVar[int] = ...
    kRotationAngleShader2: ClassVar[int] = ...
    kReflectanceShader: ClassVar[int] = ...
    kReflectanceShader2: ClassVar[int] = ...
    kRoughnessShader: ClassVar[int] = ...
    kRoughnessShader2: ClassVar[int] = ...
    kAnisotropyShader: ClassVar[int] = ...
    kAnisotropyShader2: ClassVar[int] = ...
    kDisplacementPosShader: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def activatePass(self, MDrawContext: Incomplete, int: int) -> Self: ...
    def addInputFragment(self, fragmentName: str, outputName: str, inputName: str, promotedInputName: Incomplete = ...) -> Self: ...
    def addInputFragmentForMultiParams(self, fragmentName: str, uniqueName: str, outputNames: Incomplete, inputNames: Incomplete, invalidParameterIndices: Incomplete = ..., fragmentUsage: int = ...) -> Self: ...
    def addOutputFragment(self, fragmentName: str, inputName: str) -> Self: ...
    def annotation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def bind(self, MDrawContext: Incomplete) -> Self: ...
    def clone(self) -> MShaderInstance: ...
    def createShaderInstanceWithColorManagementFragment(self, inputColorSpace: str) -> MShaderInstance: ...
    def addColorManagementTextures(self) -> Self: ...
    def getPassCount(self, MDrawContext: Incomplete) -> int: ...
    def isArrayParameter(self, string: str) -> bool: ...
    def getArraySize(self, string: str) -> int: ...
    def isTransparent(self) -> bool: ...
    def parameterDefaultValue(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def parameterList(self) -> listofstring: ...  # type: ignore[name-defined]
    def parameterSemantic(self, parameterName: Incomplete) -> str: ...
    def parameterType(self, string: str) -> int: ...
    def passAnnotation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def postDrawCallback(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def preDrawCallback(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def resourceName(self, parameterName: Incomplete) -> str: ...
    def semantic(self, string: str) -> str: ...
    def isVaryingParameter(self, string: str) -> bool: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceofbool: Incomplete, int: int) -> Self: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceofint: Incomplete, int: int) -> Self: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceoffloat: Incomplete, int: int) -> Self: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceofMMatrix: Incomplete, int: int) -> Self: ...
    def setIsTransparent(self, bool: Incomplete) -> Self: ...
    def setAsVarying(self, parameterName: Incomplete, bool: Incomplete) -> Self: ...
    def setSemantic(self, parameterName: Incomplete, string: str) -> Self: ...
    def renameParameter(self, parameterName: Incomplete, string: str) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, bool: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, int: int) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, float: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, listoffloat: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MFloatVector: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MMatrix: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MFloatMatrix: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MTexture: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MRenderTarget: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MSamplerState: Incomplete) -> Self: ...
    def techniqueNames(self) -> listofstrings: ...  # type: ignore[name-defined]
    def techniqueAnnotation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def uiName(self, parameterName: Incomplete) -> str: ...
    def uiWidget(self, parameterName: Incomplete) -> str: ...
    def unbind(self, MDrawContext: Incomplete) -> Self: ...
    def updateParameters(self, MDrawContext: Incomplete) -> Self: ...
    def requiredVertexBuffers(self, MVertexBufferDescriptorList: Incomplete) -> Self: ...
    def writeEffectSourceToFile(self, filePath: Incomplete) -> Self: ...

class MShaderManager:
    k3dSolidShader: ClassVar[int] = ...
    k3dBlinnShader: ClassVar[int] = ...
    k3dDefaultMaterialShader: ClassVar[int] = ...
    k3dSolidTextureShader: ClassVar[int] = ...
    k3dCPVFatPointShader: ClassVar[int] = ...
    k3dColorLookupFatPointShader: ClassVar[int] = ...
    k3dOpacityLookupFatPointShader: ClassVar[int] = ...
    k3dColorOpacityLookupFatPointShader: ClassVar[int] = ...
    k3dShadowerShader: ClassVar[int] = ...
    k3dFatPointShader: ClassVar[int] = ...
    k3dThickLineShader: ClassVar[int] = ...
    k3dCPVThickLineShader: ClassVar[int] = ...
    k3dDashLineShader: ClassVar[int] = ...
    k3dCPVDashLineShader: ClassVar[int] = ...
    k3dStippleShader: ClassVar[int] = ...
    k3dThickDashLineShader: ClassVar[int] = ...
    k3dCPVThickDashLineShader: ClassVar[int] = ...
    k3dDepthShader: ClassVar[int] = ...
    k3dCPVSolidShader: ClassVar[int] = ...
    k3dIntegerNumericShader: ClassVar[int] = ...
    k3dFloatNumericShader: ClassVar[int] = ...
    k3dFloat2NumericShader: ClassVar[int] = ...
    k3dFloat3NumericShader: ClassVar[int] = ...
    k3dPointVectorShader: ClassVar[int] = ...
    k3dPointLightShadowerShader: ClassVar[int] = ...
    k3dStandardSurfaceShader: ClassVar[int] = ...
    k3dIsotropicStandardSurfaceShader: ClassVar[int] = ...
    k3dCPVShader: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addShaderIncludePath(self, string: str) -> Self: ...
    def addShaderPath(self, string: str) -> Self: ...
    def getEffectsBufferShader(self, buffer: Incomplete, size: int, techniqueName: str, macros: Incomplete = ..., useEffectCache: bool = ..., preCb: function = ..., postCb: function = ...) -> MShaderInstance: ...
    def getEffectsFileShader(self, effecsFileName: Incomplete, techniqueName: str, macros: Incomplete = ..., useEffectCache: bool = ..., preCb: function = ..., postCb: function = ...) -> MShaderInstance: ...
    def getEffectsTechniques(self, effecsFileName: Incomplete, macros: Incomplete = ..., useEffectCache: bool = ...) -> tupleofstrings: ...  # type: ignore[name-defined]
    def getFragmentShader(self, fragmentName: str, structOutputName: str, decorateFragment: bool, preCb: function = ..., postCb: function = ...) -> MShaderInstance: ...
    def getShaderFromNode(self, shaderNode: MObject, shapePath: MDagPath, linkLostCb: function = ..., linkLostUserData: MUserData = ..., preCb: function = ..., postCb: function = ..., nonTextured: bool = ...) -> MShaderInstance: ...
    def getStockShader(self, shaderId: int, preCb: function = ..., postCb: function = ...) -> MShaderInstance: ...
    @staticmethod
    def isSupportedShaderSemantic(string: str) -> bool: ...
    def releaseShader(self, MShaderInstance: Incomplete) -> None: ...
    def clearEffectCache(self) -> Self: ...
    def removeEffectFromCache(self, effecsFileName: Incomplete, techniqueName: str, macros: Incomplete = ...) -> Self: ...
    def shaderIncludePaths(self) -> listofstrings: ...  # type: ignore[name-defined]
    def shaderPaths(self) -> listofstrings: ...  # type: ignore[name-defined]
    @staticmethod
    def getLastError() -> str: ...
    @staticmethod
    def getLastErrorSource(displayLineNumber: bool = ..., filterSource: s = ..., numSurroundingLines: int = ...) -> str: ...  # type: ignore[name-defined]

class MStateManager:
    kCompareNever: ClassVar[int] = ...
    kCompareLess: ClassVar[int] = ...
    kCompareEqual: ClassVar[int] = ...
    kCompareLessEqual: ClassVar[int] = ...
    kCompareGreater: ClassVar[int] = ...
    kCompareNotEqual: ClassVar[int] = ...
    kCompareGreaterEqual: ClassVar[int] = ...
    kCompareAlways: ClassVar[int] = ...
    kNoShader: ClassVar[int] = ...
    kVertexShader: ClassVar[int] = ...
    kGeometryShader: ClassVar[int] = ...
    kPixelShader: ClassVar[int] = ...
    kHullShader: ClassVar[int] = ...
    kDomainShader: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def acquireBlendState(MBlendStateDesc: Incomplete) -> MBlendState: ...
    @staticmethod
    def releaseBlendState(MBlendState: Incomplete) -> None: ...
    def setBlendState(self, MBlendState: Incomplete) -> Self: ...
    def getBlendState(self) -> MBlendState: ...
    @staticmethod
    def acquireRasterizerState(MRasterizerStateDesc: Incomplete) -> MRasterizerState: ...
    @staticmethod
    def releaseRasterizerState(MRasterizerState: Incomplete) -> None: ...
    def setRasterizerState(self, MRasterizerState: Incomplete) -> Self: ...
    def getRasterizerState(self) -> MRasterizerState: ...
    @staticmethod
    def acquireDepthStencilState(MDepthStencilStateDesc: Incomplete) -> MDepthStencilState: ...
    @staticmethod
    def releaseDepthStencilState(MDepthStencilState: Incomplete) -> None: ...
    def setDepthStencilState(self, MDepthStencilState: Incomplete) -> Self: ...
    def getDepthStencilState(self) -> MDepthStencilState: ...
    @staticmethod
    def acquireSamplerState(MSamplerStateDesc: Incomplete) -> MSamplerState: ...
    @staticmethod
    def releaseSamplerState(MSamplerState: Incomplete) -> None: ...
    def setSamplerState(self, shader: ShaderType, samplerIndex: int, samplerState: MSamplerState) -> Self: ...  # type: ignore[name-defined]
    def getSamplerState(self, shader: ShaderType, samplerIndex: int) -> MSamplerState: ...  # type: ignore[name-defined]
    @staticmethod
    def getMaxSamplerCount() -> int: ...

class MBlendState:
    kAdd: ClassVar[int] = ...
    kSubtract: ClassVar[int] = ...
    kReverseSubtract: ClassVar[int] = ...
    kMin: ClassVar[int] = ...
    kMax: ClassVar[int] = ...
    kZero: ClassVar[int] = ...
    kOne: ClassVar[int] = ...
    kSourceColor: ClassVar[int] = ...
    kInvSourceColor: ClassVar[int] = ...
    kSourceAlpha: ClassVar[int] = ...
    kInvSourceAlpha: ClassVar[int] = ...
    kSourceAlphaSat: ClassVar[int] = ...
    kDestinationColor: ClassVar[int] = ...
    kInvDestinationColor: ClassVar[int] = ...
    kDestinationAlpha: ClassVar[int] = ...
    kInvDestinationAlpha: ClassVar[int] = ...
    kBothSourceAlpha: ClassVar[int] = ...
    kBothInvSourceAlpha: ClassVar[int] = ...
    kBlendFactor: ClassVar[int] = ...
    kInvBlendFactor: ClassVar[int] = ...
    kNoChannels: ClassVar[int] = ...
    kRedChannel: ClassVar[int] = ...
    kGreenChannel: ClassVar[int] = ...
    kBlueChannel: ClassVar[int] = ...
    kAlphaChannel: ClassVar[int] = ...
    kRGBChannels: ClassVar[int] = ...
    kRGBAChannels: ClassVar[int] = ...
    kMaxTargets: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def desc(self) -> MBlendStateDesc: ...
    def resourceHandle(self) -> float: ...

class MTargetBlendDesc:
    blendEnable: Incomplete
    sourceBlend: Incomplete
    destinationBlend: Incomplete
    blendOperation: Incomplete
    alphaSourceBlend: Incomplete
    alphaDestinationBlend: Incomplete
    alphaBlendOperation: Incomplete
    targetWriteMask: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setDefaults(self) -> Self: ...

class MBlendStateDesc:
    alphaToCoverageEnable: Incomplete
    independentBlendEnable: Incomplete
    blendFactor: Incomplete
    multiSampleMask: Incomplete
    targetBlends: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setDefaults(self) -> Self: ...

class MRasterizerState:
    kFillSolid: ClassVar[int] = ...
    kFillWireFrame: ClassVar[int] = ...
    kCullNone: ClassVar[int] = ...
    kCullFront: ClassVar[int] = ...
    kCullBack: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def desc(self) -> MRasterizerStateDesc: ...
    def resourceHandle(self) -> float: ...

class MRasterizerStateDesc:
    fillMode: Incomplete
    cullMode: Incomplete
    frontCounterClockwise: Incomplete
    depthBiasIsFloat: Incomplete
    depthBias: Incomplete
    depthBiasClamp: Incomplete
    slopeScaledDepthBias: Incomplete
    depthClipEnable: Incomplete
    scissorEnable: Incomplete
    multiSampleEnable: Incomplete
    antialiasedLineEnable: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setDefaults(self) -> Self: ...

class MDepthStencilState:
    kKeepStencil: ClassVar[int] = ...
    kZeroStencil: ClassVar[int] = ...
    kReplaceStencil: ClassVar[int] = ...
    kIncrementStencilSat: ClassVar[int] = ...
    kDecrementStencilSat: ClassVar[int] = ...
    kInvertStencil: ClassVar[int] = ...
    kIncrementStencil: ClassVar[int] = ...
    kDecrementStencil: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def desc(self) -> MDepthStencilStateDesc: ...
    def resourceHandle(self) -> float: ...

class MStencilOpDesc:
    stencilPassOp: Incomplete
    stencilFailOp: Incomplete
    stencilDepthFailOp: Incomplete
    stencilFunc: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setDefaults(self) -> Self: ...

class MDepthStencilStateDesc:
    depthEnable: Incomplete
    depthWriteEnable: Incomplete
    depthFunc: Incomplete
    stencilEnable: Incomplete
    stencilReadMask: Incomplete
    stencilWriteMask: Incomplete
    stencilReferenceVal: Incomplete
    frontFace: Incomplete
    backFace: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setDefaults(self) -> Self: ...

class MSamplerState:
    kMinMagMipPoint: ClassVar[int] = ...
    kMinMagPoint_MipLinear: ClassVar[int] = ...
    kMinPoint_MagLinear_MipPoint: ClassVar[int] = ...
    kMinPoint_MagMipLinear: ClassVar[int] = ...
    kMinLinear_MagMipPoint: ClassVar[int] = ...
    kMinLinear_MagPoint_MipLinear: ClassVar[int] = ...
    kMinMagLinear_MipPoint: ClassVar[int] = ...
    kMinMagMipLinear: ClassVar[int] = ...
    kAnisotropic: ClassVar[int] = ...
    kTexWrap: ClassVar[int] = ...
    kTexMirror: ClassVar[int] = ...
    kTexClamp: ClassVar[int] = ...
    kTexBorder: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def desc(self) -> MSamplerStateDesc: ...
    def resourceHandle(self) -> float: ...

class MSamplerStateDesc:
    filter: Incomplete
    comparisonFn: Incomplete
    addressU: Incomplete
    addressV: Incomplete
    addressW: Incomplete
    borderColor: Incomplete
    mipLODBias: Incomplete
    minLOD: Incomplete
    maxLOD: Incomplete
    maxAnisotropy: Incomplete
    coordCount: Incomplete
    elementIndex: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setDefaults(self) -> Self: ...

class MSwatchRenderBase:
    renderQuality: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def cancelCurrentSwatchRender() -> None: ...
    def cancelParallelRendering(self) -> Self: ...
    def doIteration(self) -> bool: ...
    def finishParallelRender(self) -> Self: ...
    def image(self) -> MImage: ...
    def node(self) -> MObject: ...
    def renderParallel(self) -> bool: ...
    def resolution(self) -> int: ...
    def swatchNode(self) -> MObject: ...

class MTextureDescription:
    kImage1D: ClassVar[int] = ...
    kImage1DArray: ClassVar[int] = ...
    kImage2D: ClassVar[int] = ...
    kImage2DArray: ClassVar[int] = ...
    kCubeMap: ClassVar[int] = ...
    kVolumeTexture: ClassVar[int] = ...
    kDepthTexture: ClassVar[int] = ...
    kNumberOfTextureTypes: ClassVar[int] = ...
    kEnvNone: ClassVar[int] = ...
    kEnvSphere: ClassVar[int] = ...
    kEnvHemiSphere: ClassVar[int] = ...
    kEnvLatLong: ClassVar[int] = ...
    kEnvCrossVert: ClassVar[int] = ...
    kEnvCrossHoriz: ClassVar[int] = ...
    kEnvCubemap: ClassVar[int] = ...
    kNumberOfEnvMapTypes: ClassVar[int] = ...
    fWidth: Incomplete
    fHeight: Incomplete
    fDepth: Incomplete
    fBytesPerRow: Incomplete
    fBytesPerSlice: Incomplete
    fMipmaps: Incomplete
    fArraySlices: Incomplete
    fFormat: Incomplete
    fTextureType: Incomplete
    fEnvMapType: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def setToDefault2DTexture(self) -> Self: ...

class MDepthNormalizationDescription:
    fNearClipDistance: Incomplete
    fFarClipDistance: Incomplete
    fDepthScale: Incomplete
    fDepthBias: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MTextureUpdateRegion:
    fXRangeMin: Incomplete
    fXRangeMax: Incomplete
    fYRangeMin: Incomplete
    fYRangeMax: Incomplete
    fZRangeMin: Incomplete
    fZRangeMax: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MTexture:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def hasAlpha(self) -> bool: ...
    def setHasAlpha(self, bool: Incomplete) -> Self: ...
    def hasZeroAlpha(self) -> bool: ...
    def setHasZeroAlpha(self, bool: Incomplete) -> Self: ...
    def hasTransparentAlpha(self) -> bool: ...
    def setHasTransparentAlpha(self, bool: Incomplete) -> Self: ...
    def resourceHandle(self) -> float: ...
    def name(self) -> str: ...
    def bytesPerPixel(self) -> int: ...
    def textureDescription(self) -> MTextureDescription: ...
    def rawData(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def freeRawData(long: Incomplete) -> None: ...
    def update(self, pixelData: Incomplete, generateMipMaps: bool, rowPitch: int = ..., region: MTextureUpdateRegion = ...) -> Self: ...

class MTextureManager:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addImagePath(self, string: str) -> Self: ...
    def imagePaths(self) -> listofstrings: ...  # type: ignore[name-defined]
    @overload
    def acquireTexture(self, filePath: str, mipmapLevels: Incomplete = ..., layerName: str = ..., alphaChannelIdx: int = ...) -> MTexture: ...
    @overload
    def acquireTexture(self, filePath: Incomplete, contextNodeFullName: Incomplete, mipmapLevels: Incomplete = ..., layerName: Incomplete = ..., alphaChannelIdx: Incomplete = ...) -> MTexture: ...
    @overload
    def acquireTexture(self, textureName: str, plug: Incomplete, width: Incomplete, height: Incomplete, generateMipMaps: bool = ...) -> MTexture: ...
    @overload
    def acquireTexture(self, textureName: Incomplete, textureDesc: Incomplete, pixelData: Incomplete, generateMipMaps: Incomplete = ...) -> MTexture: ...
    def acquireTiledTexture(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @overload
    def acquireDepthTexture(self, textureName: str, image: MImage, generateMipMaps: bool = ..., normalizationDesc: MDepthNormalizationDescription = ...) -> MTexture: ...
    @overload
    def acquireDepthTexture(self, textureName: str, pixelData: Incomplete, width: int, height: int, generateMipMaps: bool = ..., normalizationDesc: MDepthNormalizationDescription = ...) -> MTexture: ...
    def releaseTexture(self, MTexture: Incomplete) -> Self: ...
    def saveTexture(self, MTexture: Incomplete, string: str) -> Self: ...

class MUniformParameter:
    kTypeUnknown: ClassVar[int] = ...
    kTypeBool: ClassVar[int] = ...
    kTypeInt: ClassVar[int] = ...
    kTypeFloat: ClassVar[int] = ...
    kType1DTexture: ClassVar[int] = ...
    kType2DTexture: ClassVar[int] = ...
    kType3DTexture: ClassVar[int] = ...
    kTypeCubeTexture: ClassVar[int] = ...
    kTypeEnvTexture: ClassVar[int] = ...
    kTypeString: ClassVar[int] = ...
    kTypeEnum: ClassVar[int] = ...
    kSemanticUnknown: ClassVar[int] = ...
    kSemanticObjectDir: ClassVar[int] = ...
    kSemanticWorldDir: ClassVar[int] = ...
    kSemanticViewDir: ClassVar[int] = ...
    kSemanticProjectionDir: ClassVar[int] = ...
    kSemanticObjectPos: ClassVar[int] = ...
    kSemanticWorldPos: ClassVar[int] = ...
    kSemanticViewPos: ClassVar[int] = ...
    kSemanticProjectionPos: ClassVar[int] = ...
    kSemanticColor: ClassVar[int] = ...
    kSemanticNormal: ClassVar[int] = ...
    kSemanticBump: ClassVar[int] = ...
    kSemanticEnvironment: ClassVar[int] = ...
    kSemanticWorldMatrix: ClassVar[int] = ...
    kSemanticWorldInverseMatrix: ClassVar[int] = ...
    kSemanticWorldInverseTransposeMatrix: ClassVar[int] = ...
    kSemanticViewMatrix: ClassVar[int] = ...
    kSemanticViewInverseMatrix: ClassVar[int] = ...
    kSemanticViewInverseTransposeMatrix: ClassVar[int] = ...
    kSemanticProjectionMatrix: ClassVar[int] = ...
    kSemanticProjectionInverseMatrix: ClassVar[int] = ...
    kSemanticProjectionInverseTransposeMatrix: ClassVar[int] = ...
    kSemanticWorldViewMatrix: ClassVar[int] = ...
    kSemanticWorldViewInverseMatrix: ClassVar[int] = ...
    kSemanticWorldViewInverseTransposeMatrix: ClassVar[int] = ...
    kSemanticWorldViewProjectionMatrix: ClassVar[int] = ...
    kSemanticWorldViewProjectionInverseMatrix: ClassVar[int] = ...
    kSemanticWorldViewProjectionInverseTransposeMatrix: ClassVar[int] = ...
    kSemanticColorTexture: ClassVar[int] = ...
    kSemanticNormalTexture: ClassVar[int] = ...
    kSemanticBumpTexture: ClassVar[int] = ...
    kSemanticNormalizationTexture: ClassVar[int] = ...
    kSemanticTranspDepthTexture: ClassVar[int] = ...
    kSemanticOpaqueDepthTexture: ClassVar[int] = ...
    kSemanticTime: ClassVar[int] = ...
    kSemanticWorldTransposeMatrix: ClassVar[int] = ...
    kSemanticViewTransposeMatrix: ClassVar[int] = ...
    kSemanticProjectionTransposeMatrix: ClassVar[int] = ...
    kSemanticWorldViewTransposeMatrix: ClassVar[int] = ...
    kSemanticWorldViewProjectionTransposeMatrix: ClassVar[int] = ...
    kSemanticViewProjectionMatrix: ClassVar[int] = ...
    kSemanticViewProjectionInverseMatrix: ClassVar[int] = ...
    kSemanticViewProjectionTransposeMatrix: ClassVar[int] = ...
    kSemanticViewProjectionInverseTransposeMatrix: ClassVar[int] = ...
    kSemanticLocalViewer: ClassVar[int] = ...
    kSemanticViewportPixelSize: ClassVar[int] = ...
    kSemanticBackgroundColor: ClassVar[int] = ...
    kSemanticFrameNumber: ClassVar[int] = ...
    kSemanticNearClipPlane: ClassVar[int] = ...
    kSemanticFarClipPlane: ClassVar[int] = ...
    kSemanticHWSPrimitiveBase: ClassVar[int] = ...
    kSemanticHWSPrimitiveCountPerInstance: ClassVar[int] = ...
    kSemanticHWSObjectLevel: ClassVar[int] = ...
    kSemanticHWSFaceLevel: ClassVar[int] = ...
    kSemanticHWSEdgeLevel: ClassVar[int] = ...
    kSemanticHWSVertexLevel: ClassVar[int] = ...
    kSemanticHWSOccluder: ClassVar[int] = ...
    kSemanticHWSFrontCCW: ClassVar[int] = ...
    kSemanticHWSInstancedDraw: ClassVar[int] = ...
    kSemanticHWSHighlighting: ClassVar[int] = ...
    uiHidden: Incomplete
    keyable: Incomplete
    rangeMin: Incomplete
    rangeMax: Incomplete
    softRangeMin: Incomplete
    softRangeMax: Incomplete
    enumFieldNames: Incomplete
    uiNiceName: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def asBool(self, context: MDrawContext) -> bool: ...
    def asFloat(self, context: MDrawContext) -> float: ...
    def asFloatArray(self, context: MDrawContext) -> tupleoffloats: ...  # type: ignore[name-defined]
    def asInt(self, context: MDrawContext) -> int: ...
    def asString(self, context: MDrawContext) -> str: ...
    def copy(self, source: MUniformParameter) -> Self: ...
    def hasChanged(self, context: MDrawContext) -> bool: ...
    def isATexture(self) -> bool: ...
    def name(self) -> str: ...
    def numColumns(self) -> int: ...
    def numElements(self) -> int: ...
    def numRows(self) -> int: ...
    def plug(self) -> MPlug: ...
    def semantic(self) -> int: ...
    def setBool(self, value: bool) -> Self: ...
    def setDirty(self) -> Self: ...
    def setFloat(self, value: float) -> Self: ...
    def setFloatArray(self, value: s) -> Self: ...  # type: ignore[name-defined]
    def setInt(self, value: int) -> Self: ...
    def setString(self, value: str) -> Self: ...
    def source(self) -> MPlug: ...
    def type(self) -> int: ...
    def userData(self) -> int: ...

class MUniformParameterList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, element: MUniformParameter) -> bool: ...
    def copy(self, source: MUniformParameterList) -> Self: ...
    def setElement(self, n: int, element: MUniformParameter) -> bool: ...
    def setLength(self, length: int) -> bool: ...

class MVaryingParameter:
    kInvalidParameter: ClassVar[int] = ...
    kStructure: ClassVar[int] = ...
    kFloat: ClassVar[int] = ...
    kDouble: ClassVar[int] = ...
    kChar: ClassVar[int] = ...
    kUnsignedChar: ClassVar[int] = ...
    kInt16: ClassVar[int] = ...
    kUnsignedInt16: ClassVar[int] = ...
    kInt32: ClassVar[int] = ...
    kUnsignedInt32: ClassVar[int] = ...
    kNoSemantic: ClassVar[int] = ...
    kPosition: ClassVar[int] = ...
    kNormal: ClassVar[int] = ...
    kTexCoord: ClassVar[int] = ...
    kColor: ClassVar[int] = ...
    kWeight: ClassVar[int] = ...
    kTangent: ClassVar[int] = ...
    kBinormal: ClassVar[int] = ...
    def __init__(self) -> Any: ...  # type: ignore[misc]
    def addElement(self, child: MVaryingParameter) -> Self: ...
    def copy(self, source: MVaryingParameter) -> Self: ...
    def destinationSetName(self) -> str: ...
    def dimension(self) -> int: ...
    def elementSize(self) -> int: ...
    def getElement(self, index: int) -> MVaryingParameter: ...
    def maximumStride(self) -> int: ...
    def name(self) -> str: ...
    def numElements(self) -> int: ...
    def removeElements(self) -> Self: ...
    def semantic(self) -> int: ...
    def semanticName(self) -> str: ...
    def setSource(self, semantic: Incomplete, name: str) -> Self: ...
    def sourceSetName(self) -> str: ...
    def sourceSemantic(self) -> int: ...
    def type(self) -> int: ...
    def updateId(self) -> int: ...

class MVaryingParameterList:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, element: MVaryingParameter) -> bool: ...
    def copy(self, source: MVaryingParameterList) -> Self: ...
    def setElement(self, n: int, element: MVaryingParameter) -> bool: ...
    def setLength(self, length: int) -> bool: ...

class MRenderer:
    kNone: ClassVar[int] = ...
    kOpenGL: ClassVar[int] = ...
    kDirectX11: ClassVar[int] = ...
    kOpenGLCoreProfile: ClassVar[int] = ...
    kAllDevices: ClassVar[int] = ...
    kD24S8: ClassVar[int] = ...
    kD24X8: ClassVar[int] = ...
    kD32_FLOAT: ClassVar[int] = ...
    kR24G8: ClassVar[int] = ...
    kR24X8: ClassVar[int] = ...
    kDXT1_UNORM: ClassVar[int] = ...
    kDXT1_UNORM_SRGB: ClassVar[int] = ...
    kDXT2_UNORM: ClassVar[int] = ...
    kDXT2_UNORM_SRGB: ClassVar[int] = ...
    kDXT2_UNORM_PREALPHA: ClassVar[int] = ...
    kDXT3_UNORM: ClassVar[int] = ...
    kDXT3_UNORM_SRGB: ClassVar[int] = ...
    kDXT3_UNORM_PREALPHA: ClassVar[int] = ...
    kDXT4_UNORM: ClassVar[int] = ...
    kDXT4_SNORM: ClassVar[int] = ...
    kDXT5_UNORM: ClassVar[int] = ...
    kDXT5_SNORM: ClassVar[int] = ...
    kBC6H_UF16: ClassVar[int] = ...
    kBC6H_SF16: ClassVar[int] = ...
    kBC7_UNORM: ClassVar[int] = ...
    kBC7_UNORM_SRGB: ClassVar[int] = ...
    kR9G9B9E5_FLOAT: ClassVar[int] = ...
    kR1_UNORM: ClassVar[int] = ...
    kA8: ClassVar[int] = ...
    kR8_UNORM: ClassVar[int] = ...
    kR8_SNORM: ClassVar[int] = ...
    kR8_UINT: ClassVar[int] = ...
    kR8_SINT: ClassVar[int] = ...
    kL8: ClassVar[int] = ...
    kR16_FLOAT: ClassVar[int] = ...
    kR16_UNORM: ClassVar[int] = ...
    kR16_SNORM: ClassVar[int] = ...
    kR16_UINT: ClassVar[int] = ...
    kR16_SINT: ClassVar[int] = ...
    kL16: ClassVar[int] = ...
    kR8G8_UNORM: ClassVar[int] = ...
    kR8G8_SNORM: ClassVar[int] = ...
    kR8G8_UINT: ClassVar[int] = ...
    kR8G8_SINT: ClassVar[int] = ...
    kB5G5R5A1: ClassVar[int] = ...
    kB5G6R5: ClassVar[int] = ...
    kR32_FLOAT: ClassVar[int] = ...
    kR32_UINT: ClassVar[int] = ...
    kR32_SINT: ClassVar[int] = ...
    kR16G16_FLOAT: ClassVar[int] = ...
    kR16G16_UNORM: ClassVar[int] = ...
    kR16G16_SNORM: ClassVar[int] = ...
    kR16G16_UINT: ClassVar[int] = ...
    kR16G16_SINT: ClassVar[int] = ...
    kR8G8B8A8_UNORM: ClassVar[int] = ...
    kR8G8B8A8_SNORM: ClassVar[int] = ...
    kR8G8B8A8_UINT: ClassVar[int] = ...
    kR8G8B8A8_SINT: ClassVar[int] = ...
    kR10G10B10A2_UNORM: ClassVar[int] = ...
    kR10G10B10A2_UINT: ClassVar[int] = ...
    kB8G8R8A8: ClassVar[int] = ...
    kB8G8R8X8: ClassVar[int] = ...
    kR8G8B8X8: ClassVar[int] = ...
    kA8B8G8R8: ClassVar[int] = ...
    kR32G32_FLOAT: ClassVar[int] = ...
    kR32G32_UINT: ClassVar[int] = ...
    kR32G32_SINT: ClassVar[int] = ...
    kR16G16B16A16_FLOAT: ClassVar[int] = ...
    kR16G16B16A16_UNORM: ClassVar[int] = ...
    kR16G16B16A16_SNORM: ClassVar[int] = ...
    kR16G16B16A16_UINT: ClassVar[int] = ...
    kR16G16B16A16_SINT: ClassVar[int] = ...
    kR32G32B32_FLOAT: ClassVar[int] = ...
    kR32G32B32_UINT: ClassVar[int] = ...
    kR32G32B32_SINT: ClassVar[int] = ...
    kR32G32B32A32_FLOAT: ClassVar[int] = ...
    kR32G32B32A32_UINT: ClassVar[int] = ...
    kR32G32B32A32_SINT: ClassVar[int] = ...
    kNumberOfRasterFormats: ClassVar[int] = ...
    @staticmethod
    def GPUDeviceHandle() -> float: ...
    @staticmethod
    def GPUmaximumPrimitiveCount() -> int: ...
    @staticmethod
    def GPUmaximumVertexBufferSize() -> int: ...
    @staticmethod
    def activeRenderOverride() -> str: ...
    @staticmethod
    def copyTargetToScreen(MRenderTarget: Incomplete) -> bool: ...
    @staticmethod
    def render(sourceName: str, targetList: Incomplete) -> bool: ...
    @staticmethod
    def deregisterOverride(MRenderOverride: Incomplete) -> None: ...
    @staticmethod
    def disableChangeManagementUntilNextRefresh() -> None: ...
    @staticmethod
    def drawAPI() -> int: ...
    @staticmethod
    def drawAPIIsOpenGL() -> bool: ...
    @staticmethod
    def drawAPIVersion() -> int: ...
    @staticmethod
    def findRenderOverride(string: str) -> MRenderOverride: ...
    @staticmethod
    def getFragmentManager() -> MFragmentManager: ...
    @staticmethod
    def getRenderTargetManager() -> MRenderTargetManager: ...
    @staticmethod
    def getShaderManager() -> MShaderManager: ...
    @staticmethod
    def getTextureManager() -> MTextureManager: ...
    @staticmethod
    def outputTargetSize(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def registerOverride(MRenderOverride: Incomplete) -> None: ...
    @staticmethod
    def renderOverrideCount() -> int: ...
    @staticmethod
    def renderOverrideName() -> str: ...
    @staticmethod
    def setGeometryDrawDirty(object: MObject, topologyChanged: bool = ...) -> None: ...
    @staticmethod
    def setLightRequiresShadows(object: MObject, flag: bool) -> bool: ...
    @staticmethod
    def needEvaluateAllLights() -> None: ...
    @staticmethod
    def setLightsAndShadowsDirty() -> None: ...
    @staticmethod
    def setRenderOverrideName(string: str) -> bool: ...

class MCameraOverride:
    mCameraPath: Incomplete
    mUseHiddenCameraList: Incomplete
    mHiddenCameraList: Incomplete
    mUseProjectionMatrix: Incomplete
    mProjectionMatrix: Incomplete
    mUseViewMatrix: Incomplete
    mViewMatrix: Incomplete
    mUseNearClippingPlane: Incomplete
    mNearClippingPlane: Incomplete
    mUseFarClippingPlane: Incomplete
    mFarClippingPlane: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MRenderOperation:
    kClear: ClassVar[int] = ...
    kSceneRender: ClassVar[int] = ...
    kQuadRender: ClassVar[int] = ...
    kUserDefined: ClassVar[int] = ...
    kDataServer: ClassVar[int] = ...
    kHUDRender: ClassVar[int] = ...
    kPresentTarget: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def enableSRGBWrite(self) -> bool: ...
    def name(self) -> str: ...
    def operationType(self) -> int: ...
    def targetOverrideList(self) -> listofMRenderTarget: ...  # type: ignore[name-defined]
    def viewportRectangleOverride(self) -> MFloatPoint: ...

class MUserRenderOperation(MRenderOperation):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addUIDrawables(self, drawManager: MUIDrawManager, frameContext: MFrameContext) -> Self: ...
    def cameraOverride(self) -> MCameraOverride: ...
    def hasUIDrawables(self) -> bool: ...
    def requiresLightData(self) -> bool: ...
    def requiresResetDeviceStates(self) -> bool: ...

class MHUDRender(MRenderOperation):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addUIDrawables(self, drawManager2D: tuple[0, 0], frameContext: MFrameContext) -> Self: ...  # type: ignore[valid-type]
    def hasUIDrawables(self) -> bool: ...
    def name(self) -> str: ...

class MPresentTarget(MRenderOperation):
    kCenterBuffer: ClassVar[int] = ...
    kLeftBuffer: ClassVar[int] = ...
    kRightBuffer: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def presentDepth(self) -> bool: ...
    def setPresentDepth(self, bool: Incomplete) -> Self: ...
    def setTargetBackBuffer(self, int: int) -> Self: ...
    def targetBackBuffer(self) -> int: ...

class MClearOperation(MRenderOperation):
    kClearNone: ClassVar[int] = ...
    kClearColor: ClassVar[int] = ...
    kClearDepth: ClassVar[int] = ...
    kClearStencil: ClassVar[int] = ...
    kClearAll: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def clearColor(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def clearColor2(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def clearDepth(self) -> float: ...
    def clearGradient(self) -> bool: ...
    def clearStencil(self) -> int: ...
    def mask(self) -> int: ...
    def overridesColors(self) -> bool: ...
    def setClearColor(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setClearColor2(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setClearDepth(self, float: Incomplete) -> Self: ...
    def setClearGradient(self, bool: Incomplete) -> Self: ...
    def setClearStencil(self, int: int) -> Self: ...
    def setMask(self, int: int) -> Self: ...
    def setOverridesColors(self, bool: Incomplete) -> Self: ...

class MSceneRender(MRenderOperation):
    kExcludeNone: ClassVar[int] = ...
    kExcludeNurbsCurves: ClassVar[int] = ...
    kExcludeNurbsSurfaces: ClassVar[int] = ...
    kExcludeMeshes: ClassVar[int] = ...
    kExcludePlanes: ClassVar[int] = ...
    kExcludeLights: ClassVar[int] = ...
    kExcludeCameras: ClassVar[int] = ...
    kExcludeJoints: ClassVar[int] = ...
    kExcludeIkHandles: ClassVar[int] = ...
    kExcludeDeformers: ClassVar[int] = ...
    kExcludeDynamics: ClassVar[int] = ...
    kExcludeParticleInstancers: ClassVar[int] = ...
    kExcludeLocators: ClassVar[int] = ...
    kExcludeDimensions: ClassVar[int] = ...
    kExcludeSelectHandles: ClassVar[int] = ...
    kExcludePivots: ClassVar[int] = ...
    kExcludeTextures: ClassVar[int] = ...
    kExcludeGrid: ClassVar[int] = ...
    kExcludeCVs: ClassVar[int] = ...
    kExcludeHulls: ClassVar[int] = ...
    kExcludeStrokes: ClassVar[int] = ...
    kExcludeSubdivSurfaces: ClassVar[int] = ...
    kExcludeFluids: ClassVar[int] = ...
    kExcludeFollicles: ClassVar[int] = ...
    kExcludeHairSystems: ClassVar[int] = ...
    kExcludeImagePlane: ClassVar[int] = ...
    kExcludeNCloths: ClassVar[int] = ...
    kExcludeNRigids: ClassVar[int] = ...
    kExcludeDynamicConstraints: ClassVar[int] = ...
    kExcludeManipulators: ClassVar[int] = ...
    kExcludeNParticles: ClassVar[int] = ...
    kExcludeMotionTrails: ClassVar[int] = ...
    kExcludeHoldOuts: ClassVar[int] = ...
    kExcludeAll: ClassVar[int] = ...
    kNoSceneFilterOverride: ClassVar[int] = ...
    kRenderPreSceneUIItems: ClassVar[int] = ...
    kRenderOpaqueShadedItems: ClassVar[int] = ...
    kRenderTransparentShadedItems: ClassVar[int] = ...
    kRenderShadedItems: ClassVar[int] = ...
    kRenderPostSceneUIItems: ClassVar[int] = ...
    kRenderUIItems: ClassVar[int] = ...
    kRenderNonShadedItems: ClassVar[int] = ...
    kRenderAllItems: ClassVar[int] = ...
    kNoDisplayModeOverride: ClassVar[int] = ...
    kWireFrame: ClassVar[int] = ...
    kShaded: ClassVar[int] = ...
    kFlatShaded: ClassVar[int] = ...
    kShadeActiveOnly: ClassVar[int] = ...
    kBoundingBox: ClassVar[int] = ...
    kDefaultMaterial: ClassVar[int] = ...
    kTextured: ClassVar[int] = ...
    kNoLightingModeOverride: ClassVar[int] = ...
    kNoLight: ClassVar[int] = ...
    kAmbientLight: ClassVar[int] = ...
    kLightDefault: ClassVar[int] = ...
    kSelectedLights: ClassVar[int] = ...
    kSceneLights: ClassVar[int] = ...
    kPostEffectDisableNone: ClassVar[int] = ...
    kPostEffectDisableSSAO: ClassVar[int] = ...
    kPostEffectDisableMotionBlur: ClassVar[int] = ...
    kPostEffectDisableDOF: ClassVar[int] = ...
    kPostEffectDisableAll: ClassVar[int] = ...
    kNoCullingOverride: ClassVar[int] = ...
    kCullNone: ClassVar[int] = ...
    kCullBackFaces: ClassVar[int] = ...
    kCullFrontFaces: ClassVar[int] = ...
    mClearOperation: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addPostUIDrawables(self, drawManager: MUIDrawManager, frameContext: MFrameContext) -> Self: ...
    def addPreUIDrawables(self, drawManager: MUIDrawManager, frameContext: MFrameContext) -> Self: ...
    def cameraOverride(self) -> MCameraOverride: ...
    def clearOperation(self) -> MClearOperation: ...
    def cullingOverride(self) -> int: ...
    def displayModeOverride(self) -> int: ...
    def fragmentName(self) -> String: ...  # type: ignore[name-defined]
    def hasUIDrawables(self) -> bool: ...
    def lightModeOverride(self) -> int: ...
    def objectSetOverride(self) -> MSelectionList: ...
    def getParameters(self) -> MRenderParameters: ...
    def getObjectTypeExclusions(self) -> float: ...
    def objectTypeExclusions(self) -> int: ...
    def postEffectsOverride(self) -> int: ...
    def postRender(self) -> Self: ...
    def postSceneRender(self, context: MDrawContext) -> Self: ...
    def preRender(self) -> Self: ...
    def preSceneRender(self, context: MDrawContext) -> Self: ...
    def renderFilterOverride(self) -> int: ...
    def shaderOverride(self) -> MShaderInstance: ...
    def shadowEnableOverride(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MQuadRender(MRenderOperation):
    mClearOperation: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def blendStateOverride(self) -> MBlendState: ...
    def clearOperation(self) -> MClearOperation: ...
    def depthStencilStateOverride(self) -> MDepthStencilState: ...
    def rasterizerStateOverride(self) -> MRasterizerState: ...
    def shader(self) -> MShaderInstance: ...

class MRenderOverride:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def cleanup(self) -> Self: ...
    def name(self) -> str: ...
    def nextRenderOperation(self) -> bool: ...
    def renderOperation(self) -> MRenderOperation: ...
    def setup(self, destination: Incomplete) -> Self: ...
    def startOperationIterator(self) -> bool: ...
    def supportedDrawAPIs(self) -> int: ...
    def uiName(self) -> str: ...
    def getFrameContext(self) -> MFrameContext: ...
    def select(self, frameContext: MFrameContext, selectInfo: MSelectionInfo, useDepth: bool, selectionList: MSelectionList, worldSpaceHitPts: MPointArray) -> bool: ...

class MRenderParameters:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def isArrayParameter(self, string: str) -> bool: ...
    def parameterList(self) -> listofstring: ...  # type: ignore[name-defined]
    def parameterType(self, string: str) -> int: ...
    def semantic(self, string: str) -> str: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceofbool: Incomplete, int: int) -> Self: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceofint: Incomplete, int: int) -> Self: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceoffloat: Incomplete, int: int) -> Self: ...
    @overload
    def setArrayParameter(self, parameterName: Incomplete, sequenceofMMatrix: Incomplete, int: int) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, bool: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, int: int) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, float: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, listoffloat: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MFloatVector: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MMatrix: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MFloatMatrix: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MTextureAssignment: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MRenderTargetAssignment: Incomplete) -> Self: ...
    @overload
    def setParameter(self, parameterName: Incomplete, MSamplerState: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, bool: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, int: int) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, float: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, listoffloat: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, MFloatVector: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, MMatrix: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, MFloatMatrix: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, MTextureAssignment: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, MRenderTargetAssignment: Incomplete) -> Self: ...
    @overload
    def getParameter(self, parameterName: Incomplete, MSamplerStateDesc: Incomplete) -> Self: ...

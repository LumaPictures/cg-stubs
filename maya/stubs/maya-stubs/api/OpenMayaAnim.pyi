import MFnAnimCurve  # type: ignore[import-not-found]
import maya.api.OpenMaya
from _typeshed import Incomplete
from maya.api.OpenMaya import MAnimCurveClipboardItemArray as MAnimCurveClipboardItemArray, MDagPath, MDagPathArray, MDoubleArray, MFloatArray, MIntArray, MObject, MObjectArray, MPlugArray, MSelectionList, MTime  # type: ignore[attr-defined]
from typing import Any, ClassVar, Self, overload  # type: ignore[attr-defined]

ourdict: dict
py2dict: dict
key: str
val: str

class MAnimControl:
    kPlaybackOnce: ClassVar[int] = ...
    kPlaybackLoop: ClassVar[int] = ...
    kPlaybackOscillate: ClassVar[int] = ...
    kPlaybackViewAll: ClassVar[int] = ...
    kPlaybackViewActive: ClassVar[int] = ...
    @staticmethod
    def playbackMode() -> int: ...
    @staticmethod
    def setPlaybackMode(int: int) -> None: ...
    @staticmethod
    def viewMode() -> int: ...
    @staticmethod
    def setViewMode(int: int) -> None: ...
    @staticmethod
    def playbackBy() -> float: ...
    @staticmethod
    def setPlaybackBy(float: Incomplete) -> None: ...
    @staticmethod
    def minTime() -> MTime: ...
    @staticmethod
    def maxTime() -> MTime: ...
    @staticmethod
    def setMinTime(MTime: Incomplete) -> None: ...
    @staticmethod
    def setMaxTime(MTime: Incomplete) -> None: ...
    @staticmethod
    def setMinMaxTime(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def animationStartTime() -> MTime: ...
    @staticmethod
    def animationEndTime() -> MTime: ...
    @staticmethod
    def setAnimationStartTime(MTime: Incomplete) -> None: ...
    @staticmethod
    def setAnimationEndTime(MTime: Incomplete) -> None: ...
    @staticmethod
    def setAnimationStartEndTime(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def currentTime() -> MTime: ...
    @staticmethod
    def setCurrentTime(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def playbackSpeed() -> float: ...
    @staticmethod
    def setPlaybackSpeed(float: Incomplete) -> None: ...
    @staticmethod
    def playForward() -> None: ...
    @staticmethod
    def playBackward() -> None: ...
    @staticmethod
    def isPlaying() -> bool: ...
    @staticmethod
    def isScrubbing() -> bool: ...
    @staticmethod
    def stop() -> None: ...
    @staticmethod
    def autoKeyMode() -> bool: ...
    @staticmethod
    def setAutoKeyMode(bool: Incomplete) -> None: ...
    @staticmethod
    def globalInTangentType() -> int: ...
    @staticmethod
    def setGlobalInTangentType(int: int) -> None: ...
    @staticmethod
    def globalOutTangentType() -> int: ...
    @staticmethod
    def setGlobalOutTangentType(int: int) -> None: ...
    @staticmethod
    def weightedTangents() -> bool: ...
    @staticmethod
    def setWeightedTangents(bool: Incomplete) -> None: ...

class MAnimCurveChange:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def redoIt(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def undoIt(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MAnimCurveClipboard:
    theAPIClipboard: ClassVar[MAnimCurveClipboard] = ...
    isEmpty: Incomplete
    startTime: Incomplete
    endTime: Incomplete
    startUnitlessInput: Incomplete
    endUnitlessInput: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def clear(self) -> Self: ...
    def clipboardItems(self) -> MAnimCurveClipboardItemArray: ...
    @overload
    def set(self, clipboard: Incomplete) -> Self: ...
    @overload
    def set(self, items: Incomplete) -> Self: ...
    @overload
    def set(self, items: Incomplete, startTime: Incomplete, endTime: Incomplete, startUnitlessInput: Incomplete, endUnitlessInput: Incomplete, strictValidation: Incomplete = ...) -> Self: ...

class MAnimCurveClipboardItem:
    animCurve: Incomplete
    fullAttributeName: Incomplete
    leafAttributeName: Incomplete
    nodeName: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def getAddressingInfo(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setAnimCurve(self, object: Incomplete) -> Self: ...
    def setAddressingInfo(self, rowCount: Incomplete, childCount: Incomplete, attributeCount: Incomplete) -> Self: ...
    def setNameInfo(self, nodeName: Incomplete, fullName: Incomplete, leafName: Incomplete) -> Self: ...
    def animCurveType(self) -> MFnAnimCurve.AnimCurveType: ...

class MAnimMessage(maya.api.OpenMaya.MMessage):
    @staticmethod
    def addAnimCurveEditedCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addAnimKeyframeEditedCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addAnimKeyframeEditCheckCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addNodeAnimKeyframeEditedCallback(animNode: MObject, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addPreBakeResultsCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addPostBakeResultsCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addDisableImplicitControlCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def flushAnimKeyframeEditedCallbacks() -> None: ...

class MAnimUtil:
    @overload
    @staticmethod
    def isAnimated(MObject: Incomplete, bool: Incomplete) -> bool: ...
    @overload
    @staticmethod
    def isAnimated(MDagPath: Incomplete, bool: Incomplete) -> bool: ...
    @overload
    @staticmethod
    def isAnimated(MPlug: Incomplete, bool: Incomplete) -> bool: ...
    @overload
    @staticmethod
    def isAnimated(MSelectionListselectionList: Incomplete, boolcheckParent: Incomplete) -> bool: ...
    @overload
    @staticmethod
    def findAnimatedPlugs(MObject: Incomplete, bool: Incomplete) -> MPlugArray: ...
    @overload
    @staticmethod
    def findAnimatedPlugs(MDagPath: Incomplete, bool: Incomplete) -> MPlugArray: ...
    @overload
    @staticmethod
    def findAnimatedPlugs(MSelectionListselectionList: Incomplete, boolcheckParent: Incomplete) -> MPlugArray: ...
    @staticmethod
    def findAnimation(MPlug: Incomplete) -> MObjectArray: ...
    @staticmethod
    def findSetDrivenKeyAnimation(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def findConstraint(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def findAnimatablePlugs(MSelectionList: Incomplete) -> MPlugArray: ...

class MFnAnimCurve(maya.api.OpenMaya.MFnDependencyNode):  # type: ignore[no-redef]
    kAnimCurveTA: ClassVar[int] = ...
    kAnimCurveTL: ClassVar[int] = ...
    kAnimCurveTT: ClassVar[int] = ...
    kAnimCurveTU: ClassVar[int] = ...
    kAnimCurveUA: ClassVar[int] = ...
    kAnimCurveUL: ClassVar[int] = ...
    kAnimCurveUT: ClassVar[int] = ...
    kAnimCurveUU: ClassVar[int] = ...
    kAnimCurveUnknown: ClassVar[int] = ...
    kTangentGlobal: ClassVar[int] = ...
    kTangentFixed: ClassVar[int] = ...
    kTangentLinear: ClassVar[int] = ...
    kTangentFlat: ClassVar[int] = ...
    kTangentSmooth: ClassVar[int] = ...
    kTangentStep: ClassVar[int] = ...
    kTangentSlow: ClassVar[int] = ...
    kTangentFast: ClassVar[int] = ...
    kTangentClamped: ClassVar[int] = ...
    kTangentPlateau: ClassVar[int] = ...
    kTangentStepNext: ClassVar[int] = ...
    kTangentAuto: ClassVar[int] = ...
    kTangentShared1: ClassVar[int] = ...
    kTangentShared2: ClassVar[int] = ...
    kTangentShared3: ClassVar[int] = ...
    kTangentShared4: ClassVar[int] = ...
    kTangentShared5: ClassVar[int] = ...
    kTangentShared6: ClassVar[int] = ...
    kTangentShared7: ClassVar[int] = ...
    kTangentShared8: ClassVar[int] = ...
    kTangentAutoMix: ClassVar[int] = ...
    kTangentAutoEase: ClassVar[int] = ...
    kTangentAutoCustom: ClassVar[int] = ...
    kTangentCustomStart: ClassVar[int] = ...
    kTangentCustomEnd: ClassVar[int] = ...
    kTangentTypeCount: ClassVar[int] = ...
    kConstant: ClassVar[int] = ...
    kLinear: ClassVar[int] = ...
    kCycle: ClassVar[int] = ...
    kCycleRelative: ClassVar[int] = ...
    kOscillate: ClassVar[int] = ...
    animCurveType: Incomplete
    isStatic: Incomplete
    numKeys: Incomplete
    isTimeInput: Incomplete
    isUnitlessInput: Incomplete
    isWeighted: Incomplete
    preInfinityType: Incomplete
    postInfinityType: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @overload
    def create(self, node: Incomplete, attribute: Incomplete, animCurveType: Incomplete = ...) -> MObject: ...
    @overload
    def create(self, plug: Incomplete, animCurveType: Incomplete = ...) -> MObject: ...
    def timedAnimCurveTypeForPlug(self, plug: Incomplete) -> AnimCurveType: ...  # type: ignore[name-defined]
    def unitlessAnimCurveTypeForPlug(self, plug: Incomplete) -> AnimCurveType: ...  # type: ignore[name-defined]
    def evaluate(self, at: Incomplete) -> value: ...  # type: ignore[name-defined]
    def remove(self, index: Incomplete, change: Incomplete = ...) -> Self: ...
    def addKey(self, at: Incomplete, value: Incomplete, tangentInType: Incomplete = ..., tangentOutType: Incomplete = ..., change: Incomplete = ...) -> int: ...
    def addKeys(self, times: Incomplete, values: Incomplete, tangentInType: Incomplete = ..., tangentOutType: Incomplete = ..., keepExistingKeys: Incomplete = ..., change: Incomplete = ...) -> Self: ...
    def insertKey(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def addKeysWithTangents(self, times: Incomplete, values: Incomplete, tangentInType: Incomplete = ..., tangentOutType: Incomplete = ..., tangentInTypeArray: Incomplete = ..., tangentOutTypeArray: Incomplete = ..., tangentInXArray: Incomplete = ..., tangentInYArray: Incomplete = ..., tangentOutXArray: Incomplete = ..., tangentOutYArray: Incomplete = ..., tangentsLockedArray: Incomplete = ..., weightsLockedArray: Incomplete = ..., convertUnits: Incomplete = ..., keepExistingKeys: Incomplete = ..., change: Incomplete = ...) -> Self: ...
    def find(self, at: Incomplete) -> int: ...
    def findClosest(self, at: Incomplete) -> int: ...
    def input(self, index: Incomplete) -> MTimeordouble: ...  # type: ignore[name-defined]
    def value(self, index: Incomplete) -> float: ...
    def quaternionW(self, index: Incomplete) -> float: ...
    def setValue(self, index: Incomplete, value: Incomplete, change: Incomplete = ...) -> Self: ...
    def setQuaternionW(self, index: Incomplete, quaternionW: Incomplete, change: Incomplete = ...) -> Self: ...
    def setInput(self, index: Incomplete, at: Incomplete, change: Incomplete = ...) -> Self: ...
    def inTangentType(self, index: Incomplete) -> TangentType: ...  # type: ignore[name-defined]
    def outTangentType(self, index: Incomplete) -> TangentType: ...  # type: ignore[name-defined]
    def setInTangentType(self, index: Incomplete, tangentType: Incomplete, change: Incomplete = ...) -> Self: ...
    def setOutTangentType(self, index: Incomplete, tangentType: Incomplete, change: Incomplete = ...) -> Self: ...
    def setTangentTypes(self, indexArray: Incomplete, tangentInType: Incomplete = ..., tangentOutType: Incomplete = ..., change: Incomplete = ...) -> Self: ...
    def getTangentXY(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getTangentAngleWeight(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setTangent(self, index: Incomplete, xOrAngle: Incomplete, yOrWeight: Incomplete, isInTangent: Incomplete, change: Incomplete = ..., convertUnits: Incomplete = ...) -> Self: ...
    def setAngle(self, index: Incomplete, setAngle: Incomplete, isInTangent: Incomplete, change: Incomplete = ...) -> Self: ...
    def setWeight(self, index: Incomplete, weight: Incomplete, isInTangent: Incomplete, change: Incomplete = ...) -> Self: ...
    def weightsLocked(self, index: Incomplete) -> bool: ...
    def tangentsLocked(self, index: Incomplete) -> bool: ...
    def setWeightsLocked(self, index: Incomplete, locked: Incomplete, change: Incomplete = ...) -> Self: ...
    def setTangentsLocked(self, index: Incomplete, locked: Incomplete, change: Incomplete = ...) -> Self: ...
    def setIsWeighted(self, isWeighted: Incomplete, change: Incomplete = ...) -> Self: ...
    def isBreakdown(self, index: Incomplete) -> bool: ...
    def setIsBreakdown(self, index: Incomplete, isBreakdown: Incomplete, change: Incomplete = ...) -> Self: ...
    def setPreInfinityType(self, infinityType: Incomplete, change: Incomplete = ...) -> Self: ...
    def setPostInfinityType(self, infinityType: Incomplete, change: Incomplete = ...) -> Self: ...

class MFnGeometryFilter(maya.api.OpenMaya.MFnDependencyNode):
    deformerSet: Incomplete
    envelope: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def getInputGeometry(self) -> MObjectArray: ...
    def getOutputGeometry(self) -> MObjectArray: ...
    def getPathAtIndex(self, plugIndex: int) -> MDagPath: ...
    def groupIdAtIndex(self, plugIndex: int) -> float: ...
    def indexForGroupId(self, groupId: int) -> plugIndex: ...  # type: ignore[name-defined]
    def indexForOutputConnection(self, connIndex: int) -> plugIndex: ...  # type: ignore[name-defined]
    def indexForOutputShape(self, shape: MObject) -> plugIndex: ...  # type: ignore[name-defined]
    def inputShapeAtIndex(self, plugIndex: int) -> MObject: ...
    def numOutputConnections(self) -> float: ...
    def outputShapeAtIndex(self, index: Incomplete) -> MObject: ...
    def getComponentAtIndex(self, index: Incomplete) -> MObject: ...

class MFnWeightGeometryFilter(MFnGeometryFilter):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @overload
    def getWeights(self, index: Incomplete, components: MObject) -> MFloatArray: ...
    @overload
    def getWeights(self, path: MDagPath, components: MObject) -> MFloatArray: ...
    @overload
    def setWeight(self, path: MDagPath, index: int, components: MObject, weight: float, oldValues: MFloatArray = ...) -> Any: ...
    @overload
    def setWeight(self, path: MDagPath, index: int, components: MObject, values: MFloatArray) -> Any: ...
    @overload
    def setWeight(self, path: MDagPath, components: MObject, weight: float, oldValues: MFloatArray = ...) -> Any: ...
    @overload
    def setWeight(self, path: MDagPath, components: MObject, values: MFloatArray) -> Any: ...
    def getEnvelopeWeights(self, index: int) -> MFloatArray: ...
    def weightPlugStrings(self, list: MSelectionList) -> str: ...
    def getWeightPlugStrings(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MFnIkJoint(maya.api.OpenMaya.MFnTransform):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def create(self, parent: Incomplete = ...) -> newjointnodeMObject: ...  # type: ignore[override]
    def degreesOfFreedom(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def hikJointName(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def maxRotateDampXRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def maxRotateDampXStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def maxRotateDampYRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def maxRotateDampYStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def maxRotateDampZRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def maxRotateDampZStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def minRotateDampXRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def minRotateDampXStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def minRotateDampYRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def minRotateDampYStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def minRotateDampZRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def minRotateDampZStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def orientation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def orientationComponents(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def preferredAngle(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def scaleOrientation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def segmentScale(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDegreesOfFreedom(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMaxRotateDampXRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMaxRotateDampXStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMaxRotateDampYRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMaxRotateDampYStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMaxRotateDampZRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMaxRotateDampZStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMinRotateDampXRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMinRotateDampXStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMinRotateDampYRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMinRotateDampYStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMinRotateDampZRange(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setMinRotateDampZStrength(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setOrientation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setPreferredAngle(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setScaleOrientation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setSegmentScale(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setStiffness(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def stiffness(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MFnSkinCluster(MFnGeometryFilter):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def getBlendWeights(self, shape: MDagPath, components: MObject) -> MDoubleArray: ...
    def getPointsAffectedByInfluence(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @overload
    def getWeights(self, shape: MDagPath, components: MObject, influence: int) -> MDoubleArray: ...
    @overload
    def getWeights(self, shape: MDagPath, components: MObject, influences: MIntArray) -> MDoubleArray: ...
    def indexForInfluenceObject(self, influenceObj: MObject) -> float: ...
    def influenceObjects(self) -> MDagPathArray: ...
    def setBlendWeights(self, shape: MDagPath, components: MObject, weights: MDoubleArray) -> Self: ...
    @overload
    def setWeights(self, shape: MDagPath, components: MObject, influence: int, weight: float, normalize: bool = ..., returnOldWeights: bool = ...) -> NoneorMDoubleArray: ...  # type: ignore[name-defined]
    @overload
    def setWeights(self, shape: MDagPath, components: MObject, influences: MIntArray, weights: MDoubleArray, normalize: bool = ..., returnOldWeights: bool = ...) -> NoneorMDoubleArray: ...  # type: ignore[name-defined]

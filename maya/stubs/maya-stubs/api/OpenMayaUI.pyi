import M3dView  # type: ignore[import-not-found]
import MSyntax  # type: ignore[import-not-found]
import maya.api.OpenMaya
import maya.api.OpenMayaRender
from _typeshed import Incomplete
from maya.api.OpenMaya import MAngle, MBoundingBox, MColor, MDagModifier, MDagPath, MDoubleArray, MEulerRotation, MImage, MIntArray, MMatrix, MObject, MPlug, MPoint, MPxManipulatorNode as MPxManipulatorNode, MPxSurfaceShape, MSelectionList, MSelectionMask, MTransformationMatrix, MVector  # type: ignore[attr-defined]
from maya.api.OpenMayaRender import MFrameContext, MRenderProfile, MSwatchRenderBase, MUIDrawManager, MUniformParameterList  # type: ignore[attr-defined]
from typing import Any, ClassVar, Self, overload  # type: ignore[attr-defined]

ourdict: dict
py2dict: dict
key: str
val: str

class M3dView:  # type: ignore[no-redef]
    kBoundingBox: ClassVar[int] = ...
    kFlatShaded: ClassVar[int] = ...
    kGouraudShaded: ClassVar[int] = ...
    kWireFrame: ClassVar[int] = ...
    kPoints: ClassVar[int] = ...
    kActive: ClassVar[int] = ...
    kLive: ClassVar[int] = ...
    kDormant: ClassVar[int] = ...
    kInvisible: ClassVar[int] = ...
    kHilite: ClassVar[int] = ...
    kTemplate: ClassVar[int] = ...
    kActiveTemplate: ClassVar[int] = ...
    kActiveComponent: ClassVar[int] = ...
    kLead: ClassVar[int] = ...
    kIntermediateObject: ClassVar[int] = ...
    kActiveAffected: ClassVar[int] = ...
    kNoStatus: ClassVar[int] = ...
    kActiveColors: ClassVar[int] = ...
    kDormantColors: ClassVar[int] = ...
    kTemplateColor: ClassVar[int] = ...
    kBackgroundColor: ClassVar[int] = ...
    kLeft: ClassVar[int] = ...
    kCenter: ClassVar[int] = ...
    kRight: ClassVar[int] = ...
    kDisplayEverything: ClassVar[int] = ...
    kDisplayNurbsCurves: ClassVar[int] = ...
    kDisplayNurbsSurfaces: ClassVar[int] = ...
    kDisplayMeshes: ClassVar[int] = ...
    kDisplayPlanes: ClassVar[int] = ...
    kDisplayLights: ClassVar[int] = ...
    kDisplayCameras: ClassVar[int] = ...
    kDisplayJoints: ClassVar[int] = ...
    kDisplayIkHandles: ClassVar[int] = ...
    kDisplayDeformers: ClassVar[int] = ...
    kDisplayDynamics: ClassVar[int] = ...
    kDisplayParticleInstancers: ClassVar[int] = ...
    kDisplayLocators: ClassVar[int] = ...
    kDisplayDimensions: ClassVar[int] = ...
    kDisplaySelectHandles: ClassVar[int] = ...
    kDisplayPivots: ClassVar[int] = ...
    kDisplayTextures: ClassVar[int] = ...
    kDisplayGrid: ClassVar[int] = ...
    kDisplayCVs: ClassVar[int] = ...
    kDisplayHulls: ClassVar[int] = ...
    kDisplayStrokes: ClassVar[int] = ...
    kDisplaySubdivSurfaces: ClassVar[int] = ...
    kDisplayFluids: ClassVar[int] = ...
    kDisplayFollicles: ClassVar[int] = ...
    kDisplayHairSystems: ClassVar[int] = ...
    kDisplayImagePlane: ClassVar[int] = ...
    kDisplayNCloths: ClassVar[int] = ...
    kDisplayNRigids: ClassVar[int] = ...
    kDisplayDynamicConstraints: ClassVar[int] = ...
    kDisplayManipulators: ClassVar[int] = ...
    kDisplayNParticles: ClassVar[int] = ...
    kExcludeMotionTrails: ClassVar[int] = ...
    kExcludePluginShapes: ClassVar[int] = ...
    kLightAll: ClassVar[int] = ...
    kLightSelected: ClassVar[int] = ...
    kLightActive: ClassVar[int] = ...
    kLightDefault: ClassVar[int] = ...
    kUnused1: ClassVar[int] = ...
    kLightNone: ClassVar[int] = ...
    kDefaultQualityRenderer: ClassVar[int] = ...
    kHighQualityRenderer: ClassVar[int] = ...
    kViewport2Renderer: ClassVar[int] = ...
    kExternalRenderer: ClassVar[int] = ...
    kDepth_8: ClassVar[int] = ...
    kDepth_Float: ClassVar[int] = ...
    kStippleNone: ClassVar[int] = ...
    kStippleDashed: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def display(self) -> float: ...
    def deviceContext(self) -> float: ...
    @staticmethod
    def active3dView() -> M3dView: ...
    @staticmethod
    def activeAffectedColor() -> MColor: ...
    @staticmethod
    def activeTemplateColor() -> MColor: ...
    @staticmethod
    def applicationShell() -> float: ...
    @staticmethod
    def backgroundColor() -> MColor: ...
    @staticmethod
    def backgroundColorBottom() -> MColor: ...
    @staticmethod
    def backgroundColorTop() -> MColor: ...
    def beginGL(self) -> Self: ...
    def beginProjMatrixOverride(self, projectionMatrix: MMatrix) -> Self: ...
    def beginSelect(self, buffer: bytearray = ..., size: int = ...) -> Self: ...
    @overload
    def beginXorDrawing(self, drawOrthographic: bool = ..., disableDepthTesting: bool = ..., lineWidth: float = ..., stipplePattern: int = ..., lineColor: tuple[1, 1, 1] = ...) -> Self: ...  # type: ignore[valid-type]
    @overload
    def beginXorDrawing(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def colorAtIndex(self, index: int, table: int = ...) -> MColor: ...
    def colorMask(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def disallowPolygonOffset(self) -> bool: ...
    @staticmethod
    def displayStatus(path: MDagPath) -> int: ...
    def displayStyle(self) -> int: ...
    def drawText(self, text: str, position: MPoint, textPosition: int = ...) -> Self: ...
    def endGL(self) -> Self: ...
    def endProjMatrixOverride(self) -> Self: ...
    def endSelect(self) -> int: ...
    @overload
    def endXorDrawing(self) -> Self: ...
    @overload
    def endXorDrawing(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @staticmethod
    def get3dView(index: int) -> M3dView: ...
    def getCamera(self) -> MDagPath: ...
    def getColorIndexAndTable(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getLightCount(self, visible: bool = ...) -> int: ...
    def getLightIndex(self, lightNumber: int) -> int: ...
    def getLightPath(self, lightNumber: int) -> MDagPath: ...
    def getLightingMode(self) -> int: ...
    @staticmethod
    def getM3dViewFromModelEditor(name: str) -> M3dView: ...
    @staticmethod
    def getM3dViewFromModelPanel(name: str) -> M3dView: ...
    def getRendererName(self) -> int: ...
    def getScreenPosition(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def hiliteColor() -> MColor: ...
    def initNames(self) -> Self: ...
    @staticmethod
    def isBackgroundGradient() -> bool: ...
    def isLightVisible(self, lightNumber: int) -> bool: ...
    def isShadeActiveOnly(self) -> bool: ...
    def isVisible(self) -> bool: ...
    @staticmethod
    def leadColor() -> MColor: ...
    @staticmethod
    def liveColor() -> MColor: ...
    def loadName(self, int: int) -> Self: ...
    def modelViewMatrix(self) -> MMatrix: ...
    def multipleDrawEnabled(self) -> bool: ...
    def multipleDrawPassCount(self) -> int: ...
    def numActiveColors(self) -> int: ...
    def numDormantColors(self) -> int: ...
    def numUserDefinedColors(self) -> int: ...
    @staticmethod
    def numberOf3dViews() -> int: ...
    def objectDisplay(self) -> int: ...
    def objectListFilterName(self) -> str: ...
    def playblastPortHeight(self) -> int: ...
    def playblastPortWidth(self) -> int: ...
    def pluginObjectDisplay(self, pluginDisplayFilter: str) -> bool: ...
    def popName(self) -> Self: ...
    def popViewport(self) -> Self: ...
    def portHeight(self) -> int: ...
    def portWidth(self) -> int: ...
    def projectionMatrix(self) -> MMatrix: ...
    def pushName(self, int: int) -> Self: ...
    def pushViewport(self, x: Incomplete, y: Incomplete, width: int, height: int) -> Self: ...
    def readBufferTo2dTexture(self, x: int, y: int, width: int, height: int) -> Self: ...
    def readColorBuffer(self, image: MImage, readRGBA: bool = ...) -> Self: ...
    def readDepthMap(self, x: int, y: int, width: int, heigth: Incomplete, bufferPtr: byterray, depthMapPrecision: int) -> Self: ...  # type: ignore[name-defined]
    @staticmethod
    def referenceLayerColor() -> MColor: ...
    def refresh(self, all: bool = ..., force: bool = ..., offscreen: bool = ...) -> Self: ...
    def renderOverrideName(self) -> str: ...
    def rendererString(self) -> str: ...
    def scheduleRefresh(self) -> Self: ...
    @staticmethod
    def scheduleRefreshAllViews() -> None: ...
    def selectMode(self) -> bool: ...
    def setCamera(self, camera: MDagPath) -> Self: ...
    def setColorMask(self, r: bool, g: bool, b: bool, a: bool) -> Self: ...
    def setDisallowPolygonOffset(self, v: bool) -> Self: ...
    def setDisplayStyle(self, style: int, activeOnly: Incomplete = ...) -> Self: ...
    @overload
    def setDrawColor(self, index: int, table: int = ...) -> Self: ...
    @overload
    def setDrawColor(self, color: MColor) -> Self: ...
    def setDrawColorAndAlpha(self, color: MColor) -> Self: ...
    def setMultipleDrawEnable(self, enable: bool) -> Self: ...
    def setMultipleDrawPassCount(self, count: int) -> Self: ...
    def setObjectDisplay(self, displayMask: int) -> Self: ...
    def setObjectListFilterName(self, name: str) -> Self: ...
    def setPluginObjectDisplay(self, pluginDisplayFilter: str, on: bool) -> Self: ...
    def setRenderOverrideName(self, name: str) -> Self: ...
    def setShowObjectFilterNameInHUD(self, show: bool) -> Self: ...
    def setShowViewSelectedChildren(self, show: bool) -> Self: ...
    def setUserDefinedColor(self, index: int, color: MColor) -> Self: ...
    def setViewSelectedPrefix(self, prefix: str) -> Self: ...
    def showObjectFilterNameInHUD(self) -> bool: ...
    def showViewSelectedChildren(self) -> bool: ...
    @staticmethod
    def templateColor() -> MColor: ...
    def textureMode(self) -> bool: ...
    def twoSidedLighting(self) -> bool: ...
    def updateViewingParameters(self) -> Self: ...
    def userDefinedColorIndex(self, index: int) -> int: ...
    def usingDefaultMaterial(self) -> bool: ...
    def usingMipmappedTextures(self) -> bool: ...
    def viewSelectedPrefix(self) -> str: ...
    def viewToObjectSpace(self, x_pos: int, y_pos: int, localMatrixInverse: MMatrix, oPt: MPoint, oVector: MVector) -> Self: ...
    @overload
    def viewToWorld(self, x_pos: int, y_pos: int, worldPt: MPoint, worldVector: MVector) -> Self: ...
    @overload
    def viewToWorld(self, x_pos: int, y_pos: int, nearClipPt: MPoint, farClipPt: MPoint) -> Self: ...
    def viewport(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def widget(self) -> float: ...
    def window(self) -> float: ...
    def wireframeOnShaded(self) -> bool: ...
    def wireframeOnlyInShadedMode(self) -> bool: ...
    def worldToView(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def writeColorBuffer(self, image: MImage, x: X = ..., y: Y = ...) -> Self: ...  # type: ignore[name-defined]
    def xray(self) -> bool: ...
    def xrayJoints(self) -> bool: ...
    def viewIsFiltered(self) -> bool: ...
    def filteredObjectList(self) -> MSelectionList: ...

class MCursor:
    kDefaultCursor: ClassVar[MCursor] = ...
    kCrossHairCursor: ClassVar[MCursor] = ...
    kDoubleCrossHairCursor: ClassVar[MCursor] = ...
    kEditCursor: ClassVar[MCursor] = ...
    kPencilCursor: ClassVar[MCursor] = ...
    kHandCursor: ClassVar[MCursor] = ...
    def __lt__(self, value: Incomplete) -> bool: ...
    def __le__(self, value: Incomplete) -> bool: ...
    def __eq__(self, value: Incomplete) -> bool: ...
    def __ne__(self, value: Incomplete) -> bool: ...
    def __gt__(self, value: Incomplete) -> bool: ...
    def __ge__(self, value: Incomplete) -> bool: ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MDrawData:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def geometry(self) -> float: ...

class MDrawInfo:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def canDrawComponent(self, isDisplayOn: bool, compMask: Incomplete) -> bool: ...
    def completelyInside(self) -> bool: ...
    @overload
    def displayStatus(self) -> int: ...
    @overload
    def displayStatus(self) -> Any: ...  # type: ignore[overload-cannot-match]
    @overload
    def displayStyle(self) -> int: ...
    @overload
    def displayStyle(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def getPrototype(self, drawHandler: MPxSurfaceShapeUI) -> MDrawRequest: ...
    def inSelect(self) -> bool: ...
    def inUserInteraction(self) -> bool: ...
    def inclusiveMatrix(self) -> MMatrix: ...
    def multiPath(self) -> MDagPath: ...
    def objectDisplayStatus(self, displayObj: int) -> bool: ...
    def pluginObjectDisplayStatus(self, pluginDisplayFilter: str) -> bool: ...
    def projectionMatrix(self) -> MMatrix: ...
    def setMultiPath(self, path: MDagPath) -> Self: ...
    def userChangingViewContext(self) -> bool: ...
    def view(self) -> M3dView: ...

class MDrawRequest:
    view: Incomplete
    multiPath: Incomplete
    component: Incomplete
    drawData: Incomplete
    displayStatus: Any
    displayCulling: Incomplete
    displayCullOpposite: Incomplete
    displayStyle: Any
    color: Incomplete
    material: Incomplete
    isTransparent: Incomplete
    drawLast: Incomplete
    token: Incomplete
    matrix: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def planeColor(self, table: int) -> int: ...
    def setPlaneColor(self, value: int, table: int) -> Self: ...

class MEvent:
    shiftKey: ClassVar[int] = ...
    controlKey: ClassVar[int] = ...
    kLeftMouse: ClassVar[int] = ...
    kMiddleMouse: ClassVar[int] = ...
    position: Incomplete
    modifiers: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def getWindowPosition(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def mouseButton(self) -> mouseButtonType: ...  # type: ignore[name-defined]
    def isModifierKeyRelease(self) -> bool: ...
    def isModifierNone(self) -> bool: ...
    def isModifierShift(self) -> bool: ...
    def isModifierControl(self) -> bool: ...
    def isModifierLeftMouseButton(self) -> bool: ...
    def isModifierMiddleMouseButton(self) -> bool: ...

class MFnManip3D(maya.api.OpenMaya.MFnTransform):
    isVisible: Incomplete
    manipScale: Incomplete
    isOptimizePlaybackOn: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def deleteManipulator(manip: MObject) -> None: ...
    @staticmethod
    def globalSize() -> float: ...
    @staticmethod
    def handleSize() -> float: ...
    @staticmethod
    def lineSize() -> float: ...
    def rotateXYZValue(self, valIndex: int) -> MEulerRotation: ...
    @staticmethod
    def drawPlaneHandles() -> bool: ...
    @staticmethod
    def setGlobalSize(float: Incomplete) -> None: ...
    @staticmethod
    def setHandleSize(float: Incomplete) -> None: ...
    @staticmethod
    def setLineSize(float: Incomplete) -> None: ...
    @staticmethod
    def setDrawPlaneHandles(bool: Incomplete) -> None: ...

class MFnCircleSweepManip(MFnManip3D):
    startPoint: Incomplete
    endPoint: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def angleIndex(self) -> int: ...
    def axisIndex(self) -> int: ...
    def centerIndex(self) -> int: ...
    def connectToAnglePlug(self, anglePlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., angleName: str = ...) -> MObject: ...  # type: ignore[override]
    def endCircleIndex(self) -> int: ...
    def setAngle(self, angle: MAngle) -> Self: ...
    def setCenterPoint(self, centerPoint: MPoint) -> Self: ...
    def setDrawAsArc(self, state: bool) -> Self: ...
    def setNormal(self, normal: MVector) -> Self: ...
    def setRadius(self, radius: float) -> Self: ...
    def startCircleIndex(self) -> int: ...

class MFnCurveSegmentManip(MFnManip3D):
    startParameter: Incomplete
    endParameter: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToCurvePlug(self, curvePlug: MPlug) -> Self: ...
    def connectToEndParamPlug(self, endParamPlug: MPlug) -> Self: ...
    def connectToStartParamPlug(self, startParamPlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., startParamName: str = ..., endParamName: str = ...) -> MObject: ...
    def curveIndex(self) -> int: ...
    def endParamIndex(self) -> int: ...
    def startParamIndex(self) -> int: ...

class MFnDirectionManip(MFnManip3D):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToDirectionPlug(self, directionPlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., directionName: str = ...) -> MObject: ...  # type: ignore[override]
    def directionIndex(self) -> int: ...
    def endPointIndex(self) -> int: ...
    def setDirection(self, direction: MVector) -> Self: ...
    def setDrawStart(self, bool: Incomplete) -> Self: ...
    def setNormalizeDirection(self, bool: Incomplete) -> Self: ...
    def setStartPoint(self, startPoint: MPoint) -> Self: ...
    def startPointIndex(self) -> int: ...

class MFnDiscManip(MFnManip3D):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def angleIndex(self) -> int: ...
    def axisIndex(self) -> int: ...
    def centerIndex(self) -> int: ...
    def connectToAnglePlug(self, directionPlug: Incomplete) -> Self: ...
    def create(self, manipName: str = ..., angleName: str = ...) -> MObject: ...  # type: ignore[override]
    def setAngle(self, angle: MAngle) -> Self: ...
    def setCenterPoint(self, centerPoint: MPoint) -> Self: ...
    def setNormal(self, normal: MVector) -> Self: ...
    def setRadius(self, radius: float) -> Self: ...

class MFnDistanceManip(MFnManip3D):
    isDrawStartOn: Incomplete
    isDrawLineOn: Incomplete
    scalingFactor: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToDistancePlug(self, directionPlug: Incomplete) -> Self: ...
    def create(self, manipName: str = ..., distanceName: str = ...) -> MObject: ...  # type: ignore[override]
    def currentPointIndex(self) -> int: ...
    def directionIndex(self) -> int: ...
    def distanceIndex(self) -> int: ...
    def setDirection(self, direction: MVector) -> Self: ...
    def setStartPoint(self, startPoint: MPoint) -> Self: ...
    def startPointIndex(self) -> int: ...

class MFnFreePointTriadManip(MFnManip3D):
    kYZPlane: ClassVar[int] = ...
    kXZPlane: ClassVar[int] = ...
    kXYPlane: ClassVar[int] = ...
    kViewPlane: ClassVar[int] = ...
    isDrawAxesOn: Incomplete
    isSnapModeOn: Incomplete
    isKeyframeAllOn: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToPointPlug(self, pointPlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., pointName: str = ...) -> MObject: ...  # type: ignore[override]
    def pointIndex(self) -> int: ...
    def setDirection(self, direction: MVector) -> Self: ...
    def setDrawArrowHead(self, state: bool) -> Self: ...
    def setGlobalTriadPlane(self, whichPlane: int) -> Self: ...
    def setPoint(self, pointValue: MPoint) -> Self: ...

class MFnPointOnCurveManip(MFnManip3D):
    isDrawCurveOn: Incomplete
    parameter: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToCurvePlug(self, curvePlug: MPlug) -> Self: ...
    def connectToParamPlug(self, paramPlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., paramName: str = ...) -> MObject: ...  # type: ignore[override]
    def curveIndex(self) -> int: ...
    def curvePoint(self) -> MPoint: ...
    def paramIndex(self) -> int: ...

class MFnPointOnSurfaceManip(MFnManip3D):
    uParam: Incomplete
    vParam: Incomplete
    isDrawSurfaceOn: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToParamPlug(self, paramPlug: MPlug) -> Self: ...
    def connectToSurfacePlug(self, surfacePlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., paramName: str = ...) -> MObject: ...  # type: ignore[override]
    def paramIndex(self) -> int: ...
    def setDrawArrows(self, state: bool) -> Self: ...
    def surfaceIndex(self) -> int: ...

class MFnRotateManip(MFnManip3D):
    kObjectSpace: ClassVar[int] = ...
    kWorldSpace: ClassVar[int] = ...
    kGimbal: ClassVar[int] = ...
    isSnapModeOn: Incomplete
    snapIncrement: Incomplete
    rotateMode: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToRotationCenterPlug(self, rotationCenterPlug: MPlug) -> Self: ...
    def connectToRotationPlug(self, rotationPlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., rotationName: str = ...) -> MObject: ...  # type: ignore[override]
    def displayWithNode(self, node: MObject) -> Self: ...
    def rotationCenterIndex(self) -> int: ...
    def rotationIndex(self) -> int: ...
    def setInitialRotation(self, rotation: MEulerRotation) -> Self: ...
    def setRotationCenter(self, rotationCenter: MPoint) -> Self: ...

class MFnScaleManip(MFnManip3D):
    kDefaultOrientation: ClassVar[int] = ...
    kArbitraryOrientation: ClassVar[int] = ...
    isSnapModeOn: Incomplete
    snapIncrement: Incomplete
    orientation: Incomplete
    orientationMode: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToScaleCenterPlug(self, scaleCenterPlug: MPlug) -> Self: ...
    def connectToScalePlug(self, scalePlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., scaleName: str = ...) -> MObject: ...  # type: ignore[override]
    def displayWithNode(self, node: MObject) -> Self: ...
    def scaleCenterIndex(self) -> int: ...
    def scaleIndex(self) -> int: ...
    def setInitialScale(self, scale: MVector) -> Self: ...

class MFnStateManip(MFnManip3D):
    maxStates: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToStatePlug(self, statePlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., stateName: str = ...) -> MObject: ...  # type: ignore[override]
    def positionIndex(self) -> int: ...
    def setInitialState(self, initialState: int) -> Self: ...
    def state(self) -> int: ...
    def stateIndex(self) -> int: ...

class MFnToggleManip(MFnManip3D):
    startPoint: Incomplete
    direction: Incomplete
    length: Incomplete
    toggle: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def connectToTogglePlug(self, togglePlug: MPlug) -> Self: ...
    def create(self, manipName: str = ..., toggleName: str = ...) -> MObject: ...  # type: ignore[override]
    def directionIndex(self) -> int: ...
    def lengthIndex(self) -> int: ...
    def startPointIndex(self) -> int: ...
    def toggleIndex(self) -> int: ...

class MHWShaderSwatchGenerator(maya.api.OpenMayaRender.MSwatchRenderBase):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def createObj(obj: MObject, renderObj: int, res: Incomplete) -> MSwatchRenderBase: ...
    def doIteration(self) -> bool: ...
    @staticmethod
    def getSwatchBackgroundColor() -> MColor: ...
    @staticmethod
    def initialize() -> str: ...

class MManipData:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def asBool(self) -> bool: ...
    def asDouble(self) -> float: ...
    def asFloat(self) -> float: ...
    def asLong(self) -> int: ...
    def asMObject(self) -> int: ...
    def asShort(self) -> int: ...
    def asUnsigned(self) -> int: ...
    def isSimple(self) -> bool: ...

class MMaterial:
    kColor: ClassVar[int] = ...
    kTransparency: ClassVar[int] = ...
    kAmbientColor: ClassVar[int] = ...
    kIncandescence: ClassVar[int] = ...
    kBumpMap: ClassVar[int] = ...
    kDiffuse: ClassVar[int] = ...
    kTransluscence: ClassVar[int] = ...
    kRoughness: ClassVar[int] = ...
    kHighlightSize: ClassVar[int] = ...
    kWhiteness: ClassVar[int] = ...
    kCosinePower: ClassVar[int] = ...
    kEccentricity: ClassVar[int] = ...
    kSpecularRollOff: ClassVar[int] = ...
    kSpecularColor: ClassVar[int] = ...
    kReflectivity: ClassVar[int] = ...
    kReflectedColor: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def applyTexture(self, view: M3dView, data: MDrawData) -> Self: ...
    @staticmethod
    def defaultMaterial() -> MMaterial: ...
    def evaluateDiffuse(self) -> Self: ...
    def evaluateEmission(self) -> Self: ...
    def evaluateMaterial(self, view: M3dView, path: MDagPath) -> Self: ...
    def evaluateShininess(self) -> Self: ...
    def evaluateSpecular(self) -> Self: ...
    def evaluateTexture(self, data: MDrawData) -> Self: ...
    def getDiffuse(self) -> MColor: ...
    def getEmission(self) -> MColor: ...
    def getHasTransparency(self) -> bool: ...
    def getHwShaderNode(self) -> MPxHwShaderNode: ...
    def getShininess(self) -> float: ...
    def getSpecular(self) -> MColor: ...
    def getTextureTransformation(self, data: MDrawData, texXform: MMatrix) -> Self: ...
    def materialIsTextured(self) -> bool: ...
    def setMaterial(self, path: MDagPath, hasTransparency: bool) -> Self: ...
    def shadingEngine(self) -> MObject: ...
    def textureImage(self, image: MImage, color: tuple[1, 1, 1, 1], chan: int, dagPath: MDagPath, xRes: int = ..., yRes: int = ...) -> Self: ...  # type: ignore[valid-type]

class MMaterialArray:
    sizeIncrement: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: Incomplete) -> Incomplete: ...
    def append(self, element: MMaterial) -> Self: ...
    def clear(self) -> Self: ...
    def copy(self, source: MMaterialArray) -> Self: ...
    def insert(self, element: MMaterial, index: int) -> Self: ...
    def remove(self, index: int) -> Self: ...
    def set(self, element: MMaterial, index: int) -> Self: ...
    def setLength(self, length: int) -> Self: ...

class MPaintMessage(maya.api.OpenMaya.MMessage):
    @staticmethod
    def addVertexColorCallback(function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]

class MPanelCanvas:
    kGraphEditorUndefined: ClassVar[int] = ...
    kGraphEditorBackground: ClassVar[int] = ...
    kGraphEditorFirstDefaultDraw: ClassVar[int] = ...
    kGraphEditorGrid: ClassVar[int] = ...
    kGraphEditorAxisLabels: ClassVar[int] = ...
    kGraphEditorCurves: ClassVar[int] = ...
    kGraphEditorCurveNames: ClassVar[int] = ...
    kGraphEditorTimeMarker: ClassVar[int] = ...
    kGraphEditorRetimeToolText: ClassVar[int] = ...
    kGraphEditorLastDefaultDraw: ClassVar[int] = ...
    kGraphEditorOverlayTexture: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addPrimitive(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def createFloatVertexBuffer(self, tVals: Incomplete, yVals: Incomplete, colors: Incomplete) -> int: ...
    def createTimeVertexBuffer(self, tVals: Incomplete, yVals: Incomplete, colors: Incomplete) -> int: ...
    def createPrimitive(self, primType: Incomplete, bufferId: Incomplete, startIndex: Incomplete, numVertices: Incomplete, props: Incomplete) -> int: ...
    def destroyVertexBuffer(self, bufferId: Incomplete) -> Any: ...
    def destroyPrimitive(self, primitiveId: Incomplete) -> Any: ...
    def isAutoRefresh(self) -> bool: ...
    def isLayerVisible(self, int: int) -> bool: ...
    def registerDrawUICallback(self, layer: Incomplete, cb: Incomplete, clientData: Incomplete) -> callbackId: ...  # type: ignore[name-defined]
    def removePrimitive(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setLayerVisible(self, int: int, bool: Incomplete) -> Any: ...
    def refresh(self) -> Any: ...
    def setAutoRefresh(self) -> Any: ...
    def supportsUIDrawing(self) -> bool: ...
    def isValid(self) -> bool: ...
    def unregisterDrawUICallback(self, callbackId: Incomplete) -> Any: ...

class MDrawProperties:
    color: Incomplete
    lineWidth: Incomplete
    lineStyle: Incomplete
    pointSize: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MPanelCanvasInfo:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def getViewportBounds(self) -> Any: ...
    def getViewportSize(self) -> Any: ...
    def name(self) -> str: ...
    def setViewportBounds(self, bounds: Incomplete) -> Any: ...
    def supportsUIDrawing(self) -> bool: ...

class RenderParameters:
    baseColor: Incomplete
    unfiltered: Incomplete
    showAlphaMask: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MPxHardwareShader(maya.api.OpenMaya.MPxNode):
    kIsTransparent: ClassVar[int] = ...
    kNoTransparencyFrontBackCull: ClassVar[int] = ...
    kNoTransparencyPolygonSort: ClassVar[int] = ...
    outColor: ClassVar[maya.api.OpenMaya.MObject] = ...
    outColorR: ClassVar[maya.api.OpenMaya.MObject] = ...
    outColorG: ClassVar[maya.api.OpenMaya.MObject] = ...
    outColorB: ClassVar[maya.api.OpenMaya.MObject] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    @staticmethod
    def findResource(name: Incomplete, shaderPath: Incomplete) -> str: ...
    def getAvailableImages(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def getHardwareShader(object: MObject) -> TODO: ...  # type: ignore[name-defined]
    def profile(self) -> MRenderProfile: ...
    def renderImage(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def renderSwatchImage(self, image: MImage) -> Self: ...
    def setUniformParameters(self, parameters: MUniformParameterList, remapCurrentValues: Incomplete = ..., dagModifier: MDagModifier = ...) -> Self: ...
    def setVaryingParameters(self, parameters: MUniformParameterList, remapCurrentValues: Incomplete = ..., dagModifier: MDagModifier = ...) -> Self: ...
    def transparencyOptions(self) -> int: ...

class ShaderContext:
    path: Incomplete
    shadingEngine: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MPxHwShaderNode(maya.api.OpenMaya.MPxNode):
    kWriteNone: ClassVar[int] = ...
    kWriteVertexArray: ClassVar[int] = ...
    kWriteNormalArray: ClassVar[int] = ...
    kWriteColorArrays: ClassVar[int] = ...
    kWriteTexCoordArrays: ClassVar[int] = ...
    kWriteAll: ClassVar[int] = ...
    kDirtyNone: ClassVar[int] = ...
    kDirtyVertexArray: ClassVar[int] = ...
    kDirtyNormalArray: ClassVar[int] = ...
    kDirtyColorArrays: ClassVar[int] = ...
    kDirtyTexCoordArrays: ClassVar[int] = ...
    kDirtyAll: ClassVar[int] = ...
    kIsTransparent: ClassVar[int] = ...
    kNoTransparencyFrontBackCull: ClassVar[int] = ...
    kNoTransparencyPolygonSort: ClassVar[int] = ...
    outColor: ClassVar[maya.api.OpenMaya.MObject] = ...
    outColorR: ClassVar[maya.api.OpenMaya.MObject] = ...
    outColorG: ClassVar[maya.api.OpenMaya.MObject] = ...
    outColorB: ClassVar[maya.api.OpenMaya.MObject] = ...
    outTransparency: ClassVar[maya.api.OpenMaya.MObject] = ...
    outTransparencyR: ClassVar[maya.api.OpenMaya.MObject] = ...
    outTransparencyG: ClassVar[maya.api.OpenMaya.MObject] = ...
    outTransparencyB: ClassVar[maya.api.OpenMaya.MObject] = ...
    outMatteOpacity: ClassVar[maya.api.OpenMaya.MObject] = ...
    outMatteOpacityR: ClassVar[maya.api.OpenMaya.MObject] = ...
    outMatteOpacityG: ClassVar[maya.api.OpenMaya.MObject] = ...
    outMatteOpacityB: ClassVar[maya.api.OpenMaya.MObject] = ...
    outGlowColor: ClassVar[maya.api.OpenMaya.MObject] = ...
    outGlowColorR: ClassVar[maya.api.OpenMaya.MObject] = ...
    outGlowColorG: ClassVar[maya.api.OpenMaya.MObject] = ...
    outGlowColorB: ClassVar[maya.api.OpenMaya.MObject] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def bind(self, request: MDrawRequest, view: M3dView) -> Self: ...
    @overload
    def colorsPerVertex(self) -> int: ...
    @overload
    def colorsPerVertex(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def currentPath(self) -> MDagPath: ...
    def currentShadingEngine(self) -> MObject: ...
    def dirtyMask(self) -> int: ...
    def geometry(self, request: MDrawRequest, view: M3dView, prim: int, writable: Incomplete, indexCount: int, indexArray: Incomplete, vertexCount: int, vertexIDs: Incomplete, vertexArray: Incomplete, normalCount: int, normalArrays: Incomplete, colorCount: int, colorArrays: Incomplete, texCoordCount: int, texCoordArrays: Incomplete) -> Self: ...
    def getAvailableImages(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getColorSetNames(self, names: Incomplete) -> int: ...
    @staticmethod
    def getHwShaderNode(object: MObject) -> MPxHwShaderNode: ...
    def getTexCoordSetNames(self, names: Incomplete) -> int: ...
    def glBind(self, shapePath: MDagPath) -> Self: ...
    def glGeometry(self, shapePath: MDagPath, prim: Incomplete, writable: Incomplete, indexCount: Incomplete, indexArray: Incomplete, vertexCount: Incomplete, vertexIDs: Incomplete, vertexArray: Incomplete, normalCount: Incomplete, normalArrays: Incomplete, colorCount: Incomplete, colorArrays: Incomplete, texCoordCount: Incomplete, texCoordArrays: Incomplete) -> Self: ...
    def glUnbind(self, shapePath: MDagPath) -> Self: ...
    def hasTransparency(self) -> bool: ...
    def invertTexCoords(self) -> bool: ...
    @overload
    def normalsPerVertex(self) -> int: ...
    @overload
    def normalsPerVertex(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def provideVertexIDs(self) -> bool: ...
    def renderImage(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def renderSwatchImage(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def supportsBatching(self) -> bool: ...
    @overload
    def texCoordsPerVertex(self) -> int: ...
    @overload
    def texCoordsPerVertex(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def transparencyOptions(self) -> int: ...
    def unbind(self, request: MDrawRequest, view: M3dView) -> Self: ...

class MPxLocatorNode(maya.api.OpenMaya.MPxNode):
    underWorldObject: ClassVar[maya.api.OpenMaya.MObject] = ...
    localPosition: ClassVar[maya.api.OpenMaya.MObject] = ...
    localPositionX: ClassVar[maya.api.OpenMaya.MObject] = ...
    localPositionY: ClassVar[maya.api.OpenMaya.MObject] = ...
    localPositionZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    worldPosition: ClassVar[maya.api.OpenMaya.MObject] = ...
    worldPositionX: ClassVar[maya.api.OpenMaya.MObject] = ...
    worldPositionY: ClassVar[maya.api.OpenMaya.MObject] = ...
    worldPositionZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    localScale: ClassVar[maya.api.OpenMaya.MObject] = ...
    localScaleX: ClassVar[maya.api.OpenMaya.MObject] = ...
    localScaleY: ClassVar[maya.api.OpenMaya.MObject] = ...
    localScaleZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBox: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMin: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMinX: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMinY: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMinZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMax: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMaxX: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMaxY: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxMaxZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxSize: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxSizeX: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxSizeY: ClassVar[maya.api.OpenMaya.MObject] = ...
    nodeBoundingBoxSizeZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    center: ClassVar[maya.api.OpenMaya.MObject] = ...
    boundingBoxCenterX: ClassVar[maya.api.OpenMaya.MObject] = ...
    boundingBoxCenterY: ClassVar[maya.api.OpenMaya.MObject] = ...
    boundingBoxCenterZ: ClassVar[maya.api.OpenMaya.MObject] = ...
    matrix: ClassVar[maya.api.OpenMaya.MObject] = ...
    inverseMatrix: ClassVar[maya.api.OpenMaya.MObject] = ...
    worldMatrix: ClassVar[maya.api.OpenMaya.MObject] = ...
    worldInverseMatrix: ClassVar[maya.api.OpenMaya.MObject] = ...
    parentMatrix: ClassVar[maya.api.OpenMaya.MObject] = ...
    parentInverseMatrix: ClassVar[maya.api.OpenMaya.MObject] = ...
    visibility: ClassVar[maya.api.OpenMaya.MObject] = ...
    intermediateObject: ClassVar[maya.api.OpenMaya.MObject] = ...
    isTemplated: ClassVar[maya.api.OpenMaya.MObject] = ...
    instObjGroups: ClassVar[maya.api.OpenMaya.MObject] = ...
    objectGroups: ClassVar[maya.api.OpenMaya.MObject] = ...
    objectGrpCompList: ClassVar[maya.api.OpenMaya.MObject] = ...
    objectGroupId: ClassVar[maya.api.OpenMaya.MObject] = ...
    objectGroupColor: ClassVar[maya.api.OpenMaya.MObject] = ...
    useObjectColor: ClassVar[maya.api.OpenMaya.MObject] = ...
    objectColor: ClassVar[maya.api.OpenMaya.MObject] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def boundingBox(self) -> MBoundingBox: ...
    def closestPoint(self, rayPoint: MPoint, rayDir: MVector) -> MPoint: ...
    def color(self, status: Incomplete) -> int: ...
    def colorRGB(self, status: Incomplete) -> MColor: ...
    def draw(self, view: M3dView, path: Incomplete, style: int, status: int) -> Self: ...
    def drawLast(self) -> bool: ...
    def excludeAsLocator(self) -> bool: ...
    def isBounded(self) -> bool: ...
    def isTransparent(self) -> bool: ...
    def useClosestPointForSelection(self) -> bool: ...
    def getShapeSelectionMask(self) -> MSelectionMask: ...

class MPxManipContainer(maya.api.OpenMaya.MPxNode):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addCircleSweepManip(self, manipName: str, angleName: str) -> MDagPath: ...
    def addCurveSegmentManip(self, manipName: str, startParamName: str, endParamName: str) -> MDagPath: ...
    def addDirectionManip(self, manipName: str, directionName: str) -> MDagPath: ...
    def addDiscManip(self, manipName: str, angleName: str) -> MDagPath: ...
    def addDistanceManip(self, manipName: str, distanceName: str) -> MDagPath: ...
    def addFreePointTriadManip(self, manipName: str, pointName: str) -> MDagPath: ...
    @overload
    def addManipToPlugConversion(self, plug: MPlug) -> int: ...
    @overload
    def addManipToPlugConversion(self) -> Any: ...
    @overload
    def addManipToPlugConversion(self) -> Any: ...  # type: ignore[overload-cannot-match]
    def addMPxManipulatorNode(self, manipTypeName: str, manipName: str, proxyManip: Incomplete) -> None: ...
    def addPlugToInViewEditor(self, plug: MPlug) -> Any: ...
    def addPlugToManipConversion(self, manipIndex: int) -> Any: ...
    def addPointOnCurveManip(self, manipName: str, paramName: str) -> MDagPath: ...
    def addPointOnSurfaceManip(self, manipName: str, paramName: str) -> MDagPath: ...
    def addRotateManip(self, manipName: str, rotationName: str) -> MDagPath: ...
    def addScaleManip(self, manipName: str, scaleName: str) -> MDagPath: ...
    def addStateManip(self, manipName: str, stateName: str) -> MDagPath: ...
    def addToggleManip(self, manipName: str, toggleName: str) -> MDagPath: ...
    @staticmethod
    def addToManipConnectTable(typeId: Incomplete) -> Any: ...
    def connectToDependNode(self, node: MObject) -> None: ...
    def createChildren(self) -> None: ...
    def doPress(self) -> None: ...
    def doDrag(self) -> None: ...
    def doRelease(self) -> None: ...
    def draw(self, view: M3dView, path: MDagPath, style: M3dView.DisplayStyle, status: M3dView.DisplayStatus) -> None: ...
    def drawUI(self, drawManager: MUIDrawManager, frameContext: MFrameContext) -> None: ...
    def finishAddingManips(self) -> Any: ...
    def getConverterManipDoubleValue(self) -> float: ...
    def getConverterManipMEulerRotationValue(self) -> MEulereRotation: ...  # type: ignore[name-defined]
    def getConverterManipMMatrixValue(self) -> MMatrix: ...
    def getConverterManipMPointValue(self) -> MPoint: ...
    def getConverterManipMTransformationMatrixValue(self) -> MTransformationMatrix: ...
    def getConverterManipMVectorValue(self) -> MVector: ...
    def getConverterManipUIntValue(self) -> int: ...
    def getConverterManipValues(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def getConverterPlugDoubleValue(self) -> float: ...
    def getConverterPlugMEulerRotationValue(self) -> MEulerRotation: ...
    def getConverterPlugMMatrixValue(self) -> MMatrix: ...
    def getConverterPlugMPointValue(self) -> MPoint: ...
    def getConverterPlugMVectorValue(self) -> MVector: ...
    def getConverterPlugValues(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    @staticmethod
    def initialize() -> None: ...
    def isManipActive(self, manipName: Incomplete, stateName: Incomplete) -> MDagPath: ...
    def manipToPlugConversion(self, manipIndex: int) -> MManipData: ...
    @staticmethod
    def newManipulator(*args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def plugToManipConversion(self, manipIndex: Incomplete) -> MManipData: ...
    def preDrawUI(self, view: M3dView) -> None: ...
    @staticmethod
    def removeFromManipConnectTable(typeId: Incomplete) -> Any: ...

class MPxSurfaceShapeUI:
    kSelectMeshUVs: ClassVar[int] = ...
    kSelectMeshVerts: ClassVar[int] = ...
    kSelectMeshFaces: ClassVar[int] = ...
    kSelectMeshEdges: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def canDrawUV(self) -> bool: ...
    def drawUV(self, view: M3dView, info: MTextureEditorDrawInfo) -> Self: ...
    def material(self, path: Incomplete) -> MMaterial: ...
    def materials(self, path: MDagPath, componentFilter: Incomplete, materials: Incomplete, componentSet: Incomplete = ...) -> Self: ...
    def select(self, selectInfo: MSelectInfo, selectionList: MSelectionList, worldSpaceSelectPts: Incomplete) -> bool: ...
    def selectUV(self, view: M3dView, selType: int, xmin: int, ymin: int, xmax: int, ymax: int, singleSelect: bool, selList: MSelectionList) -> bool: ...
    def snap(self, snapInfo: MSelectInfo) -> bool: ...
    def surfaceShape(self) -> MPxSurfaceShape: ...
    @staticmethod
    def surfaceShapeUI(path: MDagPath) -> MPxSurfaceShapeUI: ...

class MPxDragAndDropBehavior:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def shouldBeUsedFor(self, sourceNode: MObject, destinationNode: MObject, sourcePlug: Incomplete, destinationPlug: Incomplete) -> bool: ...
    def connectAttrToAttr(self, sourcePlug: MPlug, destinationPlug: MPlug, force: bool) -> None: ...
    def connectAttrToNode(self, sourcePlug: MPlug, destinationNode: MObject, force: bool) -> None: ...
    def connectNodeToAttr(self, sourceNode: MObject, destinationPlug: MPlug, force: bool) -> None: ...
    def connectNodeToNode(self, sourceNode: MObject, destinationNode: MObject, force: bool) -> None: ...

class MPxContext:
    kImage1: ClassVar[int] = ...
    kImage2: ClassVar[int] = ...
    kImage3: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def toolOnSetup(self, event: MEvent) -> None: ...
    def toolOffCleanup(self) -> None: ...
    def doPress(self, event: MEvent, drawMgr: Incomplete, context: Incomplete) -> None: ...
    def doRelease(self, event: MEvent, drawMgr: Incomplete, context: Incomplete) -> None: ...
    def doDrag(self, event: MEvent, drawMgr: Incomplete, context: Incomplete) -> None: ...
    def doHold(self, event: MEvent, drawMgr: Incomplete, context: Incomplete) -> None: ...
    def drawFeedback(self, event: Incomplete, drawMgr: Incomplete, context: Incomplete) -> None: ...
    def doPtrMoved(self, event: MEvent, drawMgr: Incomplete, context: Incomplete) -> None: ...
    def doPressLegacy(self, event: MEvent) -> None: ...
    def doReleaseLegacy(self, event: MEvent) -> None: ...
    def doDragLegacy(self, event: MEvent) -> None: ...
    def doHoldLegacy(self, event: MEvent) -> None: ...
    def doPtrMovedLegacy(self, event: MEvent) -> None: ...
    def doEnterRegion(self, event: MEvent) -> None: ...
    def doExitRegion(self, event: MEvent) -> None: ...
    def helpStateHasChanged(self, event: MEvent) -> None: ...
    def deleteAction(self) -> None: ...
    def completeAction(self) -> None: ...
    def addManipulator(self, manipulator: MObject) -> None: ...
    def deleteManipulators(self) -> None: ...
    def setImage(self, image: str, index: ImageIndex) -> Self: ...  # type: ignore[name-defined]
    def image(self, index: ImageIndex) -> str: ...  # type: ignore[name-defined]
    def abortAction(self) -> None: ...
    def processNumericalInput(self, values: MDoubleArray, flags: MIntArray, isAbsolute: bool) -> bool: ...
    def feedbackNumericalInput(self) -> bool: ...
    def argTypeNumericalInput(self, index: int) -> MSyntax.MArgType: ...
    def setHelpString(self, str: str) -> Self: ...
    def setTitleString(self, str: str) -> Self: ...
    def setCursor(self, newCursor: MCursor) -> Self: ...
    def beginMarquee(self, event: MEvent) -> Self: ...
    def dragMarquee(self, event: MEvent) -> Self: ...
    def releaseMarquee(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def newToolCommand(self) -> MPxToolCommand: ...
    @overload
    def stringClassName(self) -> str: ...
    @overload
    def stringClassName(self: Incomplete) -> Any: ...
    def inAlternateContext(self) -> bool: ...

class MPxContextCommand:
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def doEditFlags(self) -> None: ...
    def doQueryFlags(self) -> None: ...
    @overload
    def makeObj(self) -> MPxContext: ...
    @overload
    def makeObj(self: Incomplete) -> Any: ...
    def appendSyntax(self) -> None: ...
    def parser(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setResult(self) -> None: ...
    def syntax(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MSelectInfo(MDrawInfo):
    highestPriority: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addSelection(self, item: MSelectionList, point: MPoint, list: s, points: Incomplete, mask: MSelectionMask, isComponent: bool) -> Self: ...  # type: ignore[name-defined]
    def getAlignmentMatrix(self) -> MMatrix: ...
    def getLocalRay(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def isRay(self) -> bool: ...
    def selectClosest(self) -> bool: ...
    def selectForHilite(self, mask: MSelectionMask) -> bool: ...
    def selectOnHilitedOnly(self) -> bool: ...
    def selectPath(self) -> MDagPath: ...
    def selectRect(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def selectable(self, mask: MSelectionMask) -> bool: ...
    def selectableComponent(self, displayed: bool, mask: MSelectionMask) -> bool: ...
    @overload
    def setSnapPoint(self, point: MPoint) -> bool: ...
    @overload
    def setSnapPoint(self) -> Any: ...
    def singleSelection(self) -> bool: ...
    def view(self) -> M3dView: ...

class MPxSelectionContext(MPxContext):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def addManipulator(self, manipulator: MObject) -> None: ...
    def deleteManipulators(self) -> None: ...
    def setAllowPreSelectHilight(self) -> None: ...
    def setAllowSoftSelect(self) -> None: ...
    def setAllowSymmetry(self) -> None: ...
    def setAllowDoubleClickAction(self) -> None: ...
    def setAllowPaintSelect(self) -> None: ...
    def doDragLegacy(self, event: MEvent) -> None: ...
    def doHoldLegacy(self, event: MEvent) -> None: ...
    def doPressLegacy(self, event: MEvent) -> None: ...
    def doReleaseLegacy(self, event: MEvent) -> None: ...
    def doDrag(self, event: MEvent, drawManager: MUIDrawManager, frameContext: MFrameContext) -> None: ...
    def doHold(self, event: MEvent, drawManager: MUIDrawManager, frameContext: MFrameContext) -> None: ...
    def doPress(self, event: MEvent, drawManager: MUIDrawManager, frameContext: MFrameContext) -> None: ...
    def doRelease(self, event: MEvent, drawManager: MUIDrawManager, frameContext: MFrameContext) -> None: ...
    def helpStateHasChanged(self, event: MEvent) -> None: ...
    def abortAction(self) -> None: ...
    def processNumericalInput(self, values: MDoubleArray, flags: MIntArray, isAbsolute: bool) -> bool: ...
    def feedbackNumericalInput(self) -> bool: ...
    def argTypeNumericalInput(self, index: int) -> MSyntax.MArgType: ...
    def setImage(self, image: str, index: ImageIndex) -> Self: ...  # type: ignore[name-defined]
    def image(self, index: ImageIndex) -> str: ...  # type: ignore[name-defined]
    def isSelecting(self) -> bool: ...
    def startPoint(self) -> MPoint: ...
    def lastDragPoint(self) -> MPoint: ...
    def newToolCommand(self) -> MPxToolCommand: ...

class MTextureEditorDrawInfo:
    kDrawFunctionFirst: ClassVar[int] = ...
    kDrawWireframe: ClassVar[int] = ...
    kDrawEverything: ClassVar[int] = ...
    kDrawVertexForSelect: ClassVar[int] = ...
    kDrawEdgeForSelect: ClassVar[int] = ...
    kDrawFacetForSelect: ClassVar[int] = ...
    kDrawUVForSelect: ClassVar[int] = ...
    kDrawFunctionLast: ClassVar[int] = ...
    drawingFunction: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class MPxToolCommand(maya.api.OpenMaya.MPxCommand):
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def doIt(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def cancel(self) -> None: ...
    def finalize(self) -> None: ...
    def doFinalize(self) -> None: ...

class MUiMessage(maya.api.OpenMaya.MMessage):
    @staticmethod
    def addUiDeletedCallback(uiName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def addCameraChangedCallback(panelName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def add3dViewDestroyMsgCallback(panelName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def add3dViewPreRenderMsgCallback(panelName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def add3dViewPostRenderMsgCallback(panelName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def add3dViewRendererChangedCallback(panelName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]
    @staticmethod
    def add3dViewRenderOverrideChangedCallback(panelName: str, function: Incomplete, clientData: Incomplete = ...) -> id: ...  # type: ignore[valid-type]

class MTimeSliderCustomDrawManager:
    kAbove: ClassVar[int] = ...
    kBelow: ClassVar[int] = ...
    kOn: ClassVar[int] = ...
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def registerCustomDrawOn(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def registerCustomDrawOutside(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDrawPrimitives(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def clearDrawPrimitives(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def deregisterCustomDraw(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDrawVisible(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def requestTimeSliderRedraw(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setBackgroundColor(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDrawLayer(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDrawHeight(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDrawLocation(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setDrawPriority(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setStartPrimitiveEditFunction(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setEditPrimitiveFunction(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setStopPrimitiveEditFunction(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setTooltip(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...
    def setSetCopyPrimitivesFunction(self, *args: Incomplete, **kwargs: Incomplete) -> Incomplete: ...

class MTimeSliderDrawPrimitive:
    kFilledRect: ClassVar[int] = ...
    kUpperOutline: ClassVar[int] = ...
    kFullOutline: ClassVar[int] = ...
    kVerticalLine: ClassVar[int] = ...
    kBracket: ClassVar[int] = ...
    kFrameFlag: ClassVar[int] = ...
    kNone: ClassVar[int] = ...
    kMovePrimitive: ClassVar[int] = ...
    kMoveStartTime: ClassVar[int] = ...
    kMoveEndTime: ClassVar[int] = ...
    priority: Incomplete
    drawType: Incomplete
    startTime: Incomplete
    endTime: Incomplete
    height: Incomplete
    bottom: Incomplete
    color: Incomplete
    label: Incomplete
    tooltip: Incomplete
    def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

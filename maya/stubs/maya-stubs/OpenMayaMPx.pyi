import maya.OpenMaya
from _typeshed import Incomplete
from maya._OpenMayaMPx import getLockCaptureCount as getLockCaptureCount  # type: ignore[import-untyped]
from typing import Callable, ClassVar

class _SwigNonDynamicMeta(type):
    __setattr__: ClassVar[Callable] = ...

class charPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class intPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class shortPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class floatPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class doublePtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class boolPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class uIntPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...

class uCharPtr:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def value(cls, *args, **kwargs): ...
    @classmethod
    def cast(cls, *args, **kwargs): ...
    @staticmethod
    def frompointer(*args, **kwargs): ...
PLUGIN_COMPANY: str

class MFnPlugin(maya.OpenMaya.MFnBase):
    kImageFilePriorityHighest: ClassVar[int] = ...
    kImageFilePriorityHigh: ClassVar[int] = ...
    kImageFilePriorityLow: ClassVar[int] = ...
    kImageFilePriorityLowest: ClassVar[int] = ...
    kImageFilePriorityDefault: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    kDefaultDataLocation: ClassVar[SwigPyObject] = ...  # type: ignore[name-defined]
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def vendor(cls, *args, **kwargs): ...
    @classmethod
    def version(cls, *args, **kwargs): ...
    @classmethod
    def apiVersion(cls, *args, **kwargs): ...
    @classmethod
    def name(cls, *args, **kwargs): ...
    @classmethod
    def loadPath(cls, *args, **kwargs): ...
    @classmethod
    def setName(cls, *args, **kwargs): ...
    @classmethod
    def setVersion(cls, *args, **kwargs): ...
    @classmethod
    def registerCommand(cls, *args, **kwargs): ...
    @classmethod
    def deregisterCommand(cls, *args, **kwargs): ...
    @classmethod
    def registerControlCommand(cls, *args, **kwargs): ...
    @classmethod
    def deregisterControlCommand(cls, *args, **kwargs): ...
    @classmethod
    def registerModelEditorCommand(cls, *args, **kwargs): ...
    @classmethod
    def deregisterModelEditorCommand(cls, *args, **kwargs): ...
    @classmethod
    def registerConstraintCommand(cls, *args, **kwargs): ...
    @classmethod
    def deregisterConstraintCommand(cls, *args, **kwargs): ...
    @classmethod
    def registerContextCommand(cls, *args, **kwargs): ...
    @classmethod
    def deregisterContextCommand(cls, *args, **kwargs): ...
    @classmethod
    def registerNode(cls, *args, **kwargs): ...
    @classmethod
    def deregisterNode(cls, *args, **kwargs): ...
    @classmethod
    def registerEvaluator(cls, *args, **kwargs): ...
    @classmethod
    def deregisterEvaluator(cls, *args, **kwargs): ...
    @classmethod
    def registerTopologyEvaluator(cls, *args, **kwargs): ...
    @classmethod
    def deregisterTopologyEvaluator(cls, *args, **kwargs): ...
    @classmethod
    def registerShape(cls, *args, **kwargs): ...
    @classmethod
    def registerTransform(cls, *args, **kwargs): ...
    @classmethod
    def registerData(cls, *args, **kwargs): ...
    @classmethod
    def deregisterData(cls, *args, **kwargs): ...
    @classmethod
    def registerDevice(cls, *args, **kwargs): ...
    @classmethod
    def deregisterDevice(cls, *args, **kwargs): ...
    @classmethod
    def registerFileTranslator(cls, *args, **kwargs): ...
    @classmethod
    def deregisterFileTranslator(cls, *args, **kwargs): ...
    @classmethod
    def registerURIFileResolver(cls, *args, **kwargs): ...
    @classmethod
    def deregisterURIFileResolver(cls, *args, **kwargs): ...
    @classmethod
    def registerIkSolver(cls, *args, **kwargs): ...
    @classmethod
    def deregisterIkSolver(cls, *args, **kwargs): ...
    @classmethod
    def registerCacheFormat(cls, *args, **kwargs): ...
    @classmethod
    def deregisterCacheFormat(cls, *args, **kwargs): ...
    @classmethod
    def registerUIStrings(cls, *args, **kwargs): ...
    @classmethod
    def registerUI(cls, *args, **kwargs): ...
    @classmethod
    def registerDragAndDropBehavior(cls, *args, **kwargs): ...
    @classmethod
    def deregisterDragAndDropBehavior(cls, *args, **kwargs): ...
    @classmethod
    def registerImageFile(cls, *args, **kwargs): ...
    @classmethod
    def deregisterImageFile(cls, *args, **kwargs): ...
    @classmethod
    def registerRenderPassImpl(cls, *args, **kwargs): ...
    @classmethod
    def deregisterRenderPassImpl(cls, *args, **kwargs): ...
    @classmethod
    def registerAttributePatternFactory(cls, *args, **kwargs): ...
    @classmethod
    def deregisterAttributePatternFactory(cls, *args, **kwargs): ...
    @classmethod
    def registerAnimCurveInterpolator(cls, *args, **kwargs): ...
    @classmethod
    def deregisterAnimCurveInterpolator(cls, *args, **kwargs): ...
    @classmethod
    def registerDisplayFilter(cls, *args, **kwargs): ...
    @classmethod
    def deregisterDisplayFilter(cls, *args, **kwargs): ...
    @classmethod
    def registerRenderer(cls, *args, **kwargs): ...
    @classmethod
    def deregisterRenderer(cls, *args, **kwargs): ...
    @staticmethod
    def findPlugin(*args, **kwargs): ...
    @staticmethod
    def isNodeRegistered(*args, **kwargs): ...
    @classmethod
    def matrixTypeIdFromXformId(cls, *args, **kwargs): ...
    @classmethod
    def addMenuItem(cls, *args, **kwargs): ...
    @classmethod
    def removeMenuItem(cls, *args, **kwargs): ...
    @classmethod
    def registerMaterialInfo(cls, *args, **kwargs): ...
    @classmethod
    def unregisterMaterialInfo(cls, *args, **kwargs): ...
    @classmethod
    def registerBakeEngine(cls, *args, **kwargs): ...
    @classmethod
    def unregisterBakeEngine(cls, *args, **kwargs): ...
    @staticmethod
    def setRegisteringCallableScript(*args, **kwargs): ...
    @staticmethod
    def registeringCallableScript(*args, **kwargs): ...
    @classmethod
    def setCallableInfo(cls, *args, **kwargs): ...
    @classmethod
    def getCallableInfo(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
cvar: swigvarlink  # type: ignore[name-defined]

class MPxNode:
    kDependNode: ClassVar[int] = ...
    kLocatorNode: ClassVar[int] = ...
    kDeformerNode: ClassVar[int] = ...
    kManipContainer: ClassVar[int] = ...
    kSurfaceShape: ClassVar[int] = ...
    kFieldNode: ClassVar[int] = ...
    kEmitterNode: ClassVar[int] = ...
    kSpringNode: ClassVar[int] = ...
    kIkSolverNode: ClassVar[int] = ...
    kHardwareShader: ClassVar[int] = ...
    kHwShaderNode: ClassVar[int] = ...
    kTransformNode: ClassVar[int] = ...
    kObjectSet: ClassVar[int] = ...
    kFluidEmitterNode: ClassVar[int] = ...
    kImagePlaneNode: ClassVar[int] = ...
    kParticleAttributeMapperNode: ClassVar[int] = ...
    kCameraSetNode: ClassVar[int] = ...
    kConstraintNode: ClassVar[int] = ...
    kManipulatorNode: ClassVar[int] = ...
    kMotionPathNode: ClassVar[int] = ...
    kClientDeviceNode: ClassVar[int] = ...
    kThreadedDeviceNode: ClassVar[int] = ...
    kAssembly: ClassVar[int] = ...
    kSkinCluster: ClassVar[int] = ...
    kGeometryFilter: ClassVar[int] = ...
    kBlendShape: ClassVar[int] = ...
    kLast: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    kEvaluatedIndirectly: ClassVar[int] = ...
    kEvaluatedDirectly: ClassVar[int] = ...
    kLeaveDirty: ClassVar[int] = ...
    kPostEvaluationTypeLast: ClassVar[int] = ...
    kParallel: ClassVar[int] = ...
    kSerial: ClassVar[int] = ...
    kGloballySerial: ClassVar[int] = ...
    kUntrusted: ClassVar[int] = ...
    kSchedulingTypeLast: ClassVar[int] = ...
    kDefaultScheduling: ClassVar[int] = ...
    kSerialize: ClassVar[int] = ...
    kGloballySerialize: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    message: Incomplete
    isHistoricallyInteresting: Incomplete
    caching: Incomplete
    state: Incomplete
    frozen: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def postConstructor(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @classmethod
    def getInternalValue(cls, *args, **kwargs): ...
    @classmethod
    def setInternalValue(cls, *args, **kwargs): ...
    @classmethod
    def copyInternalData(cls, *args, **kwargs): ...
    @classmethod
    def legalConnection(cls, *args, **kwargs): ...
    @classmethod
    def legalDisconnection(cls, *args, **kwargs): ...
    @classmethod
    def setDependentsDirty(cls, *args, **kwargs): ...
    @classmethod
    def preEvaluation(cls, *args, **kwargs): ...
    @classmethod
    def postEvaluation(cls, *args, **kwargs): ...
    @classmethod
    def schedulingType(cls, *args, **kwargs): ...
    @classmethod
    def getCacheSetup(cls, *args, **kwargs): ...
    @classmethod
    def configCache(cls, *args, **kwargs): ...
    @classmethod
    def transformInvalidationRange(cls, *args, **kwargs): ...
    @classmethod
    def hasInvalidationRangeTransformation(cls, *args, **kwargs): ...
    @classmethod
    def connectionMade(cls, *args, **kwargs): ...
    @classmethod
    def connectionBroken(cls, *args, **kwargs): ...
    @classmethod
    def dependsOn(cls, *args, **kwargs): ...
    @classmethod
    def isPassiveOutput(cls, *args, **kwargs): ...
    @classmethod
    def shouldSave(cls, *args, **kwargs): ...
    @classmethod
    def passThroughToOne(cls, *args, **kwargs): ...
    @classmethod
    def passThroughToMany(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def isAbstractClass(cls, *args, **kwargs): ...
    @classmethod
    def isTrackingTopology(cls, *args, **kwargs): ...
    @staticmethod
    def addAttribute(*args, **kwargs): ...
    @staticmethod
    def inheritAttributesFrom(*args, **kwargs): ...
    @staticmethod
    def attributeAffects(*args, **kwargs): ...
    @classmethod
    def getFilesToArchive(cls, *args, **kwargs): ...
    @classmethod
    def getExternalContent(cls, *args, **kwargs): ...
    @classmethod
    def addExternalContentForFileAttr(cls, *args, **kwargs): ...
    @classmethod
    def setExternalContentForFileAttr(cls, *args, **kwargs): ...
    @classmethod
    def setExternalContent(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def typeId(cls, *args, **kwargs): ...
    @classmethod
    def typeName(cls, *args, **kwargs): ...
    @classmethod
    def name(cls, *args, **kwargs): ...
    @classmethod
    def thisMObject(cls, *args, **kwargs): ...
    @classmethod
    def setExistWithoutInConnections(cls, *args, **kwargs): ...
    @classmethod
    def existWithoutInConnections(cls, *args, **kwargs): ...
    @classmethod
    def setExistWithoutOutConnections(cls, *args, **kwargs): ...
    @classmethod
    def existWithoutOutConnections(cls, *args, **kwargs): ...
    @classmethod
    def getInternalValueInContext(cls, *args, **kwargs): ...
    @classmethod
    def setInternalValueInContext(cls, *args, **kwargs): ...
    @classmethod
    def internalArrayCount(cls, *args, **kwargs): ...

class MPxCommand:
    __init__: ClassVar[Callable] = ...
    kLong: ClassVar[int] = ...
    kDouble: ClassVar[int] = ...
    kString: ClassVar[int] = ...
    kNoArg: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def doIt(cls, *args, **kwargs): ...
    @classmethod
    def undoIt(cls, *args, **kwargs): ...
    @classmethod
    def redoIt(cls, *args, **kwargs): ...
    @classmethod
    def isUndoable(cls, *args, **kwargs): ...
    @classmethod
    def hasSyntax(cls, *args, **kwargs): ...
    @classmethod
    def syntax(cls, *args, **kwargs): ...
    @classmethod
    def isHistoryOn(cls, *args, **kwargs): ...
    @classmethod
    def commandString(cls, *args, **kwargs): ...
    @classmethod
    def setHistoryOn(cls, *args, **kwargs): ...
    @classmethod
    def setCommandString(cls, *args, **kwargs): ...
    @staticmethod
    def displayInfo(*args, **kwargs): ...
    @staticmethod
    def displayWarning(*args, **kwargs): ...
    @staticmethod
    def displayError(*args, **kwargs): ...
    @staticmethod
    def clearResult(*args, **kwargs): ...
    @staticmethod
    def setResult(*args, **kwargs): ...
    @staticmethod
    def appendToResult(*args, **kwargs): ...
    @staticmethod
    def isCurrentResultArray(*args, **kwargs): ...
    @staticmethod
    def currentResultType(*args, **kwargs): ...
    @staticmethod
    def getCurrentResult(*args, **kwargs): ...
    @staticmethod
    def currentIntResult(*args, **kwargs): ...
    @staticmethod
    def currentDoubleResult(*args, **kwargs): ...
    @staticmethod
    def currentStringResult(*args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def setUndoable(cls, *args, **kwargs): ...

class MPxAttributePatternFactory:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def createPatternsFromString(cls, *args, **kwargs): ...
    @classmethod
    def createPatternsFromFile(cls, *args, **kwargs): ...
    @classmethod
    def name(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxBakeEngine:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def setNeedTransparency(cls, *args, **kwargs): ...
    @classmethod
    def getUVRange(cls, *args, **kwargs): ...
    @classmethod
    def bake(cls, *args, **kwargs): ...

class MPxSurfaceShape(MPxNode):
    __init__: ClassVar[Callable] = ...
    kNoPointCaching: ClassVar[int] = ...
    kSavePoints: ClassVar[int] = ...
    kRestorePoints: ClassVar[int] = ...
    kUpdatePoints: ClassVar[int] = ...
    kTransformOriginalPoints: ClassVar[int] = ...
    kNormal: ClassVar[int] = ...
    kUTangent: ClassVar[int] = ...
    kVTangent: ClassVar[int] = ...
    kUVNTriad: ClassVar[int] = ...
    kMatchOk: ClassVar[int] = ...
    kMatchNone: ClassVar[int] = ...
    kMatchTooMany: ClassVar[int] = ...
    kMatchInvalidName: ClassVar[int] = ...
    kMatchInvalidAttribute: ClassVar[int] = ...
    kMatchInvalidAttributeIndex: ClassVar[int] = ...
    kMatchInvalidAttributeRange: ClassVar[int] = ...
    kMatchInvalidAttributeDim: ClassVar[int] = ...
    kObjectChanged: ClassVar[int] = ...
    kBoundingBoxChanged: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    mHasHistoryOnCreate: Incomplete
    mControlPoints: Incomplete
    mControlValueX: Incomplete
    mControlValueY: Incomplete
    mControlValueZ: Incomplete
    nodeBoundingBox: Incomplete
    nodeBoundingBoxMin: Incomplete
    nodeBoundingBoxMinX: Incomplete
    nodeBoundingBoxMinY: Incomplete
    nodeBoundingBoxMinZ: Incomplete
    nodeBoundingBoxMax: Incomplete
    nodeBoundingBoxMaxX: Incomplete
    nodeBoundingBoxMaxY: Incomplete
    nodeBoundingBoxMaxZ: Incomplete
    nodeBoundingBoxSize: Incomplete
    nodeBoundingBoxSizeX: Incomplete
    nodeBoundingBoxSizeY: Incomplete
    nodeBoundingBoxSizeZ: Incomplete
    center: Incomplete
    boundingBoxCenterX: Incomplete
    boundingBoxCenterY: Incomplete
    boundingBoxCenterZ: Incomplete
    matrix: Incomplete
    inverseMatrix: Incomplete
    worldMatrix: Incomplete
    worldInverseMatrix: Incomplete
    parentMatrix: Incomplete
    parentInverseMatrix: Incomplete
    visibility: Incomplete
    intermediateObject: Incomplete
    isTemplated: Incomplete
    instObjGroups: Incomplete
    objectGroups: Incomplete
    objectGrpCompList: Incomplete
    objectGroupId: Incomplete
    objectGroupColor: Incomplete
    useObjectColor: Incomplete
    objectColor: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def isBounded(cls, *args, **kwargs): ...
    @classmethod
    def boundingBox(cls, *args, **kwargs): ...
    @classmethod
    def evalNodeAffectsDrawDb(cls, *args, **kwargs): ...
    @classmethod
    def transformUsing(cls, *args, **kwargs): ...
    @classmethod
    def tweakUsing(cls, *args, **kwargs): ...
    @classmethod
    def convertToTweakNodePlug(cls, *args, **kwargs): ...
    @classmethod
    def weightedTransformUsing(cls, *args, **kwargs): ...
    @classmethod
    def weightedTweakUsing(cls, *args, **kwargs): ...
    @classmethod
    def vertexOffsetDirection(cls, *args, **kwargs): ...
    @classmethod
    def newControlPointComponent(cls, *args, **kwargs): ...
    @classmethod
    def componentToPlugs(cls, *args, **kwargs): ...
    @classmethod
    def match(cls, *args, **kwargs): ...
    @classmethod
    def matchComponent(cls, *args, **kwargs): ...
    @classmethod
    def getShapeSelectionMask(cls, *args, **kwargs): ...
    @classmethod
    def getComponentSelectionMask(cls, *args, **kwargs): ...
    @classmethod
    def createFullVertexGroup(cls, *args, **kwargs): ...
    @classmethod
    def createFullRenderGroup(cls, *args, **kwargs): ...
    @classmethod
    def renderGroupComponentType(cls, *args, **kwargs): ...
    @classmethod
    def deleteComponents(cls, *args, **kwargs): ...
    @classmethod
    def undeleteComponents(cls, *args, **kwargs): ...
    @classmethod
    def localShapeInAttr(cls, *args, **kwargs): ...
    @classmethod
    def localShapeOutAttr(cls, *args, **kwargs): ...
    @classmethod
    def worldShapeOutAttr(cls, *args, **kwargs): ...
    @classmethod
    def cachedShapeAttr(cls, *args, **kwargs): ...
    @classmethod
    def geometryData(cls, *args, **kwargs): ...
    @classmethod
    def canMakeLive(cls, *args, **kwargs): ...
    @classmethod
    def closestPoint(cls, *args, **kwargs): ...
    @classmethod
    def pointAtParm(cls, *args, **kwargs): ...
    @classmethod
    def geometryIteratorSetup(cls, *args, **kwargs): ...
    @classmethod
    def acceptsGeometryIterator(cls, *args, **kwargs): ...
    @classmethod
    def excludeAsPluginShape(cls, *args, **kwargs): ...
    @classmethod
    def extendSelectionFromComponents(cls, *args, **kwargs): ...
    @classmethod
    def activeComponents(cls, *args, **kwargs): ...
    @classmethod
    def hasActiveComponents(cls, *args, **kwargs): ...
    @classmethod
    def childChanged(cls, *args, **kwargs): ...
    @classmethod
    def isRenderable(cls, *args, **kwargs): ...
    @classmethod
    def setRenderable(cls, *args, **kwargs): ...
    @classmethod
    def getWorldMatrix(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxComponentShape(MPxSurfaceShape):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def transformUsing(cls, *args, **kwargs): ...
    @classmethod
    def componentToPlugs(cls, *args, **kwargs): ...
    @classmethod
    def match(cls, *args, **kwargs): ...
    @classmethod
    def createFullVertexGroup(cls, *args, **kwargs): ...
    @classmethod
    def localShapeInAttr(cls, *args, **kwargs): ...
    @classmethod
    def getControlPoints(cls, *args, **kwargs): ...
    @classmethod
    def setControlPoints(cls, *args, **kwargs): ...
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...

class MPxData:
    kData: ClassVar[int] = ...
    kGeometryData: ClassVar[int] = ...
    kLast: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def readASCII(cls, *args, **kwargs): ...
    @classmethod
    def readBinary(cls, *args, **kwargs): ...
    @classmethod
    def writeASCII(cls, *args, **kwargs): ...
    @classmethod
    def writeBinary(cls, *args, **kwargs): ...
    @classmethod
    def copy(cls, *args, **kwargs): ...
    @classmethod
    def typeId(cls, *args, **kwargs): ...
    @classmethod
    def name(cls, *args, **kwargs): ...

class MPxCameraSet(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    cameraLayer: Incomplete
    camera: Incomplete
    sceneData: Incomplete
    active: Incomplete
    order: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxEditData:
    __init__: ClassVar[Callable] = ...
    _setValue: ClassVar[Callable] = ...
    _getValue: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def isEqual(cls, *args, **kwargs): ...
    @classmethod
    def isLessThan(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def performIsEqual(cls, *args, **kwargs): ...
    @classmethod
    def performIsLessThan(cls, *args, **kwargs): ...

class MExternalContentInfoTable:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def addResolvedEntry(cls, *args, **kwargs): ...
    @classmethod
    def addUnresolvedEntry(cls, *args, **kwargs): ...
    @classmethod
    def length(cls, *args, **kwargs): ...
    @classmethod
    def getInfoByKey(cls, *args, **kwargs): ...
    @classmethod
    def getEntryByIndex(cls, *args, **kwargs): ...

class MExternalContentLocationTable:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def addEntry(cls, *args, **kwargs): ...
    @classmethod
    def length(cls, *args, **kwargs): ...
    @classmethod
    def getLocationByKey(cls, *args, **kwargs): ...
    @classmethod
    def getEntryByIndex(cls, *args, **kwargs): ...

class MPxFileResolver:
    kNone: ClassVar[int] = ...
    kInput: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def resolveURI(cls, *args, **kwargs): ...
    @classmethod
    def resolveURIWithContext(cls, *args, **kwargs): ...
    @classmethod
    def uriScheme(cls, *args, **kwargs): ...
    @classmethod
    def resolverName(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def performAfterSaveURI(cls, *args, **kwargs): ...
    @staticmethod
    def findURIResolverByScheme(*args, **kwargs): ...
    @staticmethod
    def findURIResolverByName(*args, **kwargs): ...
    @staticmethod
    def getURIResolversByScheme(*args, **kwargs): ...
    @staticmethod
    def getURIResolversByName(*args, **kwargs): ...
    @staticmethod
    def numURIResolvers(*args, **kwargs): ...

class MPxFileTranslator:
    kIsMyFileType: ClassVar[int] = ...
    kCouldBeMyFileType: ClassVar[int] = ...
    kNotMyFileType: ClassVar[int] = ...
    kUnknownAccessMode: ClassVar[int] = ...
    kOpenAccessMode: ClassVar[int] = ...
    kReferenceAccessMode: ClassVar[int] = ...
    kImportAccessMode: ClassVar[int] = ...
    kSaveAccessMode: ClassVar[int] = ...
    kExportAccessMode: ClassVar[int] = ...
    kExportActiveAccessMode: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def reader(cls, *args, **kwargs): ...
    @classmethod
    def writer(cls, *args, **kwargs): ...
    @classmethod
    def haveReadMethod(cls, *args, **kwargs): ...
    @classmethod
    def haveWriteMethod(cls, *args, **kwargs): ...
    @classmethod
    def haveNamespaceSupport(cls, *args, **kwargs): ...
    @classmethod
    def haveReferenceMethod(cls, *args, **kwargs): ...
    @classmethod
    def allowMultipleFileOptimization(cls, *args, **kwargs): ...
    @classmethod
    def defaultExtension(cls, *args, **kwargs): ...
    @classmethod
    def filter(cls, *args, **kwargs): ...
    @classmethod
    def canBeOpened(cls, *args, **kwargs): ...
    @classmethod
    def identifyFile(cls, *args, **kwargs): ...
    @staticmethod
    def fileAccessMode(*args, **kwargs): ...

class MPxGeometryData(MPxData):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def iterator(cls, *args, **kwargs): ...
    @classmethod
    def updateCompleteVertexGroup(cls, *args, **kwargs): ...
    @classmethod
    def deleteComponent(cls, *args, **kwargs): ...
    @classmethod
    def deleteComponentsFromGroups(cls, *args, **kwargs): ...
    @classmethod
    def smartCopy(cls, *args, **kwargs): ...
    @classmethod
    def copy(cls, *args, **kwargs): ...
    @classmethod
    def typeId(cls, *args, **kwargs): ...
    @classmethod
    def name(cls, *args, **kwargs): ...
    @classmethod
    def setMatrix(cls, *args, **kwargs): ...
    @classmethod
    def matrix(cls, *args, **kwargs): ...

class MPxGeometryIterator:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def isDone(cls, *args, **kwargs): ...
    @classmethod
    def next(cls, *args, **kwargs): ...
    @classmethod
    def reset(cls, *args, **kwargs): ...
    @classmethod
    def component(cls, *args, **kwargs): ...
    @classmethod
    def hasPoints(cls, *args, **kwargs): ...
    @classmethod
    def iteratorCount(cls, *args, **kwargs): ...
    @classmethod
    def point(cls, *args, **kwargs): ...
    @classmethod
    def setPoint(cls, *args, **kwargs): ...
    @classmethod
    def setPointGetNext(cls, *args, **kwargs): ...
    @classmethod
    def index(cls, *args, **kwargs): ...
    @classmethod
    def hasNormals(cls, *args, **kwargs): ...
    @classmethod
    def indexUnsimplified(cls, *args, **kwargs): ...
    @classmethod
    def currentPoint(cls, *args, **kwargs): ...
    @classmethod
    def setCurrentPoint(cls, *args, **kwargs): ...
    @classmethod
    def maxPoints(cls, *args, **kwargs): ...
    @classmethod
    def setMaxPoints(cls, *args, **kwargs): ...
    @classmethod
    def setObject(cls, *args, **kwargs): ...
    @classmethod
    def geometry(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def __next__(cls): ...

class MPxImageFile:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def open(cls, *args, **kwargs): ...
    @classmethod
    def load(cls, *args, **kwargs): ...
    @classmethod
    def glLoad(cls, *args, **kwargs): ...
    @classmethod
    def close(cls, *args, **kwargs): ...

class MPxImagePlane(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    imageType: Incomplete
    imageName: Incomplete
    useFrameExtension: Incomplete
    frameExtension: Incomplete
    frameOffset: Incomplete
    coverage: Incomplete
    coverageX: Incomplete
    coverageY: Incomplete
    coverageOrigin: Incomplete
    coverageOriginX: Incomplete
    coverageOriginY: Incomplete
    sourceTexture: Incomplete
    fit: Incomplete
    displayMode: Incomplete
    displayOnlyIfCurrent: Incomplete
    colorGain: Incomplete
    colorGainR: Incomplete
    colorGainG: Incomplete
    colorGainB: Incomplete
    colorOffset: Incomplete
    colorOffsetR: Incomplete
    colorOffsetG: Incomplete
    colorOffsetB: Incomplete
    alphaGain: Incomplete
    shadingSamplesOverride: Incomplete
    shadingSamples: Incomplete
    maxShadingSamples: Incomplete
    lockedToCamera: Incomplete
    depth: Incomplete
    squeezeCorrection: Incomplete
    size: Incomplete
    sizeX: Incomplete
    sizeY: Incomplete
    offset: Incomplete
    offsetX: Incomplete
    offsetY: Incomplete
    center: Incomplete
    centerX: Incomplete
    centerY: Incomplete
    centerZ: Incomplete
    width: Incomplete
    height: Incomplete
    visibleInReflections: Incomplete
    visibleInRefractions: Incomplete
    rotate: Incomplete
    alreadyPremult: Incomplete
    useDepthMap: Incomplete
    composite: Incomplete
    depthOversample: Incomplete
    separateDepth: Incomplete
    depthFile: Incomplete
    depthBias: Incomplete
    depthScale: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def loadImageMap(cls, *args, **kwargs): ...
    @classmethod
    def exactImageFile(cls, *args, **kwargs): ...
    @classmethod
    def refreshImage(cls, *args, **kwargs): ...
    @classmethod
    def setImageDirty(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxMayaAsciiFilterOutput:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __lshift__(cls, other): ...
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...

class MPxMayaAsciiFilter(MPxFileTranslator):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def haveWriteMethod(cls, *args, **kwargs): ...
    @classmethod
    def haveReadMethod(cls, *args, **kwargs): ...
    @classmethod
    def reader(cls, *args, **kwargs): ...
    @classmethod
    def writer(cls, *args, **kwargs): ...
    @classmethod
    def processReadOptions(cls, *args, **kwargs): ...
    @classmethod
    def processWriteOptions(cls, *args, **kwargs): ...
    @classmethod
    def writesRequirements(cls, *args, **kwargs): ...
    @classmethod
    def writesMetadata(cls, *args, **kwargs): ...
    @classmethod
    def writesCreateNode(cls, *args, **kwargs): ...
    @classmethod
    def writesSetAttr(cls, *args, **kwargs): ...
    @classmethod
    def writesConnectAttr(cls, *args, **kwargs): ...
    @classmethod
    def writesDisconnectAttr(cls, *args, **kwargs): ...
    @classmethod
    def writesParentNode(cls, *args, **kwargs): ...
    @classmethod
    def writesSelectNode(cls, *args, **kwargs): ...
    @classmethod
    def writesFileReference(cls, *args, **kwargs): ...
    @classmethod
    def writePostHeader(cls, *args, **kwargs): ...
    @classmethod
    def writePostRequires(cls, *args, **kwargs): ...
    @classmethod
    def writePreCreateNodesBlock(cls, *args, **kwargs): ...
    @classmethod
    def writePostCreateNodesBlock(cls, *args, **kwargs): ...
    @classmethod
    def writePreConnectAttrsBlock(cls, *args, **kwargs): ...
    @classmethod
    def writePostConnectAttrsBlock(cls, *args, **kwargs): ...
    @classmethod
    def writePreTrailer(cls, *args, **kwargs): ...

class MPxObjectSet(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    dagSetMembers: Incomplete
    DNSetMembers: Incomplete
    memberWireframeColor: Incomplete
    annotation: Incomplete
    isLayer: Incomplete
    verticesOnlySet: Incomplete
    edgesOnlySet: Incomplete
    facetsOnlySet: Incomplete
    editPointsOnlySet: Incomplete
    renderableOnlySet: Incomplete
    partition: Incomplete
    groupNodes: Incomplete
    usedByNodes: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def canBeDeleted(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxAssembly(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def createRepresentation(cls, *args, **kwargs): ...
    @classmethod
    def activate(cls, *args, **kwargs): ...
    @classmethod
    def getActive(cls, *args, **kwargs): ...
    @classmethod
    def isActive(cls, *args, **kwargs): ...
    @classmethod
    def getRepresentations(cls, *args, **kwargs): ...
    @classmethod
    def getRepType(cls, *args, **kwargs): ...
    @classmethod
    def getRepLabel(cls, *args, **kwargs): ...
    @classmethod
    def repTypes(cls, *args, **kwargs): ...
    @classmethod
    def deleteRepresentation(cls, *args, **kwargs): ...
    @classmethod
    def deleteAllRepresentations(cls, *args, **kwargs): ...
    @classmethod
    def getRepNamespace(cls, *args, **kwargs): ...
    @classmethod
    def updateRepNamespace(cls, *args, **kwargs): ...
    @classmethod
    def setRepName(cls, *args, **kwargs): ...
    @classmethod
    def setRepLabel(cls, *args, **kwargs): ...
    @classmethod
    def supportsEdits(cls, *args, **kwargs): ...
    @classmethod
    def supportsMemberChanges(cls, *args, **kwargs): ...
    @classmethod
    def canRepApplyEdits(cls, *args, **kwargs): ...
    @classmethod
    def handlesAddEdits(cls, *args, **kwargs): ...
    @classmethod
    def addEdits(cls, *args, **kwargs): ...
    @classmethod
    def beforeSave(cls, *args, **kwargs): ...
    @classmethod
    def postLoad(cls, *args, **kwargs): ...
    @classmethod
    def memberAdded(cls, *args, **kwargs): ...
    @classmethod
    def memberRemoved(cls, *args, **kwargs): ...
    @classmethod
    def performActivate(cls, *args, **kwargs): ...
    @classmethod
    def performInactivate(cls, *args, **kwargs): ...
    @classmethod
    def activateRep(cls, *args, **kwargs): ...
    @classmethod
    def inactivateRep(cls, *args, **kwargs): ...
    @classmethod
    def postActivateRep(cls, *args, **kwargs): ...
    @classmethod
    def preApplyEdits(cls, *args, **kwargs): ...
    @classmethod
    def preUnapplyEdits(cls, *args, **kwargs): ...
    @classmethod
    def postApplyEdits(cls, *args, **kwargs): ...
    @classmethod
    def postUnapplyEdits(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def getInstancePtr(cls, *args, **kwargs): ...
    @classmethod
    def setInstancePtr(cls, *args, **kwargs): ...
    @classmethod
    def activating(cls, *args, **kwargs): ...
    @classmethod
    def addSetAttrEdit(cls, *args, **kwargs): ...
    @classmethod
    def addConnectAttrEdit(cls, *args, **kwargs): ...
    @classmethod
    def addDisconnectAttrEdit(cls, *args, **kwargs): ...
    @classmethod
    def addDeleteAttrEdit(cls, *args, **kwargs): ...
    @classmethod
    def addAddAttrEdit(cls, *args, **kwargs): ...
    @classmethod
    def addParentEdit(cls, *args, **kwargs): ...
    @classmethod
    def getInitialRep(cls, *args, **kwargs): ...

class MPxRepresentation:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def activate(cls, *args, **kwargs): ...
    @classmethod
    def inactivate(cls, *args, **kwargs): ...
    @classmethod
    def getType(cls, *args, **kwargs): ...
    @classmethod
    def getName(cls, *args, **kwargs): ...
    @classmethod
    def canApplyEdits(cls, *args, **kwargs): ...
    @classmethod
    def getExternalContent(cls, *args, **kwargs): ...
    @classmethod
    def setExternalContent(cls, *args, **kwargs): ...

class MPxPolyTrg(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def postConstructor(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @classmethod
    def isAbstractClass(cls, *args, **kwargs): ...
    @classmethod
    def registerTrgFunction(cls, *args, **kwargs): ...
    @classmethod
    def unregisterTrgFunction(cls, *args, **kwargs): ...

class MPxTransformationMatrix:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    identity: ClassVar[MPxTransformationMatrix] = ...
    thisown: Incomplete
    baseTransformationMatrixId: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def copyValues(cls, *args, **kwargs): ...
    @classmethod
    def typeId(cls, *args, **kwargs): ...
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def __eq__(cls, other: object) -> bool: ...
    @classmethod
    def __ne__(cls, other: object) -> bool: ...
    @classmethod
    def isEquivalent(cls, *args, **kwargs): ...
    @classmethod
    def reverse(cls, *args, **kwargs): ...
    @classmethod
    def transformBy(cls, *args, **kwargs): ...
    @classmethod
    def asMatrixInverse(cls, *args, **kwargs): ...
    @classmethod
    def asScaleMatrix(cls, *args, **kwargs): ...
    @classmethod
    def asScaleMatrixInverse(cls, *args, **kwargs): ...
    @classmethod
    def asRotateMatrix(cls, *args, **kwargs): ...
    @classmethod
    def asRotateMatrixInverse(cls, *args, **kwargs): ...
    @classmethod
    def asMatrix(cls, *args, **kwargs): ...
    @classmethod
    def asInterpolationMatrix(cls, *args, **kwargs): ...
    @classmethod
    def asTransformationMatrix(cls, *args, **kwargs): ...
    @classmethod
    def translation(cls, *args, **kwargs): ...
    @classmethod
    def translateTo(cls, *args, **kwargs): ...
    @classmethod
    def translateBy(cls, *args, **kwargs): ...
    @classmethod
    def rotation(cls, *args, **kwargs): ...
    @classmethod
    def eulerRotation(cls, *args, **kwargs): ...
    @classmethod
    def rotateTo(cls, *args, **kwargs): ...
    @classmethod
    def rotateBy(cls, *args, **kwargs): ...
    @classmethod
    def rotationOrder(cls, *args, **kwargs): ...
    @classmethod
    def setRotationOrder(cls, *args, **kwargs): ...
    @classmethod
    def rotateOrientation(cls, *args, **kwargs): ...
    @classmethod
    def eulerRotateOrientation(cls, *args, **kwargs): ...
    @classmethod
    def setRotateOrientation(cls, *args, **kwargs): ...
    @classmethod
    def preRotation(cls, *args, **kwargs): ...
    @classmethod
    def scale(cls, *args, **kwargs): ...
    @classmethod
    def scaleTo(cls, *args, **kwargs): ...
    @classmethod
    def scaleBy(cls, *args, **kwargs): ...
    @classmethod
    def shear(cls, *args, **kwargs): ...
    @classmethod
    def shearTo(cls, *args, **kwargs): ...
    @classmethod
    def shearBy(cls, *args, **kwargs): ...
    @classmethod
    def scalePivot(cls, *args, **kwargs): ...
    @classmethod
    def setScalePivot(cls, *args, **kwargs): ...
    @classmethod
    def scalePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def setScalePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def rotatePivot(cls, *args, **kwargs): ...
    @classmethod
    def setRotatePivot(cls, *args, **kwargs): ...
    @classmethod
    def rotatePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def setRotatePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def unSquishIt(cls, *args, **kwargs): ...
    @classmethod
    def unSquishMatrix(cls, *args, **kwargs): ...
    @staticmethod
    def creator(*args, **kwargs): ...
    @staticmethod
    def convertTransformationRotationOrder(*args, **kwargs): ...
    @staticmethod
    def convertEulerRotationOrder(*args, **kwargs): ...
    @classmethod
    def decomposeMatrix(cls, *args, **kwargs): ...

class MPxTransform(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    nodeBoundingBox: Incomplete
    nodeBoundingBoxMin: Incomplete
    nodeBoundingBoxMinX: Incomplete
    nodeBoundingBoxMinY: Incomplete
    nodeBoundingBoxMinZ: Incomplete
    nodeBoundingBoxMax: Incomplete
    nodeBoundingBoxMaxX: Incomplete
    nodeBoundingBoxMaxY: Incomplete
    nodeBoundingBoxMaxZ: Incomplete
    nodeBoundingBoxSize: Incomplete
    nodeBoundingBoxSizeX: Incomplete
    nodeBoundingBoxSizeY: Incomplete
    nodeBoundingBoxSizeZ: Incomplete
    center: Incomplete
    boundingBoxCenterX: Incomplete
    boundingBoxCenterY: Incomplete
    boundingBoxCenterZ: Incomplete
    matrix: Incomplete
    inverseMatrix: Incomplete
    worldMatrix: Incomplete
    worldInverseMatrix: Incomplete
    parentMatrix: Incomplete
    parentInverseMatrix: Incomplete
    visibility: Incomplete
    intermediateObject: Incomplete
    isTemplated: Incomplete
    ghosting: Incomplete
    instObjGroups: Incomplete
    objectGroups: Incomplete
    objectGrpCompList: Incomplete
    objectGroupId: Incomplete
    objectGroupColor: Incomplete
    useObjectColor: Incomplete
    objectColor: Incomplete
    drawOverride: Incomplete
    overrideDisplayType: Incomplete
    overrideLevelOfDetail: Incomplete
    overrideShading: Incomplete
    overrideTexturing: Incomplete
    overridePlayback: Incomplete
    overrideEnabled: Incomplete
    overrideVisibility: Incomplete
    overrideColor: Incomplete
    lodVisibility: Incomplete
    renderInfo: Incomplete
    identification: Incomplete
    layerRenderable: Incomplete
    layerOverrideColor: Incomplete
    renderLayerInfo: Incomplete
    renderLayerId: Incomplete
    renderLayerRenderable: Incomplete
    renderLayerColor: Incomplete
    translate: Incomplete
    translateX: Incomplete
    translateY: Incomplete
    translateZ: Incomplete
    rotate: Incomplete
    rotateX: Incomplete
    rotateY: Incomplete
    rotateZ: Incomplete
    rotateOrder: Incomplete
    scale: Incomplete
    scaleX: Incomplete
    scaleY: Incomplete
    scaleZ: Incomplete
    shear: Incomplete
    shearXY: Incomplete
    shearXZ: Incomplete
    shearYZ: Incomplete
    rotatePivot: Incomplete
    rotatePivotX: Incomplete
    rotatePivotY: Incomplete
    rotatePivotZ: Incomplete
    rotatePivotTranslate: Incomplete
    rotatePivotTranslateX: Incomplete
    rotatePivotTranslateY: Incomplete
    rotatePivotTranslateZ: Incomplete
    scalePivot: Incomplete
    scalePivotX: Incomplete
    scalePivotY: Incomplete
    scalePivotZ: Incomplete
    scalePivotTranslate: Incomplete
    scalePivotTranslateX: Incomplete
    scalePivotTranslateY: Incomplete
    scalePivotTranslateZ: Incomplete
    rotateAxis: Incomplete
    rotateAxisX: Incomplete
    rotateAxisY: Incomplete
    rotateAxisZ: Incomplete
    transMinusRotatePivot: Incomplete
    transMinusRotatePivotX: Incomplete
    transMinusRotatePivotY: Incomplete
    transMinusRotatePivotZ: Incomplete
    minTransLimit: Incomplete
    minTransXLimit: Incomplete
    minTransYLimit: Incomplete
    minTransZLimit: Incomplete
    maxTransLimit: Incomplete
    maxTransXLimit: Incomplete
    maxTransYLimit: Incomplete
    maxTransZLimit: Incomplete
    minTransLimitEnable: Incomplete
    minTransXLimitEnable: Incomplete
    minTransYLimitEnable: Incomplete
    minTransZLimitEnable: Incomplete
    maxTransLimitEnable: Incomplete
    maxTransXLimitEnable: Incomplete
    maxTransYLimitEnable: Incomplete
    maxTransZLimitEnable: Incomplete
    minRotLimit: Incomplete
    minRotXLimit: Incomplete
    minRotYLimit: Incomplete
    minRotZLimit: Incomplete
    maxRotLimit: Incomplete
    maxRotXLimit: Incomplete
    maxRotYLimit: Incomplete
    maxRotZLimit: Incomplete
    minRotLimitEnable: Incomplete
    minRotXLimitEnable: Incomplete
    minRotYLimitEnable: Incomplete
    minRotZLimitEnable: Incomplete
    maxRotLimitEnable: Incomplete
    maxRotXLimitEnable: Incomplete
    maxRotYLimitEnable: Incomplete
    maxRotZLimitEnable: Incomplete
    minScaleLimit: Incomplete
    minScaleXLimit: Incomplete
    minScaleYLimit: Incomplete
    minScaleZLimit: Incomplete
    maxScaleLimit: Incomplete
    maxScaleXLimit: Incomplete
    maxScaleYLimit: Incomplete
    maxScaleZLimit: Incomplete
    minScaleLimitEnable: Incomplete
    minScaleXLimitEnable: Incomplete
    minScaleYLimitEnable: Incomplete
    minScaleZLimitEnable: Incomplete
    maxScaleLimitEnable: Incomplete
    maxScaleXLimitEnable: Incomplete
    maxScaleYLimitEnable: Incomplete
    maxScaleZLimitEnable: Incomplete
    geometry: Incomplete
    xformMatrix: Incomplete
    selectHandle: Incomplete
    selectHandleX: Incomplete
    selectHandleY: Incomplete
    selectHandleZ: Incomplete
    inheritsTransform: Incomplete
    displayHandle: Incomplete
    displayScalePivot: Incomplete
    displayRotatePivot: Incomplete
    displayLocalAxis: Incomplete
    dynamics: Incomplete
    showManipDefault: Incomplete
    specifiedManipLocation: Incomplete
    rotateQuaternion: Incomplete
    rotateQuaternionX: Incomplete
    rotateQuaternionY: Incomplete
    rotateQuaternionZ: Incomplete
    rotateQuaternionW: Incomplete
    rotationInterpolation: Incomplete
    offsetParentMatrix: Incomplete
    baseTransformationMatrix: Incomplete
    @classmethod
    def assign(cls, *args, **kwargs): ...
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def postConstructor(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def createTransformationMatrix(cls, *args, **kwargs): ...
    @classmethod
    def isBounded(cls, *args, **kwargs): ...
    @classmethod
    def boundingBox(cls, *args, **kwargs): ...
    @classmethod
    def treatAsTransform(cls, *args, **kwargs): ...
    @classmethod
    def transformationMatrix(cls, *args, **kwargs): ...
    @classmethod
    def transformationMatrixPtr(cls, *args, **kwargs): ...
    @classmethod
    def resetTransformation(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @classmethod
    def computeLocalTransformation(cls, *args, **kwargs): ...
    @classmethod
    def clearLimits(cls, *args, **kwargs): ...
    @classmethod
    def isLimited(cls, *args, **kwargs): ...
    @classmethod
    def limitValue(cls, *args, **kwargs): ...
    @classmethod
    def setLimit(cls, *args, **kwargs): ...
    @classmethod
    def enableLimit(cls, *args, **kwargs): ...
    @classmethod
    def getPreRotation(cls, *args, **kwargs): ...
    @staticmethod
    def mustCallValidateAndSet(*args, **kwargs): ...
    @staticmethod
    def setNonAffineMatricesEnabled(*args, **kwargs): ...
    @staticmethod
    def isNonAffineMatricesEnabled(*args, **kwargs): ...
    @classmethod
    def copyInternalData(cls, *args, **kwargs): ...
    @classmethod
    def applyTranslationLimits(cls, *args, **kwargs): ...
    @classmethod
    def applyTranslationLocks(cls, *args, **kwargs): ...
    @classmethod
    def applyRotationLimits(cls, *args, **kwargs): ...
    @classmethod
    def applyRotationLocks(cls, *args, **kwargs): ...
    @classmethod
    def applyScaleLimits(cls, *args, **kwargs): ...
    @classmethod
    def applyScaleLocks(cls, *args, **kwargs): ...
    @classmethod
    def applyShearLocks(cls, *args, **kwargs): ...
    @classmethod
    def applyRotateOrientationLocks(cls, *args, **kwargs): ...
    @classmethod
    def applyScaleLocksPivot(cls, *args, **kwargs): ...
    @classmethod
    def applyRotatePivotLocks(cls, *args, **kwargs): ...
    @classmethod
    def applyScaleLocksPivotTranslate(cls, *args, **kwargs): ...
    @classmethod
    def applyRotatePivotLocksTranslate(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetTranslation(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetRotation(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetScale(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetShear(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetRotateOrientation(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetRotatePivot(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetRotatePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetScalePivot(cls, *args, **kwargs): ...
    @classmethod
    def checkAndSetScalePivotTranslation(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def validateAndSetValue(cls, *args, **kwargs): ...
    @classmethod
    def updateMatrixAttrs(cls, *args, **kwargs): ...
    @classmethod
    def getMatrix(cls, *args, **kwargs): ...
    @classmethod
    def getMatrixInverse(cls, *args, **kwargs): ...
    @classmethod
    def getTranslation(cls, *args, **kwargs): ...
    @classmethod
    def translateTo(cls, *args, **kwargs): ...
    @classmethod
    def translateBy(cls, *args, **kwargs): ...
    @classmethod
    def getRotation(cls, *args, **kwargs): ...
    @classmethod
    def getEulerRotation(cls, *args, **kwargs): ...
    @classmethod
    def rotateTo(cls, *args, **kwargs): ...
    @classmethod
    def rotateBy(cls, *args, **kwargs): ...
    @classmethod
    def getScale(cls, *args, **kwargs): ...
    @classmethod
    def scaleTo(cls, *args, **kwargs): ...
    @classmethod
    def scaleBy(cls, *args, **kwargs): ...
    @classmethod
    def getShear(cls, *args, **kwargs): ...
    @classmethod
    def shearTo(cls, *args, **kwargs): ...
    @classmethod
    def shearBy(cls, *args, **kwargs): ...
    @classmethod
    def getScalePivot(cls, *args, **kwargs): ...
    @classmethod
    def getRotatePivot(cls, *args, **kwargs): ...
    @classmethod
    def getScalePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def getRotatePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def setScalePivot(cls, *args, **kwargs): ...
    @classmethod
    def setScalePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def setRotatePivot(cls, *args, **kwargs): ...
    @classmethod
    def setRotatePivotTranslation(cls, *args, **kwargs): ...
    @classmethod
    def getRotationOrder(cls, *args, **kwargs): ...
    @classmethod
    def setRotationOrder(cls, *args, **kwargs): ...
    @classmethod
    def getRotateOrientation(cls, *args, **kwargs): ...
    @classmethod
    def setRotateOrientation(cls, *args, **kwargs): ...

class MPxPolyTweakUVCommand(MPxCommand):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def parseSyntax(cls, *args, **kwargs): ...
    @classmethod
    def getTweakedUVs(cls, *args, **kwargs): ...
    @staticmethod
    def newSyntax(*args, **kwargs): ...

class MPxMultiPolyTweakUVCommand(MPxCommand):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def parseSyntax(cls, *args, **kwargs): ...
    @staticmethod
    def newSyntax(*args, **kwargs): ...
    @classmethod
    def preProcessUVs(cls, *args, **kwargs): ...
    @classmethod
    def getTweakedUVs(cls, *args, **kwargs): ...

class MaterialInputData:
    __init__: ClassVar[Callable] = ...
    thisown: Incomplete
    shininess: Incomplete
    ambient: Incomplete
    diffuse: Incomplete
    emission: Incomplete
    specular: Incomplete
    hasTransparency: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...

class MPxMaterialInformation:
    kSimpleMaterial: ClassVar[int] = ...
    kTexture: ClassVar[int] = ...
    kOverrideDraw: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def useMaterialAsTexture(cls, *args, **kwargs): ...
    @classmethod
    def materialInfoIsDirty(cls, *args, **kwargs): ...
    @classmethod
    def connectAsTexture(cls, *args, **kwargs): ...
    @classmethod
    def textureDisconnected(cls, *args, **kwargs): ...
    @classmethod
    def computeMaterial(cls, *args, **kwargs): ...

class MPxCacheFormat:
    kRead: ClassVar[int] = ...
    kWrite: ClassVar[int] = ...
    kReadWrite: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def open(cls, *args, **kwargs): ...
    @classmethod
    def close(cls, *args, **kwargs): ...
    @classmethod
    def isValid(cls, *args, **kwargs): ...
    @classmethod
    def rewind(cls, *args, **kwargs): ...
    @classmethod
    def extension(cls, *args, **kwargs): ...
    @classmethod
    def readHeader(cls, *args, **kwargs): ...
    @classmethod
    def writeHeader(cls, *args, **kwargs): ...
    @classmethod
    def beginWriteChunk(cls, *args, **kwargs): ...
    @classmethod
    def endWriteChunk(cls, *args, **kwargs): ...
    @classmethod
    def beginReadChunk(cls, *args, **kwargs): ...
    @classmethod
    def endReadChunk(cls, *args, **kwargs): ...
    @classmethod
    def writeTime(cls, *args, **kwargs): ...
    @classmethod
    def readTime(cls, *args, **kwargs): ...
    @classmethod
    def findTime(cls, *args, **kwargs): ...
    @classmethod
    def readNextTime(cls, *args, **kwargs): ...
    @classmethod
    def readArraySize(cls, *args, **kwargs): ...
    @classmethod
    def writeDoubleArray(cls, *args, **kwargs): ...
    @classmethod
    def writeFloatArray(cls, *args, **kwargs): ...
    @classmethod
    def writeIntArray(cls, *args, **kwargs): ...
    @classmethod
    def writeDoubleVectorArray(cls, *args, **kwargs): ...
    @classmethod
    def writeFloatVectorArray(cls, *args, **kwargs): ...
    @classmethod
    def writeInt32(cls, *args, **kwargs): ...
    @classmethod
    def readDoubleArray(cls, *args, **kwargs): ...
    @classmethod
    def readFloatArray(cls, *args, **kwargs): ...
    @classmethod
    def readIntArray(cls, *args, **kwargs): ...
    @classmethod
    def readDoubleVectorArray(cls, *args, **kwargs): ...
    @classmethod
    def readFloatVectorArray(cls, *args, **kwargs): ...
    @classmethod
    def readInt32(cls, *args, **kwargs): ...
    @classmethod
    def writeChannelName(cls, *args, **kwargs): ...
    @classmethod
    def findChannelName(cls, *args, **kwargs): ...
    @classmethod
    def readChannelName(cls, *args, **kwargs): ...
    @classmethod
    def handlesDescription(cls, *args, **kwargs): ...
    @classmethod
    def readDescription(cls, *args, **kwargs): ...
    @classmethod
    def writeDescription(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxCacheConfigRuleFilter:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def preRulesExecution(cls, *args, **kwargs): ...
    @classmethod
    def postRulesExecution(cls, *args, **kwargs): ...
    @classmethod
    def isMatch(cls, *args, **kwargs): ...

class MPxGeometryFilter(MPxNode):
    kDeformsUVs: ClassVar[int] = ...
    kDeformsColors: ClassVar[int] = ...
    kDeformsAll: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    kNoChange: ClassVar[int] = ...
    kTopologyChange: ClassVar[int] = ...
    kWeightsChange: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    input: Incomplete
    inputGeom: Incomplete
    groupId: Incomplete
    componentTagExpression: Incomplete
    outputGeom: Incomplete
    envelope: Incomplete
    originalGeometry: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def prepareDeform(cls, *args, **kwargs): ...
    @classmethod
    def deform(cls, *args, **kwargs): ...
    @classmethod
    def accessoryAttribute(cls, *args, **kwargs): ...
    @classmethod
    def accessoryNodeSetup(cls, *args, **kwargs): ...
    @classmethod
    def setUseExistingConnectionWhenSetEditing(cls, *args, **kwargs): ...
    @classmethod
    def setDeformationDetails(cls, *args, **kwargs): ...
    @classmethod
    def getDeformationDetails(cls, *args, **kwargs): ...
    @classmethod
    def setModifiedCallback(cls, *args, **kwargs): ...
    @classmethod
    def indexMapper(cls, *args, **kwargs): ...
    @classmethod
    def getGeometryIterator(cls, *args, **kwargs): ...
    @classmethod
    def getFixedSetupData(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxDeformerNode(MPxGeometryFilter):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    weightList: Incomplete
    weights: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def weightValue(cls, *args, **kwargs): ...
    @classmethod
    def envelopeWeights(cls, *args, **kwargs): ...
    @classmethod
    def setUseExistingConnectionWhenSetEditing(cls, *args, **kwargs): ...
    @classmethod
    def setDeformationDetails(cls, *args, **kwargs): ...
    @classmethod
    def getDeformationDetails(cls, *args, **kwargs): ...
    @classmethod
    def indexMapper(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxSkinCluster(MPxGeometryFilter):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    weightList: Incomplete
    weights: Incomplete
    matrix: Incomplete
    bindPreMatrix: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def weightValue(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxBlendShape(MPxGeometryFilter):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    weight: Incomplete
    inputTarget: Incomplete
    inputTargetGroup: Incomplete
    inputTargetItem: Incomplete
    inputGeomTarget: Incomplete
    inputPointsTarget: Incomplete
    inputComponentsTarget: Incomplete
    targetWeights: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def deformData(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxIkSolverNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def preSolve(cls, *args, **kwargs): ...
    @classmethod
    def doSolve(cls, *args, **kwargs): ...
    @classmethod
    def postSolve(cls, *args, **kwargs): ...
    @classmethod
    def solverTypeName(cls, *args, **kwargs): ...
    @classmethod
    def rotatePlane(cls, *args, **kwargs): ...
    @classmethod
    def setRotatePlane(cls, *args, **kwargs): ...
    @classmethod
    def singleChainOnly(cls, *args, **kwargs): ...
    @classmethod
    def setSingleChainOnly(cls, *args, **kwargs): ...
    @classmethod
    def positionOnly(cls, *args, **kwargs): ...
    @classmethod
    def setPositionOnly(cls, *args, **kwargs): ...
    @classmethod
    def supportJointLimits(cls, *args, **kwargs): ...
    @classmethod
    def setSupportJointLimits(cls, *args, **kwargs): ...
    @classmethod
    def uniqueSolution(cls, *args, **kwargs): ...
    @classmethod
    def setUniqueSolution(cls, *args, **kwargs): ...
    @classmethod
    def isSingleChainOnly(cls, *args, **kwargs): ...
    @classmethod
    def isPositionOnly(cls, *args, **kwargs): ...
    @classmethod
    def hasJointLimitSupport(cls, *args, **kwargs): ...
    @classmethod
    def hasUniqueSolution(cls, *args, **kwargs): ...
    @classmethod
    def groupHandlesByTopology(cls, *args, **kwargs): ...
    @classmethod
    def setFuncValueTolerance(cls, *args, **kwargs): ...
    @classmethod
    def setMaxIterations(cls, *args, **kwargs): ...
    @classmethod
    def handleGroup(cls, *args, **kwargs): ...
    @classmethod
    def setHandleGroup(cls, *args, **kwargs): ...
    @classmethod
    def toWorldSpace(cls, *args, **kwargs): ...
    @classmethod
    def toSolverSpace(cls, *args, **kwargs): ...
    @classmethod
    def funcValueTolerance(cls, *args, **kwargs): ...
    @classmethod
    def maxIterations(cls, *args, **kwargs): ...
    @classmethod
    def snapHandle(cls, *args, **kwargs): ...
    @classmethod
    def isAttributeCreatedBySolver(cls, *args, **kwargs): ...
    @classmethod
    def create(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxAnimCurveInterpolator:
    kEvaluateAtKey: ClassVar[int] = ...
    kLockType: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def initialize(cls, *args, **kwargs): ...
    @classmethod
    def evaluate(cls, *args, **kwargs): ...
    @classmethod
    def typeId(cls, *args, **kwargs): ...
    @classmethod
    def typeName(cls, *args, **kwargs): ...

class MPxConstraint(MPxNode):
    kScene: ClassVar[int] = ...
    kObject: ClassVar[int] = ...
    kObjectRotation: ClassVar[int] = ...
    kVector: ClassVar[int] = ...
    kLast: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    enableRestPosition: Incomplete
    lockOutput: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def weightAttribute(cls, *args, **kwargs): ...
    @classmethod
    def targetAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintRotateOrderAttribute(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def passiveOutputAttribute(cls, *args, **kwargs): ...
    @classmethod
    def getOutputAttributes(cls, *args, **kwargs): ...

class MPxConstraintCommand(MPxCommand):
    kTransform: ClassVar[int] = ...
    kGeometryShape: ClassVar[int] = ...
    kLast: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def doIt(cls, *args, **kwargs): ...
    @classmethod
    def undoIt(cls, *args, **kwargs): ...
    @classmethod
    def redoIt(cls, *args, **kwargs): ...
    @classmethod
    def appendSyntax(cls, *args, **kwargs): ...
    @classmethod
    def constraintNode(cls, *args, **kwargs): ...
    @classmethod
    def parseArgs(cls, *args, **kwargs): ...
    @classmethod
    def doEdit(cls, *args, **kwargs): ...
    @classmethod
    def doCreate(cls, *args, **kwargs): ...
    @classmethod
    def doQuery(cls, *args, **kwargs): ...
    @classmethod
    def createdConstraint(cls, *args, **kwargs): ...
    @classmethod
    def supportsOffset(cls, *args, **kwargs): ...
    @classmethod
    def hasVectorFlags(cls, *args, **kwargs): ...
    @classmethod
    def constraintTypeId(cls, *args, **kwargs): ...
    @classmethod
    def targetType(cls, *args, **kwargs): ...
    @classmethod
    def aimVectorAttribute(cls, *args, **kwargs): ...
    @classmethod
    def upVectorAttribute(cls, *args, **kwargs): ...
    @classmethod
    def worldUpMatrixAttribute(cls, *args, **kwargs): ...
    @classmethod
    def worldUpTypeAttribute(cls, *args, **kwargs): ...
    @classmethod
    def worldUpVectorAttribute(cls, *args, **kwargs): ...
    @classmethod
    def offsetAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintInstancedAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintOutputAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintRestAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintEnableRestAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintTargetInstancedAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintTargetAttribute(cls, *args, **kwargs): ...
    @classmethod
    def constraintTargetWeightAttribute(cls, *args, **kwargs): ...
    @classmethod
    def objectAttribute(cls, *args, **kwargs): ...
    @classmethod
    def getObjectAttributesArray(cls, *args, **kwargs): ...
    @classmethod
    def handleNewTargets(cls, *args, **kwargs): ...
    @classmethod
    def connectTarget(cls, *args, **kwargs): ...
    @classmethod
    def connectObjectAndConstraint(cls, *args, **kwargs): ...
    @classmethod
    def setRestPosition(cls, *args, **kwargs): ...

class MPxMotionPathNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    kUpScene: ClassVar[int] = ...
    kUpObject: ClassVar[int] = ...
    kUpObjectRotation: ClassVar[int] = ...
    kUpVector: ClassVar[int] = ...
    kUpNormal: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    uValue: Incomplete
    frontTwist: Incomplete
    upTwist: Incomplete
    sideTwist: Incomplete
    flowNode: Incomplete
    pathGeometry: Incomplete
    positionMarkerTime: Incomplete
    orientationMarkerTime: Incomplete
    follow: Incomplete
    normal: Incomplete
    inverseUp: Incomplete
    inverseFront: Incomplete
    frontAxis: Incomplete
    upAxis: Incomplete
    worldUpType: Incomplete
    worldUpVector: Incomplete
    worldUpVectorX: Incomplete
    worldUpVectorY: Incomplete
    worldUpVectorZ: Incomplete
    worldUpMatrix: Incomplete
    bank: Incomplete
    bankScale: Incomplete
    bankThreshold: Incomplete
    fractionMode: Incomplete
    updateOrientationMarkers: Incomplete
    allCoordinates: Incomplete
    xCoordinate: Incomplete
    yCoordinate: Incomplete
    zCoordinate: Incomplete
    orientMatrix: Incomplete
    rotate: Incomplete
    rotateX: Incomplete
    rotateY: Incomplete
    rotateZ: Incomplete
    rotateOrder: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def position(cls, *args, **kwargs): ...
    @classmethod
    def getVectors(cls, *args, **kwargs): ...
    @classmethod
    def banking(cls, *args, **kwargs): ...
    @classmethod
    def evaluatePath(cls, *args, **kwargs): ...
    @classmethod
    def parametricToFractional(cls, *args, **kwargs): ...
    @classmethod
    def fractionalToParametric(cls, *args, **kwargs): ...
    @classmethod
    def wraparoundFractionalValue(cls, *args, **kwargs): ...
    @classmethod
    def matrix(cls, *args, **kwargs): ...

class MPx3dModelView:
    kLightAll: ClassVar[int] = ...
    kLightSelected: ClassVar[int] = ...
    kLightActive: ClassVar[int] = ...
    kLightDefault: ClassVar[int] = ...
    kLightNone: ClassVar[int] = ...
    kLightQuality: ClassVar[int] = ...
    kFogFragment: ClassVar[int] = ...
    kFogCoordinate: ClassVar[int] = ...
    kFogLinear: ClassVar[int] = ...
    kFogExponential: ClassVar[int] = ...
    kFogExponentialSquared: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def name(cls, *args, **kwargs): ...
    @classmethod
    def viewType(cls, *args, **kwargs): ...
    @classmethod
    def preMultipleDraw(cls, *args, **kwargs): ...
    @classmethod
    def postMultipleDraw(cls, *args, **kwargs): ...
    @classmethod
    def preMultipleDrawPass(cls, *args, **kwargs): ...
    @classmethod
    def postMultipleDrawPass(cls, *args, **kwargs): ...
    @classmethod
    def okForMultipleDraw(cls, *args, **kwargs): ...
    @classmethod
    def multipleDrawPassCount(cls, *args, **kwargs): ...
    @classmethod
    def multipleDrawEnabled(cls, *args, **kwargs): ...
    @classmethod
    def setMultipleDrawEnable(cls, *args, **kwargs): ...
    @classmethod
    def destroyOnPanelDestruction(cls, *args, **kwargs): ...
    @classmethod
    def setDestroyOnPanelDestruction(cls, *args, **kwargs): ...
    @classmethod
    def updateViewingParameters(cls, *args, **kwargs): ...
    @classmethod
    def removingCamera(cls, *args, **kwargs): ...
    @classmethod
    def setDoUpdateOnMove(cls, *args, **kwargs): ...
    @classmethod
    def doUpdateOnMove(cls, *args, **kwargs): ...
    @classmethod
    def refresh(cls, *args, **kwargs): ...
    @classmethod
    def drawText(cls, *args, **kwargs): ...
    @classmethod
    def beginGL(cls, *args, **kwargs): ...
    @classmethod
    def endGL(cls, *args, **kwargs): ...
    @classmethod
    def setCameraInDraw(cls, *args, **kwargs): ...
    @classmethod
    def setDrawCameraOverride(cls, *args, **kwargs): ...
    @classmethod
    def setCamera(cls, *args, **kwargs): ...
    @classmethod
    def getCamera(cls, *args, **kwargs): ...
    @classmethod
    def setCameraSet(cls, *args, **kwargs): ...
    @classmethod
    def getCameraSet(cls, *args, **kwargs): ...
    @classmethod
    def setCurrentCameraSetCamera(cls, *args, **kwargs): ...
    @classmethod
    def getCurrentCameraSetCamera(cls, *args, **kwargs): ...
    @classmethod
    def getCameraHUDName(cls, *args, **kwargs): ...
    @classmethod
    def setDisplayHUD(cls, *args, **kwargs): ...
    @classmethod
    def displayHUD(cls, *args, **kwargs): ...
    @classmethod
    def drawHUDNow(cls, *args, **kwargs): ...
    @classmethod
    def setDrawAdornments(cls, *args, **kwargs): ...
    @classmethod
    def drawAdornments(cls, *args, **kwargs): ...
    @classmethod
    def drawAdornmentsNow(cls, *args, **kwargs): ...
    @classmethod
    def setDisplayAxis(cls, *args, **kwargs): ...
    @classmethod
    def displayAxisOn(cls, *args, **kwargs): ...
    @classmethod
    def setDisplayAxisAtOrigin(cls, *args, **kwargs): ...
    @classmethod
    def displayAxisAtOriginOn(cls, *args, **kwargs): ...
    @classmethod
    def setDisplayCameraAnnotation(cls, *args, **kwargs): ...
    @classmethod
    def displayCameraAnnotationOn(cls, *args, **kwargs): ...
    @classmethod
    def isVisible(cls, *args, **kwargs): ...
    @classmethod
    def displayStyle(cls, *args, **kwargs): ...
    @classmethod
    def isShadeActiveOnly(cls, *args, **kwargs): ...
    @classmethod
    def setDisplayStyle(cls, *args, **kwargs): ...
    @classmethod
    def portWidth(cls, *args, **kwargs): ...
    @classmethod
    def portHeight(cls, *args, **kwargs): ...
    @classmethod
    def beginXorDrawing(cls, *args, **kwargs): ...
    @classmethod
    def endXorDrawing(cls, *args, **kwargs): ...
    @classmethod
    def setDrawColor(cls, *args, **kwargs): ...
    @classmethod
    def numDormantColors(cls, *args, **kwargs): ...
    @classmethod
    def numActiveColors(cls, *args, **kwargs): ...
    @classmethod
    def numUserDefinedColors(cls, *args, **kwargs): ...
    @classmethod
    def setUserDefinedColor(cls, *args, **kwargs): ...
    @classmethod
    def userDefinedColorIndex(cls, *args, **kwargs): ...
    @classmethod
    def isBackgroundGradient(cls, *args, **kwargs): ...
    @classmethod
    def templateColor(cls, *args, **kwargs): ...
    @classmethod
    def backgroundColor(cls, *args, **kwargs): ...
    @classmethod
    def backgroundColorTop(cls, *args, **kwargs): ...
    @classmethod
    def backgroundColorBottom(cls, *args, **kwargs): ...
    @classmethod
    def colorAtIndex(cls, *args, **kwargs): ...
    @classmethod
    def getColorIndexAndTable(cls, *args, **kwargs): ...
    @classmethod
    def viewToWorld(cls, *args, **kwargs): ...
    @classmethod
    def viewToObjectSpace(cls, *args, **kwargs): ...
    @classmethod
    def worldToView(cls, *args, **kwargs): ...
    @classmethod
    def setObjectDisplay(cls, *args, **kwargs): ...
    @classmethod
    def objectDisplay(cls, *args, **kwargs): ...
    @classmethod
    def setBackfaceCulling(cls, *args, **kwargs): ...
    @classmethod
    def isBackfaceCulling(cls, *args, **kwargs): ...
    @classmethod
    def setWireframeOnShaded(cls, *args, **kwargs): ...
    @classmethod
    def isWireframeOnShaded(cls, *args, **kwargs): ...
    @classmethod
    def setXrayEnabled(cls, *args, **kwargs): ...
    @classmethod
    def isXrayEnabled(cls, *args, **kwargs): ...
    @classmethod
    def setTextureDisplayEnabled(cls, *args, **kwargs): ...
    @classmethod
    def isTextureDisplayEnabled(cls, *args, **kwargs): ...
    @classmethod
    def setTwoSidedLighting(cls, *args, **kwargs): ...
    @classmethod
    def isTwoSidedLighting(cls, *args, **kwargs): ...
    @classmethod
    def setLightingMode(cls, *args, **kwargs): ...
    @classmethod
    def lightingMode(cls, *args, **kwargs): ...
    @classmethod
    def setFogEnabled(cls, *args, **kwargs): ...
    @classmethod
    def isFogEnabled(cls, *args, **kwargs): ...
    @classmethod
    def fogSource(cls, *args, **kwargs): ...
    @classmethod
    def setFogSource(cls, *args, **kwargs): ...
    @classmethod
    def fogMode(cls, *args, **kwargs): ...
    @classmethod
    def setFogMode(cls, *args, **kwargs): ...
    @classmethod
    def fogDensity(cls, *args, **kwargs): ...
    @classmethod
    def setFogDensity(cls, *args, **kwargs): ...
    @classmethod
    def fogStart(cls, *args, **kwargs): ...
    @classmethod
    def setFogStart(cls, *args, **kwargs): ...
    @classmethod
    def fogEnd(cls, *args, **kwargs): ...
    @classmethod
    def setFogEnd(cls, *args, **kwargs): ...
    @classmethod
    def fogColor(cls, *args, **kwargs): ...
    @classmethod
    def setFogColor(cls, *args, **kwargs): ...
    @classmethod
    def isBackgroundFogEnabled(cls, *args, **kwargs): ...
    @classmethod
    def setBackgroundFogEnabled(cls, *args, **kwargs): ...
    @classmethod
    def viewSelectedPrefix(cls, *args, **kwargs): ...
    @classmethod
    def setViewSelectedPrefix(cls, *args, **kwargs): ...
    @classmethod
    def viewSelected(cls, *args, **kwargs): ...
    @classmethod
    def setViewSelected(cls, *args, **kwargs): ...
    @classmethod
    def viewSelectedSet(cls, *args, **kwargs): ...
    @classmethod
    def setViewSelectedSet(cls, *args, **kwargs): ...
    @classmethod
    def getObjectsToView(cls, *args, **kwargs): ...
    @classmethod
    def setObjectsToView(cls, *args, **kwargs): ...
    @classmethod
    def viewIsFiltered(cls, *args, **kwargs): ...
    @classmethod
    def filteredObjectList(cls, *args, **kwargs): ...
    @classmethod
    def hasStereoBufferSupport(cls, *args, **kwargs): ...
    @classmethod
    def getAsM3dView(cls, *args, **kwargs): ...
    @staticmethod
    def getModelView(*args, **kwargs): ...
    @classmethod
    def wantStereoGLBuffer(cls, *args, **kwargs): ...
    @classmethod
    def setInStereoDrawMode(cls, *args, **kwargs): ...
    @classmethod
    def customDrawEnabled(cls, *args, **kwargs): ...
    @classmethod
    def setCustomDrawEnable(cls, *args, **kwargs): ...
    @classmethod
    def customDraw(cls, *args, **kwargs): ...
    @classmethod
    def drawOnePass(cls, *args, **kwargs): ...
    @classmethod
    def requestOkForDraw(cls, *args, **kwargs): ...
    @classmethod
    def processDraw(cls, *args, **kwargs): ...
    @classmethod
    def handleDraw(cls, *args, **kwargs): ...
    @classmethod
    def setDrawInterrupt(cls, *args, **kwargs): ...
    @classmethod
    def drawInterrupt(cls, *args, **kwargs): ...
    @classmethod
    def setIncludeInvisible(cls, *args, **kwargs): ...
    @classmethod
    def includeInvisible(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxContext:
    kImage1: ClassVar[int] = ...
    kImage2: ClassVar[int] = ...
    kImage3: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def toolOnSetup(cls, *args, **kwargs): ...
    @classmethod
    def toolOffCleanup(cls, *args, **kwargs): ...
    @classmethod
    def doPress(cls, *args, **kwargs): ...
    @classmethod
    def doRelease(cls, *args, **kwargs): ...
    @classmethod
    def doDrag(cls, *args, **kwargs): ...
    @classmethod
    def doHold(cls, *args, **kwargs): ...
    @classmethod
    def doPtrMoved(cls, *args, **kwargs): ...
    @classmethod
    def doEnterRegion(cls, *args, **kwargs): ...
    @classmethod
    def helpStateHasChanged(cls, *args, **kwargs): ...
    @classmethod
    def deleteAction(cls, *args, **kwargs): ...
    @classmethod
    def completeAction(cls, *args, **kwargs): ...
    @classmethod
    def addManipulator(cls, *args, **kwargs): ...
    @classmethod
    def deleteManipulators(cls, *args, **kwargs): ...
    @classmethod
    def setImage(cls, *args, **kwargs): ...
    @classmethod
    def image(cls, *args, **kwargs): ...
    @classmethod
    def inAlternateContext(cls, *args, **kwargs): ...
    @classmethod
    def newToolCommand(cls, *args, **kwargs): ...
    @classmethod
    def abortAction(cls, *args, **kwargs): ...
    @classmethod
    def processNumericalInput(cls, *args, **kwargs): ...
    @classmethod
    def feedbackNumericalInput(cls, *args, **kwargs): ...
    @classmethod
    def argTypeNumericalInput(cls, *args, **kwargs): ...
    @classmethod
    def stringClassName(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def doExitRegion(cls, *args, **kwargs): ...

class MPxContextCommand:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def doEditFlags(cls, *args, **kwargs): ...
    @classmethod
    def doQueryFlags(cls, *args, **kwargs): ...
    @classmethod
    def makeObj(cls, *args, **kwargs): ...
    @classmethod
    def appendSyntax(cls, *args, **kwargs): ...
    @classmethod
    def setResult(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxControlCommand:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def makeControl(cls, *args, **kwargs): ...
    @classmethod
    def doEditFlags(cls, *args, **kwargs): ...
    @classmethod
    def doQueryFlags(cls, *args, **kwargs): ...
    @classmethod
    def appendSyntax(cls, *args, **kwargs): ...
    @classmethod
    def skipFlagForCreate(cls, *args, **kwargs): ...
    @classmethod
    def clearResult(cls, *args, **kwargs): ...
    @classmethod
    def setResult(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxDragAndDropBehavior:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def shouldBeUsedFor(cls, *args, **kwargs): ...
    @classmethod
    def connectAttrToAttr(cls, *args, **kwargs): ...
    @classmethod
    def connectAttrToNode(cls, *args, **kwargs): ...
    @classmethod
    def connectNodeToAttr(cls, *args, **kwargs): ...
    @classmethod
    def connectNodeToNode(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxGlBuffer:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def openFbo(cls, *args, **kwargs): ...
    @classmethod
    def closeFbo(cls, *args, **kwargs): ...
    @classmethod
    def bindFbo(cls, *args, **kwargs): ...
    @classmethod
    def unbindFbo(cls, *args, **kwargs): ...
    @classmethod
    def beginBufferNotify(cls, *args, **kwargs): ...
    @classmethod
    def endBufferNotify(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxLocatorNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    underWorldObject: Incomplete
    localPosition: Incomplete
    localPositionX: Incomplete
    localPositionY: Incomplete
    localPositionZ: Incomplete
    worldPosition: Incomplete
    worldPositionX: Incomplete
    worldPositionY: Incomplete
    worldPositionZ: Incomplete
    localScale: Incomplete
    localScaleX: Incomplete
    localScaleY: Incomplete
    localScaleZ: Incomplete
    nodeBoundingBox: Incomplete
    nodeBoundingBoxMin: Incomplete
    nodeBoundingBoxMinX: Incomplete
    nodeBoundingBoxMinY: Incomplete
    nodeBoundingBoxMinZ: Incomplete
    nodeBoundingBoxMax: Incomplete
    nodeBoundingBoxMaxX: Incomplete
    nodeBoundingBoxMaxY: Incomplete
    nodeBoundingBoxMaxZ: Incomplete
    nodeBoundingBoxSize: Incomplete
    nodeBoundingBoxSizeX: Incomplete
    nodeBoundingBoxSizeY: Incomplete
    nodeBoundingBoxSizeZ: Incomplete
    center: Incomplete
    boundingBoxCenterX: Incomplete
    boundingBoxCenterY: Incomplete
    boundingBoxCenterZ: Incomplete
    matrix: Incomplete
    inverseMatrix: Incomplete
    worldMatrix: Incomplete
    worldInverseMatrix: Incomplete
    parentMatrix: Incomplete
    parentInverseMatrix: Incomplete
    visibility: Incomplete
    intermediateObject: Incomplete
    isTemplated: Incomplete
    instObjGroups: Incomplete
    objectGroups: Incomplete
    objectGrpCompList: Incomplete
    objectGroupId: Incomplete
    objectGroupColor: Incomplete
    useObjectColor: Incomplete
    objectColor: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def draw(cls, *args, **kwargs): ...
    @classmethod
    def isBounded(cls, *args, **kwargs): ...
    @classmethod
    def boundingBox(cls, *args, **kwargs): ...
    @classmethod
    def getCacheSetup(cls, *args, **kwargs): ...
    @classmethod
    def color(cls, *args, **kwargs): ...
    @classmethod
    def colorRGB(cls, *args, **kwargs): ...
    @classmethod
    def excludeAsLocator(cls, *args, **kwargs): ...
    @classmethod
    def isTransparent(cls, *args, **kwargs): ...
    @classmethod
    def drawLast(cls, *args, **kwargs): ...
    @classmethod
    def useClosestPointForSelection(cls, *args, **kwargs): ...
    @classmethod
    def closestPoint(cls, *args, **kwargs): ...
    @classmethod
    def getShapeSelectionMask(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxManipContainer(MPxNode):
    kFreePointTriadManip: ClassVar[int] = ...
    kDirectionManip: ClassVar[int] = ...
    kDistanceManip: ClassVar[int] = ...
    kPointOnCurveManip: ClassVar[int] = ...
    kPointOnSurfaceManip: ClassVar[int] = ...
    kDiscManip: ClassVar[int] = ...
    kCircleSweepManip: ClassVar[int] = ...
    kToggleManip: ClassVar[int] = ...
    kStateManip: ClassVar[int] = ...
    kCurveSegmentManip: ClassVar[int] = ...
    kCustomManip: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @staticmethod
    def initialize(*args, **kwargs): ...
    @staticmethod
    def newManipulator(*args, **kwargs): ...
    @classmethod
    def draw(cls, *args, **kwargs): ...
    @classmethod
    def connectToDependNode(cls, *args, **kwargs): ...
    @classmethod
    def createChildren(cls, *args, **kwargs): ...
    @classmethod
    def addFreePointTriadManip(cls, *args, **kwargs): ...
    @classmethod
    def addDirectionManip(cls, *args, **kwargs): ...
    @classmethod
    def addDistanceManip(cls, *args, **kwargs): ...
    @classmethod
    def addPointOnCurveManip(cls, *args, **kwargs): ...
    @classmethod
    def addPointOnSurfaceManip(cls, *args, **kwargs): ...
    @classmethod
    def addDiscManip(cls, *args, **kwargs): ...
    @classmethod
    def addCircleSweepManip(cls, *args, **kwargs): ...
    @classmethod
    def addToggleManip(cls, *args, **kwargs): ...
    @classmethod
    def addStateManip(cls, *args, **kwargs): ...
    @classmethod
    def addCurveSegmentManip(cls, *args, **kwargs): ...
    @classmethod
    def addRotateManip(cls, *args, **kwargs): ...
    @classmethod
    def addScaleManip(cls, *args, **kwargs): ...
    @classmethod
    def addMPxManipulatorNode(cls, *args, **kwargs): ...
    @classmethod
    def isManipActive(cls, *args, **kwargs): ...
    @classmethod
    def finishAddingManips(cls, *args, **kwargs): ...
    @staticmethod
    def addToManipConnectTable(*args, **kwargs): ...
    @staticmethod
    def removeFromManipConnectTable(*args, **kwargs): ...
    @classmethod
    def plugToManipConversion(cls, *args, **kwargs): ...
    @classmethod
    def manipToPlugConversion(cls, *args, **kwargs): ...
    @classmethod
    def addPlugToManipConversion(cls, *args, **kwargs): ...
    @classmethod
    def addManipToPlugConversion(cls, *args, **kwargs): ...
    @classmethod
    def addPlugToInViewEditor(cls, *args, **kwargs): ...
    @classmethod
    def getConverterManipValue(cls, *args, **kwargs): ...
    @classmethod
    def getConverterPlugValue(cls, *args, **kwargs): ...
    @classmethod
    def doPress(cls, *args, **kwargs): ...
    @classmethod
    def doDrag(cls, *args, **kwargs): ...
    @classmethod
    def doRelease(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxMidiInputDevice:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def openDevice(cls, *args, **kwargs): ...
    @classmethod
    def closeDevice(cls, *args, **kwargs): ...
    @classmethod
    def nameAxes(cls, *args, **kwargs): ...
    @classmethod
    def nameButtons(cls, *args, **kwargs): ...
    @classmethod
    def deviceState(cls, *args, **kwargs): ...
    @classmethod
    def sendMessage(cls, *args, **kwargs): ...
    @classmethod
    def getMessage(cls, *args, **kwargs): ...
    @classmethod
    def doButtonEvents(cls, *args, **kwargs): ...
    @classmethod
    def doMovementEvents(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxModelEditorCommand:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def doEditFlags(cls, *args, **kwargs): ...
    @classmethod
    def doQueryFlags(cls, *args, **kwargs): ...
    @classmethod
    def appendSyntax(cls, *args, **kwargs): ...
    @classmethod
    def skipFlagForCreate(cls, *args, **kwargs): ...
    @classmethod
    def setResult(cls, *args, **kwargs): ...
    @classmethod
    def editorCommandName(cls, *args, **kwargs): ...
    @classmethod
    def editorMenuScriptName(cls, *args, **kwargs): ...
    @classmethod
    def makeModelView(cls, *args, **kwargs): ...
    @classmethod
    def modelView(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxSelectionContext(MPxContext):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def doPress(cls, *args, **kwargs): ...
    @classmethod
    def doRelease(cls, *args, **kwargs): ...
    @classmethod
    def doDrag(cls, *args, **kwargs): ...
    @classmethod
    def doHold(cls, *args, **kwargs): ...
    @classmethod
    def helpStateHasChanged(cls, *args, **kwargs): ...
    @classmethod
    def addManipulator(cls, *args, **kwargs): ...
    @classmethod
    def deleteManipulators(cls, *args, **kwargs): ...
    @classmethod
    def setAllowPreSelectHilight(cls, *args, **kwargs): ...
    @classmethod
    def setAllowSoftSelect(cls, *args, **kwargs): ...
    @classmethod
    def setAllowSymmetry(cls, *args, **kwargs): ...
    @classmethod
    def setAllowDoubleClickAction(cls, *args, **kwargs): ...
    @classmethod
    def setAllowPaintSelect(cls, *args, **kwargs): ...
    @classmethod
    def setImage(cls, *args, **kwargs): ...
    @classmethod
    def image(cls, *args, **kwargs): ...
    @classmethod
    def newToolCommand(cls, *args, **kwargs): ...
    @classmethod
    def abortAction(cls, *args, **kwargs): ...
    @classmethod
    def processNumericalInput(cls, *args, **kwargs): ...
    @classmethod
    def feedbackNumericalInput(cls, *args, **kwargs): ...
    @classmethod
    def argTypeNumericalInput(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxSurfaceShapeUI:
    __init__: ClassVar[Callable] = ...
    kSelectMeshUVs: ClassVar[int] = ...
    kSelectMeshVerts: ClassVar[int] = ...
    kSelectMeshFaces: ClassVar[int] = ...
    kSelectMeshEdges: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def getDrawData(cls, *args, **kwargs): ...
    @classmethod
    def getDrawRequests(cls, *args, **kwargs): ...
    @classmethod
    def draw(cls, *args, **kwargs): ...
    @classmethod
    def select(cls, *args, **kwargs): ...
    @classmethod
    def snap(cls, *args, **kwargs): ...
    @classmethod
    def canDrawUV(cls, *args, **kwargs): ...
    @classmethod
    def drawUV(cls, *args, **kwargs): ...
    @classmethod
    def selectUV(cls, *args, **kwargs): ...
    @classmethod
    def surfaceShape(cls, *args, **kwargs): ...
    @classmethod
    def material(cls, *args, **kwargs): ...
    @classmethod
    def materials(cls, *args, **kwargs): ...
    @staticmethod
    def surfaceShapeUI(*args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxTexContext(MPxContext):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def viewToPort(cls, *args, **kwargs): ...
    @classmethod
    def portToView(cls, *args, **kwargs): ...
    @classmethod
    def viewRect(cls, *args, **kwargs): ...
    @classmethod
    def portSize(cls, *args, **kwargs): ...
    @staticmethod
    def getMarqueeSelection(*args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def newToolCommand(cls, *args, **kwargs): ...

class MPxToolCommand(MPxCommand):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def doIt(cls, *args, **kwargs): ...
    @classmethod
    def cancel(cls, *args, **kwargs): ...
    @classmethod
    def finalize(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxPolyTweakUVInteractiveCommand(MPxToolCommand):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def setUVs(cls, *args, **kwargs): ...
    @classmethod
    def isUndoable(cls, *args, **kwargs): ...
    @classmethod
    def doIt(cls, *args, **kwargs): ...
    @classmethod
    def cancel(cls, *args, **kwargs): ...
    @classmethod
    def finalize(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxUIControl:
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxUITableControl(MPxUIControl):
    __init__: ClassVar[Callable] = ...
    kNoLabel: ClassVar[int] = ...
    kRowLabel: ClassVar[int] = ...
    kColumnLabel: ClassVar[int] = ...
    kAllLabels: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def redrawLabels(cls, *args, **kwargs): ...
    @classmethod
    def redrawCells(cls, *args, **kwargs): ...
    @classmethod
    def addToSelection(cls, *args, **kwargs): ...
    @classmethod
    def removeFromSelection(cls, *args, **kwargs): ...
    @classmethod
    def clearSelection(cls, *args, **kwargs): ...
    @classmethod
    def setSelection(cls, *args, **kwargs): ...
    @classmethod
    def setNumberOfRows(cls, *args, **kwargs): ...
    @classmethod
    def numberOfRows(cls, *args, **kwargs): ...
    @classmethod
    def setNumberOfColumns(cls, *args, **kwargs): ...
    @classmethod
    def numberOfColumns(cls, *args, **kwargs): ...
    @classmethod
    def suspendUpdates(cls, *args, **kwargs): ...
    @classmethod
    def isSelected(cls, *args, **kwargs): ...
    @classmethod
    def collapseOrExpandRow(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...
    @classmethod
    def cellString(cls, *args, **kwargs): ...
    @classmethod
    def labelString(cls, *args, **kwargs): ...
    @classmethod
    def allowEdit(cls, *args, **kwargs): ...
    @classmethod
    def allowSelection(cls, *args, **kwargs): ...
    @classmethod
    def getCellColor(cls, *args, **kwargs): ...

class MPxHwShaderNode(MPxNode):
    kWriteNone: ClassVar[int] = ...
    kWriteVertexArray: ClassVar[int] = ...
    kWriteNormalArray: ClassVar[int] = ...
    kWriteColorArrays: ClassVar[int] = ...
    kWriteTexCoordArrays: ClassVar[int] = ...
    kWriteAll: ClassVar[int] = ...
    kDirtyNone: ClassVar[int] = ...
    kDirtyVertexArray: ClassVar[int] = ...
    kDirtyNormalArray: ClassVar[int] = ...
    kDirtyColorArrays: ClassVar[int] = ...
    kDirtyTexCoordArrays: ClassVar[int] = ...
    kDirtyAll: ClassVar[int] = ...
    kIsTransparent: ClassVar[int] = ...
    kNoTransparencyFrontBackCull: ClassVar[int] = ...
    kNoTransparencyPolygonSort: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    outColor: Incomplete
    outColorR: Incomplete
    outColorG: Incomplete
    outColorB: Incomplete
    outTransparency: Incomplete
    outTransparencyR: Incomplete
    outTransparencyG: Incomplete
    outTransparencyB: Incomplete
    outMatteOpacity: Incomplete
    outMatteOpacityR: Incomplete
    outMatteOpacityG: Incomplete
    outMatteOpacityB: Incomplete
    outGlowColor: Incomplete
    outGlowColorR: Incomplete
    outGlowColorG: Incomplete
    outGlowColorB: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def bind(cls, *args, **kwargs): ...
    @classmethod
    def unbind(cls, *args, **kwargs): ...
    @classmethod
    def geometry(cls, *args, **kwargs): ...
    @classmethod
    def glBind(cls, *args, **kwargs): ...
    @classmethod
    def glUnbind(cls, *args, **kwargs): ...
    @classmethod
    def glGeometry(cls, *args, **kwargs): ...
    @classmethod
    def supportsBatching(cls, *args, **kwargs): ...
    @classmethod
    def invertTexCoords(cls, *args, **kwargs): ...
    @classmethod
    def currentPath(cls, *args, **kwargs): ...
    @classmethod
    def dirtyMask(cls, *args, **kwargs): ...
    @classmethod
    def normalsPerVertex(cls, *args, **kwargs): ...
    @classmethod
    def colorsPerVertex(cls, *args, **kwargs): ...
    @classmethod
    def texCoordsPerVertex(cls, *args, **kwargs): ...
    @classmethod
    def hasTransparency(cls, *args, **kwargs): ...
    @classmethod
    def provideVertexIDs(cls, *args, **kwargs): ...
    @classmethod
    def provideFaceIDs(cls, *args, **kwargs): ...
    @classmethod
    def provideLocalUVCoord(cls, *args, **kwargs): ...
    @classmethod
    def transparencyOptions(cls, *args, **kwargs): ...
    @classmethod
    def renderSwatchImage(cls, *args, **kwargs): ...
    @staticmethod
    def getHwShaderNodePtr(*args, **kwargs): ...
    @classmethod
    def currentShadingEngine(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxHardwareShader(MPxNode):
    kIsTransparent: ClassVar[int] = ...
    kNoTransparencyFrontBackCull: ClassVar[int] = ...
    kNoTransparencyPolygonSort: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    outColor: Incomplete
    outColorR: Incomplete
    outColorG: Incomplete
    outColorB: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def setVaryingParameters(cls, *args, **kwargs): ...
    @classmethod
    def setUniformParameters(cls, *args, **kwargs): ...
    @classmethod
    def render(cls, *args, **kwargs): ...
    @classmethod
    def transparencyOptions(cls, *args, **kwargs): ...
    @classmethod
    def profile(cls, *args, **kwargs): ...
    @classmethod
    def renderSwatchImage(cls, *args, **kwargs): ...
    @staticmethod
    def getHardwareShaderPtr(*args, **kwargs): ...
    @staticmethod
    def findResource(*args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxManipulatorNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    connectedNodes: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def connectToDependNode(cls, *args, **kwargs): ...
    @classmethod
    def draw(cls, *args, **kwargs): ...
    @classmethod
    def doPress(cls, *args, **kwargs): ...
    @classmethod
    def doDrag(cls, *args, **kwargs): ...
    @classmethod
    def doRelease(cls, *args, **kwargs): ...
    @classmethod
    def doMove(cls, *args, **kwargs): ...
    @classmethod
    def finishAddingManips(cls, *args, **kwargs): ...
    @classmethod
    def colorAndName(cls, *args, **kwargs): ...
    @classmethod
    def shouldDrawHandleAsSelected(cls, *args, **kwargs): ...
    @classmethod
    def setHandleColor(cls, *args, **kwargs): ...
    @classmethod
    def glFirstHandle(cls, *args, **kwargs): ...
    @classmethod
    def glActiveName(cls, *args, **kwargs): ...
    @classmethod
    def mouseRay(cls, *args, **kwargs): ...
    @classmethod
    def mouseRayWorld(cls, *args, **kwargs): ...
    @classmethod
    def mousePosition(cls, *args, **kwargs): ...
    @classmethod
    def mouseDown(cls, *args, **kwargs): ...
    @classmethod
    def mouseUp(cls, *args, **kwargs): ...
    @classmethod
    def registerForMouseMove(cls, *args, **kwargs): ...
    @classmethod
    def deregisterForMouseMove(cls, *args, **kwargs): ...
    @classmethod
    def addDoubleValue(cls, *args, **kwargs): ...
    @classmethod
    def addPointValue(cls, *args, **kwargs): ...
    @classmethod
    def addVectorValue(cls, *args, **kwargs): ...
    @classmethod
    def setDoubleValue(cls, *args, **kwargs): ...
    @classmethod
    def setPointValue(cls, *args, **kwargs): ...
    @classmethod
    def setVectorValue(cls, *args, **kwargs): ...
    @classmethod
    def getDoubleValue(cls, *args, **kwargs): ...
    @classmethod
    def getPointValue(cls, *args, **kwargs): ...
    @classmethod
    def getVectorValue(cls, *args, **kwargs): ...
    @classmethod
    def connectPlugToValue(cls, *args, **kwargs): ...
    @staticmethod
    def newManipulator(*args, **kwargs): ...
    @classmethod
    def addDependentPlug(cls, *args, **kwargs): ...
    @classmethod
    def dependentPlugsReset(cls, *args, **kwargs): ...
    @classmethod
    def mainColor(cls, *args, **kwargs): ...
    @classmethod
    def xColor(cls, *args, **kwargs): ...
    @classmethod
    def yColor(cls, *args, **kwargs): ...
    @classmethod
    def zColor(cls, *args, **kwargs): ...
    @classmethod
    def prevColor(cls, *args, **kwargs): ...
    @classmethod
    def lineColor(cls, *args, **kwargs): ...
    @classmethod
    def dimmedColor(cls, *args, **kwargs): ...
    @classmethod
    def selectedColor(cls, *args, **kwargs): ...
    @classmethod
    def labelColor(cls, *args, **kwargs): ...
    @classmethod
    def labelBackgroundColor(cls, *args, **kwargs): ...
    @classmethod
    def getInstancePtr(cls, *args, **kwargs): ...
    @classmethod
    def setInstancePtr(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxEmitterNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    kDirectional: ClassVar[int] = ...
    kOmni: ClassVar[int] = ...
    kSurface: ClassVar[int] = ...
    kCurve: ClassVar[int] = ...
    kVolume: ClassVar[int] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    mEmitterType: Incomplete
    mRate: Incomplete
    mSpeed: Incomplete
    mDirection: Incomplete
    mDirectionX: Incomplete
    mDirectionY: Incomplete
    mDirectionZ: Incomplete
    mOwnerPosData: Incomplete
    mOwnerVelData: Incomplete
    mOwnerCentroid: Incomplete
    mOwnerCentroidX: Incomplete
    mOwnerCentroidY: Incomplete
    mOwnerCentroidZ: Incomplete
    mSweptGeometry: Incomplete
    mWorldMatrix: Incomplete
    mStartTime: Incomplete
    mDeltaTime: Incomplete
    mIsFull: Incomplete
    mInheritFactor: Incomplete
    mSeed: Incomplete
    mRandState: Incomplete
    mRandStateX: Incomplete
    mRandStateY: Incomplete
    mRandStateZ: Incomplete
    mCurrentTime: Incomplete
    mOutput: Incomplete
    mMinDistance: Incomplete
    mMaxDistance: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @classmethod
    def draw(cls, *args, **kwargs): ...
    @classmethod
    def getEmitterType(cls, *args, **kwargs): ...
    @classmethod
    def getOwnerShape(cls, *args, **kwargs): ...
    @classmethod
    def getCurrentTime(cls, *args, **kwargs): ...
    @classmethod
    def getStartTime(cls, *args, **kwargs): ...
    @classmethod
    def getDeltaTime(cls, *args, **kwargs): ...
    @classmethod
    def getRandomSeed(cls, *args, **kwargs): ...
    @classmethod
    def getRandomState(cls, *args, **kwargs): ...
    @classmethod
    def setRandomState(cls, *args, **kwargs): ...
    @classmethod
    def resetRandomState(cls, *args, **kwargs): ...
    @classmethod
    def randgen(cls, *args, **kwargs): ...
    @classmethod
    def getRate(cls, *args, **kwargs): ...
    @classmethod
    def getMinDistance(cls, *args, **kwargs): ...
    @classmethod
    def getMaxDistance(cls, *args, **kwargs): ...
    @classmethod
    def getWorldPosition(cls, *args, **kwargs): ...
    @classmethod
    def getWorldMatrix(cls, *args, **kwargs): ...
    @classmethod
    def volumePrimitiveBoundingBox(cls, *args, **kwargs): ...
    @classmethod
    def volumePrimitivePointInside(cls, *args, **kwargs): ...
    @classmethod
    def volumePrimitiveDistanceFromAxis(cls, *args, **kwargs): ...
    @classmethod
    def hasValidEmission2dTexture(cls, *args, **kwargs): ...
    @classmethod
    def evalEmission2dTexture(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxFieldNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    mMagnitude: Incomplete
    mAttenuation: Incomplete
    mMaxDistance: Incomplete
    mUseMaxDistance: Incomplete
    mApplyPerVertex: Incomplete
    mInputData: Incomplete
    mInputPositions: Incomplete
    mInputVelocities: Incomplete
    mInputMass: Incomplete
    mDeltaTime: Incomplete
    mInputForce: Incomplete
    mOutputForce: Incomplete
    mOwnerCentroidX: Incomplete
    mOwnerCentroidY: Incomplete
    mOwnerCentroidZ: Incomplete
    mOwnerCentroid: Incomplete
    mOwnerPosData: Incomplete
    mOwnerVelData: Incomplete
    mWorldMatrix: Incomplete
    mInputPPData: Incomplete
    mOwnerPPData: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @classmethod
    def getForceAtPoint(cls, *args, **kwargs): ...
    @classmethod
    def iconSizeAndOrigin(cls, *args, **kwargs): ...
    @classmethod
    def iconBitmap(cls, *args, **kwargs): ...
    @classmethod
    def draw(cls, *args, **kwargs): ...
    @classmethod
    def falloffCurve(cls, *args, **kwargs): ...
    @classmethod
    def isFalloffCurveConstantOne(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxFluidEmitterNode(MPxEmitterNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    mFluidDensityEmission: Incomplete
    mFluidHeatEmission: Incomplete
    mFluidFuelEmission: Incomplete
    mEmitFluidColor: Incomplete
    mFluidColor: Incomplete
    mFluidColorR: Incomplete
    mFluidColorG: Incomplete
    mFluidColorB: Incomplete
    mFluidDropoff: Incomplete
    mTurbulence: Incomplete
    mFluidJitter: Incomplete
    mEmissionFunction: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @classmethod
    def fluidEmitter(cls, *args, **kwargs): ...
    @classmethod
    def fluidDensityEmission(cls, *args, **kwargs): ...
    @classmethod
    def fluidHeatEmission(cls, *args, **kwargs): ...
    @classmethod
    def fluidFuelEmission(cls, *args, **kwargs): ...
    @classmethod
    def fluidEmitColor(cls, *args, **kwargs): ...
    @classmethod
    def fluidColor(cls, *args, **kwargs): ...
    @classmethod
    def fluidDropoff(cls, *args, **kwargs): ...
    @classmethod
    def turbulence(cls, *args, **kwargs): ...
    @classmethod
    def fluidJitter(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxSpringNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    mEnd1Weight: Incomplete
    mEnd2Weight: Incomplete
    mDeltaTime: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def applySpringLaw(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxParticleAttributeMapperNode(MPxNode):
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    computeNode: Incomplete
    uCoordPP: Incomplete
    vCoordPP: Incomplete
    outMinValue: Incomplete
    outMaxValue: Incomplete
    computeNodeColor: Incomplete
    computeNodeColorR: Incomplete
    computeNodeColorG: Incomplete
    computeNodeColorB: Incomplete
    time: Incomplete
    outColorPP: Incomplete
    outValuePP: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def type(cls, *args, **kwargs): ...
    @classmethod
    def compute(cls, *args, **kwargs): ...
    @staticmethod
    def className(*args, **kwargs): ...

class MPxRenderPassImpl:
    kUInt8: ClassVar[int] = ...
    kUInt16: ClassVar[int] = ...
    kUInt32: ClassVar[int] = ...
    kUInt64: ClassVar[int] = ...
    kInt8: ClassVar[int] = ...
    kInt16: ClassVar[int] = ...
    kInt32: ClassVar[int] = ...
    kInt64: ClassVar[int] = ...
    kFloat16: ClassVar[int] = ...
    kFloat32: ClassVar[int] = ...
    kFloat64: ClassVar[int] = ...
    kBit: ClassVar[int] = ...
    kOther: ClassVar[int] = ...
    kInvalidSemantic: ClassVar[int] = ...
    kColorSemantic: ClassVar[int] = ...
    kVectorSemantic: ClassVar[int] = ...
    kDirectionVectorSemantic: ClassVar[int] = ...
    kDepthSemantic: ClassVar[int] = ...
    kLabelSemantic: ClassVar[int] = ...
    kMaskSemantic: ClassVar[int] = ...
    kOtherSemantic: ClassVar[int] = ...
    __init__: ClassVar[Callable] = ...
    __disown__: ClassVar[Callable] = ...
    thisown: Incomplete
    @classmethod
    def __swig_destroy__(cls, *args, **kwargs): ...
    @classmethod
    def isCompatible(cls, *args, **kwargs): ...
    @classmethod
    def typesSupported(cls, *args, **kwargs): ...
    @classmethod
    def getDefaultType(cls, *args, **kwargs): ...
    @classmethod
    def getNumChannels(cls, *args, **kwargs): ...
    @classmethod
    def frameBufferSemantic(cls, *args, **kwargs): ...
    @classmethod
    def perLightPassContributionSupported(cls, *args, **kwargs): ...
def asMPxPtr(mpxObj): ...
def asHashable(mpxObj): ...

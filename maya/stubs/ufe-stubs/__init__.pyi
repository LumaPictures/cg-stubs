from _typeshed import Incomplete
from typing import Callable, ClassVar, Iterator, overload

class AreaInterface:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def normalize(self, arg0: bool, /) -> None: ...
    @overload
    def normalize(self) -> bool: ...
    def normalizeCmd(self, *args, **kwargs): ...

class Attribute:
    kBool: ClassVar[str] = ...
    kColorFloat3: ClassVar[str] = ...
    kColorFloat4: ClassVar[str] = ...
    kDouble: ClassVar[str] = ...
    kDouble3: ClassVar[str] = ...
    kEnumString: ClassVar[str] = ...
    kFilename: ClassVar[str] = ...
    kFloat: ClassVar[str] = ...
    kFloat2: ClassVar[str] = ...
    kFloat3: ClassVar[str] = ...
    kFloat4: ClassVar[str] = ...
    kGeneric: ClassVar[str] = ...
    kInt: ClassVar[str] = ...
    kInt3: ClassVar[str] = ...
    kInvalid: ClassVar[str] = ...
    kLocked: ClassVar[str] = ...
    kMatrix3d: ClassVar[str] = ...
    kMatrix4d: ClassVar[str] = ...
    kString: ClassVar[str] = ...
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def clearMetadata(self, arg0: str, /) -> bool: ...
    def clearMetadataCmd(self, *args, **kwargs): ...
    def getDocumentation(self) -> str: ...
    def getMetadata(self, arg0: str, /) -> Value: ...
    def hasMetadata(self, arg0: str, /) -> bool: ...
    def hasValue(self) -> bool: ...
    def sceneItem(self) -> SceneItem: ...
    def setMetadata(self, arg0: str, arg1: Value, /) -> bool: ...
    def setMetadataCmd(self, *args, **kwargs): ...
    def __eq__(self, arg0: Attribute, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Attribute, /) -> bool: ...  # type: ignore
    @property
    def displayName(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def type(self) -> str: ...

class AttributeAdded(AttributeChanged):
    def __init__(self, arg0: Path, arg1: str, /) -> None: ...
    def name(self) -> str: ...
    def path(self) -> Path: ...

class AttributeBool(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> bool: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: bool, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeChanged(Notification):
    def __init__(self, arg0: Path, arg1: str, /) -> None: ...
    def name(self) -> str: ...
    def path(self) -> Path: ...

class AttributeColorFloat3(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Color3f: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Color3f, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeColorFloat4(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Color4f: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Color4f, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeCommand(UndoableCommand):
    def __init__(self) -> None: ...
    @property
    def attribute(self) -> Attribute: ...

class AttributeConnectionChanged(AttributeChanged):
    def __init__(self, arg0: Path, arg1: str, /) -> None: ...
    def name(self) -> str: ...
    def path(self) -> Path: ...

class AttributeDef:
    class IOType:
        __members__: ClassVar[dict] = ...  # read-only
        INPUT_ATTR: ClassVar[AttributeDef.IOType] = ...
        OUTPUT_ATTR: ClassVar[AttributeDef.IOType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    INPUT_ATTR: ClassVar[AttributeDef.IOType] = ...
    OUTPUT_ATTR: ClassVar[AttributeDef.IOType] = ...
    kNativeType: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def defaultValue(self) -> str: ...
    def getMetadata(self, arg0: str, /) -> Value: ...
    def hasMetadata(self, arg0: str, /) -> bool: ...
    def ioType(self, *args, **kwargs): ...
    def name(self) -> str: ...
    def type(self) -> str: ...

class AttributeDouble(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> float: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: float, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeDouble3(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Vector3d: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Vector3d, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeEnumString(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> str: ...
    def getEnumValues(self) -> list[str]: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: str, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeFilename(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> str: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: str, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeFloat(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> float: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: float, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeFloat2(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Vector2f: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Vector2f, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeFloat3(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Vector3f: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Vector3f, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeFloat4(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Vector4f: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Vector4f, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeGeneric(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def nativeType(self) -> str: ...

class AttributeInfo:
    @overload
    def __init__(self, arg0: Path, arg1: str, /) -> None: ...
    @overload
    def __init__(self, arg0: Attribute, /) -> None: ...
    def attribute(self) -> Attribute: ...
    @property
    def name(self) -> str: ...
    @property
    def path(self) -> Path: ...
    @property
    def runTimeId(self) -> int: ...

class AttributeInt(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> int: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: int, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeInt3(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Vector3i: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Vector3i, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeMatrix3d(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Matrix3d: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Matrix3d, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeMatrix4d(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> Matrix4d: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: Matrix4d, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeMetadataChanged(AttributeChanged):
    def __init__(self, arg0: Path, arg1: str, arg2: set[str], /) -> None: ...
    def keys(self) -> set[str]: ...
    def name(self) -> str: ...
    def path(self) -> Path: ...

class AttributeRemoved(AttributeChanged):
    def __init__(self, arg0: Path, arg1: str, /) -> None: ...
    def name(self) -> str: ...
    def path(self) -> Path: ...

class AttributeString(Attribute):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def get(self) -> str: ...
    def isDefault(self) -> bool: ...
    def reset(self) -> None: ...
    def resetCmd(self, *args, **kwargs): ...
    def set(self, arg0: str, /) -> None: ...
    def setCmd(self, *args, **kwargs): ...

class AttributeValueChanged(AttributeChanged):
    def __init__(self, arg0: Path, arg1: str, /) -> None: ...
    def name(self) -> str: ...
    def path(self) -> Path: ...

class Attributes:
    attribute: ClassVar[Callable] = ...
    def __init__(self) -> None: ...
    def addAttribute(self, arg0: str, arg1: str, /) -> Attribute: ...
    def addAttributeCmd(self, *args, **kwargs): ...
    @overload
    @staticmethod
    def addObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def addObserver(arg0: Observer, /) -> bool: ...
    def attributeType(self, arg0: str, /) -> str: ...
    @staticmethod
    def attributes(arg0: SceneItem, /) -> Attributes: ...
    def getEnums(self, arg0: str, /) -> list[tuple[str, str]]: ...
    def getRawAddress(self) -> int: ...
    def hasAttribute(self, arg0: str, /) -> bool: ...
    @overload
    @staticmethod
    def hasObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def hasObserver(arg0: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: Path, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: int, /) -> bool: ...
    @overload
    @staticmethod
    def nbObservers(arg0: SceneItem, /) -> int: ...
    @overload
    @staticmethod
    def nbObservers() -> int: ...
    @staticmethod
    def notify(arg0, /) -> None: ...
    def removeAttribute(self, arg0: str, /) -> bool: ...
    def removeAttributeCmd(self, *args, **kwargs): ...
    @overload
    @staticmethod
    def removeObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def removeObserver(arg0: Observer, /) -> bool: ...
    def renameAttribute(self, arg0: str, arg1: str, /) -> Attribute: ...
    def renameAttributeCmd(self, *args, **kwargs): ...
    def sceneItem(self) -> SceneItem: ...
    @property
    def attributeNames(self) -> list[str]: ...

class AttributesHandler:
    def __init__(self) -> None: ...
    def attributes(self, arg0: SceneItem, /) -> Attributes: ...

class BBox3d:
    max: Incomplete
    min: Incomplete
    def __init__(self) -> None: ...
    def empty(self) -> bool: ...

class BatchCompositeCommand(CompositeUndoableCommand):
    def __init__(self, arg0: Selection, arg1: str, /) -> None: ...
    def append(self, arg0: UndoableCommand, /) -> None: ...
    def cmdsList(self) -> list[UndoableCommand]: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class BatchOpsHandler:
    def __init__(self) -> None: ...
    @staticmethod
    def duplicateSelectionCmd(*args, **kwargs): ...
    def duplicateSelectionCmd_(self, *args, **kwargs): ...

class Camera:
    class Projection:
        __members__: ClassVar[dict] = ...  # read-only
        Orthographic: ClassVar[Camera.Projection] = ...
        Perspective: ClassVar[Camera.Projection] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Orthographic: ClassVar[Camera.Projection] = ...
    Perspective: ClassVar[Camera.Projection] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def addObserver(arg0, arg1, /) -> bool: ...
    @staticmethod
    def camera(arg0, /) -> Camera: ...
    @overload
    def fStop(self, arg0: float, /) -> None: ...
    @overload
    def fStop(self) -> float: ...
    def fStopCmd(self, *args, **kwargs): ...
    @overload
    def farClipPlane(self, arg0: float, /) -> None: ...
    @overload
    def farClipPlane(self) -> float: ...
    def farClipPlaneCmd(self, *args, **kwargs): ...
    @overload
    def focalLength(self, arg0: float, /) -> None: ...
    @overload
    def focalLength(self) -> float: ...
    def focalLengthCmd(self, *args, **kwargs): ...
    @overload
    def focusDistance(self, arg0: float, /) -> None: ...
    @overload
    def focusDistance(self) -> float: ...
    def focusDistanceCmd(self, *args, **kwargs): ...
    @staticmethod
    def hasObserver(arg0, arg1, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: int, /) -> bool: ...  # type: ignore
    @overload
    def horizontalAperture(self, arg0: float, /) -> None: ...
    @overload
    def horizontalAperture(self) -> float: ...
    def horizontalApertureCmd(self, *args, **kwargs): ...
    @overload
    def horizontalApertureOffset(self, arg0: float, /) -> None: ...
    @overload
    def horizontalApertureOffset(self) -> float: ...
    def horizontalApertureOffsetCmd(self, *args, **kwargs): ...
    @staticmethod
    def nbObservers(arg0, /) -> int: ...
    @overload
    def nearClipPlane(self, arg0: float, /) -> None: ...
    @overload
    def nearClipPlane(self) -> float: ...
    def nearClipPlaneCmd(self, *args, **kwargs): ...
    @staticmethod
    def notify(arg0, /) -> None: ...
    def path(self, *args, **kwargs): ...
    def projection(self, arg0, /) -> None: ...
    def projectionCmd(self, *args, **kwargs): ...
    @overload
    @staticmethod
    def removeObserver(arg0, arg1, /) -> bool: ...
    @overload
    @staticmethod
    def removeObserver(arg0, arg1, /) -> bool: ...  # type: ignore
    def renderable(self) -> bool: ...
    def sceneItem(self, *args, **kwargs): ...
    @overload
    def verticalAperture(self, arg0: float, /) -> None: ...
    @overload
    def verticalAperture(self) -> float: ...
    def verticalApertureCmd(self, *args, **kwargs): ...
    @overload
    def verticalApertureOffset(self, arg0: float, /) -> None: ...
    @overload
    def verticalApertureOffset(self) -> float: ...
    def verticalApertureOffsetCmd(self, *args, **kwargs): ...

class CameraChanged(Notification):
    @overload
    def __init__(self, arg0: CameraChanged, /) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class CameraHandler:
    def __init__(self) -> None: ...
    def camera(self, arg0, /) -> Camera: ...
    @staticmethod
    def find(*args, **kwargs): ...
    @staticmethod
    def findAll(*args, **kwargs): ...
    def find_(self, *args, **kwargs): ...

class CellInfo:
    fontBold: bool
    fontItalics: bool
    fontName: str
    fontPointSize: float
    fontStrikeout: bool
    textBgColor: Incomplete
    textFgColor: Incomplete
    def __init__(self) -> None: ...

class ChildFilterFlag:
    label: str
    name: str
    value: bool
    def __init__(self) -> None: ...

class ClipboardHandler:
    def __init__(self) -> None: ...
    @staticmethod
    def canBeCut(arg0: SceneItem, /) -> bool: ...
    def canBeCut_(self, arg0: SceneItem, /) -> bool: ...
    @staticmethod
    def clipboardHandler(arg0: int, /) -> ClipboardHandler: ...
    @staticmethod
    def copyCmd(arg0: Selection, /) -> UndoableCommand: ...
    @overload
    def copyCmd_(self, arg0: SceneItem, /) -> UndoableCommand: ...
    @overload
    def copyCmd_(self, arg0: Selection, /) -> UndoableCommand: ...
    @staticmethod
    def cutCmd(arg0: Selection, /) -> UndoableCommand: ...
    @overload
    def cutCmd_(self, arg0: SceneItem, /) -> UndoableCommand: ...
    @overload
    def cutCmd_(self, arg0: Selection, /) -> UndoableCommand: ...
    @staticmethod
    def hasItemsToPaste(arg0: int, /) -> bool: ...
    def hasItemsToPaste_(self) -> bool: ...
    @staticmethod
    def pasteCmd(arg0: Selection, /) -> UndoableCommand: ...
    def pasteCmd_(self, arg0: Selection, /) -> UndoableCommand: ...
    @staticmethod
    def preCopy() -> None: ...
    def preCopy_(self) -> None: ...
    @staticmethod
    def preCut() -> None: ...
    def preCut_(self) -> None: ...

class CodeWrapper:
    def __init__(self) -> None: ...
    def cleanup(self, arg0: str, /) -> None: ...
    def prelude(self, arg0: str, /) -> None: ...

class CodeWrapperContainer:
    def __init__(self, arg0: Selection, arg1: str, /) -> None: ...
    def codeWrappers(self) -> list[CodeWrapper]: ...

class CodeWrapperContext:
    def __init__(self, arg0: CodeWrapperContainer, arg1: str, /) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object, /) -> bool: ...

class CodeWrapperHandler:
    def __init__(self) -> None: ...
    def createCodeWrapper(self, arg0: Selection, arg1: str, /) -> CodeWrapper: ...
    @staticmethod
    def duplicateSelectionCmd(arg0: Selection, arg1: dict[str, Value], /) -> SelectionUndoableCommand: ...
    def duplicateSelectionCmd_(self, arg0: Selection, arg1: dict[str, Value], /) -> SelectionUndoableCommand: ...

class Color3f:
    color: list[float[3]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[3]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def b(self) -> float: ...
    def g(self) -> float: ...
    def r(self) -> float: ...
    def set(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def __eq__(self, arg0: Color3f, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Color3f, /) -> bool: ...  # type: ignore

class Color4f:
    color: list[float[4]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[4]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def g(self) -> float: ...
    def r(self) -> float: ...
    def set(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...
    def __eq__(self, arg0: Color4f, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Color4f, /) -> bool: ...  # type: ignore

class CompositeUndoableCommand(UndoableCommand):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[UndoableCommand], /) -> None: ...
    @overload
    def __init__(self, arg0: UndoableCommand, /) -> None: ...
    def append(self, arg0: UndoableCommand, /) -> None: ...
    def cmdsList(self) -> list[UndoableCommand]: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class ConeInterface:
    def __init__(self, *args, **kwargs) -> None: ...
    def coneProps(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def conePropsCmd(self, *args, **kwargs): ...

class Connection:
    def __init__(self, arg0: AttributeInfo, arg1: AttributeInfo, /) -> None: ...
    @property
    def dst(self) -> AttributeInfo: ...
    @property
    def src(self) -> AttributeInfo: ...

class ConnectionHandler:
    def __init__(self) -> None: ...
    @overload
    def connect(self, arg0: AttributeInfo, arg1: AttributeInfo, /) -> Connection: ...
    @overload
    def connect(self, arg0: Attribute, arg1: Attribute, /) -> Connection: ...
    def createConnectionCmd(self, *args, **kwargs): ...
    def deleteConnectionCmd(self, *args, **kwargs): ...
    @overload
    def disconnect(self, arg0: AttributeInfo, arg1: AttributeInfo, /) -> None: ...
    @overload
    def disconnect(self, arg0: Attribute, arg1: Attribute, /) -> None: ...
    def sourceConnections(self, arg0: SceneItem, /) -> Connections: ...

class ConnectionResultUndoableCommand(UndoableCommand):
    def __init__(self) -> None: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...
    @property
    def connection(self) -> Connection: ...

class Connections:
    class AttributeType:
        __members__: ClassVar[dict] = ...  # read-only
        ATTR_ANY: ClassVar[Connections.AttributeType] = ...
        ATTR_IS_DESTINATION: ClassVar[Connections.AttributeType] = ...
        ATTR_IS_SOURCE: ClassVar[Connections.AttributeType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    ATTR_ANY: ClassVar[Connections.AttributeType] = ...
    ATTR_IS_DESTINATION: ClassVar[Connections.AttributeType] = ...
    ATTR_IS_SOURCE: ClassVar[Connections.AttributeType] = ...
    def __init__(self) -> None: ...
    def allConnections(self) -> list[Connection]: ...
    def connections(self, arg0: Attribute, arg1, /) -> list[Connection]: ...
    def hasConnection(self, arg0: Attribute, arg1, /) -> bool: ...

class ContextItem:
    kIsOptionBox: ClassVar[str] = ...
    checkable: bool
    checked: bool
    enabled: bool
    exclusive: bool
    hasChildren: bool
    image: str
    item: str
    label: str
    metaData: Incomplete
    separator: bool
    def __init__(self) -> None: ...
    def getMetaData(self, *args, **kwargs): ...
    def setMetaData(self, arg0: str, arg1, /) -> None: ...

class ContextOps:
    def __init__(self) -> None: ...
    @staticmethod
    def contextOps(arg0, /) -> ContextOps: ...
    def doOp(self, arg0: list[str], /) -> None: ...
    def doOpCmd(self, *args, **kwargs): ...
    def getItems(self, arg0: list[str], /) -> list[ContextItem]: ...
    def sceneItem(self, *args, **kwargs): ...

class ContextOpsHandler:
    def __init__(self) -> None: ...
    def contextOps(self, arg0, /) -> ContextOps: ...

class DirectionalInterface:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def angle(self, arg0: float, /) -> None: ...
    @overload
    def angle(self) -> float: ...
    def angleCmd(self, *args, **kwargs): ...

class Duplicate:
    item: Incomplete
    undoableCommand: Incomplete
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0, arg1, /) -> None: ...

class EditTransform3dHint:
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        NoHint: ClassVar[EditTransform3dHint.Type] = ...
        Rotate: ClassVar[EditTransform3dHint.Type] = ...
        RotatePivot: ClassVar[EditTransform3dHint.Type] = ...
        Scale: ClassVar[EditTransform3dHint.Type] = ...
        ScalePivot: ClassVar[EditTransform3dHint.Type] = ...
        Translate: ClassVar[EditTransform3dHint.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    NoHint: ClassVar[EditTransform3dHint.Type] = ...
    Rotate: ClassVar[EditTransform3dHint.Type] = ...
    RotatePivot: ClassVar[EditTransform3dHint.Type] = ...
    Scale: ClassVar[EditTransform3dHint.Type] = ...
    ScalePivot: ClassVar[EditTransform3dHint.Type] = ...
    Translate: ClassVar[EditTransform3dHint.Type] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0, /) -> None: ...
    def type(self, *args, **kwargs): ...

class Hierarchy:
    def __init__(self) -> None: ...
    def appendChildCmd(self, arg0: SceneItem, /) -> InsertChildCommand: ...
    def children(self) -> list[SceneItem]: ...
    def createGroup(self, arg0: PathComponent, /) -> SceneItem: ...
    def createGroupCmd(self, arg0: PathComponent, /) -> InsertChildCommand: ...
    @staticmethod
    def createItem(arg0: Path, /) -> SceneItem: ...
    def defaultParent(self) -> SceneItem: ...
    def filteredChildren(self, arg0: list[ChildFilterFlag], /) -> list[SceneItem]: ...
    def hasChildren(self) -> bool: ...
    def hasFilteredChildren(self, arg0: list[ChildFilterFlag], /) -> bool: ...
    @staticmethod
    def hierarchy(arg0: SceneItem, /) -> Hierarchy: ...
    def insertChild(self, arg0: SceneItem, arg1: SceneItem, /) -> SceneItem: ...
    def insertChildCmd(self, arg0: SceneItem, arg1: SceneItem, /) -> InsertChildCommand: ...
    def parent(self) -> SceneItem: ...
    def reorder(self, arg0: list[SceneItem], /) -> bool: ...
    def reorderCmd(self, arg0: list[SceneItem], /) -> UndoableCommand: ...
    def sceneItem(self) -> SceneItem: ...
    def ungroup(self) -> bool: ...
    def ungroupCmd(self) -> UndoableCommand: ...

class HierarchyHandler:
    def __init__(self) -> None: ...
    def childFilter(self, *args, **kwargs): ...
    def createItem(self, arg0: Path, /) -> SceneItem: ...
    def hierarchy(self, *args, **kwargs): ...

class InsertChildCommand(UndoableCommand):
    def __init__(self) -> None: ...
    @property
    def insertedChild(self) -> SceneItem: ...

class KeysView[str]:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def __contains__(self, arg0: str, /) -> bool: ...
    @overload
    def __contains__(self, arg0: object, /) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class Light:
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        Area: ClassVar[Light.Type] = ...
        Directional: ClassVar[Light.Type] = ...
        Invalid: ClassVar[Light.Type] = ...
        Point: ClassVar[Light.Type] = ...
        Spot: ClassVar[Light.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Area: ClassVar[Light.Type] = ...
    Directional: ClassVar[Light.Type] = ...
    Invalid: ClassVar[Light.Type] = ...
    Point: ClassVar[Light.Type] = ...
    Spot: ClassVar[Light.Type] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def addObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    def areaInterface(self, *args, **kwargs): ...
    @overload
    def color(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def color(self) -> Color3f: ...
    def colorCmd(self, *args, **kwargs): ...
    def coneInterface(self, *args, **kwargs): ...
    @overload
    def diffuse(self, arg0: float, /) -> None: ...
    @overload
    def diffuse(self) -> float: ...
    def diffuseCmd(self, *args, **kwargs): ...
    def directionalInterface(self, *args, **kwargs): ...
    @staticmethod
    def hasObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: Path, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: int, /) -> bool: ...
    @overload
    def intensity(self, arg0: float, /) -> None: ...
    @overload
    def intensity(self) -> float: ...
    def intensityCmd(self, *args, **kwargs): ...
    @staticmethod
    def light(arg0: SceneItem, /) -> Light: ...
    @staticmethod
    def nbObservers(arg0: SceneItem, /) -> int: ...
    @staticmethod
    def notify(arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    @staticmethod
    def removeObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    def sceneItem(self) -> SceneItem: ...
    @overload
    def shadowColor(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def shadowColor(self) -> Color3f: ...
    def shadowColorCmd(self, *args, **kwargs): ...
    @overload
    def shadowEnable(self, arg0: bool, /) -> None: ...
    @overload
    def shadowEnable(self) -> bool: ...
    def shadowEnableCmd(self, *args, **kwargs): ...
    @overload
    def specular(self, arg0: float, /) -> None: ...
    @overload
    def specular(self) -> float: ...
    def specularCmd(self, *args, **kwargs): ...
    def sphereInterface(self, *args, **kwargs): ...
    def type(self, *args, **kwargs): ...

class LightChanged(Notification):
    @overload
    def __init__(self, arg0: LightChanged, /) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class LightHandler:
    def __init__(self) -> None: ...
    def light(self, arg0: SceneItem, /) -> Light: ...

class Light_ConeProps:
    angle: float
    focus: float
    softness: float
    def __init__(self) -> None: ...

class Light_SphereProps:
    asPoint: bool
    radius: float
    def __init__(self) -> None: ...

class Material:
    def __init__(self) -> None: ...
    def getMaterials(self) -> list[SceneItem]: ...
    def hasMaterial(self) -> bool: ...
    @staticmethod
    def material(arg0: SceneItem, /) -> Material: ...

class MaterialHandler:
    def __init__(self) -> None: ...
    def material(self, arg0: SceneItem, /) -> Material: ...

class Matrix3d:
    matrix: list[None]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[None], /) -> None: ...
    def __eq__(self, arg0: Matrix3d, /) -> bool: ...  # type: ignore
    def __mul__(self, arg0: Matrix3d, /) -> Matrix3d: ...
    def __ne__(self, arg0: Matrix3d, /) -> bool: ...  # type: ignore

class Matrix4d:
    matrix: list[None]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[None], /) -> None: ...
    def __eq__(self, arg0: Matrix4d, /) -> bool: ...  # type: ignore
    def __mul__(self, arg0: Matrix4d, /) -> Matrix4d: ...
    def __ne__(self, arg0: Matrix4d, /) -> bool: ...  # type: ignore

class NodeDef:
    def __init__(self) -> None: ...
    def classification(self, arg0: int, /) -> str: ...
    def createNode(self, arg0: SceneItem, arg1: PathComponent, /) -> SceneItem: ...
    def createNodeCmd(self, *args, **kwargs): ...
    @staticmethod
    def definition(arg0: int, arg1: str, /) -> NodeDef: ...
    def getMetadata(self, *args, **kwargs): ...
    def hasInput(self, arg0: str, /) -> bool: ...
    def hasMetadata(self, arg0: str, /) -> bool: ...
    def hasOutput(self, arg0: str, /) -> bool: ...
    def input(self, *args, **kwargs): ...
    def inputNames(self) -> list[str]: ...
    def inputs(self, *args, **kwargs): ...
    def nbClassifications(self) -> int: ...
    def output(self, *args, **kwargs): ...
    def outputNames(self) -> list[str]: ...
    def outputs(self, *args, **kwargs): ...
    def type(self) -> str: ...

class NodeDefHandler:
    def __init__(self) -> None: ...
    @overload
    def definition(self, arg0: SceneItem, /) -> NodeDef: ...
    @overload
    def definition(self, arg0: str, /) -> NodeDef: ...
    def definitions(self, arg0: str, /) -> list[NodeDef]: ...

class Notification:
    @overload
    def __init__(self, arg0: Notification, /) -> None: ...
    @overload
    def __init__(self) -> None: ...

class NotificationGuard:
    def __init__(self, arg0: Subject, /) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object, /) -> bool: ...

class Object3d:
    def __init__(self) -> None: ...
    @staticmethod
    def addObserver(arg0: Observer, /) -> bool: ...
    def boundingBox(self) -> BBox3d: ...
    @staticmethod
    def hasObserver(arg0: Observer, /) -> bool: ...
    @staticmethod
    def nbObservers() -> int: ...
    @staticmethod
    def notify(arg0: Notification, /) -> None: ...
    @staticmethod
    def object3d(arg0: SceneItem, /) -> Object3d: ...
    @staticmethod
    def removeObserver(arg0: Observer, /) -> bool: ...
    def sceneItem(self) -> SceneItem: ...
    def setVisibility(self, arg0: bool, /) -> None: ...
    def setVisibleCmd(self, *args, **kwargs): ...
    def visibility(self) -> bool: ...

class Object3dHandler:
    def __init__(self) -> None: ...
    def object3d(self, arg0: SceneItem, /) -> Object3d: ...

class ObjectAdd(SceneChanged):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def changedPath(self) -> Path: ...
    def item(self) -> SceneItem: ...

class ObjectDelete(SceneChanged):
    class SubOpType:
        __members__: ClassVar[dict] = ...  # read-only
        ObjectDelete: ClassVar[ObjectDelete.SubOpType] = ...
        ObjectDestroyed: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
        ObjectPostDelete: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
        ObjectPreDelete: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    ObjectDelete: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
    ObjectDestroyed: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
    ObjectPostDelete: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
    ObjectPreDelete: ClassVar[ObjectDelete.SubOpType] = ...  # type: ignore
    def __init__(self, arg0: Path, /) -> None: ...
    def changedPath(self) -> Path: ...
    def path(self) -> Path: ...

class ObjectDestroyed(ObjectDelete):
    def __init__(self, arg0: Path, /) -> None: ...

class ObjectPathAdd(ObjectPathChange):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def changedPath(self) -> Path: ...
    def item(self) -> SceneItem: ...

class ObjectPathChange(SceneChanged):
    class SubOpType:
        __members__: ClassVar[dict] = ...  # read-only
        ObjectPathAdd: ClassVar[ObjectPathChange.SubOpType] = ...
        ObjectPathChange: ClassVar[ObjectPathChange.SubOpType] = ...
        ObjectPathRemove: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
        ObjectRename: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
        ObjectReparent: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    ObjectPathAdd: ClassVar[ObjectPathChange.SubOpType] = ...
    ObjectPathChange: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
    ObjectPathRemove: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
    ObjectRename: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
    ObjectReparent: ClassVar[ObjectPathChange.SubOpType] = ...  # type: ignore
    def __init__(self) -> None: ...

class ObjectPathRemove(ObjectPathChange):
    def __init__(self, arg0: Path, /) -> None: ...
    def changedPath(self) -> Path: ...
    def removedPath(self) -> Path: ...

class ObjectPostDelete(ObjectDelete):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class ObjectPreDelete(ObjectDelete):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class ObjectRename(ObjectPathChange):
    def __init__(self, arg0: SceneItem, arg1: Path, /) -> None: ...
    def changedPath(self) -> Path: ...
    def item(self) -> SceneItem: ...
    def previousPath(self) -> Path: ...

class ObjectReparent(ObjectPathChange):
    def __init__(self, arg0: SceneItem, arg1: Path, /) -> None: ...
    def changedPath(self) -> Path: ...
    def item(self) -> SceneItem: ...
    def previousPath(self) -> Path: ...

class ObservableSelection(Selection, Subject):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: ObservableSelection, /) -> None: ...
    def append(self, arg0: SceneItem, /) -> bool: ...
    def clear(self) -> None: ...
    def insert(self, arg0: SceneItem, arg1: SceneItem, /) -> bool: ...
    def remove(self, arg0: SceneItem, /) -> bool: ...
    def replaceWith(self, arg0: Selection, /) -> None: ...

class Observer:
    def __init__(self) -> None: ...
    def __call__(self, arg0, /) -> None: ...

class PasteClipboardCommand(UndoableCommand):
    class PasteInfo:
        def __init__(self) -> None: ...
        @property
        def failedPastes(self) -> list[Path]: ...
        @property
        def pasteTarget(self) -> Path: ...
        @property
        def successfulPastes(self) -> list[Path]: ...
    def __init__(self) -> None: ...
    def getPasteInfos(self, *args, **kwargs): ...
    def targetItems(self) -> list[SceneItem]: ...

class Path:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Path, /) -> None: ...
    @overload
    def __init__(self, arg0: list[PathSegment], /) -> None: ...
    @overload
    def __init__(self, arg0: PathSegment, /) -> None: ...
    def back(self) -> PathComponent: ...
    def head(self, arg0: int, /) -> Path: ...
    def nbSegments(self) -> int: ...
    def pop(self) -> Path: ...
    def popHead(self) -> Path: ...
    def popSegment(self) -> Path: ...
    def reparent(self, arg0: Path, arg1: Path, /) -> Path: ...
    def replaceComponent(self, arg0: int, arg1: PathComponent, /) -> Path: ...
    def runTimeId(self) -> int: ...
    def sibling(self, arg0: PathComponent, /) -> Path: ...
    def startsWith(self, arg0: Path, /) -> bool: ...
    @overload
    def __add__(self, arg0: str, /) -> Path: ...
    @overload
    def __add__(self, arg0: PathComponent, /) -> Path: ...
    @overload
    def __add__(self, arg0: PathSegment, /) -> Path: ...
    def __eq__(self, arg0: Path, /) -> bool: ...  # type: ignore
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Path, /) -> bool: ...  # type: ignore
    @property
    def segments(self) -> list[PathSegment]: ...

class PathComponent:
    @overload
    def __init__(self, arg0: PathComponent, /) -> None: ...
    @overload
    def __init__(self, arg0: str, /) -> None: ...
    @staticmethod
    def exists(arg0: str, /) -> bool: ...
    @staticmethod
    def tableSize() -> int: ...
    def __eq__(self, arg0: PathComponent, /) -> bool: ...  # type: ignore
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: PathComponent, /) -> bool: ...  # type: ignore

class PathMappingHandler:
    def __init__(self) -> None: ...
    def fromHost(self, *args, **kwargs): ...
    @overload
    @staticmethod
    def pathMappingHandler(arg0: int, /) -> PathMappingHandler: ...
    @overload
    @staticmethod
    def pathMappingHandler(arg0, /) -> PathMappingHandler: ...
    def toHost(self, *args, **kwargs): ...

class PathSegment:
    @overload
    def __init__(self, arg0: PathSegment, /) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: int, arg2: str, /) -> None: ...
    @overload
    def __init__(self, arg0: list[PathComponent], arg1: int, arg2: str, /) -> None: ...
    @overload
    def __init__(self, arg0: PathComponent, arg1: int, arg2: str, /) -> None: ...
    def components(self) -> list[PathComponent]: ...
    def head(self, arg0: int, /) -> PathSegment: ...
    def pop(self) -> PathSegment: ...
    def popHead(self) -> PathSegment: ...
    def runTimeId(self) -> int: ...
    def __eq__(self, arg0: PathSegment, /) -> bool: ...  # type: ignore
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: PathSegment, /) -> bool: ...  # type: ignore
    @property
    def separator(self) -> str: ...

class PathSubject(Subject):
    def __init__(self, arg0: Path, arg1, arg2, /) -> None: ...

class Rename:
    item: SceneItem
    undoableCommand: Incomplete
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, arg1, /) -> None: ...

class RunTimeMgr:
    class Handlers:
        attributesHandler: AttributesHandler
        batchOpsHandler: BatchOpsHandler
        cameraHandler: CameraHandler
        clipboardHandler: Incomplete
        connectionHandler: ConnectionHandler
        contextOpsHandler: ContextOpsHandler
        hierarchyHandler: HierarchyHandler
        lightHandler: LightHandler
        materialHandler: MaterialHandler
        nodeDefHandler: NodeDefHandler
        object3dHandler: Object3dHandler
        pathMappingHandler: PathMappingHandler
        sceneItemOpsHandler: SceneItemOpsHandler
        sceneSegmentHandler: SceneSegmentHandler
        transform3dHandler: Transform3dHandler
        uiInfoHandler: UIInfoHandler
        uiNodeGraphNodeHandler: UINodeGraphNodeHandler
        def __init__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def attributesHandler(self, arg0: int, /) -> AttributesHandler: ...
    def batchOpsHandler(self, arg0: int, /) -> BatchOpsHandler: ...
    def cameraHandler(self, arg0: int, /) -> CameraHandler: ...
    def clipboardHandler(self, *args, **kwargs): ...
    def codeWrapperHandler(self, *args, **kwargs): ...
    def connectionHandler(self, arg0: int, /) -> ConnectionHandler: ...
    def contextOpsHandler(self, arg0: int, /) -> ContextOpsHandler: ...
    def getId(self, arg0: str, /) -> int: ...
    def getIds(self) -> list[int]: ...
    def getName(self, arg0: int, /) -> str: ...
    def hasId(self, arg0: int, /) -> bool: ...
    def hierarchyHandler(self, arg0: int, /) -> HierarchyHandler: ...
    @staticmethod
    def instance() -> RunTimeMgr: ...
    def lightHandler(self, arg0: int, /) -> LightHandler: ...
    def materialHandler(self, arg0: int, /) -> MaterialHandler: ...
    def nodeDefHandler(self, arg0: int, /) -> NodeDefHandler: ...
    def object3dHandler(self, arg0: int, /) -> Object3dHandler: ...
    def pathMappingHandler(self, arg0: int, /) -> PathMappingHandler: ...
    def register(self, arg0: str, arg1, /) -> int: ...
    def sceneItemOpsHandler(self, arg0: int, /) -> SceneItemOpsHandler: ...
    def sceneSegmentHandler(self, arg0: int, /) -> SceneSegmentHandler: ...
    def setAttributesHandler(self, arg0: int, arg1: AttributesHandler, /) -> None: ...
    def setBatchOpsHandler(self, arg0: int, arg1: BatchOpsHandler, /) -> None: ...
    def setCameraHandler(self, arg0: int, arg1: CameraHandler, /) -> None: ...
    def setClipboardHandler(self, arg0: int, arg1, /) -> None: ...
    def setCodeWrapperHandler(self, arg0: int, arg1, /) -> None: ...
    def setConnectionHandler(self, arg0: int, arg1: ConnectionHandler, /) -> None: ...
    def setContextOpsHandler(self, arg0: int, arg1: ContextOpsHandler, /) -> None: ...
    def setHierarchyHandler(self, arg0: int, arg1: HierarchyHandler, /) -> None: ...
    def setLightHandler(self, arg0: int, arg1: LightHandler, /) -> None: ...
    def setMaterialHandler(self, arg0: int, arg1: MaterialHandler, /) -> None: ...
    def setNodeDefHandler(self, arg0: int, arg1: NodeDefHandler, /) -> None: ...
    def setObject3dHandler(self, arg0: int, arg1: Object3dHandler, /) -> None: ...
    def setPathMappingHandler(self, arg0: int, arg1: PathMappingHandler, /) -> None: ...
    def setSceneItemOpsHandler(self, arg0: int, arg1: SceneItemOpsHandler, /) -> None: ...
    def setSceneSegmentHandler(self, arg0: int, arg1: SceneSegmentHandler, /) -> None: ...
    def setTransform3dHandler(self, arg0: int, arg1: Transform3dHandler, /) -> None: ...
    def setUIInfoHandler(self, arg0: int, arg1: UIInfoHandler, /) -> None: ...
    def setUINodeGraphNodeHandler(self, arg0: int, arg1: UINodeGraphNodeHandler, /) -> None: ...
    def transform3dHandler(self, arg0: int, /) -> Transform3dHandler: ...
    def uiInfoHandler(self, arg0: int, /) -> UIInfoHandler: ...
    def uiNodeGraphNodeHandler(self, arg0: int, /) -> UINodeGraphNodeHandler: ...
    def unregister(self, arg0: int, /) -> None: ...

class Scene:
    def __init__(self) -> None: ...
    @staticmethod
    def addObserver(arg0: Observer, /) -> bool: ...
    @staticmethod
    def hasObserver(arg0: Observer, /) -> bool: ...
    @staticmethod
    def initializeInstance(arg0: Scene, /) -> None: ...
    @staticmethod
    def instance() -> Scene: ...
    @staticmethod
    def nbObservers() -> int: ...
    @staticmethod
    def notify(arg0: Notification, /) -> None: ...
    @staticmethod
    def removeObserver(arg0: Observer, /) -> bool: ...

class SceneChanged(Notification):
    class OpType:
        __members__: ClassVar[dict] = ...  # read-only
        ObjectAdd: ClassVar[SceneChanged.OpType] = ...
        ObjectDelete: ClassVar[SceneChanged.OpType] = ...
        ObjectPathChange: ClassVar[SceneChanged.OpType] = ...
        SceneCompositeNotification: ClassVar[SceneChanged.OpType] = ...
        SubtreeInvalidate: ClassVar[SceneChanged.OpType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    ObjectAdd: ClassVar[SceneChanged.OpType] = ...
    ObjectDelete: ClassVar[SceneChanged.OpType] = ...
    ObjectPathChange: ClassVar[SceneChanged.OpType] = ...
    SceneCompositeNotification: ClassVar[SceneChanged.OpType] = ...
    SubtreeInvalidate: ClassVar[SceneChanged.OpType] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def changedPath(self) -> Path: ...
    def opType(self, *args, **kwargs): ...
    def subOpType(self) -> int: ...

class SceneCompositeNotification(SceneChanged):
    class Op:
        item: SceneItem
        opType: SceneChanged.OpType
        path: Path
        specificOpType: int
        def __init__(self, arg0: SceneChanged.OpType, arg1: int, arg2: SceneItem, arg3: Path, /) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SceneCompositeNotification, /) -> None: ...
    def appendOp(self, arg0, /) -> None: ...
    def appendSceneChanged(self, arg0: SceneChanged, /) -> None: ...
    def changedPath(self) -> Path: ...
    def empty(self) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class SceneItem:
    def __init__(self, arg0: Path, /) -> None: ...
    def ancestorNodeTypes(self) -> list[str]: ...
    def clearGroupMetadata(self, arg0: str, arg1: str, /) -> None: ...
    def clearGroupMetadataCmd(self, *args, **kwargs): ...
    def clearMetadata(self, arg0: str, /) -> None: ...
    def clearMetadataCmd(self, *args, **kwargs): ...
    def getGroupMetadata(self, *args, **kwargs): ...
    def getMetadata(self, *args, **kwargs): ...
    def getRawAddress(self) -> int: ...
    def isProperty(self) -> bool: ...
    def nodeName(self) -> str: ...
    def nodeType(self) -> str: ...
    def path(self) -> Path: ...
    def runTimeId(self) -> int: ...
    def setGroupMetadata(self, arg0: str, arg1: str, arg2, /) -> None: ...
    def setGroupMetadataCmd(self, *args, **kwargs): ...
    def setMetadata(self, arg0: str, arg1, /) -> None: ...
    def setMetadataCmd(self, *args, **kwargs): ...
    def __eq__(self, arg0: SceneItem, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: SceneItem, /) -> bool: ...  # type: ignore

class SceneItemOps:
    def __init__(self) -> None: ...
    def deleteItem(self) -> bool: ...
    def deleteItemCmd(self, *args, **kwargs): ...
    def deleteItemCmdNoExecute(self, *args, **kwargs): ...
    def duplicateItem(self) -> SceneItem: ...
    def duplicateItemCmd(self) -> Duplicate: ...
    def duplicateItemCmdNoExecute(self, *args, **kwargs): ...
    def renameItem(self, arg0: PathComponent, /) -> SceneItem: ...
    def renameItemCmd(self, arg0: PathComponent, /) -> Rename: ...
    def renameItemCmdNoExecute(self, *args, **kwargs): ...
    def sceneItem(self) -> SceneItem: ...
    @staticmethod
    def sceneItemOps(arg0: SceneItem, /) -> SceneItemOps: ...

class SceneItemOpsHandler:
    def __init__(self) -> None: ...
    def sceneItemOps(self, arg0: SceneItem, /) -> SceneItemOps: ...

class SceneItemResultUndoableCommand(UndoableCommand):
    def __init__(self) -> None: ...
    @property
    def sceneItem(self) -> SceneItem: ...

class SceneSegmentHandler:
    def __init__(self) -> None: ...
    @overload
    @staticmethod
    def findGatewayItems(arg0: Path, /) -> Selection: ...
    @overload
    @staticmethod
    def findGatewayItems(arg0: Path, arg1: int, /) -> Selection: ...
    @overload
    def findGatewayItems_(self, arg0: Path, /) -> Selection: ...
    @overload
    def findGatewayItems_(self, arg0: Path, arg1: int, /) -> Selection: ...
    @staticmethod
    def isGateway(arg0: Path, /) -> bool: ...
    def isGateway_(self, arg0: Path, /) -> bool: ...
    @staticmethod
    def sceneSegmentHandler(arg0: int, /) -> SceneSegmentHandler: ...

class Selection:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, /) -> None: ...
    @overload
    def __init__(self, arg0: list[SceneItem], /) -> None: ...
    def append(self, arg0: SceneItem, /) -> bool: ...
    def back(self) -> SceneItem: ...
    def clear(self) -> None: ...
    def closestCommonAncestor(self) -> SceneItem: ...
    def contains(self, arg0: Path, /) -> bool: ...
    def containsAncestor(self, arg0: Path, /) -> bool: ...
    def containsAncestorInclusive(self, arg0: Path, /) -> bool: ...
    def containsDescendant(self, arg0: Path, /) -> bool: ...
    def containsDescendantInclusive(self, arg0: Path, /) -> bool: ...
    def empty(self) -> bool: ...
    def front(self) -> SceneItem: ...
    def insert(self, arg0: SceneItem, arg1: SceneItem, /) -> bool: ...
    def next(self, arg0: SceneItem, /) -> SceneItem: ...
    def remove(self, arg0: SceneItem, /) -> bool: ...
    def replaceWith(self, arg0: Selection, /) -> None: ...
    def __contains__(self, arg0: Path, /) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class SelectionAppendItem(UndoableCommand):
    def __init__(self, arg0: ObservableSelection, arg1: SceneItem, /) -> None: ...
    @staticmethod
    def createAndExecute(arg0: ObservableSelection, arg1: SceneItem, /) -> UndoableCommand: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class SelectionChanged(Notification):
    class OpType:
        __members__: ClassVar[dict] = ...  # read-only
        Append: ClassVar[SelectionChanged.OpType] = ...
        Clear: ClassVar[SelectionChanged.OpType] = ...
        Insert: ClassVar[SelectionChanged.OpType] = ...
        Remove: ClassVar[SelectionChanged.OpType] = ...
        ReplaceWith: ClassVar[SelectionChanged.OpType] = ...
        SelectionCompositeNotification: ClassVar[SelectionChanged.OpType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Append: ClassVar[SelectionChanged.OpType] = ...
    Clear: ClassVar[SelectionChanged.OpType] = ...
    Insert: ClassVar[SelectionChanged.OpType] = ...
    Remove: ClassVar[SelectionChanged.OpType] = ...
    ReplaceWith: ClassVar[SelectionChanged.OpType] = ...
    SelectionCompositeNotification: ClassVar[SelectionChanged.OpType] = ...
    @overload
    def __init__(self, arg0: SelectionChanged, /) -> None: ...
    @overload
    def __init__(self, arg0, /) -> None: ...
    def opType(self, *args, **kwargs): ...

class SelectionClear(UndoableCommand):
    def __init__(self, arg0: ObservableSelection, /) -> None: ...
    @staticmethod
    def createAndExecute(arg0: ObservableSelection, /) -> UndoableCommand: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class SelectionCleared(SelectionChanged):
    @overload
    def __init__(self, arg0: SelectionCleared, /) -> None: ...
    @overload
    def __init__(self, arg0: Selection, /) -> None: ...
    def previousSelection(self) -> Selection: ...

class SelectionCompositeNotification(SelectionChanged):
    class Op:
        item: SceneItem
        opType: SelectionChanged.OpType
        position: SceneItem
        @overload
        def __init__(self, arg0: SelectionChanged.OpType, /) -> None: ...
        @overload
        def __init__(self, arg0: SelectionChanged.OpType, arg1: SceneItem, /) -> None: ...
        @overload
        def __init__(self, arg0: SelectionChanged.OpType, arg1: SceneItem, arg2: SceneItem, /) -> None: ...
    def __init__(self, arg0: SelectionCompositeNotification, /) -> None: ...
    def appendAppendOp(self, arg0: SceneItem, /) -> None: ...
    def appendClearOp(self) -> None: ...
    def appendInsertOp(self, arg0: SceneItem, arg1: SceneItem, /) -> None: ...
    def appendRemoveOp(self, arg0: SceneItem, /) -> None: ...
    def appendReplaceWithOp(self) -> None: ...
    def empty(self) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class SelectionItemAppended(SelectionChanged):
    @overload
    def __init__(self, arg0: SelectionItemAppended, /) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class SelectionItemInserted(SelectionChanged):
    @overload
    def __init__(self, arg0: SelectionItemInserted, /) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, arg1: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...
    def position(self) -> SceneItem: ...

class SelectionItemRemoved(SelectionChanged):
    @overload
    def __init__(self, arg0: SelectionItemRemoved, /) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class SelectionRemoveItem(UndoableCommand):
    def __init__(self, arg0: ObservableSelection, arg1: SceneItem, /) -> None: ...
    @staticmethod
    def createAndExecute(arg0: ObservableSelection, arg1: SceneItem, /) -> UndoableCommand: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class SelectionReplaceWith(UndoableCommand):
    def __init__(self, arg0: ObservableSelection, arg1: Selection, /) -> None: ...
    @staticmethod
    def createAndExecute(arg0: ObservableSelection, arg1: Selection, /) -> UndoableCommand: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class SelectionReplaced(SelectionChanged):
    @overload
    def __init__(self, arg0: SelectionReplaced, /) -> None: ...
    @overload
    def __init__(self, arg0: Selection, /) -> None: ...
    def previousSelection(self) -> Selection: ...

class SelectionUndoableCommand(UndoableCommand):
    def __init__(self) -> None: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def targetItem(self, arg0: Path, /) -> SceneItem: ...
    def undo(self) -> None: ...

class SetBoolUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: bool, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetColor3fUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: Color3f, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetColor4fUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: Color4f, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetDouble3UndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: float, arg1: float, arg2: float, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetDoubleUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: float, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetFloat2UndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: float, arg1: float, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetFloat3UndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: float, arg1: float, arg2: float, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetFloat4UndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetFloatUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: float, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetIntUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: int, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetLight_ConePropsUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: Light_ConeProps, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetLight_SpherePropsUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: Light_SphereProps, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetMatrix3dUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: Matrix3d, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SetMatrix4dUndoableCommand(UndoableCommand):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    def sceneItem(self) -> SceneItem: ...
    def set(self, arg0: Matrix4d, /) -> bool: ...
    def setPath(self, arg0: Path, /) -> None: ...

class SphereInterface:
    def __init__(self, *args, **kwargs) -> None: ...
    def sphereProps(self, arg0: float, arg1: bool, /) -> None: ...
    def spherePropsCmd(self, *args, **kwargs): ...

class Subject:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Subject, /) -> None: ...
    def addObserver(self, arg0, /) -> bool: ...
    def hasObserver(self, arg0, /) -> bool: ...
    def nbObservers(self) -> int: ...
    def notify(self, arg0, /) -> None: ...
    def removeObserver(self, arg0, /) -> bool: ...

class SubtreeInvalidate(SceneChanged):
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def changedPath(self) -> Path: ...
    def root(self) -> SceneItem: ...

class Transform3d:
    def __init__(self) -> None: ...
    @staticmethod
    def addObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @staticmethod
    def editTransform3d(arg0: SceneItem, arg1: EditTransform3dHint, /) -> Transform3d: ...
    def exclusiveMatrix(self) -> Matrix4d: ...
    @staticmethod
    def hasObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: Path, /) -> bool: ...
    @overload
    @staticmethod
    def hasObservers(arg0: int, /) -> bool: ...
    def inclusiveMatrix(self) -> Matrix4d: ...
    def matrix(self) -> Matrix4d: ...
    @staticmethod
    def nbObservers(arg0: SceneItem, /) -> int: ...
    @staticmethod
    def notify(arg0: Path, /) -> None: ...
    def path(self) -> Path: ...
    @overload
    @staticmethod
    def removeObserver(arg0: SceneItem, arg1: Observer, /) -> bool: ...
    @overload
    @staticmethod
    def removeObserver(arg0: Path, arg1: Observer, /) -> bool: ...
    def rotate(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def rotateAxis(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def rotateAxis(self) -> Vector3d: ...
    def rotateAxisCmd(self, *args, **kwargs): ...
    def rotateCmd(self, *args, **kwargs): ...
    @overload
    def rotatePivot(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def rotatePivot(self) -> Vector3d: ...
    def rotatePivotCmd(self, *args, **kwargs): ...
    def rotatePivotTranslation(self) -> Vector3d: ...
    def rotation(self) -> Vector3d: ...
    @overload
    def scale(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def scale(self) -> Vector3d: ...
    def scaleCmd(self, *args, **kwargs): ...
    @overload
    def scalePivot(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def scalePivot(self) -> Vector3d: ...
    def scalePivotCmd(self, *args, **kwargs): ...
    def scalePivotTranslation(self) -> Vector3d: ...
    def sceneItem(self) -> SceneItem: ...
    def segmentExclusiveMatrix(self) -> Matrix4d: ...
    def segmentInclusiveMatrix(self) -> Matrix4d: ...
    def setMatrix(self, arg0: Matrix4d, /) -> None: ...
    def setMatrixCmd(self, *args, **kwargs): ...
    @overload
    def shear(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    @overload
    def shear(self) -> Vector3d: ...
    def shearCmd(self, *args, **kwargs): ...
    @staticmethod
    def transform3d(arg0: SceneItem, /) -> Transform3d: ...
    def translate(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def translateCmd(self, *args, **kwargs): ...
    def translateRotatePivot(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def translateRotatePivotCmd(self, *args, **kwargs): ...
    def translateScalePivot(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def translateScalePivotCmd(self, *args, **kwargs): ...
    def translation(self) -> Vector3d: ...

class Transform3dChanged(Notification):
    @overload
    def __init__(self, arg0: Transform3dChanged, /) -> None: ...
    @overload
    def __init__(self, arg0: SceneItem, /) -> None: ...
    def item(self) -> SceneItem: ...

class Transform3dHandler:
    def __init__(self) -> None: ...
    def editTransform3d(self, arg0: SceneItem, arg1: EditTransform3dHint, /) -> Transform3d: ...
    def transform3d(self, arg0: SceneItem, /) -> Transform3d: ...

class Transform3dPathSubject(PathSubject):
    def __init__(self, arg0: Path, /) -> None: ...

class UIInfoHandler:
    class Icon:
        badgeIcon: str
        baseIcon: str
        mode: UIInfoHandler.Mode
        pos: UIInfoHandler.Quadrant
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: str, /) -> None: ...
        @overload
        def __init__(self, arg0: str, arg1: UIInfoHandler.Mode, /) -> None: ...
        @overload
        def __init__(self, arg0: str, arg1: str, arg2: UIInfoHandler.Quadrant, /) -> None: ...

    class Mode:
        __members__: ClassVar[dict] = ...  # read-only
        Active: ClassVar[UIInfoHandler.Mode] = ...
        Disabled: ClassVar[UIInfoHandler.Mode] = ...
        Normal: ClassVar[UIInfoHandler.Mode] = ...
        Selected: ClassVar[UIInfoHandler.Mode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Quadrant:
        __members__: ClassVar[dict] = ...  # read-only
        LowerLeft: ClassVar[UIInfoHandler.Quadrant] = ...
        LowerRight: ClassVar[UIInfoHandler.Quadrant] = ...
        UpperLeft: ClassVar[UIInfoHandler.Quadrant] = ...
        UpperRight: ClassVar[UIInfoHandler.Quadrant] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Active: ClassVar[UIInfoHandler.Mode] = ...
    Disabled: ClassVar[UIInfoHandler.Mode] = ...
    LowerLeft: ClassVar[UIInfoHandler.Quadrant] = ...
    LowerRight: ClassVar[UIInfoHandler.Quadrant] = ...
    Normal: ClassVar[UIInfoHandler.Mode] = ...
    Selected: ClassVar[UIInfoHandler.Mode] = ...
    UpperLeft: ClassVar[UIInfoHandler.Quadrant] = ...
    UpperRight: ClassVar[UIInfoHandler.Quadrant] = ...
    def __init__(self) -> None: ...
    def getLongRunTimeLabel(self) -> str: ...
    def treeViewCellInfo(self, arg0, arg1: CellInfo, /) -> bool: ...
    def treeViewIcon(self, *args, **kwargs): ...
    def treeViewTooltip(self, arg0, /) -> str: ...
    @staticmethod
    def uiInfoHandler(arg0: int, /) -> UIInfoHandler: ...

class UINodeGraphNode:
    def __init__(self) -> None: ...
    def getDisplayColor(self, *args, **kwargs): ...
    def getPosition(self, *args, **kwargs): ...
    def getSize(self, *args, **kwargs): ...
    def hasDisplayColor(self) -> bool: ...
    def hasPosition(self) -> bool: ...
    def hasSize(self) -> bool: ...
    def sceneItem(self) -> SceneItem: ...
    def setDisplayColor(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def setDisplayColorCmd(self, *args, **kwargs): ...
    def setPosition(self, arg0: float, arg1: float, /) -> None: ...
    def setPositionCmd(self, *args, **kwargs): ...
    def setSize(self, arg0: float, arg1: float, /) -> None: ...
    def setSizeCmd(self, *args, **kwargs): ...
    @staticmethod
    def uiNodeGraphNode(arg0: SceneItem, /) -> UINodeGraphNode: ...

class UINodeGraphNodeHandler:
    def __init__(self) -> None: ...
    def uiNodeGraphNode(self, arg0: SceneItem, /) -> UINodeGraphNode: ...

class UndoableCommand:
    def __init__(self) -> None: ...
    def execute(self) -> None: ...
    def redo(self) -> None: ...
    def undo(self) -> None: ...

class UndoableCommandGuard:
    def __init__(self, arg0: str, /) -> None: ...
    def setSuccess(self) -> None: ...
    def __enter__(self) -> object: ...
    def __exit__(self, arg0: handle, arg1: handle, arg2: handle, /) -> None: ...  # type: ignore

class UndoableCommandMgr:
    def __init__(self) -> None: ...
    def executeCmd(self, arg0: UndoableCommand, /) -> None: ...
    @staticmethod
    def initializeInstance(arg0: UndoableCommandMgr, /) -> None: ...
    @staticmethod
    def instance() -> UndoableCommandMgr: ...

class Value:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: bool, /) -> None: ...
    @overload
    def __init__(self, arg0: int, /) -> None: ...
    @overload
    def __init__(self, arg0: float, /) -> None: ...
    @overload
    def __init__(self, arg0: str, /) -> None: ...
    @overload
    def __init__(self, arg0: Value, /) -> None: ...
    def empty(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: Value, /) -> bool: ...  # type: ignore
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: Value, /) -> bool: ...  # type: ignore

class ValueDictionary:
    def __init__(self) -> None: ...
    def items(self, *args, **kwargs): ...
    def keys(self) -> KeysView[str]: ...
    def values(self, *args, **kwargs): ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str, /) -> bool: ...
    @overload
    def __contains__(self, arg0: object, /) -> bool: ...
    def __delitem__(self, arg0: str, /) -> None: ...
    def __getitem__(self, index): ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1, /) -> None: ...

class Vector2d:
    vector: list[float[2]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[2]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, /) -> None: ...
    def set(self, arg0: float, arg1: float, /) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def __eq__(self, arg0: Vector2d, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector2d, /) -> bool: ...  # type: ignore

class Vector2f:
    vector: list[float[2]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[2]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, /) -> None: ...
    def set(self, arg0: float, arg1: float, /) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def __eq__(self, arg0: Vector2f, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector2f, /) -> bool: ...  # type: ignore

class Vector2i:
    vector: list[int[2]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[int[2]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: int, arg1: int, /) -> None: ...
    def set(self, arg0: int, arg1: int, /) -> None: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def __eq__(self, arg0: Vector2i, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector2i, /) -> bool: ...  # type: ignore

class Vector3d:
    vector: list[float[3]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[3]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def set(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __eq__(self, arg0: Vector3d, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector3d, /) -> bool: ...  # type: ignore

class Vector3f:
    vector: list[float[3]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[3]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def set(self, arg0: float, arg1: float, arg2: float, /) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __eq__(self, arg0: Vector3f, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector3f, /) -> bool: ...  # type: ignore

class Vector3i:
    vector: list[int[3]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[int[3]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: int, arg1: int, arg2: int, /) -> None: ...
    def set(self, arg0: int, arg1: int, arg2: int, /) -> None: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def __eq__(self, arg0: Vector3i, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector3i, /) -> bool: ...  # type: ignore

class Vector4d:
    vector: list[float[4]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[4]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...
    def set(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...
    def w(self) -> float: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __eq__(self, arg0: Vector4d, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector4d, /) -> bool: ...  # type: ignore

class Vector4f:
    vector: list[float[4]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[float[4]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...
    def set(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...
    def w(self) -> float: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __eq__(self, arg0: Vector4f, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector4f, /) -> bool: ...  # type: ignore

class Vector4i:
    vector: list[int[4]]  # type: ignore
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[int[4]], /) -> None: ...  # type: ignore
    @overload
    def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int, /) -> None: ...
    def set(self, arg0: int, arg1: int, arg2: int, arg3: int, /) -> None: ...
    def w(self) -> int: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def __eq__(self, arg0: Vector4i, /) -> bool: ...  # type: ignore
    def __ne__(self, arg0: Vector4i, /) -> bool: ...  # type: ignore

class VersionInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def getBuildDate() -> str: ...
    @staticmethod
    def getBuildNumber() -> int: ...
    @staticmethod
    def getGitBranch() -> str: ...
    @staticmethod
    def getGitCommit() -> str: ...
    @staticmethod
    def getMajorVersion() -> int: ...
    @staticmethod
    def getMinorVersion() -> int: ...
    @staticmethod
    def getPatchLevel() -> int: ...

class VisibilityChanged(Notification):
    def __init__(self, arg0: Path, /) -> None: ...
    def path(self) -> Path: ...

def getAttributeBool(arg0: Attributes, arg1: str, /) -> AttributeBool: ...
def getAttributeColorFloat3(arg0: Attributes, arg1: str, /) -> AttributeColorFloat3: ...
def getAttributeColorFloat4(arg0: Attributes, arg1: str, /) -> AttributeColorFloat4: ...
def getAttributeDouble(arg0: Attributes, arg1: str, /) -> AttributeDouble: ...
def getAttributeDouble3(arg0: Attributes, arg1: str, /) -> AttributeDouble3: ...
def getAttributeEnumString(arg0: Attributes, arg1: str, /) -> AttributeEnumString: ...
def getAttributeFilename(arg0: Attributes, arg1: str, /) -> AttributeFilename: ...
def getAttributeFloat(arg0: Attributes, arg1: str, /) -> AttributeFloat: ...
def getAttributeFloat2(arg0: Attributes, arg1: str, /) -> AttributeFloat2: ...
def getAttributeFloat3(arg0: Attributes, arg1: str, /) -> AttributeFloat3: ...
def getAttributeFloat4(arg0: Attributes, arg1: str, /) -> AttributeFloat4: ...
def getAttributeGeneric(arg0: Attributes, arg1: str, /) -> AttributeGeneric: ...
def getAttributeInt(arg0: Attributes, arg1: str, /) -> AttributeInt: ...
def getAttributeInt3(arg0: Attributes, arg1: str, /) -> AttributeInt3: ...
def getAttributeMatrix3d(arg0: Attributes, arg1: str, /) -> AttributeMatrix3d: ...
def getAttributeMatrix4d(arg0: Attributes, arg1: str, /) -> AttributeMatrix4d: ...
def getAttributeString(arg0: Attributes, arg1: str, /) -> AttributeString: ...
def getAttributesFromRaw(arg0: int, /) -> Attributes: ...
def getSceneItemFromRaw(arg0: int, /) -> SceneItem: ...

# mypy: disable-error-code="misc, override, no-redef, assignment"

from . import current, session, system, utils
import PySide2.QtCore
import PySide2.QtWidgets
import typing
from _typeshed import Incomplete
from typing import ClassVar

ModoRender: Palette
TextureSetsPalette: Palette
actions: ActionManager
app: Application
canvases: CanvasManager
clock: Clock
colors: Colors
ddi: DDI
environ: Environment
event: Event
exports: ExportManager
geo: GeoManager
gl_render: GLRender
history: History
images: ImageManager
lights: LightManager
menus: MenuManager
misc: Miscellaneous
nodes: NodeManager
ocio: OpenColorIO
palettes: PaletteManager
particle: Particle
patch_links: PatchLinksManager
prefs: Preferences
projection: ProjectionManager
projectors: ProjectorManager
projects: ProjectManager
resources: ResourceInfo
selection_groups: SelectionGroupManager
shader_models: ShaderModelManager
shelves: ShelfManager
tools: ToolManager

class API(PySide2.QtCore.QObject):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def isNull(self, *args, **kwargs): ...
    def __bool__(self) -> bool: ...

class Action(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    triggered: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addToSet(self, SetName: str): ...
    def iconPath(self) -> str: ...
    def isCheckable(self) -> bool: ...
    def isChecked(self) -> bool: ...
    def isEnabled(self) -> bool: ...
    def name(self) -> str: ...
    def path(self) -> str: ...
    def removeFromSet(self, SetName: str): ...
    def removeShortcut(self, Group: ActionManager.ShortcutGroup = ...): ...
    def setCheckable(self, Checkable: bool): ...
    def setChecked(self, Checked: bool): ...
    def setEnabled(self, Enabled: bool): ...
    def setIconPath(self, IconPath: str): ...
    def setShortcut(self, rString: str, Group: ActionManager.ShortcutGroup = ...): ...
    def setStatusTip(self, StatusTip: str): ...
    def setText(self, NewText: str): ...
    def setToolTip(self, ToolTip: str): ...
    def setWhatsThis(self, WhatsThis: str): ...
    def shortcut(self, Group: ActionManager.ShortcutGroup = ...) -> str: ...
    def statusTip(self) -> str: ...
    def text(self) -> str: ...
    def toolTip(self) -> str: ...
    def trigger(self): ...
    def whatsThis(self) -> str: ...
    def __bool__(self) -> bool: ...

class ActionManager(API):
    class ShortcutGroup:
        APPLICATION: ClassVar[ActionManager.ShortcutGroup] = ...
        NODE_GRAPH: ClassVar[ActionManager.ShortcutGroup] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    APPLICATION: ClassVar[ActionManager.ShortcutGroup] = ...
    NODE_GRAPH: ClassVar[ActionManager.ShortcutGroup] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def actionFromShortcut(self, Shortcut: str, Group: ShortcutGroup = ...) -> str: ...
    def addToSet(self, SetName: str, pAction: Action): ...
    def create(self, rIdentifier: str, rCommand: str) -> ScriptAction: ...
    def disableSet(self, SetName: str): ...
    def enableSet(self, SetName: str): ...
    def find(self, rPath: str) -> Action: ...
    def get(self, rPath: str) -> Action: ...
    def list(self, rPath: str = ...) -> typing.List[str]: ...
    def loadUserShortcuts(self): ...
    def removeFromSet(self, SetName: str, pAction: Action): ...
    def removeShortcut(self, Path: str, Shortcut: str = ..., Group: ShortcutGroup = ...): ...
    def removeShortcuts(self, Path: str, Group: ShortcutGroup = ...): ...
    def setShortcut(self, Path: str, Shortcut: str, Group: ShortcutGroup = ...): ...
    def sets(self) -> typing.List[str]: ...
    def shortcut(self, Path: str, Group: ShortcutGroup = ...) -> str: ...
    def shortcutIsInUse(self, Shortcut: str, Group: ShortcutGroup = ...) -> bool: ...
    def shortcuts(self, Path: str, Group: ShortcutGroup = ...) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class AdjustableLayer(Layer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def adjustmentStack(self) -> LayerStack: ...
    def hasAdjustmentStack(self) -> bool: ...
    def isAdjustmentStackEnabled(self) -> bool: ...
    def makeAdjustmentStack(self) -> LayerStack: ...
    def removeAdjustmentStack(self): ...
    def setAdjustmentStackEnabled(self, Enabled: bool): ...
    def __bool__(self) -> bool: ...

class AdjustmentLayer(Layer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def getPrimaryAdjustmentParameter(self, ParameterName: str) -> variant: ...
    def getPrimaryAdjustmentParameterAsImage(self, ParameterName: str) -> Image: ...
    def getSecondaryAdjustmentParameter(self, ParameterName: str) -> variant: ...
    def getSecondaryAdjustmentParameterAsImage(self, ParameterName: str) -> Image: ...
    def hasSecondaryAdjustment(self) -> bool: ...
    def makeSecondaryAdjustment(self, AdjustmentKey: str): ...
    def primaryAdjustmentParameters(self) -> typing.List[str]: ...
    def primaryAdjustmentType(self) -> str: ...
    def removeSecondaryAdjustment(self): ...
    def secondaryAdjustmentParameters(self) -> typing.List[str]: ...
    def secondaryAdjustmentType(self) -> str: ...
    def setPrimaryAdjustmentParameter(self, ParameterName: str, NewValue: variant): ...
    def setSecondaryAdjustmentParameter(self, ParameterName: str, NewValue: variant): ...
    def __bool__(self) -> bool: ...

class AppVersion(API):
    class Stage:
        ALPHA: ClassVar[AppVersion.Stage] = ...
        BETA: ClassVar[AppVersion.Stage] = ...
        DEV: ClassVar[AppVersion.Stage] = ...
        RELEASE: ClassVar[AppVersion.Stage] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    ALPHA: ClassVar[AppVersion.Stage] = ...
    BETA: ClassVar[AppVersion.Stage] = ...
    DEV: ClassVar[AppVersion.Stage] = ...
    RELEASE: ClassVar[AppVersion.Stage] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def date(self) -> str: ...
    def feature(self): ...
    def info(self): ...
    def isLinux(self) -> bool: ...
    def isMac(self) -> bool: ...
    def isWindows(self) -> bool: ...
    def iteration(self): ...
    def major(self): ...
    def minor(self): ...
    def number(self): ...
    def qt(self) -> str: ...
    def revision(self): ...
    def stage(self): ...
    def string(self): ...
    def time(self) -> str: ...
    def __bool__(self) -> bool: ...

class Application(API):
    class DropTargetArea:
        CANVAS: ClassVar[Application.DropTargetArea] = ...
        IMAGE_MANAGER: ClassVar[Application.DropTargetArea] = ...
        LAYER_STACK: ClassVar[Application.DropTargetArea] = ...
        NODE_GRAPH: ClassVar[Application.DropTargetArea] = ...
        SHELF: ClassVar[Application.DropTargetArea] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class ToolBarArea:
        BOTTOM_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
        LEFT_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
        RIGHT_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
        TOP_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    BOTTOM_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
    CANVAS: ClassVar[Application.DropTargetArea] = ...
    IMAGE_MANAGER: ClassVar[Application.DropTargetArea] = ...
    LAYER_STACK: ClassVar[Application.DropTargetArea] = ...
    LEFT_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
    NODE_GRAPH: ClassVar[Application.DropTargetArea] = ...
    RIGHT_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
    SHELF: ClassVar[Application.DropTargetArea] = ...
    TOP_TOOLBAR_AREA: ClassVar[Application.ToolBarArea] = ...
    autosaveReset: ClassVar[PySide2.QtCore.Signal] = ...
    autosaveTriggered: ClassVar[PySide2.QtCore.Signal] = ...
    backgroundJobsRunning: ClassVar[PySide2.QtCore.Signal] = ...
    canceledProcessing: ClassVar[PySide2.QtCore.Signal] = ...
    endingProcessing: ClassVar[PySide2.QtCore.Signal] = ...
    exiting: ClassVar[PySide2.QtCore.Signal] = ...
    fullScreenChanging: ClassVar[PySide2.QtCore.Signal] = ...
    layoutLoaded: ClassVar[PySide2.QtCore.Signal] = ...
    layoutSaved: ClassVar[PySide2.QtCore.Signal] = ...
    onProgress: ClassVar[PySide2.QtCore.Signal] = ...
    progressDescriptionChanged: ClassVar[PySide2.QtCore.Signal] = ...
    startingProcessing: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    toolBarsCreated: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def activateMainWindow(self): ...
    def addTab(self, Name: str, Widget: PySide2.QtWidgets.QWidget): ...
    def backgroundJobCaption(self, JobID: typing.SupportsInt) -> str: ...
    def backgroundJobIDs(self) -> typing.List[int]: ...
    def canvasHeight(self): ...
    def canvasWidth(self): ...
    def captureDesktop(self) -> PySide2.QtWidgets.QPixmap: ...
    def clearScriptOutput(self): ...
    def commandPortEnabled(self) -> bool: ...
    def commandPortNumber(self): ...
    def createCustomDisplayWidget(self, Name: str, OffscreenBufferWidth: typing.SupportsInt, OffscreenBufferHeight: typing.SupportsInt, Widget: PySide2.QtWidgets.QWidget): ...
    def createToolBar(self, Name: str, Area: ToolBarArea = ..., IsVisible: bool = ...) -> ToolBar: ...
    def currentMeshPathInGeoLoader(self) -> str: ...
    def decryptString(self): ...
    def deleteToolBar(self, Name: str): ...
    def enableCommandPort(self): ...
    def encryptString(self): ...
    def executeDialog(self, Dialog: PySide2.QtWidgets.QDialog) -> int: ...
    def exit(self, ResultCode: typing.SupportsInt = ..., ConfirmIfProjectModified: bool = ...): ...
    def findToolBar(self): ...
    def geometry(self) -> PySide2.QtWidgets.QRect: ...
    def getGeoPluginAttribute(self): ...
    def hasPendingPortCommands(self) -> bool: ...
    def inRestrictedVersion(self) -> bool: ...
    def inTerminalMode(self) -> bool: ...
    def isBackgroundJobFinished(self, JobID: typing.SupportsInt) -> bool: ...
    def isFullScreen(self) -> bool: ...
    def isMaximized(self) -> bool: ...
    def isMinimized(self) -> bool: ...
    def isProcessing(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def isSafeFeature_BypassUserEnvironmentResourceKeys_Enabled(self) -> bool: ...
    def lastDropData(self) -> variant: ...
    def launchArgs(self) -> typing.List[str]: ...
    def launchDir(self) -> str: ...
    def loadLayout(self, Filename: str): ...
    def log(self, Message: str): ...
    def logFileName(self) -> str: ...
    def maximize(self): ...
    def minimize(self): ...
    def numProcessingSteps(self) -> int: ...
    def popupsAllowed(self) -> bool: ...
    def processEvents(self): ...
    def progress(self) -> int: ...
    def progressDescription(self) -> str: ...
    def quit(self, ConfirmIfProjectModified: bool = ...): ...
    def registerCustomDropMimeType(self, MimeType: str, Target: DropTargetArea): ...
    def registerGeoPluginWidget(self, FileExtensions: typing.List[str], Widget: PySide2.QtWidgets.QWidget): ...
    def removeTab(self, Name: str): ...
    def restore(self): ...
    def restoreCursor(self): ...
    def resumeProcessing(self): ...
    def saveLayout(self, Filename: str): ...
    def setActiveTab(self, Name: str): ...
    def setCommandPortNumber(self): ...
    def setFixedCanvasSize(self, Width: typing.SupportsInt, Height: typing.SupportsInt): ...
    def setFullScreen(self, FullScreen: bool): ...
    def setGeoPluginAttribute(self): ...
    def setGeometry(self, Geom: PySide2.QtWidgets.QRect): ...
    def setNukeConnectionActive(self, Active: bool, ConnectionInfo: str = ...): ...
    def setProgress(self, Progress: typing.SupportsInt): ...
    def setProgressDescription(self, Description: str): ...
    def setWaitCursor(self): ...
    def startProcessing(self, Description: str, NumSteps: typing.SupportsInt = ..., CanCancel: bool = ...): ...
    def stepProgress(self): ...
    def stopProcessing(self): ...
    def suspendProcessing(self): ...
    def tabNames(self): ...
    def toggleFullScreen(self): ...
    def toolBar(self): ...
    def version(self): ...
    def wasProcessingCanceled(self) -> bool: ...
    def __bool__(self) -> bool: ...

class BackdropNode(Node):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def childNodes(self) -> typing.List[Node]: ...
    def isBackdropNode(self) -> bool: ...
    def portListMode(self): ...
    def selectChildNodes(self): ...
    def setNodeGraphSize(self, Size: PySide2.QtWidgets.QSizeF): ...
    def setPortListMode(self): ...
    def __bool__(self) -> bool: ...

class BakePointLayer(Layer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bake(self): ...
    def bakedResult(self) -> ImageSet: ...
    def deleteBakedResult(self): ...
    def hasBakedResult(self): ...
    def isBakedResultUpToDate(self): ...
    def setUseBaked(self): ...
    def useBaked(self): ...
    def __bool__(self) -> bool: ...

class BakePointNode(PaintNode):
    class BakePointNodeState:
        BAKEPOINTSTATE_DIRTY: ClassVar[BakePointNode.BakePointNodeState] = ...
        BAKEPOINTSTATE_NOT_AVAILABLE: ClassVar[BakePointNode.BakePointNodeState] = ...
        BAKEPOINTSTATE_UP_TO_DATE: ClassVar[BakePointNode.BakePointNodeState] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    BAKEPOINTSTATE_DIRTY: ClassVar[BakePointNode.BakePointNodeState] = ...
    BAKEPOINTSTATE_NOT_AVAILABLE: ClassVar[BakePointNode.BakePointNodeState] = ...
    BAKEPOINTSTATE_UP_TO_DATE: ClassVar[BakePointNode.BakePointNodeState] = ...
    bakedStateChanged: ClassVar[PySide2.QtCore.Signal] = ...
    exportPathChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def applyFilterCollection(self): ...
    def bake(self): ...
    def bakedResult(self) -> ImageSet: ...
    def connectSignals(self, *args, **kwargs): ...
    def deleteBakedResult(self): ...
    def depth(self) -> Image.Depth: ...
    def exportBakedResult(self, BakeOutOfDate: bool, Options: typing.SupportsInt = ..., UVIndexList: typing.List[int] = ..., FileOptions: variant = ...): ...
    def exportOnBake(self) -> bool: ...
    def exportPath(self) -> str: ...
    def filterCollection(self) -> PostFilterCollection: ...
    def filterCollectionEnabled(self) -> bool: ...
    def geoChannel(self) -> GeoChannel: ...
    def geoChannelName(self) -> str: ...
    def hasBakedResult(self): ...
    def isBakePointNode(self) -> bool: ...
    def isBakedResultUpToDate(self): ...
    def limitBake(self) -> bool: ...
    def limitBakeRange(self) -> UvIndexRangeList: ...
    def onBakeStateChanged(self, *args, **kwargs): ...
    def setExportOnBake(self, ExportOnBake: bool): ...
    def setExportPath(self, Path: str): ...
    def setFilterCollectionEnabled(self, FilterCollectionEnabled: bool): ...
    def setGeoChannelName(self, Alias: str): ...
    def setLimitBake(self, LimitBake: bool): ...
    def setLimitBakeRange(self, LimitBakeRange: UvIndexRangeList): ...
    def setSyncToGeoChannel(self, Sync: bool): ...
    def syncGeoChannel(self): ...
    def syncToGeoChannel(self) -> bool: ...
    def __bool__(self) -> bool: ...

class BroadcastTeleportNode(TeleportNode):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def connectSignals(self, *args, **kwargs): ...
    def setChannelName(self, ChannelName: str): ...
    def __bool__(self) -> bool: ...

class Camera(Metadata):
    class Type:
        ORTHOGRAPHIC: ClassVar[Camera.Type] = ...
        PERSPECTIVE: ClassVar[Camera.Type] = ...
        UV: ClassVar[Camera.Type] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    ORTHOGRAPHIC: ClassVar[Camera.Type] = ...
    PERSPECTIVE: ClassVar[Camera.Type] = ...
    UV: ClassVar[Camera.Type] = ...
    attributeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    moved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def adjustClipPlanes(self): ...
    def farClip(self): ...
    def fieldOfView(self): ...
    def fieldOfViewX(self): ...
    def fieldOfViewY(self): ...
    def isAnimated(self) -> bool: ...
    def lookAt(self): ...
    def name(self) -> str: ...
    def nearClip(self): ...
    def perspectiveAspectRatio(self): ...
    def projectionMatrix(self, AspectRatio: float = ..., Frame: typing.SupportsInt = ...) -> variant: ...
    def scale(self) -> float: ...
    def setAnimated(self): ...
    def setFarClip(self): ...
    def setFieldOfView(self): ...
    def setFieldOfViewX(self): ...
    def setFieldOfViewY(self): ...
    def setLookAt(self): ...
    def setName(self): ...
    def setNearClip(self): ...
    def setScale(self): ...
    def setTranslation(self): ...
    def setType(self): ...
    def setUp(self): ...
    def translation(self): ...
    def type(self) -> type: ...
    def up(self): ...
    def viewMatrix(self, Frame: typing.SupportsInt = ...) -> variant: ...
    def viewport(self) -> PySide2.QtWidgets.QRect: ...
    def viewportAspectRatio(self) -> float: ...
    def __bool__(self) -> bool: ...

class Canvas(API):
    class PickSpace:
        PICKSPACE_PAINTING: ClassVar[Canvas.PickSpace] = ...
        PICKSPACE_SCREEN: ClassVar[Canvas.PickSpace] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    PICKSPACE_PAINTING: ClassVar[Canvas.PickSpace] = ...
    PICKSPACE_SCREEN: ClassVar[Canvas.PickSpace] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def averageColor(self, X: typing.SupportsInt, Y: typing.SupportsInt, Width: typing.SupportsInt, Height: typing.SupportsInt, Space: PickSpace = ...) -> Color: ...
    def camera(self) -> Camera: ...
    def capture(self, Width: typing.SupportsInt = ..., Height: typing.SupportsInt = ...) -> PySide2.QtWidgets.QImage: ...
    def displayPropertyList(self) -> typing.List[str]: ...
    def getDisplayProperty(self, PropertyKey: str) -> variant: ...
    def pickColor(self, X: typing.SupportsInt, Y: typing.SupportsInt, Space: PickSpace = ...) -> Color: ...
    def repaint(self): ...
    def requestRepaint(self): ...
    def sceneCamera(self) -> Camera: ...
    def setDisplayProperty(self, PropertyKey: str, NewValue: variant): ...
    def size(self) -> PySide2.QtWidgets.QSize: ...
    def __bool__(self) -> bool: ...

class CanvasManager(PropertySource):
    class RenderState:
        Render_Busy: ClassVar[CanvasManager.RenderState] = ...
        Render_Disabled: ClassVar[CanvasManager.RenderState] = ...
        Render_Error: ClassVar[CanvasManager.RenderState] = ...
        Render_Normal: ClassVar[CanvasManager.RenderState] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    Render_Busy: ClassVar[CanvasManager.RenderState] = ...
    Render_Disabled: ClassVar[CanvasManager.RenderState] = ...
    Render_Error: ClassVar[CanvasManager.RenderState] = ...
    Render_Normal: ClassVar[CanvasManager.RenderState] = ...
    aboutToRenderCanvas: ClassVar[PySide2.QtCore.Signal] = ...
    normalRenderFinished: ClassVar[PySide2.QtCore.Signal] = ...
    renderError: ClassVar[PySide2.QtCore.Signal] = ...
    renderedCanvas: ClassVar[PySide2.QtCore.Signal] = ...
    renderedCanvas2: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def current(self) -> Canvas: ...
    def fps(self) -> float: ...
    def list(self) -> typing.List[Canvas]: ...
    def paintBuffer(self) -> PaintBuffer: ...
    def pauseShaderCompiles(self) -> bool: ...
    def setPauseShaderCompiles(self, Pause: bool): ...
    def size(self) -> typing.List[int]: ...
    def __bool__(self) -> bool: ...

class Channel(LayerStack):
    class ConvertOption:
        CONVERT_ALL: ClassVar[Channel.ConvertOption] = ...
        CONVERT_CHANNEL_ONLY: ClassVar[Channel.ConvertOption] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class ResizeMetric:
        RESIZE_BY_PATCH_MAXIMUM: ClassVar[Channel.ResizeMetric] = ...
        RESIZE_BY_TEXELS_PER_UNIT: ClassVar[Channel.ResizeMetric] = ...
        RESIZE_BY_TEXEL_SIZE: ClassVar[Channel.ResizeMetric] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    CONVERT_ALL: ClassVar[Channel.ConvertOption] = ...
    CONVERT_CHANNEL_ONLY: ClassVar[Channel.ConvertOption] = ...
    RESIZE_BY_PATCH_MAXIMUM: ClassVar[Channel.ResizeMetric] = ...
    RESIZE_BY_TEXELS_PER_UNIT: ClassVar[Channel.ResizeMetric] = ...
    RESIZE_BY_TEXEL_SIZE: ClassVar[Channel.ResizeMetric] = ...
    colorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    layerMadeCurrent: ClassVar[PySide2.QtCore.Signal] = ...
    lockedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    scalarColorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    snapshotAdded: ClassVar[PySide2.QtCore.Signal] = ...
    snapshotRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bakeTo(self, TargetLayer: Layer, SelectedOnly: bool = ...) -> bool: ...
    def bleed(self) -> bool: ...
    def channelNode(self) -> ChannelNode: ...
    def colorspaceConfig(self) -> ColorspaceConfig: ...
    def convertColorSpaceTo(self, NewColorSpace: str, Option: ConvertOption = ...): ...
    def createSnapshot(self, Name: str, ID: str = ...) -> Snapshot: ...
    def currentLayer(self): ...
    def deleteSnapshot(self, ShotToDelete: Snapshot): ...
    def depth(self) -> Image.Depth: ...
    def exportToGeoChannel(self, GeoChannelName: str) -> bool: ...
    def fileSpace(self) -> Image.FileSpace: ...
    def findSnapshotWithID(self, ID: str) -> Snapshot: ...
    def flatten(self) -> Layer: ...
    def geoEntity(self) -> GeoEntity: ...
    def height(self, UVIndex: typing.SupportsInt = ...) -> int: ...
    def isLocked(self) -> bool: ...
    def isPtex(self): ...
    def isShaderStack(self): ...
    def lock(self): ...
    def makeCurrent(self): ...
    def metricResize(self, Metric: ResizeMetric, Value: float, UVIndexList: typing.List[int] = ...): ...
    def name(self) -> str: ...
    def resize(self, NewSize: ImageSet.Size, UVIndexList: typing.List[int] = ...): ...
    def revertToSnapshot(self, OldSnapshot: Snapshot): ...
    def scalarColorspaceConfig(self) -> ColorspaceConfig: ...
    def setBleed(self, Bleed: bool): ...
    def setColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setCurrentLayer(self, NewCurrentLayer: Layer): ...
    def setDepth(self, Depth: Image.Depth, Option: ConvertOption): ...
    def setFileSpace(self, FileSpace: Image.FileSpace): ...
    def setLocked(self): ...
    def setName(self, NewName: str): ...
    def setScalarColorspaceConfig(self, Config: ColorspaceConfig): ...
    def snapshotList(self) -> typing.List[Snapshot]: ...
    def unlock(self): ...
    def updateUvImageSizes(self): ...
    def width(self, UVIndex: typing.SupportsInt = ...) -> int: ...
    def __bool__(self) -> bool: ...

class ChannelInfo(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def colorspaceConfig(self) -> ColorspaceConfig: ...
    def depth(self): ...
    def fileSpace(self): ...
    def fileTemplate(self) -> str: ...
    def fillColor(self): ...
    def height(self): ...
    def name(self): ...
    def path(self): ...
    def scalarColorspaceConfig(self) -> ColorspaceConfig: ...
    def setColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setDepth(self): ...
    def setFileSpace(self): ...
    def setFileTemplate(self, rTemplate: str): ...
    def setFillColor(self): ...
    def setHeight(self): ...
    def setName(self): ...
    def setPath(self): ...
    def setScalarColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setShader(self, rShader: str): ...
    def setSize(self, WidthAndHeight: typing.SupportsInt): ...
    def setWidth(self): ...
    def shader(self): ...
    def size(self) -> int: ...
    def width(self): ...
    def __bool__(self) -> bool: ...

class ChannelLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def channel(self) -> Channel: ...
    def __bool__(self) -> bool: ...

class ChannelNode(BakePointNode):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def channel(self) -> Channel: ...
    def isBakePointNode(self) -> bool: ...
    def __bool__(self) -> bool: ...

class ChannelSnapshot(Snapshot):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def extract(self, NewChannelName: str): ...
    def __bool__(self) -> bool: ...

class Clock(API):
    class PlayDirection:
        BACKWARDS: ClassVar[Clock.PlayDirection] = ...
        FORWARDS: ClassVar[Clock.PlayDirection] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class RepeatType:
        BOUNCE: ClassVar[Clock.RepeatType] = ...
        LOOP: ClassVar[Clock.RepeatType] = ...
        STOP: ClassVar[Clock.RepeatType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    BACKWARDS: ClassVar[Clock.PlayDirection] = ...
    BOUNCE: ClassVar[Clock.RepeatType] = ...
    FORWARDS: ClassVar[Clock.PlayDirection] = ...
    LOOP: ClassVar[Clock.RepeatType] = ...
    STOP: ClassVar[Clock.RepeatType] = ...
    frameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    frameRateChanged: ClassVar[PySide2.QtCore.Signal] = ...
    playingChanged: ClassVar[PySide2.QtCore.Signal] = ...
    rangeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def frame(self) -> int: ...
    def frameCount(self) -> int: ...
    def frameRate(self) -> int: ...
    def loopCount(self) -> int: ...
    def play(self, Direction: PlayDirection = ...): ...
    def playing(self) -> bool: ...
    def repeatType(self) -> RepeatType: ...
    def reset(self): ...
    def rewind(self): ...
    def setFrame(self, Frame: typing.SupportsInt): ...
    def setFrameRange(self, Start: typing.SupportsInt, End: typing.SupportsInt): ...
    def setFrameRate(self, fps: typing.SupportsInt): ...
    def setRepeatType(self, Type: RepeatType): ...
    def setSourceFrameRate(self, Fps: typing.SupportsInt): ...
    def sourceFrameRate(self) -> int: ...
    def startFrame(self) -> int: ...
    def stepBack(self): ...
    def stepForward(self): ...
    def stop(self): ...
    def stopFrame(self) -> int: ...
    def time(self) -> str: ...
    def __bool__(self) -> bool: ...

class Color(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def a(self): ...
    def b(self): ...
    def exposure(self): ...
    def g(self): ...
    def h(self): ...
    def hsl(self): ...
    def hsla(self): ...
    def hsv(self): ...
    def hsva(self): ...
    def l(self): ...
    def lum(self): ...
    def r(self): ...
    def rgb(self): ...
    def rgba(self): ...
    def s(self): ...
    def setA(self): ...
    def setB(self): ...
    def setG(self): ...
    def setH(self): ...
    def setHSL(self): ...
    def setHSLA(self): ...
    def setHSV(self): ...
    def setHSVA(self): ...
    def setL(self): ...
    def setR(self): ...
    def setRGB(self): ...
    def setRGBA(self): ...
    def setS(self): ...
    def setV(self): ...
    def toString(self): ...
    def userReadable(self): ...
    def v(self): ...
    def __bool__(self) -> bool: ...

class Colors(API):
    backgroundChanged: ClassVar[PySide2.QtCore.Signal] = ...
    foregroundChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def background(self) -> Color: ...
    def foreground(self) -> Color: ...
    def pick(self, InitialColor: Color, ScalarPickingMode: bool = ...): ...
    def setBackground(self, NewColor: Color): ...
    def setForeground(self, NewColor: Color): ...
    def __bool__(self) -> bool: ...

class ColorspaceConfig(API):
    class ColorspaceStage:
        COLORSPACE_STAGE_COUNT: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
        COLORSPACE_STAGE_NATIVE: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
        COLORSPACE_STAGE_OUTPUT: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
        COLORSPACE_STAGE_WORKING: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class ColorspaceType:
        COLORSPACE_TYPE_COUNT: ClassVar[ColorspaceConfig.ColorspaceType] = ...
        COLORSPACE_TYPE_FLOAT: ClassVar[ColorspaceConfig.ColorspaceType] = ...
        COLORSPACE_TYPE_INT16: ClassVar[ColorspaceConfig.ColorspaceType] = ...
        COLORSPACE_TYPE_INT8: ClassVar[ColorspaceConfig.ColorspaceType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    COLORSPACE_STAGE_COUNT: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
    COLORSPACE_STAGE_NATIVE: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
    COLORSPACE_STAGE_OUTPUT: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
    COLORSPACE_STAGE_WORKING: ClassVar[ColorspaceConfig.ColorspaceStage] = ...
    COLORSPACE_TYPE_COUNT: ClassVar[ColorspaceConfig.ColorspaceType] = ...
    COLORSPACE_TYPE_FLOAT: ClassVar[ColorspaceConfig.ColorspaceType] = ...
    COLORSPACE_TYPE_INT16: ClassVar[ColorspaceConfig.ColorspaceType] = ...
    COLORSPACE_TYPE_INT8: ClassVar[ColorspaceConfig.ColorspaceType] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def automaticColorspace(self, Stage: ColorspaceStage) -> str: ...
    def automaticType(self, Stage: ColorspaceStage) -> ColorspaceType: ...
    def availableColorspaces(self, Stage: ColorspaceStage = ..., PrettyNames: bool = ...) -> typing.List[str]: ...
    def colorspace(self, Stage: ColorspaceStage) -> str: ...
    def defaultColorspace(self, Stage: ColorspaceStage) -> str: ...
    def fileName(self): ...
    def fromString(self, Str: str): ...
    def isColorspaceValid(self, Colorspace: str, Stage: ColorspaceStage = ..., Strict: bool = ...) -> bool: ...
    def isFileCustom(self): ...
    def isFileValid(self): ...
    def isValid(self): ...
    def raw(self) -> bool: ...
    def reset(self): ...
    def resolveColorspace(self, Stage: ColorspaceStage) -> str: ...
    def resolveRaw(self): ...
    def scalar(self) -> bool: ...
    def setAutomaticColorspace(self, Stage: ColorspaceStage, Colorspace: str): ...
    def setAutomaticType(self, Stage: ColorspaceStage, Type: ColorspaceType): ...
    def setColorspace(self, Stage: ColorspaceStage, Colorspace: str): ...
    def setRaw(self, Enable: bool): ...
    def setScalar(self, Enable: bool): ...
    def toString(self) -> str: ...
    def __bool__(self) -> bool: ...

class ColorspaceDefaults(API):
    class ColorspaceTarget:
        COLORSPACE_TARGET_BLENDING: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_COLOR_PICKER: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_COUNT: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_FLOAT: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_INT16: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_INT8: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_INT_SCALAR: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_MONITOR: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_SCALAR_MONITOR: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        COLORSPACE_TARGET_WORKING: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    COLORSPACE_TARGET_BLENDING: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_COLOR_PICKER: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_COUNT: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_FLOAT: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_INT16: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_INT8: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_INT_SCALAR: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_MONITOR: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_SCALAR_MONITOR: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    COLORSPACE_TARGET_WORKING: ClassVar[ColorspaceDefaults.ColorspaceTarget] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def availableColorspaces(self, Target: ColorspaceTarget = ..., PrettyNames: bool = ...) -> typing.List[str]: ...
    def colorManagementEnabled(self): ...
    def colorspace(self, Target: ColorspaceTarget) -> str: ...
    def defaultColorspace(self, Target: ColorspaceTarget) -> str: ...
    def fileName(self): ...
    def hasColorspace(self, Colorspace: str) -> bool: ...
    def isFileCustom(self): ...
    def isFileValid(self): ...
    def isValid(self): ...
    def reset(self): ...
    def resolveColorspace(self, Target: ColorspaceTarget) -> str: ...
    def setColorManagementEnabled(self, Enable: bool): ...
    def setColorspace(self, Target: ColorspaceTarget, Colorspace: str): ...
    def setFileName(self, FileName: str): ...
    def __bool__(self) -> bool: ...

class ComboBox(WidgetBase):
    currentIndexChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self): ...
    def currentIndex(self): ...
    def currentText(self) -> str: ...
    def findText(self, Text: str): ...
    def setContents(self, Values: typing.List[str]): ...
    def setCurrentIndex(self, Index: typing.SupportsInt): ...
    def setCurrentText(self, Value: str): ...
    def __bool__(self) -> bool: ...

class CustomLUTFilter(PostFilter):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setData(self, Data: typing.List[Color]): ...
    def __bool__(self) -> bool: ...

class CustomProceduralLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def convertToPaintable(self, SelectedOnly: bool = ...): ...
    def customProceduralType(self) -> CustomProceduralNode.CustomProceduralType: ...
    def geoChannels(self) -> typing.List[str]: ...
    def missingGeoChannels(self) -> typing.List[str]: ...
    def nodeGraph(self) -> NodeGraph: ...
    def setCustomProceduralType(self, Type: CustomProceduralNode.CustomProceduralType): ...
    def __bool__(self) -> bool: ...

class CustomProceduralNode(GroupNode):
    class CustomProceduralType:
        CUSTOMPROCEDURAL_TYPE_COLOR: ClassVar[CustomProceduralNode.CustomProceduralType] = ...
        CUSTOMPROCEDURAL_TYPE_MASK: ClassVar[CustomProceduralNode.CustomProceduralType] = ...
        CUSTOMPROCEDURAL_TYPE_SCALAR: ClassVar[CustomProceduralNode.CustomProceduralType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    CUSTOMPROCEDURAL_TYPE_COLOR: ClassVar[CustomProceduralNode.CustomProceduralType] = ...
    CUSTOMPROCEDURAL_TYPE_MASK: ClassVar[CustomProceduralNode.CustomProceduralType] = ...
    CUSTOMPROCEDURAL_TYPE_SCALAR: ClassVar[CustomProceduralNode.CustomProceduralType] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addCustomProceduralTag(self, Tag: str): ...
    def addCustomProceduralTags(self, Tags: typing.List[str]): ...
    def customProceduralTags(self) -> typing.List[str]: ...
    def customProceduralType(self) -> CustomProceduralType: ...
    def exportCustomProcedural(self, FileName: str, ThumbnailFileName: str = ...): ...
    def geoChannels(self) -> typing.List[str]: ...
    def missingGeoChannels(self) -> typing.List[str]: ...
    @classmethod
    def readMetadataFromCustomProceduralFile(cls, CustomProceduralFilePath: str) -> PySide2.QtWidgets.QJsonDocument: ...
    @classmethod
    def readSystemMetadataFromCustomProceduralFile(cls, CustomProceduralFilePath: str) -> PySide2.QtWidgets.QJsonDocument: ...
    @classmethod
    def readTagsFromCustomProceduralFile(cls, CustomProceduralFilePath: str) -> typing.List[str]: ...
    @classmethod
    def readThumbnailFromCustomProceduralFile(cls, CustomProceduralFilePath: str) -> PySide2.QtWidgets.QImage: ...
    def removeCustomProceduralTag(self, Tag: str): ...
    def removeCustomProceduralTags(self, Tags: typing.List[str]): ...
    def setCustomProceduralTags(self, CustomProceduralTags: typing.List[str]): ...
    def setCustomProceduralType(self, Type: CustomProceduralType): ...
    @classmethod
    def writeMetadataToCustomProceduralFile(cls, MetadataMap: PySide2.QtWidgets.QJsonDocument, CustomProceduralFilePath: str) -> bool: ...
    @classmethod
    def writeTagsToCustomProceduralFile(cls, Tags: typing.List[str], CustomProceduralFilePath: str) -> bool: ...
    @classmethod
    def writeThumbnailToCustomProceduralFile(cls, Thumbnail: PySide2.QtWidgets.QImage, CustomProceduralFilePath: str): ...
    def __bool__(self) -> bool: ...

class DDI(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def clearMemory(self): ...
    def clearMemoryCache(self): ...
    def clearTraces(self, Hash: str): ...
    def dataBlocks(self) -> int: ...
    def garbageCollect(self, UnusedPatches: bool = ...): ...
    def isLive(self, Hash: str) -> bool: ...
    def liveBlocks(self) -> int: ...
    def liveBytes(self): ...
    def memoryCacheSize(self) -> int: ...
    def profile(self, NumberOfBlocks: typing.SupportsInt = ..., BlockSize: unsignedint = ..., RandomSize: bool = ...) -> int: ...
    def setMemoryCacheSize(self, Size: typing.SupportsInt): ...
    def setTraceEnabled(self, Hash: str, Enabled: bool = ...): ...
    def traces(self, Hash: str) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class Environment(API):
    changed: ClassVar[PySide2.QtCore.Signal] = ...
    removed: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def exists(self, Name: str) -> bool: ...
    def get(self, Name: str) -> str: ...
    def names(self) -> typing.List[str]: ...
    def set(self, Name: str, NewValue: str) -> bool: ...
    def unset(self, Name: str) -> bool: ...
    def __bool__(self) -> bool: ...

class EnvironmentLight(Light):
    class CubeImageType:
        TYPE_2D_CROSS: ClassVar[EnvironmentLight.CubeImageType] = ...
        TYPE_2D_LATLONG: ClassVar[EnvironmentLight.CubeImageType] = ...
        TYPE_3D_CUBEMAP: ClassVar[EnvironmentLight.CubeImageType] = ...
        TYPE_GUESS: ClassVar[EnvironmentLight.CubeImageType] = ...
        TYPE_NONE: ClassVar[EnvironmentLight.CubeImageType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class ImageUpAxis:
        AXIS_UP_X: ClassVar[EnvironmentLight.ImageUpAxis] = ...
        AXIS_UP_Y: ClassVar[EnvironmentLight.ImageUpAxis] = ...
        AXIS_UP_Z: ClassVar[EnvironmentLight.ImageUpAxis] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class RotationMode:
        MODE_ROTATE: ClassVar[EnvironmentLight.RotationMode] = ...
        MODE_STATIC: ClassVar[EnvironmentLight.RotationMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    AXIS_UP_X: ClassVar[EnvironmentLight.ImageUpAxis] = ...
    AXIS_UP_Y: ClassVar[EnvironmentLight.ImageUpAxis] = ...
    AXIS_UP_Z: ClassVar[EnvironmentLight.ImageUpAxis] = ...
    MODE_ROTATE: ClassVar[EnvironmentLight.RotationMode] = ...
    MODE_STATIC: ClassVar[EnvironmentLight.RotationMode] = ...
    TYPE_2D_CROSS: ClassVar[EnvironmentLight.CubeImageType] = ...
    TYPE_2D_LATLONG: ClassVar[EnvironmentLight.CubeImageType] = ...
    TYPE_3D_CUBEMAP: ClassVar[EnvironmentLight.CubeImageType] = ...
    TYPE_GUESS: ClassVar[EnvironmentLight.CubeImageType] = ...
    TYPE_NONE: ClassVar[EnvironmentLight.CubeImageType] = ...
    canvasBlurChanged: ClassVar[PySide2.QtCore.Signal] = ...
    canvasDisplayChanged: ClassVar[PySide2.QtCore.Signal] = ...
    cubeImageFilenameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    cubeImageResolutionChanged: ClassVar[PySide2.QtCore.Signal] = ...
    cubeImageTypeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    cubeImageUpAxisChanged: ClassVar[PySide2.QtCore.Signal] = ...
    fixedToChanged: ClassVar[PySide2.QtCore.Signal] = ...
    intensityChanged: ClassVar[PySide2.QtCore.Signal] = ...
    rotationUpChanged: ClassVar[PySide2.QtCore.Signal] = ...
    rotationUpModeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    rotationUpSpeedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def canvasBlur(self) -> float: ...
    def canvasDisplay(self) -> bool: ...
    def clearCubeImageCache(self): ...
    def clearLightCache(self): ...
    def cubeImage(self) -> Image: ...
    def cubeImageFilename(self) -> str: ...
    def cubeImageResolution(self) -> int: ...
    def cubeImageType(self) -> CubeImageType: ...
    def cubeImageUpAxis(self) -> ImageUpAxis: ...
    def fixedTo(self) -> FixedTo: ...
    def intensity(self) -> float: ...
    def printLightCacheKeys(self): ...
    def rotationUp(self) -> float: ...
    def rotationUpMode(self) -> RotationMode: ...
    def rotationUpSpeed(self) -> float: ...
    def setCanvasBlur(self, Blur: float): ...
    def setCanvasDisplay(self, Display: bool): ...
    def setCubeImage(self, rImage: variant, Type: CubeImageType): ...
    def setCubeImageResolution(self, Resolution: typing.SupportsInt): ...
    def setCubeImageType(self, Type: CubeImageType): ...
    def setCubeImageUpAxis(self, Axis: ImageUpAxis): ...
    def setFixedTo(self, TargetType: FixedTo): ...
    def setIntensity(self, Intensity: float): ...
    def setRotationUp(self, Angle: float): ...
    def setRotationUpMode(self, Mode: RotationMode): ...
    def setRotationUpSpeed(self, Speed: float): ...
    def __bool__(self) -> bool: ...

class Event(API):
    class EventCoordinateSpace:
        APPLICATION_SPACE: ClassVar[Event.EventCoordinateSpace] = ...
        CANVAS_SPACE: ClassVar[Event.EventCoordinateSpace] = ...
        DESKTOP_SPACE: ClassVar[Event.EventCoordinateSpace] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class EventType:
        KEY_PRESS: ClassVar[Event.EventType] = ...
        KEY_RELEASE: ClassVar[Event.EventType] = ...
        MOUSE_DOUBLE_CLICK: ClassVar[Event.EventType] = ...
        MOUSE_MOVE: ClassVar[Event.EventType] = ...
        MOUSE_PRESS: ClassVar[Event.EventType] = ...
        MOUSE_RELEASE: ClassVar[Event.EventType] = ...
        TABLET_ENTER_PROXIMITY: ClassVar[Event.EventType] = ...
        TABLET_LEAVE_PROXIMITY: ClassVar[Event.EventType] = ...
        TABLET_MOVE: ClassVar[Event.EventType] = ...
        TABLET_PRESS: ClassVar[Event.EventType] = ...
        TABLET_RELEASE: ClassVar[Event.EventType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class KeyboardModifier:
        ALT_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        CONTROL_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        GROUP_SWITCH_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        KEYPAD_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        META_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        NO_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        SHIFT_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class MouseButton:
        LEFT_BUTTON: ClassVar[Event.MouseButton] = ...
        MIDDLE_BUTTON: ClassVar[Event.MouseButton] = ...
        NO_BUTTON: ClassVar[Event.MouseButton] = ...
        RIGHT_BUTTON: ClassVar[Event.MouseButton] = ...
        X_BUTTON_1: ClassVar[Event.MouseButton] = ...
        X_BUTTON_2: ClassVar[Event.MouseButton] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    ALT_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    APPLICATION_SPACE: ClassVar[Event.EventCoordinateSpace] = ...
    CANVAS_SPACE: ClassVar[Event.EventCoordinateSpace] = ...
    CONTROL_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    DESKTOP_SPACE: ClassVar[Event.EventCoordinateSpace] = ...
    GROUP_SWITCH_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    KEYPAD_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    KEY_PRESS: ClassVar[Event.EventType] = ...
    KEY_RELEASE: ClassVar[Event.EventType] = ...
    LEFT_BUTTON: ClassVar[Event.MouseButton] = ...
    META_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    MIDDLE_BUTTON: ClassVar[Event.MouseButton] = ...
    MOUSE_DOUBLE_CLICK: ClassVar[Event.EventType] = ...
    MOUSE_MOVE: ClassVar[Event.EventType] = ...
    MOUSE_PRESS: ClassVar[Event.EventType] = ...
    MOUSE_RELEASE: ClassVar[Event.EventType] = ...
    NO_BUTTON: ClassVar[Event.MouseButton] = ...
    NO_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    RIGHT_BUTTON: ClassVar[Event.MouseButton] = ...
    SHIFT_MODIFIER: ClassVar[Event.KeyboardModifier] = ...
    TABLET_ENTER_PROXIMITY: ClassVar[Event.EventType] = ...
    TABLET_LEAVE_PROXIMITY: ClassVar[Event.EventType] = ...
    TABLET_MOVE: ClassVar[Event.EventType] = ...
    TABLET_PRESS: ClassVar[Event.EventType] = ...
    TABLET_RELEASE: ClassVar[Event.EventType] = ...
    X_BUTTON_1: ClassVar[Event.MouseButton] = ...
    X_BUTTON_2: ClassVar[Event.MouseButton] = ...
    playbackComplete: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def eventFilter(self, *args, **kwargs): ...
    def isPlaying(self) -> bool: ...
    def recordPlay(self): ...
    def recordStart(self, Space: EventCoordinateSpace = ..., Normalized: bool = ...): ...
    def recordStop(self): ...
    def recordString(self) -> str: ...
    def sendKeyEvent(self, Type: EventType, Key: typing.SupportsInt, Modifiers: typing.SupportsInt, AutoRepeat: bool, Msecs: typing.SupportsInt = ...): ...
    def sendMouseEvent(self, Type: EventType, Pos: PySide2.QtWidgets.QPointF, Button: MouseButton, Buttons: typing.SupportsInt, Modifiers: typing.SupportsInt, Space: EventCoordinateSpace = ..., Normalized: bool = ..., Msecs: typing.SupportsInt = ...): ...
    def sendTabletEvent(self, Type: EventType, Pos: PySide2.QtWidgets.QPointF, Pressure: qreal, Modifiers: typing.SupportsInt, Space: EventCoordinateSpace = ..., Normalized: bool = ..., Msecs: typing.SupportsInt = ...): ...
    def __bool__(self) -> bool: ...

class ExportItem(Metadata):
    imageExported: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def colorspace(self) -> str: ...
    def depth(self) -> str: ...
    def deserializeFromString(self, XMLString: str): ...
    def errorStringList(self) -> typing.List[str]: ...
    def exportEnabled(self) -> bool: ...
    def fileOptions(self) -> variant: ...
    def fileOptionsString(self) -> str: ...
    def fileTemplate(self) -> str: ...
    def geoEntity(self): ...
    def onImageExported(self, *args, **kwargs): ...
    def postProcessCommand(self) -> str: ...
    def resolution(self) -> str: ...
    def resolveExportFilePaths(self, RootPath: str = ...) -> typing.List[str]: ...
    def resolveFileTemplate(self, Overrides: variant = ...) -> str: ...
    def resolvedColorspace(self) -> str: ...
    def serializeToString(self) -> str: ...
    def setColorspace(self, Colorspace: str): ...
    def setDepth(self, Depth: str): ...
    def setErrorStringList(self, ErrorStringList: typing.List[str]): ...
    def setExportEnabled(self, ExportEnabled: bool): ...
    def setFileOptions(self, FileOptions: variant): ...
    def setFileTemplate(self, FileTemplate: str): ...
    def setGeoEntity(self, Entity: GeoEntity): ...
    def setPostProcessCommand(self, PostProcessCommand: str): ...
    def setResolution(self, Resolution: str): ...
    def setSourceNode(self, SourceNode: Node): ...
    def setUvIndexList(self, UVIndexList: typing.List[int]): ...
    def setWarningStringList(self, WarningStringList: typing.List[str]): ...
    def sourceColorspace(self) -> str: ...
    def sourceDepth(self) -> Image.Depth: ...
    def sourceDepthAsInternalFormat(self) -> int: ...
    def sourceNode(self) -> Node: ...
    def sourceNodeName(self) -> str: ...
    def sourceResolution(self) -> str: ...
    def uvIndexList(self) -> typing.List[int]: ...
    def warningStringList(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class ExportManager(API):
    imageExported: ClassVar[PySide2.QtCore.Signal] = ...
    itemAdded: ClassVar[PySide2.QtCore.Signal] = ...
    itemExported: ClassVar[PySide2.QtCore.Signal] = ...
    itemRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addExportItem(self, Item: ExportItem, Entity: GeoEntity): ...
    def checkExportItemIsValid(self, Item: ExportItem, Entity: GeoEntity) -> bool: ...
    def colorspaceList(self) -> typing.List[str]: ...
    def depthList(self) -> typing.List[str]: ...
    def exportItemList(self, Entity: GeoEntity) -> typing.List[ExportItem]: ...
    def exportTextures(self, ExportItems: typing.List[ExportItem], ExportRootPath: str, Overrides: variant = ...) -> str: ...
    def imageFileExtensionList(self) -> typing.List[str]: ...
    def imageFileOptions(self, Extension: str) -> variant: ...
    def imageFileOptionsWidget(self, Extension: str) -> PySide2.QtWidgets.QWidget: ...
    def postProcessCommandList(self) -> typing.List[str]: ...
    def registerPostProcessCommand(self, Command: str): ...
    def removeExportItem(self, Item: ExportItem): ...
    def resolutionList(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class FaceSelectionGroup(SelectionGroup):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def geoEntityList(self): ...
    def geoVersionList(self): ...
    def meshLocationToFaceSelectionIndexRangeListMap(self) -> dict[str, IndexRangeList]: ...
    def __bool__(self) -> bool: ...

class FileLUTFilter(PostFilter):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def filePath(self) -> str: ...
    def setFilePath(self, FilePath: str): ...
    def __bool__(self) -> bool: ...

class FileList(API):
    class Type:
        TYPE_CHOOSE_FILE: ClassVar[FileList.Type] = ...
        TYPE_DIRECTORY: ClassVar[FileList.Type] = ...
        TYPE_FILE: ClassVar[FileList.Type] = ...
        TYPE_FILE_AND_DIRECTORY: ClassVar[FileList.Type] = ...
        TYPE_SAVE_FILE: ClassVar[FileList.Type] = ...
        TYPE_SINGLE_DIRECTORY: ClassVar[FileList.Type] = ...
        TYPE_SINGLE_FILE: ClassVar[FileList.Type] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    TYPE_CHOOSE_FILE: ClassVar[FileList.Type] = ...
    TYPE_DIRECTORY: ClassVar[FileList.Type] = ...
    TYPE_FILE: ClassVar[FileList.Type] = ...
    TYPE_FILE_AND_DIRECTORY: ClassVar[FileList.Type] = ...
    TYPE_SAVE_FILE: ClassVar[FileList.Type] = ...
    TYPE_SINGLE_DIRECTORY: ClassVar[FileList.Type] = ...
    TYPE_SINGLE_FILE: ClassVar[FileList.Type] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def acceptNonExisting(self) -> bool: ...
    def append(self, File: str): ...
    def at(self, Index: typing.SupportsInt) -> str: ...
    def clear(self): ...
    def contains(self, File: str) -> bool: ...
    def count(self) -> int: ...
    def defaultDirectory(self) -> str: ...
    def filter(self) -> str: ...
    def insert(self, Index: typing.SupportsInt, File: str): ...
    def isEmpty(self) -> bool: ...
    def pathKey(self) -> str: ...
    def pickedFile(self) -> str: ...
    def removeAt(self, Index: typing.SupportsInt): ...
    def setAcceptNonExisting(self, AcceptNonExisting: bool): ...
    def setDefaultDirectory(self, DefaultDirectory: str): ...
    def setFilter(self, Filter: str): ...
    def setPathKey(self, PathKey: str): ...
    def setPickedFile(self, PickedFile: str): ...
    def setType(self, T: type): ...
    def type(self) -> type: ...
    def __bool__(self) -> bool: ...

class FloatSlider(SliderBase):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    valueChanged: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setValue(self, Value: float): ...
    def value(self) -> float: ...
    def __bool__(self) -> bool: ...

class GLRender(API):
    class ShaderCompileResult:
        SHADER_COMPILE_FAILED: ClassVar[GLRender.ShaderCompileResult] = ...
        SHADER_LINK_FAILED: ClassVar[GLRender.ShaderCompileResult] = ...
        SHADER_LINK_SUCCESS: ClassVar[GLRender.ShaderCompileResult] = ...
        SHADER_RELOAD_MACROS_FAILED: ClassVar[GLRender.ShaderCompileResult] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    SHADER_COMPILE_FAILED: ClassVar[GLRender.ShaderCompileResult] = ...
    SHADER_LINK_FAILED: ClassVar[GLRender.ShaderCompileResult] = ...
    SHADER_LINK_SUCCESS: ClassVar[GLRender.ShaderCompileResult] = ...
    SHADER_RELOAD_MACROS_FAILED: ClassVar[GLRender.ShaderCompileResult] = ...
    currentPostFilterCollectionModified: ClassVar[PySide2.QtCore.Signal] = ...
    postFilterCollectionAdded: ClassVar[PySide2.QtCore.Signal] = ...
    postFilterCollectionRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    postProcessingEnabled: ClassVar[PySide2.QtCore.Signal] = ...
    setCurrentPostFilterCollection: ClassVar[PySide2.QtCore.Signal] = ...
    shaderCompileComplete: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def applyFilter(self, Filter: PostFilter) -> bool: ...
    def clearError(self): ...
    def createPostFilterCollection(self, Name: str): ...
    def createQuickApplyGLSL(self, Name: str, DefinitionsSnippet: str = ..., BodySnippet: str = ..., IconPath: str = ..., DisplayMetadata: bool = ...) -> GLSLFilter: ...
    def currentPostFilterCollection(self): ...
    def deletePostFilterCollection(self, Collection: PostFilterCollection): ...
    @classmethod
    def deregisterCustomCubemapFile(cls, UUID: str): ...
    @classmethod
    def deregisterCustomImagemapFile(cls, UUID: str): ...
    def findFilter(self, Name: str) -> PostFilter: ...
    def findPostFilterCollection(self, Name: str) -> PostFilterCollection: ...
    def findQuickApplyFilter(self, Name: str) -> PostFilter: ...
    def isCurrentGLShaderProgramValid(self): ...
    def isPostProcessingEnabled(self) -> bool: ...
    def platformInformation(self): ...
    def postFilterCollectionNames(self) -> typing.List[str]: ...
    def postFilterCollections(self) -> typing.List[PostFilterCollection]: ...
    @classmethod
    def registerCustomAdjustmentLayerFromXMLFile(cls, Name: str, FilePath: str): ...
    @classmethod
    def registerCustomBlendMode(cls, DisplayName: str, FunctionName: str, BlendModeCode: str): ...
    @classmethod
    def registerCustomCodeFile(cls, UUID: str, FilePath: str): ...
    @classmethod
    def registerCustomCubemapFile(cls, UUID: str, FilePath: str, MinMipSize: typing.SupportsInt = ...): ...
    @classmethod
    def registerCustomDiffuseShaderFromXMLFile(cls, Name: str, FilePath: str): ...
    @classmethod
    def registerCustomHeaderFile(cls, UUID: str, FilePath: str): ...
    @classmethod
    def registerCustomImagemapFile(cls, UUID: str, FilePath: str): ...
    @classmethod
    def registerCustomLayeredShaderFromXMLFile(cls, Name: str, FilePath: str): ...
    @classmethod
    def registerCustomNodeFromXMLFile(cls, Name: str, FilePath: str): ...
    @classmethod
    def registerCustomProceduralLayerFromXMLFile(cls, Name: str, FilePath: str): ...
    @classmethod
    def registerCustomSpecularShaderFromXMLFile(cls, Name: str, FilePath: str): ...
    @classmethod
    def registerCustomStandaloneShaderFromXMLFile(cls, Name: str, FilePath: str): ...
    def reloadXMLDefinitions(self): ...
    def removeQuickApplyFilter(self, Filter: PostFilter): ...
    def runGLSLCode(self, GLSLCode: str, Destination: ImageSet, Source: ImageSet = ..., Mask: ImageSet = ..., BlendMode: str = ..., BlendAmount: float = ...): ...
    def setPostFilterCollection(self, Collection: PostFilterCollection): ...
    def setPostProcessingEnabled(self, Enabled: bool): ...
    def upgradeExistingShadersAndLayers(self): ...
    def __bool__(self) -> bool: ...

class GLSLFilter(PostFilter):
    class Clamp:
        CLAMP_REPEAT: ClassVar[GLSLFilter.Clamp] = ...
        CLAMP_TO_EDGE: ClassVar[GLSLFilter.Clamp] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class Filter:
        FILTER_LINEAR: ClassVar[GLSLFilter.Filter] = ...
        FILTER_MIPMAP_LINEAR: ClassVar[GLSLFilter.Filter] = ...
        FILTER_NEAREST: ClassVar[GLSLFilter.Filter] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class Format:
        FORMAT_L: ClassVar[GLSLFilter.Format] = ...
        FORMAT_R: ClassVar[GLSLFilter.Format] = ...
        FORMAT_RGB: ClassVar[GLSLFilter.Format] = ...
        FORMAT_RGBA: ClassVar[GLSLFilter.Format] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    CLAMP_REPEAT: ClassVar[GLSLFilter.Clamp] = ...
    CLAMP_TO_EDGE: ClassVar[GLSLFilter.Clamp] = ...
    FILTER_LINEAR: ClassVar[GLSLFilter.Filter] = ...
    FILTER_MIPMAP_LINEAR: ClassVar[GLSLFilter.Filter] = ...
    FILTER_NEAREST: ClassVar[GLSLFilter.Filter] = ...
    FORMAT_L: ClassVar[GLSLFilter.Format] = ...
    FORMAT_R: ClassVar[GLSLFilter.Format] = ...
    FORMAT_RGB: ClassVar[GLSLFilter.Format] = ...
    FORMAT_RGBA: ClassVar[GLSLFilter.Format] = ...
    enabledChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bodySnippet(self) -> str: ...
    def definitionsSnippet(self) -> str: ...
    def deleteTexture(self, SamplerName: str): ...
    def setBodySnippet(self, BodySnippet: str): ...
    def setDefinitionsSnippet(self, DefinitionsSnippet: str): ...
    def setTexture1D(self, SamplerName: str, Width: typing.SupportsInt, DataFormat: Format, Data: typing.List[float], MinFilter: Filter = ..., MagFilter: Filter = ..., ClampS: Clamp = ..., ClampT: Clamp = ...): ...
    def setTexture2D(self, SamplerName: str, Width: typing.SupportsInt, Height: typing.SupportsInt, DataFormat: Format, Data: typing.List[float], MinFilter: Filter = ..., MagFilter: Filter = ..., ClampS: Clamp = ..., ClampT: Clamp = ...): ...
    def setTexture3D(self, SamplerName: str, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, DataFormat: Format, Data: typing.List[float], MinFilter: Filter = ..., MagFilter: Filter = ..., ClampS: Clamp = ..., ClampT: Clamp = ..., ClampR: Clamp = ...): ...
    def updateTexture1D(self, SamplerName: str, Data: typing.List[float]): ...
    def updateTexture2D(self, SamplerName: str, Data: typing.List[float]): ...
    def updateTexture3D(self, SamplerName: str, Data: typing.List[float]): ...
    def __bool__(self) -> bool: ...

class GLSLFilterFactory(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def deregisterFilter(self): ...
    def registerFilter(self, CreateMenuEntries: bool = ..., IconPath: str = ..., DisplayProperties: bool = ...): ...
    def setupFilter(self, Filter: GLSLFilter): ...
    def __bool__(self) -> bool: ...

class GeoChannel(Metadata):
    imageSetChanged: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def aliases(self) -> typing.List[str]: ...
    def geoChannelLayers(self) -> typing.List[Layer]: ...
    def geoChannelNodes(self) -> typing.List[GeoChannelNode]: ...
    def imageSet(self) -> ImageSet: ...
    def name(self) -> str: ...
    def setAliases(self, Aliases: typing.List[str]): ...
    def setImageSet(self, ImageSetObject: ImageSet): ...
    def setName(self, Name: str): ...
    def __bool__(self) -> bool: ...

class GeoChannelNode(Node):
    geoChannelNameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def geoChannelName(self): ...
    def isGeoChannelNode(self) -> bool: ...
    def setGeoChannelName(self, Name: str): ...
    def __bool__(self) -> bool: ...

class GeoEntity(Lockable):
    class ChannelDestroyStrategy:
        DESTROY_ALL: ClassVar[GeoEntity.ChannelDestroyStrategy] = ...
        DESTROY_NONE: ClassVar[GeoEntity.ChannelDestroyStrategy] = ...
        DESTROY_UNSHARED: ClassVar[GeoEntity.ChannelDestroyStrategy] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class SystemShaderType:
        SYSTEM_SHADER_CURRENT_CHANNEL: ClassVar[GeoEntity.SystemShaderType] = ...
        SYSTEM_SHADER_CURRENT_LAYER: ClassVar[GeoEntity.SystemShaderType] = ...
        SYSTEM_SHADER_CURRENT_LAYER_AND_BELOW: ClassVar[GeoEntity.SystemShaderType] = ...
        SYSTEM_SHADER_CURRENT_PAINT_TARGET: ClassVar[GeoEntity.SystemShaderType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    DESTROY_ALL: ClassVar[GeoEntity.ChannelDestroyStrategy] = ...
    DESTROY_NONE: ClassVar[GeoEntity.ChannelDestroyStrategy] = ...
    DESTROY_UNSHARED: ClassVar[GeoEntity.ChannelDestroyStrategy] = ...
    SYSTEM_SHADER_CURRENT_CHANNEL: ClassVar[GeoEntity.SystemShaderType] = ...
    SYSTEM_SHADER_CURRENT_LAYER: ClassVar[GeoEntity.SystemShaderType] = ...
    SYSTEM_SHADER_CURRENT_LAYER_AND_BELOW: ClassVar[GeoEntity.SystemShaderType] = ...
    SYSTEM_SHADER_CURRENT_PAINT_TARGET: ClassVar[GeoEntity.SystemShaderType] = ...
    channelAdded: ClassVar[PySide2.QtCore.Signal] = ...
    channelCreated: ClassVar[PySide2.QtCore.Signal] = ...
    channelMadeCurrent: ClassVar[PySide2.QtCore.Signal] = ...
    channelRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    geoChannelAdded: ClassVar[PySide2.QtCore.Signal] = ...
    geoChannelRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    geometryVersionAdded: ClassVar[PySide2.QtCore.Signal] = ...
    geometryVersionMadeCurrent: ClassVar[PySide2.QtCore.Signal] = ...
    geometryVersionRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    imageSetAdded: ClassVar[PySide2.QtCore.Signal] = ...
    imageSetMadeCurrent: ClassVar[PySide2.QtCore.Signal] = ...
    imageSetRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shaderCreated: ClassVar[PySide2.QtCore.Signal] = ...
    shaderMadeCurrent: ClassVar[PySide2.QtCore.Signal] = ...
    shaderRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addLocator(self) -> LocatorEntity: ...
    def addVersion(self, Paths: variant, Name: str, Options: variant = ...): ...
    def boundingBoxLowerBounds(self) -> VectorN: ...
    def boundingBoxUpperBounds(self) -> VectorN: ...
    def boundingSphereCenter(self) -> VectorN: ...
    def boundingSphereRadius(self) -> float: ...
    def channel(self, ChannelName: str) -> Channel: ...
    def channelList(self) -> typing.List[Channel]: ...
    def completePatchList(self) -> typing.List[GeoPatch]: ...
    def createChannel(self, Name: str, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, IsShaderStack: bool = ...) -> Channel: ...
    def createDuplicateChannel(self, ChannelToDuplicate: Channel, NewChannelName: str = ...) -> Channel: ...
    def createDuplicateShader(self, ShaderToDuplicate: Shader, NewShaderName: str = ...) -> Shader: ...
    def createGeoChannel(self) -> GeoChannel: ...
    def createLayeredShader(self, Name: str, LayeredType: str) -> Shader: ...
    def createPtexChannel(self, Name: str, Depth: typing.SupportsInt) -> Channel: ...
    def createStandaloneShader(self, Name: str, StandaloneType: str) -> Shader: ...
    def currentChannel(self) -> Channel: ...
    def currentImageSet(self) -> ImageSet: ...
    def currentShader(self) -> Shader: ...
    def currentVersion(self) -> GeoEntityVersion: ...
    def currentVersionName(self) -> str: ...
    def exportAsArchive(self, DirPath: str): ...
    def findChannel(self, name: str) -> Channel: ...
    def findGeoChannel(self, Alias: str) -> GeoChannel: ...
    def findImageSet(self): ...
    def findShader(self, Name: str) -> Shader: ...
    def generateSubdivision(self, Options: dict[str, variant]) -> bool: ...
    def geoChannels(self) -> typing.List[GeoChannel]: ...
    def hideLocator(self): ...
    def imageSet(self): ...
    def imageSetList(self) -> typing.List[ImageSet]: ...
    def imageSetNames(self) -> typing.List[str]: ...
    def importFromArchive(self, DirPath: str): ...
    def isPtex(self): ...
    def isSelected(self) -> bool: ...
    def maximumSubdivisionLevel(self): ...
    def missingGeoChannels(self) -> typing.List[str]: ...
    def name(self) -> str: ...
    def nodeGraph(self) -> NodeGraph: ...
    def patch(self, UvIndex: typing.SupportsInt) -> GeoPatch: ...
    def patchImage(self, Patch: GeoPatch, pImageSet: ImageSet) -> Image: ...
    def patchList(self) -> typing.List[GeoPatch]: ...
    def remapSubdivisionSettings(self, Options: dict[str, variant]): ...
    def removeChannel(self, ChannelToRemove: Channel, Strategy: ChannelDestroyStrategy = ...): ...
    def removeGeoChannel(self, GeoChannelObject: GeoChannel): ...
    def removeShader(self, ShaderToRemove: Shader, RetractionMode: Shader.ChannelSetMode = ...): ...
    def removeVersion(self, VersionName: str): ...
    def renameVersion(self, OldName: str, NewName: str): ...
    def save(self, FileName: str, Format: str = ...): ...
    def selectedPatches(self) -> typing.List[GeoPatch]: ...
    def setCurrentChannel(self, NewCurrentChannel: Channel): ...
    def setCurrentImageSet(self, NewCurrentImageSet: variant): ...
    def setCurrentShader(self, NewCurrentShader: Shader): ...
    def setCurrentVersion(self, VersionName: str): ...
    def setName(self, NewName: str): ...
    def setSelected(self, Selected: bool): ...
    def setSubdivisionLevel(self, Level: typing.SupportsInt): ...
    def setTransform(self, pTransform: Matrix, Frame: typing.SupportsInt = ...): ...
    def shader(self, Name: str) -> Shader: ...
    @classmethod
    def shaderLayeredTypeList(cls, *args, **kwargs): ...
    def shaderList(self) -> typing.List[Shader]: ...
    @classmethod
    def shaderStandaloneTypeList(cls, *args, **kwargs): ...
    def showLocator(self): ...
    def subdivisionBoundaryInterpolateMethod(self): ...
    def subdivisionCreasing(self): ...
    def subdivisionFaceVaryingBoundaryInterpolateMethod(self): ...
    def subdivisionScheme(self): ...
    def subdivisionSkippedMeshList(self): ...
    def subdivisionTriangleSubdivisionRule(self): ...
    def systemShader(self, Type: SystemShaderType) -> Shader: ...
    def transform(self, Frame: typing.SupportsInt) -> Matrix: ...
    def translation(self, Frame: typing.SupportsInt = ...) -> VectorN: ...
    def version(self, VersionName: str) -> GeoEntityVersion: ...
    def versionList(self) -> typing.List[GeoEntityVersion]: ...
    def versionNames(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class GeoEntityVersion(Metadata):
    aboutToLoad: ClassVar[PySide2.QtCore.Signal] = ...
    createdChanged: ClassVar[PySide2.QtCore.Signal] = ...
    creatorChanged: ClassVar[PySide2.QtCore.Signal] = ...
    loaded: ClassVar[PySide2.QtCore.Signal] = ...
    modifiedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    pathChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def created(self) -> PySide2.QtWidgets.QDateTime: ...
    def creator(self) -> str: ...
    def geoEntity(self) -> GeoEntity: ...
    def geometryCount(self) -> int: ...
    def load(self) -> bool: ...
    def meshLocationToFaceCountMap(self) -> dict[str, int]: ...
    def meshPaths(self) -> typing.List[str]: ...
    def modified(self) -> PySide2.QtWidgets.QDateTime: ...
    def name(self) -> str: ...
    def patchList(self) -> typing.List[GeoPatch]: ...
    def path(self) -> str: ...
    def setCreated(self, CreatedDate: PySide2.QtWidgets.QDateTime): ...
    def setCreator(self, Creator: str): ...
    def setMeshPaths(self, Paths: typing.List[str]): ...
    def setModified(self, ModifiedDate: PySide2.QtWidgets.QDateTime): ...
    def setName(self, NewName: str): ...
    def setPath(self, Path: str): ...
    def setSettings(self, NewSettings: variant): ...
    def setSettingsString(self, SettingsString: str): ...
    def settings(self) -> variant: ...
    def settingsString(self) -> str: ...
    def sourceMeshLocationList(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class GeoManager(API):
    class CreateSelectionSetOptions:
        SELECTION_GROUPS_CREATE_FROM_FACE_GROUPS: ClassVar[GeoManager.CreateSelectionSetOptions] = ...
        SELECTION_GROUPS_DONT_CREATE: ClassVar[GeoManager.CreateSelectionSetOptions] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class GeometryImportFlags:
        GEOMETRY_IMPORT_DONT_MERGE_CHILDREN: ClassVar[GeoManager.GeometryImportFlags] = ...
        GEOMETRY_IMPORT_DONT_SELECT_CHILDREN: ClassVar[GeoManager.GeometryImportFlags] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class MergeSelectionGroupWithSameNameType:
        MERGESELECTIONGROUP_DO_NOT_MERGE: ClassVar[GeoManager.MergeSelectionGroupWithSameNameType] = ...
        MERGESELECTIONGROUP_MERGE_SELECTIONGROUP_HAVING_SAME_NAME: ClassVar[GeoManager.MergeSelectionGroupWithSameNameType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class MergeType:
        MERGETYPE_JUST_MERGE_NODES: ClassVar[GeoManager.MergeType] = ...
        MERGETYPE_SINGLE_MESH: ClassVar[GeoManager.MergeType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class NodeType:
        CAMERA: ClassVar[GeoManager.NodeType] = ...
        FACESET: ClassVar[GeoManager.NodeType] = ...
        GROUP: ClassVar[GeoManager.NodeType] = ...
        POLYMESH: ClassVar[GeoManager.NodeType] = ...
        ROOT: ClassVar[GeoManager.NodeType] = ...
        SUBDIV: ClassVar[GeoManager.NodeType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class OpenSubdivisionBoundaryInterpolation:
        VTX_BOUNDARY_EDGE_AND_CORNER: ClassVar[GeoManager.OpenSubdivisionBoundaryInterpolation] = ...
        VTX_BOUNDARY_EDGE_ONLY: ClassVar[GeoManager.OpenSubdivisionBoundaryInterpolation] = ...
        VTX_BOUNDARY_NONE: ClassVar[GeoManager.OpenSubdivisionBoundaryInterpolation] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class OpenSubdivisionCreasingMethod:
        CREASE_CHAIKIN: ClassVar[GeoManager.OpenSubdivisionCreasingMethod] = ...
        CREASE_UNIFORM: ClassVar[GeoManager.OpenSubdivisionCreasingMethod] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class OpenSubdivisionFaceVaryingInterpolation:
        FVAR_LINEAR_ALL: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
        FVAR_LINEAR_BOUNDARIES: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
        FVAR_LINEAR_CORNERS_ONLY: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
        FVAR_LINEAR_CORNERS_PLUS1: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
        FVAR_LINEAR_CORNERS_PLUS2: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
        FVAR_LINEAR_NONE: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class OpenSubdivisionSchemeType:
        SCHEME_BILINEAR: ClassVar[GeoManager.OpenSubdivisionSchemeType] = ...
        SCHEME_CATMARK: ClassVar[GeoManager.OpenSubdivisionSchemeType] = ...
        SCHEME_LOOP: ClassVar[GeoManager.OpenSubdivisionSchemeType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class OpenSubdivisionTriangleSubdivision:
        TRI_SUB_CATMARK: ClassVar[GeoManager.OpenSubdivisionTriangleSubdivision] = ...
        TRI_SUB_SMOOTH: ClassVar[GeoManager.OpenSubdivisionTriangleSubdivision] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    CAMERA: ClassVar[GeoManager.NodeType] = ...
    CREASE_CHAIKIN: ClassVar[GeoManager.OpenSubdivisionCreasingMethod] = ...
    CREASE_UNIFORM: ClassVar[GeoManager.OpenSubdivisionCreasingMethod] = ...
    FACESET: ClassVar[GeoManager.NodeType] = ...
    FVAR_LINEAR_ALL: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
    FVAR_LINEAR_BOUNDARIES: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
    FVAR_LINEAR_CORNERS_ONLY: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
    FVAR_LINEAR_CORNERS_PLUS1: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
    FVAR_LINEAR_CORNERS_PLUS2: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
    FVAR_LINEAR_NONE: ClassVar[GeoManager.OpenSubdivisionFaceVaryingInterpolation] = ...
    GEOMETRY_IMPORT_DONT_MERGE_CHILDREN: ClassVar[GeoManager.GeometryImportFlags] = ...
    GEOMETRY_IMPORT_DONT_SELECT_CHILDREN: ClassVar[GeoManager.GeometryImportFlags] = ...
    GROUP: ClassVar[GeoManager.NodeType] = ...
    MERGESELECTIONGROUP_DO_NOT_MERGE: ClassVar[GeoManager.MergeSelectionGroupWithSameNameType] = ...
    MERGESELECTIONGROUP_MERGE_SELECTIONGROUP_HAVING_SAME_NAME: ClassVar[GeoManager.MergeSelectionGroupWithSameNameType] = ...
    MERGETYPE_JUST_MERGE_NODES: ClassVar[GeoManager.MergeType] = ...
    MERGETYPE_SINGLE_MESH: ClassVar[GeoManager.MergeType] = ...
    POLYMESH: ClassVar[GeoManager.NodeType] = ...
    ROOT: ClassVar[GeoManager.NodeType] = ...
    SCHEME_BILINEAR: ClassVar[GeoManager.OpenSubdivisionSchemeType] = ...
    SCHEME_CATMARK: ClassVar[GeoManager.OpenSubdivisionSchemeType] = ...
    SCHEME_LOOP: ClassVar[GeoManager.OpenSubdivisionSchemeType] = ...
    SELECTION_GROUPS_CREATE_FROM_FACE_GROUPS: ClassVar[GeoManager.CreateSelectionSetOptions] = ...
    SELECTION_GROUPS_DONT_CREATE: ClassVar[GeoManager.CreateSelectionSetOptions] = ...
    SUBDIV: ClassVar[GeoManager.NodeType] = ...
    TRI_SUB_CATMARK: ClassVar[GeoManager.OpenSubdivisionTriangleSubdivision] = ...
    TRI_SUB_SMOOTH: ClassVar[GeoManager.OpenSubdivisionTriangleSubdivision] = ...
    VTX_BOUNDARY_EDGE_AND_CORNER: ClassVar[GeoManager.OpenSubdivisionBoundaryInterpolation] = ...
    VTX_BOUNDARY_EDGE_ONLY: ClassVar[GeoManager.OpenSubdivisionBoundaryInterpolation] = ...
    VTX_BOUNDARY_NONE: ClassVar[GeoManager.OpenSubdivisionBoundaryInterpolation] = ...
    entityAdded: ClassVar[PySide2.QtCore.Signal] = ...
    entityMadeCurrent: ClassVar[PySide2.QtCore.Signal] = ...
    entityRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addLocator(self, AddAsChildToSelectedObject: bool = ...) -> LocatorEntity: ...
    def current(self) -> GeoEntity: ...
    def currentLocator(self) -> LocatorEntity: ...
    def duplicateCurrentGeoEntity(self, DuplicateShaderNetwork: bool = ...): ...
    def duplicateGeoEntity(self, Object: GeoEntity, DuplicateShaderNetwork: bool = ...): ...
    def find(self, Name: str) -> GeoEntity: ...
    def geometryOperationList(self) -> typing.List[GeometryOperation]: ...
    def get(self, Name: str) -> GeoEntity: ...
    def getAnimationTakes(self, Path: str) -> typing.List[str]: ...
    def getDefaultAnimationTake(self, Path: str) -> str: ...
    def getFileContents(self, Path: str) -> variant: ...
    def getFileFrameRange(self, Path: str, Take: str = ...) -> typing.List[int]: ...
    def importFromArchive(self, DirPath: str): ...
    def list(self) -> typing.List[GeoEntity]: ...
    def listLocators(self) -> typing.List[LocatorEntity]: ...
    def load(self, Path: str, Options: variant = ..., ObjectsToLoad: variant = ..., LoadAsChild: bool = ...) -> typing.List[GeoEntity]: ...
    def names(self) -> typing.List[str]: ...
    def recalculatePatchBounds(self): ...
    def remove(self, Name: str): ...
    def setCurrent(self, Name: str): ...
    def supportedReadFormats(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class GeoPatch(Lockable):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def isLocked(self) -> bool: ...
    def isSelected(self) -> bool: ...
    def isValid(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def name(self) -> str: ...
    def setLocked(self, Locked: bool): ...
    def setName(self, Name: str): ...
    def setSelected(self, Selected: bool): ...
    def setVisibility(self, Visible: bool): ...
    def u(self) -> int: ...
    def udim(self) -> int: ...
    def uv(self) -> PySide2.QtWidgets.QPoint: ...
    def uvIndex(self) -> int: ...
    def v(self) -> int: ...
    def __bool__(self) -> bool: ...

class GeometryOperation(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def execute(self, Operation: str, GeometryEntity: GeoEntity, GeoVersion: GeoEntityVersion, QuerySubdivisionMesh: bool, SubdivisionLevel: typing.SupportsInt, ExtraParams: variant = ...) -> bool: ...
    def name(self) -> str: ...
    def operationDescription(self, Name: str) -> str: ...
    def supportedOperations(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class GraphLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def convertToPaintable(self, SelectedOnly: bool = ...): ...
    def nodeGraph(self) -> NodeGraph: ...
    def __bool__(self) -> bool: ...

class GroupLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def flattenLayerGroup(self) -> bool: ...
    def layerStack(self) -> LayerStack: ...
    def __bool__(self) -> bool: ...

class GroupNode(Node):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def childNodeGraph(self) -> NodeGraph: ...
    def convertToCustomProcedural(self): ...
    def createKnob(self, KnobName: str, TargetNode: Node, TargetAttributeName: str, PrettyKnobName: str = ...) -> bool: ...
    def deleteKnob(self, KnobName: str, TargetNode: Node, TargetAttributeName: str): ...
    def groupInputNode(self, InputName: str) -> Node: ...
    def groupOutputNode(self, OutputName: str) -> Node: ...
    def isGroupNode(self) -> bool: ...
    def knobList(self) -> typing.List[variant]: ...
    def linkKnobs(self, KnobName: str, TargetKnobNames: typing.List[str], PrettyKnobName: str = ...): ...
    def renameKnob(self, OldName: str, NewName: str): ...
    def __bool__(self) -> bool: ...

class History(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def cancelMacro(self): ...
    def clear(self, ShowDialog: bool = ...): ...
    def isMacroActive(self) -> bool: ...
    def redo(self) -> bool: ...
    def startMacro(self, MacroName: str): ...
    def stopMacro(self): ...
    def undo(self) -> bool: ...
    def __bool__(self) -> bool: ...

class Image(Metadata):
    class Depth:
        DEPTH_BYTE: ClassVar[Image.Depth] = ...
        DEPTH_FLOAT: ClassVar[Image.Depth] = ...
        DEPTH_HALF: ClassVar[Image.Depth] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class FileSpace:
        FILESPACE_NORMAL: ClassVar[Image.FileSpace] = ...
        FILESPACE_NORMAL_Y_FLIP: ClassVar[Image.FileSpace] = ...
        FILESPACE_VECTOR: ClassVar[Image.FileSpace] = ...
        FILESPACE_VECTOR_Y_FLIP: ClassVar[Image.FileSpace] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class SaveOptions:
        BACKGROUND_EXPORT: ClassVar[Image.SaveOptions] = ...
        DEFAULT_OPTIONS: ClassVar[Image.SaveOptions] = ...
        DISABLE_SMALL_UNIFORMS: ClassVar[Image.SaveOptions] = ...
        ENABLE_FULL_PATCH_BLEED: ClassVar[Image.SaveOptions] = ...
        EXPORT_UV_MASK_IN_ALPHA: ClassVar[Image.SaveOptions] = ...
        REMOVE_ALPHA: ClassVar[Image.SaveOptions] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    BACKGROUND_EXPORT: ClassVar[Image.SaveOptions] = ...
    DEFAULT_OPTIONS: ClassVar[Image.SaveOptions] = ...
    DEPTH_BYTE: ClassVar[Image.Depth] = ...
    DEPTH_FLOAT: ClassVar[Image.Depth] = ...
    DEPTH_HALF: ClassVar[Image.Depth] = ...
    DISABLE_SMALL_UNIFORMS: ClassVar[Image.SaveOptions] = ...
    ENABLE_FULL_PATCH_BLEED: ClassVar[Image.SaveOptions] = ...
    EXPORT_UV_MASK_IN_ALPHA: ClassVar[Image.SaveOptions] = ...
    FILESPACE_NORMAL: ClassVar[Image.FileSpace] = ...
    FILESPACE_NORMAL_Y_FLIP: ClassVar[Image.FileSpace] = ...
    FILESPACE_VECTOR: ClassVar[Image.FileSpace] = ...
    FILESPACE_VECTOR_Y_FLIP: ClassVar[Image.FileSpace] = ...
    REMOVE_ALPHA: ClassVar[Image.SaveOptions] = ...
    aboutToClose: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToExport: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToImport: ClassVar[PySide2.QtCore.Signal] = ...
    colorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    exported: ClassVar[PySide2.QtCore.Signal] = ...
    imported: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def close(self): ...
    def colorspaceConfig(self) -> ColorspaceConfig: ...
    def convertDepth(self, Depth: Image.Depth): ...
    def copyFrom(self, SourceImage: Image): ...
    def depth(self): ...
    @classmethod
    def depthAsInternalFormat(cls, Depth: Image.Depth) -> int: ...
    def filePath(self) -> str: ...
    def fileSpace(self): ...
    def fill(self, FillColor: Color): ...
    def hash(self) -> str: ...
    def height(self, MipMapLevel: typing.SupportsInt = ...) -> int: ...
    def isUniform(self) -> bool: ...
    def lastExportPath(self) -> str: ...
    def lastExportTime(self) -> PySide2.QtWidgets.QDateTime: ...
    def lastImportPath(self) -> str: ...
    def lastImportTime(self) -> PySide2.QtWidgets.QDateTime: ...
    def makeThumbnail(self): ...
    def mipMapCount(self) -> int: ...
    def mostRelevantPath(self) -> str: ...
    def resize(self, NewSize: PySide2.QtWidgets.QSize): ...
    def saveAs(self, FileName: str, Options: variant = ..., SaveOpts: typing.SupportsInt = ...): ...
    def setColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setFileSpace(self): ...
    def setUniformColor(self, pUniformColor: Color): ...
    def size(self, MipMapLevel: typing.SupportsInt = ...) -> typing.List[int]: ...
    def thumbnail(self): ...
    def transform(self, Collection: PostFilterCollection) -> bool: ...
    def uniformColor(self) -> Color: ...
    def width(self, MipMapLevel: typing.SupportsInt = ...) -> int: ...
    def __bool__(self) -> bool: ...

class ImageManager(Metadata):
    class ImageAlphaProcessing:
        IMAGE_NO_PRE_MULTIPLY_ALPHA: ClassVar[ImageManager.ImageAlphaProcessing] = ...
        IMAGE_PRE_MULTIPLY_ALPHA: ClassVar[ImageManager.ImageAlphaProcessing] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class ImageColorSpaceConversionType:
        IMAGE_COLOR_CONVERSION_LINEAR_TO_SRGB: ClassVar[ImageManager.ImageColorSpaceConversionType] = ...
        IMAGE_COLOR_CONVERSION_NONE: ClassVar[ImageManager.ImageColorSpaceConversionType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    IMAGE_COLOR_CONVERSION_LINEAR_TO_SRGB: ClassVar[ImageManager.ImageColorSpaceConversionType] = ...
    IMAGE_COLOR_CONVERSION_NONE: ClassVar[ImageManager.ImageColorSpaceConversionType] = ...
    IMAGE_NO_PRE_MULTIPLY_ALPHA: ClassVar[ImageManager.ImageAlphaProcessing] = ...
    IMAGE_PRE_MULTIPLY_ALPHA: ClassVar[ImageManager.ImageAlphaProcessing] = ...
    beginImageLoading: ClassVar[PySide2.QtCore.Signal] = ...
    endImageLoading: ClassVar[PySide2.QtCore.Signal] = ...
    handleProtocol: ClassVar[PySide2.QtCore.Signal] = ...
    imageLoaded: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self, ImageToAdd: Image, Name: str = ...): ...
    def addCategory(self, CategoryName: str): ...
    def addImage(self, ImageToAdd: PySide2.QtWidgets.QImage, Name: str = ...) -> Image: ...
    def backgroundOpen(self, Path: str, Config: ColorspaceConfig = ..., AlphaProcessing: ImageAlphaProcessing = ..., Name: str = ..., Category: str = ...): ...
    def categories(self) -> typing.List[str]: ...
    def clearTraces(self, PathOrHash: str): ...
    def compressionList(self, Extension: str) -> typing.List[str]: ...
    def currentCategory(self) -> str: ...
    def defaultCompressionMethod(self, Extension: str) -> str: ...
    def defaultImageFormat(self, BitDepth: Image.Depth) -> str: ...
    def getImage(self, Hash: str) -> Image: ...
    def imageOperationList(self) -> typing.List[ImageOperation]: ...
    def list(self) -> typing.List[Image]: ...
    def open(self, Path: str, Config: ColorspaceConfig = ..., AlphaProcessing: ImageAlphaProcessing = ..., Name: str = ...) -> typing.List[Image]: ...
    def protocolSupported(self, Protocol: str) -> bool: ...
    def registerContextAction(self, MenuAction: PySide2.QtWidgets.QAction, Category: str = ..., IconPath: str = ...): ...
    def registerProtocolHandler(self, Protocol: str, Handler: ImageProtocolHandler) -> bool: ...
    def remove(self, ImageToRemove: Image): ...
    def removeCategory(self, CategoryName: str) -> bool: ...
    def removeContextAction(self, MenuAction: PySide2.QtWidgets.QAction, Category: str = ...) -> bool: ...
    def saveImages(self, Images: typing.List[Image], Path: str) -> bool: ...
    def selectCategory(self, CategoryName: str) -> bool: ...
    def selected(self) -> typing.List[Image]: ...
    def setDefaultImageFormat(self, Format: str, BitDepth: Image.Depth): ...
    def setMetadata(self, Name: str, Value: variant): ...
    def setTraceEnabled(self, PathOrHash: str, Enabled: bool = ...): ...
    def supportedReadFormats(self) -> typing.List[str]: ...
    def supportedTextureSizeList(self) -> typing.List[variant]: ...
    def supportedWriteFormats(self): ...
    def traces(self, PathOrHash: str) -> typing.List[str]: ...
    def unregisterProtocolHandler(self, Protocol: str): ...
    def __bool__(self) -> bool: ...

class ImageMimeDataInfo(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def colorspaceConfigString(self) -> str: ...
    @classmethod
    def fromMimeDataString(cls, MimeDataString: str) -> typing.List[ImageMimeDataInfo]: ...
    def path(self) -> str: ...
    def __bool__(self) -> bool: ...

class ImageOperation(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def execute(self, Operation: str, Source: Image, ExtraParams: variant = ...) -> bool: ...
    def name(self) -> str: ...
    def operationDescription(self, Name: str) -> str: ...
    def supportedOperations(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class ImageProtocolHandler(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def load(self, Location: str) -> str: ...
    def __bool__(self) -> bool: ...

class ImageSet(Snapshotable):
    class ScaleChoice:
        SCALE_THE_IMAGE: ClassVar[ImageSet.ScaleChoice] = ...
        SCALE_THE_PATCH: ClassVar[ImageSet.ScaleChoice] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class Size:
        SIZE_1024: ClassVar[ImageSet.Size] = ...
        SIZE_16384: ClassVar[ImageSet.Size] = ...
        SIZE_2048: ClassVar[ImageSet.Size] = ...
        SIZE_256: ClassVar[ImageSet.Size] = ...
        SIZE_32768: ClassVar[ImageSet.Size] = ...
        SIZE_4096: ClassVar[ImageSet.Size] = ...
        SIZE_512: ClassVar[ImageSet.Size] = ...
        SIZE_8192: ClassVar[ImageSet.Size] = ...
        SIZE_DOUBLE: ClassVar[ImageSet.Size] = ...
        SIZE_HALF: ClassVar[ImageSet.Size] = ...
        SIZE_NULL: ClassVar[ImageSet.Size] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    SCALE_THE_IMAGE: ClassVar[ImageSet.ScaleChoice] = ...
    SCALE_THE_PATCH: ClassVar[ImageSet.ScaleChoice] = ...
    SIZE_1024: ClassVar[ImageSet.Size] = ...
    SIZE_16384: ClassVar[ImageSet.Size] = ...
    SIZE_2048: ClassVar[ImageSet.Size] = ...
    SIZE_256: ClassVar[ImageSet.Size] = ...
    SIZE_32768: ClassVar[ImageSet.Size] = ...
    SIZE_4096: ClassVar[ImageSet.Size] = ...
    SIZE_512: ClassVar[ImageSet.Size] = ...
    SIZE_8192: ClassVar[ImageSet.Size] = ...
    SIZE_DOUBLE: ClassVar[ImageSet.Size] = ...
    SIZE_HALF: ClassVar[ImageSet.Size] = ...
    SIZE_NULL: ClassVar[ImageSet.Size] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addKeyFrame(self, FrameNumber: typing.SupportsInt) -> bool: ...
    @classmethod
    def calculateNewSize(cls, *args, **kwargs): ...
    def createSnapshot(self, Name: str, ID: str = ...) -> Snapshot: ...
    def defaultKeyFrame(self) -> int: ...
    def deleteSnapshot(self, ShotToDelete: Snapshot): ...
    def exportImages(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., FileOptions: variant = ...): ...
    def findSnapshotWithID(self, ID: str) -> Snapshot: ...
    def frameCount(self) -> int: ...
    def frames(self) -> typing.List[int]: ...
    def image(self, UVIndex: typing.SupportsInt, Frame: typing.SupportsInt = ...): ...
    def imageCount(self) -> int: ...
    def imageList(self, Frame: typing.SupportsInt = ...) -> typing.List[Image]: ...
    def importImages(self, ImagePaths: variant, ScaleOption: ScaleChoice, UVIndexList: typing.List[int] = ..., RemoveAlpha: bool = ..., SourceColorConfig: ColorspaceConfig = ...): ...
    def importImagesFromDict(self, ImagePaths: dict[Image, str], ScaleOption: ScaleChoice, RemoveAlpha: bool = ..., SourceColorConfig: ColorspaceConfig = ...): ...
    @classmethod
    def internalScaleChoiceFromAPI(cls, *args, **kwargs): ...
    def isAnimated(self) -> bool: ...
    def isPtex(self) -> bool: ...
    def name(self): ...
    def removeKeyFrame(self): ...
    def resize(self, NewSize: ImageSet.Size, UVIndexList: typing.List[int] = ...): ...
    def revertToSnapshot(self, OldSnapshot: Snapshot): ...
    def setName(self, NewName: str): ...
    @classmethod
    def sizeFromQSize(cls, *args, **kwargs): ...
    def snapshotList(self) -> typing.List[Snapshot]: ...
    def supportedWriteFormats(self): ...
    def uvImageList(self): ...
    def uvIndex(self, UvImage: Image) -> int: ...
    def uvIndices(self): ...
    def __bool__(self) -> bool: ...

class IndexRangeList(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def fromString(self, RangeString: str) -> bool: ...
    def indexList(self) -> typing.List[int]: ...
    def toString(self) -> str: ...
    def __bool__(self) -> bool: ...

class IndexRangeListWidget(WidgetBase):
    lostFocus: ClassVar[PySide2.QtCore.Signal] = ...
    movedMouse: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setExtraControlsDisplayed(self, Display: bool): ...
    def setGeoEntity(self, GeoEntityObject: GeoEntity): ...
    def setUdimMode(self, UdimMode: bool): ...
    def setValue(self, Value: IndexRangeList): ...
    def udimMode(self) -> bool: ...
    def value(self) -> IndexRangeList: ...
    def __bool__(self) -> bool: ...

class IntSlider(SliderBase):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    valueChanged: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setValue(self, Value: typing.SupportsInt): ...
    def value(self) -> int: ...
    def __bool__(self) -> bool: ...

class Layer(Metadata):
    class AdvancedBlendComponent:
        BLUE_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
        GREEN_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
        GREYSCALE_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
        LUMINANCE_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
        RED_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class BlendMode:
        ADD: ClassVar[Layer.BlendMode] = ...
        ADD_NORMAL_MAPS: ClassVar[Layer.BlendMode] = ...
        BURN_HIGHLIGHTS: ClassVar[Layer.BlendMode] = ...
        BURN_MIDRANGE: ClassVar[Layer.BlendMode] = ...
        BURN_SHADOWS: ClassVar[Layer.BlendMode] = ...
        CLEAR: ClassVar[Layer.BlendMode] = ...
        COLOR: ClassVar[Layer.BlendMode] = ...
        COLOR_BURN: ClassVar[Layer.BlendMode] = ...
        COLOR_DODGE: ClassVar[Layer.BlendMode] = ...
        CONTRAST: ClassVar[Layer.BlendMode] = ...
        COPY: ClassVar[Layer.BlendMode] = ...
        COPY_RGB: ClassVar[Layer.BlendMode] = ...
        CUSTOM: ClassVar[Layer.BlendMode] = ...
        DARKEN: ClassVar[Layer.BlendMode] = ...
        DECONTRAST: ClassVar[Layer.BlendMode] = ...
        DIFFERENCE: ClassVar[Layer.BlendMode] = ...
        DODGE_HIGHLIGHTS: ClassVar[Layer.BlendMode] = ...
        DODGE_MIDRANGE: ClassVar[Layer.BlendMode] = ...
        DODGE_SHADOWS: ClassVar[Layer.BlendMode] = ...
        EXCLUSION: ClassVar[Layer.BlendMode] = ...
        HARD_LIGHT: ClassVar[Layer.BlendMode] = ...
        HARD_MIX: ClassVar[Layer.BlendMode] = ...
        HUE: ClassVar[Layer.BlendMode] = ...
        INVERSE_DIFFERENCE: ClassVar[Layer.BlendMode] = ...
        INVERT: ClassVar[Layer.BlendMode] = ...
        LIGHTEN: ClassVar[Layer.BlendMode] = ...
        LUMINANCE: ClassVar[Layer.BlendMode] = ...
        MIX: ClassVar[Layer.BlendMode] = ...
        MIX_NORMAL_MAPS: ClassVar[Layer.BlendMode] = ...
        MULTIPLY: ClassVar[Layer.BlendMode] = ...
        NUDGE_FLOW_VECTORS: ClassVar[Layer.BlendMode] = ...
        NUDGE_NORMAL_VECTORS: ClassVar[Layer.BlendMode] = ...
        OVERLAY: ClassVar[Layer.BlendMode] = ...
        PAINT_FLOW_VECTORS: ClassVar[Layer.BlendMode] = ...
        PAINT_NORMAL_VECTORS: ClassVar[Layer.BlendMode] = ...
        PIN_LIGHT: ClassVar[Layer.BlendMode] = ...
        REORIENTED_NORMAL_MAPPING: ClassVar[Layer.BlendMode] = ...
        SATURATION: ClassVar[Layer.BlendMode] = ...
        SCALE_VECTORS: ClassVar[Layer.BlendMode] = ...
        SCREEN: ClassVar[Layer.BlendMode] = ...
        SOFT_LIGHT: ClassVar[Layer.BlendMode] = ...
        SPONGE_DESATURATE: ClassVar[Layer.BlendMode] = ...
        VIVID_LIGHT: ClassVar[Layer.BlendMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class BlendType:
        ADVANCED_BLEND: ClassVar[Layer.BlendType] = ...
        BASIC_BLEND: ClassVar[Layer.BlendType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class MaskType:
        FROM_ALPHA: ClassVar[Layer.MaskType] = ...
        FROM_SELECTION_GROUP: ClassVar[Layer.MaskType] = ...
        HIDE_ALL: ClassVar[Layer.MaskType] = ...
        REVEAL_ALL: ClassVar[Layer.MaskType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class SwizzleDestination:
        SWIZZLE_DST_ALPHA: ClassVar[Layer.SwizzleDestination] = ...
        SWIZZLE_DST_BLUE: ClassVar[Layer.SwizzleDestination] = ...
        SWIZZLE_DST_GREEN: ClassVar[Layer.SwizzleDestination] = ...
        SWIZZLE_DST_RED: ClassVar[Layer.SwizzleDestination] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class SwizzleSource:
        SWIZZLE_SRC_ALPHA: ClassVar[Layer.SwizzleSource] = ...
        SWIZZLE_SRC_BLUE: ClassVar[Layer.SwizzleSource] = ...
        SWIZZLE_SRC_GREEN: ClassVar[Layer.SwizzleSource] = ...
        SWIZZLE_SRC_ONE: ClassVar[Layer.SwizzleSource] = ...
        SWIZZLE_SRC_RED: ClassVar[Layer.SwizzleSource] = ...
        SWIZZLE_SRC_ZERO: ClassVar[Layer.SwizzleSource] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    ADD: ClassVar[Layer.BlendMode] = ...
    ADD_NORMAL_MAPS: ClassVar[Layer.BlendMode] = ...
    ADVANCED_BLEND: ClassVar[Layer.BlendType] = ...
    BASIC_BLEND: ClassVar[Layer.BlendType] = ...
    BLUE_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
    BURN_HIGHLIGHTS: ClassVar[Layer.BlendMode] = ...
    BURN_MIDRANGE: ClassVar[Layer.BlendMode] = ...
    BURN_SHADOWS: ClassVar[Layer.BlendMode] = ...
    CLEAR: ClassVar[Layer.BlendMode] = ...
    COLOR: ClassVar[Layer.BlendMode] = ...
    COLOR_BURN: ClassVar[Layer.BlendMode] = ...
    COLOR_DODGE: ClassVar[Layer.BlendMode] = ...
    CONTRAST: ClassVar[Layer.BlendMode] = ...
    COPY: ClassVar[Layer.BlendMode] = ...
    COPY_RGB: ClassVar[Layer.BlendMode] = ...
    CUSTOM: ClassVar[Layer.BlendMode] = ...
    DARKEN: ClassVar[Layer.BlendMode] = ...
    DECONTRAST: ClassVar[Layer.BlendMode] = ...
    DIFFERENCE: ClassVar[Layer.BlendMode] = ...
    DODGE_HIGHLIGHTS: ClassVar[Layer.BlendMode] = ...
    DODGE_MIDRANGE: ClassVar[Layer.BlendMode] = ...
    DODGE_SHADOWS: ClassVar[Layer.BlendMode] = ...
    EXCLUSION: ClassVar[Layer.BlendMode] = ...
    FROM_ALPHA: ClassVar[Layer.MaskType] = ...
    FROM_SELECTION_GROUP: ClassVar[Layer.MaskType] = ...
    GREEN_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
    GREYSCALE_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
    HARD_LIGHT: ClassVar[Layer.BlendMode] = ...
    HARD_MIX: ClassVar[Layer.BlendMode] = ...
    HIDE_ALL: ClassVar[Layer.MaskType] = ...
    HUE: ClassVar[Layer.BlendMode] = ...
    INVERSE_DIFFERENCE: ClassVar[Layer.BlendMode] = ...
    INVERT: ClassVar[Layer.BlendMode] = ...
    LIGHTEN: ClassVar[Layer.BlendMode] = ...
    LUMINANCE: ClassVar[Layer.BlendMode] = ...
    LUMINANCE_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
    MIX: ClassVar[Layer.BlendMode] = ...
    MIX_NORMAL_MAPS: ClassVar[Layer.BlendMode] = ...
    MULTIPLY: ClassVar[Layer.BlendMode] = ...
    NUDGE_FLOW_VECTORS: ClassVar[Layer.BlendMode] = ...
    NUDGE_NORMAL_VECTORS: ClassVar[Layer.BlendMode] = ...
    OVERLAY: ClassVar[Layer.BlendMode] = ...
    PAINT_FLOW_VECTORS: ClassVar[Layer.BlendMode] = ...
    PAINT_NORMAL_VECTORS: ClassVar[Layer.BlendMode] = ...
    PIN_LIGHT: ClassVar[Layer.BlendMode] = ...
    RED_BLEND: ClassVar[Layer.AdvancedBlendComponent] = ...
    REORIENTED_NORMAL_MAPPING: ClassVar[Layer.BlendMode] = ...
    REVEAL_ALL: ClassVar[Layer.MaskType] = ...
    SATURATION: ClassVar[Layer.BlendMode] = ...
    SCALE_VECTORS: ClassVar[Layer.BlendMode] = ...
    SCREEN: ClassVar[Layer.BlendMode] = ...
    SOFT_LIGHT: ClassVar[Layer.BlendMode] = ...
    SPONGE_DESATURATE: ClassVar[Layer.BlendMode] = ...
    SWIZZLE_DST_ALPHA: ClassVar[Layer.SwizzleDestination] = ...
    SWIZZLE_DST_BLUE: ClassVar[Layer.SwizzleDestination] = ...
    SWIZZLE_DST_GREEN: ClassVar[Layer.SwizzleDestination] = ...
    SWIZZLE_DST_RED: ClassVar[Layer.SwizzleDestination] = ...
    SWIZZLE_SRC_ALPHA: ClassVar[Layer.SwizzleSource] = ...
    SWIZZLE_SRC_BLUE: ClassVar[Layer.SwizzleSource] = ...
    SWIZZLE_SRC_GREEN: ClassVar[Layer.SwizzleSource] = ...
    SWIZZLE_SRC_ONE: ClassVar[Layer.SwizzleSource] = ...
    SWIZZLE_SRC_RED: ClassVar[Layer.SwizzleSource] = ...
    SWIZZLE_SRC_ZERO: ClassVar[Layer.SwizzleSource] = ...
    VIVID_LIGHT: ClassVar[Layer.BlendMode] = ...
    blendAmountChanged: ClassVar[PySide2.QtCore.Signal] = ...
    blendComponentChanged: ClassVar[PySide2.QtCore.Signal] = ...
    blendModeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    blendTypeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    cacheStateChanged: ClassVar[PySide2.QtCore.Signal] = ...
    colorTagChanged: ClassVar[PySide2.QtCore.Signal] = ...
    convertedToPaint: ClassVar[PySide2.QtCore.Signal] = ...
    lockedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    maskCreated: ClassVar[PySide2.QtCore.Signal] = ...
    maskRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    maskStackCreated: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    selectedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def activeCacheUpToHereParents(self) -> typing.List[Layer]: ...
    @classmethod
    def advancedBlendComponentName(cls, Value: AdvancedBlendComponent) -> str: ...
    def advancedBlendComponentStr(self) -> str: ...
    def blendAmount(self) -> float: ...
    def blendAmountEnabled(self) -> bool: ...
    def blendMode(self) -> BlendMode: ...
    @classmethod
    def blendModeName(cls, BlendModeValue: BlendMode) -> str: ...
    def blendModePath(self) -> str: ...
    def blendModeStr(self) -> str: ...
    def blendType(self) -> BlendType: ...
    @classmethod
    def blendTypeName(cls, BlendTypeValue: BlendType) -> str: ...
    def blendTypeStr(self) -> str: ...
    def cacheLayer(self): ...
    def cacheUpToHere(self): ...
    def cacheUpToHereParents(self) -> typing.List[Layer]: ...
    def close(self): ...
    def colorTag(self) -> str: ...
    @classmethod
    def colorTagNames(cls): ...
    def getAdvancedBlendComponent(self) -> AdvancedBlendComponent: ...
    def getLayerBelowBlendLut(self) -> variant: ...
    def getThisLayerBlendLut(self) -> variant: ...
    def groupStack(self) -> LayerStack: ...
    def hasCacheUpToHere(self) -> bool: ...
    def hasLayerCache(self) -> bool: ...
    def hasMask(self) -> bool: ...
    def hasMaskCustomProcedural(self) -> bool: ...
    def hasMaskStack(self) -> bool: ...
    def hash(self, UVIndex: typing.SupportsInt = ...) -> str: ...
    def imageHash(self, UVIndex: typing.SupportsInt = ...) -> str: ...
    def isAdjustableLayer(self) -> bool: ...
    def isAdjustmentLayer(self) -> bool: ...
    def isBakePointLayer(self) -> bool: ...
    def isCachedUpToHere(self) -> bool: ...
    def isChannelLayer(self) -> bool: ...
    def isChildOfActiveCacheUpToHere(self) -> bool: ...
    def isChildOfCacheUpToHere(self) -> bool: ...
    def isCustomProceduralLayer(self) -> bool: ...
    def isGraphLayer(self) -> bool: ...
    def isGroupLayer(self) -> bool: ...
    def isLayerCached(self) -> bool: ...
    def isLocked(self) -> bool: ...
    def isMaskEnabled(self) -> bool: ...
    def isModifiable(self) -> bool: ...
    def isMultiChannelGroupLayer(self) -> bool: ...
    def isMultiChannelMaterialLayer(self) -> bool: ...
    def isPaintableLayer(self) -> bool: ...
    def isProceduralLayer(self) -> bool: ...
    def isSelected(self) -> bool: ...
    def isShaderLayer(self) -> bool: ...
    def isShared(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def layerNode(self) -> Node: ...
    def makeCurrent(self): ...
    def makeMask(self, Mask: MaskType = ..., Group: SelectionGroup = ...) -> ImageSet: ...
    def makeMaskCustomProcedural(self, FileName: str): ...
    def makeMaskStack(self): ...
    def maskCustomProceduralNode(self) -> CustomProceduralNode: ...
    def maskImageSet(self) -> ImageSet: ...
    def maskStack(self) -> LayerStack: ...
    def name(self) -> str: ...
    def parents(self) -> typing.List[variant]: ...
    def removeMask(self): ...
    def setAdvancedBlendComponent(self, Component: AdvancedBlendComponent): ...
    def setBlendAmount(self, BlendAmount: float): ...
    def setBlendAmountEnabled(self, Enabled: bool): ...
    def setBlendMode(self, BlendModeValue: variant): ...
    def setBlendType(self, Type: BlendType): ...
    def setCachedUpToHere(self, Cache: bool): ...
    def setColorTag(self, ColorTag: str): ...
    def setLayerBelowBlendLut(self, NewLut: LookUpTable): ...
    def setLayerCached(self, Cache: bool): ...
    def setLocked(self, Locked: bool): ...
    def setMaskEnabled(self, Enabled: bool): ...
    def setMaskImageSet(self): ...
    def setMaskStack(self): ...
    def setName(self, NewName: str): ...
    def setSelected(self, Selected: bool): ...
    def setSwizzle(self, Dst: SwizzleDestination, Src: SwizzleSource): ...
    def setThisLayerBlendLut(self, NewLut: LookUpTable): ...
    def setVisibility(self, Visible: bool): ...
    def siblingSharedLayerList(self) -> typing.List[Layer]: ...
    def swizzle(self): ...
    def uncacheLayer(self): ...
    def uncacheUpToHere(self): ...
    def __bool__(self) -> bool: ...

class LayerStack(Metadata):
    class ClearSelectionFlag:
        CLEAR_ADJUSTMENT_STACKS: ClassVar[LayerStack.ClearSelectionFlag] = ...
        CLEAR_GROUPS: ClassVar[LayerStack.ClearSelectionFlag] = ...
        CLEAR_MASK_STACKS: ClassVar[LayerStack.ClearSelectionFlag] = ...
        DEFAULT_CLEAR_SELECTION_FLAGS: ClassVar[LayerStack.ClearSelectionFlag] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class LayerCreateFlag:
        CLEAR_CURRENT_LAYER_SELECTION: ClassVar[LayerStack.LayerCreateFlag] = ...
        DEFAULT_LAYER_CREATE_FLAGS: ClassVar[LayerStack.LayerCreateFlag] = ...
        INSERT_NEW_LAYER_ABOVE_SELECTION: ClassVar[LayerStack.LayerCreateFlag] = ...
        INSERT_NEW_LAYER_BELOW_REF_LAYER: ClassVar[LayerStack.LayerCreateFlag] = ...
        MAKE_NEW_LAYER_CURRENT: ClassVar[LayerStack.LayerCreateFlag] = ...
        SELECT_NEW_LAYERS: ClassVar[LayerStack.LayerCreateFlag] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class LayerImportOption:
        CREATE_NEW_LAYERS: ClassVar[LayerStack.LayerImportOption] = ...
        OPTION_NOT_SPECIFIED: ClassVar[LayerStack.LayerImportOption] = ...
        SKIP_LAYERS: ClassVar[LayerStack.LayerImportOption] = ...
        UPDATE_LAYERS: ClassVar[LayerStack.LayerImportOption] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    CLEAR_ADJUSTMENT_STACKS: ClassVar[LayerStack.ClearSelectionFlag] = ...
    CLEAR_CURRENT_LAYER_SELECTION: ClassVar[LayerStack.LayerCreateFlag] = ...
    CLEAR_GROUPS: ClassVar[LayerStack.ClearSelectionFlag] = ...
    CLEAR_MASK_STACKS: ClassVar[LayerStack.ClearSelectionFlag] = ...
    CREATE_NEW_LAYERS: ClassVar[LayerStack.LayerImportOption] = ...
    DEFAULT_CLEAR_SELECTION_FLAGS: ClassVar[LayerStack.ClearSelectionFlag] = ...
    DEFAULT_LAYER_CREATE_FLAGS: ClassVar[LayerStack.LayerCreateFlag] = ...
    INSERT_NEW_LAYER_ABOVE_SELECTION: ClassVar[LayerStack.LayerCreateFlag] = ...
    INSERT_NEW_LAYER_BELOW_REF_LAYER: ClassVar[LayerStack.LayerCreateFlag] = ...
    MAKE_NEW_LAYER_CURRENT: ClassVar[LayerStack.LayerCreateFlag] = ...
    OPTION_NOT_SPECIFIED: ClassVar[LayerStack.LayerImportOption] = ...
    SELECT_NEW_LAYERS: ClassVar[LayerStack.LayerCreateFlag] = ...
    SKIP_LAYERS: ClassVar[LayerStack.LayerImportOption] = ...
    UPDATE_LAYERS: ClassVar[LayerStack.LayerImportOption] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @classmethod
    def adjustmentLayerTypeList(cls, *args, **kwargs): ...
    def clearSelection(self, Flags: typing.SupportsInt = ...): ...
    def createAdjustmentLayer(self, LayerName: str, PrimaryAdjustmentKey: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> AdjustmentLayer: ...
    def createBakePointLayer(self, LayerName: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> BakePointLayer: ...
    def createChannelLayer(self, LayerName: str, TargetChannel: Channel, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> ChannelLayer: ...
    def createCustomProceduralLayer(self, LayerName: str, FilePath: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> CustomProceduralLayer: ...
    def createGraphLayer(self, LayerName: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> GraphLayer: ...
    def createGroupLayer(self, LayerName: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> GroupLayer: ...
    def createMaterialLayer(self, LayerName: str, FilePath: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> MultiChannelMaterialLayer: ...
    def createMultiChannelGroupLayer(self, LayerName: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> MultiChannelGroupLayer: ...
    def createPaintableLayer(self, LayerName: str, RefLayer: Layer = ..., FillColor: Color = ..., Flags: typing.SupportsInt = ...) -> PaintableLayer: ...
    def createProceduralLayer(self, LayerName: str, ProceduralKey: str, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> ProceduralLayer: ...
    def createShaderLayer(self, LayerName: str, TargetShader: Shader, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> ShaderLayer: ...
    def duplicateLayers(self, LayersToDuplicate: typing.List[Layer] = ..., RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> typing.List[Layer]: ...
    def exportImages(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., UVIndexList: typing.List[int] = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def exportImagesFlattened(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., UVIndexList: typing.List[int] = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def exportSelectedPatches(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def exportSelectedPatchesFlattened(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def findLayer(self): ...
    def groupLayers(self, LayersToGroup: typing.List[Layer] = ..., RefLayer: Layer = ..., LayerName: str = ..., Flags: typing.SupportsInt = ...) -> Layer: ...
    def hash(self, UVIndex: typing.SupportsInt = ...) -> str: ...
    def imageHash(self, UVIndex: typing.SupportsInt = ...) -> str: ...
    def importImages(self, PathAndTemplate: str, ScaleOption: ImageSet.ScaleChoice = ..., MatchingLayersOption: LayerImportOption = ..., MismatchingLayersOption: LayerImportOption = ..., UVIndexList: typing.List[int] = ..., RemoveAlpha: bool = ..., SourceColorConfig: ColorspaceConfig = ...): ...
    def layer(self, LayerName: str) -> Layer: ...
    def layerList(self) -> typing.List[Layer]: ...
    def mergeLayers(self, LayersToMerge: typing.List[Layer] = ..., RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> Layer: ...
    def moveLayer(self, LayerToMove: Layer, RefLayer: Layer = ...): ...
    def moveLayerBelow(self, LayerToMove: Layer, RefLayer: Layer = ...): ...
    def name(self) -> str: ...
    @classmethod
    def proceduralLayerTypeList(cls, *args, **kwargs): ...
    def removeLayers(self, LayersToRemove: typing.List[Layer] = ...): ...
    def shareLayer(self, LayerToShare: Layer, RefLayer: Layer = ..., Flags: typing.SupportsInt = ...) -> Layer: ...
    def ungroupLayers(self, GroupLayersToUngroup: typing.List[Layer] = ...): ...
    def __bool__(self) -> bool: ...

class Light(Metadata):
    class FixedTo:
        CAMERA: ClassVar[Light.FixedTo] = ...
        SCENE: ClassVar[Light.FixedTo] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    CAMERA: ClassVar[Light.FixedTo] = ...
    SCENE: ClassVar[Light.FixedTo] = ...
    onChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def isEnvironmentLight(self) -> bool: ...
    def isOn(self) -> bool: ...
    def isPointLight(self) -> bool: ...
    def name(self) -> str: ...
    def setOn(self, OnOrOff: bool): ...
    def __bool__(self) -> bool: ...

class LightManager(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def current(self) -> Light: ...
    def list(self) -> typing.List[Light]: ...
    def selection(self) -> typing.List[Light]: ...
    def __bool__(self) -> bool: ...

class LineEdit(WidgetBase):
    lostFocus: ClassVar[PySide2.QtCore.Signal] = ...
    movedMouse: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addFloatValidator(self, Minimum: float, Maximum: float, Precision: typing.SupportsInt): ...
    def home(self, Mark: bool): ...
    def isReadOnly(self): ...
    def setRange(self, Range: typing.SupportsInt): ...
    def setReadOnly(self): ...
    def setText(self): ...
    def setValue(self, Value: typing.SupportsInt): ...
    def text(self): ...
    def __bool__(self) -> bool: ...

class LocatorEntity(Lockable):
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addLocator(self) -> LocatorEntity: ...
    def hideLocator(self): ...
    def isSelected(self) -> bool: ...
    def name(self) -> str: ...
    def setName(self, NewName: str): ...
    def setSelected(self, Selected: bool): ...
    def setTransform(self, pTransform: Matrix, Frame: typing.SupportsInt = ...): ...
    def showLocator(self): ...
    def transform(self, Frame: typing.SupportsInt) -> Matrix: ...
    def translation(self, Frame: typing.SupportsInt = ...) -> VectorN: ...
    def __bool__(self) -> bool: ...

class LocatorList(API):
    class LocatorListType:
        LOCATOR_LIST_TYPE_MATRIX: ClassVar[LocatorList.LocatorListType] = ...
        LOCATOR_LIST_TYPE_PROJECTOR: ClassVar[LocatorList.LocatorListType] = ...
        LOCATOR_LIST_TYPE_ROTATION: ClassVar[LocatorList.LocatorListType] = ...
        LOCATOR_LIST_TYPE_SCALE: ClassVar[LocatorList.LocatorListType] = ...
        LOCATOR_LIST_TYPE_TRANSLATION: ClassVar[LocatorList.LocatorListType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    LOCATOR_LIST_TYPE_MATRIX: ClassVar[LocatorList.LocatorListType] = ...
    LOCATOR_LIST_TYPE_PROJECTOR: ClassVar[LocatorList.LocatorListType] = ...
    LOCATOR_LIST_TYPE_ROTATION: ClassVar[LocatorList.LocatorListType] = ...
    LOCATOR_LIST_TYPE_SCALE: ClassVar[LocatorList.LocatorListType] = ...
    LOCATOR_LIST_TYPE_TRANSLATION: ClassVar[LocatorList.LocatorListType] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def currentLocator(self) -> LocatorEntity: ...
    def internalLocatorList(self, *args, **kwargs): ...
    def locatorType(self) -> LocatorListType: ...
    def locatorUUID(self, *args, **kwargs): ...
    def rotationVector(self) -> VectorN: ...
    def scaleVector(self) -> VectorN: ...
    def setCurrentLocator(self, Locator: LocatorEntity): ...
    def setCurrentProjector(self, ProjectorEntity: Projector): ...
    def setLocatorType(self, Type: LocatorListType): ...
    def setRotationVector(self, Vector: VectorN): ...
    def setScaleVector(self, Vector: VectorN): ...
    def setShowUI(self, Value: bool): ...
    def setTranslationVector(self, Vector: VectorN): ...
    def setWorldSpace(self, Value: bool): ...
    def showUI(self) -> bool: ...
    def translationVector(self) -> VectorN: ...
    def worldSpace(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self): ...

class Lockable(Metadata):
    lockedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    visibilityChanged: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def hide(self): ...
    def isLocked(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def lock(self): ...
    def setLocked(self): ...
    def setVisibility(self, Visible: bool): ...
    def show(self): ...
    def unlock(self): ...
    def __bool__(self) -> bool: ...

class LookUpTable(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def controlPoints(self) -> typing.List[VectorN]: ...
    def controlPointsAsString(self) -> str: ...
    def invert(self): ...
    def isClamped(self) -> bool: ...
    def setClamped(self, Clamped: bool): ...
    def setControlPoints(self, ControlPoints: typing.List[VectorN]): ...
    def setControlPointsFromString(self, ControlPointsString: str): ...
    def setLinear(self, ValueAtZero: float, ValueAtOne: float): ...
    def __bool__(self) -> bool: ...

class MaterialNode(GroupNode):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addMaterialTag(self, Tag: str): ...
    def addMaterialTags(self, Tags: typing.List[str]): ...
    def exportMaterial(self, FileName: str, ThumbnailFileName: str = ...): ...
    def geoChannels(self) -> typing.List[str]: ...
    def materialTags(self) -> typing.List[str]: ...
    def missingGeoChannels(self) -> typing.List[str]: ...
    @classmethod
    def readMetadataFromMaterialFile(cls, MaterialFilePath: str) -> PySide2.QtWidgets.QJsonDocument: ...
    @classmethod
    def readSystemMetadataFromMaterialFile(cls, MaterialFilePath: str) -> PySide2.QtWidgets.QJsonDocument: ...
    @classmethod
    def readTagsFromMaterialFile(cls, MaterialFilePath: str) -> typing.List[str]: ...
    @classmethod
    def readThumbnailFromMaterialFile(cls, MaterialFilePath: str) -> PySide2.QtWidgets.QImage: ...
    def removeMaterialTag(self, Tag: str): ...
    def removeMaterialTags(self, Tags: typing.List[str]): ...
    def setMaterialTags(self, MaterialTags: typing.List[str]): ...
    def shaderModel(self) -> ShaderModel: ...
    @classmethod
    def writeMetadataToMaterialFile(cls, MetadataMap: PySide2.QtWidgets.QJsonDocument, MaterialFilePath: str) -> bool: ...
    @classmethod
    def writeTagsToMaterialFile(cls, Tags: typing.List[str], MaterialFilePath: str) -> bool: ...
    @classmethod
    def writeThumbnailToMaterialFile(cls, Thumbnail: PySide2.QtWidgets.QImage, MaterialFilePath: str): ...
    def __bool__(self) -> bool: ...

class Matrix(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def asList(self) -> tuple[float, ...]: ...
    def length(self) -> int: ...
    def __bool__(self) -> bool: ...

class MenuManager(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def actions(self, rSet: str, rRoot: str, rSubMenu: str = ...) -> typing.List[Action]: ...
    def addAction(self, pAction: Action, rPath: str, rAddBefore: str = ...): ...
    def addSeparator(self, Path: str, rAddBefore: str = ...): ...
    def itemNames(self, rSet: str, rRoot: str, rSubMenu: str = ...) -> typing.List[str]: ...
    def removeAction(self, pAction: Action, rFullPath: str): ...
    def roots(self, rSet: str) -> typing.List[str]: ...
    def sets(self) -> typing.List[str]: ...
    def submenus(self, rSet: str, rRoot: str, rSubMenu: str = ...) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class MessageBox(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def critical(cls, *args, **kwargs): ...
    @classmethod
    def information(cls, *args, **kwargs): ...
    @classmethod
    def question(cls, *args, **kwargs): ...
    @classmethod
    def warning(cls, *args, **kwargs): ...
    def __bool__(self) -> bool: ...

class Metadata(API):
    class MetadataFlag:
        METADATA_EDITABLE: ClassVar[Metadata.MetadataFlag] = ...
        METADATA_REMOVABLE: ClassVar[Metadata.MetadataFlag] = ...
        METADATA_REMOVEABLE: ClassVar[Metadata.MetadataFlag] = ...
        METADATA_SAVED: ClassVar[Metadata.MetadataFlag] = ...
        METADATA_UNDOABLE: ClassVar[Metadata.MetadataFlag] = ...
        METADATA_VISIBLE: ClassVar[Metadata.MetadataFlag] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __rand__(self, other): ...
        def __ror__(self, other): ...
        def __rxor__(self, other): ...
        def __xor__(self, other): ...

    class MetadataFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __int__(self) -> int: ...
        def __invert__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __rand__(self, other): ...
        def __ror__(self, other): ...
        def __rxor__(self, other): ...
        def __xor__(self, other): ...

    class MetadataGroupHint:
        METADATA_GROUP_HINT_DISPLAY: ClassVar[Metadata.MetadataGroupHint] = ...
        METADATA_GROUP_HINT_SORTABLE: ClassVar[Metadata.MetadataGroupHint] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __rand__(self, other): ...
        def __ror__(self, other): ...
        def __rxor__(self, other): ...
        def __xor__(self, other): ...

    class MetadataGroupHints:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __int__(self) -> int: ...
        def __invert__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __rand__(self, other): ...
        def __ror__(self, other): ...
        def __rxor__(self, other): ...
        def __xor__(self, other): ...

    class MetadataTypeFlag:
        METADATA_TYPE_FLAG_COLOR_SCALAR: ClassVar[Metadata.MetadataTypeFlag] = ...
        METADATA_TYPE_FLAG_FLOAT_LOGARITHMIC: ClassVar[Metadata.MetadataTypeFlag] = ...
        METADATA_TYPE_FLAG_STRING_MULTILINE: ClassVar[Metadata.MetadataTypeFlag] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __rand__(self, other): ...
        def __ror__(self, other): ...
        def __rxor__(self, other): ...
        def __xor__(self, other): ...

    class MetadataTypeFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __int__(self) -> int: ...
        def __invert__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __rand__(self, other): ...
        def __ror__(self, other): ...
        def __rxor__(self, other): ...
        def __xor__(self, other): ...
    METADATA_EDITABLE: ClassVar[Metadata.MetadataFlag] = ...
    METADATA_GROUP_HINT_DISPLAY: ClassVar[Metadata.MetadataGroupHint] = ...
    METADATA_GROUP_HINT_SORTABLE: ClassVar[Metadata.MetadataGroupHint] = ...
    METADATA_REMOVABLE: ClassVar[Metadata.MetadataFlag] = ...
    METADATA_REMOVEABLE: ClassVar[Metadata.MetadataFlag] = ...
    METADATA_SAVED: ClassVar[Metadata.MetadataFlag] = ...
    METADATA_TYPE_FLAG_COLOR_SCALAR: ClassVar[Metadata.MetadataTypeFlag] = ...
    METADATA_TYPE_FLAG_FLOAT_LOGARITHMIC: ClassVar[Metadata.MetadataTypeFlag] = ...
    METADATA_TYPE_FLAG_STRING_MULTILINE: ClassVar[Metadata.MetadataTypeFlag] = ...
    METADATA_UNDOABLE: ClassVar[Metadata.MetadataFlag] = ...
    METADATA_VISIBLE: ClassVar[Metadata.MetadataFlag] = ...
    metadataCreated: ClassVar[PySide2.QtCore.Signal] = ...
    metadataEnabledChanged: ClassVar[PySide2.QtCore.Signal] = ...
    metadataRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    metadataValueChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def hasMetadata(self, Name: str) -> bool: ...
    @classmethod
    def isSupportedMetadataType(cls, Value: variant) -> bool: ...
    def metadata(self, Name: str) -> variant: ...
    def metadataAsImage(self, Name: str) -> Image: ...
    def metadataDefault(self, Name: str) -> variant: ...
    def metadataDescription(self, Name: str) -> str: ...
    def metadataDisplayName(self, Name: str) -> str: ...
    def metadataFlags(self, Name: str) -> MetadataFlags: ...
    def metadataIsEnabled(self, Name: str) -> bool: ...
    def metadataItemList(self, Name: str) -> typing.List[str]: ...
    def metadataMax(self, Name: str) -> variant: ...
    def metadataMin(self, Name: str) -> variant: ...
    def metadataNames(self) -> typing.List[str]: ...
    def metadataStep(self, Name: str) -> variant: ...
    def metadataTypeFlags(self, Name: str) -> MetadataTypeFlags: ...
    def removeMetadata(self, Name: str): ...
    def setMetadata(self, Name: str, Value: variant): ...
    def setMetadataDefault(self, Name: str, Default: variant): ...
    def setMetadataDescription(self, Name: str, Description: str): ...
    def setMetadataDisplayName(self, Name: str, DisplayName: str): ...
    def setMetadataEnabled(self, Name: str, Enabled: bool): ...
    def setMetadataFlags(self, Name: str, Flags: MetadataFlags): ...
    def setMetadataGroupHints(self, Name: str, Hints: MetadataGroupHints): ...
    def setMetadataItemList(self, Name: str, ItemList: typing.List[str]): ...
    def setMetadataRange(self, Name: str, Min: variant, Max: variant): ...
    def setMetadataStep(self, Name: str, Step: variant): ...
    def setMetadataTypeFlags(self, Name: str, Flags: MetadataTypeFlags): ...
    def uuid(self) -> str: ...
    def __bool__(self) -> bool: ...

class Miscellaneous(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def createIconFromPath(self, Path: str) -> PySide2.QtWidgets.QIcon: ...
    def getExistingDirectory(self, Parent: PySide2.QtWidgets.QWidget = ..., Caption: str = ..., Dir: str = ...) -> str: ...
    def getMkdirCommand(self) -> str: ...
    def getOpenFileName(self, Parent: PySide2.QtWidgets.QWidget = ..., Caption: str = ..., Dir: str = ..., Filter: str = ..., SelectedFilter: str = ..., Options: typing.SupportsInt = ...) -> str: ...
    def getSaveFileName(self, Parent: PySide2.QtWidgets.QWidget = ..., Caption: str = ..., Dir: str = ..., Filter: str = ..., SelectedFilter: str = ..., Options: typing.SupportsInt = ..., SaveFileName: str = ...) -> str: ...
    def registerRegExpChannelNameExtractor(self, RegExp: str): ...
    def setMkdirCommand(self, Command: str): ...
    def __bool__(self) -> bool: ...

class MultiChannelBakePointNode(GroupNode):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def bakeActive(self): ...
    def bakePointNode(self, ShaderModelInputForBakePoint: ShaderModelInput) -> BakePointNode: ...
    def bakeStreams(self, Streams: typing.List[ShaderModelInput]): ...
    def deleteBake(self): ...
    def setLimitBake(self, LimitBake: bool): ...
    def setLimitBakeRange(self, LimitBakeRange: UvIndexRangeList): ...
    def shaderModel(self) -> ShaderModel: ...
    def streamBakePointNodes(self) -> variant: ...
    def __bool__(self) -> bool: ...

class MultiChannelContainer(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def isVisible(self) -> bool: ...
    def setVisibility(self, Visible: bool): ...
    def shaderModel(self) -> ShaderModel: ...
    def streamList(self) -> typing.List[MultiChannelLayer]: ...
    def __bool__(self) -> bool: ...

class MultiChannelGroup(MultiChannelContainer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def flattenLayerGroup(self) -> typing.List[Layer]: ...
    def __bool__(self) -> bool: ...

class MultiChannelGroupLayer(MultiChannelLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def container(self) -> MultiChannelGroup: ...
    def layerStack(self) -> LayerStack: ...
    def __bool__(self) -> bool: ...

class MultiChannelLayer(Layer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def activeCacheUpToHereParents(self) -> typing.List[Layer]: ...
    def blendAmount(self) -> float: ...
    def blendAmountEnabled(self) -> bool: ...
    def blendMode(self) -> BlendMode: ...
    def blendModePath(self) -> str: ...
    def blendModeStr(self) -> str: ...
    def blendType(self) -> BlendType: ...
    def cacheUpToHereParents(self) -> typing.List[Layer]: ...
    def getAdvancedBlendComponent(self) -> AdvancedBlendComponent: ...
    def getLayerBelowBlendLut(self) -> variant: ...
    def getThisLayerBlendLut(self) -> variant: ...
    def groupStack(self) -> LayerStack: ...
    def isChildOfActiveCacheUpToHere(self) -> bool: ...
    def isChildOfCacheUpToHere(self) -> bool: ...
    def isMultiChannelGroupLayer(self) -> bool: ...
    def isMultiChannelMaterialLayer(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def parents(self) -> typing.List[variant]: ...
    def setAdvancedBlendComponent(self, Component: AdvancedBlendComponent): ...
    def setBlendAmount(self, BlendAmount: float): ...
    def setBlendAmountEnabled(self, Enabled: bool): ...
    def setBlendMode(self, BlendModeValue: variant): ...
    def setBlendType(self, Type: BlendType): ...
    def setLayerBelowBlendLut(self, NewLut: LookUpTable): ...
    def setSwizzle(self, Dst: SwizzleDestination, Src: SwizzleSource): ...
    def setThisLayerBlendLut(self, NewLut: LookUpTable): ...
    def setVisibility(self, Visible: bool): ...
    def streamName(self) -> str: ...
    def swizzle(self): ...
    def __bool__(self) -> bool: ...

class MultiChannelMaterial(MultiChannelContainer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def convertToPaintable(self, SelectedOnly: bool = ...): ...
    def materialNode(self) -> MaterialNode: ...
    def __bool__(self) -> bool: ...

class MultiChannelMaterialLayer(MultiChannelLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def container(self) -> MultiChannelMaterial: ...
    def __bool__(self) -> bool: ...

class Node(Metadata):
    class PortListMode:
        PORT_LIST_COLLAPSED: ClassVar[Node.PortListMode] = ...
        PORT_LIST_EXPANDED: ClassVar[Node.PortListMode] = ...
        PORT_LIST_GROUPED: ClassVar[Node.PortListMode] = ...
        PORT_LIST_ONLY_CONNECTED: ClassVar[Node.PortListMode] = ...
        PORT_LIST_T2B: ClassVar[Node.PortListMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    PORT_LIST_COLLAPSED: ClassVar[Node.PortListMode] = ...
    PORT_LIST_EXPANDED: ClassVar[Node.PortListMode] = ...
    PORT_LIST_GROUPED: ClassVar[Node.PortListMode] = ...
    PORT_LIST_ONLY_CONNECTED: ClassVar[Node.PortListMode] = ...
    PORT_LIST_T2B: ClassVar[Node.PortListMode] = ...
    hasChanged: ClassVar[PySide2.QtCore.Signal] = ...
    inputNodeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addNodeContext(self, Name: str, Context: NodeContext): ...
    def addTag(self, Tag: str, ForceAdd: bool = ...): ...
    def attachViewer(self, InputNumber: typing.SupportsInt = ...): ...
    def bake(self, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, FileSpace: Image.FileSpace = ..., ColorConfig: ColorspaceConfig = ..., OutputPortName: str = ...): ...
    def bypassInput(self, OutputPoint: str = ...) -> int: ...
    def connectSignals(self, *args, **kwargs): ...
    def exportToGeoChannel(self, DestGeoChannel: GeoChannel, OutputPortName: str = ...) -> bool: ...
    def focusInNodeGraph(self): ...
    def getNodeGraphViewContextMeta(self, *args, **kwargs): ...
    def hasTag(self): ...
    def hash(self, UVIndex: typing.SupportsInt = ..., IgnoreChildren: bool = ...) -> str: ...
    def inputConnection(self, PortName: str) -> typing.List[variant]: ...
    def inputNode(self, PortName: str) -> Node: ...
    def inputPortCount(self) -> int: ...
    def inputPortName(self): ...
    def inputPortNames(self) -> typing.List[str]: ...
    def isBackdropNode(self) -> bool: ...
    def isBakePointNode(self) -> bool: ...
    def isEnabled(self) -> bool: ...
    def isGeoChannelNode(self) -> bool: ...
    def isGroupNode(self) -> bool: ...
    def isPaintNode(self) -> bool: ...
    def isSelected(self) -> bool: ...
    def name(self) -> str: ...
    def nodeContext(self, Name: str) -> NodeContext: ...
    def nodeContextNames(self) -> typing.List[str]: ...
    def nodeGraphPosition(self) -> PySide2.QtWidgets.QPointF: ...
    def nodeGraphSize(self) -> PySide2.QtWidgets.QSizeF: ...
    def nodeInformation(self) -> str: ...
    def nodePath(self): ...
    def outputNodes(self, PortName: str = ...) -> typing.List[variant]: ...
    def outputPortCount(self) -> int: ...
    def outputPortName(self): ...
    def outputPortNames(self) -> typing.List[str]: ...
    def parentNodeGraph(self) -> NodeGraph: ...
    def portListMode(self): ...
    def printVersionHashSource(self): ...
    def removeNodeContext(self, Name: str): ...
    def removeTag(self, Tag: str, ForceRemove: bool = ...): ...
    def setBypassInput(self, BypassInput: typing.SupportsInt): ...
    def setEnabled(self, Enabled: bool): ...
    def setInputNode(self, PortName: str, NodeToConnect: Node, OutputPortName: str = ...): ...
    def setMetadata(self, Name: str, Value: variant): ...
    def setName(self, NewName: str): ...
    def setNodeGraphPosition(self, Position: PySide2.QtWidgets.QPointF): ...
    def setPortListMode(self, Mode: PortListMode): ...
    def setSelected(self, Selected: bool): ...
    def setTypeID(self, TypeID: str): ...
    def tagList(self) -> typing.List[str]: ...
    def typeID(self) -> str: ...
    def __bool__(self) -> bool: ...

class NodeContext(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def metadataSupported(self, MetadataName: str): ...
    def setMetadataSupported(self, MetadataName: str, Supported: bool): ...
    def __bool__(self) -> bool: ...

class NodeGraph(Metadata):
    nodeSelectionChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addNode(self, NodeToAdd: Node): ...
    def autoLayoutNodes(self, Roots: typing.List[Node]): ...
    def bakeEmptyAndUpdateOutOfDateBakePoints(self): ...
    def bakeSelectedBakePoints(self): ...
    def createBakePointNode(self, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, FillColor: Color = ..., FileSpace: Image.FileSpace = ..., ColorConfig: ColorspaceConfig = ...): ...
    def createChannelNode(self, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, FileSpace: Image.FileSpace = ..., ColorConfig: ColorspaceConfig = ..., Name: str = ...) -> Node: ...
    def createMaterialTemplate(self, Model: ShaderModel, CreateWithDefaultColors: bool = ...): ...
    def createMultiChannelBakePointNode(self, Model: ShaderModel, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, StreamSettingsMap: variant = ...) -> GroupNode: ...
    def createMultiChannelBottomTransparencyNode(self, Model: ShaderModel): ...
    def createMultiChannelMergeNode(self, Model: ShaderModel): ...
    def createNode(self, Type: str): ...
    def createPaintNode(self, Width: typing.SupportsInt, Height: typing.SupportsInt, Depth: typing.SupportsInt, FillColor: Color = ..., FileSpace: Image.FileSpace = ..., ColorConfig: ColorspaceConfig = ...): ...
    def deleteNode(self, NodeToDelete: Node): ...
    def exportNodesAsArchive(self, DirPath: str, Nodes: typing.List[Node], NoDataBlockCopy: bool = ..., UVIndexList: typing.List[int] = ...) -> dict[str, str]: ...
    @classmethod
    def getAllUpstreamNodes(cls, DestNode: Node) -> typing.List[Node]: ...
    @classmethod
    def getUpstreamNodes(cls, DestNode: Node) -> typing.List[Node]: ...
    def groupNodes(self, Nodes: typing.List[Node]) -> GroupNode: ...
    def importCustomProcedural(self, FileName: str) -> Node: ...
    def importMaterial(self, FileName: str) -> Node: ...
    def importNodesFromArchive(self, DirPath: str, UuidsToLoad: typing.List[str], UvIndexMap: dict[int, typing.List[int]]) -> typing.List[Node]: ...
    def load(self, FilePath: str) -> typing.List[Node]: ...
    def nodeList(self, IncludeSystemNodes: bool = ...) -> typing.List[Node]: ...
    def nodesFromString(self, String: str) -> typing.List[Node]: ...
    def nodesToString(self, Nodes: typing.List[Node]) -> str: ...
    def nodesWithTag(self, Tag: str) -> typing.List[Node]: ...
    def parentGeoEntity(self) -> GeoEntity: ...
    def parentGroupNode(self) -> GroupNode: ...
    def removeNode(self, NodeToRemove: Node): ...
    def save(self, FilePath: str, Nodes: typing.List[Node]): ...
    def selectedNodeList(self, IncludeSystemNodes: bool = ...) -> typing.List[Node]: ...
    def setActiveViewerInput(self, InputNumber: typing.SupportsInt): ...
    def teleportBroadcastChannelNameList(self) -> typing.List[str]: ...
    def teleportNodeBroadcastingOnChannel(self): ...
    def teleportNodesListeningToChannel(self): ...
    @classmethod
    def topologicalSortTo(cls, DestNode: Node, ReverseOrder: bool = ...) -> typing.List[Node]: ...
    def typeList(self) -> typing.List[str]: ...
    def updateSelectedBakePoints(self): ...
    def viewerNode(self) -> Node: ...
    @classmethod
    def willConnectionBreakDAG(cls, SourceNode: Node, SourceNodeOutputPort: str, DestNode: Node, DestNodeInputPort: str) -> bool: ...
    def __bool__(self) -> bool: ...

class NodeGraphPalette(Palette):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def closeTab(self, Index: typing.SupportsInt): ...
    def currentTabIndex(self) -> int: ...
    def indexForNodeGraph(self, NodeGraphObject: NodeGraph) -> int: ...
    def nodeGraphView(self, TabIndex: typing.SupportsInt) -> NodeGraphView: ...
    def nodeGraphViewList(self) -> typing.List[NodeGraphView]: ...
    def setCurrentTabIndex(self, Index: typing.SupportsInt): ...
    def __bool__(self) -> bool: ...

class NodeGraphView(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def center(self) -> PySide2.QtWidgets.QPointF: ...
    def nodeGraph(self) -> NodeGraph: ...
    def posFromGlobalPos(self, GlobalPos: PySide2.QtWidgets.QPoint) -> PySide2.QtWidgets.QPointF: ...
    def setCenter(self, Center: PySide2.QtWidgets.QPointF): ...
    def setZoomLevel(self, ZoomLevel: float): ...
    def zoomLevel(self) -> float: ...
    def __bool__(self) -> bool: ...

class NodeManager(API):
    customProceduralNodeExported: ClassVar[PySide2.QtCore.Signal] = ...
    customProceduralNodeImported: ClassVar[PySide2.QtCore.Signal] = ...
    materialNodeExported: ClassVar[PySide2.QtCore.Signal] = ...
    materialNodeImported: ClassVar[PySide2.QtCore.Signal] = ...
    nodeCreated: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __bool__(self) -> bool: ...

class ObjectSelectionGroup(SelectionGroup):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def geoEntityList(self) -> typing.List[GeoEntity]: ...
    def __bool__(self) -> bool: ...

class OpenColorIO(API):
    class ColorPickerMode:
        COLOR_PICKER_COLOR_MANAGER: ClassVar[OpenColorIO.ColorPickerMode] = ...
        COLOR_PICKER_OCIO: ClassVar[OpenColorIO.ColorPickerMode] = ...
        COLOR_PICKER_RAW: ClassVar[OpenColorIO.ColorPickerMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    COLOR_PICKER_COLOR_MANAGER: ClassVar[OpenColorIO.ColorPickerMode] = ...
    COLOR_PICKER_OCIO: ClassVar[OpenColorIO.ColorPickerMode] = ...
    COLOR_PICKER_RAW: ClassVar[OpenColorIO.ColorPickerMode] = ...
    colorPickerModeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    lutSizeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    targetScalarChanged: ClassVar[PySide2.QtCore.Signal] = ...
    viewerScalarChanged: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def colorPickerMode(self) -> ColorPickerMode: ...
    def colorspace(self, Config: str, Index: typing.SupportsInt) -> str: ...
    def colorspaceCount(self, Config: str) -> int: ...
    def colorspacePrettyNames(self, Config: str) -> typing.List[str]: ...
    def configDescription(self, Config: str) -> str: ...
    def currentColorspaceConfig(self) -> ColorspaceConfig: ...
    def currentColorspaceDefaults(self) -> ColorspaceDefaults: ...
    def defaultConfig(self) -> str: ...
    def get3DLutValuesFromDisplayViewTransform(self, Config: str, Src: str, View: str, Display: str, LutSize: typing.SupportsInt) -> tuple[float, ...]: ...
    def get3DLutValuesFromFileTransform(self, Config: str, Input: str, Output: str, LutSize: typing.SupportsInt) -> tuple[float, ...]: ...
    def hasColorspace(self, Config: str, Name: str) -> bool: ...
    def hasRole(self, Config: str, Name: str) -> bool: ...
    def isConfigValid(self, Config: str) -> bool: ...
    def isShaderTransformAccurate(self, Config: str, InputColorspace: str, OutputColorspace: str, LutSize: typing.SupportsInt) -> bool: ...
    def isStandardConfig(self, Name: str) -> bool: ...
    def isTargetScalar(self) -> bool: ...
    def isTransformValid(self, Config: str, InputColorspace: str, OutputColorspace: str) -> bool: ...
    def isViewerScalar(self) -> bool: ...
    def lutSize(self) -> int: ...
    def parseColorspaceFromString(self, Config: str, Str: str) -> str: ...
    def registerConfigUiAllowlist(self, ConfigFilePath: str, Allowlist: typing.List[str]): ...
    def role(self, Config: str, Index: typing.SupportsInt) -> str: ...
    def roleCount(self, Config: str) -> int: ...
    def setColorPickerMode(self, Mode: ColorPickerMode): ...
    def setLutSize(self): ...
    def setShaderTransformAccuracy(self, Config: str, InputColorspace: str, OutputColorspace: str, MinimumLutSize: typing.SupportsInt): ...
    def setShaderTransformCode(self, Config: str, InputColorspace: str, OutputColorspace: str, Code: str): ...
    def shaderTransformUsesLut(self, Config: str, InputColorspace: str, OutputColorspace: str) -> bool: ...
    def standardConfigPath(self, Config: str) -> str: ...
    def standardConfigs(self) -> typing.List[str]: ...
    def toColorspace(self, Config: str, Role: str) -> str: ...
    def toPrettyName(self, Config: str, Name: str) -> str: ...
    def transformColor(self, Config: str, InputColorspace: str, OutputColorspace: str, InputColor: Color) -> Color: ...
    def transformImage(self, Config: str, InputColorspace: str, OutputColorspace: str, InputImage: Image) -> Image: ...
    def __bool__(self) -> bool: ...

class PaintBuffer(PropertySource):
    class BufferDepth:
        DEPTH_BYTE: ClassVar[PaintBuffer.BufferDepth] = ...
        DEPTH_FLOAT: ClassVar[PaintBuffer.BufferDepth] = ...
        DEPTH_HALF: ClassVar[PaintBuffer.BufferDepth] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class Mirroring:
        MIRROR_NONE: ClassVar[PaintBuffer.Mirroring] = ...
        MIRROR_X: ClassVar[PaintBuffer.Mirroring] = ...
        MIRROR_XY: ClassVar[PaintBuffer.Mirroring] = ...
        MIRROR_Y: ClassVar[PaintBuffer.Mirroring] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    DEPTH_BYTE: ClassVar[PaintBuffer.BufferDepth] = ...
    DEPTH_FLOAT: ClassVar[PaintBuffer.BufferDepth] = ...
    DEPTH_HALF: ClassVar[PaintBuffer.BufferDepth] = ...
    MIRROR_NONE: ClassVar[PaintBuffer.Mirroring] = ...
    MIRROR_X: ClassVar[PaintBuffer.Mirroring] = ...
    MIRROR_XY: ClassVar[PaintBuffer.Mirroring] = ...
    MIRROR_Y: ClassVar[PaintBuffer.Mirroring] = ...
    aboutToBake: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToClear: ClassVar[PySide2.QtCore.Signal] = ...
    baked: ClassVar[PySide2.QtCore.Signal] = ...
    cleared: ClassVar[PySide2.QtCore.Signal] = ...
    depthChanged: ClassVar[PySide2.QtCore.Signal] = ...
    resolutionChanged: ClassVar[PySide2.QtCore.Signal] = ...
    rotationChanged: ClassVar[PySide2.QtCore.Signal] = ...
    scaleChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    translationChanged: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bake(self) -> bool: ...
    def bakeAndClear(self) -> bool: ...
    def clampColors(self) -> bool: ...
    def clear(self): ...
    def compImage(self): ...
    def depth(self) -> BufferDepth: ...
    def getPaint(self) -> PySide2.QtWidgets.QImage: ...
    def isDirty(self) -> bool: ...
    def loadPaint(self, Paint: Image): ...
    def mirroring(self) -> Mirroring: ...
    def pickColor(self, x: typing.SupportsInt, y: typing.SupportsInt) -> Color: ...
    def resolution(self) -> PySide2.QtWidgets.QSize: ...
    def restoreContent(self): ...
    def rotation(self) -> float: ...
    def saveContent(self): ...
    def savePaint(self) -> Image: ...
    def scale(self) -> PySide2.QtWidgets.QSizeF: ...
    def setClampColors(self, ClampColors: bool): ...
    def setDepth(self, Depth: BufferDepth): ...
    def setMirroring(self, Mirror: Mirroring): ...
    def setPaint(self, PaintImage: PySide2.QtWidgets.QImage) -> bool: ...
    def setResolution(self): ...
    def setRotation(self, Angle: float): ...
    def setScale(self, Size: PySide2.QtWidgets.QSizeF): ...
    def setTranslation(self, Translation: PySide2.QtWidgets.QPointF): ...
    def supportedResolutions(self) -> typing.List[PySide2.QtWidgets.QSize]: ...
    def translation(self) -> PySide2.QtWidgets.QPointF: ...
    def __bool__(self) -> bool: ...

class PaintNode(Node):
    class ManagementType:
        MANAGED_BY_CHANNEL: ClassVar[PaintNode.ManagementType] = ...
        MANAGED_BY_SELF: ClassVar[PaintNode.ManagementType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    MANAGED_BY_CHANNEL: ClassVar[PaintNode.ManagementType] = ...
    MANAGED_BY_SELF: ClassVar[PaintNode.ManagementType] = ...
    bleedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    colorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    depthChanged: ClassVar[PySide2.QtCore.Signal] = ...
    fileSpaceChanged: ClassVar[PySide2.QtCore.Signal] = ...
    managementChanged: ClassVar[PySide2.QtCore.Signal] = ...
    sizeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bleed(self) -> bool: ...
    def colorspaceConfig(self) -> ColorspaceConfig: ...
    def connectSignals(self, *args, **kwargs): ...
    def depth(self): ...
    def fileSpace(self) -> Image.FileSpace: ...
    def fillColor(self) -> Color: ...
    def imageSet(self) -> ImageSet: ...
    def isPaintNode(self) -> bool: ...
    def management(self) -> ManagementType: ...
    def setBleed(self, Bleed: bool): ...
    def setColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setDepth(self, NewDepth: Image.Depth): ...
    def setFileSpace(self, FileSpace: Image.FileSpace): ...
    def setManagement(self, ManagedBy: ManagementType): ...
    def setSize(self, NewSize: ImageSet.Size): ...
    def size(self): ...
    def __bool__(self) -> bool: ...

class PaintableLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bleed(self) -> bool: ...
    def exportImages(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., UVIndexList: typing.List[int] = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def exportSelectedPatches(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def imageSet(self) -> ImageSet: ...
    def importImages(self, PathAndTemplate: str, ScaleOption: ImageSet.ScaleChoice = ..., UVIndexList: typing.List[int] = ..., RemoveAlpha: bool = ..., SourceColorConfig: ColorspaceConfig = ...): ...
    def setBleed(self, bleed: bool): ...
    def __bool__(self) -> bool: ...

class Palette(WidgetBase):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bringToFront(self): ...
    def fullName(self) -> str: ...
    def helpURL(self) -> str: ...
    def name(self) -> str: ...
    def setBodyWidget(self, pBody: PySide2.QtWidgets.QWidget): ...
    def setCSHKey(self, Key: str): ...
    def setFullName(self, rName: str): ...
    def setShortName(self, rName: str): ...
    def shortName(self) -> str: ...
    def showInFront(self): ...
    def __bool__(self) -> bool: ...

class PaletteManager(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def create(self, rName: str, pBodyWidget: PySide2.QtWidgets.QWidget): ...
    def createWithIcon(self, rName: str, rIconPath: str, pBodyWidget: PySide2.QtWidgets.QWidget = ...): ...
    def find(self): ...
    def get(self): ...
    def list(self): ...
    def remove(self, rName: str): ...
    def __bool__(self) -> bool: ...

class Particle(API):
    class ExportFlags:
        EXPORT_ALPHA: ClassVar[Particle.ExportFlags] = ...
        EXPORT_AMBIENT_OCCLUSION: ClassVar[Particle.ExportFlags] = ...
        EXPORT_BITANGENT: ClassVar[Particle.ExportFlags] = ...
        EXPORT_CENTER_POSITIONS: ClassVar[Particle.ExportFlags] = ...
        EXPORT_GEOMETRY_ID: ClassVar[Particle.ExportFlags] = ...
        EXPORT_IGNORE_HIDDEN: ClassVar[Particle.ExportFlags] = ...
        EXPORT_IGNORE_MEMORY_REQUIREMENT: ClassVar[Particle.ExportFlags] = ...
        EXPORT_IGNORE_UNSELECTED: ClassVar[Particle.ExportFlags] = ...
        EXPORT_MATCH_IMPORT: ClassVar[Particle.ExportFlags] = ...
        EXPORT_NORMAL: ClassVar[Particle.ExportFlags] = ...
        EXPORT_PARTICLE_ID: ClassVar[Particle.ExportFlags] = ...
        EXPORT_PATCH_ID: ClassVar[Particle.ExportFlags] = ...
        EXPORT_PIXEL_COORDINATE: ClassVar[Particle.ExportFlags] = ...
        EXPORT_RADIUS: ClassVar[Particle.ExportFlags] = ...
        EXPORT_TANGENT: ClassVar[Particle.ExportFlags] = ...
        EXPORT_UV: ClassVar[Particle.ExportFlags] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class ImportFlags:
        IMPORT_BLEED_EDGES: ClassVar[Particle.ImportFlags] = ...
        IMPORT_CENTER_POSITIONS: ClassVar[Particle.ImportFlags] = ...
        IMPORT_FLATTEN: ClassVar[Particle.ImportFlags] = ...
        IMPORT_IGNORE_HIDDEN: ClassVar[Particle.ImportFlags] = ...
        IMPORT_IGNORE_UNSELECTED: ClassVar[Particle.ImportFlags] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class InterpolationMethod:
        INTERPOLATION_INVERSE_DISTANCE_WEIGHTED: ClassVar[Particle.InterpolationMethod] = ...
        INTERPOLATION_INVERSE_DISTANCE_WEIGHTED_SHARPER: ClassVar[Particle.InterpolationMethod] = ...
        INTERPOLATION_INVERSE_DISTANCE_WEIGHTED_SMOOTHER: ClassVar[Particle.InterpolationMethod] = ...
        INTERPOLATION_NEAREST_NEIGHBOR: ClassVar[Particle.InterpolationMethod] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class RangeUnits:
        RANGE_GEO_SIZE_PERCENTAGE: ClassVar[Particle.RangeUnits] = ...
        RANGE_INFINITE: ClassVar[Particle.RangeUnits] = ...
        RANGE_WORLD_SPACE_UNITS: ClassVar[Particle.RangeUnits] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class SearchMethod:
        SEARCH_BACKWARD: ClassVar[Particle.SearchMethod] = ...
        SEARCH_BIDIRECTIONAL: ClassVar[Particle.SearchMethod] = ...
        SEARCH_FORWARD: ClassVar[Particle.SearchMethod] = ...
        SEARCH_RADIAL: ClassVar[Particle.SearchMethod] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    EXPORT_ALPHA: ClassVar[Particle.ExportFlags] = ...
    EXPORT_AMBIENT_OCCLUSION: ClassVar[Particle.ExportFlags] = ...
    EXPORT_BITANGENT: ClassVar[Particle.ExportFlags] = ...
    EXPORT_CENTER_POSITIONS: ClassVar[Particle.ExportFlags] = ...
    EXPORT_GEOMETRY_ID: ClassVar[Particle.ExportFlags] = ...
    EXPORT_IGNORE_HIDDEN: ClassVar[Particle.ExportFlags] = ...
    EXPORT_IGNORE_MEMORY_REQUIREMENT: ClassVar[Particle.ExportFlags] = ...
    EXPORT_IGNORE_UNSELECTED: ClassVar[Particle.ExportFlags] = ...
    EXPORT_MATCH_IMPORT: ClassVar[Particle.ExportFlags] = ...
    EXPORT_NORMAL: ClassVar[Particle.ExportFlags] = ...
    EXPORT_PARTICLE_ID: ClassVar[Particle.ExportFlags] = ...
    EXPORT_PATCH_ID: ClassVar[Particle.ExportFlags] = ...
    EXPORT_PIXEL_COORDINATE: ClassVar[Particle.ExportFlags] = ...
    EXPORT_RADIUS: ClassVar[Particle.ExportFlags] = ...
    EXPORT_TANGENT: ClassVar[Particle.ExportFlags] = ...
    EXPORT_UV: ClassVar[Particle.ExportFlags] = ...
    IMPORT_BLEED_EDGES: ClassVar[Particle.ImportFlags] = ...
    IMPORT_CENTER_POSITIONS: ClassVar[Particle.ImportFlags] = ...
    IMPORT_FLATTEN: ClassVar[Particle.ImportFlags] = ...
    IMPORT_IGNORE_HIDDEN: ClassVar[Particle.ImportFlags] = ...
    IMPORT_IGNORE_UNSELECTED: ClassVar[Particle.ImportFlags] = ...
    INTERPOLATION_INVERSE_DISTANCE_WEIGHTED: ClassVar[Particle.InterpolationMethod] = ...
    INTERPOLATION_INVERSE_DISTANCE_WEIGHTED_SHARPER: ClassVar[Particle.InterpolationMethod] = ...
    INTERPOLATION_INVERSE_DISTANCE_WEIGHTED_SMOOTHER: ClassVar[Particle.InterpolationMethod] = ...
    INTERPOLATION_NEAREST_NEIGHBOR: ClassVar[Particle.InterpolationMethod] = ...
    RANGE_GEO_SIZE_PERCENTAGE: ClassVar[Particle.RangeUnits] = ...
    RANGE_INFINITE: ClassVar[Particle.RangeUnits] = ...
    RANGE_WORLD_SPACE_UNITS: ClassVar[Particle.RangeUnits] = ...
    SEARCH_BACKWARD: ClassVar[Particle.SearchMethod] = ...
    SEARCH_BIDIRECTIONAL: ClassVar[Particle.SearchMethod] = ...
    SEARCH_FORWARD: ClassVar[Particle.SearchMethod] = ...
    SEARCH_RADIAL: ClassVar[Particle.SearchMethod] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def availableOps(self, *args, **kwargs): ...
    def exportGeo(self, *args, **kwargs): ...
    def exportImageSets(self, *args, **kwargs): ...
    def findOp(self, *args, **kwargs): ...
    def importImageSets(self, *args, **kwargs): ...
    def interpolationMethods(self, *args, **kwargs): ...
    def rangeUnits(self, *args, **kwargs): ...
    def searchMethods(self, *args, **kwargs): ...
    def supportedFileFormats(self, *args, **kwargs): ...
    def transferChannel(self, *args, **kwargs): ...
    def transferImageSets(self, *args, **kwargs): ...
    def transferLayers(self, *args, **kwargs): ...
    def __bool__(self) -> bool: ...

class ParticleOp(PropertySource):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def description(self, *args, **kwargs): ...
    def execute(self, *args, **kwargs): ...
    def name(self, *args, **kwargs): ...
    def propertyWidget(self, *args, **kwargs): ...
    def __bool__(self) -> bool: ...

class PatchLinksManager(API):
    groupAdded: ClassVar[PySide2.QtCore.Signal] = ...
    groupRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    groupRenamed: ClassVar[PySide2.QtCore.Signal] = ...
    imageUnlinked: ClassVar[PySide2.QtCore.Signal] = ...
    imagesLinked: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def canLinkImageInternals(self, Images: typing.List[Image]) -> bool: ...
    def canLinkImages(self, Images: typing.List[Image], GroupName: str) -> bool: ...
    def canLinkPatchInternals(self, Patches: typing.List[GeoPatch], pImageSet: ImageSet) -> bool: ...
    def canLinkPatches(self, Patches: typing.List[GeoPatch], GroupName: str, pImageSet: ImageSet) -> bool: ...
    def generateUniqueGroupName(self) -> str: ...
    def groupNames(self) -> typing.List[str]: ...
    def groupNamesForImageSet(self, pImageSet: ImageSet) -> typing.List[str]: ...
    def imageGroup(self, Img: Image) -> str: ...
    def images(self, GroupName: str) -> typing.List[Image]: ...
    def isImageLinked(self, Img: Image) -> bool: ...
    def isPatchLinked(self, Patch: GeoPatch, pImageSet: ImageSet) -> bool: ...
    def linkImages(self, Images: typing.List[Image], GroupName: str): ...
    def linkPatches(self, Patches: typing.List[GeoPatch], GroupName: str, pImageSet: ImageSet): ...
    def linkSelectedPatches(self, GroupName: str, pImageSet: ImageSet): ...
    def linkedImages(self, Img: Image) -> typing.List[Image]: ...
    def linkedPatches(self, Patch: GeoPatch, pImageSet: ImageSet = ...) -> typing.List[GeoPatch]: ...
    def patchGroup(self, Patch: GeoPatch, pImageSet: ImageSet) -> str: ...
    def patches(self, GroupName: str, pImageSet: ImageSet = ...) -> typing.List[GeoPatch]: ...
    def removeGroup(self, GroupName: str): ...
    def renameGroup(self, OldName: str, NewName: str): ...
    def unlinkImage(self, Img: Image): ...
    def unlinkPatch(self, Patch: GeoPatch, pImageSet: ImageSet): ...
    def unlinkSelectedPatches(self, pImageSet: ImageSet): ...
    def __bool__(self) -> bool: ...

class PatchSelectionGroup(SelectionGroup):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def patchList(self) -> typing.List[GeoPatch]: ...
    def __bool__(self) -> bool: ...

class PointLight(Light):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def ambient(self) -> Color: ...
    def constantAttenuation(self) -> float: ...
    def diffuse(self) -> Color: ...
    def fixedTo(self) -> FixedTo: ...
    def intensity(self) -> float: ...
    def linearAttenuation(self) -> float: ...
    def position(self, Frame: typing.SupportsInt = ...) -> VectorN: ...
    def quadraticAttenuation(self) -> float: ...
    def renderShadows(self) -> bool: ...
    def setAmbient(self, NewColor: Color): ...
    def setConstantAttenuation(self, Atten: float): ...
    def setDiffuse(self, NewColor: Color): ...
    def setFixedTo(self, TargetType: FixedTo): ...
    def setIntensity(self, Intensity: float): ...
    def setLinearAttenuation(self, Atten: float): ...
    def setPosition(self, pTranslation: VectorN): ...
    def setQuadraticAttenuation(self, Atten: float): ...
    def setRenderShadows(self, Render: bool): ...
    def setSpecular(self, NewColor: Color): ...
    def setSpotCutoff(self, Cutoff: float): ...
    def setSpotDirection(self, Direction: VectorN): ...
    def setSpotExponent(self, Exponent: float): ...
    def specular(self) -> Color: ...
    def spotCutoff(self) -> float: ...
    def spotDirection(self) -> VectorN: ...
    def spotExponent(self) -> float: ...
    def __bool__(self) -> bool: ...

class PostFilter(PropertySource):
    class PostFilterFlags:
        POSTFILTER_ENABLED: ClassVar[PostFilter.PostFilterFlags] = ...
        POSTFILTER_REMOVABLE: ClassVar[PostFilter.PostFilterFlags] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    POSTFILTER_ENABLED: ClassVar[PostFilter.PostFilterFlags] = ...
    POSTFILTER_REMOVABLE: ClassVar[PostFilter.PostFilterFlags] = ...
    flagsChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def enabled(self) -> bool: ...
    def flags(self) -> int: ...
    def name(self) -> str: ...
    def setEnabled(self, Enabled: bool): ...
    def setFlags(self, Flags: typing.SupportsInt): ...
    def __bool__(self) -> bool: ...

class PostFilterCollection(Metadata):
    class PostFilterCollectionFlags:
        POSTFILTERCOLLECTION_EDITABLE: ClassVar[PostFilterCollection.PostFilterCollectionFlags] = ...
        POSTFILTERCOLLECTION_REMOVABLE: ClassVar[PostFilterCollection.PostFilterCollectionFlags] = ...
        POSTFILTERCOLLECTION_RENAMABLE: ClassVar[PostFilterCollection.PostFilterCollectionFlags] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    POSTFILTERCOLLECTION_EDITABLE: ClassVar[PostFilterCollection.PostFilterCollectionFlags] = ...
    POSTFILTERCOLLECTION_REMOVABLE: ClassVar[PostFilterCollection.PostFilterCollectionFlags] = ...
    POSTFILTERCOLLECTION_RENAMABLE: ClassVar[PostFilterCollection.PostFilterCollectionFlags] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addFilter(self, Name: str, Index: typing.SupportsInt = ...): ...
    def clear(self): ...
    def createCustomLUT(self, Name: str, Index: typing.SupportsInt = ...) -> CustomLUTFilter: ...
    def createFileLUT(self, Name: str, Index: typing.SupportsInt = ...) -> FileLUTFilter: ...
    def createGLSL(self, Name: str, DefinitionsSnippet: str = ..., BodySnippet: str = ..., Index: typing.SupportsInt = ...) -> GLSLFilter: ...
    def filters(self) -> typing.List[PostFilter]: ...
    def find(self, Name: str) -> PostFilter: ...
    def flags(self) -> int: ...
    def indexOf(self, Filter: PostFilter, StartAt: typing.SupportsInt = ...) -> int: ...
    def isReadOnly(self): ...
    def move(self, Filter: PostFilter, Index: typing.SupportsInt): ...
    def name(self) -> str: ...
    def remove(self, Filter: PostFilter): ...
    def setFlags(self, Flags: typing.SupportsInt): ...
    def setReadOnly(self): ...
    def size(self): ...
    def __bool__(self) -> bool: ...

class Preferences(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def event(self, *args, **kwargs): ...
    def get(self, Path: str) -> variant: ...
    def list(self, Path: str = ...): ...
    def prettyPropertyName(self): ...
    def remove(self, Path: str): ...
    def set(self, Path: str, Value: variant): ...
    def setChangedScript(self, Path: str, ChangedScript: str): ...
    def setDefault(self, Path: str, Default: variant): ...
    def setDisplayName(self, Path: str, DisplayName: str): ...
    def setItemList(self, Path: str, ItemList: typing.List[str]): ...
    def setRange(self, Path: str, Min: variant, Max: variant): ...
    def setStep(self, Path: str, Step: variant): ...
    def __bool__(self) -> bool: ...

class ProceduralLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def convertToPaintable(self, SelectedOnly: bool = ...): ...
    def exportImages(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., UVIndexList: typing.List[int] = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def exportSelectedPatches(self, PathAndTemplate: str, Options: typing.SupportsInt = ..., FileOptions: variant = ..., OutputColorConfig: ColorspaceConfig = ...): ...
    def getProceduralParameter(self, ParameterName: str) -> variant: ...
    def getProceduralParameterAsImage(self, ParameterName: str) -> Image: ...
    def proceduralParameters(self) -> typing.List[str]: ...
    def proceduralType(self) -> str: ...
    def setProceduralParameter(self, ParameterName: str, NewValue: variant): ...
    def __bool__(self) -> bool: ...

class Project(PropertySource):
    class LightingMode:
        LIGHTING_BASIC: ClassVar[Project.LightingMode] = ...
        LIGHTING_FLAT: ClassVar[Project.LightingMode] = ...
        LIGHTING_FULL: ClassVar[Project.LightingMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    LIGHTING_BASIC: ClassVar[Project.LightingMode] = ...
    LIGHTING_FLAT: ClassVar[Project.LightingMode] = ...
    LIGHTING_FULL: ClassVar[Project.LightingMode] = ...
    closing: ClassVar[PySide2.QtCore.Signal] = ...
    colorspaceDefaultsChanged: ClassVar[PySide2.QtCore.Signal] = ...
    saved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def close(self, ConfirmIfModified: bool = ...): ...
    def colorspaceDefaults(self) -> ColorspaceDefaults: ...
    def info(self) -> ProjectInfo: ...
    def isDirty(self) -> bool: ...
    def isModified(self) -> bool: ...
    def isSaved(self) -> bool: ...
    def lightingMode(self) -> LightingMode: ...
    def name(self) -> str: ...
    def remapConfigColorspaces(self, ColorspaceRemappings: dict[str, variant], FileName: str = ..., Stages: typing.List[int] = ...): ...
    def removeInvalidImageTags(self) -> bool: ...
    def save(self, ForceSave: bool = ...): ...
    def setColorspaceDefaults(self, Defaults: ColorspaceDefaults): ...
    def setLightingMode(self, Mode: LightingMode): ...
    def updatePatchResolutionInfo(self): ...
    def uuid(self) -> str: ...
    def __bool__(self) -> bool: ...

class ProjectInfo(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addMetadataToToolTip(self, Name: str): ...
    def autosavePath(self): ...
    def cacheDiskUsage(self): ...
    def close(self, ConfirmIfModified: bool = ...): ...
    def createdTime(self): ...
    def isEnabled(self) -> bool: ...
    def isMinionProject(self) -> bool: ...
    def isNull(self): ...
    def isOpen(self): ...
    def lastModifiedTime(self): ...
    def modelPath(self): ...
    def modelPathList(self): ...
    def name(self): ...
    def open(self) -> Project: ...
    def projectDirectories(self): ...
    def projectPath(self): ...
    def recentIndex(self) -> int: ...
    def removeMetadataFromToolTip(self, Name: str): ...
    def setEnabled(self, Enabled: bool): ...
    def subcachePath(self): ...
    def uuid(self): ...
    def version(self) -> str: ...
    def versionHistory(self) -> str: ...
    def __bool__(self) -> bool: ...

class ProjectManager(API):
    class AllowedVersions:
        ANY: ClassVar[ProjectManager.AllowedVersions] = ...
        ASK: ClassVar[ProjectManager.AllowedVersions] = ...
        EXACT: ClassVar[ProjectManager.AllowedVersions] = ...
        OLDER_OR_EXACT: ClassVar[ProjectManager.AllowedVersions] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class MeshOptions:
        FORCE_PTEX: ClassVar[ProjectManager.MeshOptions] = ...
        UV_OR_PTEX: ClassVar[ProjectManager.MeshOptions] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class MultipleGeometryOptions:
        KEEP_SEPARATE: ClassVar[ProjectManager.MultipleGeometryOptions] = ...
        MERGE_GEOMETRIES: ClassVar[ProjectManager.MultipleGeometryOptions] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class OCIOOptions:
        OCIO_ASK: ClassVar[ProjectManager.OCIOOptions] = ...
        OCIO_EXACT: ClassVar[ProjectManager.OCIOOptions] = ...
        OCIO_REMAP: ClassVar[ProjectManager.OCIOOptions] = ...
        OCIO_RESET: ClassVar[ProjectManager.OCIOOptions] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class PtexFaceSizeScheme:
        PTEX_UNIFORM_SIZE: ClassVar[ProjectManager.PtexFaceSizeScheme] = ...
        PTEX_WORLD_SPACE_DENSITY_SIZE: ClassVar[ProjectManager.PtexFaceSizeScheme] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class PtexFormat:
        PTEXFORMAT_BYTE: ClassVar[ProjectManager.PtexFormat] = ...
        PTEXFORMAT_FLOAT: ClassVar[ProjectManager.PtexFormat] = ...
        PTEXFORMAT_HALF: ClassVar[ProjectManager.PtexFormat] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    ANY: ClassVar[ProjectManager.AllowedVersions] = ...
    ASK: ClassVar[ProjectManager.AllowedVersions] = ...
    EXACT: ClassVar[ProjectManager.AllowedVersions] = ...
    FORCE_PTEX: ClassVar[ProjectManager.MeshOptions] = ...
    KEEP_SEPARATE: ClassVar[ProjectManager.MultipleGeometryOptions] = ...
    MERGE_GEOMETRIES: ClassVar[ProjectManager.MultipleGeometryOptions] = ...
    OCIO_ASK: ClassVar[ProjectManager.OCIOOptions] = ...
    OCIO_EXACT: ClassVar[ProjectManager.OCIOOptions] = ...
    OCIO_REMAP: ClassVar[ProjectManager.OCIOOptions] = ...
    OCIO_RESET: ClassVar[ProjectManager.OCIOOptions] = ...
    OLDER_OR_EXACT: ClassVar[ProjectManager.AllowedVersions] = ...
    PTEXFORMAT_BYTE: ClassVar[ProjectManager.PtexFormat] = ...
    PTEXFORMAT_FLOAT: ClassVar[ProjectManager.PtexFormat] = ...
    PTEXFORMAT_HALF: ClassVar[ProjectManager.PtexFormat] = ...
    PTEX_UNIFORM_SIZE: ClassVar[ProjectManager.PtexFaceSizeScheme] = ...
    PTEX_WORLD_SPACE_DENSITY_SIZE: ClassVar[ProjectManager.PtexFaceSizeScheme] = ...
    UV_OR_PTEX: ClassVar[ProjectManager.MeshOptions] = ...
    aboutToArchive: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToClose: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToExport: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToOpen: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToSave: ClassVar[PySide2.QtCore.Signal] = ...
    aboutToSaveNew: ClassVar[PySide2.QtCore.Signal] = ...
    archived: ClassVar[PySide2.QtCore.Signal] = ...
    closed: ClassVar[PySide2.QtCore.Signal] = ...
    created: ClassVar[PySide2.QtCore.Signal] = ...
    exported: ClassVar[PySide2.QtCore.Signal] = ...
    exportedSummary: ClassVar[PySide2.QtCore.Signal] = ...
    opened: ClassVar[PySide2.QtCore.Signal] = ...
    projectDuplicated: ClassVar[PySide2.QtCore.Signal] = ...
    saved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def archive(self, rUUIDOrName: str, rTargetFileName: str): ...
    def cachePath(self) -> str: ...
    def close(self, ConfirmIfModified: bool = ...): ...
    def copy(self, rUUIDOrName: str) -> ProjectInfo: ...
    def create(self, Name: str, MeshPaths: variant, ChannelsToCreate: typing.List[ChannelInfo], ChannelsToImport: typing.List[ChannelInfo] = ..., ProjectMetaOptions: variant = ..., ObjectsToLoad: variant = ..., ColorspaceSettings: ColorspaceDefaults = ...): ...
    def current(self) -> Project: ...
    def duplicate(self, rUUIDOrName: str) -> ProjectInfo: ...
    def extract(self, rFileName: str) -> ProjectInfo: ...
    def find(self, rUUIDOrName: str) -> ProjectInfo: ...
    def get(self, rUUIDOrName: str) -> ProjectInfo: ...
    def list(self) -> typing.List[ProjectInfo]: ...
    def names(self) -> typing.List[str]: ...
    def open(self, rUUIDOrName: str, Allowed: AllowedVersions = ..., OCIO: variant = ...) -> Project: ...
    def remove(self, rUUIDOrName: str): ...
    def rename(self, OldName: str, NewName: str): ...
    def showCreateDialog(self): ...
    def __bool__(self) -> bool: ...

class ProjectionManager(PropertySource):
    class MirrorPlane:
        X: ClassVar[ProjectionManager.MirrorPlane] = ...
        Y: ClassVar[ProjectionManager.MirrorPlane] = ...
        Z: ClassVar[ProjectionManager.MirrorPlane] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    X: ClassVar[ProjectionManager.MirrorPlane] = ...
    Y: ClassVar[ProjectionManager.MirrorPlane] = ...
    Z: ClassVar[ProjectionManager.MirrorPlane] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def debugOcclusionResult(self): ...
    def mirrorAxis(self): ...
    def mirrorProjectionEnabled(self): ...
    def paintingMode(self) -> Layer.BlendMode: ...
    def paintingModeList(self) -> typing.List[Layer.BlendMode]: ...
    def paintingModePath(self) -> str: ...
    def paintingModePathList(self) -> typing.List[str]: ...
    def paintingModeStr(self) -> str: ...
    def paintingModeStrList(self) -> typing.List[str]: ...
    def setMirrorAxis(self): ...
    def setPaintingMode(self, PaintingMode: variant): ...
    def toggleDebugDrawOcclusion(self): ...
    def __bool__(self) -> bool: ...

class Projector(Metadata):
    class BitDepth:
        DEPTH_BYTE: ClassVar[Projector.BitDepth] = ...
        DEPTH_FLOAT: ClassVar[Projector.BitDepth] = ...
        DEPTH_HALF: ClassVar[Projector.BitDepth] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class DepthProjectionMode:
        FRONT: ClassVar[Projector.DepthProjectionMode] = ...
        THROUGH: ClassVar[Projector.DepthProjectionMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...

    class LightingMode:
        BASIC: ClassVar[Projector.LightingMode] = ...
        FLAT: ClassVar[Projector.LightingMode] = ...
        FULL: ClassVar[Projector.LightingMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    BASIC: ClassVar[Projector.LightingMode] = ...
    DEPTH_BYTE: ClassVar[Projector.BitDepth] = ...
    DEPTH_FLOAT: ClassVar[Projector.BitDepth] = ...
    DEPTH_HALF: ClassVar[Projector.BitDepth] = ...
    FLAT: ClassVar[Projector.LightingMode] = ...
    FRONT: ClassVar[Projector.DepthProjectionMode] = ...
    FULL: ClassVar[Projector.LightingMode] = ...
    THROUGH: ClassVar[Projector.DepthProjectionMode] = ...
    aboutToSaveImage: ClassVar[PySide2.QtCore.Signal] = ...
    colorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    exportColorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    frameOffsetChanged: ClassVar[PySide2.QtCore.Signal] = ...
    importColorspaceConfigChanged: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def bitDepth(self) -> BitDepth: ...
    def camera(self): ...
    def clampColors(self) -> bool: ...
    def colorspaceConfig(self) -> ColorspaceConfig: ...
    def depthProjectionMode(self) -> DepthProjectionMode: ...
    def exportColorspaceConfig(self) -> ColorspaceConfig: ...
    def exportOptions(self) -> variant: ...
    def exportPath(self) -> str: ...
    def format(self): ...
    def frameOffset(self) -> int: ...
    def height(self) -> int: ...
    def importColorspaceConfig(self) -> ColorspaceConfig: ...
    def importFromFile(self, Path: str = ...): ...
    def importPath(self) -> str: ...
    def lightingMode(self) -> LightingMode: ...
    def makeCurrent(self): ...
    def name(self) -> str: ...
    def paintingMode(self) -> Layer.BlendMode: ...
    def paintingModePath(self) -> str: ...
    def paintingModeStr(self) -> str: ...
    def project(self): ...
    def projectFromFile(self, Path: str = ...): ...
    def projectionMaskNameList(self) -> typing.List[str]: ...
    def projectionMaskProperty(self): ...
    def projectionMaskPropertyList(self): ...
    def rotation(self): ...
    def save(self, FileName: str): ...
    def scale(self): ...
    def setBitDepth(self, Depth: BitDepth): ...
    def setClampColors(self, ClampColors: bool): ...
    def setColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setDepthProjectionMode(self, ProjectionMode: DepthProjectionMode): ...
    def setExportColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setExportOptions(self, Options: variant): ...
    def setExportPath(self, Path: str): ...
    def setFormat(self): ...
    def setFrameOffset(self, Offset: typing.SupportsInt): ...
    def setImportColorspaceConfig(self, Config: ColorspaceConfig): ...
    def setImportPath(self, Path: str): ...
    def setLightingMode(self, NewMode: LightingMode): ...
    def setName(self): ...
    def setPaintingMode(self, PaintingMode: variant): ...
    def setProjectionMaskProperty(self): ...
    def setRotation(self): ...
    def setScale(self): ...
    def setSize(self): ...
    def setTranslation(self): ...
    def setUseShader(self, UseShader: str): ...
    def translation(self): ...
    def unproject(self, SaveOptions: typing.SupportsInt = ...): ...
    def unprojectToFile(self, Path: str = ..., Options: variant = ..., SaveOptions: typing.SupportsInt = ...): ...
    def useShader(self) -> str: ...
    def useShaderList(self) -> typing.List[str]: ...
    def width(self) -> int: ...
    def __bool__(self) -> bool: ...

class ProjectorManager(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def create(self, Name: str): ...
    def current(self) -> Projector: ...
    def find(self, Name: str) -> Projector: ...
    def get(self, Name: str) -> Projector: ...
    def list(self) -> typing.List[Projector]: ...
    def load(self, Path: str, Options: typing.List[str] = ..., CameraNames: variant = ...) -> typing.List[Projector]: ...
    def names(self) -> typing.List[str]: ...
    def remove(self, Name: str): ...
    def selection(self) -> typing.List[Projector]: ...
    def setCurrent(self, Current: Projector): ...
    def __bool__(self) -> bool: ...

class PropertySource(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def canResetProperty(self, *args, **kwargs): ...
    def getProperty(self, *args, **kwargs): ...
    def propertiesList(self, *args, **kwargs): ...
    def propertyDisplayName(self, *args, **kwargs): ...
    def propertyEnumValues(self, *args, **kwargs): ...
    def propertyHasMinMax(self, *args, **kwargs): ...
    def propertyIsEnum(self, *args, **kwargs): ...
    def propertyIsReadOnly(self, *args, **kwargs): ...
    def propertyMinMax(self, *args, **kwargs): ...
    def propertyTooltip(self, *args, **kwargs): ...
    def resetProperty(self, *args, **kwargs): ...
    def setProperty(self, *args, **kwargs): ...
    def __bool__(self) -> bool: ...

class Ptex(Metadata):
    class ResizeMethod:
        LARGEST_AREA_PER_FACE_SIZE: ClassVar[Ptex.ResizeMethod] = ...
        MATCH_CHANNEL_TO_PTEX: ClassVar[Ptex.ResizeMethod] = ...
        MATCH_PTEX_TO_CHANNEL: ClassVar[Ptex.ResizeMethod] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    LARGEST_AREA_PER_FACE_SIZE: ClassVar[Ptex.ResizeMethod] = ...
    MATCH_CHANNEL_TO_PTEX: ClassVar[Ptex.ResizeMethod] = ...
    MATCH_PTEX_TO_CHANNEL: ClassVar[Ptex.ResizeMethod] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def doubleFaceSize(self, FaceId: typing.SupportsInt): ...
    def exportToPtexFile(self, PtexPathName: str, IncludeGeo: bool, IncludeAdjacency: bool, GenerateMipMaps: bool, IncludeUserAttributes: bool, RemapQuads: bool): ...
    def faceSize(self, FaceId: typing.SupportsInt) -> PySide2.QtWidgets.QSize: ...
    def floodFillFace(self, FaceId: typing.SupportsInt, FillColor: Color): ...
    def geoFaceCount(self) -> int: ...
    def halveFaceSize(self, FaceId: typing.SupportsInt): ...
    def hash(self) -> str: ...
    def importFromPtexFile(self, PtexPathName: str, RemapQuads: bool, Method: typing.SupportsInt = ...): ...
    def resizeFace(self, FaceId: typing.SupportsInt, NewSize: PySide2.QtWidgets.QSize): ...
    def resizeFaceToTexelDensity(self, FaceId: typing.SupportsInt, Density: float): ...
    def validFaceSizes(self) -> typing.List[int]: ...
    def __bool__(self) -> bool: ...

class ReceiverTeleportNode(TeleportNode):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def connectSignals(self, *args, **kwargs): ...
    def setChannelName(self, ChannelName: str): ...
    def __bool__(self) -> bool: ...

class ResourceInfo(API):
    ICONS: ClassVar[str] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def bundledUsdPath(cls, *args, **kwargs): ...
    @classmethod
    def cAPIDocPathKey(cls, *args, **kwargs): ...
    @classmethod
    def cAPIExamplesPathKey(cls, *args, **kwargs): ...
    @classmethod
    def certificatesPathKey(cls, *args, **kwargs): ...
    @classmethod
    def colorPathKey(cls, *args, **kwargs): ...
    @classmethod
    def configPathKey(cls, *args, **kwargs): ...
    def createIcon(self, IconFileName: str) -> PySide2.QtWidgets.QIcon: ...
    def customPluginPaths(self): ...
    @classmethod
    def defaultArchivePathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultCameraPathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultExportPathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultGeometryPathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultImagePathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultImportPathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultRenderPathKey(cls, *args, **kwargs): ...
    @classmethod
    def defaultShelfPathKey(cls, *args, **kwargs): ...
    def disableEnviromentKeyValues(self): ...
    @classmethod
    def examplesPathKey(cls, *args, **kwargs): ...
    def exportSequenceTemplate(self) -> str: ...
    def flattenedSequenceTemplate(self) -> str: ...
    @classmethod
    def gradientPathKey(cls, *args, **kwargs): ...
    @classmethod
    def helpPathKey(cls, *args, **kwargs): ...
    @classmethod
    def iconPathKey(cls, *args, **kwargs): ...
    @classmethod
    def imagePathKey(cls, *args, **kwargs): ...
    def importSequenceTemplate(self) -> str: ...
    @classmethod
    def logoPathKey(cls, *args, **kwargs): ...
    @classmethod
    def lutPathKey(cls, *args, **kwargs): ...
    @classmethod
    def mediaPathKey(cls, *args, **kwargs): ...
    @classmethod
    def miscPathKey(cls, *args, **kwargs): ...
    @classmethod
    def onlineHelpPathKey(cls, *args, **kwargs): ...
    def path(self, Key: str) -> str: ...
    def pathList(self, Key: str) -> typing.List[str]: ...
    def ptexFlattenedSequenceTemplate(self) -> str: ...
    def ptexSequenceTemplate(self) -> str: ...
    @classmethod
    def qtPluginsPathKey(cls, *args, **kwargs): ...
    def refreshAllPaths(self): ...
    def refreshPath(self): ...
    @classmethod
    def scriptDocPathKey(cls, *args, **kwargs): ...
    def sequenceTemplate(self) -> str: ...
    def sequenceToken(self) -> str: ...
    def setExportSequenceTemplate(self, Name: str): ...
    def setFlattenedSequenceTemplate(self, Name: str): ...
    def setImportSequenceTemplate(self, Name: str): ...
    def setPath(self, Key: str, NewPath: str): ...
    def setPathList(self, Key: str, NewPathList: typing.List[str]): ...
    def setPtexFlattenedSequenceTemplate(self, Name: str): ...
    def setPtexSequenceTemplate(self, Name: str): ...
    def setSequenceTemplate(self, Name: str): ...
    def setSequenceToken(self, Token: str): ...
    def settingsFilePath(self, Name: str) -> str: ...
    @classmethod
    def settingsPathKey(cls, *args, **kwargs): ...
    @classmethod
    def shaderPathKey(cls, *args, **kwargs): ...
    def showPDF(self, Path: str): ...
    def showURL(self, Url: str): ...
    @classmethod
    def sysScriptPathKey(cls, *args, **kwargs): ...
    @classmethod
    def testPathKey(cls, *args, **kwargs): ...
    @classmethod
    def userPathKey(cls, *args, **kwargs): ...
    @classmethod
    def userPluginsPathKey(cls, *args, **kwargs): ...
    @classmethod
    def userScriptPathKey(cls, *args, **kwargs): ...
    def __bool__(self) -> bool: ...

class ScriptAction(Action):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    triggered: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def script(self): ...
    def setScript(self): ...
    def __bool__(self) -> bool: ...

class SelectionGroup(Lockable):
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def entityName(self) -> str: ...
    def name(self) -> str: ...
    def selectionMode(self) -> SelectionGroupManager.SelectionMode: ...
    def setEntityName(self, name: str): ...
    def __bool__(self) -> bool: ...

class SelectionGroupManager(API):
    class SelectionMode:
        SELECTION_MODE_FACES: ClassVar[SelectionGroupManager.SelectionMode] = ...
        SELECTION_MODE_OBJECTS: ClassVar[SelectionGroupManager.SelectionMode] = ...
        SELECTION_MODE_PATCHES: ClassVar[SelectionGroupManager.SelectionMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    SELECTION_MODE_FACES: ClassVar[SelectionGroupManager.SelectionMode] = ...
    SELECTION_MODE_OBJECTS: ClassVar[SelectionGroupManager.SelectionMode] = ...
    SELECTION_MODE_PATCHES: ClassVar[SelectionGroupManager.SelectionMode] = ...
    hiddenChanged: ClassVar[PySide2.QtCore.Signal] = ...
    lockedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    modeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    selectModeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    selectedChanged: ClassVar[PySide2.QtCore.Signal] = ...
    selectionGroupAdded: ClassVar[PySide2.QtCore.Signal] = ...
    selectionGroupRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    visibleChanged: ClassVar[PySide2.QtCore.Signal] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def createSelectionGroupFromSelection(self, name: str): ...
    def current(self) -> SelectionGroup: ...
    def list(self) -> typing.List[SelectionGroup]: ...
    def removeSelectionGroup(self, group: SelectionGroup): ...
    def sceneSelectionMode(self) -> SelectionMode: ...
    def select(self, group: SelectionGroup): ...
    def selection(self) -> typing.List[SelectionGroup]: ...
    def setSelectionMode(self, mode: SelectionMode): ...
    def __bool__(self) -> bool: ...

class Settings(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def beginGroup(self, Prefix: str): ...
    def endGroup(self): ...
    def setValue(self, Key: str, Value: variant): ...
    def value(self, Key: str, DefaultValue: variant = ...) -> variant: ...
    def __bool__(self) -> bool: ...

class Shader(Metadata):
    class ChannelSetMode:
        EXTEND_INVISIBLE: ClassVar[Shader.ChannelSetMode] = ...
        EXTEND_VISIBLE: ClassVar[Shader.ChannelSetMode] = ...
        NONE: ClassVar[Shader.ChannelSetMode] = ...
        REMOVE_CONVERT: ClassVar[Shader.ChannelSetMode] = ...
        REMOVE_DISCONNECT: ClassVar[Shader.ChannelSetMode] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    EXTEND_INVISIBLE: ClassVar[Shader.ChannelSetMode] = ...
    EXTEND_VISIBLE: ClassVar[Shader.ChannelSetMode] = ...
    NONE: ClassVar[Shader.ChannelSetMode] = ...
    REMOVE_CONVERT: ClassVar[Shader.ChannelSetMode] = ...
    REMOVE_DISCONNECT: ClassVar[Shader.ChannelSetMode] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    parameterValueChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def channelList(self) -> typing.List[Channel]: ...
    def diffuseType(self) -> str: ...
    def getParameter(self, ParameterName: str) -> variant: ...
    def inputList(self) -> typing.List[variant]: ...
    def inputNameList(self) -> typing.List[str]: ...
    def isInputForShaderStacks(self): ...
    def isLayeredShader(self): ...
    def isLocked(self) -> bool: ...
    def isStackShader(self): ...
    def isSystemShader(self): ...
    def layeredType(self) -> str: ...
    def makeCurrent(self): ...
    def name(self) -> str: ...
    def parameterNameList(self) -> typing.List[str]: ...
    def setInput(self, InputName: str, Input: Channel, SetMode: ChannelSetMode = ...): ...
    def setName(self, Name: str): ...
    def setParameter(self, ParameterName: str, NewValue: variant): ...
    def shaderModel(self) -> ShaderModel: ...
    def shaderNode(self) -> Node: ...
    def specularType(self) -> str: ...
    def standaloneType(self) -> str: ...
    def __bool__(self) -> bool: ...

class ShaderLayer(AdjustableLayer):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def shader(self) -> Shader: ...
    def __bool__(self) -> bool: ...

class ShaderModel(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def id(self) -> str: ...
    def input(self, InputName: str) -> ShaderModelInput: ...
    def inputNames(self) -> typing.List[str]: ...
    def inputs(self) -> variant: ...
    def __bool__(self) -> bool: ...

class ShaderModelInput(Metadata):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def defaultColor(self) -> Color: ...
    def name(self) -> str: ...
    def prettyName(self) -> str: ...
    def scalar(self) -> bool: ...
    def setDefaultColor(self, DefaultColor: Color): ...
    def shortName(self) -> str: ...
    def __bool__(self) -> bool: ...

class ShaderModelManager(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def list(self) -> typing.List[ShaderModel]: ...
    def modelNames(self) -> typing.List[str]: ...
    def nodePathKey(self, Model: ShaderModel) -> str: ...
    def shaderModel(self, Name: str) -> ShaderModel: ...
    def shaderNodePathKeys(self) -> typing.List[str]: ...
    def __bool__(self) -> bool: ...

class Shelf(Metadata):
    shelfItemAdded: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemBadgeChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemDataChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemIconChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemLabelChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemRefreshed: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemTagsChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shelfItemTooltipChanged: ClassVar[PySide2.QtCore.Signal] = ...
    shelfNameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def createItem(self, Item: variant, ForceImmediateLoad: bool = ...) -> ShelfItem: ...
    def exportTo(self, DirectoryPath: str, GenerateCatalog: bool): ...
    def find(self): ...
    def importShelf(self, FileName: str): ...
    def isGrouped(self) -> bool: ...
    def isSystemShelf(self) -> bool: ...
    def list(self) -> typing.List[ShelfItem]: ...
    def loadItem(self, FileName: str): ...
    def loadShelf(self, FileName: str): ...
    def locked(self) -> bool: ...
    def name(self) -> str: ...
    def path(self) -> str: ...
    def removeItem(self, Item: ShelfItem) -> bool: ...
    def saveAs(self, rFileName: str): ...
    def setLocked(self, Locked: bool): ...
    def setName(self, NewName: str): ...
    def __bool__(self) -> bool: ...

class ShelfItem(Action):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def data(self) -> variant: ...
    def name(self) -> str: ...
    def saveAs(self, rFileName: str): ...
    def setName(self, NewName: str): ...
    def setTags(self): ...
    def tags(self) -> typing.List[str]: ...
    def type(self) -> ShelfManager.ShelfItemType: ...
    def __bool__(self) -> bool: ...

class ShelfManager(API):
    class ShelfItemType:
        SHELF_ITEM_BRUSH: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_COLOR: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_COLOR_PROCEDURAL: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_IMAGE: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_MATERIAL: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_PROCEDURAL_MASK: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_SCALAR_PROCEDURAL: ClassVar[ShelfManager.ShelfItemType] = ...
        SHELF_ITEM_UNKNOWN: ClassVar[ShelfManager.ShelfItemType] = ...
        values: ClassVar[dict] = ...
        name: Incomplete
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other): ...
        def __and__(self, other): ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other): ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other): ...
        def __pos__(self): ...
        def __radd__(self, other): ...
        def __rand__(self, other): ...
        def __rmul__(self, other): ...
        def __ror__(self, other): ...
        def __rsub__(self, other): ...
        def __rxor__(self, other): ...
        def __sub__(self, other): ...
        def __xor__(self, other): ...
    SHELF_ITEM_BRUSH: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_COLOR: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_COLOR_PROCEDURAL: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_IMAGE: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_MATERIAL: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_PROCEDURAL_MASK: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_SCALAR_PROCEDURAL: ClassVar[ShelfManager.ShelfItemType] = ...
    SHELF_ITEM_UNKNOWN: ClassVar[ShelfManager.ShelfItemType] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def createShelf(self, ShelfName: str) -> Shelf: ...
    def find(self, Name: str) -> Shelf: ...
    def groupShelf(self, ShelfToGroup: Shelf, GroupPath: str): ...
    def list(self) -> typing.List[Shelf]: ...
    def names(self) -> typing.List[str]: ...
    def removeShelf(self, ShelfToRemove: Shelf) -> bool: ...
    def search(self, SearchKeyword: str, Shelves: typing.List[Shelf]) -> typing.List[ShelfItem]: ...
    def ungroupShelf(self, ShelfToUngroup: Shelf): ...
    def __bool__(self) -> bool: ...

class SliderBase(WidgetBase):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def hideSlider(self): ...
    def hideValueEdit(self): ...
    def logarithmic(self) -> bool: ...
    def precision(self) -> int: ...
    def range(self, Min: float, Max: float): ...
    def rangeMax(self) -> float: ...
    def rangeMin(self) -> float: ...
    def setLogarithmic(self, IsLogarithmic: bool): ...
    def setPrecision(self, NumDecimalPlaces: typing.SupportsInt): ...
    def setRange(self, Min: float, Max: float): ...
    def setStepSize(self, StepSize: float): ...
    def showSlider(self): ...
    def showValueEdit(self): ...
    def stepSize(self) -> float: ...
    def __bool__(self) -> bool: ...

class Snapshot(Metadata):
    creationDateChanged: ClassVar[PySide2.QtCore.Signal] = ...
    creatorChanged: ClassVar[PySide2.QtCore.Signal] = ...
    idChanged: ClassVar[PySide2.QtCore.Signal] = ...
    nameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    previewChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def creationDate(self) -> PySide2.QtWidgets.QDateTime: ...
    def creator(self) -> str: ...
    def hasPreview(self) -> bool: ...
    def id(self) -> str: ...
    def name(self) -> str: ...
    def preview(self) -> PySide2.QtWidgets.QPixmap: ...
    def setCreationDate(self, DateTime: PySide2.QtWidgets.QDateTime): ...
    def setCreator(self, Creator: str): ...
    def setID(self, NewID: str): ...
    def setName(self, NewName: str): ...
    def setPreview(self, NewImage: PySide2.QtWidgets.QPixmap): ...
    def __bool__(self) -> bool: ...

class Snapshotable(Lockable):
    snapshotAdded: ClassVar[PySide2.QtCore.Signal] = ...
    snapshotRemoved: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def createSnapshot(self, Name: str, ID: str = ...) -> Snapshot: ...
    def deleteSnapshot(self, ShotToDelete: Snapshot): ...
    def findSnapshotWithID(self, ID: str) -> Snapshot: ...
    def revertToSnapshot(self, OldSnapshot: Snapshot): ...
    def snapshotList(self) -> typing.List[Snapshot]: ...
    def __bool__(self) -> bool: ...

class TeleportNode(Node):
    channelNameChanged: ClassVar[PySide2.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def channelName(self) -> str: ...
    def connectSignals(self, *args, **kwargs): ...
    def setChannelName(self): ...
    def __bool__(self) -> bool: ...

class Tool(PropertySource):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def cursor(self) -> PySide2.QtWidgets.QCursor: ...
    def description(self) -> str: ...
    def help(self) -> str: ...
    def icon(self) -> PySide2.QtWidgets.QIcon: ...
    def iconActive(self) -> PySide2.QtWidgets.QIcon: ...
    def information(self) -> str: ...
    def name(self) -> str: ...
    def __bool__(self) -> bool: ...

class ToolBar(WidgetBase):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def actionsList(self): ...
    def addAction(self, Path: str, Pos: typing.List[int] = ..., Removable: bool = ...): ...
    def addActionBefore(self, Path: str, InsertBefore: PySide2.QtWidgets.QAction = ..., Removable: bool = ...): ...
    def addActionList(self, Actions: typing.List[str], Removable: bool): ...
    def addActionObject(self, Object: PySide2.QtWidgets.QAction): ...
    def addSeparator(self): ...
    def addWidget(self): ...
    def insertSeparator(self, Path: str): ...
    def insertWidget(self): ...
    def isLocked(self) -> bool: ...
    def lock(self): ...
    def setLocked(self): ...
    def setSpacing(self): ...
    def setVisibile(self, Visible: bool): ...
    def spacing(self): ...
    def unlock(self): ...
    def __bool__(self) -> bool: ...

class ToolManager(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def current(self) -> str: ...
    def currentHelpString(self) -> str: ...
    def currentTool(self) -> Tool: ...
    def getTool(self, Name: str) -> Tool: ...
    def loadBrushes(self, Path: str): ...
    def names(self) -> typing.List[str]: ...
    def setCurrent(self, Name: str): ...
    def setCurrentTool(self, NewTool: Tool): ...
    def toolsList(self) -> typing.List[Tool]: ...
    def __bool__(self) -> bool: ...

class UvIndexRangeList(IndexRangeList):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def fromString(self, RangeString: str) -> bool: ...
    def toString(self) -> str: ...
    def udimList(self) -> typing.List[int]: ...
    def uvIndexList(self) -> typing.List[int]: ...
    def __bool__(self) -> bool: ...

class VectorN(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def asTuple(self) -> tuple[float, ...]: ...
    def length(self) -> int: ...
    def size(self) -> int: ...
    def w(self): ...
    def x(self): ...
    def y(self): ...
    def z(self): ...
    def __bool__(self) -> bool: ...
    def __reduce__(self): ...

class WidgetBase(API):
    staticMetaObject: ClassVar[PySide2.QtCore.QMetaObject] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def addToLayout(self, Layout: PySide2.QtWidgets.QLayout): ...
    def blockSignals(self, Block: bool) -> bool: ...
    def disable(self): ...
    def enable(self): ...
    def hide(self): ...
    def isEnabled(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def maximumHeight(self): ...
    def maximumWidth(self): ...
    def minimumHeight(self): ...
    def minimumWidth(self): ...
    def setEnabled(self, Enable: bool): ...
    def setMaximumHeight(self): ...
    def setMaximumWidth(self): ...
    def setMinimumHeight(self): ...
    def setMinimumWidth(self): ...
    def setStatusTip(self): ...
    def setToolTip(self): ...
    def setVisible(self, Visible: bool): ...
    def show(self): ...
    def statusTip(self): ...
    def toolTip(self): ...
    def __bool__(self) -> bool: ...

# mypy: disable-error-code="misc, override, no-redef"

import Boost.Python
import pxr.Ar
import pxr.Tf
import typing
from _typeshed import Incomplete
from typing import Any, ClassVar, overload

MIN_ORTHO_TOLERANCE: float
MIN_VECTOR_LENGTH: float
__MFB_FULL_PACKAGE_NAME: str

class BBox3d(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    box: Range3d
    hasZeroAreaPrimitives: Incomplete
    matrix: Matrix4d
    @overload
    def __init__(self, arg2: Range3d | list[float] | tuple[float, float, float], arg3: Matrix4d) -> None: ...
    @overload
    def __init__(self, arg2: BBox3d) -> None: ...
    @overload
    def __init__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Combine(arg1: BBox3d, arg2: BBox3d) -> BBox3d: ...
    def ComputeAlignedBox(self) -> Range3d: ...
    def ComputeAlignedRange(self) -> Range3d: ...
    def ComputeCentroid(self) -> Vec3d: ...
    def GetBox(self) -> Range3d: ...
    def GetInverseMatrix(self) -> Matrix4d: ...
    def GetMatrix(self) -> Matrix4d: ...
    def GetRange(self) -> Range3d: ...
    def GetVolume(self) -> float: ...
    def HasZeroAreaPrimitives(self) -> bool: ...
    def Set(self, arg2: Range3d | list[float] | tuple[float, float, float], arg3: Matrix4d) -> BBox3d: ...
    def SetHasZeroAreaPrimitives(self, arg2: bool) -> None: ...
    def SetMatrix(self, arg2: Matrix4d) -> BBox3d: ...
    def SetRange(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> BBox3d: ...
    def Transform(self, arg2: Matrix4d) -> BBox3d: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Camera(Boost.Python.instance):
    class FOVDirection(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: str | pxr.Ar.ResolvedPath) -> Any: ...

    class Projection(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: str | pxr.Ar.ResolvedPath) -> Any: ...
    APERTURE_UNIT: ClassVar[float] = ...
    DEFAULT_HORIZONTAL_APERTURE: ClassVar[float] = ...
    DEFAULT_VERTICAL_APERTURE: ClassVar[float] = ...
    FOCAL_LENGTH_UNIT: ClassVar[float] = ...
    FOVHorizontal: ClassVar[Camera.FOVDirection] = ...
    FOVVertical: ClassVar[Camera.FOVDirection] = ...
    Orthographic: ClassVar[Camera.Projection] = ...
    Perspective: ClassVar[Camera.Projection] = ...
    __instance_size__: ClassVar[int] = ...
    clippingPlanes: list[Vec4f]
    clippingRange: Range1f
    fStop: float
    focalLength: float
    focusDistance: float
    horizontalAperture: float
    horizontalApertureOffset: float
    projection: Camera.Projection
    transform: Matrix4d
    verticalAperture: float
    verticalApertureOffset: float
    @overload
    def __init__(self, transform: Matrix4d = ..., projection: object = ..., horizontalAperture: float = ..., verticalAperture: float = ..., horizontalApertureOffset: float = ..., verticalApertureOffset: float = ..., focalLength: float = ..., clippingRange: Range1f = ..., clippingPlanes: object = ..., fStop: float = ..., focusDistance: float = ...) -> None: ...
    @overload
    def __init__(self, arg2: Camera) -> None: ...
    def GetFieldOfView(self, arg2: Camera.FOVDirection) -> float: ...
    def SetFromViewAndProjectionMatrix(self, viewMatrix: Matrix4d, projMatrix: Matrix4d, focalLength: float = ...) -> None: ...
    def SetOrthographicFromAspectRatioAndSize(self, aspectRatio: float, orthographicSize: float, direction: Camera.FOVDirection) -> None: ...
    def SetPerspectiveFromAspectRatioAndFieldOfView(self, aspectRatio: float, fieldOfView: float, direction: Camera.FOVDirection, horizontalAperture: float = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def aspectRatio(self) -> float: ...
    @property
    def frustum(self) -> Frustum: ...
    @property
    def horizontalFieldOfView(self): ...
    @property
    def verticalFieldOfView(self): ...

class DualQuatd(Boost.Python.instance):
    dual: Quatd
    real: Quatd
    @overload
    def __init__(self, rotation: Quatd | Quatf | Quath, translation: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, real: Quatd | Quatf | Quath, dual: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self, realVal: float) -> None: ...
    @overload
    def __init__(self, real: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConjugate(self) -> DualQuatd: ...
    def GetDual(self) -> Quatd: ...
    @staticmethod
    def GetIdentity() -> DualQuatd: ...
    def GetInverse(self) -> DualQuatd: ...
    def GetLength(self) -> tuple[float, float]: ...
    def GetNormalized(self, eps: float = ...) -> DualQuatd: ...
    def GetReal(self) -> Quatd: ...
    def GetTranslation(self) -> Vec3d: ...
    @staticmethod
    def GetZero() -> DualQuatd: ...
    def Normalize(self, eps: float = ...) -> DualQuatd: ...
    def SetDual(self, arg2: Quatd | Quatf | Quath) -> None: ...
    def SetReal(self, arg2: Quatd | Quatf | Quath) -> None: ...
    def SetTranslation(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def Transform(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def __add__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    @overload
    def __imul__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> Any: ...
    def __itruediv__(self, arg2: float) -> DualQuatd: ...
    @overload
    def __mul__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class DualQuatf(Boost.Python.instance):
    dual: Quatf
    real: Quatf
    @overload
    def __init__(self, rotation: Quatf | Quath, translation: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, real: Quatf | Quath, dual: Quatf | Quath) -> None: ...
    @overload
    def __init__(self, realVal: float) -> None: ...
    @overload
    def __init__(self, real: Quatf | Quath) -> None: ...
    @overload
    def __init__(self, arg2: DualQuatf | DualQuath) -> None: ...
    @overload
    def __init__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConjugate(self) -> DualQuatf: ...
    def GetDual(self) -> Quatf: ...
    @staticmethod
    def GetIdentity() -> DualQuatf: ...
    def GetInverse(self) -> DualQuatf: ...
    def GetLength(self) -> tuple[float, float]: ...
    def GetNormalized(self, eps: float = ...) -> DualQuatf: ...
    def GetReal(self) -> Quatf: ...
    def GetTranslation(self) -> Vec3f: ...
    @staticmethod
    def GetZero() -> DualQuatf: ...
    def Normalize(self, eps: float = ...) -> DualQuatf: ...
    def SetDual(self, arg2: Quatf | Quath) -> None: ...
    def SetReal(self, arg2: Quatf | Quath) -> None: ...
    def SetTranslation(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    def Transform(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    def __add__(self, arg2: DualQuatf | DualQuath) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: DualQuatf | DualQuath) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    @overload
    def __imul__(self, arg2: DualQuatf | DualQuath) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: DualQuatf | DualQuath) -> Any: ...
    def __itruediv__(self, arg2: float) -> DualQuatf: ...
    @overload
    def __mul__(self, arg2: DualQuatf | DualQuath) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: DualQuatf | DualQuath) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class DualQuath(Boost.Python.instance):
    dual: Quath
    real: Quath
    @overload
    def __init__(self, rotation: Quath, translation: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, real: Quath, dual: Quath) -> None: ...
    @overload
    def __init__(self, realVal: object) -> None: ...
    @overload
    def __init__(self, real: Quath) -> None: ...
    @overload
    def __init__(self, arg2: DualQuath) -> None: ...
    @overload
    def __init__(self, arg2: DualQuatd | DualQuatf | DualQuath) -> None: ...
    @overload
    def __init__(self, arg2: DualQuatf | DualQuath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConjugate(self) -> DualQuath: ...
    def GetDual(self) -> Quath: ...
    @staticmethod
    def GetIdentity() -> DualQuath: ...
    def GetInverse(self) -> DualQuath: ...
    def GetLength(self) -> tuple[float, float]: ...
    def GetNormalized(self, eps: float = ...) -> DualQuath: ...
    def GetReal(self) -> Quath: ...
    def GetTranslation(self) -> Vec3h: ...
    @staticmethod
    def GetZero() -> DualQuath: ...
    def Normalize(self, eps: float = ...) -> DualQuath: ...
    def SetDual(self, arg2: Quath) -> None: ...
    def SetReal(self, arg2: Quath) -> None: ...
    def SetTranslation(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    def Transform(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
    def __add__(self, arg2: DualQuath) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: DualQuath) -> Any: ...
    def __idiv__(self, arg2: object) -> Any: ...
    @overload
    def __imul__(self, arg2: DualQuath) -> Any: ...
    @overload
    def __imul__(self, arg2: object) -> Any: ...
    def __isub__(self, arg2: DualQuath) -> Any: ...
    def __itruediv__(self, arg2: object) -> DualQuath: ...
    @overload
    def __mul__(self, arg2: DualQuath) -> Any: ...
    @overload
    def __mul__(self, arg2: object) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: object) -> Any: ...
    def __sub__(self, arg2: DualQuath) -> Any: ...
    def __truediv__(self, arg2: object) -> Any: ...

class Frustum(Boost.Python.instance):
    class ProjectionType(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: str | pxr.Ar.ResolvedPath) -> Any: ...
    Orthographic: ClassVar[Frustum.ProjectionType] = ...
    Perspective: ClassVar[Frustum.ProjectionType] = ...
    __instance_size__: ClassVar[int] = ...
    nearFar: Range1d
    position: Vec3d
    projectionType: Frustum.ProjectionType
    rotation: Rotation
    viewDistance: float
    window: Range2d
    @overload
    def __init__(self, position: Vec3d | list[float] | tuple[float, float, float], rotation: Rotation, window: Range2d | list[float] | tuple[float, float], nearFar: Range1d, projectionType: object, viewDistance: float = ...) -> None: ...
    @overload
    def __init__(self, camToWorldXf: Matrix4d, window: Range2d | list[float] | tuple[float, float], nearFar: Range1d, projectionType: object, viewDistance: float = ...) -> None: ...
    @overload
    def __init__(self, arg2: Frustum) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComputeAspectRatio(self) -> float: ...
    def ComputeCorners(self) -> tuple: ...
    def ComputeCornersAtDistance(self, arg2: float) -> tuple: ...
    def ComputeLookAtPoint(self) -> Vec3d: ...
    @overload
    def ComputeNarrowedFrustum(self, arg2: Vec2d | list[float] | tuple[float, float], arg3: Vec2d | list[float] | tuple[float, float]) -> Frustum: ...
    @overload
    def ComputeNarrowedFrustum(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec2d | list[float] | tuple[float, float]) -> Frustum: ...
    @overload
    def ComputePickRay(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Ray: ...
    @overload
    def ComputePickRay(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Ray: ...
    def ComputeProjectionMatrix(self) -> Matrix4d: ...
    def ComputeUpVector(self) -> Vec3d: ...
    def ComputeViewDirection(self) -> Vec3d: ...
    def ComputeViewFrame(self) -> tuple: ...
    def ComputeViewInverse(self) -> Matrix4d: ...
    def ComputeViewMatrix(self) -> Matrix4d: ...
    def FitToSphere(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: float, arg4: float = ...) -> None: ...
    def GetFOV(self, isFovVertical: bool = ...) -> float: ...
    def GetNearFar(self) -> Range1d: ...
    def GetOrthographic(self) -> tuple: ...
    def GetPerspective(self, isFovVertical: bool = ...) -> Any: ...
    def GetPosition(self) -> Vec3d: ...
    def GetProjectionType(self) -> Frustum.ProjectionType: ...
    @staticmethod
    def GetReferencePlaneDepth() -> float: ...
    def GetRotation(self) -> Rotation: ...
    def GetViewDistance(self) -> float: ...
    def GetWindow(self) -> Range2d: ...
    @overload
    def Intersects(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: Vec3d | list[float] | tuple[float, float, float]) -> bool: ...
    @overload
    def Intersects(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> bool: ...
    @overload
    def Intersects(self, arg2: BBox3d) -> bool: ...
    @overload
    def Intersects(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> bool: ...
    @staticmethod
    def IntersectsViewVolume(arg1: BBox3d, arg2: Matrix4d) -> bool: ...
    def SetNearFar(self, arg2: Range1d) -> None: ...
    def SetOrthographic(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float) -> None: ...
    @overload
    def SetPerspective(self, fov: float, isFovVertical: bool, aspectRatio: float, nearDist: float, farDist: float) -> None: ...
    @overload
    def SetPerspective(self, fovHeight: float, aspectRatio: float, nearDist: float, farDist: float) -> None: ...
    def SetPosition(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def SetPositionAndRotationFromMatrix(self, camToWorldXf: Matrix4d) -> None: ...
    def SetProjectionType(self, arg2: Frustum.ProjectionType) -> None: ...
    def SetRotation(self, arg2: Rotation) -> None: ...
    def SetViewDistance(self, arg2: float) -> None: ...
    def SetWindow(self, arg2: Range2d | list[float] | tuple[float, float]) -> None: ...
    def Transform(self, arg2: Matrix4d) -> Frustum: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Interval(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: bool, arg5: bool) -> None: ...
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Interval) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: Interval) -> bool: ...
    @overload
    def Contains(self, arg2: float) -> bool: ...
    @staticmethod
    def GetFullInterval() -> Interval: ...
    def GetMax(self) -> float: ...
    def GetMin(self) -> float: ...
    def GetSize(self) -> float: ...
    def In(self, arg2: float) -> bool: ...
    def Intersects(self, arg2: Interval) -> bool: ...
    def IsEmpty(self) -> bool: ...
    def IsFinite(self) -> bool: ...
    def IsMaxClosed(self) -> bool: ...
    def IsMaxFinite(self) -> bool: ...
    def IsMaxOpen(self) -> bool: ...
    def IsMinClosed(self) -> bool: ...
    def IsMinFinite(self) -> bool: ...
    def IsMinOpen(self) -> bool: ...
    @overload
    def SetMax(self, arg2: float, arg3: bool) -> None: ...
    @overload
    def SetMax(self, arg2: float) -> None: ...
    @overload
    def SetMin(self, arg2: float, arg3: bool) -> None: ...
    @overload
    def SetMin(self, arg2: float) -> None: ...
    def __add__(self, arg2: Interval) -> Any: ...
    def __and__(self, arg2: Interval) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Interval) -> Any: ...
    def __iand__(self, arg2: Interval) -> Any: ...
    def __imul__(self, arg2: Interval) -> Any: ...
    def __ior__(self, arg2: Interval) -> Any: ...
    def __isub__(self, arg2: Interval) -> Any: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, arg2: Interval) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __or__(self, arg2: Interval) -> Any: ...
    def __sub__(self, arg2: Interval) -> Any: ...
    @property
    def finite(self): ...
    @property
    def isEmpty(self) -> bool: ...
    @property
    def max(self) -> float: ...
    @property
    def maxClosed(self): ...
    @property
    def maxFinite(self): ...
    @property
    def maxOpen(self): ...
    @property
    def min(self) -> float: ...
    @property
    def minClosed(self): ...
    @property
    def minFinite(self): ...
    @property
    def minOpen(self): ...
    @property
    def size(self) -> float: ...

class Line(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    direction: Vec3d
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def FindClosestPoint(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> tuple: ...
    def GetDirection(self) -> Vec3d: ...
    def GetPoint(self, arg2: float) -> Vec3d: ...
    def Set(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Line: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class LineSeg(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def FindClosestPoint(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> tuple: ...
    def GetDirection(self) -> Vec3d: ...
    def GetLength(self) -> float: ...
    def GetPoint(self, arg2: float) -> Vec3d: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def direction(self) -> Vec3d: ...
    @property
    def length(self) -> float: ...

class Matrix2d(Boost.Python.instance):
    dimension: ClassVar[tuple] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...
    @overload
    def __init__(self, arg2: Matrix2d) -> None: ...
    @overload
    def __init__(self, arg2: Matrix2f) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: typing.Iterable[typing.Iterable[float]]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetColumn(self, arg2: int) -> Vec2d: ...
    def GetDeterminant(self) -> float: ...
    def GetInverse(self) -> Matrix2d: ...
    def GetRow(self, arg2: int) -> Vec2d: ...
    def GetTranspose(self) -> Matrix2d: ...
    def Set(self, arg2: float, arg3: float, arg4: float, arg5: float) -> Matrix2d: ...
    def SetColumn(self, arg2: int, arg3: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def SetDiagonal(self, arg2: float) -> Matrix2d: ...
    @overload
    def SetDiagonal(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Matrix2d: ...
    def SetIdentity(self) -> Matrix2d: ...
    def SetRow(self, arg2: int, arg3: Vec2d | list[float] | tuple[float, float]) -> None: ...
    def SetZero(self) -> Matrix2d: ...
    def __add__(self, arg2: Matrix2d) -> Any: ...
    @overload
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __contains__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: tuple) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> Vec2d: ...
    def __iter__(self) -> typing.Iterator[Vec2d]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Matrix2d) -> Any: ...
    @overload
    def __imul__(self, arg2: Matrix2d) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Matrix2d) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix2d) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    @overload
    def __setitem__(self, arg2: tuple, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Vec2d | list[float] | tuple[float, float]) -> None: ...
    def __sub__(self, arg2: Matrix2d) -> Any: ...
    def __truediv__(self, arg2: Matrix2d) -> Any: ...

class Matrix2f(Boost.Python.instance):
    dimension: ClassVar[tuple] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...
    @overload
    def __init__(self, arg2: Matrix2d) -> None: ...
    @overload
    def __init__(self, arg2: Matrix2f) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: typing.Iterable[typing.Iterable[float]]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetColumn(self, arg2: int) -> Vec2f: ...
    def GetDeterminant(self) -> float: ...
    def GetInverse(self) -> Matrix2f: ...
    def GetRow(self, arg2: int) -> Vec2f: ...
    def GetTranspose(self) -> Matrix2f: ...
    def Set(self, arg2: float, arg3: float, arg4: float, arg5: float) -> Matrix2f: ...
    def SetColumn(self, arg2: int, arg3: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def SetDiagonal(self, arg2: float) -> Matrix2f: ...
    @overload
    def SetDiagonal(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Matrix2f: ...
    def SetIdentity(self) -> Matrix2f: ...
    def SetRow(self, arg2: int, arg3: Vec2f | list[float] | tuple[float, float]) -> None: ...
    def SetZero(self) -> Matrix2f: ...
    def __add__(self, arg2: Matrix2f) -> Any: ...
    @overload
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __contains__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: tuple) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> Vec2f: ...
    def __iter__(self) -> typing.Iterator[Vec2f]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Matrix2f) -> Any: ...
    @overload
    def __imul__(self, arg2: Matrix2f) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Matrix2f) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix2f) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    @overload
    def __setitem__(self, arg2: tuple, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Vec2f | list[float] | tuple[float, float]) -> None: ...
    def __sub__(self, arg2: Matrix2f) -> Any: ...
    def __truediv__(self, arg2: Matrix2f) -> Any: ...

class Matrix3d(Boost.Python.instance):
    dimension: ClassVar[tuple] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float) -> None: ...
    @overload
    def __init__(self, arg2: Matrix3d) -> None: ...
    @overload
    def __init__(self, arg2: Matrix3f) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Rotation) -> None: ...
    @overload
    def __init__(self, arg2: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ExtractRotation(self) -> Rotation: ...
    def GetColumn(self, arg2: int) -> Vec3d: ...
    def GetDeterminant(self) -> float: ...
    def GetHandedness(self) -> float: ...
    def GetInverse(self) -> Matrix3d: ...
    def GetOrthonormalized(self, issueWarning: bool = ...) -> Matrix3d: ...
    def GetRow(self, arg2: int) -> Vec3d: ...
    def GetTranspose(self) -> Matrix3d: ...
    def IsLeftHanded(self) -> bool: ...
    def IsRightHanded(self) -> bool: ...
    def Orthonormalize(self, issueWarning: bool = ...) -> bool: ...
    def Set(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float) -> Matrix3d: ...
    def SetColumn(self, arg2: int, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def SetDiagonal(self, arg2: float) -> Matrix3d: ...
    @overload
    def SetDiagonal(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Matrix3d: ...
    def SetIdentity(self) -> Matrix3d: ...
    @overload
    def SetRotate(self, arg2: Quatd | Quatf | Quath) -> Matrix3d: ...
    @overload
    def SetRotate(self, arg2: Rotation) -> Matrix3d: ...
    def SetRow(self, arg2: int, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def SetScale(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Matrix3d: ...
    @overload
    def SetScale(self, arg2: float) -> Matrix3d: ...
    def SetZero(self) -> Matrix3d: ...
    def __add__(self, arg2: Matrix3d) -> Any: ...
    @overload
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __contains__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: tuple) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> Vec3d: ...
    def __iter__(self) -> typing.Iterator[Vec3d]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Matrix3d) -> Any: ...
    @overload
    def __imul__(self, arg2: Matrix3d) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Matrix3d) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix3d) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    @overload
    def __setitem__(self, arg2: tuple, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def __sub__(self, arg2: Matrix3d) -> Any: ...
    def __truediv__(self, arg2: Matrix3d) -> Any: ...

class Matrix3f(Boost.Python.instance):
    dimension: ClassVar[tuple] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float) -> None: ...
    @overload
    def __init__(self, arg2: Matrix3d) -> None: ...
    @overload
    def __init__(self, arg2: Matrix3f) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Rotation) -> None: ...
    @overload
    def __init__(self, arg2: Quatf | Quath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ExtractRotation(self) -> Rotation: ...
    def GetColumn(self, arg2: int) -> Vec3f: ...
    def GetDeterminant(self) -> float: ...
    def GetHandedness(self) -> float: ...
    def GetInverse(self) -> Matrix3f: ...
    def GetOrthonormalized(self, issueWarning: bool = ...) -> Matrix3f: ...
    def GetRow(self, arg2: int) -> Vec3f: ...
    def GetTranspose(self) -> Matrix3f: ...
    def IsLeftHanded(self) -> bool: ...
    def IsRightHanded(self) -> bool: ...
    def Orthonormalize(self, issueWarning: bool = ...) -> bool: ...
    def Set(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float) -> Matrix3f: ...
    def SetColumn(self, arg2: int, arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def SetDiagonal(self, arg2: float) -> Matrix3f: ...
    @overload
    def SetDiagonal(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Matrix3f: ...
    def SetIdentity(self) -> Matrix3f: ...
    @overload
    def SetRotate(self, arg2: Quatf | Quath) -> Matrix3f: ...
    @overload
    def SetRotate(self, arg2: Rotation) -> Matrix3f: ...
    def SetRow(self, arg2: int, arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def SetScale(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Matrix3f: ...
    @overload
    def SetScale(self, arg2: float) -> Matrix3f: ...
    def SetZero(self) -> Matrix3f: ...
    def __add__(self, arg2: Matrix3f) -> Any: ...
    @overload
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __contains__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: tuple) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> Vec3f: ...
    def __iter__(self) -> typing.Iterator[Vec3f]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Matrix3f) -> Any: ...
    @overload
    def __imul__(self, arg2: Matrix3f) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Matrix3f) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix3f) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    @overload
    def __setitem__(self, arg2: tuple, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    def __sub__(self, arg2: Matrix3f) -> Any: ...
    def __truediv__(self, arg2: Matrix3f) -> Any: ...

class Matrix4d(Boost.Python.instance):
    dimension: ClassVar[tuple] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: float, arg17: float) -> None: ...
    @overload
    def __init__(self, arg2: object, arg3: object, arg4: object, arg5: object) -> None: ...
    @overload
    def __init__(self, arg2: Matrix3d, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Rotation, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Matrix4d) -> None: ...
    @overload
    def __init__(self, arg2: Matrix4f) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ExtractRotation(self) -> Rotation: ...
    def ExtractRotationMatrix(self) -> Matrix3d: ...
    def ExtractRotationQuat(self) -> Quatd: ...
    def ExtractTranslation(self) -> Vec3d: ...
    def Factor(self, arg2: float = ...) -> tuple: ...
    def GetColumn(self, arg2: int) -> Vec4d: ...
    def GetDeterminant(self) -> float: ...
    def GetDeterminant3(self) -> float: ...
    def GetHandedness(self) -> float: ...
    def GetInverse(self) -> Matrix4d: ...
    def GetOrthonormalized(self, issueWarning: bool = ...) -> Matrix4d: ...
    def GetRow(self, arg2: int) -> Vec4d: ...
    def GetRow3(self, arg2: int) -> Vec3d: ...
    def GetTranspose(self) -> Matrix4d: ...
    def HasOrthogonalRows3(self) -> bool: ...
    def IsLeftHanded(self) -> bool: ...
    def IsRightHanded(self) -> bool: ...
    def Orthonormalize(self, issueWarning: bool = ...) -> bool: ...
    def RemoveScaleShear(self) -> Matrix4d: ...
    def Set(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: float, arg17: float) -> Matrix4d: ...
    def SetColumn(self, arg2: int, arg3: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def SetDiagonal(self, arg2: float) -> Matrix4d: ...
    @overload
    def SetDiagonal(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Matrix4d: ...
    def SetIdentity(self) -> Matrix4d: ...
    @overload
    def SetLookAt(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: Vec3d | list[float] | tuple[float, float, float]) -> Matrix4d: ...
    @overload
    def SetLookAt(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Rotation) -> Matrix4d: ...
    @overload
    def SetRotate(self, arg2: Quatd | Quatf | Quath) -> Matrix4d: ...
    @overload
    def SetRotate(self, arg2: Rotation) -> Matrix4d: ...
    @overload
    def SetRotate(self, arg2: Matrix3d) -> Matrix4d: ...
    @overload
    def SetRotateOnly(self, arg2: Quatd | Quatf | Quath) -> Matrix4d: ...
    @overload
    def SetRotateOnly(self, arg2: Rotation) -> Matrix4d: ...
    @overload
    def SetRotateOnly(self, arg2: Matrix3d) -> Matrix4d: ...
    def SetRow(self, arg2: int, arg3: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    def SetRow3(self, arg2: int, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def SetScale(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Matrix4d: ...
    @overload
    def SetScale(self, arg2: float) -> Matrix4d: ...
    @overload
    def SetTransform(self, arg2: Rotation, arg3: Vec3d | list[float] | tuple[float, float, float]) -> Matrix4d: ...
    @overload
    def SetTransform(self, arg2: Matrix3d, arg3: Vec3d | list[float] | tuple[float, float, float]) -> Matrix4d: ...
    def SetTranslate(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Matrix4d: ...
    def SetTranslateOnly(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Matrix4d: ...
    def SetZero(self) -> Matrix4d: ...
    @overload
    def Transform(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def Transform(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    @overload
    def TransformAffine(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def TransformAffine(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    @overload
    def TransformDir(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def TransformDir(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def __add__(self, arg2: Matrix4d) -> Any: ...
    @overload
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __contains__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: tuple) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> Vec4d: ...
    def __iter__(self) -> typing.Iterator[Vec4d]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Matrix4d) -> Any: ...
    @overload
    def __imul__(self, arg2: Matrix4d) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Matrix4d) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix4d) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    @overload
    def __setitem__(self, arg2: tuple, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    def __sub__(self, arg2: Matrix4d) -> Any: ...
    def __truediv__(self, arg2: Matrix4d) -> Any: ...

class Matrix4f(Boost.Python.instance):
    dimension: ClassVar[tuple] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: float, arg17: float) -> None: ...
    @overload
    def __init__(self, arg2: object, arg3: object, arg4: object, arg5: object) -> None: ...
    @overload
    def __init__(self, arg2: Matrix3f, arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Rotation, arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Matrix4d) -> None: ...
    @overload
    def __init__(self, arg2: Matrix4f) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ExtractRotation(self) -> Rotation: ...
    def ExtractRotationMatrix(self) -> Matrix3f: ...
    def ExtractRotationQuat(self) -> Quatf: ...
    def ExtractTranslation(self) -> Vec3f: ...
    def Factor(self, arg2: float = ...) -> tuple: ...
    def GetColumn(self, arg2: int) -> Vec4f: ...
    def GetDeterminant(self) -> float: ...
    def GetDeterminant3(self) -> float: ...
    def GetHandedness(self) -> float: ...
    def GetInverse(self) -> Matrix4f: ...
    def GetOrthonormalized(self, issueWarning: bool = ...) -> Matrix4f: ...
    def GetRow(self, arg2: int) -> Vec4f: ...
    def GetRow3(self, arg2: int) -> Vec3f: ...
    def GetTranspose(self) -> Matrix4f: ...
    def HasOrthogonalRows3(self) -> bool: ...
    def IsLeftHanded(self) -> bool: ...
    def IsRightHanded(self) -> bool: ...
    def Orthonormalize(self, issueWarning: bool = ...) -> bool: ...
    def RemoveScaleShear(self) -> Matrix4f: ...
    def Set(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: float, arg17: float) -> Matrix4f: ...
    def SetColumn(self, arg2: int, arg3: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def SetDiagonal(self, arg2: float) -> Matrix4f: ...
    @overload
    def SetDiagonal(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Matrix4f: ...
    def SetIdentity(self) -> Matrix4f: ...
    @overload
    def SetLookAt(self, arg2: Vec3f | list[float] | tuple[float, float, float], arg3: Vec3f | list[float] | tuple[float, float, float], arg4: Vec3f | list[float] | tuple[float, float, float]) -> Matrix4f: ...
    @overload
    def SetLookAt(self, arg2: Vec3f | list[float] | tuple[float, float, float], arg3: Rotation) -> Matrix4f: ...
    @overload
    def SetRotate(self, arg2: Quatf | Quath) -> Matrix4f: ...
    @overload
    def SetRotate(self, arg2: Rotation) -> Matrix4f: ...
    @overload
    def SetRotate(self, arg2: Matrix3f) -> Matrix4f: ...
    @overload
    def SetRotateOnly(self, arg2: Quatf | Quath) -> Matrix4f: ...
    @overload
    def SetRotateOnly(self, arg2: Rotation) -> Matrix4f: ...
    @overload
    def SetRotateOnly(self, arg2: Matrix3f) -> Matrix4f: ...
    def SetRow(self, arg2: int, arg3: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    def SetRow3(self, arg2: int, arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def SetScale(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Matrix4f: ...
    @overload
    def SetScale(self, arg2: float) -> Matrix4f: ...
    @overload
    def SetTransform(self, arg2: Rotation, arg3: Vec3f | list[float] | tuple[float, float, float]) -> Matrix4f: ...
    @overload
    def SetTransform(self, arg2: Matrix3f, arg3: Vec3f | list[float] | tuple[float, float, float]) -> Matrix4f: ...
    def SetTranslate(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Matrix4f: ...
    def SetTranslateOnly(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Matrix4f: ...
    def SetZero(self) -> Matrix4f: ...
    @overload
    def Transform(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def Transform(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    @overload
    def TransformAffine(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def TransformAffine(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    @overload
    def TransformDir(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def TransformDir(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def __add__(self, arg2: Matrix4f) -> Any: ...
    @overload
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __contains__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: tuple) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> Vec4f: ...
    def __iter__(self) -> typing.Iterator[Vec4f]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Matrix4f) -> Any: ...
    @overload
    def __imul__(self, arg2: Matrix4f) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Matrix4f) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix4f) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __rmul__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    @overload
    def __setitem__(self, arg2: tuple, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    def __sub__(self, arg2: Matrix4f) -> Any: ...
    def __truediv__(self, arg2: Matrix4f) -> Any: ...

class MultiInterval(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: Interval) -> None: ...
    @overload
    def __init__(self, arg2: MultiInterval) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Add(self, arg2: Interval) -> None: ...
    @overload
    def Add(self, arg2: MultiInterval) -> None: ...
    def ArithmeticAdd(self, arg2: Interval) -> None: ...
    def Clear(self) -> None: ...
    @overload
    def Contains(self, arg2: Interval) -> bool: ...
    @overload
    def Contains(self, arg2: MultiInterval) -> bool: ...
    @overload
    def Contains(self, arg2: float) -> bool: ...
    def GetBounds(self) -> Interval: ...
    def GetComplement(self) -> MultiInterval: ...
    def GetContainingInterval(self, arg2: float) -> const_iterator: ...
    @staticmethod
    def GetFullInterval() -> MultiInterval: ...
    def GetNextNonContainingInterval(self, arg2: float) -> const_iterator: ...
    def GetPriorNonContainingInterval(self, arg2: float) -> const_iterator: ...
    def GetSize(self) -> int: ...
    @overload
    def Intersect(self, arg2: Interval) -> None: ...
    @overload
    def Intersect(self, arg2: MultiInterval) -> None: ...
    def IsEmpty(self) -> bool: ...
    @overload
    def Remove(self, arg2: Interval) -> None: ...
    @overload
    def Remove(self, arg2: MultiInterval) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Any: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def bounds(self) -> Interval: ...
    @property
    def isEmpty(self) -> bool: ...
    @property
    def size(self) -> int: ...

class Plane(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetDistance(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> float: ...
    def GetDistanceFromOrigin(self) -> float: ...
    def GetEquation(self) -> Vec4d: ...
    def GetNormal(self) -> Vec3d: ...
    @overload
    def IntersectsPositiveHalfSpace(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> bool: ...
    @overload
    def IntersectsPositiveHalfSpace(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> bool: ...
    def Project(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def Reorient(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Plane: ...
    @overload
    def Set(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: Vec3d | list[float] | tuple[float, float, float]) -> Plane: ...
    @overload
    def Set(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: float) -> Plane: ...
    @overload
    def Set(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Plane: ...
    @overload
    def Set(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Plane: ...
    def Transform(self, arg2: Matrix4d) -> Plane: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def distanceFromOrigin(self) -> float: ...
    @property
    def normal(self) -> Vec3d: ...

class Quatd(Boost.Python.instance):
    imaginary: Vec3d
    real: float
    @overload
    def __init__(self, real: float, i: float, j: float, k: float) -> None: ...
    @overload
    def __init__(self, real: float, imaginary: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, real: float) -> None: ...
    @overload
    def __init__(self, arg2: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConjugate(self) -> Quatd: ...
    @staticmethod
    def GetIdentity() -> Quatd: ...
    def GetImaginary(self) -> Vec3d: ...
    def GetInverse(self) -> Quatd: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, eps: float = ...) -> Quatd: ...
    def GetReal(self) -> float: ...
    @staticmethod
    def GetZero() -> Quatd: ...
    def Normalize(self, eps: float = ...) -> Quatd: ...
    @overload
    def SetImaginary(self, i: float, j: float, k: float) -> None: ...
    @overload
    def SetImaginary(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def SetReal(self, arg2: float) -> None: ...
    def Transform(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def __add__(self, arg2: Quatd | Quatf | Quath) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Quatd | Quatf | Quath) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    @overload
    def __imul__(self, arg2: Quatd | Quatf | Quath) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Quatd | Quatf | Quath) -> Any: ...
    def __itruediv__(self, arg2: float) -> Quatd: ...
    @overload
    def __mul__(self, arg2: Quatd | Quatf | Quath) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Quatd | Quatf | Quath) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Quaternion(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    imaginary: Vec3d
    real: float
    @overload
    def __init__(self, arg2: float, arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self, arg2: Quaternion) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def GetIdentity() -> Quaternion: ...
    def GetImaginary(self) -> Vec3d: ...
    def GetInverse(self) -> Quaternion: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Quaternion: ...
    def GetReal(self) -> float: ...
    @staticmethod
    def GetZero() -> Quaternion: ...
    def Normalize(self, arg2: float = ...) -> Quaternion: ...
    def __add__(self, arg2: Quaternion) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Quaternion) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    @overload
    def __imul__(self, arg2: Quaternion) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Quaternion) -> Any: ...
    def __itruediv__(self, arg2: float) -> Quaternion: ...
    @overload
    def __mul__(self, arg2: Quaternion) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Quaternion) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Quatf(Boost.Python.instance):
    imaginary: Vec3f
    real: float
    @overload
    def __init__(self, real: float, i: float, j: float, k: float) -> None: ...
    @overload
    def __init__(self, real: float, imaginary: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, real: float) -> None: ...
    @overload
    def __init__(self, arg2: Quatf | Quath) -> None: ...
    @overload
    def __init__(self, arg2: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConjugate(self) -> Quatf: ...
    @staticmethod
    def GetIdentity() -> Quatf: ...
    def GetImaginary(self) -> Vec3f: ...
    def GetInverse(self) -> Quatf: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, eps: float = ...) -> Quatf: ...
    def GetReal(self) -> float: ...
    @staticmethod
    def GetZero() -> Quatf: ...
    def Normalize(self, eps: float = ...) -> Quatf: ...
    @overload
    def SetImaginary(self, i: float, j: float, k: float) -> None: ...
    @overload
    def SetImaginary(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    def SetReal(self, arg2: float) -> None: ...
    def Transform(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    def __add__(self, arg2: Quatf | Quath) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Quatf | Quath) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    @overload
    def __imul__(self, arg2: Quatf | Quath) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Quatf | Quath) -> Any: ...
    def __itruediv__(self, arg2: float) -> Quatf: ...
    @overload
    def __mul__(self, arg2: Quatf | Quath) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Quatf | Quath) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Quath(Boost.Python.instance):
    imaginary: Vec3h
    real: float
    @overload
    def __init__(self, real: object, i: object, j: object, k: object) -> None: ...
    @overload
    def __init__(self, real: object, imaginary: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, real: object) -> None: ...
    @overload
    def __init__(self, arg2: Quath) -> None: ...
    @overload
    def __init__(self, arg2: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self, arg2: Quatf | Quath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConjugate(self) -> Quath: ...
    @staticmethod
    def GetIdentity() -> Quath: ...
    def GetImaginary(self) -> Vec3h: ...
    def GetInverse(self) -> Quath: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, eps: float = ...) -> Quath: ...
    def GetReal(self) -> float: ...
    @staticmethod
    def GetZero() -> Quath: ...
    def Normalize(self, eps: float = ...) -> Quath: ...
    @overload
    def SetImaginary(self, i: float, j: float, k: float) -> None: ...
    @overload
    def SetImaginary(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    def SetReal(self, arg2: float) -> None: ...
    def Transform(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
    def __add__(self, arg2: Quath) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Quath) -> Any: ...
    def __idiv__(self, arg2: object) -> Any: ...
    @overload
    def __imul__(self, arg2: Quath) -> Any: ...
    @overload
    def __imul__(self, arg2: object) -> Any: ...
    def __isub__(self, arg2: Quath) -> Any: ...
    def __itruediv__(self, arg2: object) -> Quath: ...
    @overload
    def __mul__(self, arg2: Quath) -> Any: ...
    @overload
    def __mul__(self, arg2: object) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: object) -> Any: ...
    def __sub__(self, arg2: Quath) -> Any: ...
    def __truediv__(self, arg2: object) -> Any: ...

class Range1d(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    max: float
    min: float
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Range1d) -> None: ...
    @overload
    def __init__(self, arg2: Range1f) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: float) -> bool: ...
    @overload
    def Contains(self, arg2: Range1d) -> bool: ...
    def GetDistanceSquared(self, arg2: float) -> float: ...
    @staticmethod
    def GetIntersection(arg1: Range1d, arg2: Range1d) -> Range1d: ...
    def GetMax(self) -> float: ...
    def GetMidpoint(self) -> float: ...
    def GetMin(self) -> float: ...
    def GetSize(self) -> float: ...
    @staticmethod
    def GetUnion(arg1: Range1d, arg2: Range1d) -> Range1d: ...
    def IntersectWith(self, arg2: Range1d) -> Range1d: ...
    def IsEmpty(self) -> bool: ...
    def SetEmpty(self) -> None: ...
    def SetMax(self, arg2: float) -> None: ...
    def SetMin(self, arg2: float) -> None: ...
    @overload
    def UnionWith(self, arg2: float) -> Range1d: ...
    @overload
    def UnionWith(self, arg2: Range1d) -> Range1d: ...
    def __add__(self, arg2: Range1d) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Range1d) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Range1d) -> Any: ...
    def __itruediv__(self, arg2: float) -> Range1d: ...
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Range1d) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Range1f(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    max: float
    min: float
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Range1f) -> None: ...
    @overload
    def __init__(self, arg2: Range1d) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: float) -> bool: ...
    @overload
    def Contains(self, arg2: Range1f) -> bool: ...
    def GetDistanceSquared(self, arg2: float) -> float: ...
    @staticmethod
    def GetIntersection(arg1: Range1f, arg2: Range1f) -> Range1f: ...
    def GetMax(self) -> float: ...
    def GetMidpoint(self) -> float: ...
    def GetMin(self) -> float: ...
    def GetSize(self) -> float: ...
    @staticmethod
    def GetUnion(arg1: Range1f, arg2: Range1f) -> Range1f: ...
    def IntersectWith(self, arg2: Range1f) -> Range1f: ...
    def IsEmpty(self) -> bool: ...
    def SetEmpty(self) -> None: ...
    def SetMax(self, arg2: float) -> None: ...
    def SetMin(self, arg2: float) -> None: ...
    @overload
    def UnionWith(self, arg2: float) -> Range1f: ...
    @overload
    def UnionWith(self, arg2: Range1f) -> Range1f: ...
    def __add__(self, arg2: Range1f) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Range1f) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Range1f) -> Any: ...
    def __itruediv__(self, arg2: float) -> Range1f: ...
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Range1f) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Range2d(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    unitSquare: ClassVar[Range2d] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    max: Vec2d
    min: Vec2d
    @overload
    def __init__(self, arg2: Vec2d | list[float] | tuple[float, float], arg3: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: Vec2d | list[float] | tuple[float, float]) -> bool: ...
    @overload
    def Contains(self, arg2: Range2d | list[float] | tuple[float, float]) -> bool: ...
    def GetCorner(self, arg2: int) -> Vec2d: ...
    def GetDistanceSquared(self, arg2: Vec2d | list[float] | tuple[float, float]) -> float: ...
    @staticmethod
    def GetIntersection(arg1: Range2d | list[float] | tuple[float, float], arg2: Range2d | list[float] | tuple[float, float]) -> Range2d: ...
    def GetMax(self) -> Vec2d: ...
    def GetMidpoint(self) -> Vec2d: ...
    def GetMin(self) -> Vec2d: ...
    def GetQuadrant(self, arg2: int) -> Range2d: ...
    def GetSize(self) -> Vec2d: ...
    @staticmethod
    def GetUnion(arg1: Range2d | list[float] | tuple[float, float], arg2: Range2d | list[float] | tuple[float, float]) -> Range2d: ...
    def IntersectWith(self, arg2: Range2d | list[float] | tuple[float, float]) -> Range2d: ...
    def IsEmpty(self) -> bool: ...
    def SetEmpty(self) -> None: ...
    def SetMax(self, arg2: Vec2d | list[float] | tuple[float, float]) -> None: ...
    def SetMin(self, arg2: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def UnionWith(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Range2d: ...
    @overload
    def UnionWith(self, arg2: Range2d | list[float] | tuple[float, float]) -> Range2d: ...
    def __add__(self, arg2: Range2d | list[float] | tuple[float, float]) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Range2d | list[float] | tuple[float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Range2d | list[float] | tuple[float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Range2d: ...
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Range2d | list[float] | tuple[float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Range2f(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    unitSquare: ClassVar[Range2f] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    max: Vec2f
    min: Vec2f
    @overload
    def __init__(self, arg2: Vec2f | list[float] | tuple[float, float], arg3: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: Vec2f | list[float] | tuple[float, float]) -> bool: ...
    @overload
    def Contains(self, arg2: Range2f | list[float] | tuple[float, float]) -> bool: ...
    def GetCorner(self, arg2: int) -> Vec2f: ...
    def GetDistanceSquared(self, arg2: Vec2f | list[float] | tuple[float, float]) -> float: ...
    @staticmethod
    def GetIntersection(arg1: Range2f | list[float] | tuple[float, float], arg2: Range2f | list[float] | tuple[float, float]) -> Range2f: ...
    def GetMax(self) -> Vec2f: ...
    def GetMidpoint(self) -> Vec2f: ...
    def GetMin(self) -> Vec2f: ...
    def GetQuadrant(self, arg2: int) -> Range2f: ...
    def GetSize(self) -> Vec2f: ...
    @staticmethod
    def GetUnion(arg1: Range2f | list[float] | tuple[float, float], arg2: Range2f | list[float] | tuple[float, float]) -> Range2f: ...
    def IntersectWith(self, arg2: Range2f | list[float] | tuple[float, float]) -> Range2f: ...
    def IsEmpty(self) -> bool: ...
    def SetEmpty(self) -> None: ...
    def SetMax(self, arg2: Vec2f | list[float] | tuple[float, float]) -> None: ...
    def SetMin(self, arg2: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def UnionWith(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Range2f: ...
    @overload
    def UnionWith(self, arg2: Range2f | list[float] | tuple[float, float]) -> Range2f: ...
    def __add__(self, arg2: Range2f | list[float] | tuple[float, float]) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Range2f | list[float] | tuple[float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Range2f | list[float] | tuple[float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Range2f: ...
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Range2f | list[float] | tuple[float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Range3d(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    unitCube: ClassVar[Range3d] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    max: Vec3d
    min: Vec3d
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> bool: ...
    @overload
    def Contains(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> bool: ...
    def GetCorner(self, arg2: int) -> Vec3d: ...
    def GetDistanceSquared(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> float: ...
    @staticmethod
    def GetIntersection(arg1: Range3d | list[float] | tuple[float, float, float], arg2: Range3d | list[float] | tuple[float, float, float]) -> Range3d: ...
    def GetMax(self) -> Vec3d: ...
    def GetMidpoint(self) -> Vec3d: ...
    def GetMin(self) -> Vec3d: ...
    def GetOctant(self, arg2: int) -> Range3d: ...
    def GetSize(self) -> Vec3d: ...
    @staticmethod
    def GetUnion(arg1: Range3d | list[float] | tuple[float, float, float], arg2: Range3d | list[float] | tuple[float, float, float]) -> Range3d: ...
    def IntersectWith(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> Range3d: ...
    def IsEmpty(self) -> bool: ...
    def SetEmpty(self) -> None: ...
    def SetMax(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def SetMin(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def UnionWith(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Range3d: ...
    @overload
    def UnionWith(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> Range3d: ...
    def __add__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Range3d: ...
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Range3f(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    unitCube: ClassVar[Range3f] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    max: Vec3f
    min: Vec3f
    @overload
    def __init__(self, arg2: Vec3f | list[float] | tuple[float, float, float], arg3: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Contains(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> bool: ...
    @overload
    def Contains(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> bool: ...
    def GetCorner(self, arg2: int) -> Vec3f: ...
    def GetDistanceSquared(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> float: ...
    @staticmethod
    def GetIntersection(arg1: Range3f | list[float] | tuple[float, float, float], arg2: Range3f | list[float] | tuple[float, float, float]) -> Range3f: ...
    def GetMax(self) -> Vec3f: ...
    def GetMidpoint(self) -> Vec3f: ...
    def GetMin(self) -> Vec3f: ...
    def GetOctant(self, arg2: int) -> Range3f: ...
    def GetSize(self) -> Vec3f: ...
    @staticmethod
    def GetUnion(arg1: Range3f | list[float] | tuple[float, float, float], arg2: Range3f | list[float] | tuple[float, float, float]) -> Range3f: ...
    def IntersectWith(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> Range3f: ...
    def IsEmpty(self) -> bool: ...
    def SetEmpty(self) -> None: ...
    def SetMax(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    def SetMin(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def UnionWith(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Range3f: ...
    @overload
    def UnionWith(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> Range3f: ...
    def __add__(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Range3f: ...
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: Range3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Ray(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    direction: Vec3d
    startPoint: Vec3d
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def FindClosestPoint(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> tuple: ...
    def GetPoint(self, arg2: float) -> Vec3d: ...
    @overload
    def Intersect(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: float, arg5: float) -> tuple: ...
    @overload
    def Intersect(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: Vec3d | list[float] | tuple[float, float, float]) -> tuple: ...
    @overload
    def Intersect(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: float) -> tuple: ...
    @overload
    def Intersect(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: float) -> tuple: ...
    @overload
    def Intersect(self, arg2: Plane) -> tuple: ...
    @overload
    def Intersect(self, arg2: Range3d | list[float] | tuple[float, float, float]) -> tuple: ...
    @overload
    def Intersect(self, arg2: BBox3d) -> tuple: ...
    def SetEnds(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Ray: ...
    def SetPointAndDirection(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Ray: ...
    def Transform(self, arg2: Matrix4d) -> Ray: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Rect2i(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    max: Vec2i
    maxX: int
    maxY: int
    min: Vec2i
    minX: int
    minY: int
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int], arg3: int, arg4: int) -> None: ...
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int], arg3: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Rect2i) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Contains(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> bool: ...
    def GetArea(self) -> int: ...
    def GetCenter(self) -> Vec2i: ...
    def GetHeight(self) -> int: ...
    def GetIntersection(self, arg2: Rect2i) -> Rect2i: ...
    def GetMax(self) -> Vec2i: ...
    def GetMaxX(self) -> int: ...
    def GetMaxY(self) -> int: ...
    def GetMin(self) -> Vec2i: ...
    def GetMinX(self) -> int: ...
    def GetMinY(self) -> int: ...
    def GetNormalized(self) -> Rect2i: ...
    def GetSize(self) -> Vec2i: ...
    def GetUnion(self, arg2: Rect2i) -> Rect2i: ...
    def GetWidth(self) -> int: ...
    def IsEmpty(self) -> bool: ...
    def IsNull(self) -> bool: ...
    def IsValid(self) -> bool: ...
    def SetMax(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    def SetMaxX(self, arg2: int) -> None: ...
    def SetMaxY(self, arg2: int) -> None: ...
    def SetMin(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    def SetMinX(self, arg2: int) -> None: ...
    def SetMinY(self, arg2: int) -> None: ...
    def Translate(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> Rect2i: ...
    def __add__(self, arg2: Rect2i) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Rect2i) -> Any: ...
    def __ne__(self, other: object) -> bool: ...

class Rotation(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    angle: float
    axis: Vec3d
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Quaternion) -> None: ...
    @overload
    def __init__(self, arg2: Quatd | Quatf | Quath) -> None: ...
    @overload
    def __init__(self, arg2: Rotation) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Decompose(self, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    @staticmethod
    def DecomposeRotation(rot: Matrix4d, twAxis: Vec3d | list[float] | tuple[float, float, float], fbAxis: Vec3d | list[float] | tuple[float, float, float], lrAxis: Vec3d | list[float] | tuple[float, float, float], handedness: float, thetaTwHint: float, thetaFBHint: float, thetaLRHint: float, thetaSwHint: float = ..., useHint: bool = ..., swShift: float = ...) -> tuple: ...
    @staticmethod
    def DecomposeRotation3(rot: Matrix4d, twAxis: Vec3d | list[float] | tuple[float, float, float], fbAxis: Vec3d | list[float] | tuple[float, float, float], lrAxis: Vec3d | list[float] | tuple[float, float, float], handedness: float, thetaTwHint: float = ..., thetaFBHint: float = ..., thetaLRHint: float = ..., useHint: bool = ...) -> tuple: ...
    def GetAngle(self) -> float: ...
    def GetAxis(self) -> Vec3d: ...
    def GetInverse(self) -> Rotation: ...
    def GetQuat(self) -> Quatd: ...
    def GetQuaternion(self) -> Quaternion: ...
    @staticmethod
    def MatchClosestEulerRotation(arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> tuple: ...
    @staticmethod
    def RotateOntoProjected(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Rotation: ...
    def SetAxisAngle(self, axis: Vec3d | list[float] | tuple[float, float, float], angle: float) -> Rotation: ...
    def SetIdentity(self) -> Rotation: ...
    def SetQuat(self, quat: Quatd | Quatf | Quath) -> Rotation: ...
    def SetQuaternion(self, quaternion: Quaternion) -> Rotation: ...
    def SetRotateInto(self, rotateFrom: Vec3d | list[float] | tuple[float, float, float], rotateTo: Vec3d | list[float] | tuple[float, float, float]) -> Rotation: ...
    @overload
    def TransformDir(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    @overload
    def TransformDir(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __idiv__(self, arg2: float) -> Any: ...
    @overload
    def __imul__(self, arg2: Rotation) -> Any: ...
    @overload
    def __imul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Rotation) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Size2(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: int, arg3: int) -> None: ...
    @overload
    def __init__(self, arg2: Size2 | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Set(self, arg2: int, arg3: int) -> Size2: ...
    def __add__(self, arg2: Size2 | list[float] | tuple[float, float]) -> Any: ...
    def __contains__(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: int) -> int: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __iadd__(self, arg2: Size2 | list[float] | tuple[float, float]) -> Any: ...
    def __idiv__(self, arg2: int) -> Any: ...
    def __imul__(self, arg2: int) -> Any: ...
    def __isub__(self, arg2: Size2 | list[float] | tuple[float, float]) -> Any: ...
    def __itruediv__(self, arg2: int) -> Size2: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Size2 | list[float] | tuple[float, float]) -> Any: ...
    @overload
    def __mul__(self, arg2: int) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: int) -> Any: ...
    def __setitem__(self, arg2: int, arg3: int) -> None: ...
    def __sub__(self, arg2: Size2 | list[float] | tuple[float, float]) -> Any: ...
    def __truediv__(self, arg2: int) -> Any: ...

class Size3(Boost.Python.instance):
    dimension: ClassVar[int] = ...  # read-only
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: int, arg3: int, arg4: int) -> None: ...
    @overload
    def __init__(self, arg2: Size3 | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Set(self, arg2: int, arg3: int, arg4: int) -> Size3: ...
    def __add__(self, arg2: Size3 | list[float] | tuple[float, float, float]) -> Any: ...
    def __contains__(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: int) -> int: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __iadd__(self, arg2: Size3 | list[float] | tuple[float, float, float]) -> Any: ...
    def __idiv__(self, arg2: int) -> Any: ...
    def __imul__(self, arg2: int) -> Any: ...
    def __isub__(self, arg2: Size3 | list[float] | tuple[float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: int) -> Size3: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Size3 | list[float] | tuple[float, float, float]) -> Any: ...
    @overload
    def __mul__(self, arg2: int) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __rmul__(self, arg2: int) -> Any: ...
    def __setitem__(self, arg2: int, arg3: int) -> None: ...
    def __sub__(self, arg2: Size3 | list[float] | tuple[float, float, float]) -> Any: ...
    def __truediv__(self, arg2: int) -> Any: ...

class Transform(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    pivotOrientation: Rotation
    pivotPosition: Vec3d
    rotation: Rotation
    scale: Vec3d
    translation: Vec3d
    @overload
    def __init__(self, translation: Vec3d | list[float] | tuple[float, float, float] = ..., rotation: Rotation = ..., scale: Vec3d | list[float] | tuple[float, float, float] = ..., pivotPosition: Vec3d | list[float] | tuple[float, float, float] = ..., pivotOrientation: Rotation = ...) -> None: ...
    @overload
    def __init__(self, scale: Vec3d | list[float] | tuple[float, float, float], pivotOrientation: Rotation, rotation: Rotation, pivotPosition: Vec3d | list[float] | tuple[float, float, float], translation: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Matrix4d) -> None: ...
    def GetMatrix(self) -> Matrix4d: ...
    def GetPivotOrientation(self) -> Rotation: ...
    def GetPivotPosition(self) -> Vec3d: ...
    def GetRotation(self) -> Rotation: ...
    def GetScale(self) -> Vec3d: ...
    def GetTranslation(self) -> Vec3d: ...
    @overload
    def Set(self, translation: Vec3d | list[float] | tuple[float, float, float] = ..., rotation: Rotation = ..., scale: Vec3d | list[float] | tuple[float, float, float] = ..., pivotPosition: Vec3d | list[float] | tuple[float, float, float] = ..., pivotOrientation: Rotation = ...) -> Transform: ...
    @overload
    def Set(self, scale: Vec3d | list[float] | tuple[float, float, float], pivotOrientation: Rotation, rotation: Rotation, pivotPosition: Vec3d | list[float] | tuple[float, float, float], translation: Vec3d | list[float] | tuple[float, float, float]) -> Transform: ...
    def SetIdentity(self) -> Transform: ...
    def SetMatrix(self, arg2: Matrix4d) -> Transform: ...
    def SetPivotOrientation(self, arg2: Rotation) -> None: ...
    def SetPivotPosition(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def SetRotation(self, arg2: Rotation) -> None: ...
    def SetScale(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def SetTranslation(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __imul__(self, arg2: Transform) -> Any: ...
    def __mul__(self, arg2: Transform) -> Any: ...
    def __ne__(self, other: object) -> bool: ...

class Vec2d(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec2d: ...
    def GetComplement(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
    def GetDot(self, arg2: Vec2d | list[float] | tuple[float, float]) -> float: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec2d: ...
    def GetProjection(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def XAxis() -> Vec2d: ...
    @staticmethod
    def YAxis() -> Vec2d: ...
    def __add__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    def __contains__(self, arg2: float) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Vec2d: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Vec2f(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec2f: ...
    def GetComplement(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
    def GetDot(self, arg2: Vec2f | list[float] | tuple[float, float]) -> float: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec2f: ...
    def GetProjection(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def XAxis() -> Vec2f: ...
    @staticmethod
    def YAxis() -> Vec2f: ...
    def __add__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __contains__(self, arg2: float) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Vec2f: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Vec2h(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec2d | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2f | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec2h: ...
    def GetComplement(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Vec2h: ...
    def GetDot(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec2h: ...
    def GetProjection(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Vec2h: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def XAxis() -> Vec2h: ...
    @staticmethod
    def YAxis() -> Vec2h: ...
    def __add__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
    def __contains__(self, arg2: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
    def __idiv__(self, arg2: object) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
    def __itruediv__(self, arg2: object) -> Vec2h: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
    def __truediv__(self, arg2: object) -> Any: ...

class Vec2i(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: int, arg3: int) -> None: ...
    @overload
    def __init__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec2i: ...
    def GetDot(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> int: ...
    @staticmethod
    def XAxis() -> Vec2i: ...
    @staticmethod
    def YAxis() -> Vec2i: ...
    def __add__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> Any: ...
    def __contains__(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> int: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> Any: ...
    def __idiv__(self, arg2: int) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> Any: ...
    def __itruediv__(self, arg2: int) -> Vec2i: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: int) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> Any: ...
    def __truediv__(self, arg2: int) -> Any: ...

class Vec3d(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec3d: ...
    def BuildOrthonormalFrame(self, arg2: float = ...) -> tuple: ...
    def GetComplement(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def GetCross(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def GetDot(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> float: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec3d: ...
    def GetProjection(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def OrthogonalizeBasis(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float], arg4: bool, arg5: float = ...) -> bool: ...
    @staticmethod
    def XAxis() -> Vec3d: ...
    @staticmethod
    def YAxis() -> Vec3d: ...
    @staticmethod
    def ZAxis() -> Vec3d: ...
    def __add__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __contains__(self, arg2: float) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Vec3d: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...
    def __xor__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> Any: ...

class Vec3f(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec3f: ...
    def BuildOrthonormalFrame(self, arg2: float = ...) -> tuple: ...
    def GetComplement(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    def GetCross(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    def GetDot(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> float: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec3f: ...
    def GetProjection(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def OrthogonalizeBasis(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float], arg3: Vec3f | list[float] | tuple[float, float, float], arg4: bool, arg5: float = ...) -> bool: ...
    @staticmethod
    def XAxis() -> Vec3f: ...
    @staticmethod
    def YAxis() -> Vec3f: ...
    @staticmethod
    def ZAxis() -> Vec3f: ...
    def __add__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __contains__(self, arg2: float) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Vec3f: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...
    def __xor__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> Any: ...

class Vec3h(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec3d | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3f | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec3h: ...
    def BuildOrthonormalFrame(self, arg2: float = ...) -> tuple: ...
    def GetComplement(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
    def GetCross(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
    def GetDot(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec3h: ...
    def GetProjection(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def OrthogonalizeBasis(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float], arg3: Vec3h | list[float] | tuple[float, float, float], arg4: bool, arg5: float = ...) -> bool: ...
    @staticmethod
    def XAxis() -> Vec3h: ...
    @staticmethod
    def YAxis() -> Vec3h: ...
    @staticmethod
    def ZAxis() -> Vec3h: ...
    def __add__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
    def __contains__(self, arg2: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
    def __idiv__(self, arg2: object) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: object) -> Vec3h: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
    def __truediv__(self, arg2: object) -> Any: ...
    def __xor__(self, arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...

class Vec3i(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: int, arg3: int, arg4: int) -> None: ...
    @overload
    def __init__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec3i: ...
    def GetDot(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> int: ...
    @staticmethod
    def XAxis() -> Vec3i: ...
    @staticmethod
    def YAxis() -> Vec3i: ...
    @staticmethod
    def ZAxis() -> Vec3i: ...
    def __add__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> Any: ...
    def __contains__(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> int: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> Any: ...
    def __idiv__(self, arg2: int) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> Any: ...
    def __itruediv__(self, arg2: int) -> Vec3i: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: int) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> Any: ...
    def __truediv__(self, arg2: int) -> Any: ...

class Vec4d(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec4d: ...
    def GetComplement(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
    def GetDot(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> float: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec4d: ...
    def GetProjection(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def WAxis() -> Vec4d: ...
    @staticmethod
    def XAxis() -> Vec4d: ...
    @staticmethod
    def YAxis() -> Vec4d: ...
    @staticmethod
    def ZAxis() -> Vec4d: ...
    def __add__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __contains__(self, arg2: float) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Vec4d: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Vec4f(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec4f: ...
    def GetComplement(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
    def GetDot(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> float: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec4f: ...
    def GetProjection(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def WAxis() -> Vec4f: ...
    @staticmethod
    def XAxis() -> Vec4f: ...
    @staticmethod
    def YAxis() -> Vec4f: ...
    @staticmethod
    def ZAxis() -> Vec4f: ...
    def __add__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __contains__(self, arg2: float) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __idiv__(self, arg2: float) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: float) -> Vec4f: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: float) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __truediv__(self, arg2: float) -> Any: ...

class Vec4h(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...
    @overload
    def __init__(self, arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> None: ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec4h: ...
    def GetComplement(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
    def GetDot(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
    def GetLength(self) -> float: ...
    def GetNormalized(self, arg2: float = ...) -> Vec4h: ...
    def GetProjection(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
    def Normalize(self, arg2: float = ...) -> float: ...
    @staticmethod
    def WAxis() -> Vec4h: ...
    @staticmethod
    def XAxis() -> Vec4h: ...
    @staticmethod
    def YAxis() -> Vec4h: ...
    @staticmethod
    def ZAxis() -> Vec4h: ...
    def __add__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __contains__(self, arg2: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> float: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __idiv__(self, arg2: object) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __itruediv__(self, arg2: object) -> Vec4h: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
    def __truediv__(self, arg2: object) -> Any: ...

class Vec4i(Boost.Python.instance):
    __isGfVec: ClassVar[bool] = ...  # read-only
    dimension: ClassVar[int] = ...  # read-only
    __safe_for_unpickling__: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: int, arg3: int, arg4: int, arg5: int) -> None: ...
    @overload
    def __init__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Axis(arg1: int) -> Vec4i: ...
    def GetDot(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> int: ...
    @staticmethod
    def WAxis() -> Vec4i: ...
    @staticmethod
    def XAxis() -> Vec4i: ...
    @staticmethod
    def YAxis() -> Vec4i: ...
    @staticmethod
    def ZAxis() -> Vec4i: ...
    def __add__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> Any: ...
    def __contains__(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getinitargs__(self) -> tuple: ...
    @overload
    def __getitem__(self, arg2: int) -> int: ...
    @overload
    def __getitem__(self, arg2: int) -> list: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> Any: ...
    def __idiv__(self, arg2: int) -> Any: ...
    def __imul__(self, arg2: float) -> Any: ...
    def __isub__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> Any: ...
    def __itruediv__(self, arg2: int) -> Vec4i: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    @overload
    def __mul__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    @overload
    def __setitem__(self, arg2: int, arg3: int) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    def __sub__(self, arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> Any: ...
    def __truediv__(self, arg2: int) -> Any: ...

def Abs(arg1: float) -> float: ...
@overload
def Absf(f) -> float: ...
@overload
def Absf(arg1: float) -> float: ...
@overload
def ApplyGamma(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: float) -> Vec3f: ...
@overload
def ApplyGamma(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: float) -> Vec3d: ...
@overload
def ApplyGamma(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: float) -> Vec3h: ...
@overload
def ApplyGamma(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: float) -> Vec4f: ...
@overload
def ApplyGamma(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: float) -> Vec4d: ...
@overload
def ApplyGamma(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: float) -> Vec4h: ...
def Ceil(arg1: float) -> float: ...
@overload
def Ceilf(f) -> float: ...
@overload
def Ceilf(arg1: float) -> float: ...
def Clamp(arg1: float, arg2: float, arg3: float) -> float: ...
@overload
def Clampf(arg1: float, arg2: float, arg3: float) -> float: ...
@overload
def Clampf(f) -> float: ...
@overload
def CompDiv(arg1: float, arg2: float) -> float: ...
@overload
def CompDiv(arg1: Vec2h | list[float] | tuple[float, float], arg2: Vec2h | list[float] | tuple[float, float]) -> Vec2h: ...
@overload
def CompDiv(arg1: Vec2f | list[float] | tuple[float, float], arg2: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
@overload
def CompDiv(arg1: Vec2d | list[float] | tuple[float, float], arg2: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
@overload
def CompDiv(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def CompDiv(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def CompDiv(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def CompDiv(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
@overload
def CompDiv(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def CompDiv(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def CompMult(arg1: float, arg2: float) -> float: ...
@overload
def CompMult(arg1: Vec2h | list[float] | tuple[float, float], arg2: Vec2h | list[float] | tuple[float, float]) -> Vec2h: ...
@overload
def CompMult(arg1: Vec2f | list[float] | tuple[float, float], arg2: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
@overload
def CompMult(arg1: Vec2d | list[float] | tuple[float, float], arg2: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
@overload
def CompMult(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def CompMult(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def CompMult(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def CompMult(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
@overload
def CompMult(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def CompMult(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def ConvertDisplayToLinear(arg1: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def ConvertDisplayToLinear(arg1: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def ConvertDisplayToLinear(arg1: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def ConvertDisplayToLinear(arg1: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def ConvertDisplayToLinear(arg1: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def ConvertDisplayToLinear(arg1: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
@overload
def ConvertLinearToDisplay(arg1: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def ConvertLinearToDisplay(arg1: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def ConvertLinearToDisplay(arg1: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def ConvertLinearToDisplay(arg1: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def ConvertLinearToDisplay(arg1: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def ConvertLinearToDisplay(arg1: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
@overload
def Cross(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def Cross(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def Cross(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
def DegreesToRadians(arg1: float) -> float: ...
@overload
def Dot(arg1: DualQuatd | DualQuatf | DualQuath, arg2: DualQuatd | DualQuatf | DualQuath) -> float: ...
@overload
def Dot(arg1: DualQuatf | DualQuath, arg2: DualQuatf | DualQuath) -> float: ...
@overload
def Dot(arg1: DualQuath, arg2: DualQuath) -> Any: ...
@overload
def Dot(arg1: float, arg2: float) -> float: ...
@overload
def Dot(arg1: Quatd | Quatf | Quath, arg2: Quatd | Quatf | Quath) -> float: ...
@overload
def Dot(arg1: Quatf | Quath, arg2: Quatf | Quath) -> float: ...
@overload
def Dot(arg1: Quath, arg2: Quath) -> Any: ...
@overload
def Dot(arg1: Quaternion, arg2: Quaternion) -> float: ...
@overload
def Dot(arg1: Vec2h | list[float] | tuple[float, float], arg2: Vec2h | list[float] | tuple[float, float]) -> Any: ...
@overload
def Dot(arg1: Vec2f | list[float] | tuple[float, float], arg2: Vec2f | list[float] | tuple[float, float]) -> float: ...
@overload
def Dot(arg1: Vec2d | list[float] | tuple[float, float], arg2: Vec2d | list[float] | tuple[float, float]) -> float: ...
@overload
def Dot(arg1: Vec2i | list[int] | Size2 | tuple[int, int], arg2: Vec2i | list[int] | Size2 | tuple[int, int]) -> int: ...
@overload
def Dot(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
@overload
def Dot(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float]) -> float: ...
@overload
def Dot(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float]) -> float: ...
@overload
def Dot(arg1: Vec3i | list[int] | Size3 | tuple[int, int, int], arg2: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> int: ...
@overload
def Dot(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
@overload
def Dot(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> float: ...
@overload
def Dot(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> float: ...
@overload
def Dot(arg1: Vec4i | list[int] | tuple[int, int, int, int], arg2: Vec4i | list[int] | tuple[int, int, int, int]) -> int: ...
def Exp(arg1: float) -> float: ...
@overload
def Expf(f) -> float: ...
@overload
def Expf(arg1: float) -> float: ...
@overload
def FindClosestPoints(arg1: Line, arg2: Line) -> tuple: ...
@overload
def FindClosestPoints(arg1: Line, arg2: LineSeg) -> tuple: ...
@overload
def FindClosestPoints(arg1: LineSeg, arg2: LineSeg) -> tuple: ...
@overload
def FindClosestPoints(arg1: Ray, arg2: Line) -> tuple: ...
@overload
def FindClosestPoints(arg1: Ray, arg2: LineSeg) -> tuple: ...
def FitPlaneToPoints(arg1: typing.Iterable[Vec3d | list[float] | tuple[float, float, float]]) -> Plane: ...
def Floor(arg1: float) -> float: ...
@overload
def Floorf(f) -> float: ...
@overload
def Floorf(arg1: float) -> float: ...
@overload
def GetComplement(arg1: Vec2h | list[float] | tuple[float, float], arg2: Vec2h | list[float] | tuple[float, float]) -> Vec2h: ...
@overload
def GetComplement(arg1: Vec2f | list[float] | tuple[float, float], arg2: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
@overload
def GetComplement(arg1: Vec2d | list[float] | tuple[float, float], arg2: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
@overload
def GetComplement(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def GetComplement(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def GetComplement(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def GetComplement(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
@overload
def GetComplement(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def GetComplement(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
def GetDisplayGamma() -> float: ...
@overload
def GetHomogenized(arg1: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def GetHomogenized(arg1: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def GetLength(arg1: Vec2h | list[float] | tuple[float, float]) -> Any: ...
@overload
def GetLength(arg1: Vec2f | list[float] | tuple[float, float]) -> float: ...
@overload
def GetLength(arg1: Vec2d | list[float] | tuple[float, float]) -> float: ...
@overload
def GetLength(arg1: Vec3h | list[float] | tuple[float, float, float]) -> Any: ...
@overload
def GetLength(arg1: Vec3f | list[float] | tuple[float, float, float]) -> float: ...
@overload
def GetLength(arg1: Vec3d | list[float] | tuple[float, float, float]) -> float: ...
@overload
def GetLength(arg1: Vec4h | list[float] | tuple[float, float, float, float]) -> Any: ...
@overload
def GetLength(arg1: Vec4f | list[float] | tuple[float, float, float, float]) -> float: ...
@overload
def GetLength(arg1: Vec4d | list[float] | tuple[float, float, float, float]) -> float: ...
@overload
def GetNormalized(arg1: Vec2h | list[float] | tuple[float, float], arg2: object = ...) -> Vec2h: ...
@overload
def GetNormalized(arg1: Vec2f | list[float] | tuple[float, float], arg2: float = ...) -> Vec2f: ...
@overload
def GetNormalized(arg1: Vec2d | list[float] | tuple[float, float], arg2: float = ...) -> Vec2d: ...
@overload
def GetNormalized(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: object = ...) -> Vec3h: ...
@overload
def GetNormalized(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: float = ...) -> Vec3f: ...
@overload
def GetNormalized(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: float = ...) -> Vec3d: ...
@overload
def GetNormalized(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: object = ...) -> Vec4h: ...
@overload
def GetNormalized(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: float = ...) -> Vec4f: ...
@overload
def GetNormalized(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: float = ...) -> Vec4d: ...
@overload
def GetProjection(arg1: Vec2h | list[float] | tuple[float, float], arg2: Vec2h | list[float] | tuple[float, float]) -> Vec2h: ...
@overload
def GetProjection(arg1: Vec2f | list[float] | tuple[float, float], arg2: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
@overload
def GetProjection(arg1: Vec2d | list[float] | tuple[float, float], arg2: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
@overload
def GetProjection(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def GetProjection(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def GetProjection(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def GetProjection(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4h | list[float] | tuple[float, float, float, float]) -> Vec4h: ...
@overload
def GetProjection(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def GetProjection(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def HomogeneousCross(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def HomogeneousCross(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def IsClose(arg1: float, arg2: float, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Matrix2d, arg2: Matrix2d, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Matrix2f, arg2: Matrix2f, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Matrix3d, arg2: Matrix3d, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Matrix3f, arg2: Matrix3f, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Matrix4f, arg2: Matrix4f, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Matrix4d, arg2: Matrix4d, arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec2h | list[float] | tuple[float, float], arg2: Vec2h | list[float] | tuple[float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec2f | list[float] | tuple[float, float], arg2: Vec2f | list[float] | tuple[float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec2d | list[float] | tuple[float, float], arg2: Vec2d | list[float] | tuple[float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: Vec3h | list[float] | tuple[float, float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: Vec3f | list[float] | tuple[float, float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: Vec3d | list[float] | tuple[float, float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4h | list[float] | tuple[float, float, float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4f | list[float] | tuple[float, float, float, float], arg3: float) -> bool: ...
@overload
def IsClose(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4d | list[float] | tuple[float, float, float, float], arg3: float) -> bool: ...
@overload
def Lerp(arg1: float, arg2: float, arg3: float) -> float: ...
@overload
def Lerp(arg1: float, arg2: Vec2i | list[int] | Size2 | tuple[int, int], arg3: Vec2i | list[int] | Size2 | tuple[int, int]) -> Vec2i: ...
@overload
def Lerp(arg1: float, arg2: Vec3i | list[int] | Size3 | tuple[int, int, int], arg3: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> Vec3i: ...
@overload
def Lerp(arg1: float, arg2: Vec2f | list[float] | tuple[float, float], arg3: Vec2f | list[float] | tuple[float, float]) -> Vec2f: ...
@overload
def Lerp(arg1: float, arg2: Vec3f | list[float] | tuple[float, float, float], arg3: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def Lerp(arg1: float, arg2: Vec4f | list[float] | tuple[float, float, float, float], arg3: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec4f: ...
@overload
def Lerp(arg1: float, arg2: Vec2d | list[float] | tuple[float, float], arg3: Vec2d | list[float] | tuple[float, float]) -> Vec2d: ...
@overload
def Lerp(arg1: float, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def Lerp(arg1: float, arg2: Vec4d | list[float] | tuple[float, float, float, float], arg3: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec4d: ...
@overload
def Lerpf(arg1: float, arg2: float, arg3: float) -> float: ...
@overload
def Lerpf(f) -> float: ...
def Log(arg1: float) -> float: ...
@overload
def Logf(f) -> float: ...
@overload
def Logf(arg1: float) -> float: ...
@overload
def Max(arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> float: ...
@overload
def Max(arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> int: ...
@overload
def Max(arg1: float, arg2: float, arg3: float, arg4: float) -> float: ...
@overload
def Max(arg1: int, arg2: int, arg3: int, arg4: int) -> int: ...
@overload
def Max(arg1: float, arg2: float, arg3: float) -> float: ...
@overload
def Max(arg1: int, arg2: int, arg3: int) -> int: ...
@overload
def Max(arg1: float, arg2: float) -> float: ...
@overload
def Max(arg1: int, arg2: int) -> int: ...
@overload
def Min(arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> float: ...
@overload
def Min(arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> int: ...
@overload
def Min(arg1: float, arg2: float, arg3: float, arg4: float) -> float: ...
@overload
def Min(arg1: int, arg2: int, arg3: int, arg4: int) -> int: ...
@overload
def Min(arg1: float, arg2: float, arg3: float) -> float: ...
@overload
def Min(arg1: int, arg2: int, arg3: int) -> int: ...
@overload
def Min(arg1: float, arg2: float) -> float: ...
@overload
def Min(arg1: int, arg2: int) -> int: ...
def Mod(arg1: float, arg2: float) -> float: ...
@overload
def Modf(arg1: float, arg2: float) -> float: ...
@overload
def Modf(f) -> float: ...
@overload
def Normalize(arg1: Vec2h | list[float] | tuple[float, float], arg2: object = ...) -> Any: ...
@overload
def Normalize(arg1: Vec2f | list[float] | tuple[float, float], arg2: float = ...) -> float: ...
@overload
def Normalize(arg1: Vec2d | list[float] | tuple[float, float], arg2: float = ...) -> float: ...
@overload
def Normalize(arg1: Vec3h | list[float] | tuple[float, float, float], arg2: object = ...) -> Any: ...
@overload
def Normalize(arg1: Vec3f | list[float] | tuple[float, float, float], arg2: float = ...) -> float: ...
@overload
def Normalize(arg1: Vec3d | list[float] | tuple[float, float, float], arg2: float = ...) -> float: ...
@overload
def Normalize(arg1: Vec4h | list[float] | tuple[float, float, float, float], arg2: object = ...) -> Any: ...
@overload
def Normalize(arg1: Vec4f | list[float] | tuple[float, float, float, float], arg2: float = ...) -> float: ...
@overload
def Normalize(arg1: Vec4d | list[float] | tuple[float, float, float, float], arg2: float = ...) -> float: ...
def Pow(arg1: float, arg2: float) -> float: ...
@overload
def Powf(arg1: float, arg2: float) -> float: ...
@overload
def Powf(f) -> float: ...
@overload
def Project(arg1: Vec4d | list[float] | tuple[float, float, float, float]) -> Vec3d: ...
@overload
def Project(arg1: Vec4f | list[float] | tuple[float, float, float, float]) -> Vec3f: ...
def RadiansToDegrees(arg1: float) -> float: ...
def Round(arg1: float) -> float: ...
@overload
def Roundf(f) -> float: ...
@overload
def Roundf(arg1: float) -> float: ...
@overload
def Sgn(arg1: float) -> float: ...
@overload
def Sgn(arg1: int) -> int: ...
@overload
def Slerp(arg1: float, arg2: Quatd | Quatf | Quath, arg3: Quatd | Quatf | Quath) -> Quatd: ...
@overload
def Slerp(arg1: float, arg2: Quatf | Quath, arg3: Quatf | Quath) -> Quatf: ...
@overload
def Slerp(arg1: float, arg2: Quath, arg3: Quath) -> Quath: ...
@overload
def Slerp(arg1: float, arg2: Quaternion, arg3: Quaternion) -> Quaternion: ...
@overload
def Slerp(arg1: float, arg2: Vec3h | list[float] | tuple[float, float, float], arg3: Vec3h | list[float] | tuple[float, float, float]) -> Vec3h: ...
@overload
def Slerp(arg1: float, arg2: Vec3f | list[float] | tuple[float, float, float], arg3: Vec3f | list[float] | tuple[float, float, float]) -> Vec3f: ...
@overload
def Slerp(arg1: float, arg2: Vec3d | list[float] | tuple[float, float, float], arg3: Vec3d | list[float] | tuple[float, float, float]) -> Vec3d: ...
@overload
def Sqr(arg1: float) -> float: ...
@overload
def Sqr(arg1: int) -> float: ...
@overload
def Sqr(arg1: Vec2i | list[int] | Size2 | tuple[int, int]) -> float: ...
@overload
def Sqr(arg1: Vec3i | list[int] | Size3 | tuple[int, int, int]) -> float: ...
@overload
def Sqr(arg1: Vec2f | list[float] | tuple[float, float]) -> float: ...
@overload
def Sqr(arg1: Vec3f | list[float] | tuple[float, float, float]) -> float: ...
@overload
def Sqr(arg1: Vec4f | list[float] | tuple[float, float, float, float]) -> float: ...
@overload
def Sqr(arg1: Vec2d | list[float] | tuple[float, float]) -> float: ...
@overload
def Sqr(arg1: Vec3d | list[float] | tuple[float, float, float]) -> float: ...
@overload
def Sqr(arg1: Vec4d | list[float] | tuple[float, float, float, float]) -> float: ...
def Sqrt(arg1: float) -> float: ...
@overload
def Sqrtf(f) -> float: ...
@overload
def Sqrtf(arg1: float) -> float: ...
def _HalfRoundTrip(arg1: object) -> Any: ...

# mypy: disable-error-code="misc, override, no-redef"

import Boost.Python
import pxr.Gf
import pxr.Tf
import typing
from _typeshed import Incomplete
from pxr.Ts.TsTest_Comparator import TsTest_Comparator as TsTest_Comparator
from pxr.Ts.TsTest_CompareBaseline import TsTest_CompareBaseline as TsTest_CompareBaseline
from pxr.Ts.TsTest_Grapher import TsTest_Grapher as TsTest_Grapher
from typing import Any, ClassVar, overload

ExtrapolationHeld: ExtrapolationType
ExtrapolationLinear: ExtrapolationType
KnotBezier: KnotType
KnotHeld: KnotType
KnotLinear: KnotType
Left: Side
Right: Side
__MFB_FULL_PACKAGE_NAME: str

class ExtrapolationType(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class KeyFrame(Boost.Python.instance):
    isDualValued: Incomplete
    knotType: KnotType
    leftLen: Incomplete
    leftSlope: Incomplete
    rightLen: Incomplete
    rightSlope: Incomplete
    tangentSymmetryBroken: bool
    time: Time
    value: Any
    @overload
    def __init__(self, time: float, leftValue: object, rightValue: object, knotType: object, leftSlope: object = ..., rightSlope: object = ..., leftLen: float = ..., rightLen: float = ...) -> None: ...
    @overload
    def __init__(self, time: float = ..., value: object = ..., knotType: object = ..., leftSlope: object = ..., rightSlope: object = ..., leftLen: float = ..., rightLen: float = ...) -> None: ...
    @overload
    def __init__(self, arg2: KeyFrame) -> None: ...
    @overload
    def CanSetKnotType(self, kf) -> typing.Any: ...
    @overload
    def CanSetKnotType(self, arg2: object) -> _AnnotatedBoolResult: ...
    def GetValue(self, arg2: object) -> Any: ...
    def IsEquivalentAtSide(self, arg2: KeyFrame, arg3: Side) -> bool: ...
    def SetValue(self, arg2: object, arg3: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def hasTangents(self): ...
    @property
    def isInterpolatable(self) -> bool: ...
    @property
    def supportsTangents(self): ...

class KnotType(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class LoopParams(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    looping: bool
    valueOffset: float
    @overload
    def __init__(self, arg2: bool, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetLoopedInterval(self) -> pxr.Gf.Interval: ...
    def GetMasterInterval(self) -> pxr.Gf.Interval: ...
    def IsValid(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def period(self) -> float: ...
    @property
    def preRepeatFrames(self) -> float: ...
    @property
    def repeatFrames(self) -> float: ...
    @property
    def start(self) -> float: ...

class Side(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class Spline(Boost.Python.instance):
    extrapolation: tuple[ExtrapolationType, ExtrapolationType]
    loopParams: LoopParams
    @overload
    def __init__(self, arg2: typing.Iterable[KeyFrame], arg3: ExtrapolationType = ..., arg4: ExtrapolationType = ..., arg5: LoopParams = ...) -> None: ...
    @overload
    def __init__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __init__(self, arg2: Spline) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def BakeSplineLoops(self) -> None: ...
    @overload
    def Breakdown(self, arg2: float, arg3: KnotType, arg4: bool, arg5: float, arg6: typing.Iterable[Any] = ...) -> tuple[None, pxr.Gf.Interval, KeyFrameMap]: ...
    @overload
    def Breakdown(self, arg2: typing.Iterable[float], arg3: typing.Iterable[KnotType], arg4: bool, arg5: float, arg6: typing.Iterable[Any]) -> dict: ...
    @overload
    def Breakdown(self, arg2: float, arg3: KnotType, arg4: bool, arg5: float, arg6: Any) -> dict: ...
    @overload
    def Breakdown(self, arg2: object, arg3: object, arg4: bool, arg5: float) -> dict: ...
    @overload
    def CanSetKeyFrame(self, kf) -> bool: ...
    @overload
    def CanSetKeyFrame(self, kf) -> typing.Any: ...
    @overload
    def CanSetKeyFrame(self, arg2: KeyFrame) -> _AnnotatedBoolResult: ...
    def ClearRedundantKeyFrames(self, defaultValue: Any = ..., intervals: pxr.Gf.MultiInterval = ...) -> bool: ...
    @overload
    def ClosestKeyFrame(self, time) -> TsKeyFrame: ...
    @overload
    def ClosestKeyFrame(self, arg2: float) -> Any: ...
    @overload
    def ClosestKeyFrameAfter(self, time) -> TsKeyFrame: ...
    @overload
    def ClosestKeyFrameAfter(self, arg2: float) -> Any: ...
    @overload
    def ClosestKeyFrameBefore(self, time) -> TsKeyFrame: ...
    @overload
    def ClosestKeyFrameBefore(self, arg2: float) -> Any: ...
    def DoSidesDiffer(self, time: float) -> bool: ...
    @overload
    def Eval(self, time: float, side: object = ...) -> Any: ...
    @overload
    def Eval(self, arg2: object) -> tuple: ...
    def EvalDerivative(self, arg2: float, side: Side = ...) -> Any: ...
    def EvalHeld(self, arg2: float, side: Side = ...) -> Any: ...
    def GetKeyFramesInMultiInterval(self, arg2: pxr.Gf.MultiInterval) -> list[KeyFrame]: ...
    def HasRedundantKeyFrames(self, defaultValue: Any = ...) -> bool: ...
    @overload
    def IsKeyFrameRedundant(self, arg2: float, arg3: Any = ...) -> bool: ...
    @overload
    def IsKeyFrameRedundant(self, arg2: KeyFrame, arg3: Any = ...) -> bool: ...
    def IsLinear(self) -> bool: ...
    @overload
    def IsSegmentFlat(self, arg2: float, arg3: float) -> bool: ...
    @overload
    def IsSegmentFlat(self, arg2: KeyFrame, arg3: KeyFrame) -> bool: ...
    @overload
    def IsSegmentValueMonotonic(self, arg2: float, arg3: float) -> bool: ...
    @overload
    def IsSegmentValueMonotonic(self, arg2: KeyFrame, arg3: KeyFrame) -> bool: ...
    def IsTimeLooped(self, arg2: float) -> bool: ...
    def IsVarying(self) -> bool: ...
    def IsVaryingSignificantly(self) -> bool: ...
    def Range(self, arg2: float, arg3: float) -> tuple: ...
    def Sample(self, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float) -> tuple: ...
    def SetKeyFrame(self, arg2: KeyFrame) -> None: ...
    @overload
    def SetKeyFrames(self, keyFrames) -> typing.Any: ...
    @overload
    def SetKeyFrames(self, arg2: object) -> None: ...
    def clear(self) -> None: ...
    def has_key(self, arg2: float) -> bool: ...
    def keys(self) -> list: ...
    def values(self) -> list: ...
    def __contains__(self, arg2: float) -> bool: ...
    @overload
    def __delitem__(self, arg2: float) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: float) -> KeyFrame: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def empty(self): ...
    @property
    def frameRange(self) -> pxr.Gf.Interval: ...
    @property
    def frames(self): ...
    @property
    def typeName(self) -> str: ...

class TsTest_Evaluator(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def BakeInnerLoops(self, splineData: TsTest_SplineData) -> TsTest_SplineData: ...
    def Eval(self, splineData: TsTest_SplineData, sampleTimes: TsTest_SampleTimes) -> list: ...
    def Sample(self, splineData: TsTest_SplineData, tolerance: float) -> list: ...

class TsTest_Museum(Boost.Python.instance):
    class DataId(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...
    Crossover: ClassVar[DataId] = ...
    Recurve: ClassVar[DataId] = ...
    SimpleInnerLoop: ClassVar[DataId] = ...
    TwoKnotBezier: ClassVar[DataId] = ...
    TwoKnotLinear: ClassVar[DataId] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetData(self) -> TsTest_SplineData: ...

class TsTest_Sample(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    time: Incomplete
    value: Incomplete
    @overload
    def __init__(self, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg2: TsTest_Sample) -> None: ...
    @overload
    def __init__(self) -> None: ...

class TsTest_SampleTimes(Boost.Python.instance):
    class SampleTime(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        pre: Incomplete
        time: Incomplete
        @overload
        def __init__(self, arg2: float, arg3: bool) -> None: ...
        @overload
        def __init__(self, arg2: float) -> None: ...
        @overload
        def __init__(self, arg2: SampleTime) -> None: ...
        @overload
        def __init__(self) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
    @overload
    def __init__(self, times: object = ...) -> None: ...
    @overload
    def __init__(self, arg2: TsTest_SplineData) -> None: ...
    def AddExtrapolationTimes(self, extrapolationFactor: float) -> None: ...
    def AddKnotTimes(self) -> None: ...
    def AddStandardTimes(self) -> None: ...
    def AddTimes(self, arg2: object) -> None: ...
    def AddUniformInterpolationTimes(self, numSamples: int) -> None: ...
    def GetTimes(self) -> list: ...

class TsTest_SplineData(Boost.Python.instance):
    class ExtrapMethod(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...

    class Extrapolation(Boost.Python.instance):
        loopMode: Incomplete
        method: Incomplete
        slope: Incomplete
        @overload
        def __init__(self, method: object = ..., slope: float = ..., loopMode: object = ...) -> None: ...
        @overload
        def __init__(self, arg2: Extrapolation) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...

    class Feature(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...

    class InnerLoopParams(Boost.Python.instance):
        closedEnd: Incomplete
        enabled: Incomplete
        postLoopEnd: Incomplete
        preLoopStart: Incomplete
        protoEnd: Incomplete
        protoStart: Incomplete
        valueOffset: Incomplete
        @overload
        def __init__(self, enabled: object = ..., protoStart: object = ..., protoEnd: object = ..., preLoopStart: object = ..., postLoopEnd: object = ..., closedEnd: object = ..., valueOffset: object = ...) -> None: ...
        @overload
        def __init__(self, arg2: InnerLoopParams) -> None: ...
        def IsValid(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...

    class InterpMethod(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...

    class Knot(Boost.Python.instance):
        isDualValued: Incomplete
        nextSegInterpMethod: Incomplete
        postAuto: Incomplete
        postLen: Incomplete
        postSlope: Incomplete
        preAuto: Incomplete
        preLen: Incomplete
        preSlope: Incomplete
        preValue: Incomplete
        time: Incomplete
        value: Incomplete
        @overload
        def __init__(self, time: object = ..., nextSegInterpMethod: object = ..., value: object = ..., preValue: object = ..., preSlope: object = ..., postSlope: object = ..., preLen: object = ..., postLen: object = ..., preAuto: object = ..., postAuto: object = ...) -> None: ...
        @overload
        def __init__(self, arg2: Knot) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...

    class LoopMode(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...
    ExtrapHeld: ClassVar[ExtrapMethod] = ...
    ExtrapLinear: ClassVar[ExtrapMethod] = ...
    ExtrapLoop: ClassVar[ExtrapMethod] = ...
    ExtrapSloped: ClassVar[ExtrapMethod] = ...
    FeatureBezierSegments: ClassVar[Feature] = ...
    FeatureDualValuedKnots: ClassVar[Feature] = ...
    FeatureExtrapolatingLoops: ClassVar[Feature] = ...
    FeatureHeldSegments: ClassVar[Feature] = ...
    FeatureHermiteSegments: ClassVar[Feature] = ...
    FeatureInnerLoops: ClassVar[Feature] = ...
    FeatureLinearSegments: ClassVar[Feature] = ...
    InterpCurve: ClassVar[InterpMethod] = ...
    InterpHeld: ClassVar[InterpMethod] = ...
    InterpLinear: ClassVar[InterpMethod] = ...
    LoopContinue: ClassVar[LoopMode] = ...
    LoopNone: ClassVar[LoopMode] = ...
    LoopOscillate: ClassVar[LoopMode] = ...
    LoopRepeat: ClassVar[LoopMode] = ...
    LoopReset: ClassVar[LoopMode] = ...
    def __init__(self, isHermite: bool = ..., knots: object = ..., preExtrapolation: object = ..., postExtrapolation: object = ..., innerLoopParams: object = ...) -> None: ...
    def AddKnot(self, knot: Knot) -> None: ...
    def GetDebugDescription(self) -> str: ...
    def GetInnerLoopParams(self) -> InnerLoopParams: ...
    def GetIsHermite(self) -> bool: ...
    def GetKnots(self) -> list: ...
    def GetPostExtrapolation(self) -> Extrapolation: ...
    def GetPreExtrapolation(self) -> Extrapolation: ...
    def GetRequiredFeatures(self) -> int: ...
    def SetInnerLoopParams(self, params: InnerLoopParams) -> None: ...
    def SetIsHermite(self, isHermite: bool) -> None: ...
    def SetKnots(self, knots: object) -> None: ...
    def SetPostExtrapolation(self, postExtrap: Extrapolation) -> None: ...
    def SetPreExtrapolation(self, preExtrap: Extrapolation) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class TsTest_TsEvaluator(TsTest_Evaluator):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...

class ValueSample(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isBlur(self): ...
    @property
    def leftTime(self): ...
    @property
    def leftValue(self): ...
    @property
    def rightTime(self): ...
    @property
    def rightValue(self): ...

class _AnnotatedBoolResult(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, arg2: bool, arg3: object) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> typing.Iterator[Any]: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def reasonWhyNot(self): ...

def SimplifySpline(arg1: Spline, arg2: pxr.Gf.MultiInterval, arg3: float) -> None: ...
def SimplifySplinesInParallel(arg1: typing.Iterable[pxr.Gf.MultiInterval], arg2: float, arg3: float) -> None: ...
def TsTest_SampleBezier(splineData: TsTest_SplineData, numSamples: int) -> list: ...

# mypy: disable-error-code="misc, override, no-redef"

import Boost.Python
import pxr.Ar
import pxr.Tf
import pxr.Vt
import types
import typing
import typing_extensions
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, overload

AngularUnitDegrees: AngularUnit
AngularUnitRadians: AngularUnit
AuthoringErrorUnrecognizedFields: AuthoringError
AuthoringErrorUnrecognizedSpecType: AuthoringError
DimensionlessUnitDefault: DimensionlessUnit
DimensionlessUnitPercent: DimensionlessUnit
Find: Callable
LengthUnitCentimeter: LengthUnit
LengthUnitDecimeter: LengthUnit
LengthUnitFoot: LengthUnit
LengthUnitInch: LengthUnit
LengthUnitKilometer: LengthUnit
LengthUnitMeter: LengthUnit
LengthUnitMile: LengthUnit
LengthUnitMillimeter: LengthUnit
LengthUnitYard: LengthUnit
ListOpTypeAdded: ListOpType
ListOpTypeAppended: ListOpType
ListOpTypeDeleted: ListOpType
ListOpTypeExplicit: ListOpType
ListOpTypeOrdered: ListOpType
ListOpTypePrepended: ListOpType
PermissionPrivate: Permission
PermissionPublic: Permission
SpecTypeAttribute: SpecType
SpecTypeConnection: SpecType
SpecTypeExpression: SpecType
SpecTypeMapper: SpecType
SpecTypeMapperArg: SpecType
SpecTypePrim: SpecType
SpecTypePseudoRoot: SpecType
SpecTypeRelationship: SpecType
SpecTypeRelationshipTarget: SpecType
SpecTypeUnknown: SpecType
SpecTypeVariant: SpecType
SpecTypeVariantSet: SpecType
SpecifierClass: Specifier
SpecifierDef: Specifier
SpecifierOver: Specifier
VariabilityUniform: Variability
VariabilityVarying: Variability
_PathElemsToPrefixes: Callable
__MFB_FULL_PACKAGE_NAME: str

class AngularUnit(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class AssetPath(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __init__(self, arg2: AssetPath | str) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def path(self): ...
    @property
    def resolvedPath(self): ...

class AssetPathArray(Boost.Python.instance):
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> Any: ...
    @overload
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...

class AttributeSpec(PropertySpec):
    ConnectionPathsKey: ClassVar[str] = ...
    DefaultValueKey: ClassVar[str] = ...
    DisplayUnitKey: ClassVar[str] = ...
    allowedTokens: pxr.Vt.TokenArray
    colorSpace: str
    displayUnit: pxr.Tf.Enum
    def __init__(self, owner: PrimSpec, name: str, typeName: ValueTypeName, variability: Variability = ..., custom: bool = ...) -> None: ...
    def ClearColorSpace(self) -> None: ...
    def HasColorSpace(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def connectionPathList(self) -> ConnectionsProxy: ...
    @property
    def expired(self): ...
    @property
    def roleName(self) -> str: ...
    @property
    def typeName(self): ...
    @property
    def valueType(self): ...

class AuthoringError(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class BatchNamespaceEdit(Boost.Python.instance):
    @overload
    def __init__(self, arg2: BatchNamespaceEdit) -> None: ...
    @overload
    def __init__(self, arg2: list[NamespaceEdit]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Add(self, arg2: Path | str, arg3: Path | str, arg4: int) -> None: ...
    @overload
    def Add(self, arg2: Path | str, arg3: Path | str) -> None: ...
    @overload
    def Add(self, arg2: NamespaceEdit) -> None: ...
    def Process(self, hasObjectAtPath: HasObjectAtPath, canEdit: CanEdit, fixBackpointers: bool = ...) -> tuple: ...
    @property
    def edits(self) -> list[NamespaceEdit]: ...

class ChangeBlock(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, enabled: bool = ...) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate(Boost.Python.instance):
    class ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: AttributeSpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_Iterator: ...
    def keys(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: AttributeSpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> AttributeSpec: ...
    @overload
    def __getitem__(self, arg2: int) -> AttributeSpec: ...
    def __iter__(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfAttributeViewPredicate_ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec__(Boost.Python.instance):
    class ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: AttributeSpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___Iterator: ...
    def keys(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: AttributeSpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> AttributeSpec: ...
    @overload
    def __getitem__(self, arg2: int) -> AttributeSpec: ...
    def __iter__(self) -> ChildrenView_Sdf_AttributeChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfAttributeSpec___ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec__(Boost.Python.instance):
    class ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: PrimSpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___Iterator: ...
    def keys(self) -> ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: PrimSpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> PrimSpec: ...
    @overload
    def __getitem__(self, arg2: int) -> PrimSpec: ...
    def __iter__(self) -> ChildrenView_Sdf_PrimChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPrimSpec___ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec__(Boost.Python.instance):
    class ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: PropertySpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___Iterator: ...
    def keys(self) -> ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: PropertySpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> PropertySpec: ...
    @overload
    def __getitem__(self, arg2: int) -> PropertySpec: ...
    def __iter__(self) -> ChildrenView_Sdf_PropertyChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfPropertySpec___ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate(Boost.Python.instance):
    class ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: RelationshipSpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_Iterator: ...
    def keys(self) -> ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: RelationshipSpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> RelationshipSpec: ...
    @overload
    def __getitem__(self, arg2: int) -> RelationshipSpec: ...
    def __iter__(self) -> ChildrenView_Sdf_RelationshipChildPolicy_SdfRelationshipViewPredicate_ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec__(Boost.Python.instance):
    class ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: VariantSpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___Iterator: ...
    def keys(self) -> ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: VariantSpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> VariantSpec: ...
    @overload
    def __getitem__(self, arg2: int) -> VariantSpec: ...
    def __iter__(self) -> ChildrenView_Sdf_VariantChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSpec___ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec__(Boost.Python.instance):
    class ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, arg2: object) -> Any: ...
    @overload
    def index(self, arg2: object) -> int: ...
    @overload
    def index(self, arg2: VariantSetSpec) -> int: ...
    def items(self) -> ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___Iterator: ...
    def keys(self) -> ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___KeyIterator: ...
    def values(self) -> ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___ValueIterator: ...
    @overload
    def __contains__(self, arg2: object) -> bool: ...
    @overload
    def __contains__(self, arg2: VariantSetSpec) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> VariantSetSpec: ...
    @overload
    def __getitem__(self, arg2: int) -> VariantSetSpec: ...
    def __iter__(self) -> ChildrenView_Sdf_VariantSetChildPolicy_SdfChildrenViewTrivialPredicate_SdfHandle_SdfVariantSetSpec___ValueIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class CleanupEnabler(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class DimensionlessUnit(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class FileFormat(Boost.Python.instance):
    class Tokens(Boost.Python.instance):
        TargetArg: ClassVar[str] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CanRead(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    @staticmethod
    def FindAllDerivedFileFormatExtensions(arg1: pxr.Tf.Type) -> list[str]: ...
    @staticmethod
    def FindAllFileFormatExtensions() -> list[str]: ...
    @overload
    @staticmethod
    def FindByExtension(extension: str | pxr.Ar.ResolvedPath, target: str | pxr.Ar.ResolvedPath = ...) -> FileFormat: ...
    @overload
    @staticmethod
    def FindByExtension(extension: str | pxr.Ar.ResolvedPath, args: dict[str | pxr.Ar.ResolvedPath, str | pxr.Ar.ResolvedPath]) -> FileFormat: ...
    @staticmethod
    def FindById(arg1: str | pxr.Ar.ResolvedPath) -> FileFormat: ...
    @staticmethod
    def FormatSupportsEditing(extension: str | pxr.Ar.ResolvedPath, target: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
    @staticmethod
    def FormatSupportsReading(extension: str | pxr.Ar.ResolvedPath, target: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
    @staticmethod
    def FormatSupportsWriting(extension: str | pxr.Ar.ResolvedPath, target: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
    @staticmethod
    def GetFileExtension(arg1: str | pxr.Ar.ResolvedPath) -> str: ...
    def GetFileExtensions(self) -> list[str]: ...
    def IsPackage(self) -> bool: ...
    def IsSupportedExtension(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SupportsEditing(self) -> bool: ...
    def SupportsReading(self) -> bool: ...
    def SupportsWriting(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...
    @property
    def fileCookie(self) -> str: ...
    @property
    def formatId(self) -> str: ...
    @property
    def primaryFileExtension(self) -> str: ...
    @property
    def target(self) -> str: ...

class Int64ListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: Int64ListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class IntListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: IntListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class Layer(Boost.Python.instance):
    class DetachedLayerRules(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        def __init__(self) -> None: ...
        def Exclude(self, arg2: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> Layer.DetachedLayerRules: ...
        def GetExcluded(self) -> list[str]: ...
        def GetIncluded(self) -> list[str]: ...
        def Include(self, arg2: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> Layer.DetachedLayerRules: ...
        def IncludeAll(self) -> Layer.DetachedLayerRules: ...
        def IncludedAll(self) -> bool: ...
        def IsIncluded(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    ColorConfigurationKey: ClassVar[str] = ...
    ColorManagementSystemKey: ClassVar[str] = ...
    CommentKey: ClassVar[str] = ...
    DocumentationKey: ClassVar[str] = ...
    EndFrameKey: ClassVar[str] = ...
    EndTimeCodeKey: ClassVar[str] = ...
    FramePrecisionKey: ClassVar[str] = ...
    FramesPerSecondKey: ClassVar[str] = ...
    HasOwnedSubLayers: ClassVar[str] = ...
    LayerRelocatesKey: ClassVar[str] = ...
    OwnerKey: ClassVar[str] = ...
    SessionOwnerKey: ClassVar[str] = ...
    StartFrameKey: ClassVar[str] = ...
    StartTimeCodeKey: ClassVar[str] = ...
    TimeCodesPerSecondKey: ClassVar[str] = ...
    colorConfiguration: AssetPath
    colorManagementSystem: str
    comment: str
    customLayerData: dict
    defaultPrim: str
    documentation: str
    endTimeCode: float
    expressionVariables: dict
    framePrecision: int
    framesPerSecond: float
    hasOwnedSubLayers: bool
    identifier: str
    owner: str
    relocates: Relocates
    rootPrimOrder: ListProxy_SdfNameTokenKeyPolicy
    sessionOwner: str
    startTimeCode: float
    subLayerPaths: ListProxy_SdfSubLayerTypePolicy
    timeCodesPerSecond: float
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def AddToMutedLayers(arg1: str | pxr.Ar.ResolvedPath) -> None: ...
    def Apply(self, arg2: BatchNamespaceEdit) -> bool: ...
    def ApplyRootPrimOrder(self, arg2: list[str] | list[pxr.Ar.ResolvedPath]) -> list: ...
    def CanApply(self, arg2: BatchNamespaceEdit) -> tuple[NamespaceEditDetail.Result, list[NamespaceEditDetail]]: ...
    def Clear(self) -> None: ...
    def ClearColorConfiguration(self) -> None: ...
    def ClearColorManagementSystem(self) -> None: ...
    def ClearCustomLayerData(self) -> None: ...
    def ClearDefaultPrim(self) -> None: ...
    def ClearEndTimeCode(self) -> None: ...
    def ClearExpressionVariables(self) -> None: ...
    def ClearFramePrecision(self) -> None: ...
    def ClearFramesPerSecond(self) -> None: ...
    def ClearOwner(self) -> None: ...
    def ClearRelocates(self) -> None: ...
    def ClearSessionOwner(self) -> None: ...
    def ClearStartTimeCode(self) -> None: ...
    def ClearTimeCodesPerSecond(self) -> None: ...
    def ComputeAbsolutePath(self, arg2: str | pxr.Ar.ResolvedPath) -> str: ...
    @overload
    @staticmethod
    def CreateAnonymous(tag: str | pxr.Ar.ResolvedPath, format: FileFormat, args: dict = ...) -> Layer: ...
    @overload
    @staticmethod
    def CreateAnonymous(tag: str | pxr.Ar.ResolvedPath = ..., args: dict = ...) -> Layer: ...
    @staticmethod
    def CreateIdentifier(arg1: str | pxr.Ar.ResolvedPath, arg2: dict[str | pxr.Ar.ResolvedPath, str | pxr.Ar.ResolvedPath]) -> str: ...
    @staticmethod
    def CreateNew(identifier: str | pxr.Ar.ResolvedPath, args: dict = ...) -> Layer: ...
    @staticmethod
    def DumpLayerInfo() -> None: ...
    def EraseTimeSample(self, arg2: Path | str, arg3: float) -> None: ...
    def Export(self, filename: str | pxr.Ar.ResolvedPath, comment: str | pxr.Ar.ResolvedPath = ..., args: dict = ...) -> bool: ...
    def ExportToString(self) -> str: ...
    @staticmethod
    def Find(identifier: str | pxr.Ar.ResolvedPath, args: dict = ...) -> Layer: ...
    @staticmethod
    def FindOrOpen(identifier: str | pxr.Ar.ResolvedPath, args: dict = ...) -> Layer: ...
    @staticmethod
    def FindOrOpenRelativeToLayer(anchor: Layer, identifier: str | pxr.Ar.ResolvedPath, args: dict = ...) -> Layer: ...
    @staticmethod
    def FindRelativeToLayer(anchor: Layer, assetPath: str | pxr.Ar.ResolvedPath, args: dict = ...) -> Layer: ...
    def GetAssetInfo(self) -> Any: ...
    def GetAssetName(self) -> str: ...
    def GetAttributeAtPath(self, arg2: Path | str) -> AttributeSpec: ...
    def GetBracketingTimeSamples(self, arg2: float) -> tuple: ...
    def GetBracketingTimeSamplesForPath(self, arg2: Path | str, arg3: float) -> tuple: ...
    def GetCompositionAssetDependencies(self) -> list[str]: ...
    @staticmethod
    def GetDetachedLayerRules() -> Layer.DetachedLayerRules: ...
    def GetDisplayName(self) -> str: ...
    @staticmethod
    def GetDisplayNameFromIdentifier(arg1: str | pxr.Ar.ResolvedPath) -> str: ...
    def GetExternalAssetDependencies(self) -> list[str]: ...
    def GetExternalReferences(self) -> tuple: ...
    def GetFileFormat(self) -> FileFormat: ...
    def GetFileFormatArguments(self) -> dict[str, str]: ...
    @staticmethod
    def GetLoadedLayers() -> list[Layer]: ...
    @staticmethod
    def GetMutedLayers() -> list[str]: ...
    def GetNumTimeSamplesForPath(self, arg2: Path | str) -> int: ...
    def GetObjectAtPath(self, arg2: Path | str) -> Spec: ...
    def GetPrimAtPath(self, arg2: Path | str) -> PrimSpec: ...
    def GetPropertyAtPath(self, arg2: Path | str) -> PropertySpec: ...
    def GetRelationshipAtPath(self, arg2: Path | str) -> RelationshipSpec: ...
    def HasColorConfiguration(self) -> bool: ...
    def HasColorManagementSystem(self) -> bool: ...
    def HasCustomLayerData(self) -> bool: ...
    def HasDefaultPrim(self) -> bool: ...
    def HasEndTimeCode(self) -> bool: ...
    def HasExpressionVariables(self) -> bool: ...
    def HasFramePrecision(self) -> bool: ...
    def HasFramesPerSecond(self) -> bool: ...
    def HasOwner(self) -> bool: ...
    def HasRelocates(self) -> bool: ...
    def HasSessionOwner(self) -> bool: ...
    def HasStartTimeCode(self) -> bool: ...
    def HasTimeCodesPerSecond(self) -> bool: ...
    def Import(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def ImportFromString(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    @staticmethod
    def IsAnonymousLayerIdentifier(arg1: str | pxr.Ar.ResolvedPath) -> bool: ...
    def IsDetached(self) -> bool: ...
    @staticmethod
    def IsIncludedByDetachedLayerRules(arg1: str | pxr.Ar.ResolvedPath) -> bool: ...
    def IsMuted(self) -> bool: ...
    def ListAllTimeSamples(self) -> list[float]: ...
    def ListTimeSamplesForPath(self, arg2: Path | str) -> list[float]: ...
    @staticmethod
    def New(fileFormat: FileFormat, identifier: str | pxr.Ar.ResolvedPath, args: dict = ...) -> Layer: ...
    @staticmethod
    def OpenAsAnonymous(filePath: str | pxr.Ar.ResolvedPath = ..., metadataOnly: bool = ..., tag: str | pxr.Ar.ResolvedPath = ...) -> Layer: ...
    def QueryTimeSample(self, arg2: Path | str, arg3: float) -> Any: ...
    def Reload(self, force: bool = ...) -> bool: ...
    @staticmethod
    def ReloadLayers(arg1: typing.Iterable[Layer], force: bool = ...) -> bool: ...
    @staticmethod
    def RemoveFromMutedLayers(arg1: str | pxr.Ar.ResolvedPath) -> None: ...
    def RemoveInertSceneDescription(self) -> None: ...
    def Save(self, force: bool = ...) -> bool: ...
    def ScheduleRemoveIfInert(self, arg2: Spec) -> None: ...
    @staticmethod
    def SetDetachedLayerRules(arg1: Layer.DetachedLayerRules) -> None: ...
    def SetMuted(self, arg2: bool) -> None: ...
    def SetPermissionToEdit(self, arg2: bool) -> None: ...
    def SetPermissionToSave(self, arg2: bool) -> None: ...
    def SetTimeSample(self, arg2: Path | str, arg3: float, arg4: object) -> None: ...
    @staticmethod
    def SplitIdentifier(arg1: str | pxr.Ar.ResolvedPath) -> tuple: ...
    def StreamsData(self) -> bool: ...
    def TransferContent(self, arg2: Layer) -> None: ...
    def Traverse(self, path: Path | str, func: TraversalFunction) -> None: ...
    def UpdateAssetInfo(self) -> None: ...
    def UpdateCompositionAssetDependency(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> bool: ...
    def UpdateExternalReference(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> bool: ...
    def _WriteDataFile(self, arg2: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def anonymous(self): ...
    @property
    def dirty(self): ...
    @property
    def empty(self): ...
    @property
    def expired(self): ...
    @property
    def externalReferences(self) -> list[str]: ...
    @property
    def fileExtension(self) -> str: ...
    @property
    def permissionToEdit(self): ...
    @property
    def permissionToSave(self): ...
    @property
    def pseudoRoot(self) -> PrimSpec: ...
    @property
    def realPath(self) -> str: ...
    @property
    def repositoryPath(self) -> str: ...
    @property
    def resolvedPath(self) -> pxr.Ar.ResolvedPath: ...
    @property
    def rootPrims(self) -> RootPrimsView: ...
    @property
    def subLayerOffsets(self) -> list[LayerOffset]: ...
    @property
    def version(self) -> str: ...

class LayerOffset(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, offset: float = ..., scale: float = ...) -> None: ...
    @overload
    def __init__(self, arg2: LayerOffset) -> None: ...
    def GetInverse(self) -> LayerOffset: ...
    def IsIdentity(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __mul__(self, arg2: LayerOffset) -> Any: ...
    @overload
    def __mul__(self, arg2: TimeCode | float) -> Any: ...
    @overload
    def __mul__(self, arg2: float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def offset(self) -> float: ...
    @property
    def scale(self) -> float: ...

class LayerTree(Boost.Python.instance):
    @overload
    def __init__(self, arg2: Layer, arg3: object, arg4: LayerOffset) -> None: ...
    @overload
    def __init__(self, arg2: Layer, arg3: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def childTrees(self) -> list[LayerTree]: ...
    @property
    def expired(self): ...
    @property
    def layer(self) -> Layer: ...
    @property
    def offset(self) -> LayerOffset: ...

class LengthUnit(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class ListEditorProxy_SdfNameKeyPolicy(Boost.Python.instance):
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def Add(self, arg2: object) -> None: ...
    def Append(self, arg2: object) -> None: ...
    @overload
    def ApplyEditsToList(self, arg2: object, arg3: object) -> list: ...
    @overload
    def ApplyEditsToList(self, arg2: object) -> list: ...
    def ClearEdits(self) -> bool: ...
    def ClearEditsAndMakeExplicit(self) -> bool: ...
    def ContainsItemEdit(self, item: object, onlyAddOrExplicit: bool = ...) -> bool: ...
    def CopyItems(self, arg2: ListEditorProxy_SdfNameKeyPolicy) -> bool: ...
    def Erase(self, arg2: object) -> None: ...
    def GetAddedOrExplicitItems(self) -> tuple: ...
    def GetAppliedItems(self) -> tuple: ...
    def ModifyItemEdits(self, arg2: object) -> None: ...
    def Prepend(self, arg2: object) -> None: ...
    def Remove(self, arg2: object) -> None: ...
    def RemoveItemEdits(self, arg2: object) -> None: ...
    def ReplaceItemEdits(self, arg2: object, arg3: object) -> None: ...
    @property
    def isExpired(self): ...
    @property
    def isExplicit(self): ...
    @property
    def isOrderedOnly(self): ...

class ListEditorProxy_SdfPathKeyPolicy(Boost.Python.instance):
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def Add(self, arg2: Path | str) -> None: ...
    def Append(self, arg2: Path | str) -> None: ...
    @overload
    def ApplyEditsToList(self, arg2: object, arg3: object) -> list: ...
    @overload
    def ApplyEditsToList(self, arg2: object) -> list: ...
    def ClearEdits(self) -> bool: ...
    def ClearEditsAndMakeExplicit(self) -> bool: ...
    def ContainsItemEdit(self, item: Path | str, onlyAddOrExplicit: bool = ...) -> bool: ...
    def CopyItems(self, arg2: ListEditorProxy_SdfPathKeyPolicy) -> bool: ...
    def Erase(self, arg2: Path | str) -> None: ...
    def GetAddedOrExplicitItems(self) -> tuple: ...
    def GetAppliedItems(self) -> tuple: ...
    def ModifyItemEdits(self, arg2: object) -> None: ...
    def Prepend(self, arg2: Path | str) -> None: ...
    def Remove(self, arg2: Path | str) -> None: ...
    def RemoveItemEdits(self, arg2: Path | str) -> None: ...
    def ReplaceItemEdits(self, arg2: Path | str, arg3: Path | str) -> None: ...
    @property
    def isExpired(self): ...
    @property
    def isExplicit(self): ...
    @property
    def isOrderedOnly(self): ...

class ListEditorProxy_SdfPayloadTypePolicy(Boost.Python.instance):
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def Add(self, arg2: Payload) -> None: ...
    def Append(self, arg2: Payload) -> None: ...
    @overload
    def ApplyEditsToList(self, arg2: object, arg3: object) -> list: ...
    @overload
    def ApplyEditsToList(self, arg2: object) -> list: ...
    def ClearEdits(self) -> bool: ...
    def ClearEditsAndMakeExplicit(self) -> bool: ...
    def ContainsItemEdit(self, item: Payload, onlyAddOrExplicit: bool = ...) -> bool: ...
    def CopyItems(self, arg2: ListEditorProxy_SdfPayloadTypePolicy) -> bool: ...
    def Erase(self, arg2: Payload) -> None: ...
    def GetAddedOrExplicitItems(self) -> tuple: ...
    def GetAppliedItems(self) -> tuple: ...
    def ModifyItemEdits(self, arg2: object) -> None: ...
    def Prepend(self, arg2: Payload) -> None: ...
    def Remove(self, arg2: Payload) -> None: ...
    def RemoveItemEdits(self, arg2: Payload) -> None: ...
    def ReplaceItemEdits(self, arg2: Payload, arg3: Payload) -> None: ...
    @property
    def isExpired(self): ...
    @property
    def isExplicit(self): ...
    @property
    def isOrderedOnly(self): ...

class ListEditorProxy_SdfReferenceTypePolicy(Boost.Python.instance):
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def Add(self, arg2: Reference) -> None: ...
    def Append(self, arg2: Reference) -> None: ...
    @overload
    def ApplyEditsToList(self, arg2: object, arg3: object) -> list: ...
    @overload
    def ApplyEditsToList(self, arg2: object) -> list: ...
    def ClearEdits(self) -> bool: ...
    def ClearEditsAndMakeExplicit(self) -> bool: ...
    def ContainsItemEdit(self, item: Reference, onlyAddOrExplicit: bool = ...) -> bool: ...
    def CopyItems(self, arg2: ListEditorProxy_SdfReferenceTypePolicy) -> bool: ...
    def Erase(self, arg2: Reference) -> None: ...
    def GetAddedOrExplicitItems(self) -> tuple: ...
    def GetAppliedItems(self) -> tuple: ...
    def ModifyItemEdits(self, arg2: object) -> None: ...
    def Prepend(self, arg2: Reference) -> None: ...
    def Remove(self, arg2: Reference) -> None: ...
    def RemoveItemEdits(self, arg2: Reference) -> None: ...
    def ReplaceItemEdits(self, arg2: Reference, arg3: Reference) -> None: ...
    @property
    def isExpired(self): ...
    @property
    def isExplicit(self): ...
    @property
    def isOrderedOnly(self): ...

class ListOpType(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class ListProxy_SdfNameKeyPolicy(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ApplyEditsToList(self, arg2: object) -> Any: ...
    def ApplyList(self, arg2: ListProxy_SdfNameKeyPolicy) -> None: ...
    def append(self, arg2: object) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> list: ...
    def count(self, arg2: object) -> int: ...
    def index(self, arg2: object) -> int: ...
    def insert(self, arg2: int, arg3: object) -> None: ...
    def remove(self, arg2: object) -> None: ...
    def replace(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __delitem__(self, arg2: int) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: int) -> str: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class ListProxy_SdfNameTokenKeyPolicy(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ApplyEditsToList(self, arg2: object) -> Any: ...
    def ApplyList(self, arg2: ListProxy_SdfNameTokenKeyPolicy) -> None: ...
    def append(self, arg2: object) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> list: ...
    def count(self, arg2: object) -> int: ...
    def index(self, arg2: object) -> int: ...
    def insert(self, arg2: int, arg3: object) -> None: ...
    def remove(self, arg2: object) -> None: ...
    def replace(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __delitem__(self, arg2: int) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: int) -> Any: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> typing.Iterator[Any]: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class ListProxy_SdfPathKeyPolicy(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ApplyEditsToList(self, arg2: object) -> Any: ...
    def ApplyList(self, arg2: ListProxy_SdfPathKeyPolicy) -> None: ...
    def append(self, arg2: Path | str) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> list: ...
    def count(self, arg2: Path | str) -> int: ...
    def index(self, arg2: Path | str) -> int: ...
    def insert(self, arg2: int, arg3: Path | str) -> None: ...
    def remove(self, arg2: Path | str) -> None: ...
    def replace(self, arg2: Path | str, arg3: Path | str) -> None: ...
    @overload
    def __delitem__(self, arg2: int) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    @overload
    def __delitem__(self, arg2: Path | str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: int) -> Path: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> typing.Iterator[Path]: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Path | str) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class ListProxy_SdfPayloadTypePolicy(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ApplyEditsToList(self, arg2: object) -> Any: ...
    def ApplyList(self, arg2: ListProxy_SdfPayloadTypePolicy) -> None: ...
    def append(self, arg2: Payload) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> list: ...
    def count(self, arg2: Payload) -> int: ...
    def index(self, arg2: Payload) -> int: ...
    def insert(self, arg2: int, arg3: Payload) -> None: ...
    def remove(self, arg2: Payload) -> None: ...
    def replace(self, arg2: Payload, arg3: Payload) -> None: ...
    @overload
    def __delitem__(self, arg2: int) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    @overload
    def __delitem__(self, arg2: Payload) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: int) -> Payload: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> typing.Iterator[Payload]: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Payload) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class ListProxy_SdfReferenceTypePolicy(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ApplyEditsToList(self, arg2: object) -> Any: ...
    def ApplyList(self, arg2: ListProxy_SdfReferenceTypePolicy) -> None: ...
    def append(self, arg2: Reference) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> list: ...
    def count(self, arg2: Reference) -> int: ...
    def index(self, arg2: Reference) -> int: ...
    def insert(self, arg2: int, arg3: Reference) -> None: ...
    def remove(self, arg2: Reference) -> None: ...
    def replace(self, arg2: Reference, arg3: Reference) -> None: ...
    @overload
    def __delitem__(self, arg2: int) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    @overload
    def __delitem__(self, arg2: Reference) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: int) -> Reference: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> typing.Iterator[Reference]: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: int, arg3: Reference) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class ListProxy_SdfSubLayerTypePolicy(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ApplyEditsToList(self, arg2: object) -> Any: ...
    def ApplyList(self, arg2: ListProxy_SdfSubLayerTypePolicy) -> None: ...
    def append(self, arg2: object) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> list: ...
    def count(self, arg2: object) -> int: ...
    def index(self, arg2: object) -> int: ...
    def insert(self, arg2: int, arg3: object) -> None: ...
    def remove(self, arg2: object) -> None: ...
    def replace(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __delitem__(self, arg2: int) -> None: ...
    @overload
    def __delitem__(self, arg2: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: int) -> str: ...
    @overload
    def __getitem__(self, arg2: object) -> list: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class MapEditProxy_VtDictionary(Boost.Python.instance):
    class MapEditProxy_VtDictionary_Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class MapEditProxy_VtDictionary_KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class MapEditProxy_VtDictionary_ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def copy(self, arg2: object) -> None: ...
    @overload
    def get(self, arg2: object, arg3: object) -> Any: ...
    @overload
    def get(self, arg2: object) -> Any: ...
    def items(self) -> MapEditProxy_VtDictionary_Iterator: ...
    def keys(self) -> MapEditProxy_VtDictionary_KeyIterator: ...
    def pop(self, arg2: object) -> Any: ...
    def popitem(self) -> tuple: ...
    def setdefault(self, arg2: object, arg3: object) -> Any: ...
    @overload
    def update(self, arg2: dict) -> None: ...
    @overload
    def update(self, arg2: list) -> None: ...
    def values(self) -> MapEditProxy_VtDictionary_ValueIterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg2: object) -> bool: ...
    def __delitem__(self, arg2: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: object) -> Any: ...
    def __iter__(self) -> MapEditProxy_VtDictionary_KeyIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath___(Boost.Python.instance):
    class MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def copy(self, arg2: object) -> None: ...
    @overload
    def get(self, arg2: Path | str, arg3: Path | str) -> Path: ...
    @overload
    def get(self, arg2: Path | str) -> Any: ...
    def items(self) -> MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____Iterator: ...
    def keys(self) -> MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____KeyIterator: ...
    def pop(self, arg2: Path | str) -> Path: ...
    def popitem(self) -> tuple: ...
    def setdefault(self, arg2: Path | str, arg3: Path | str) -> Path: ...
    @overload
    def update(self, arg2: dict) -> None: ...
    @overload
    def update(self, arg2: list) -> None: ...
    def values(self) -> MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____ValueIterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg2: Path | str) -> bool: ...
    def __delitem__(self, arg2: Path | str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: Path | str) -> Path: ...
    def __iter__(self) -> MapEditProxy___1_map_SdfPath__SdfPath____1_less_SdfPath_____1_allocator___1_pair_SdfPath_const__SdfPath____KeyIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, arg2: Path | str, arg3: Path | str) -> None: ...
    @property
    def expired(self): ...

class MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string___(Boost.Python.instance):
    class MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____KeyIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...

    class MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____ValueIterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Any: ...
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def copy(self, arg2: object) -> None: ...
    @overload
    def get(self, arg2: object, arg3: object) -> str: ...
    @overload
    def get(self, arg2: object) -> Any: ...
    def items(self) -> MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____Iterator: ...
    def keys(self) -> MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____KeyIterator: ...
    def pop(self, arg2: object) -> str: ...
    def popitem(self) -> tuple: ...
    def setdefault(self, arg2: object, arg3: object) -> str: ...
    @overload
    def update(self, arg2: dict) -> None: ...
    @overload
    def update(self, arg2: list) -> None: ...
    def values(self) -> MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____ValueIterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg2: object) -> bool: ...
    def __delitem__(self, arg2: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: object) -> str: ...
    def __iter__(self) -> MapEditProxy___1_map_string__string____1_less_string_____1_allocator___1_pair_stringconst__string____KeyIterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @property
    def expired(self): ...

class NamespaceEdit(Boost.Python.instance):
    atEnd: ClassVar[int] = ...  # read-only
    same: ClassVar[int] = ...  # read-only
    currentPath: Incomplete
    index: Incomplete
    newPath: Incomplete
    @overload
    def __init__(self, arg2: Path | str, arg3: Path | str, arg4: int = ...) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def Remove(arg1: Path | str) -> NamespaceEdit: ...
    @staticmethod
    def Rename(arg1: Path | str, arg2: str | pxr.Ar.ResolvedPath) -> NamespaceEdit: ...
    @staticmethod
    def Reorder(arg1: Path | str, arg2: int) -> NamespaceEdit: ...
    @staticmethod
    def Reparent(arg1: Path | str, arg2: Path | str, arg3: int) -> NamespaceEdit: ...
    @staticmethod
    def ReparentAndRename(arg1: Path | str, arg2: Path | str, arg3: str | pxr.Ar.ResolvedPath, arg4: int) -> NamespaceEdit: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class NamespaceEditDetail(Boost.Python.instance):
    class Result(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...
    Error: ClassVar[VariableExpression.Result] = ...
    Okay: ClassVar[VariableExpression.Result] = ...
    Unbatched: ClassVar[VariableExpression.Result] = ...
    edit: Incomplete
    reason: Incomplete
    result: Incomplete
    @overload
    def __init__(self, arg2: VariableExpression.Result, arg3: NamespaceEdit, arg4: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Notice(Boost.Python.instance):
    class Base(pxr.Tf.Notice):
        def __init__(self, *args, **kwargs) -> None: ...

    class LayerDidReloadContent(Notice.LayerDidReplaceContent):
        def __init__(self, *args, **kwargs) -> None: ...

    class LayerDidReplaceContent(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...

    class LayerDirtinessChanged(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...

    class LayerIdentifierDidChange(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def newIdentifier(self) -> str: ...
        @property
        def oldIdentifier(self) -> str: ...

    class LayerInfoDidChange(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...
        def key(self) -> Any: ...

    class LayerMutenessChanged(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def layerPath(self) -> str: ...
        @property
        def wasMuted(self): ...

    class LayersDidChange(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...
        def GetLayers(self) -> list: ...
        def GetSerialNumber(self) -> int: ...

    class LayersDidChangeSentPerLayer(Notice.Base):
        def __init__(self, *args, **kwargs) -> None: ...
        def GetLayers(self) -> list: ...
        def GetSerialNumber(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...

class OpaqueValue(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Path(Boost.Python.instance):
    class AncestorsRange(Boost.Python.instance):
        class _iterator(Boost.Python.instance):
            def __init__(self, *args, **kwargs) -> None: ...
            def __next__(self) -> Path: ...
        __instance_size__: ClassVar[int] = ...
        def __init__(self, arg2: Path | str) -> None: ...
        def GetPath(self) -> Path: ...
        def __iter__(self) -> _iterator: ...

    class _IsValidPathStringResult(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        def __init__(self, arg2: bool, arg3: object) -> None: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __getitem__(self, arg2: int) -> Any: ...
        def __iter__(self) -> typing.Iterator[Any]: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def errorMessage(self): ...
    absoluteRootPath: ClassVar[Path] = ...  # read-only
    emptyPath: ClassVar[Path] = ...  # read-only
    reflexiveRelativePath: ClassVar[Path] = ...  # read-only
    absoluteIndicator: ClassVar[str] = ...
    childDelimiter: ClassVar[str] = ...
    expressionIndicator: ClassVar[str] = ...
    mapperArgDelimiter: ClassVar[str] = ...
    mapperIndicator: ClassVar[str] = ...
    namespaceDelimiter: ClassVar[str] = ...
    parentPathElement: ClassVar[str] = ...
    propertyDelimiter: ClassVar[str] = ...
    relationshipTargetEnd: ClassVar[str] = ...
    relationshipTargetStart: ClassVar[str] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self, arg2: Path | str = ...) -> None: ...
    def AppendChild(self, arg2: str | pxr.Ar.ResolvedPath) -> Path: ...
    def AppendElementString(self, arg2: str | pxr.Ar.ResolvedPath) -> Path: ...
    def AppendExpression(self) -> Path: ...
    def AppendMapper(self, arg2: Path | str) -> Path: ...
    def AppendMapperArg(self, arg2: str | pxr.Ar.ResolvedPath) -> Path: ...
    def AppendPath(self, arg2: Path | str) -> Path: ...
    def AppendProperty(self, arg2: str | pxr.Ar.ResolvedPath) -> Path: ...
    def AppendRelationalAttribute(self, arg2: str | pxr.Ar.ResolvedPath) -> Path: ...
    def AppendTarget(self, arg2: Path | str) -> Path: ...
    def AppendVariantSelection(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> Path: ...
    def ContainsPrimVariantSelection(self) -> bool: ...
    def ContainsPropertyElements(self) -> bool: ...
    def ContainsTargetPath(self) -> bool: ...
    @staticmethod
    def FindLongestPrefix(arg2: Path | str) -> Any: ...
    @staticmethod
    def FindLongestStrictPrefix(arg2: Path | str) -> Any: ...
    @staticmethod
    def FindPrefixedRange(arg2: Path | str) -> Any: ...
    def GetAbsoluteRootOrPrimPath(self) -> Path: ...
    def GetAllTargetPathsRecursively(self) -> list: ...
    def GetAncestorsRange(self) -> AncestorsRange: ...
    def GetCommonPrefix(self, arg2: Path | str) -> Path: ...
    @staticmethod
    def GetConciseRelativePaths(arg1: typing.Iterable[Path | str]) -> list[Path]: ...
    def GetParentPath(self) -> Path: ...
    def GetPrefixes(self, numPrefixes: int = ...) -> list[Path]: ...
    def GetPrimOrPrimVariantSelectionPath(self) -> Path: ...
    def GetPrimPath(self) -> Path: ...
    def GetVariantSelection(self) -> tuple: ...
    def HasPrefix(self, arg2: Path | str) -> bool: ...
    def IsAbsolutePath(self) -> bool: ...
    def IsAbsoluteRootOrPrimPath(self) -> bool: ...
    def IsAbsoluteRootPath(self) -> bool: ...
    def IsExpressionPath(self) -> bool: ...
    def IsMapperArgPath(self) -> bool: ...
    def IsMapperPath(self) -> bool: ...
    def IsNamespacedPropertyPath(self) -> bool: ...
    def IsPrimPath(self) -> bool: ...
    def IsPrimPropertyPath(self) -> bool: ...
    def IsPrimVariantSelectionPath(self) -> bool: ...
    def IsPropertyPath(self) -> bool: ...
    def IsRelationalAttributePath(self) -> bool: ...
    def IsRootPrimPath(self) -> bool: ...
    def IsTargetPath(self) -> bool: ...
    @staticmethod
    def IsValidIdentifier(arg1: str | pxr.Ar.ResolvedPath) -> bool: ...
    @staticmethod
    def IsValidNamespacedIdentifier(arg1: str | pxr.Ar.ResolvedPath) -> bool: ...
    @staticmethod
    def IsValidPathString(arg1: str | pxr.Ar.ResolvedPath) -> _IsValidPathStringResult: ...
    @overload
    @staticmethod
    def JoinIdentifier(arg1: object, arg2: object) -> str: ...
    @overload
    @staticmethod
    def JoinIdentifier(arg1: object) -> str: ...
    def MakeAbsolutePath(self, arg2: Path | str) -> Path: ...
    def MakeRelativePath(self, arg2: Path | str) -> Path: ...
    @staticmethod
    def RemoveAncestorPaths(arg1: list[Path] | list[str]) -> list: ...
    def RemoveCommonSuffix(self, arg2: Path | str, stopAtRootPrim: bool = ...) -> tuple: ...
    @staticmethod
    def RemoveDescendentPaths(arg1: list[Path] | list[str]) -> list: ...
    def ReplaceName(self, arg2: str | pxr.Ar.ResolvedPath) -> Path: ...
    def ReplacePrefix(self, oldPrefix: Path | str, newPrefix: Path | str, fixTargetPaths: bool = ...) -> Path: ...
    def ReplaceTargetPath(self, arg2: Path | str) -> Path: ...
    def StripAllVariantSelections(self) -> Path: ...
    @staticmethod
    def StripNamespace(arg1: object) -> str: ...
    @staticmethod
    def StripPrefixNamespace(arg1: str | pxr.Ar.ResolvedPath, arg2: str | pxr.Ar.ResolvedPath) -> tuple: ...
    @staticmethod
    def TokenizeIdentifier(arg1: str | pxr.Ar.ResolvedPath) -> list[str]: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def elementString(self) -> str: ...
    @property
    def isEmpty(self) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def pathElementCount(self) -> int: ...
    @property
    def pathString(self): ...
    @property
    def targetPath(self) -> Path: ...

class PathArray(Boost.Python.instance):
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> Any: ...
    @overload
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...

class PathExpression(Boost.Python.instance):
    class ExpressionReference(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        name: Incomplete
        path: Incomplete
        def __init__(self) -> None: ...
        @staticmethod
        def Weaker() -> PathExpression.ExpressionReference: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...

    class Op(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...

    class PathPattern(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        def __init__(self) -> None: ...
        def AppendChild(self, text: object, predExpr: PredicateExpression = ...) -> None: ...
        def AppendProperty(self, text: object, predExpr: PredicateExpression = ...) -> None: ...
        def GetPrefix(self) -> Path: ...
        def GetText(self) -> str: ...
        def SetPrefix(self, prefix: Path | str) -> None: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
    Complement: ClassVar[PathExpression.Op] = ...
    Difference: ClassVar[PathExpression.Op] = ...
    ExpressionRef: ClassVar[PathExpression.Op] = ...
    ImpliedUnion: ClassVar[PathExpression.Op] = ...
    Intersection: ClassVar[PathExpression.Op] = ...
    Pattern: ClassVar[PathExpression.Op] = ...
    Union: ClassVar[PathExpression.Op] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, patternString: object, parseContext: object = ...) -> None: ...
    @overload
    def __init__(self, arg2: PathExpression) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComposeOver(self, weaker: PathExpression) -> PathExpression: ...
    def ContainsExpressionReferences(self) -> bool: ...
    def ContainsWeakerExpressionReference(self) -> bool: ...
    @staticmethod
    def Everything() -> PathExpression: ...
    def GetText(self) -> str: ...
    def IsAbsolute(self) -> bool: ...
    def IsComplete(self) -> bool: ...
    def IsEmpty(self) -> bool: ...
    def MakeAbsolute(self, anchor: Path | str) -> PathExpression: ...
    @overload
    @staticmethod
    def MakeAtom(ref: PathExpression.ExpressionReference) -> PathExpression: ...
    @overload
    @staticmethod
    def MakeAtom(pattern: PathExpression.PathPattern) -> PathExpression: ...
    @staticmethod
    def MakeComplement(right: PathExpression) -> PathExpression: ...
    @staticmethod
    def MakeOp(op: object, left: PathExpression, right: PathExpression) -> PathExpression: ...
    @staticmethod
    def Nothing() -> PathExpression: ...
    def ReplacePrefix(self, oldPrefix: Path | str, newPrefix: Path | str) -> PathExpression: ...
    def ResolveReferences(self, resolve: object) -> PathExpression: ...
    def Walk(self, logic: pxr.Tf.FunctionRef[None], ref: pxr.Tf.FunctionRef[None], pattern: pxr.Tf.FunctionRef[None]) -> None: ...
    @staticmethod
    def WeakerRef() -> PathExpression: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class PathListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: PathListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: Path | str) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class Payload(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    assetPath: str
    layerOffset: LayerOffset
    primPath: Path
    @overload
    def __init__(self, assetPath: object = ..., primPath: Path | str = ..., layerOffset: LayerOffset = ...) -> None: ...
    @overload
    def __init__(self, arg2: Payload) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class PayloadListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: PayloadListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: Payload) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class Permission(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class PredicateExpression(Boost.Python.instance):
    class FnArg(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        argName: Incomplete
        value: Incomplete
        @overload
        def __init__(self, arg2: PredicateExpression.FnArg) -> None: ...
        @overload
        def __init__(self) -> None: ...
        @staticmethod
        def Keyword(name: str | pxr.Ar.ResolvedPath, value: Any) -> PredicateExpression.FnArg: ...
        @staticmethod
        def Positional(value: Any) -> PredicateExpression.FnArg: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...

    class FnCall(Boost.Python.instance):
        class Kind(pxr.Tf.Tf_PyEnumWrapper):
            _baseName: ClassVar[str] = ...
            allValues: ClassVar[tuple] = ...
            def __init__(self, *args, **kwargs) -> None: ...
            @staticmethod
            def GetValueFromName(name: object) -> Any: ...
        BareCall: ClassVar[PredicateExpression.FnCall.Kind] = ...
        ColonCall: ClassVar[PredicateExpression.FnCall.Kind] = ...
        ParenCall: ClassVar[PredicateExpression.FnCall.Kind] = ...
        __instance_size__: ClassVar[int] = ...
        args: Incomplete
        funcName: Incomplete
        kind: Incomplete
        @overload
        def __init__(self, arg2: PredicateExpression.FnCall) -> None: ...
        @overload
        def __init__(self) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...

    class Op(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...

    class _PredicateExpressionFnArgVector(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        def __init__(self) -> None: ...
        def append(self, arg2: object) -> None: ...
        def extend(self, arg2: object) -> None: ...
        def __contains__(self, arg2: object) -> bool: ...
        def __delitem__(self, arg2: object) -> None: ...
        def __getitem__(self, arg2: object) -> Any: ...
        def __iter__(self) -> Any: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg2: object, arg3: object) -> None: ...
    And: ClassVar[PathExpression.Op] = ...
    Call: ClassVar[PathExpression.Op] = ...
    ImpliedAnd: ClassVar[PathExpression.Op] = ...
    Not: ClassVar[PathExpression.Op] = ...
    Or: ClassVar[PathExpression.Op] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, exprString: object, context: object = ...) -> None: ...
    @overload
    def __init__(self, arg2: PredicateExpression) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetParseError(self) -> str: ...
    def GetText(self) -> str: ...
    def IsEmpty(self) -> bool: ...
    @staticmethod
    def MakeCall(call: PredicateExpression.FnCall) -> PredicateExpression: ...
    @staticmethod
    def MakeNot(right: PredicateExpression) -> PredicateExpression: ...
    @staticmethod
    def MakeOp(op: PathExpression.Op, left: PredicateExpression, right: PredicateExpression) -> PredicateExpression: ...
    def Walk(self, logic: pxr.Tf.FunctionRef[None], call: pxr.Tf.FunctionRef[None]) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class PredicateFunctionResult(Boost.Python.instance):
    class Constancy(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @staticmethod
        def GetValueFromName(name: object) -> Any: ...
    ConstantOverDescendants: ClassVar[PredicateFunctionResult.Constancy] = ...
    MayVaryOverDescendants: ClassVar[PredicateFunctionResult.Constancy] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, value: bool, constancy: PredicateFunctionResult.Constancy = ...) -> None: ...
    @overload
    def __init__(self, arg2: PredicateFunctionResult) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetConstancy(self) -> PredicateFunctionResult.Constancy: ...
    def GetValue(self) -> bool: ...
    def IsConstant(self) -> bool: ...
    @staticmethod
    def MakeConstant(value: bool) -> PredicateFunctionResult: ...
    @staticmethod
    def MakeVarying(value: bool) -> PredicateFunctionResult: ...
    def SetAndPropagateConstancy(self, arg2: PredicateFunctionResult) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class PrimSpec(Spec):
    ActiveKey: ClassVar[str] = ...
    AnyTypeToken: ClassVar[str] = ...
    CommentKey: ClassVar[str] = ...
    CustomDataKey: ClassVar[str] = ...
    DisplayName: ClassVar[str] = ...
    DocumentationKey: ClassVar[str] = ...
    HiddenKey: ClassVar[str] = ...
    InheritPathsKey: ClassVar[str] = ...
    KindKey: ClassVar[str] = ...
    PayloadKey: ClassVar[str] = ...
    PermissionKey: ClassVar[str] = ...
    PrefixKey: ClassVar[str] = ...
    PrefixSubstitutionsKey: ClassVar[str] = ...
    PrimOrderKey: ClassVar[str] = ...
    PropertyOrderKey: ClassVar[str] = ...
    ReferencesKey: ClassVar[str] = ...
    RelocatesKey: ClassVar[str] = ...
    SpecializesKey: ClassVar[str] = ...
    SpecifierKey: ClassVar[str] = ...
    SymmetricPeerKey: ClassVar[str] = ...
    SymmetryArgumentsKey: ClassVar[str] = ...
    SymmetryFunctionKey: ClassVar[str] = ...
    TypeNameKey: ClassVar[str] = ...
    VariantSelectionKey: ClassVar[str] = ...
    VariantSetNamesKey: ClassVar[str] = ...
    active: bool
    assetInfo: MapEditProxy_VtDictionary
    comment: str
    customData: MapEditProxy_VtDictionary
    documentation: str
    hidden: bool
    instanceable: bool
    kind: str
    name: str
    nameChildrenOrder: ListProxy_SdfNameTokenKeyPolicy
    permission: Permission
    prefix: str
    prefixSubstitutions: dict
    propertyOrder: ListProxy_SdfNameTokenKeyPolicy
    relocates: RelocatesMapProxy
    specifier: Specifier
    suffix: str
    suffixSubstitutions: dict
    symmetricPeer: str
    symmetryArguments: MapEditProxy_VtDictionary
    symmetryFunction: str
    typeName: str
    @overload
    def __init__(self, parentPrim: PrimSpec, name: str, spec: Specifier, typeName: str = ...) -> None: ...
    @overload
    def __init__(self, parentLayer: Layer, name: str, spec: Specifier, typeName: str = ...) -> None: ...
    def ApplyNameChildrenOrder(self, arg2: list[str] | list[pxr.Ar.ResolvedPath]) -> list: ...
    def ApplyPropertyOrder(self, arg2: list[str] | list[pxr.Ar.ResolvedPath]) -> list: ...
    def BlockVariantSelection(self, arg2: str | pxr.Ar.ResolvedPath) -> None: ...
    def CanSetName(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def ClearActive(self) -> None: ...
    def ClearInstanceable(self) -> None: ...
    def ClearKind(self) -> None: ...
    def ClearPayloadList(self) -> None: ...
    def ClearReferenceList(self) -> None: ...
    def GetAttributeAtPath(self, arg2: Path | str) -> AttributeSpec: ...
    def GetObjectAtPath(self, arg2: Path | str) -> Spec: ...
    def GetPrimAtPath(self, arg2: Path | str) -> PrimSpec: ...
    def GetPropertyAtPath(self, arg2: Path | str) -> PropertySpec: ...
    def GetRelationshipAtPath(self, arg2: Path | str) -> RelationshipSpec: ...
    def GetVariantNames(self, arg2: str | pxr.Ar.ResolvedPath) -> list[str]: ...
    def HasActive(self) -> bool: ...
    def HasInstanceable(self) -> bool: ...
    def HasKind(self) -> bool: ...
    def RemoveProperty(self, arg2: PropertySpec) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def attributes(self) -> AttributeSpecView: ...
    @property
    def expired(self): ...
    @property
    def hasPayloads(self): ...
    @property
    def hasReferences(self): ...
    @property
    def inheritPathList(self) -> ListEditorProxy_SdfPathKeyPolicy: ...
    @property
    def nameChildren(self) -> NameChildrenView: ...
    @property
    def nameParent(self) -> PrimSpec: ...
    @property
    def nameRoot(self) -> PrimSpec: ...
    @property
    def payloadList(self) -> PayloadsProxy: ...
    @property
    def properties(self) -> PropertySpecView: ...
    @property
    def realNameParent(self) -> PrimSpec: ...
    @property
    def referenceList(self) -> ReferenceTypePolicy: ...
    @property
    def relationships(self) -> RelationshipSpecView: ...
    @property
    def specializesList(self) -> ListEditorProxy_SdfPathKeyPolicy: ...
    @property
    def variantSelections(self) -> VariantSelectionProxy: ...
    @property
    def variantSetNameList(self) -> ListEditorProxy_SdfNameKeyPolicy: ...
    @property
    def variantSets(self) -> VariantSetsProxy: ...

class PropertySpec(Spec):
    AssetInfoKey: ClassVar[str] = ...
    CommentKey: ClassVar[str] = ...
    CustomDataKey: ClassVar[str] = ...
    CustomKey: ClassVar[str] = ...
    DisplayGroupKey: ClassVar[str] = ...
    DisplayNameKey: ClassVar[str] = ...
    DocumentationKey: ClassVar[str] = ...
    HiddenKey: ClassVar[str] = ...
    PermissionKey: ClassVar[str] = ...
    PrefixKey: ClassVar[str] = ...
    SymmetricPeerKey: ClassVar[str] = ...
    SymmetryArgumentsKey: ClassVar[str] = ...
    SymmetryFunctionKey: ClassVar[str] = ...
    assetInfo: MapEditProxy_VtDictionary
    comment: str
    custom: Incomplete
    customData: MapEditProxy_VtDictionary
    default: Incomplete
    displayGroup: str
    displayName: str
    documentation: str
    hidden: bool
    name: str
    permission: Permission
    prefix: str
    symmetricPeer: str
    symmetryArguments: MapEditProxy_VtDictionary
    symmetryFunction: str
    def __init__(self, *args, **kwargs) -> None: ...
    def ClearDefaultValue(self) -> None: ...
    def HasDefaultValue(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...
    @property
    def hasOnlyRequiredFields(self): ...
    @property
    def owner(self) -> Spec: ...
    @property
    def variability(self) -> Variability: ...

class PseudoRootSpec(PrimSpec):
    def __init__(self, *args, **kwargs) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...

class Reference(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, assetPath: object = ..., primPath: Path | str = ..., layerOffset: LayerOffset = ..., customData: object = ...) -> None: ...
    @overload
    def __init__(self, arg2: Reference) -> None: ...
    def IsInternal(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def assetPath(self) -> str: ...
    @property
    def customData(self) -> dict: ...
    @property
    def layerOffset(self) -> LayerOffset: ...
    @property
    def primPath(self) -> Path: ...

class ReferenceListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: ReferenceListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: Reference) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class RelationshipSpec(PropertySpec):
    TargetsKey: ClassVar[str] = ...
    noLoadHint: Incomplete
    def __init__(self, owner: PrimSpec, name: str, custom: bool = ..., variability: Variability = ...) -> None: ...
    def RemoveTargetPath(self, arg2: Path | str, preserveTargetOrder: bool = ...) -> None: ...
    def ReplaceTargetPath(self, arg2: Path | str, arg3: Path | str) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...
    @property
    def targetPathList(self) -> TargetsProxy: ...

class Spec(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def ClearInfo(self, key: str | pxr.Ar.ResolvedPath) -> None: ...
    def GetAsText(self) -> str: ...
    def GetFallbackForInfo(self, arg2: str | pxr.Ar.ResolvedPath) -> Any: ...
    def GetInfo(self, arg2: str | pxr.Ar.ResolvedPath) -> Any: ...
    def GetMetaDataDisplayGroup(self, arg2: str | pxr.Ar.ResolvedPath) -> str: ...
    def GetMetaDataInfoKeys(self) -> list[str]: ...
    def GetTypeForInfo(self, arg2: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
    def HasInfo(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def IsInert(self, ignoreChildren: bool = ...) -> bool: ...
    def ListInfoKeys(self) -> list[str]: ...
    def SetInfo(self, arg2: str | pxr.Ar.ResolvedPath, arg3: Any) -> None: ...
    def SetInfoDictionaryValue(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath, arg4: Any) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...
    @property
    def isInert(self): ...
    @property
    def layer(self) -> Layer: ...
    @property
    def path(self) -> Path: ...

class SpecType(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class Specifier(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class StringListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: StringListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> StringListOp: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> StringListOp: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class TimeCode(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetValue(self) -> float: ...
    def __add__(self, arg2: TimeCode | float) -> Any: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __float__(self) -> float: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, arg2: TimeCode | float) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, arg2: float) -> Any: ...
    def __rmul__(self, arg2: float) -> Any: ...
    def __rsub__(self, arg2: float) -> Any: ...
    def __rtruediv__(self, arg2: float) -> Any: ...
    def __sub__(self, arg2: TimeCode | float) -> Any: ...
    def __truediv__(self, arg2: TimeCode | float) -> Any: ...

class TimeCodeArray(Boost.Python.instance):
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self, arg2: int, arg3: object) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self, arg2: int) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object) -> Any: ...
    @overload
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object) -> None: ...

class TokenListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: TokenListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class UInt64ListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: UInt64ListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class UIntListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: UIntListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: int) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class UnregisteredValue(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self, arg2: UnregisteredValue) -> None: ...
    @overload
    def __init__(self, arg2: UnregisteredValueListOp) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def value(self) -> Any: ...

class UnregisteredValueListOp(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    addedItems: Incomplete
    appendedItems: Incomplete
    deletedItems: Incomplete
    explicitItems: Incomplete
    orderedItems: Incomplete
    prependedItems: Incomplete
    def __init__(self) -> None: ...
    @overload
    def ApplyOperations(self, arg2: object) -> Any: ...
    @overload
    def ApplyOperations(self, arg2: UnregisteredValueListOp) -> Any: ...
    def Clear(self) -> None: ...
    def ClearAndMakeExplicit(self) -> None: ...
    @staticmethod
    def Create(prependedItems: object = ..., appendedItems: object = ..., deletedItems: object = ...) -> typing_extensions.Self: ...
    @staticmethod
    def CreateExplicit(explicitItems: object = ...) -> typing_extensions.Self: ...
    def GetAddedOrExplicitItems(self) -> Any: ...
    def GetAppliedItems(self) -> Any: ...
    def HasItem(self, arg2: UnregisteredValue) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def isExplicit(self): ...

class ValueBlock(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class ValueRoleNames(Boost.Python.instance):
    Color: ClassVar[str] = ...  # read-only
    EdgeIndex: ClassVar[str] = ...  # read-only
    FaceIndex: ClassVar[str] = ...  # read-only
    Frame: ClassVar[str] = ...  # read-only
    Group: ClassVar[str] = ...  # read-only
    Normal: ClassVar[str] = ...  # read-only
    Point: ClassVar[str] = ...  # read-only
    PointIndex: ClassVar[str] = ...  # read-only
    TextureCoordinate: ClassVar[str] = ...  # read-only
    Transform: ClassVar[str] = ...  # read-only
    Vector: ClassVar[str] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...

class ValueTypeName(Boost.Python.instance):
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def aliasesAsStrings(self): ...
    @property
    def arrayType(self) -> ValueTypeName: ...
    @property
    def cppTypeName(self): ...
    @property
    def defaultUnit(self) -> pxr.Tf.Enum: ...
    @property
    def defaultValue(self) -> Any: ...
    @property
    def isArray(self) -> bool: ...
    @property
    def isScalar(self) -> bool: ...
    @property
    def role(self) -> str: ...
    @property
    def scalarType(self) -> ValueTypeName: ...
    @property
    def type(self) -> pxr.Tf.Type: ...

class ValueTypeNames(Boost.Python.instance):
    Asset: ClassVar[ValueTypeName] = ...  # read-only
    AssetArray: ClassVar[ValueTypeName] = ...  # read-only
    Bool: ClassVar[ValueTypeName] = ...  # read-only
    BoolArray: ClassVar[ValueTypeName] = ...  # read-only
    Color3d: ClassVar[ValueTypeName] = ...  # read-only
    Color3dArray: ClassVar[ValueTypeName] = ...  # read-only
    Color3f: ClassVar[ValueTypeName] = ...  # read-only
    Color3fArray: ClassVar[ValueTypeName] = ...  # read-only
    Color3h: ClassVar[ValueTypeName] = ...  # read-only
    Color3hArray: ClassVar[ValueTypeName] = ...  # read-only
    Color4d: ClassVar[ValueTypeName] = ...  # read-only
    Color4dArray: ClassVar[ValueTypeName] = ...  # read-only
    Color4f: ClassVar[ValueTypeName] = ...  # read-only
    Color4fArray: ClassVar[ValueTypeName] = ...  # read-only
    Color4h: ClassVar[ValueTypeName] = ...  # read-only
    Color4hArray: ClassVar[ValueTypeName] = ...  # read-only
    Double: ClassVar[ValueTypeName] = ...  # read-only
    Double2: ClassVar[ValueTypeName] = ...  # read-only
    Double2Array: ClassVar[ValueTypeName] = ...  # read-only
    Double3: ClassVar[ValueTypeName] = ...  # read-only
    Double3Array: ClassVar[ValueTypeName] = ...  # read-only
    Double4: ClassVar[ValueTypeName] = ...  # read-only
    Double4Array: ClassVar[ValueTypeName] = ...  # read-only
    DoubleArray: ClassVar[ValueTypeName] = ...  # read-only
    Float: ClassVar[ValueTypeName] = ...  # read-only
    Float2: ClassVar[ValueTypeName] = ...  # read-only
    Float2Array: ClassVar[ValueTypeName] = ...  # read-only
    Float3: ClassVar[ValueTypeName] = ...  # read-only
    Float3Array: ClassVar[ValueTypeName] = ...  # read-only
    Float4: ClassVar[ValueTypeName] = ...  # read-only
    Float4Array: ClassVar[ValueTypeName] = ...  # read-only
    FloatArray: ClassVar[ValueTypeName] = ...  # read-only
    Frame4d: ClassVar[ValueTypeName] = ...  # read-only
    Frame4dArray: ClassVar[ValueTypeName] = ...  # read-only
    Group: ClassVar[ValueTypeName] = ...  # read-only
    Half: ClassVar[ValueTypeName] = ...  # read-only
    Half2: ClassVar[ValueTypeName] = ...  # read-only
    Half2Array: ClassVar[ValueTypeName] = ...  # read-only
    Half3: ClassVar[ValueTypeName] = ...  # read-only
    Half3Array: ClassVar[ValueTypeName] = ...  # read-only
    Half4: ClassVar[ValueTypeName] = ...  # read-only
    Half4Array: ClassVar[ValueTypeName] = ...  # read-only
    HalfArray: ClassVar[ValueTypeName] = ...  # read-only
    Int: ClassVar[ValueTypeName] = ...  # read-only
    Int2: ClassVar[ValueTypeName] = ...  # read-only
    Int2Array: ClassVar[ValueTypeName] = ...  # read-only
    Int3: ClassVar[ValueTypeName] = ...  # read-only
    Int3Array: ClassVar[ValueTypeName] = ...  # read-only
    Int4: ClassVar[ValueTypeName] = ...  # read-only
    Int4Array: ClassVar[ValueTypeName] = ...  # read-only
    Int64: ClassVar[ValueTypeName] = ...  # read-only
    Int64Array: ClassVar[ValueTypeName] = ...  # read-only
    IntArray: ClassVar[ValueTypeName] = ...  # read-only
    Matrix2d: ClassVar[ValueTypeName] = ...  # read-only
    Matrix2dArray: ClassVar[ValueTypeName] = ...  # read-only
    Matrix3d: ClassVar[ValueTypeName] = ...  # read-only
    Matrix3dArray: ClassVar[ValueTypeName] = ...  # read-only
    Matrix4d: ClassVar[ValueTypeName] = ...  # read-only
    Matrix4dArray: ClassVar[ValueTypeName] = ...  # read-only
    Normal3d: ClassVar[ValueTypeName] = ...  # read-only
    Normal3dArray: ClassVar[ValueTypeName] = ...  # read-only
    Normal3f: ClassVar[ValueTypeName] = ...  # read-only
    Normal3fArray: ClassVar[ValueTypeName] = ...  # read-only
    Normal3h: ClassVar[ValueTypeName] = ...  # read-only
    Normal3hArray: ClassVar[ValueTypeName] = ...  # read-only
    Opaque: ClassVar[ValueTypeName] = ...  # read-only
    PathExpression: ClassVar[ValueTypeName] = ...  # read-only
    PathExpressionArray: ClassVar[ValueTypeName] = ...  # read-only
    Point3d: ClassVar[ValueTypeName] = ...  # read-only
    Point3dArray: ClassVar[ValueTypeName] = ...  # read-only
    Point3f: ClassVar[ValueTypeName] = ...  # read-only
    Point3fArray: ClassVar[ValueTypeName] = ...  # read-only
    Point3h: ClassVar[ValueTypeName] = ...  # read-only
    Point3hArray: ClassVar[ValueTypeName] = ...  # read-only
    Quatd: ClassVar[ValueTypeName] = ...  # read-only
    QuatdArray: ClassVar[ValueTypeName] = ...  # read-only
    Quatf: ClassVar[ValueTypeName] = ...  # read-only
    QuatfArray: ClassVar[ValueTypeName] = ...  # read-only
    Quath: ClassVar[ValueTypeName] = ...  # read-only
    QuathArray: ClassVar[ValueTypeName] = ...  # read-only
    String: ClassVar[ValueTypeName] = ...  # read-only
    StringArray: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord2d: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord2dArray: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord2f: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord2fArray: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord2h: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord2hArray: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord3d: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord3dArray: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord3f: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord3fArray: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord3h: ClassVar[ValueTypeName] = ...  # read-only
    TexCoord3hArray: ClassVar[ValueTypeName] = ...  # read-only
    TimeCode: ClassVar[ValueTypeName] = ...  # read-only
    TimeCodeArray: ClassVar[ValueTypeName] = ...  # read-only
    Token: ClassVar[ValueTypeName] = ...  # read-only
    TokenArray: ClassVar[ValueTypeName] = ...  # read-only
    UChar: ClassVar[ValueTypeName] = ...  # read-only
    UCharArray: ClassVar[ValueTypeName] = ...  # read-only
    UInt: ClassVar[ValueTypeName] = ...  # read-only
    UInt64: ClassVar[ValueTypeName] = ...  # read-only
    UInt64Array: ClassVar[ValueTypeName] = ...  # read-only
    UIntArray: ClassVar[ValueTypeName] = ...  # read-only
    Vector3d: ClassVar[ValueTypeName] = ...  # read-only
    Vector3dArray: ClassVar[ValueTypeName] = ...  # read-only
    Vector3f: ClassVar[ValueTypeName] = ...  # read-only
    Vector3fArray: ClassVar[ValueTypeName] = ...  # read-only
    Vector3h: ClassVar[ValueTypeName] = ...  # read-only
    Vector3hArray: ClassVar[ValueTypeName] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def Find() -> ValueTypeName: ...

class Variability(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def GetValueFromName(name: object) -> Any: ...

class VariableExpression(Boost.Python.instance):
    class Result(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def errors(self): ...
        @property
        def usedVariables(self): ...
        @property
        def value(self): ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, expression: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Evaluate(self, vars: dict) -> VariableExpression.Result: ...
    def GetErrors(self) -> list[str]: ...
    @staticmethod
    def IsExpression(arg1: str | pxr.Ar.ResolvedPath) -> bool: ...
    @staticmethod
    def IsValidVariableType(arg1: Any) -> bool: ...
    def __bool__(self) -> bool: ...

class VariantSetSpec(Spec):
    @overload
    def __init__(self, prim: PrimSpec, name: str) -> None: ...
    @overload
    def __init__(self, prim: VariantSpec, name: str) -> None: ...
    def RemoveVariant(self, arg2: VariantSpec) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...
    @property
    def name(self) -> str: ...
    @property
    def owner(self) -> Spec: ...
    @property
    def variantList(self) -> list[VariantSpec]: ...
    @property
    def variants(self) -> VariantView: ...

class VariantSpec(Spec):
    def __init__(self, owner: VariantSetSpec, name: str) -> None: ...
    def GetVariantNames(self, arg2: str | pxr.Ar.ResolvedPath) -> list[str]: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...
    @property
    def name(self) -> str: ...
    @property
    def owner(self) -> VariantSetSpec: ...
    @property
    def primSpec(self) -> PrimSpec: ...
    @property
    def variantSets(self) -> VariantSetsProxy: ...

@overload
def Cat(arg1: AssetPathArray, arg2: AssetPathArray, arg3: AssetPathArray, arg4: AssetPathArray, arg5: AssetPathArray) -> AssetPathArray: ...
@overload
def Cat(arg1: PathArray, arg2: PathArray, arg3: PathArray, arg4: PathArray, arg5: PathArray) -> PathArray: ...
@overload
def Cat(arg1: TimeCodeArray, arg2: TimeCodeArray, arg3: TimeCodeArray, arg4: TimeCodeArray, arg5: TimeCodeArray) -> TimeCodeArray: ...
@overload
def Cat(arg1: AssetPathArray, arg2: AssetPathArray, arg3: AssetPathArray, arg4: AssetPathArray) -> AssetPathArray: ...
@overload
def Cat(arg1: PathArray, arg2: PathArray, arg3: PathArray, arg4: PathArray) -> PathArray: ...
@overload
def Cat(arg1: TimeCodeArray, arg2: TimeCodeArray, arg3: TimeCodeArray, arg4: TimeCodeArray) -> TimeCodeArray: ...
@overload
def Cat(arg1: AssetPathArray, arg2: AssetPathArray, arg3: AssetPathArray) -> AssetPathArray: ...
@overload
def Cat(arg1: PathArray, arg2: PathArray, arg3: PathArray) -> PathArray: ...
@overload
def Cat(arg1: TimeCodeArray, arg2: TimeCodeArray, arg3: TimeCodeArray) -> TimeCodeArray: ...
@overload
def Cat(arg1: AssetPathArray, arg2: AssetPathArray) -> AssetPathArray: ...
@overload
def Cat(arg1: PathArray, arg2: PathArray) -> PathArray: ...
@overload
def Cat(arg1: TimeCodeArray, arg2: TimeCodeArray) -> TimeCodeArray: ...
@overload
def Cat(arg1: AssetPathArray) -> AssetPathArray: ...
@overload
def Cat(arg1: PathArray) -> PathArray: ...
@overload
def Cat(arg1: TimeCodeArray) -> TimeCodeArray: ...
def ComputeAssetPathRelativeToLayer(anchor: Layer, assetPath: str | pxr.Ar.ResolvedPath) -> str: ...
def ConvertToValidMetadataDictionary(arg1: object) -> tuple: ...
def ConvertUnit(arg1: pxr.Tf.Enum, arg2: pxr.Tf.Enum) -> float: ...
@overload
def CopySpec(srcLayer: Layer, srcPath: Path | str, dstLayer: Layer, dstPath: Path | str, shouldCopyValueFn: ShouldCopyValueFn, shouldCopyChildrenFn: ShouldCopyChildrenFn) -> bool: ...
@overload
def CopySpec(srcLayer: Layer, srcPath: Path | str, dstLayer: Layer, dstPath: Path | str) -> bool: ...
def CreatePrimInLayer(arg1: Layer, arg2: Path | str) -> PrimSpec: ...
def CreateVariantInLayer(arg1: Layer, arg2: Path | str, arg3: str | pxr.Ar.ResolvedPath, arg4: str | pxr.Ar.ResolvedPath) -> VariantSpec: ...
@overload
def DefaultUnit(arg1: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Enum: ...
@overload
def DefaultUnit(arg1: pxr.Tf.Enum) -> pxr.Tf.Enum: ...
@overload
def Equal(arg1: AssetPathArray, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: AssetPath | str, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: AssetPathArray, arg2: AssetPath | str) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: AssetPathArray, arg2: tuple) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: AssetPathArray, arg2: list) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: list, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: PathArray, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: Path | str, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: PathArray, arg2: Path | str) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: PathArray, arg2: tuple) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: PathArray, arg2: list) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: list, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: TimeCodeArray, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: TimeCode | float, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: TimeCodeArray, arg2: TimeCode | float) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: TimeCodeArray, arg2: tuple) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: TimeCodeArray, arg2: list) -> pxr.Vt.BoolArray: ...
@overload
def Equal(arg1: list, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
def GetNameForUnit(arg1: pxr.Tf.Enum) -> str: ...
def GetTypeForValueTypeName(arg1: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
def GetUnitFromName(arg1: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Enum: ...
def GetValueTypeNameForValue(arg1: Any) -> ValueTypeName: ...
def JustCreatePrimAttributeInLayer(layer: Layer, attrPath: Path | str, typeName: ValueTypeName, variability: Variability = ..., isCustom: bool = ...) -> bool: ...
def JustCreatePrimInLayer(arg1: Layer, arg2: Path | str) -> bool: ...
@overload
def NotEqual(arg1: AssetPathArray, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: AssetPath | str, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: AssetPathArray, arg2: AssetPath | str) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: AssetPathArray, arg2: tuple) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: AssetPathArray, arg2: list) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: AssetPathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: PathArray, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: Path | str, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: PathArray, arg2: Path | str) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: PathArray, arg2: tuple) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: PathArray, arg2: list) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: PathArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: TimeCodeArray, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: TimeCode | float, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: TimeCodeArray, arg2: TimeCode | float) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: TimeCodeArray, arg2: tuple) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: TimeCodeArray, arg2: list) -> pxr.Vt.BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: TimeCodeArray) -> pxr.Vt.BoolArray: ...
def UnitCategory(arg1: pxr.Tf.Enum) -> str: ...
def ValueHasValidType(arg1: Any) -> bool: ...
def _DumpPathStats() -> None: ...
def _MakeBasicMatchEval(arg1: object) -> Any: ...
def _PathGetDebuggerPathText(arg1: Path | str) -> str: ...
def _PathStress() -> None: ...
def _TestTakeOwnership(arg1: object) -> None: ...

# mypy: disable-error-code="misc, override, no-redef"

import PySide6.QtCore
import PySide6.QtOpenGLWidgets
import pxr.CameraUtil as CameraUtil
import pxr.Gf as Gf
import pxr.Glf as Glf
import pxr.Sdf as Sdf
import pxr.Tf as Tf
import pxr.Usd as Usd
import pxr.UsdGeom as UsdGeom
import pxr.UsdImagingGL as UsdImagingGL
import pxr.Usdviewq.common
import pxr.Usdviewq.rootDataModel
from _typeshed import Incomplete
from pxr.Usdviewq.common import ColorCorrectionModes as ColorCorrectionModes, DefaultFontFamily as DefaultFontFamily, RenderModes as RenderModes, ReportMetricSize as ReportMetricSize, SelectionHighlightModes as SelectionHighlightModes, ShadedRenderModes as ShadedRenderModes, Timer as Timer
from pxr.Usdviewq.freeCamera import FreeCamera as FreeCamera
from pxr.Usdviewq.rootDataModel import RootDataModel as RootDataModel
from pxr.Usdviewq.selectionDataModel import SelectionDataModel as SelectionDataModel
from pxr.Usdviewq.viewSettingsDataModel import ViewSettingsDataModel as ViewSettingsDataModel
from typing import ClassVar

ALL_INSTANCES: int
DEBUG_CLIPPING: str

class FilledRect(Rect):
    _glslProgram: ClassVar[None] = ...
    _vao: ClassVar[int] = ...
    _vbo: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def compileProgram(self): ...
    def glDraw(self, color): ...

class GLSLProgram:
    def __init__(self, VS3, FS3, VS2, FS2, uniformDict) -> None: ...
    def uniform4f(self, param, x, y, z, w): ...

class HUD:
    class Group:
        def __init__(self, name, w, h) -> None: ...
    def __init__(self) -> None: ...
    def addGroup(self, name, w, h): ...
    def compileProgram(self): ...
    def draw(self, qglwidget): ...
    def updateGroup(self, name, x, y, col, dic, keys: Incomplete | None = ...): ...

class Mask(Prim2DDrawTask):
    def __init__(self) -> None: ...
    def updateColor(self, color): ...
    def updatePrims(self, croppedViewport, qglwidget): ...

class Outline(Prim2DDrawTask):
    def __init__(self) -> None: ...
    def updatePrims(self, croppedViewport, qglwidget): ...

class OutlineRect(Rect):
    _glslProgram: ClassVar[None] = ...
    _vao: ClassVar[int] = ...
    _vbo: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def compileProgram(self): ...
    def glDraw(self, color): ...

class Prim2DDrawTask:
    def __init__(self) -> None: ...
    def Execute(self, ctx): ...
    def Sync(self, ctx): ...

class Prim2DSetupTask:
    def __init__(self, viewport) -> None: ...
    def Execute(self, ctx): ...
    def Sync(self, ctx): ...

class Rect:
    def __init__(self) -> None: ...
    def _splitAlongX(self, x): ...
    def _splitAlongY(self, y): ...
    def difference(self, xywh): ...
    @classmethod
    def fromCorners(cls, c0, c1): ...
    @classmethod
    def fromXYWH(cls, xywh): ...
    def scaledAndBiased(self, sxy, txy): ...

class Reticles(Prim2DDrawTask):
    def __init__(self) -> None: ...
    def updateColor(self, color): ...
    def updatePrims(self, croppedViewport, qglwidget, inside, outside): ...

class StageView(PySide6.QtOpenGLWidgets.QOpenGLWidget):
    class DefaultDataModel(pxr.Usdviewq.rootDataModel.RootDataModel):
        staticMetaObject: ClassVar[PySide6.QtCore.QMetaObject] = ...
        def __init__(self) -> None: ...
        @property
        def selection(self): ...
        @property
        def viewSettings(self): ...
    signalBboxUpdateTimeChanged: ClassVar[PySide6.QtCore.Signal] = ...
    signalErrorMessage: ClassVar[PySide6.QtCore.Signal] = ...
    signalFrustumChanged: ClassVar[PySide6.QtCore.Signal] = ...
    signalMouseDrag: ClassVar[PySide6.QtCore.Signal] = ...
    signalPrimRollover: ClassVar[PySide6.QtCore.Signal] = ...
    signalPrimSelected: ClassVar[PySide6.QtCore.Signal] = ...
    signalSwitchedToFreeCam: ClassVar[PySide6.QtCore.Signal] = ...
    staticMetaObject: ClassVar[PySide6.QtCore.QMetaObject] = ...
    HUDStatKeys: Incomplete
    allowAsync: Incomplete
    cameraPrim: Incomplete
    camerasWithGuides: Incomplete
    fpsHUDInfo: Incomplete
    fpsHUDKeys: Incomplete
    renderParams: Incomplete
    rolloverPicking: Incomplete
    upperHUDInfo: Incomplete
    def __init__(self, parent: Incomplete | None = ..., dataModel: Incomplete | None = ..., makeTimer: type[pxr.Usdviewq.common.Timer] = ...) -> None: ...
    def DrawAxis(self, viewProjectionMatrix): ...
    def DrawCameraGuides(self, mvpMatrix): ...
    def ExportFreeCameraToStage(self, stage, defcamName: str = ..., imgWidth: Incomplete | None = ..., imgHeight: Incomplete | None = ...):
        """
        Export the free camera to the specified USD stage, if it is
        currently defined. If it is not active (i.e. we are viewing through
        a stage camera), raise a ValueError.
        """
    def ExportSession(self, stagePath, defcamName: str = ..., imgWidth: Incomplete | None = ..., imgHeight: Incomplete | None = ...):
        """
        Export the free camera (if currently active) and session layer to a
        USD file at the specified stagePath that references the current-viewed
        stage.
        """
    def GetCurrentRendererId(self): ...
    def GetRendererAovs(self): ...
    def GetRendererCommands(self): ...
    def GetRendererDisplayName(self, plugId): ...
    def GetRendererPlugins(self): ...
    def GetRendererSetting(self, name): ...
    def GetRendererSettingsList(self): ...
    def GetSimpleGLSLProgram(self): ...
    def InvokeRendererCommand(self, command): ...
    def IsPauseRendererSupported(self): ...
    def IsRendererConverged(self): ...
    def IsStopRendererSupported(self): ...
    def PollForAsynchronousUpdates(self): ...
    def SetForceRefresh(self, val): ...
    def SetRendererAov(self, aov): ...
    def SetRendererPaused(self, paused): ...
    def SetRendererPlugin(self, plugId): ...
    def SetRendererSetting(self, name, value): ...
    def SetRendererStopped(self, stopped): ...
    def _createNewFreeCamera(self, viewSettings, isZUp):
        """Creates a new free camera, persisting the previous camera settings
                (fov, aspect, clipping planes)."""
    def _getDefaultBBox(self): ...
    def _getEmptyBBox(self): ...
    def _getRenderer(self): ...
    def _handleRendererChanged(self, rendererId): ...
    def _isInfiniteBBox(self, bbox): ...
    def _onAutoComputeClippingChanged(self):
        """If we are currently rendering from a prim camera, switch to the
                FreeCamera.  Then reset the near/far clipping planes based on
                distance to closest geometry.  But only when autoClip has turned on!"""
    def _onFreeCameraSettingChanged(self):
        """Switch to the free camera if any of its settings have been modified.
        """
    def _primSelectionChanged(self): ...
    def _processBBoxes(self): ...
    def _processSelection(self): ...
    def _scaleMouseCoords(self, point): ...
    def _stageReplaced(self):
        """Set the USD Stage this widget will be displaying. To decommission
                (even temporarily) this widget, supply None as 'stage'."""
    def closeRenderer(self):
        """Close the current renderer."""
    def computeAndSetClosestDistance(self):
        """Using the current FreeCamera's frustum, determine the world-space
                closest rendered point to the camera.  Use that point
                to set our FreeCamera's closest visible distance."""
    def computeCameraViewport(self, cameraAspectRatio): ...
    def computePickFrustum(self, x, y): ...
    def computeWindowPolicy(self, cameraAspectRatio): ...
    def computeWindowSize(self): ...
    def computeWindowViewport(self): ...
    def copyViewState(self):
        """Returns a copy of this StageView's view-affecting state,
                which can be used later to restore the view via restoreViewState().
                Take note that we do NOT include the StageView's notion of the
                current time (used by prim-based cameras to extract their data),
                since we do not want a restore operation to put us out of sync
                with respect to our owner's time.
        """
    def drawHUD(self, renderer): ...
    def getActiveSceneCamera(self): ...
    def getSelectionBBox(self): ...
    def getStageBBox(self): ...
    def glDraw(self): ...
    def grabFrameBuffer(self, cropToAspectRatio: bool = ...):
        """
        Returns an image of the frame buffer. If cropToAspectRatio is True
        and the camera mask is shown, the image is cropped to the camera's
        aspect ratio.
        """
    def hasLockedAspectRatio(self):
        """True if the camera has a defined aspect ratio that should not change
                when the viewport is resized."""
    def initializeGL(self): ...
    def mouseMoveEvent(self, event): ...
    def mousePressEvent(self, event):
        """This widget claims the Alt modifier key as the enabler for camera
                manipulation, and will consume mousePressEvents when Alt is present.
                In any other modifier state, a mousePressEvent will result in a
                pick operation, and the pressed button and active modifiers will be
                made available to clients via a signalPrimSelected()."""
    def mouseReleaseEvent(self, event): ...
    def paintGL(self): ...
    def pick(self, pickFrustum):
        """
        Find closest point in scene rendered through 'pickFrustum'.
        Returns a sextuple:
          selectedPoint, selectedNormal, selectedPrimPath,
          selectedInstancerPath, selectedInstanceIndex, selectedInstancerContext
        """
    def pickObject(self, x, y, button, modifiers):
        """
        Render stage into fbo with each piece as a different color.
        Emits a signalPrimSelected or signalRollover depending on
        whether 'button' is None.
        """
    def recomputeBBox(self): ...
    def renderSinglePass(self, renderMode, renderSelHighlights): ...
    def resetCam(self, frameFit: float = ...): ...
    def resolveCamera(self):
        """Returns a tuple of the camera to use for rendering (either a scene
                camera or a free camera) and that camera's original aspect ratio.
                Depending on camera guide settings, the camera frustum may be conformed
                to fit the window viewport. Emits a signalFrustumChanged if the
                camera frustum has changed since the last time resolveCamera was called."""
    def restoreViewState(self, viewState):
        """Restore view parameters from 'viewState', and redraw"""
    def sizeHint(self): ...
    def switchToFreeCamera(self, computeAndSetClosestDistance: bool = ...):
        """
        If our current camera corresponds to a prim, create a FreeCamera
        that has the same view and use it.
        """
    def updateBboxPurposes(self): ...
    def updateForPlayback(self):
        """If playing, update the GL canvas.  Otherwise a no-op"""
    def updateGL(self):
        """We override this virtual so that we can make it a no-op during
                playback.  The client driving playback at a particular rate should
                instead call updateForPlayback() to image the next frame."""
    def updateSelection(self): ...
    def updateView(self, resetCam: bool = ..., forceComputeBBox: bool = ..., frameFit: float = ...):
        """Updates bounding boxes and camera. resetCam = True causes the camera to reframe
                the specified prims. frameFit sets the ratio of the camera's frustum's
                relevant dimension to the object's bounding box. 1.1, the default,
                fits the prim's bounding box in the frame with a roughly 10% margin.
        """
    def wheelEvent(self, event): ...
    @property
    def _cropImageToCameraViewport(self): ...
    @property
    def _fitCameraInViewport(self): ...
    @property
    def autoClip(self): ...
    @property
    def cameraFrustum(self): ...
    @property
    def gfCamera(self): ...
    @property
    def rendererAovName(self): ...
    @property
    def rendererDisplayName(self): ...
    @property
    def showReticles(self): ...

def ViewportMakeCenteredIntegral(viewport): ...
def _ComputeCameraFraming(viewport, renderBufferSize): ...

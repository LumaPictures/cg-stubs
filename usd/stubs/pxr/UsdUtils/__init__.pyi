# mypy: disable_error_code = misc
import Boost.Python
import pxr.UsdUtils.complianceChecker as complianceChecker
import pxr.UsdUtils.constantsGroup as constantsGroup
import pxr.UsdUtils.fixBrokenPixarSchemas as fixBrokenPixarSchemas
import pxr.Usd
import std
import pxr.UsdUtils.toolPaths as toolPaths
import typing
import typing_extensions
import pxr.UsdUtils.updateSchemaWithSdrNode as updateSchemaWithSdrNode
import pxr.UsdUtils.usdzUtils as usdzUtils
from pxr.UsdUtils.complianceChecker import ComplianceChecker as ComplianceChecker
from pxr.UsdUtils.fixBrokenPixarSchemas import FixBrokenPixarSchemas as FixBrokenPixarSchemas
from pxr.UsdUtils.updateSchemaWithSdrNode import PropertyDefiningKeys as PropertyDefiningKeys, SchemaDefiningKeys as SchemaDefiningKeys, SchemaDefiningMiscConstants as SchemaDefiningMiscConstants, UpdateSchemaWithSdrNode as UpdateSchemaWithSdrNode
from pxr.UsdUtils.usdzUtils import CheckUsdzCompliance as CheckUsdzCompliance, CreateUsdzPackage as CreateUsdzPackage, ExtractUsdzPackage as ExtractUsdzPackage, UsdzAssetIterator as UsdzAssetIterator
from typing import Any, ClassVar, overload

class CoalescingDiagnosticDelegate(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def DumpCoalescedDiagnosticsToStderr(self) -> None: ...
    def DumpCoalescedDiagnosticsToStdout(self) -> None: ...
    def DumpUncoalescedDiagnostics(self) -> None: ...
    def TakeCoalescedDiagnostics(self) -> list[CoalescingDiagnosticDelegate]: ...
    def TakeUncoalescedDiagnostics(self) -> list[std.unique_ptr[pxr.Tf.DiagnosticBase]]: ...
    def __reduce__(self) -> Any: ...

class CoalescingDiagnosticDelegateItem(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    @property
    def sharedItem(self) -> Any: ...
    @property
    def unsharedItems(self) -> Any: ...

class CoalescingDiagnosticDelegateSharedItem(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    @property
    def sourceFileName(self) -> Any: ...
    @property
    def sourceFunction(self) -> Any: ...
    @property
    def sourceLineNumber(self) -> Any: ...

class CoalescingDiagnosticDelegateUnsharedItem(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    @property
    def commentary(self) -> Any: ...
    @property
    def context(self) -> Any: ...

class ConditionalAbortDiagnosticDelegate(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, arg2: ConditionalAbortDiagnosticDelegateErrorFilters, arg3: ConditionalAbortDiagnosticDelegateErrorFilters) -> None: ...
    def __reduce__(self) -> Any: ...

class ConditionalAbortDiagnosticDelegateErrorFilters(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetCodePathFilters(self) -> list[str]: ...
    def GetStringFilters(self) -> list[str]: ...
    def SetCodePathFilters(self, codePathFilters: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> None: ...
    def SetStringFilters(self, stringFilters: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> None: ...
    def __reduce__(self) -> Any: ...

class RegisteredVariantSet(Boost.Python.instance):
    class SelectionExportPolicy(Boost.Python.enum):
        Always: ClassVar[RegisteredVariantSet.SelectionExportPolicy] = ...
        IfAuthored: ClassVar[RegisteredVariantSet.SelectionExportPolicy] = ...
        Never: ClassVar[RegisteredVariantSet.SelectionExportPolicy] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...
        __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def selectionExportPolicy(self) -> Any: ...

class SparseAttrValueWriter(Boost.Python.instance):
    def __init__(self, attr: pxr.Usd.Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output, defaultValue: object = ...) -> None: ...
    def SetTimeSample(self, value: object, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    def __reduce__(self) -> Any: ...

class SparseValueWriter(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def GetSparseAttrValueWriters(self) -> list[SparseAttrValueWriter]: ...
    def SetAttribute(self, attr: pxr.Usd.Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output, value: object, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def __reduce__(self) -> Any: ...

class StageCache(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    @classmethod
    def Get(cls) -> pxr.Usd.StageCache: ...
    @classmethod
    def GetSessionLayerForVariantSelections(cls, arg1: str | pxr.Ar.ResolvedPath, arg2: typing.Iterable[tuple[str | pxr.Ar.ResolvedPath, str | pxr.Ar.ResolvedPath]]) -> pxr.Sdf.Layer: ...
    def __reduce__(self) -> Any: ...

class TimeCodeRange(Boost.Python.instance):
    class Tokens(Boost.Python.instance):
        EmptyTimeCodeRange: ClassVar[Any] = ...  # read-only
        RangeSeparator: ClassVar[Any] = ...  # read-only
        StrideSeparator: ClassVar[Any] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...
        def __reduce__(self) -> Any: ...
    class _Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> pxr.Usd.TimeCode: ...
        def __reduce__(self) -> Any: ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, startTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, endTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, stride: float) -> None: ...
    @overload
    def __init__(self, startTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, endTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    @overload
    def __init__(self, timeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def CreateFromFrameSpec(cls, arg1: str | pxr.Ar.ResolvedPath) -> TimeCodeRange: ...
    def IsValid(self) -> bool: ...
    def empty(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __iter__(self) -> _Iterator: ...
    def __ne__(self, other: object) -> bool: ...
    def __reduce__(self) -> Any: ...
    @property
    def endTimeCode(self) -> pxr.Usd.TimeCode: ...
    @property
    def frameSpec(self) -> Any: ...
    @property
    def startTimeCode(self) -> pxr.Usd.TimeCode: ...
    @property
    def stride(self) -> float: ...

class UsdStageStatsKeys(Boost.Python.instance):
    activePrimCount: ClassVar[Any] = ...  # read-only
    approxMemoryInMb: ClassVar[Any] = ...  # read-only
    assetCount: ClassVar[Any] = ...  # read-only
    inactivePrimCount: ClassVar[Any] = ...  # read-only
    instanceCount: ClassVar[Any] = ...  # read-only
    instancedModelCount: ClassVar[Any] = ...  # read-only
    modelCount: ClassVar[Any] = ...  # read-only
    primCounts: ClassVar[Any] = ...  # read-only
    primCountsByType: ClassVar[Any] = ...  # read-only
    primary: ClassVar[Any] = ...  # read-only
    prototypeCount: ClassVar[Any] = ...  # read-only
    prototypes: ClassVar[Any] = ...  # read-only
    pureOverCount: ClassVar[Any] = ...  # read-only
    totalInstanceCount: ClassVar[Any] = ...  # read-only
    totalPrimCount: ClassVar[Any] = ...  # read-only
    untyped: ClassVar[Any] = ...  # read-only
    usedLayerCount: ClassVar[Any] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...

def AuthorCollection(collectionName: str | pxr.Ar.ResolvedPath, usdPrim: pxr.Usd.Prim, pathsToInclude: list[pxr.Sdf.Path] | list[str], pathsToExclude: list[pxr.Sdf.Path] | list[str] = ...) -> pxr.Usd.CollectionAPI: ...
def ComputeAllDependencies(assetPath: pxr.Sdf.AssetPath | str) -> tuple: ...
def ComputeCollectionIncludesAndExcludes(includedRootPaths: typing.Iterable[pxr.Sdf.Path | str], usdStage: pxr.Usd.Stage, minInclusionRatio: float = ..., maxNumExcludesBelowInclude: int = ..., minIncludeExcludeCollectionSize: int = ..., pathsToIgnore: PathHashSet = ...) -> tuple[list[pxr.Sdf.Path], list[pxr.Sdf.Path]]: ...
@overload
def ComputeUsdStageStats(arg1: str | pxr.Ar.ResolvedPath) -> tuple[pxr.Usd.Stage, dict]: ...
@overload
def ComputeUsdStageStats(arg1: pxr.Usd.Stage) -> tuple[int, dict]: ...
def CopyLayerMetadata(source: pxr.Sdf.Layer, destination: pxr.Sdf.Layer, skipSublayers: bool = ..., bakeUnauthoredFallbacks: bool = ...) -> bool: ...
def CreateCollections(assignments: typing.Iterable[tuple[str | pxr.Ar.ResolvedPath, typing.Iterable[pxr.Sdf.Path | str]]], usdPrim: pxr.Usd.Prim, minInclusionRatio: float = ..., maxNumExcludesBelowInclude: int = ..., minIncludeExcludeCollectionSize: int = ...) -> list[pxr.Usd.CollectionAPI]: ...
def CreateNewARKitUsdzPackage(assetPath: pxr.Sdf.AssetPath | str, usdzFilePath: str | pxr.Ar.ResolvedPath, firstLayerName: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def CreateNewUsdzPackage(assetPath: pxr.Sdf.AssetPath | str, usdzFilePath: str | pxr.Ar.ResolvedPath, firstLayerName: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def ExtractExternalReferences(filePath: str | pxr.Ar.ResolvedPath) -> tuple: ...
@overload
def FlattenLayerStack(stage: pxr.Usd.Stage, resolveAssetPathFn: ResolveAssetPathFn, tag: str | pxr.Ar.ResolvedPath = ...) -> pxr.Sdf.Layer: ...
@overload
def FlattenLayerStack(stage: pxr.Usd.Stage, tag: str | pxr.Ar.ResolvedPath = ...) -> pxr.Sdf.Layer: ...
def FlattenLayerStackResolveAssetPath(sourceLayer: pxr.Sdf.Layer, assetPath: str | pxr.Ar.ResolvedPath) -> str: ...
def GenerateClipManifestName(rootLayerName: str | pxr.Ar.ResolvedPath) -> str: ...
def GenerateClipTopologyName(rootLayerName: str | pxr.Ar.ResolvedPath) -> str: ...
def GetAlphaAttributeNameForColor(colorAttrName: str | pxr.Ar.ResolvedPath) -> str: ...
def GetDirtyLayers(stage: pxr.Usd.Stage, includeClipLayers: bool = ...) -> list[pxr.Sdf.Layer]: ...
def GetMaterialsScopeName(forceDefault: bool = ...) -> str: ...
def GetModelNameFromRootLayer(arg1: pxr.Sdf.Layer) -> str: ...
def GetPrefName() -> str: ...
def GetPrimAtPathWithForwarding(stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> pxr.Usd.Prim: ...
def GetPrimaryCameraName(forceDefault: bool = ...) -> str: ...
def GetPrimaryUVSetName() -> str: ...
def GetRegisteredVariantSets() -> list[RegisteredVariantSet]: ...
def ModifyAssetPaths(layer: pxr.Sdf.Layer, modifyFn: ModifyAssetPathFn) -> None: ...
def StitchClips(resultLayer: pxr.Sdf.Layer, clipLayerFiles: typing.Iterable[str | pxr.Ar.ResolvedPath], clipPath: pxr.Sdf.Path | str, startFrame: float = ..., endFrame: float = ..., interpolateMissingClipValues: bool = ..., clipSet: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def StitchClipsManifest(manifestLayer: pxr.Sdf.Layer, topologyLayer: pxr.Sdf.Layer, clipPath: typing.Iterable[str | pxr.Ar.ResolvedPath], clipLayerFiles: pxr.Sdf.Path | str) -> bool: ...
def StitchClipsTemplate(resultLayer: pxr.Sdf.Layer, topologyLayer: pxr.Sdf.Layer, manifestLayer: pxr.Sdf.Layer, clipPath: pxr.Sdf.Path | str, templatePath: str | pxr.Ar.ResolvedPath, startTimeCode: float, endTimeCode: float, stride: float, activeOffset: float = ..., interpolateMissingClipValues: bool = ..., clipSet: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def StitchClipsTopology(topologyLayer: pxr.Sdf.Layer, clipLayerFiles: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> bool: ...
def StitchInfo(strongObj: pxr.Sdf.Spec, weakObj: pxr.Sdf.Spec) -> None: ...
def StitchLayers(strongLayer: pxr.Sdf.Layer, weakLayer: pxr.Sdf.Layer) -> None: ...
def UninstancePrimAtPath(stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> pxr.Usd.Prim: ...
# mypy: disable-error-code="misc, override, no-redef"

import Boost.Python
import pxr.Ar
import pxr.Sdf
import pxr.Tf
import pxr.Usd
import pxr.UsdGeom
import pxr.UsdShade
import typing
import typing_extensions
from . import complianceChecker as complianceChecker, constantsGroup as constantsGroup, fixBrokenPixarSchemas as fixBrokenPixarSchemas, toolPaths as toolPaths, updateSchemaWithSdrNode as updateSchemaWithSdrNode, usdzUtils as usdzUtils
from pxr.UsdUtils.complianceChecker import ComplianceChecker as ComplianceChecker
from pxr.UsdUtils.fixBrokenPixarSchemas import FixBrokenPixarSchemas as FixBrokenPixarSchemas
from pxr.UsdUtils.updateSchemaWithSdrNode import PropertyDefiningKeys as PropertyDefiningKeys, SchemaDefiningKeys as SchemaDefiningKeys, SchemaDefiningMiscConstants as SchemaDefiningMiscConstants, UpdateSchemaWithSdrNode as UpdateSchemaWithSdrNode
from pxr.UsdUtils.usdzUtils import CheckUsdzCompliance as CheckUsdzCompliance, CreateUsdzPackage as CreateUsdzPackage, ExtractUsdzPackage as ExtractUsdzPackage, UsdzAssetIterator as UsdzAssetIterator
from typing import Any, ClassVar, overload

__MFB_FULL_PACKAGE_NAME: str

class CoalescingDiagnosticDelegate(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def DumpCoalescedDiagnosticsToStderr(self) -> None: ...
    def DumpCoalescedDiagnosticsToStdout(self) -> None: ...
    def DumpUncoalescedDiagnostics(self) -> None: ...
    def TakeCoalescedDiagnostics(self) -> list[CoalescingDiagnosticDelegate]: ...
    def TakeUncoalescedDiagnostics(self) -> list[[pxr.Tf.DiagnosticBase]]: ...

class CoalescingDiagnosticDelegateItem(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def sharedItem(self) -> Any: ...
    @property
    def unsharedItems(self) -> Any: ...

class CoalescingDiagnosticDelegateSharedItem(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def sourceFileName(self) -> Any: ...
    @property
    def sourceFunction(self) -> Any: ...
    @property
    def sourceLineNumber(self) -> Any: ...

class CoalescingDiagnosticDelegateUnsharedItem(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def commentary(self) -> Any: ...
    @property
    def context(self) -> Any: ...

class ConditionalAbortDiagnosticDelegate(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, arg2: ConditionalAbortDiagnosticDelegateErrorFilters, arg3: ConditionalAbortDiagnosticDelegateErrorFilters) -> None: ...

class ConditionalAbortDiagnosticDelegateErrorFilters(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: object, arg3: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetCodePathFilters(self) -> list[str]: ...
    def GetStringFilters(self) -> list[str]: ...
    def SetCodePathFilters(self, codePathFilters: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> None: ...
    def SetStringFilters(self, stringFilters: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> None: ...

class RegisteredVariantSet(Boost.Python.instance):
    class SelectionExportPolicy(Boost.Python.enum):
        Always: ClassVar[RegisteredVariantSet.SelectionExportPolicy] = ...
        IfAuthored: ClassVar[RegisteredVariantSet.SelectionExportPolicy] = ...
        Never: ClassVar[RegisteredVariantSet.SelectionExportPolicy] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...
        __slots__: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def name(self) -> Any: ...
    @property
    def selectionExportPolicy(self) -> Any: ...

class SparseAttrValueWriter(Boost.Python.instance):
    def __init__(self, attr: pxr.Usd.Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output, defaultValue: object = ...) -> None: ...
    def SetTimeSample(self, value: object, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...

class SparseValueWriter(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def GetSparseAttrValueWriters(self) -> list[SparseAttrValueWriter]: ...
    def SetAttribute(self, attr: pxr.Usd.Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output, value: object, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...

class StageCache(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    @classmethod
    def Get(cls) -> pxr.Usd.StageCache: ...
    @classmethod
    def GetSessionLayerForVariantSelections(cls, arg1: str | pxr.Ar.ResolvedPath, arg2: typing.Iterable[tuple[str | pxr.Ar.ResolvedPath, str | pxr.Ar.ResolvedPath]]) -> pxr.Sdf.Layer: ...

class TimeCodeRange(Boost.Python.instance):
    class Tokens(Boost.Python.instance):
        EmptyTimeCodeRange: ClassVar[str] = ...  # read-only
        RangeSeparator: ClassVar[str] = ...  # read-only
        StrideSeparator: ClassVar[str] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...

    class _Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> pxr.Usd.TimeCode: ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, startTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, endTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, stride: float) -> None: ...
    @overload
    def __init__(self, startTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, endTimeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    @overload
    def __init__(self, timeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def CreateFromFrameSpec(cls, arg1: str | pxr.Ar.ResolvedPath) -> TimeCodeRange: ...
    def IsValid(self) -> bool: ...
    def empty(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __iter__(self) -> _Iterator: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def endTimeCode(self) -> pxr.Usd.TimeCode: ...
    @property
    def frameSpec(self) -> Any: ...
    @property
    def startTimeCode(self) -> pxr.Usd.TimeCode: ...
    @property
    def stride(self) -> float: ...

class UsdStageStatsKeys(Boost.Python.instance):
    activePrimCount: ClassVar[str] = ...  # read-only
    approxMemoryInMb: ClassVar[str] = ...  # read-only
    assetCount: ClassVar[str] = ...  # read-only
    inactivePrimCount: ClassVar[str] = ...  # read-only
    instanceCount: ClassVar[str] = ...  # read-only
    instancedModelCount: ClassVar[str] = ...  # read-only
    modelCount: ClassVar[str] = ...  # read-only
    primCounts: ClassVar[str] = ...  # read-only
    primCountsByType: ClassVar[str] = ...  # read-only
    primary: ClassVar[str] = ...  # read-only
    prototypeCount: ClassVar[str] = ...  # read-only
    prototypes: ClassVar[str] = ...  # read-only
    pureOverCount: ClassVar[str] = ...  # read-only
    totalInstanceCount: ClassVar[str] = ...  # read-only
    totalPrimCount: ClassVar[str] = ...  # read-only
    untyped: ClassVar[str] = ...  # read-only
    usedLayerCount: ClassVar[str] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...

def AuthorCollection(collectionName: str | pxr.Ar.ResolvedPath, usdPrim: pxr.Usd.Prim, pathsToInclude: list[pxr.Sdf.Path] | list[str], pathsToExclude: list[pxr.Sdf.Path] | list[str] = ...) -> pxr.Usd.CollectionAPI: ...
def ComputeAllDependencies(assetPath: pxr.Sdf.AssetPath | str) -> tuple: ...
def ComputeCollectionIncludesAndExcludes(includedRootPaths: typing.Iterable[pxr.Sdf.Path | str], usdStage: pxr.Usd.Stage, minInclusionRatio: float = ..., maxNumExcludesBelowInclude: int = ..., minIncludeExcludeCollectionSize: int = ..., pathsToIgnore: PathHashSet = ...) -> tuple[list[pxr.Sdf.Path], list[pxr.Sdf.Path]]: ...
@overload
def ComputeUsdStageStats(arg1: str | pxr.Ar.ResolvedPath) -> tuple[pxr.Usd.Stage, dict]: ...
@overload
def ComputeUsdStageStats(arg1: pxr.Usd.Stage) -> tuple[int, dict]: ...
def CopyLayerMetadata(source: pxr.Sdf.Layer, destination: pxr.Sdf.Layer, skipSublayers: bool = ..., bakeUnauthoredFallbacks: bool = ...) -> bool: ...
def CreateCollections(assignments: typing.Iterable[tuple[str | pxr.Ar.ResolvedPath, typing.Iterable[pxr.Sdf.Path | str]]], usdPrim: pxr.Usd.Prim, minInclusionRatio: float = ..., maxNumExcludesBelowInclude: int = ..., minIncludeExcludeCollectionSize: int = ...) -> list[pxr.Usd.CollectionAPI]: ...
def CreateNewARKitUsdzPackage(assetPath: pxr.Sdf.AssetPath | str, usdzFilePath: str | pxr.Ar.ResolvedPath, firstLayerName: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def CreateNewUsdzPackage(assetPath: pxr.Sdf.AssetPath | str, usdzFilePath: str | pxr.Ar.ResolvedPath, firstLayerName: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def ExtractExternalReferences(filePath: str | pxr.Ar.ResolvedPath) -> tuple: ...
@overload
def FlattenLayerStack(stage: pxr.Usd.Stage, resolveAssetPathFn: ResolveAssetPathFn, tag: str | pxr.Ar.ResolvedPath = ...) -> pxr.Sdf.Layer: ...
@overload
def FlattenLayerStack(stage: pxr.Usd.Stage, tag: str | pxr.Ar.ResolvedPath = ...) -> pxr.Sdf.Layer: ...
def FlattenLayerStackResolveAssetPath(sourceLayer: pxr.Sdf.Layer, assetPath: str | pxr.Ar.ResolvedPath) -> str: ...
def GenerateClipManifestName(rootLayerName: str | pxr.Ar.ResolvedPath) -> str: ...
def GenerateClipTopologyName(rootLayerName: str | pxr.Ar.ResolvedPath) -> str: ...
def GetAlphaAttributeNameForColor(colorAttrName: str | pxr.Ar.ResolvedPath) -> str: ...
def GetDirtyLayers(stage: pxr.Usd.Stage, includeClipLayers: bool = ...) -> list[pxr.Sdf.Layer]: ...
def GetMaterialsScopeName(forceDefault: bool = ...) -> str: ...
def GetModelNameFromRootLayer(arg1: pxr.Sdf.Layer) -> str: ...
def GetPrefName() -> str: ...
def GetPrimAtPathWithForwarding(stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> pxr.Usd.Prim: ...
def GetPrimaryCameraName(forceDefault: bool = ...) -> str: ...
def GetPrimaryUVSetName() -> str: ...
def GetRegisteredVariantSets() -> list[RegisteredVariantSet]: ...
def ModifyAssetPaths(layer: pxr.Sdf.Layer, modifyFn: ModifyAssetPathFn) -> None: ...
def StitchClips(resultLayer: pxr.Sdf.Layer, clipLayerFiles: typing.Iterable[str | pxr.Ar.ResolvedPath], clipPath: pxr.Sdf.Path | str, startFrame: float = ..., endFrame: float = ..., interpolateMissingClipValues: bool = ..., clipSet: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def StitchClipsManifest(manifestLayer: pxr.Sdf.Layer, topologyLayer: pxr.Sdf.Layer, clipPath: typing.Iterable[str | pxr.Ar.ResolvedPath], clipLayerFiles: pxr.Sdf.Path | str) -> bool: ...
def StitchClipsTemplate(resultLayer: pxr.Sdf.Layer, topologyLayer: pxr.Sdf.Layer, manifestLayer: pxr.Sdf.Layer, clipPath: pxr.Sdf.Path | str, templatePath: str | pxr.Ar.ResolvedPath, startTimeCode: float, endTimeCode: float, stride: float, activeOffset: float = ..., interpolateMissingClipValues: bool = ..., clipSet: str | pxr.Ar.ResolvedPath = ...) -> bool: ...
def StitchClipsTopology(topologyLayer: pxr.Sdf.Layer, clipLayerFiles: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> bool: ...
def StitchInfo(strongObj: pxr.Sdf.Spec, weakObj: pxr.Sdf.Spec) -> None: ...
def StitchLayers(strongLayer: pxr.Sdf.Layer, weakLayer: pxr.Sdf.Layer) -> None: ...
def UninstancePrimAtPath(stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> pxr.Usd.Prim: ...

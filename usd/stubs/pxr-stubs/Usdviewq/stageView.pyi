from .common import ColorCorrectionModes as ColorCorrectionModes, DEBUG_CLIPPING as DEBUG_CLIPPING, DefaultFontFamily as DefaultFontFamily, RenderModes as RenderModes, ReportMetricSize as ReportMetricSize, SelectionHighlightModes as SelectionHighlightModes, ShadedRenderModes as ShadedRenderModes, Timer as Timer
from .freeCamera import FreeCamera as FreeCamera
from .qt import QGLFormat as QGLFormat, QGLWidget as QGLWidget, QtCore as QtCore, QtGui as QtGui, QtOpenGL as QtOpenGL, QtWidgets as QtWidgets
from .rootDataModel import RootDataModel as RootDataModel
from .selectionDataModel import ALL_INSTANCES as ALL_INSTANCES, SelectionDataModel as SelectionDataModel
from .viewSettingsDataModel import ViewSettingsDataModel as ViewSettingsDataModel
from _typeshed import Incomplete
from math import tan as tan
from pxr import CameraUtil as CameraUtil, Gf as Gf, Glf as Glf, Sdf as Sdf, Tf as Tf, Usd as Usd, UsdGeom as UsdGeom, UsdImagingGL as UsdImagingGL

def ViewportMakeCenteredIntegral(viewport): ...

class GLSLProgram:
    _glMajorVersion: Incomplete
    _glMinorVersion: Incomplete
    useVAO: Incomplete
    useSampleAlphaToCoverage: Incomplete
    program: Incomplete
    uniformLocations: Incomplete
    def __init__(self, VS3, FS3, VS2, FS2, uniformDict) -> None: ...
    def uniform4f(self, param, x, y, z, w) -> None: ...

class Rect:
    xywh: Incomplete
    def __init__(self) -> None: ...
    @classmethod
    def fromXYWH(cls, xywh): ...
    @classmethod
    def fromCorners(cls, c0, c1): ...
    def scaledAndBiased(self, sxy, txy): ...
    def _splitAlongY(self, y): ...
    def _splitAlongX(self, x): ...
    def difference(self, xywh): ...

class OutlineRect(Rect):
    _glslProgram: Incomplete
    _vbo: int
    _vao: int
    def __init__(self) -> None: ...
    @classmethod
    def compileProgram(self): ...
    def glDraw(self, color) -> None: ...

class FilledRect(Rect):
    _glslProgram: Incomplete
    _vbo: int
    _vao: int
    def __init__(self) -> None: ...
    @classmethod
    def compileProgram(self): ...
    def glDraw(self, color) -> None: ...

class Prim2DSetupTask:
    _viewport: Incomplete
    def __init__(self, viewport) -> None: ...
    def Sync(self, ctx) -> None: ...
    def Execute(self, ctx) -> None: ...

class Prim2DDrawTask:
    _prims: Incomplete
    _colors: Incomplete
    _pixelRatio: Incomplete
    def __init__(self) -> None: ...
    def Sync(self, ctx) -> None: ...
    def Execute(self, ctx) -> None: ...

class Outline(Prim2DDrawTask):
    _outlineColor: Incomplete
    def __init__(self) -> None: ...
    _prims: Incomplete
    _colors: Incomplete
    def updatePrims(self, croppedViewport, qglwidget) -> None: ...

class Reticles(Prim2DDrawTask):
    _outlineColor: Incomplete
    def __init__(self) -> None: ...
    def updateColor(self, color) -> None: ...
    _prims: Incomplete
    _colors: Incomplete
    def updatePrims(self, croppedViewport, qglwidget, inside, outside) -> None: ...

class Mask(Prim2DDrawTask):
    _maskColor: Incomplete
    def __init__(self) -> None: ...
    def updateColor(self, color) -> None: ...
    _prims: Incomplete
    _colors: Incomplete
    def updatePrims(self, croppedViewport, qglwidget) -> None: ...

class HUD:
    class Group:
        x: int
        y: int
        w: Incomplete
        h: Incomplete
        qimage: Incomplete
        painter: Incomplete
        def __init__(self, name, w, h) -> None: ...
    _pixelRatio: Incomplete
    _HUDLineSpacing: int
    _HUDFont: Incomplete
    _groups: Incomplete
    _glslProgram: Incomplete
    _vao: int
    def __init__(self) -> None: ...
    _vbo: Incomplete
    def compileProgram(self): ...
    def addGroup(self, name, w, h) -> None: ...
    def updateGroup(self, name, x, y, col, dic, keys: Incomplete | None = None): ...
    def draw(self, qglwidget) -> None: ...

def _ComputeCameraFraming(viewport, renderBufferSize): ...

class StageView(QGLWidget):
    """
    QGLWidget that displays a USD Stage.  A StageView requires a dataModel
    object from which it will query state it needs to properly image its
    given UsdStage.  See the nested DefaultDataModel class for the expected
    API.
    """
    class DefaultDataModel(RootDataModel):
        _selectionDataModel: Incomplete
        _viewSettingsDataModel: Incomplete
        def __init__(self) -> None: ...
        @property
        def selection(self): ...
        @property
        def viewSettings(self): ...
    signalBboxUpdateTimeChanged: Incomplete
    signalPrimSelected: Incomplete
    signalPrimRollover: Incomplete
    signalMouseDrag: Incomplete
    signalErrorMessage: Incomplete
    signalSwitchedToFreeCam: Incomplete
    signalFrustumChanged: Incomplete
    @property
    def renderParams(self): ...
    _renderParams: Incomplete
    @renderParams.setter  # type: ignore[no-redef]
    def renderParams(self, params) -> None: ...
    @property
    def autoClip(self): ...
    @property
    def showReticles(self): ...
    @property
    def _fitCameraInViewport(self): ...
    @property
    def _cropImageToCameraViewport(self): ...
    @property
    def cameraPrim(self): ...
    @cameraPrim.setter
    def cameraPrim(self, prim) -> None: ...
    @property
    def rolloverPicking(self): ...
    _rolloverPicking: Incomplete
    @rolloverPicking.setter  # type: ignore[no-redef]
    def rolloverPicking(self, enabled) -> None: ...
    @property
    def fpsHUDInfo(self): ...
    _fpsHUDInfo: Incomplete
    @fpsHUDInfo.setter  # type: ignore[no-redef]
    def fpsHUDInfo(self, info) -> None: ...
    @property
    def fpsHUDKeys(self): ...
    _fpsHUDKeys: Incomplete
    @fpsHUDKeys.setter  # type: ignore[no-redef]
    def fpsHUDKeys(self, keys) -> None: ...
    @property
    def upperHUDInfo(self): ...
    _upperHUDInfo: Incomplete
    @upperHUDInfo.setter  # type: ignore[no-redef]
    def upperHUDInfo(self, info) -> None: ...
    @property
    def HUDStatKeys(self): ...
    _HUDStatKeys: Incomplete
    @HUDStatKeys.setter  # type: ignore[no-redef]
    def HUDStatKeys(self, keys) -> None: ...
    @property
    def camerasWithGuides(self): ...
    _camerasWithGuides: Incomplete
    @camerasWithGuides.setter  # type: ignore[no-redef]
    def camerasWithGuides(self, value) -> None: ...
    @property
    def gfCamera(self):
        """Return the last computed Gf Camera"""
    @property
    def cameraFrustum(self):
        """Unlike the StageView.freeCamera property, which is invalid/None
        whenever we are viewing from a scene/stage camera, the 'cameraFrustum'
        property will always return the last-computed camera frustum, regardless
        of source."""
    @property
    def rendererDisplayName(self): ...
    @property
    def rendererAovName(self): ...
    @property
    def allowAsync(self): ...
    _allowAsync: Incomplete
    @allowAsync.setter  # type: ignore[no-redef]
    def allowAsync(self, value) -> None: ...
    _dataModel: Incomplete
    _makeTimer: Incomplete
    _isFirstImage: bool
    _lastComputedGfCamera: Incomplete
    _lastAspectRatio: float
    _mask: Incomplete
    _maskOutline: Incomplete
    _reticles: Incomplete
    _hud: Incomplete
    _stageIsZup: bool
    _cameraMode: str
    _dragActive: bool
    _lastX: int
    _lastY: int
    _renderer: Incomplete
    _renderPauseState: bool
    _renderStopState: bool
    _reportedContextError: bool
    _rendererSelectionNeedsUpdate: bool
    _renderModeDict: Incomplete
    _dist: int
    _bbox: Incomplete
    _selectionBBox: Incomplete
    _selectionBrange: Incomplete
    _forceRefresh: bool
    _renderTime: int
    _glPrimitiveGeneratedQuery: Incomplete
    _glTimeElapsedQuery: Incomplete
    _simpleGLSLProgram: Incomplete
    _axisVBO: Incomplete
    _bboxVBO: Incomplete
    _cameraGuidesVBO: Incomplete
    _vao: int
    def __init__(self, parent: Incomplete | None = None, dataModel: Incomplete | None = None, makeTimer=...) -> None: ...
    def _getRenderer(self): ...
    _rendererDisplayName: Incomplete
    _rendererAovName: str
    def _handleRendererChanged(self, rendererId) -> None: ...
    def _scaleMouseCoords(self, point): ...
    def closeRenderer(self) -> None:
        """Close the current renderer."""
    def GetRendererPlugins(self): ...
    def GetRendererDisplayName(self, plugId): ...
    def GetCurrentRendererId(self): ...
    def SetRendererPlugin(self, plugId): ...
    def GetRendererAovs(self): ...
    def SetRendererAov(self, aov): ...
    def GetRendererSettingsList(self): ...
    def GetRendererSetting(self, name): ...
    def SetRendererSetting(self, name, value) -> None: ...
    def GetRendererCommands(self): ...
    def InvokeRendererCommand(self, command): ...
    def SetRendererPaused(self, paused) -> None: ...
    def IsPauseRendererSupported(self): ...
    def IsRendererConverged(self): ...
    def SetRendererStopped(self, stopped) -> None: ...
    def IsStopRendererSupported(self): ...
    camerasWithGuides: Incomplete  # type: ignore[no-redef]
    def _stageReplaced(self) -> None:
        """Set the USD Stage this widget will be displaying. To decommission
        (even temporarily) this widget, supply None as 'stage'."""
    def _createNewFreeCamera(self, viewSettings, isZUp):
        """Creates a new free camera, persisting the previous camera settings
        (fov, aspect, clipping planes)."""
    def GetSimpleGLSLProgram(self): ...
    def DrawAxis(self, viewProjectionMatrix) -> None: ...
    def _processBBoxes(self) -> None: ...
    def DrawCameraGuides(self, mvpMatrix) -> None: ...
    def updateBboxPurposes(self) -> None: ...
    def recomputeBBox(self) -> None: ...
    def resetCam(self, frameFit: float = 1.1) -> None: ...
    def updateView(self, resetCam: bool = False, forceComputeBBox: bool = False, frameFit: float = 1.1) -> None:
        """Updates bounding boxes and camera. resetCam = True causes the camera to reframe
        the specified prims. frameFit sets the ratio of the camera's frustum's
        relevant dimension to the object's bounding box. 1.1, the default,
        fits the prim's bounding box in the frame with a roughly 10% margin.
        """
    def updateSelection(self) -> None: ...
    def _processSelection(self) -> None: ...
    def _getEmptyBBox(self): ...
    def _getDefaultBBox(self): ...
    def _isInfiniteBBox(self, bbox): ...
    def getStageBBox(self): ...
    def getSelectionBBox(self): ...
    def renderSinglePass(self, renderMode, renderSelHighlights) -> None: ...
    def initializeGL(self) -> None: ...
    def updateGL(self) -> None:
        """We override this virtual so that we can make it a no-op during
        playback.  The client driving playback at a particular rate should
        instead call updateForPlayback() to image the next frame."""
    def updateForPlayback(self) -> None:
        """If playing, update the GL canvas.  Otherwise a no-op"""
    def getActiveSceneCamera(self): ...
    def hasLockedAspectRatio(self):
        """True if the camera has a defined aspect ratio that should not change
        when the viewport is resized."""
    def computeWindowPolicy(self, cameraAspectRatio): ...
    def computeWindowSize(self): ...
    def computeWindowViewport(self): ...
    def resolveCamera(self):
        """Returns a tuple of the camera to use for rendering (either a scene
        camera or a free camera) and that camera's original aspect ratio.
        Depending on camera guide settings, the camera frustum may be conformed
        to fit the window viewport. Emits a signalFrustumChanged if the
        camera frustum has changed since the last time resolveCamera was called."""
    def computeCameraViewport(self, cameraAspectRatio): ...
    def copyViewState(self):
        """Returns a copy of this StageView's view-affecting state,
        which can be used later to restore the view via restoreViewState().
        Take note that we do NOT include the StageView's notion of the
        current time (used by prim-based cameras to extract their data),
        since we do not want a restore operation to put us out of sync
        with respect to our owner's time.
        """
    def restoreViewState(self, viewState) -> None:
        """Restore view parameters from 'viewState', and redraw"""
    def paintGL(self) -> None: ...
    def drawHUD(self, renderer) -> None: ...
    def grabFrameBuffer(self, cropToAspectRatio: bool = False):
        """
        Returns an image of the frame buffer. If cropToAspectRatio is True
        and the camera mask is shown, the image is cropped to the camera's
        aspect ratio.
        """
    def sizeHint(self): ...
    def switchToFreeCamera(self, computeAndSetClosestDistance: bool = True) -> None:
        """
        If our current camera corresponds to a prim, create a FreeCamera
        that has the same view and use it.
        """
    def mousePressEvent(self, event) -> None:
        """This widget claims the Alt modifier key as the enabler for camera
        manipulation, and will consume mousePressEvents when Alt is present.
        In any other modifier state, a mousePressEvent will result in a
        pick operation, and the pressed button and active modifiers will be
        made available to clients via a signalPrimSelected()."""
    def mouseReleaseEvent(self, event) -> None: ...
    def mouseMoveEvent(self, event) -> None: ...
    def wheelEvent(self, event) -> None: ...
    def _onAutoComputeClippingChanged(self) -> None:
        """If we are currently rendering from a prim camera, switch to the
        FreeCamera.  Then reset the near/far clipping planes based on
        distance to closest geometry.  But only when autoClip has turned on!"""
    def _onFreeCameraSettingChanged(self) -> None:
        """Switch to the free camera if any of its settings have been modified.
        """
    def computeAndSetClosestDistance(self) -> None:
        """Using the current FreeCamera's frustum, determine the world-space
        closest rendered point to the camera.  Use that point
        to set our FreeCamera's closest visible distance."""
    def pick(self, pickFrustum):
        """
        Find closest point in scene rendered through 'pickFrustum'.
        Returns a sextuple:
          selectedPoint, selectedNormal, selectedPrimPath,
          selectedInstancerPath, selectedInstanceIndex, selectedInstancerContext
        """
    def computePickFrustum(self, x, y): ...
    def pickObject(self, x, y, button, modifiers) -> None:
        """
        Render stage into fbo with each piece as a different color.
        Emits a signalPrimSelected or signalRollover depending on
        whether 'button' is None.
        """
    def glDraw(self) -> None: ...
    def SetForceRefresh(self, val) -> None: ...
    def ExportFreeCameraToStage(self, stage, defcamName: str = 'usdviewCam', imgWidth: Incomplete | None = None, imgHeight: Incomplete | None = None) -> None:
        """
        Export the free camera to the specified USD stage, if it is
        currently defined. If it is not active (i.e. we are viewing through
        a stage camera), raise a ValueError.
        """
    def ExportSession(self, stagePath, defcamName: str = 'usdviewCam', imgWidth: Incomplete | None = None, imgHeight: Incomplete | None = None) -> None:
        """
        Export the free camera (if currently active) and session layer to a
        USD file at the specified stagePath that references the current-viewed
        stage.
        """
    def _primSelectionChanged(self) -> None: ...
    def PollForAsynchronousUpdates(self): ...

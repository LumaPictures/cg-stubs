from _typeshed import Incomplete
from pxr import Ar as Ar
from pxr.UsdUtils.constantsGroup import ConstantsGroup as ConstantsGroup

class NodeTypes(ConstantsGroup):
    UsdPreviewSurface: str
    UsdUVTexture: str
    UsdTransform2d: str
    UsdPrimvarReader: str

class ShaderProps(ConstantsGroup):
    Bias: str
    Scale: str
    SourceColorSpace: str
    Normal: str
    File: str

def _IsPackageOrPackagedLayer(layer): ...

class BaseRuleChecker:
    """This is Base class for all the rule-checkers."""
    _verbose: Incomplete
    _consumerLevelChecks: Incomplete
    _assetLevelChecks: Incomplete
    _failedChecks: Incomplete
    _errors: Incomplete
    _warnings: Incomplete
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def _AddFailedCheck(self, msg) -> None: ...
    def _AddError(self, msg) -> None: ...
    def _AddWarning(self, msg) -> None: ...
    def _Msg(self, msg) -> None: ...
    def GetFailedChecks(self): ...
    def GetErrors(self): ...
    def GetWarnings(self): ...
    def CheckStage(self, usdStage) -> None:
        """ Check the given usdStage. """
    def CheckDiagnostics(self, diagnostics) -> None:
        """ Check the diagnostic messages that were generated when opening the 
            USD stage. The diagnostic messages are collected using a 
            UsdUtilsCoalescingDiagnosticDelegate.
        """
    def CheckUnresolvedPaths(self, unresolvedPaths) -> None:
        """ Check or process any unresolved asset paths that were found when 
            analysing the dependencies.
        """
    def CheckDependencies(self, usdStage, layerDeps, assetDeps) -> None:
        """ Check usdStage's layer and asset dependencies that were gathered 
            using UsdUtils.ComputeAllDependencies().
        """
    def CheckLayer(self, layer) -> None:
        """ Check the given SdfLayer. """
    def CheckZipFile(self, zipFile, packagePath) -> None:
        """ Check the zipFile object created by opening the package at path 
            packagePath.
        """
    def CheckPrim(self, prim) -> None:
        """ Check the given prim, which may only exist is a specific combination
            of variant selections on the UsdStage.
        """
    def ResetCaches(self) -> None:
        """ Reset any caches the rule owns.  Called whenever stage authoring
        occurs, such as when we iterate through VariantSet combinations.
        """

class ByteAlignmentChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckZipFile(self, zipFile, packagePath) -> None: ...

class CompressionChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckZipFile(self, zipFile, packagePath) -> None: ...

class MissingReferenceChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckDiagnostics(self, diagnostics) -> None: ...
    def CheckUnresolvedPaths(self, unresolvedPaths) -> None: ...

class StageMetadataChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckStage(self, usdStage) -> None: ...

class TextureChecker(BaseRuleChecker):
    _basicUSDZImageFormats: Incomplete
    _unsupportedImageFormats: Incomplete
    @staticmethod
    def GetDescription(): ...
    _allowedFormats: Incomplete
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckStage(self, usdStage) -> None: ...
    def _CheckTexture(self, texAssetPath, inputPath) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class PrimEncapsulationChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def _HasGprimAncestor(self, prim): ...
    def _FindConnectableAncestor(self, prim): ...
    def CheckPrim(self, prim) -> None: ...
    _connectableAncestorMap: Incomplete
    _hasGprimInPathMap: Incomplete
    def ResetCaches(self) -> None: ...

class NormalMapTextureChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def _GetShaderId(self, shader): ...
    def _TextureIs8Bit(self, asset): ...
    def _GetInputValue(self, shader, inputName): ...
    def CheckPrim(self, prim) -> None: ...

class MaterialBindingAPIAppliedChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class SkelBindingAPIAppliedChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    _skelBindingAPIProps: Incomplete
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class ShaderPropertyTypeConformanceChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def _FillSdrNameToTypeMap(self, shadeNode, mapping) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class ARKitPackageEncapsulationChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckDependencies(self, usdStage, layerDeps, assetDeps) -> None: ...

class ARKitLayerChecker(BaseRuleChecker):
    _allowedLayerFormatIds: Incomplete
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckLayer(self, layer) -> None: ...

class ARKitPrimTypeChecker(BaseRuleChecker):
    _allowedPrimTypeNames: Incomplete
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class ARKitShaderChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class ARKitMaterialBindingChecker(BaseRuleChecker):
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckPrim(self, prim) -> None: ...

class ARKitFileExtensionChecker(BaseRuleChecker):
    _allowedFileExtensions: Incomplete
    @staticmethod
    def GetDescription(): ...
    def __init__(self, verbose, consumerLevelChecks, assetLevelChecks) -> None: ...
    def CheckZipFile(self, zipFile, packagePath) -> None: ...

class ComplianceChecker:
    ''' A utility class for checking compliance of a given USD asset or a USDZ 
    package.

    Since usdz files are zip files, someone could use generic zip tools to 
    create an archive and just change the extension, producing a .usdz file that 
    does not honor the additional constraints that usdz files require.  Even if 
    someone does use our official archive creation tools, though, we 
    intentionally allow creation of usdz files that can be very "permissive" in 
    their contents for internal studio uses, where portability outside the 
    studio is not a concern.  For content meant to be delivered over the web 
    (eg. ARKit assets), however, we must be much more restrictive.

    This class provides two levels of compliance checking: 
    * "structural" validation that is represented by a set of base rules. 
    * "ARKit" compatibility validation, which includes many more restrictions.
    
    Calling ComplianceChecker.DumpAllRules() will print an enumeration of the 
    various rules in the two categories of compliance checking.
    '''
    @staticmethod
    def GetBaseRules(): ...
    @staticmethod
    def GetARKitRules(skipARKitRootLayerCheck: bool = False): ...
    @staticmethod
    def GetRules(arkit: bool = False, skipARKitRootLayerCheck: bool = False): ...
    @staticmethod
    def DumpAllRules() -> None: ...
    _rootPackageOnly: Incomplete
    _doVariants: Incomplete
    _verbose: Incomplete
    _errors: Incomplete
    _warnings: Incomplete
    _checkedPackages: Incomplete
    _rules: Incomplete
    def __init__(self, arkit: bool = False, skipARKitRootLayerCheck: bool = False, rootPackageOnly: bool = False, skipVariants: bool = False, verbose: bool = False, assetLevelChecks: bool = True) -> None: ...
    def _Msg(self, msg) -> None: ...
    def _AddError(self, errMsg) -> None: ...
    def _AddWarning(self, errMsg) -> None: ...
    def GetErrors(self): ...
    def GetWarnings(self): ...
    def DumpRules(self) -> None: ...
    def GetFailedChecks(self): ...
    def CheckCompliance(self, inputFile) -> None: ...
    def _CheckPackage(self, packagePath) -> None: ...
    def _CheckLayer(self, layer) -> None: ...
    def _CheckPrim(self, prim) -> None: ...
    def _TraverseRange(self, primRangeIt, isStageRoot) -> None: ...
    def _TraverseVariants(self, prim): ...

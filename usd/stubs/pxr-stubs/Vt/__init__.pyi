# mypy: disable-error-code="misc, override, no-redef"

import Boost.Python
import pxr.Ar
import pxr.Gf
import typing
from typing import Any, ClassVar, overload

__MFB_FULL_PACKAGE_NAME: str

class BoolArray(Boost.Python.instance):
    """An array of type bool."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        BoolArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        BoolArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: BoolArray | typing.Iterable[bool], /) -> Any: ...
    @overload
    def __add__(self, arg2: bool, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __add__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __div__(self, arg2: list, /) -> BoolArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: BoolArray | typing.Iterable[bool], /) -> Any: ...
    @overload
    def __mod__(self, arg2: bool, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __mul__(self, arg2: BoolArray | typing.Iterable[bool], /) -> Any: ...
    @overload
    def __mul__(self, arg2: bool, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> BoolArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: bool, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __rmod__(self, arg2: bool, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __rmul__(self, arg2: bool, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __rsub__(self, arg2: bool, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> BoolArray: ...
    def __rtruediv__(self, arg2: bool, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: BoolArray | typing.Iterable[bool], /) -> Any: ...
    @overload
    def __sub__(self, arg2: bool, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> BoolArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> BoolArray: ...
    @overload
    def __truediv__(self, arg2: BoolArray | typing.Iterable[bool], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: bool, /) -> Any: ...

class CharArray(Boost.Python.instance):
    """An array of type char."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        CharArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        CharArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> Any: ...
    @overload
    def __add__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __add__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __div__(self, arg2: list, /) -> CharArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> Any: ...
    @overload
    def __mod__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __mul__(self, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> Any: ...
    @overload
    def __mul__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> CharArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __rmod__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __rmul__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __rsub__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> CharArray: ...
    def __rtruediv__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> Any: ...
    @overload
    def __sub__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> CharArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> CharArray: ...
    @overload
    def __truediv__(self, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...

class DoubleArray(Boost.Python.instance):
    """An array of type double."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        DoubleArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        DoubleArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: DoubleArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __add__(self, arg2: float, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __add__(self, arg2: list, /) -> DoubleArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __div__(self, arg2: list, /) -> DoubleArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: DoubleArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> DoubleArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: float, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> DoubleArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> DoubleArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> DoubleArray: ...
    @overload
    def __rsub__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> DoubleArray: ...
    def __rtruediv__(self, arg2: float, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: DoubleArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: float, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> DoubleArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> DoubleArray: ...
    @overload
    def __truediv__(self, arg2: DoubleArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: float, /) -> Any: ...

class DualQuatdArray(Boost.Python.instance):
    """An array of type GfDualQuatd."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        DualQuatdArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        DualQuatdArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: DualQuatdArray, /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> DualQuatdArray: ...
    @overload
    def __add__(self, arg2: list, /) -> DualQuatdArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: DualQuatdArray, /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> DualQuatdArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> DualQuatdArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> DualQuatdArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> DualQuatdArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> DualQuatdArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> DualQuatdArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> DualQuatdArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> DualQuatdArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: DualQuatdArray, /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> DualQuatdArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> DualQuatdArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class DualQuatfArray(Boost.Python.instance):
    """An array of type GfDualQuatf."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        DualQuatfArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        DualQuatfArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: DualQuatfArray, /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> DualQuatfArray: ...
    @overload
    def __add__(self, arg2: list, /) -> DualQuatfArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: DualQuatfArray, /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> DualQuatfArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> DualQuatfArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> DualQuatfArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> DualQuatfArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> DualQuatfArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> DualQuatfArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> DualQuatfArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> DualQuatfArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: DualQuatfArray, /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> DualQuatfArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> DualQuatfArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class DualQuathArray(Boost.Python.instance):
    """An array of type GfDualQuath."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        DualQuathArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        DualQuathArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: DualQuathArray, /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> DualQuathArray: ...
    @overload
    def __add__(self, arg2: list, /) -> DualQuathArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: DualQuathArray, /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> DualQuathArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> DualQuathArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> DualQuathArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> DualQuathArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> DualQuathArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> DualQuathArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> DualQuathArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> DualQuathArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: DualQuathArray, /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.DualQuath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> DualQuathArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> DualQuathArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class FloatArray(Boost.Python.instance):
    """An array of type float."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        FloatArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        FloatArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: FloatArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __add__(self, arg2: float, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __add__(self, arg2: list, /) -> FloatArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __div__(self, arg2: list, /) -> FloatArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: FloatArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> FloatArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: float, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> FloatArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> FloatArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> FloatArray: ...
    @overload
    def __rsub__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> FloatArray: ...
    def __rtruediv__(self, arg2: float, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: FloatArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: float, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> FloatArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> FloatArray: ...
    @overload
    def __truediv__(self, arg2: FloatArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: float, /) -> Any: ...

class HalfArray(Boost.Python.instance):
    """An array of type pxr_half::half."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        HalfArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        HalfArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: HalfArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __add__(self, arg2: object, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __add__(self, arg2: list, /) -> HalfArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __div__(self, arg2: list, /) -> HalfArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: HalfArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __mul__(self, arg2: object, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> HalfArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: object, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> HalfArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> HalfArray: ...
    @overload
    def __rmul__(self, arg2: object, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> HalfArray: ...
    @overload
    def __rsub__(self, arg2: object, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> HalfArray: ...
    def __rtruediv__(self, arg2: object, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: HalfArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: object, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> HalfArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> HalfArray: ...
    @overload
    def __truediv__(self, arg2: HalfArray | typing.Iterable[float], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: object, /) -> Any: ...

class Int64Array(Boost.Python.instance):
    """An array of type long long."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Int64ArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Int64ArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Int64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __add__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __div__(self, arg2: list, /) -> Int64Array: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: Int64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __mod__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __mul__(self, arg2: Int64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __mul__(self, arg2: list, /) -> Int64Array: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __radd__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __rmod__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Int64Array: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Int64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Int64Array: ...
    @overload
    def __sub__(self, arg2: list, /) -> Int64Array: ...
    @overload
    def __truediv__(self, arg2: Int64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class IntArray(Boost.Python.instance):
    """An array of type int."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        IntArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        IntArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: IntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __add__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __div__(self, arg2: list, /) -> IntArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: IntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __mul__(self, arg2: IntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> IntArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> IntArray: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: IntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> IntArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> IntArray: ...
    @overload
    def __truediv__(self, arg2: IntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class IntervalArray(Boost.Python.instance):
    """An array of type GfInterval."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __add__(self, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Interval, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> IntervalArray: ...
    @overload
    def __add__(self, arg2: list, /) -> IntervalArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Interval, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> IntervalArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> IntervalArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Matrix2dArray(Boost.Python.instance):
    """An array of type GfMatrix2d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Matrix2dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Matrix2dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Matrix2dArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __div__(self, arg2: list, /) -> Matrix2dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> Matrix2dArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Matrix2dArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Matrix2dArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Matrix2dArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Matrix2dArray: ...
    def __rtruediv__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Matrix2dArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Matrix2dArray: ...
    @overload
    def __truediv__(self, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: pxr.Gf.Matrix2d, /) -> Any: ...

class Matrix2fArray(Boost.Python.instance):
    """An array of type GfMatrix2f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Matrix2fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Matrix2fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Matrix2fArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __div__(self, arg2: list, /) -> Matrix2fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> Matrix2fArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Matrix2fArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Matrix2fArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Matrix2fArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Matrix2fArray: ...
    def __rtruediv__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Matrix2fArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Matrix2fArray: ...
    @overload
    def __truediv__(self, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: pxr.Gf.Matrix2f, /) -> Any: ...

class Matrix3dArray(Boost.Python.instance):
    """An array of type GfMatrix3d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Matrix3dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Matrix3dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Matrix3dArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __div__(self, arg2: list, /) -> Matrix3dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> Matrix3dArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Matrix3dArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Matrix3dArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Matrix3dArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Matrix3dArray: ...
    def __rtruediv__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Matrix3dArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Matrix3dArray: ...
    @overload
    def __truediv__(self, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: pxr.Gf.Matrix3d, /) -> Any: ...

class Matrix3fArray(Boost.Python.instance):
    """An array of type GfMatrix3f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Matrix3fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Matrix3fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Matrix3fArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __div__(self, arg2: list, /) -> Matrix3fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> Matrix3fArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Matrix3fArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Matrix3fArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Matrix3fArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Matrix3fArray: ...
    def __rtruediv__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Matrix3fArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Matrix3fArray: ...
    @overload
    def __truediv__(self, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: pxr.Gf.Matrix3f, /) -> Any: ...

class Matrix4dArray(Boost.Python.instance):
    """An array of type GfMatrix4d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Matrix4dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Matrix4dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Matrix4dArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __div__(self, arg2: list, /) -> Matrix4dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> Matrix4dArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Matrix4dArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Matrix4dArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Matrix4dArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Matrix4dArray: ...
    def __rtruediv__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Matrix4dArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Matrix4dArray: ...
    @overload
    def __truediv__(self, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: pxr.Gf.Matrix4d, /) -> Any: ...

class Matrix4fArray(Boost.Python.instance):
    """An array of type GfMatrix4f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Matrix4fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Matrix4fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Matrix4fArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __div__(self, arg2: list, /) -> Matrix4fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> Matrix4fArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Matrix4fArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> Matrix4fArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> Matrix4fArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Matrix4fArray: ...
    def __rtruediv__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Matrix4fArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Matrix4fArray: ...
    @overload
    def __truediv__(self, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: pxr.Gf.Matrix4f, /) -> Any: ...

class QuatdArray(Boost.Python.instance):
    """An array of type GfQuatd."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        QuatdArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        QuatdArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> QuatdArray: ...
    @overload
    def __add__(self, arg2: list, /) -> QuatdArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> QuatdArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> QuatdArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> QuatdArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> QuatdArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> QuatdArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> QuatdArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> QuatdArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> QuatdArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> QuatdArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> QuatdArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class QuaternionArray(Boost.Python.instance):
    """An array of type GfQuaternion."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __add__(self, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Quaternion, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> QuaternionArray: ...
    @overload
    def __add__(self, arg2: list, /) -> QuaternionArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Quaternion, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> QuaternionArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> QuaternionArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Quaternion, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> QuaternionArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> QuaternionArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Quaternion, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> QuaternionArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> QuaternionArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Quaternion, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> QuaternionArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> QuaternionArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Quaternion, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> QuaternionArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> QuaternionArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class QuatfArray(Boost.Python.instance):
    """An array of type GfQuatf."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        QuatfArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        QuatfArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> QuatfArray: ...
    @overload
    def __add__(self, arg2: list, /) -> QuatfArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> QuatfArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> QuatfArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> QuatfArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> QuatfArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> QuatfArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> QuatfArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> QuatfArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> QuatfArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> QuatfArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> QuatfArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class QuathArray(Boost.Python.instance):
    """An array of type GfQuath."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        QuathArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        QuathArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> QuathArray: ...
    @overload
    def __add__(self, arg2: list, /) -> QuathArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __mul__(self, arg2: pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> QuathArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> QuathArray: ...
    @overload
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> QuathArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> QuathArray: ...
    @overload
    def __rmul__(self, arg2: pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> QuathArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> QuathArray: ...
    @overload
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> QuathArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> QuathArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Quath, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> QuathArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> QuathArray: ...
    def __truediv__(self, arg2: float, /) -> Any: ...

class Range1dArray(Boost.Python.instance):
    """An array of type GfRange1d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Range1dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Range1dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Range1d, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Range1dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Range1dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Range1d, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Range1dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Range1dArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Range1fArray(Boost.Python.instance):
    """An array of type GfRange1f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Range1fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Range1fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Range1f, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Range1fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Range1fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Range1f, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Range1fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Range1fArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Range2dArray(Boost.Python.instance):
    """An array of type GfRange2d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Range2dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Range2dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Range2d | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Range2dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Range2dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Range2d | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Range2dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Range2dArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Range2fArray(Boost.Python.instance):
    """An array of type GfRange2f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Range2fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Range2fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Range2f | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Range2fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Range2fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Range2f | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Range2fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Range2fArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Range3dArray(Boost.Python.instance):
    """An array of type GfRange3d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Range3dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Range3dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Range3d | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Range3dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Range3dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Range3d | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Range3dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Range3dArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Range3fArray(Boost.Python.instance):
    """An array of type GfRange3f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Range3fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Range3fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Range3f | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Range3fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Range3fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Range3f | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Range3fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Range3fArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class Rect2iArray(Boost.Python.instance):
    """An array of type GfRect2i."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Rect2iArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Rect2iArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Rect2i, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Rect2iArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Rect2iArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Rect2i, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Rect2iArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Rect2iArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class ShortArray(Boost.Python.instance):
    """An array of type short."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        ShortArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        ShortArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: ShortArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __add__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __div__(self, arg2: list, /) -> ShortArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: ShortArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __mul__(self, arg2: ShortArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> ShortArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> ShortArray: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: ShortArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> ShortArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> ShortArray: ...
    @overload
    def __truediv__(self, arg2: ShortArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class StringArray(Boost.Python.instance):
    """An array of type string."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __add__(self, arg2: StringArray, /) -> Any: ...
    @overload
    def __add__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> StringArray: ...
    @overload
    def __add__(self, arg2: list, /) -> StringArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __radd__(self, arg2: str | pxr.Ar.ResolvedPath, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> StringArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> StringArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class TokenArray(Boost.Python.instance):
    """An array of type TfToken."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...

class UCharArray(Boost.Python.instance):
    """An array of type unsigned char."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        UCharArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        UCharArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: UCharArray, /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __add__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __div__(self, arg2: list, /) -> UCharArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: UCharArray, /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __mul__(self, arg2: UCharArray, /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> UCharArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> UCharArray: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: UCharArray, /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> UCharArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> UCharArray: ...
    @overload
    def __truediv__(self, arg2: UCharArray, /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class UInt64Array(Boost.Python.instance):
    """An array of type unsigned long long."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        UInt64ArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        UInt64ArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: UInt64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __add__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __div__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __div__(self, arg2: list, /) -> UInt64Array: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: UInt64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __mod__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __mul__(self, arg2: UInt64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __mul__(self, arg2: list, /) -> UInt64Array: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __radd__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __rmod__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __rmul__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __rsub__(self, arg2: list, /) -> UInt64Array: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: UInt64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> UInt64Array: ...
    @overload
    def __sub__(self, arg2: list, /) -> UInt64Array: ...
    @overload
    def __truediv__(self, arg2: UInt64Array | typing.Iterable[int], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class UIntArray(Boost.Python.instance):
    """An array of type unsigned int."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        UIntArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        UIntArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: UIntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __add__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __div__(self, arg2: list, /) -> UIntArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: UIntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __mul__(self, arg2: UIntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> UIntArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> UIntArray: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: UIntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> UIntArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> UIntArray: ...
    @overload
    def __truediv__(self, arg2: UIntArray | typing.Iterable[int], /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class UShortArray(Boost.Python.instance):
    """An array of type unsigned short."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        UShortArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        UShortArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: UShortArray, /) -> Any: ...
    @overload
    def __add__(self, arg2: int, /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __add__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __div__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __div__(self, arg2: list, /) -> UShortArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @overload
    def __mod__(self, arg2: UShortArray, /) -> Any: ...
    @overload
    def __mod__(self, arg2: int, /) -> Any: ...
    @overload
    def __mod__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __mod__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __mul__(self, arg2: UShortArray, /) -> Any: ...
    @overload
    def __mul__(self, arg2: int, /) -> Any: ...
    @overload
    def __mul__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __mul__(self, arg2: list, /) -> UShortArray: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: int, /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __rdiv__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __rdiv__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __rmod__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmod__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __rmod__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __rmul__(self, arg2: int, /) -> Any: ...
    @overload
    def __rmul__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __rmul__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __rsub__(self, arg2: int, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> UShortArray: ...
    def __rtruediv__(self, arg2: int, /) -> Any: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: UShortArray, /) -> Any: ...
    @overload
    def __sub__(self, arg2: int, /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> UShortArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> UShortArray: ...
    @overload
    def __truediv__(self, arg2: UShortArray, /) -> Any: ...
    @overload
    def __truediv__(self, arg2: int, /) -> Any: ...

class Vec2dArray(Boost.Python.instance):
    """An array of type GfVec2d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec2dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec2dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec2d | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec2dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec2dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec2d | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec2dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec2dArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec2d | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec2dArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec2dArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec2d | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec2dArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec2dArray: ...

class Vec2fArray(Boost.Python.instance):
    """An array of type GfVec2f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec2fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec2fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec2f | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec2fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec2fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec2f | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec2fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec2fArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec2f | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec2fArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec2fArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec2f | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec2fArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec2fArray: ...

class Vec2hArray(Boost.Python.instance):
    """An array of type GfVec2h."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec2hArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec2hArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec2h | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec2hArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec2hArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec2h | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec2hArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec2hArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec2h | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec2hArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec2hArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec2h | list[float] | tuple[float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec2hArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec2hArray: ...

class Vec2iArray(Boost.Python.instance):
    """An array of type GfVec2i."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec2iArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec2iArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec2iArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec2iArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec2iArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec2iArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec2iArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec2iArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec2iArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec2iArray: ...

class Vec3dArray(Boost.Python.instance):
    """An array of type GfVec3d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec3dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec3dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec3dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec3dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec3dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec3dArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec3dArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec3dArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec3dArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec3dArray: ...

class Vec3fArray(Boost.Python.instance):
    """An array of type GfVec3f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec3fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec3fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec3fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec3fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec3fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec3fArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec3fArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec3fArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec3fArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec3fArray: ...

class Vec3hArray(Boost.Python.instance):
    """An array of type GfVec3h."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec3hArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec3hArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec3hArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec3hArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec3hArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec3hArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec3hArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec3hArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec3hArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec3hArray: ...

class Vec3iArray(Boost.Python.instance):
    """An array of type GfVec3i."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec3iArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec3iArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec3iArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec3iArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec3iArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec3iArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec3iArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec3iArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec3iArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec3iArray: ...

class Vec4dArray(Boost.Python.instance):
    """An array of type GfVec4d."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec4dArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec4dArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec4dArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec4dArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec4dArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec4dArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec4dArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec4dArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec4dArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec4dArray: ...

class Vec4fArray(Boost.Python.instance):
    """An array of type GfVec4f."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec4fArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec4fArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec4fArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec4fArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec4fArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec4fArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec4fArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec4fArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec4fArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec4fArray: ...

class Vec4hArray(Boost.Python.instance):
    """An array of type GfVec4h."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec4hArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec4hArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec4hArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec4hArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec4hArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec4hArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec4hArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec4hArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec4hArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec4hArray: ...

class Vec4iArray(Boost.Python.instance):
    """An array of type GfVec4i."""
    _isVtArray: ClassVar[bool] = ...
    @overload
    def __init__(self) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int, array: typing.Iterable) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @overload
    def __init__(self, size: int) -> None:
        """    __init__(values)

            values: a sequence (tuple, list, or another VtArray with element type convertible to the new array's element type)



        __init__( (object)arg1, (int)arg2, (object)arg3) -> object

        __init__( (object)arg1, (int)arg2) -> None"""
    @staticmethod
    def FromBuffer(*args, **kwargs):
        """

        Vec4iArrayFromBuffer( (object)arg1) -> object"""
    @staticmethod
    def FromNumpy(*args, **kwargs):
        """

        Vec4iArrayFromBuffer( (object)arg1) -> object"""
    @overload
    def __add__(self, arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Any: ...
    @overload
    def __add__(self, arg2: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], /) -> Any: ...
    @overload
    def __add__(self, arg2: tuple, /) -> Vec4iArray: ...
    @overload
    def __add__(self, arg2: list, /) -> Vec4iArray: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, arg2: object, /) -> Any: ...
    @overload
    def __getitem__(self, arg2: int, /) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg2: float, /) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Any: ...
    @overload
    def __radd__(self, arg2: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], /) -> Any: ...
    @overload
    def __radd__(self, arg2: tuple, /) -> Vec4iArray: ...
    @overload
    def __radd__(self, arg2: list, /) -> Vec4iArray: ...
    def __rmul__(self, arg2: float, /) -> Any: ...
    @overload
    def __rsub__(self, arg2: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], /) -> Any: ...
    @overload
    def __rsub__(self, arg2: tuple, /) -> Vec4iArray: ...
    @overload
    def __rsub__(self, arg2: list, /) -> Vec4iArray: ...
    @overload
    def __setitem__(self, arg2: object, arg3: object, /) -> None: ...
    @overload
    def __setitem__(self, arg2: int, arg3: object, /) -> None: ...
    @overload
    def __sub__(self, arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Any: ...
    @overload
    def __sub__(self, arg2: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], /) -> Any: ...
    @overload
    def __sub__(self, arg2: tuple, /) -> Vec4iArray: ...
    @overload
    def __sub__(self, arg2: list, /) -> Vec4iArray: ...

class _ValueWrapper(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None:
        """Raises an exception
        This class cannot be instantiated from Python
        """
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

@overload
def AllTrue(_a: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> bool:
    '''
    Returns true if every element of input array is not VtZero, else
    false.


    Intended to be used to evaluate results of boolean operations on
    arrays, e.g. ::

      a = Vt.StringArray((3,),("foo","bar","baz"))
      t = Vt.AllTrue(Vt.Equal(a,"bar"))

    (This example, if you look carefully, evaluates this function not on
    the strings, but on the results of the comparison).
    '''
@overload
def AllTrue(arg1: DoubleArray | typing.Iterable[float], /) -> bool: ...
@overload
def AllTrue(arg1: FloatArray | typing.Iterable[float], /) -> bool: ...
@overload
def AllTrue(arg1: HalfArray | typing.Iterable[float], /) -> bool: ...
@overload
def AllTrue(arg1: BoolArray | typing.Iterable[bool], /) -> bool: ...
@overload
def AllTrue(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> bool: ...
@overload
def AllTrue(arg1: UCharArray, /) -> bool: ...
@overload
def AllTrue(arg1: ShortArray | typing.Iterable[int], /) -> bool: ...
@overload
def AllTrue(arg1: UShortArray, /) -> bool: ...
@overload
def AllTrue(arg1: IntArray | typing.Iterable[int], /) -> bool: ...
@overload
def AllTrue(arg1: UIntArray | typing.Iterable[int], /) -> bool: ...
@overload
def AllTrue(arg1: Int64Array | typing.Iterable[int], /) -> bool: ...
@overload
def AllTrue(arg1: UInt64Array | typing.Iterable[int], /) -> bool: ...
@overload
def AllTrue(arg1: StringArray, /) -> bool: ...
@overload
def AnyTrue(_a: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> bool:
    '''
    Returns true if any element of input array is not VtZero, else false.


    Intended to be used to evaluate results of boolean operations on
    arrays, e.g. ::

      a = Vt.StringArray((3,),("foo","bar","baz"))
      t = Vt.AnyTrue(Vt.Equal(a,"bar"))

    (This example, if you look carefully, evaluates this function not on
    the strings, but on the results of the comparison).
    '''
@overload
def AnyTrue(arg1: DoubleArray | typing.Iterable[float], /) -> bool: ...
@overload
def AnyTrue(arg1: FloatArray | typing.Iterable[float], /) -> bool: ...
@overload
def AnyTrue(arg1: HalfArray | typing.Iterable[float], /) -> bool: ...
@overload
def AnyTrue(arg1: BoolArray | typing.Iterable[bool], /) -> bool: ...
@overload
def AnyTrue(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> bool: ...
@overload
def AnyTrue(arg1: UCharArray, /) -> bool: ...
@overload
def AnyTrue(arg1: ShortArray | typing.Iterable[int], /) -> bool: ...
@overload
def AnyTrue(arg1: UShortArray, /) -> bool: ...
@overload
def AnyTrue(arg1: IntArray | typing.Iterable[int], /) -> bool: ...
@overload
def AnyTrue(arg1: UIntArray | typing.Iterable[int], /) -> bool: ...
@overload
def AnyTrue(arg1: Int64Array | typing.Iterable[int], /) -> bool: ...
@overload
def AnyTrue(arg1: UInt64Array | typing.Iterable[int], /) -> bool: ...
@overload
def AnyTrue(arg1: StringArray, /) -> bool: ...
def Bool(arg1: bool, /) -> _ValueWrapper:
    """Bool(value) -> _ValueWrapper

    value : bool

    Use this function to specify a value with the explicit C++ type bool when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def BoolArrayFromBuffer(arg1: object, /) -> Any: ...
@overload
def Cat(_a0: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], _a1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], _aN: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Vec2dArray:
    """
    Concatenates arrays.


    The result is an array with length equal to the sum of the number of
    elements in the source arrays.
    """
@overload
def Cat(arg1: DualQuathArray, /) -> DualQuathArray: ...
@overload
def Cat(arg1: DualQuathArray, arg2: DualQuathArray, /) -> DualQuathArray: ...
@overload
def Cat(arg1: DualQuathArray, arg2: DualQuathArray, arg3: DualQuathArray, /) -> DualQuathArray: ...
@overload
def Cat(arg1: DualQuathArray, arg2: DualQuathArray, arg3: DualQuathArray, arg4: DualQuathArray, /) -> DualQuathArray: ...
@overload
def Cat(arg1: DualQuathArray, arg2: DualQuathArray, arg3: DualQuathArray, arg4: DualQuathArray, arg5: DualQuathArray, /) -> DualQuathArray: ...
@overload
def Cat(arg1: DualQuatfArray, /) -> DualQuatfArray: ...
@overload
def Cat(arg1: DualQuatfArray, arg2: DualQuatfArray, /) -> DualQuatfArray: ...
@overload
def Cat(arg1: DualQuatfArray, arg2: DualQuatfArray, arg3: DualQuatfArray, /) -> DualQuatfArray: ...
@overload
def Cat(arg1: DualQuatfArray, arg2: DualQuatfArray, arg3: DualQuatfArray, arg4: DualQuatfArray, /) -> DualQuatfArray: ...
@overload
def Cat(arg1: DualQuatfArray, arg2: DualQuatfArray, arg3: DualQuatfArray, arg4: DualQuatfArray, arg5: DualQuatfArray, /) -> DualQuatfArray: ...
@overload
def Cat(arg1: DualQuatdArray, /) -> DualQuatdArray: ...
@overload
def Cat(arg1: DualQuatdArray, arg2: DualQuatdArray, /) -> DualQuatdArray: ...
@overload
def Cat(arg1: DualQuatdArray, arg2: DualQuatdArray, arg3: DualQuatdArray, /) -> DualQuatdArray: ...
@overload
def Cat(arg1: DualQuatdArray, arg2: DualQuatdArray, arg3: DualQuatdArray, arg4: DualQuatdArray, /) -> DualQuatdArray: ...
@overload
def Cat(arg1: DualQuatdArray, arg2: DualQuatdArray, arg3: DualQuatdArray, arg4: DualQuatdArray, arg5: DualQuatdArray, /) -> DualQuatdArray: ...
@overload
def Cat(arg1: DoubleArray | typing.Iterable[float], /) -> DoubleArray: ...
@overload
def Cat(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> DoubleArray: ...
@overload
def Cat(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], arg3: DoubleArray | typing.Iterable[float], /) -> DoubleArray: ...
@overload
def Cat(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], arg3: DoubleArray | typing.Iterable[float], arg4: DoubleArray | typing.Iterable[float], /) -> DoubleArray: ...
@overload
def Cat(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], arg3: DoubleArray | typing.Iterable[float], arg4: DoubleArray | typing.Iterable[float], arg5: DoubleArray | typing.Iterable[float], /) -> DoubleArray: ...
@overload
def Cat(arg1: FloatArray | typing.Iterable[float], /) -> FloatArray: ...
@overload
def Cat(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> FloatArray: ...
@overload
def Cat(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], arg3: FloatArray | typing.Iterable[float], /) -> FloatArray: ...
@overload
def Cat(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], arg3: FloatArray | typing.Iterable[float], arg4: FloatArray | typing.Iterable[float], /) -> FloatArray: ...
@overload
def Cat(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], arg3: FloatArray | typing.Iterable[float], arg4: FloatArray | typing.Iterable[float], arg5: FloatArray | typing.Iterable[float], /) -> FloatArray: ...
@overload
def Cat(arg1: HalfArray | typing.Iterable[float], /) -> HalfArray: ...
@overload
def Cat(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> HalfArray: ...
@overload
def Cat(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], arg3: HalfArray | typing.Iterable[float], /) -> HalfArray: ...
@overload
def Cat(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], arg3: HalfArray | typing.Iterable[float], arg4: HalfArray | typing.Iterable[float], /) -> HalfArray: ...
@overload
def Cat(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], arg3: HalfArray | typing.Iterable[float], arg4: HalfArray | typing.Iterable[float], arg5: HalfArray | typing.Iterable[float], /) -> HalfArray: ...
@overload
def Cat(arg1: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Cat(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Cat(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], arg3: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Cat(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], arg3: BoolArray | typing.Iterable[bool], arg4: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Cat(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], arg3: BoolArray | typing.Iterable[bool], arg4: BoolArray | typing.Iterable[bool], arg5: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Cat(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> CharArray: ...
@overload
def Cat(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> CharArray: ...
@overload
def Cat(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg3: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> CharArray: ...
@overload
def Cat(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg3: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg4: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> CharArray: ...
@overload
def Cat(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg3: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg4: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg5: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> CharArray: ...
@overload
def Cat(arg1: UCharArray, /) -> UCharArray: ...
@overload
def Cat(arg1: UCharArray, arg2: UCharArray, /) -> UCharArray: ...
@overload
def Cat(arg1: UCharArray, arg2: UCharArray, arg3: UCharArray, /) -> UCharArray: ...
@overload
def Cat(arg1: UCharArray, arg2: UCharArray, arg3: UCharArray, arg4: UCharArray, /) -> UCharArray: ...
@overload
def Cat(arg1: UCharArray, arg2: UCharArray, arg3: UCharArray, arg4: UCharArray, arg5: UCharArray, /) -> UCharArray: ...
@overload
def Cat(arg1: ShortArray | typing.Iterable[int], /) -> ShortArray: ...
@overload
def Cat(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> ShortArray: ...
@overload
def Cat(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], arg3: ShortArray | typing.Iterable[int], /) -> ShortArray: ...
@overload
def Cat(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], arg3: ShortArray | typing.Iterable[int], arg4: ShortArray | typing.Iterable[int], /) -> ShortArray: ...
@overload
def Cat(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], arg3: ShortArray | typing.Iterable[int], arg4: ShortArray | typing.Iterable[int], arg5: ShortArray | typing.Iterable[int], /) -> ShortArray: ...
@overload
def Cat(arg1: UShortArray, /) -> UShortArray: ...
@overload
def Cat(arg1: UShortArray, arg2: UShortArray, /) -> UShortArray: ...
@overload
def Cat(arg1: UShortArray, arg2: UShortArray, arg3: UShortArray, /) -> UShortArray: ...
@overload
def Cat(arg1: UShortArray, arg2: UShortArray, arg3: UShortArray, arg4: UShortArray, /) -> UShortArray: ...
@overload
def Cat(arg1: UShortArray, arg2: UShortArray, arg3: UShortArray, arg4: UShortArray, arg5: UShortArray, /) -> UShortArray: ...
@overload
def Cat(arg1: IntArray | typing.Iterable[int], /) -> IntArray: ...
@overload
def Cat(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> IntArray: ...
@overload
def Cat(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], arg3: IntArray | typing.Iterable[int], /) -> IntArray: ...
@overload
def Cat(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], arg3: IntArray | typing.Iterable[int], arg4: IntArray | typing.Iterable[int], /) -> IntArray: ...
@overload
def Cat(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], arg3: IntArray | typing.Iterable[int], arg4: IntArray | typing.Iterable[int], arg5: IntArray | typing.Iterable[int], /) -> IntArray: ...
@overload
def Cat(arg1: UIntArray | typing.Iterable[int], /) -> UIntArray: ...
@overload
def Cat(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> UIntArray: ...
@overload
def Cat(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], arg3: UIntArray | typing.Iterable[int], /) -> UIntArray: ...
@overload
def Cat(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], arg3: UIntArray | typing.Iterable[int], arg4: UIntArray | typing.Iterable[int], /) -> UIntArray: ...
@overload
def Cat(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], arg3: UIntArray | typing.Iterable[int], arg4: UIntArray | typing.Iterable[int], arg5: UIntArray | typing.Iterable[int], /) -> UIntArray: ...
@overload
def Cat(arg1: Int64Array | typing.Iterable[int], /) -> Int64Array: ...
@overload
def Cat(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> Int64Array: ...
@overload
def Cat(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], arg3: Int64Array | typing.Iterable[int], /) -> Int64Array: ...
@overload
def Cat(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], arg3: Int64Array | typing.Iterable[int], arg4: Int64Array | typing.Iterable[int], /) -> Int64Array: ...
@overload
def Cat(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], arg3: Int64Array | typing.Iterable[int], arg4: Int64Array | typing.Iterable[int], arg5: Int64Array | typing.Iterable[int], /) -> Int64Array: ...
@overload
def Cat(arg1: UInt64Array | typing.Iterable[int], /) -> UInt64Array: ...
@overload
def Cat(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> UInt64Array: ...
@overload
def Cat(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], arg3: UInt64Array | typing.Iterable[int], /) -> UInt64Array: ...
@overload
def Cat(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], arg3: UInt64Array | typing.Iterable[int], arg4: UInt64Array | typing.Iterable[int], /) -> UInt64Array: ...
@overload
def Cat(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], arg3: UInt64Array | typing.Iterable[int], arg4: UInt64Array | typing.Iterable[int], arg5: UInt64Array | typing.Iterable[int], /) -> UInt64Array: ...
@overload
def Cat(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Matrix4fArray: ...
@overload
def Cat(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Matrix4fArray: ...
@overload
def Cat(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg3: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Matrix4fArray: ...
@overload
def Cat(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg3: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg4: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Matrix4fArray: ...
@overload
def Cat(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg3: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg4: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg5: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> Matrix4fArray: ...
@overload
def Cat(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Matrix3fArray: ...
@overload
def Cat(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Matrix3fArray: ...
@overload
def Cat(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg3: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Matrix3fArray: ...
@overload
def Cat(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg3: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg4: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Matrix3fArray: ...
@overload
def Cat(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg3: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg4: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg5: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> Matrix3fArray: ...
@overload
def Cat(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Matrix2fArray: ...
@overload
def Cat(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Matrix2fArray: ...
@overload
def Cat(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg3: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Matrix2fArray: ...
@overload
def Cat(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg3: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg4: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Matrix2fArray: ...
@overload
def Cat(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg3: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg4: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg5: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> Matrix2fArray: ...
@overload
def Cat(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Matrix4dArray: ...
@overload
def Cat(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Matrix4dArray: ...
@overload
def Cat(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg3: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Matrix4dArray: ...
@overload
def Cat(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg3: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg4: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Matrix4dArray: ...
@overload
def Cat(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg3: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg4: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg5: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> Matrix4dArray: ...
@overload
def Cat(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Matrix3dArray: ...
@overload
def Cat(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Matrix3dArray: ...
@overload
def Cat(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg3: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Matrix3dArray: ...
@overload
def Cat(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg3: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg4: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Matrix3dArray: ...
@overload
def Cat(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg3: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg4: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg5: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> Matrix3dArray: ...
@overload
def Cat(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Matrix2dArray: ...
@overload
def Cat(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Matrix2dArray: ...
@overload
def Cat(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg3: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Matrix2dArray: ...
@overload
def Cat(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg3: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg4: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Matrix2dArray: ...
@overload
def Cat(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg3: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg4: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg5: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> Matrix2dArray: ...
@overload
def Cat(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> QuathArray: ...
@overload
def Cat(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> QuathArray: ...
@overload
def Cat(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], arg3: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> QuathArray: ...
@overload
def Cat(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], arg3: QuathArray | typing.Iterable[pxr.Gf.Quath], arg4: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> QuathArray: ...
@overload
def Cat(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], arg3: QuathArray | typing.Iterable[pxr.Gf.Quath], arg4: QuathArray | typing.Iterable[pxr.Gf.Quath], arg5: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> QuathArray: ...
@overload
def Cat(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatfArray: ...
@overload
def Cat(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatfArray: ...
@overload
def Cat(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg3: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatfArray: ...
@overload
def Cat(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg3: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg4: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatfArray: ...
@overload
def Cat(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg3: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg4: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg5: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatfArray: ...
@overload
def Cat(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatdArray: ...
@overload
def Cat(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatdArray: ...
@overload
def Cat(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg3: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatdArray: ...
@overload
def Cat(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg3: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg4: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatdArray: ...
@overload
def Cat(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg3: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg4: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg5: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> QuatdArray: ...
@overload
def Cat(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> QuaternionArray: ...
@overload
def Cat(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> QuaternionArray: ...
@overload
def Cat(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg3: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> QuaternionArray: ...
@overload
def Cat(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg3: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg4: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> QuaternionArray: ...
@overload
def Cat(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg3: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg4: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg5: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> QuaternionArray: ...
@overload
def Cat(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> Range3fArray: ...
@overload
def Cat(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> Range3fArray: ...
@overload
def Cat(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg3: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> Range3fArray: ...
@overload
def Cat(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg3: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg4: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> Range3fArray: ...
@overload
def Cat(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg3: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg4: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg5: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> Range3fArray: ...
@overload
def Cat(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> Range3dArray: ...
@overload
def Cat(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> Range3dArray: ...
@overload
def Cat(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg3: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> Range3dArray: ...
@overload
def Cat(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg3: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg4: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> Range3dArray: ...
@overload
def Cat(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg3: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg4: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg5: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> Range3dArray: ...
@overload
def Cat(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> Range2fArray: ...
@overload
def Cat(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> Range2fArray: ...
@overload
def Cat(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg3: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> Range2fArray: ...
@overload
def Cat(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg3: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg4: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> Range2fArray: ...
@overload
def Cat(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg3: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg4: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg5: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> Range2fArray: ...
@overload
def Cat(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> Range2dArray: ...
@overload
def Cat(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> Range2dArray: ...
@overload
def Cat(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg3: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> Range2dArray: ...
@overload
def Cat(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg3: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg4: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> Range2dArray: ...
@overload
def Cat(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg3: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg4: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg5: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> Range2dArray: ...
@overload
def Cat(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> Range1fArray: ...
@overload
def Cat(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> Range1fArray: ...
@overload
def Cat(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg3: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> Range1fArray: ...
@overload
def Cat(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg3: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg4: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> Range1fArray: ...
@overload
def Cat(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg3: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg4: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg5: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> Range1fArray: ...
@overload
def Cat(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> Range1dArray: ...
@overload
def Cat(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> Range1dArray: ...
@overload
def Cat(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg3: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> Range1dArray: ...
@overload
def Cat(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg3: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg4: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> Range1dArray: ...
@overload
def Cat(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg3: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg4: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg5: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> Range1dArray: ...
@overload
def Cat(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> IntervalArray: ...
@overload
def Cat(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> IntervalArray: ...
@overload
def Cat(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg3: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> IntervalArray: ...
@overload
def Cat(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg3: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg4: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> IntervalArray: ...
@overload
def Cat(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg3: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg4: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg5: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> IntervalArray: ...
@overload
def Cat(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> Rect2iArray: ...
@overload
def Cat(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> Rect2iArray: ...
@overload
def Cat(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg3: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> Rect2iArray: ...
@overload
def Cat(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg3: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg4: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> Rect2iArray: ...
@overload
def Cat(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg3: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg4: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg5: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> Rect2iArray: ...
@overload
def Cat(arg1: StringArray, /) -> StringArray: ...
@overload
def Cat(arg1: StringArray, arg2: StringArray, /) -> StringArray: ...
@overload
def Cat(arg1: StringArray, arg2: StringArray, arg3: StringArray, /) -> StringArray: ...
@overload
def Cat(arg1: StringArray, arg2: StringArray, arg3: StringArray, arg4: StringArray, /) -> StringArray: ...
@overload
def Cat(arg1: StringArray, arg2: StringArray, arg3: StringArray, arg4: StringArray, arg5: StringArray, /) -> StringArray: ...
@overload
def Cat(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> TokenArray: ...
@overload
def Cat(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> TokenArray: ...
@overload
def Cat(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg3: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> TokenArray: ...
@overload
def Cat(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg3: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg4: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> TokenArray: ...
@overload
def Cat(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg3: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg4: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg5: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> TokenArray: ...
@overload
def Cat(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Vec4iArray: ...
@overload
def Cat(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Vec4iArray: ...
@overload
def Cat(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg3: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Vec4iArray: ...
@overload
def Cat(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg3: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg4: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Vec4iArray: ...
@overload
def Cat(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg3: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg4: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg5: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> Vec4iArray: ...
@overload
def Cat(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Vec3iArray: ...
@overload
def Cat(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Vec3iArray: ...
@overload
def Cat(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg3: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Vec3iArray: ...
@overload
def Cat(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg3: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg4: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Vec3iArray: ...
@overload
def Cat(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg3: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg4: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg5: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> Vec3iArray: ...
@overload
def Cat(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Vec2iArray: ...
@overload
def Cat(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Vec2iArray: ...
@overload
def Cat(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg3: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Vec2iArray: ...
@overload
def Cat(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg3: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg4: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Vec2iArray: ...
@overload
def Cat(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg3: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg4: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg5: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> Vec2iArray: ...
@overload
def Cat(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4hArray: ...
@overload
def Cat(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4hArray: ...
@overload
def Cat(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4hArray: ...
@overload
def Cat(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg4: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4hArray: ...
@overload
def Cat(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg4: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg5: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4hArray: ...
@overload
def Cat(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Vec3hArray: ...
@overload
def Cat(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Vec3hArray: ...
@overload
def Cat(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg3: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Vec3hArray: ...
@overload
def Cat(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg3: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg4: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Vec3hArray: ...
@overload
def Cat(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg3: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg4: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg5: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> Vec3hArray: ...
@overload
def Cat(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Vec2hArray: ...
@overload
def Cat(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Vec2hArray: ...
@overload
def Cat(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg3: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Vec2hArray: ...
@overload
def Cat(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg3: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg4: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Vec2hArray: ...
@overload
def Cat(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg3: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg4: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg5: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> Vec2hArray: ...
@overload
def Cat(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4fArray: ...
@overload
def Cat(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4fArray: ...
@overload
def Cat(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4fArray: ...
@overload
def Cat(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg4: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4fArray: ...
@overload
def Cat(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg4: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg5: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4fArray: ...
@overload
def Cat(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Vec3fArray: ...
@overload
def Cat(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Vec3fArray: ...
@overload
def Cat(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg3: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Vec3fArray: ...
@overload
def Cat(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg3: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg4: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Vec3fArray: ...
@overload
def Cat(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg3: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg4: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg5: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> Vec3fArray: ...
@overload
def Cat(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Vec2fArray: ...
@overload
def Cat(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Vec2fArray: ...
@overload
def Cat(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg3: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Vec2fArray: ...
@overload
def Cat(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg3: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg4: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Vec2fArray: ...
@overload
def Cat(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg3: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg4: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg5: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> Vec2fArray: ...
@overload
def Cat(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4dArray: ...
@overload
def Cat(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4dArray: ...
@overload
def Cat(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4dArray: ...
@overload
def Cat(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg4: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4dArray: ...
@overload
def Cat(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg3: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg4: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg5: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> Vec4dArray: ...
@overload
def Cat(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Vec3dArray: ...
@overload
def Cat(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Vec3dArray: ...
@overload
def Cat(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg3: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Vec3dArray: ...
@overload
def Cat(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg3: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg4: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Vec3dArray: ...
@overload
def Cat(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg3: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg4: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg5: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> Vec3dArray: ...
@overload
def Cat(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Vec2dArray: ...
@overload
def Cat(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Vec2dArray: ...
@overload
def Cat(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg3: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg4: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Vec2dArray: ...
@overload
def Cat(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg3: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg4: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg5: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> Vec2dArray: ...
def CharArrayFromBuffer(arg1: object, /) -> Any: ...
def Double(arg1: float, /) -> _ValueWrapper:
    """Double(value) -> _ValueWrapper

    value : double

    Use this function to specify a value with the explicit C++ type double when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def DoubleArrayFromBuffer(arg1: object, /) -> Any: ...
def DualQuatdArrayFromBuffer(arg1: object, /) -> Any: ...
def DualQuatfArrayFromBuffer(arg1: object, /) -> Any: ...
def DualQuathArrayFromBuffer(arg1: object, /) -> Any: ...
@overload
def Equal(arg1: DualQuathArray, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.DualQuath, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuathArray, arg2: pxr.Gf.DualQuath, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuathArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuathArray, arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatfArray, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatfArray, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatfArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatfArray, arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatdArray, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatdArray, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatdArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DualQuatdArray, arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def Equal(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: float, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: DoubleArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def Equal(arg1: DoubleArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: DoubleArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: float, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: FloatArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def Equal(arg1: FloatArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: FloatArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: object, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: HalfArray | typing.Iterable[float], arg2: object, /) -> BoolArray: ...
@overload
def Equal(arg1: HalfArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: HalfArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Equal(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Equal(arg1: bool, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Equal(arg1: BoolArray | typing.Iterable[bool], arg2: bool, /) -> BoolArray: ...
@overload
def Equal(arg1: BoolArray | typing.Iterable[bool], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Equal(arg1: BoolArray | typing.Iterable[bool], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Equal(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: str | pxr.Ar.ResolvedPath, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def Equal(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: UCharArray, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Equal(arg1: UCharArray, arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: UCharArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Equal(arg1: UCharArray, arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Equal(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: ShortArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: ShortArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: ShortArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UShortArray, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Equal(arg1: UShortArray, arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: UShortArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Equal(arg1: UShortArray, arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Equal(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: IntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: IntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: IntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UIntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: UIntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UIntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: Int64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: Int64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: Int64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: int, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UInt64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Equal(arg1: UInt64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: UInt64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Matrix4f, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: pxr.Gf.Matrix4f, /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Matrix3f, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: pxr.Gf.Matrix3f, /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Matrix2f, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: pxr.Gf.Matrix2f, /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Matrix4d, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: pxr.Gf.Matrix4d, /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Matrix3d, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: pxr.Gf.Matrix3d, /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Matrix2d, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: pxr.Gf.Matrix2d, /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def Equal(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def Equal(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Quath, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: pxr.Gf.Quath, /) -> BoolArray: ...
@overload
def Equal(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Quatf | pxr.Gf.Quath, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> BoolArray: ...
@overload
def Equal(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> BoolArray: ...
@overload
def Equal(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def Equal(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Quaternion, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def Equal(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: pxr.Gf.Quaternion, /) -> BoolArray: ...
@overload
def Equal(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def Equal(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Range3f | list[float] | tuple[float, float, float], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Range3f | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Range3d | list[float] | tuple[float, float, float], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Range3d | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Range2f | list[float] | tuple[float, float], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Range2f | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Range2d | list[float] | tuple[float, float], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Range2d | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Range1f, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def Equal(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: pxr.Gf.Range1f, /) -> BoolArray: ...
@overload
def Equal(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def Equal(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def Equal(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Range1d, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def Equal(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: pxr.Gf.Range1d, /) -> BoolArray: ...
@overload
def Equal(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def Equal(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def Equal(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Interval, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def Equal(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: pxr.Gf.Interval, /) -> BoolArray: ...
@overload
def Equal(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def Equal(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def Equal(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Rect2i, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def Equal(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: pxr.Gf.Rect2i, /) -> BoolArray: ...
@overload
def Equal(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def Equal(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def Equal(arg1: StringArray, arg2: StringArray, /) -> BoolArray: ...
@overload
def Equal(arg1: str | pxr.Ar.ResolvedPath, arg2: StringArray, /) -> BoolArray: ...
@overload
def Equal(arg1: StringArray, arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def Equal(arg1: StringArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: StringArray, /) -> BoolArray: ...
@overload
def Equal(arg1: StringArray, arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: StringArray, /) -> BoolArray: ...
@overload
def Equal(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: object, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: object, /) -> BoolArray: ...
@overload
def Equal(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec2h | list[float] | tuple[float, float], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Vec2h | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec2f | list[float] | tuple[float, float], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Vec2f | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: pxr.Gf.Vec2d | list[float] | tuple[float, float], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Vec2d | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def Equal(arg1: tuple, arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def Equal(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def Equal(arg1: list, arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
def Float(arg1: float, /) -> _ValueWrapper:
    """Float(value) -> _ValueWrapper

    value : float

    Use this function to specify a value with the explicit C++ type float when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def FloatArrayFromBuffer(arg1: object, /) -> Any: ...
@overload
def Greater(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: float, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: DoubleArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def Greater(arg1: DoubleArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: DoubleArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: float, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: FloatArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def Greater(arg1: FloatArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: FloatArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: object, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: HalfArray | typing.Iterable[float], arg2: object, /) -> BoolArray: ...
@overload
def Greater(arg1: HalfArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: HalfArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Greater(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Greater(arg1: bool, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Greater(arg1: BoolArray | typing.Iterable[bool], arg2: bool, /) -> BoolArray: ...
@overload
def Greater(arg1: BoolArray | typing.Iterable[bool], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Greater(arg1: BoolArray | typing.Iterable[bool], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Greater(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: str | pxr.Ar.ResolvedPath, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def Greater(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: UCharArray, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Greater(arg1: UCharArray, arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: UCharArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Greater(arg1: UCharArray, arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Greater(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: ShortArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: ShortArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: ShortArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UShortArray, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Greater(arg1: UShortArray, arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: UShortArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Greater(arg1: UShortArray, arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Greater(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: IntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: IntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: IntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UIntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: UIntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UIntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: Int64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: Int64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: Int64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: int, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UInt64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Greater(arg1: UInt64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: UInt64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Greater(arg1: StringArray, arg2: StringArray, /) -> BoolArray: ...
@overload
def Greater(arg1: str | pxr.Ar.ResolvedPath, arg2: StringArray, /) -> BoolArray: ...
@overload
def Greater(arg1: StringArray, arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def Greater(arg1: StringArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: StringArray, /) -> BoolArray: ...
@overload
def Greater(arg1: StringArray, arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: StringArray, /) -> BoolArray: ...
@overload
def Greater(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: object, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: object, /) -> BoolArray: ...
@overload
def Greater(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def Greater(arg1: tuple, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Greater(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def Greater(arg1: list, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: float, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: float, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: object, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: object, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: bool, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: bool, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: str | pxr.Ar.ResolvedPath, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UCharArray, arg2: UCharArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: UCharArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UCharArray, arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UCharArray, arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: UCharArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UCharArray, arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: UCharArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UShortArray, arg2: UShortArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: UShortArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UShortArray, arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UShortArray, arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: UShortArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UShortArray, arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: UShortArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: IntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: IntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: IntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: int, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: StringArray, arg2: StringArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: str | pxr.Ar.ResolvedPath, arg2: StringArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: StringArray, arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: StringArray, arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: StringArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: StringArray, arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: StringArray, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: object, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: object, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: tuple, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def GreaterOrEqual(arg1: list, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
def Half(arg1: object, /) -> _ValueWrapper:
    """Half(value) -> _ValueWrapper

    value : half

    Use this function to specify a value with the explicit C++ type GfHalf when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def HalfArrayFromBuffer(arg1: object, /) -> Any: ...
def Int(arg1: int, /) -> _ValueWrapper:
    """Int(value) -> _ValueWrapper

    value : int

    Use this function to specify a value with the explicit C++ type int when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def Int64(arg1: int, /) -> _ValueWrapper:
    """Int64(value) -> _ValueWrapper

    value : int64_t

    Use this function to specify a value with the explicit C++ type int64_t when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def Int64ArrayFromBuffer(arg1: object, /) -> Any: ...
def IntArrayFromBuffer(arg1: object, /) -> Any: ...
@overload
def Less(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: float, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: DoubleArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def Less(arg1: DoubleArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: DoubleArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: float, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: FloatArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def Less(arg1: FloatArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: FloatArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: object, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: HalfArray | typing.Iterable[float], arg2: object, /) -> BoolArray: ...
@overload
def Less(arg1: HalfArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: HalfArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def Less(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Less(arg1: bool, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Less(arg1: BoolArray | typing.Iterable[bool], arg2: bool, /) -> BoolArray: ...
@overload
def Less(arg1: BoolArray | typing.Iterable[bool], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Less(arg1: BoolArray | typing.Iterable[bool], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def Less(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: str | pxr.Ar.ResolvedPath, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def Less(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: UCharArray, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Less(arg1: UCharArray, arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: UCharArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Less(arg1: UCharArray, arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: UCharArray, /) -> BoolArray: ...
@overload
def Less(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: ShortArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: ShortArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: ShortArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UShortArray, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Less(arg1: UShortArray, arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: UShortArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Less(arg1: UShortArray, arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: UShortArray, /) -> BoolArray: ...
@overload
def Less(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: IntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: IntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: IntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UIntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: UIntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UIntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: Int64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: Int64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: Int64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: int, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UInt64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def Less(arg1: UInt64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: UInt64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def Less(arg1: StringArray, arg2: StringArray, /) -> BoolArray: ...
@overload
def Less(arg1: str | pxr.Ar.ResolvedPath, arg2: StringArray, /) -> BoolArray: ...
@overload
def Less(arg1: StringArray, arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def Less(arg1: StringArray, arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: StringArray, /) -> BoolArray: ...
@overload
def Less(arg1: StringArray, arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: StringArray, /) -> BoolArray: ...
@overload
def Less(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: object, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: object, /) -> BoolArray: ...
@overload
def Less(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def Less(arg1: tuple, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def Less(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def Less(arg1: list, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: float, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: DoubleArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: float, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: FloatArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: object, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: object, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: HalfArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: bool, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: bool, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: BoolArray | typing.Iterable[bool], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: str | pxr.Ar.ResolvedPath, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UCharArray, arg2: UCharArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: UCharArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UCharArray, arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UCharArray, arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: UCharArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UCharArray, arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: UCharArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: ShortArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UShortArray, arg2: UShortArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: UShortArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UShortArray, arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UShortArray, arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: UShortArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UShortArray, arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: UShortArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: IntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: IntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: IntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UIntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: Int64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: int, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: UInt64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: StringArray, arg2: StringArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: str | pxr.Ar.ResolvedPath, arg2: StringArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: StringArray, arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: StringArray, arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: StringArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: StringArray, arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: StringArray, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: object, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: object, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: tuple, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def LessOrEqual(arg1: list, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
def Long(arg1: int, /) -> _ValueWrapper:
    """Long(value) -> _ValueWrapper

    value : long

    Use this function to specify a value with the explicit C++ type long when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def Matrix2dArrayFromBuffer(arg1: object, /) -> Any: ...
def Matrix2fArrayFromBuffer(arg1: object, /) -> Any: ...
def Matrix3dArrayFromBuffer(arg1: object, /) -> Any: ...
def Matrix3fArrayFromBuffer(arg1: object, /) -> Any: ...
def Matrix4dArrayFromBuffer(arg1: object, /) -> Any: ...
def Matrix4fArrayFromBuffer(arg1: object, /) -> Any: ...
@overload
def NotEqual(arg1: DualQuathArray, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.DualQuath, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuathArray, arg2: pxr.Gf.DualQuath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuathArray, arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuathArray, arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: DualQuathArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatfArray, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatfArray, arg2: pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatfArray, arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatfArray, arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: DualQuatfArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatdArray, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatdArray, arg2: pxr.Gf.DualQuatd | pxr.Gf.DualQuatf | pxr.Gf.DualQuath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatdArray, arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DualQuatdArray, arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: DualQuatdArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DoubleArray | typing.Iterable[float], arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: float, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: DoubleArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def NotEqual(arg1: DoubleArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: DoubleArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: DoubleArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: FloatArray | typing.Iterable[float], arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: float, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: FloatArray | typing.Iterable[float], arg2: float, /) -> BoolArray: ...
@overload
def NotEqual(arg1: FloatArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: FloatArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: FloatArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: HalfArray | typing.Iterable[float], arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: object, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: HalfArray | typing.Iterable[float], arg2: object, /) -> BoolArray: ...
@overload
def NotEqual(arg1: HalfArray | typing.Iterable[float], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: HalfArray | typing.Iterable[float], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: HalfArray | typing.Iterable[float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: BoolArray | typing.Iterable[bool], arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def NotEqual(arg1: bool, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def NotEqual(arg1: BoolArray | typing.Iterable[bool], arg2: bool, /) -> BoolArray: ...
@overload
def NotEqual(arg1: BoolArray | typing.Iterable[bool], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def NotEqual(arg1: BoolArray | typing.Iterable[bool], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: BoolArray | typing.Iterable[bool], /) -> BoolArray: ...
@overload
def NotEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: str | pxr.Ar.ResolvedPath, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: CharArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UCharArray, arg2: UCharArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: UCharArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UCharArray, arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UCharArray, arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: UCharArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UCharArray, arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: UCharArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: ShortArray | typing.Iterable[int], arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: ShortArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: ShortArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: ShortArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: ShortArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UShortArray, arg2: UShortArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: UShortArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UShortArray, arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UShortArray, arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: UShortArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UShortArray, arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: UShortArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntArray | typing.Iterable[int], arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: IntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UIntArray | typing.Iterable[int], arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UIntArray | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UIntArray | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UIntArray | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: UIntArray | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Int64Array | typing.Iterable[int], arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Int64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Int64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Int64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Int64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UInt64Array | typing.Iterable[int], arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: int, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UInt64Array | typing.Iterable[int], arg2: int, /) -> BoolArray: ...
@overload
def NotEqual(arg1: UInt64Array | typing.Iterable[int], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: UInt64Array | typing.Iterable[int], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: UInt64Array | typing.Iterable[int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Matrix4f, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: pxr.Gf.Matrix4f, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Matrix4fArray | typing.Iterable[pxr.Gf.Matrix4f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Matrix3f, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: pxr.Gf.Matrix3f, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Matrix3fArray | typing.Iterable[pxr.Gf.Matrix3f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Matrix2f, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: pxr.Gf.Matrix2f, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Matrix2fArray | typing.Iterable[pxr.Gf.Matrix2f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Matrix4d, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: pxr.Gf.Matrix4d, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Matrix4dArray | typing.Iterable[pxr.Gf.Matrix4d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Matrix3d, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: pxr.Gf.Matrix3d, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Matrix3dArray | typing.Iterable[pxr.Gf.Matrix3d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Matrix2d, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: pxr.Gf.Matrix2d, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Matrix2dArray | typing.Iterable[pxr.Gf.Matrix2d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Quath, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: pxr.Gf.Quath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuathArray | typing.Iterable[pxr.Gf.Quath], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: QuathArray | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Quatf | pxr.Gf.Quath, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: pxr.Gf.Quatf | pxr.Gf.Quath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: QuatfArray | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: pxr.Gf.Quatd | pxr.Gf.Quatf | pxr.Gf.Quath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: QuatdArray | typing.Iterable[pxr.Gf.Quatd] | typing.Iterable[pxr.Gf.Quatf] | typing.Iterable[pxr.Gf.Quath], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Quaternion, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: pxr.Gf.Quaternion, /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def NotEqual(arg1: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: QuaternionArray | typing.Iterable[pxr.Gf.Quaternion], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Range3f | list[float] | tuple[float, float, float], arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Range3f | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Range3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Range3d | list[float] | tuple[float, float, float], arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Range3d | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Range3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Range2f | list[float] | tuple[float, float], arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Range2f | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Range2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Range2d | list[float] | tuple[float, float], arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Range2d | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Range2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Range2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Range1f, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: pxr.Gf.Range1f, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1fArray | typing.Iterable[pxr.Gf.Range1f], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Range1fArray | typing.Iterable[pxr.Gf.Range1f], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Range1d, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: pxr.Gf.Range1d, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Range1dArray | typing.Iterable[pxr.Gf.Range1d], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Range1dArray | typing.Iterable[pxr.Gf.Range1d], /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Interval, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: pxr.Gf.Interval, /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def NotEqual(arg1: IntervalArray | typing.Iterable[pxr.Gf.Interval], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: IntervalArray | typing.Iterable[pxr.Gf.Interval], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Rect2i, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: pxr.Gf.Rect2i, /) -> BoolArray: ...
@overload
def NotEqual(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Rect2iArray | typing.Iterable[pxr.Gf.Rect2i], /) -> BoolArray: ...
@overload
def NotEqual(arg1: StringArray, arg2: StringArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: str | pxr.Ar.ResolvedPath, arg2: StringArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: StringArray, arg2: str | pxr.Ar.ResolvedPath, /) -> BoolArray: ...
@overload
def NotEqual(arg1: StringArray, arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: StringArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: StringArray, arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: StringArray, /) -> BoolArray: ...
@overload
def NotEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: object, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: object, /) -> BoolArray: ...
@overload
def NotEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: TokenArray | typing.Iterable[pxr.Ar.ResolvedPath] | typing.Iterable[str], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: pxr.Gf.Vec4i | list[int] | tuple[int, int, int, int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec4iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Vec4i] | typing.Iterable[tuple[int, int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: pxr.Gf.Vec3i | list[int] | pxr.Gf.Size3 | tuple[int, int, int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec3iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size3] | typing.Iterable[pxr.Gf.Vec3i] | typing.Iterable[tuple[int, int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: pxr.Gf.Vec2i | list[int] | pxr.Gf.Size2 | tuple[int, int], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec2iArray | typing.Iterable[list[int]] | typing.Iterable[pxr.Gf.Size2] | typing.Iterable[pxr.Gf.Vec2i] | typing.Iterable[tuple[int, int]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: pxr.Gf.Vec4h | list[float] | tuple[float, float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec4hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4h] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Vec3h | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec3hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3h] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec2h | list[float] | tuple[float, float], arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Vec2h | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec2hArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2h] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: pxr.Gf.Vec4f | list[float] | tuple[float, float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec4fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4f] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec3fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3f] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec2f | list[float] | tuple[float, float], arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Vec2f | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec2fArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2f] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: pxr.Gf.Vec4d | list[float] | tuple[float, float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec4dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec4d] | typing.Iterable[tuple[float, float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec3dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec3d] | typing.Iterable[tuple[float, float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: pxr.Gf.Vec2d | list[float] | tuple[float, float], arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: pxr.Gf.Vec2d | list[float] | tuple[float, float], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: tuple, /) -> BoolArray: ...
@overload
def NotEqual(arg1: tuple, arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
@overload
def NotEqual(arg1: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], arg2: list, /) -> BoolArray: ...
@overload
def NotEqual(arg1: list, arg2: Vec2dArray | typing.Iterable[list[float]] | typing.Iterable[pxr.Gf.Vec2d] | typing.Iterable[tuple[float, float]], /) -> BoolArray: ...
def QuatdArrayFromBuffer(arg1: object, /) -> Any: ...
def QuatfArrayFromBuffer(arg1: object, /) -> Any: ...
def QuathArrayFromBuffer(arg1: object, /) -> Any: ...
def Range1dArrayFromBuffer(arg1: object, /) -> Any: ...
def Range1fArrayFromBuffer(arg1: object, /) -> Any: ...
def Range2dArrayFromBuffer(arg1: object, /) -> Any: ...
def Range2fArrayFromBuffer(arg1: object, /) -> Any: ...
def Range3dArrayFromBuffer(arg1: object, /) -> Any: ...
def Range3fArrayFromBuffer(arg1: object, /) -> Any: ...
def Rect2iArrayFromBuffer(arg1: object, /) -> Any: ...
def Short(arg1: int, /) -> _ValueWrapper:
    """Short(value) -> _ValueWrapper

    value : short

    Use this function to specify a value with the explicit C++ type short when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def ShortArrayFromBuffer(arg1: object, /) -> Any: ...
def Token(arg1: object, /) -> _ValueWrapper:
    """TfToken(value) -> _ValueWrapper

    value : TfToken

    Use this function to specify a value with the explicit C++ type TfToken when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def UChar(arg1: int, /) -> _ValueWrapper:
    """UChar(value) -> _ValueWrapper

    value : unsigned char

    Use this function to specify a value with the explicit C++ type unsigned char when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def UCharArrayFromBuffer(arg1: object, /) -> Any: ...
def UInt(arg1: int, /) -> _ValueWrapper:
    """UInt(value) -> _ValueWrapper

    value : unsigned int

    Use this function to specify a value with the explicit C++ type unsigned int when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def UInt64(arg1: int, /) -> _ValueWrapper:
    """UInt64(value) -> _ValueWrapper

    value : uint64_t

    Use this function to specify a value with the explicit C++ type uint64_t when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def UInt64ArrayFromBuffer(arg1: object, /) -> Any: ...
def UIntArrayFromBuffer(arg1: object, /) -> Any: ...
def ULong(arg1: int, /) -> _ValueWrapper:
    """ULong(value) -> _ValueWrapper

    value : unsigned long

    Use this function to specify a value with the explicit C++ type unsigned long when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def UShort(arg1: int, /) -> _ValueWrapper:
    """UShort(value) -> _ValueWrapper

    value : unsigned short

    Use this function to specify a value with the explicit C++ type unsigned short when calling a C++ wrapped function that expects a VtValue. (There are some C++ types that have no equivalents in Python, such as short.)"""
def UShortArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec2dArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec2fArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec2hArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec2iArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec3dArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec3fArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec3hArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec3iArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec4dArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec4fArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec4hArrayFromBuffer(arg1: object, /) -> Any: ...
def Vec4iArrayFromBuffer(arg1: object, /) -> Any: ...
def _ReturnDictionary(arg1: object, /) -> Any: ...
def _test_Ident(arg1: object, /) -> Any: ...
def _test_Str(arg1: object, /) -> str: ...
def _test_ValueTypeName(arg1: object, /) -> str: ...

import asyncio
import collections.abc
import concurrent.futures
import contextvars
import enum
from . import futures, tasks
from PySide6.QtCore import QCoreApplication, QEventLoop, QObject, QThread
from _typeshed import Incomplete
from typing import Any, Callable, TypeVar
from typing_extensions import TypeVarTuple, Unpack

__all__ = ['QAsyncioEventLoopPolicy', 'QAsyncioEventLoop', 'QAsyncioHandle', 'QAsyncioTimerHandle']

_T = TypeVar('_T')
_Ts = TypeVarTuple('_Ts')
Context = contextvars.Context

class QAsyncioExecutorWrapper(QObject):
    _loop: QEventLoop
    _func: Incomplete
    _args: Incomplete
    _result: Any
    _exception: BaseException | None
    def __init__(self, func: Callable[[Unpack[_Ts]], Any], *args: Unpack[_Ts]) -> None: ...
    def _cb(self) -> None: ...
    def do(self) -> Any: ...
    def exit(self) -> None: ...

class QAsyncioEventLoopPolicy(asyncio.AbstractEventLoopPolicy):
    _application: Incomplete
    _quit_qapp: Incomplete
    _event_loop: asyncio.AbstractEventLoop | None
    def __init__(self, quit_qapp: bool = True, handle_sigint: bool = False) -> None: ...
    def get_event_loop(self) -> asyncio.AbstractEventLoop: ...
    def set_event_loop(self, loop: asyncio.AbstractEventLoop | None) -> None: ...
    def new_event_loop(self) -> asyncio.AbstractEventLoop: ...
    def get_child_watcher(self) -> asyncio.AbstractChildWatcher: ...
    def set_child_watcher(self, watcher: asyncio.AbstractChildWatcher) -> None: ...

class QAsyncioEventLoop(asyncio.BaseEventLoop, QObject):
    class ShutDownThread(QThread):
        _future: Incomplete
        _loop: Incomplete
        def __init__(self, future: futures.QAsyncioFuture, loop: QAsyncioEventLoop) -> None: ...
        def run(self) -> None: ...
        def shutdown(self) -> None: ...
    _application: QCoreApplication
    _quit_qapp: Incomplete
    _thread: Incomplete
    _closed: bool
    _quit_from_inside: bool
    _quit_from_outside: bool
    _asyncgens: set[collections.abc.AsyncGenerator]
    _default_executor: Incomplete
    _exception_handler: Callable | None
    _task_factory: Callable | None
    _future_to_complete: futures.QAsyncioFuture | None
    _debug: Incomplete
    def __init__(self, application: QCoreApplication, quit_qapp: bool = True) -> None: ...
    def _run_until_complete_cb(self, future: futures.QAsyncioFuture) -> None: ...
    def run_until_complete(self, future: futures.QAsyncioFuture) -> Any: ...  # type: ignore[override]
    def run_forever(self) -> None: ...
    def _about_to_quit_cb(self) -> None: ...
    def stop(self) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def close(self) -> None: ...
    async def shutdown_asyncgens(self) -> None: ...
    async def shutdown_default_executor(self, timeout: int | float | None = None) -> None: ...
    def _call_soon_impl(self, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None, is_threadsafe: bool | None = False) -> asyncio.Handle: ...
    def call_soon(self, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None) -> asyncio.Handle: ...
    def call_soon_threadsafe(self, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None) -> asyncio.Handle: ...
    def _call_later_impl(self, delay: float, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None, is_threadsafe: bool | None = False) -> asyncio.TimerHandle: ...
    def call_later(self, delay: float, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None) -> asyncio.TimerHandle: ...
    def _call_at_impl(self, when: float, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None, is_threadsafe: bool | None = False) -> asyncio.TimerHandle: ...
    def call_at(self, when: float, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts], context: Context | None = None) -> asyncio.TimerHandle: ...
    def time(self) -> float: ...
    def create_future(self) -> futures.QAsyncioFuture: ...  # type: ignore[override]
    def create_task(self, coro: collections.abc.Generator | collections.abc.Coroutine, *, name: str | None = None, context: contextvars.Context | None = None) -> tasks.QAsyncioTask: ...  # type: ignore[override]
    def set_task_factory(self, factory: Callable | None) -> None: ...
    def get_task_factory(self) -> Callable | None: ...
    async def create_connection(self, protocol_factory, host=None, port=None, *, ssl=None, family: int = 0, proto: int = 0, flags: int = 0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, happy_eyeballs_delay=None, interleave=None) -> None: ...  # type: ignore[override]
    async def create_datagram_endpoint(self, protocol_factory, local_addr=None, remote_addr=None, *, family: int = 0, proto: int = 0, flags: int = 0, reuse_address=None, reuse_port=None, allow_broadcast=None, sock=None) -> None: ...  # type: ignore[override]
    async def create_unix_connection(self, protocol_factory, path=None, *, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None) -> None: ...  # type: ignore[override]
    async def create_server(self, protocol_factory, host=None, port=None, *, family=..., flags=..., sock=None, backlog: int = 100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving: bool = True) -> None: ...  # type: ignore[override]
    async def create_unix_server(self, protocol_factory, path=None, *, sock=None, backlog: int = 100, ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving: bool = True) -> None: ...  # type: ignore[override]
    async def connect_accepted_socket(self, protocol_factory, sock, *, ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None) -> None: ...  # type: ignore[override]
    async def sendfile(self, transport, file, offset: int = 0, count=None, *, fallback: bool = True) -> None: ...  # type: ignore[override]
    async def start_tls(self, transport, protocol, sslcontext, *, server_side: bool = False, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None) -> None: ...
    def add_reader(self, fd, callback, *args) -> None: ...  # type: ignore[override]
    def remove_reader(self, fd) -> None: ...  # type: ignore[override]
    def add_writer(self, fd, callback, *args) -> None: ...  # type: ignore[override]
    def remove_writer(self, fd) -> None: ...  # type: ignore[override]
    async def sock_recv(self, sock, nbytes) -> None: ...  # type: ignore[override]
    async def sock_recv_into(self, sock, buf) -> None: ...  # type: ignore[override]
    async def sock_recvfrom(self, sock, bufsize) -> None: ...
    async def sock_recvfrom_into(self, sock, buf, nbytes: int = 0) -> None: ...
    async def sock_sendall(self, sock, data) -> None: ...
    async def sock_sendto(self, sock, data, address) -> None: ...
    async def sock_connect(self, sock, address) -> None: ...
    async def sock_accept(self, sock) -> None: ...  # type: ignore[override]
    async def sock_sendfile(self, sock, file, offset: int = 0, count=None, *, fallback=None) -> None: ...  # type: ignore[override]
    async def getaddrinfo(self, host, port, *, family: int = 0, type: int = 0, proto: int = 0, flags: int = 0) -> None: ...  # type: ignore[override]
    async def getnameinfo(self, sockaddr, flags: int = 0) -> None: ...  # type: ignore[override]
    async def connect_read_pipe(self, protocol_factory, pipe) -> None: ...  # type: ignore[override]
    async def connect_write_pipe(self, protocol_factory, pipe) -> None: ...  # type: ignore[override]
    def add_signal_handler(self, sig, callback, *args) -> None: ...  # type: ignore[override]
    def remove_signal_handler(self, sig) -> None: ...  # type: ignore[override]
    def run_in_executor(self, executor: concurrent.futures.ThreadPoolExecutor | None, func: Callable[[Unpack[_Ts]], _T], *args: Unpack[_Ts]) -> asyncio.Future[_T]: ...  # type: ignore[override]
    def set_default_executor(self, executor: concurrent.futures.ThreadPoolExecutor | None) -> None: ...  # type: ignore[override]
    def set_exception_handler(self, handler: Callable | None) -> None: ...
    def get_exception_handler(self) -> Callable | None: ...
    def default_exception_handler(self, context: dict[str, Any]) -> None: ...
    def call_exception_handler(self, context: dict[str, Any]) -> None: ...
    def get_debug(self) -> bool: ...
    def set_debug(self, enabled: bool) -> None: ...
    async def subprocess_exec(self, protocol_factory, *args, stdin=..., stdout=..., stderr=..., **kwargs) -> None: ...  # type: ignore[override]
    async def subprocess_shell(self, protocol_factory, cmd, *, stdin=..., stdout=..., stderr=..., **kwargs) -> None: ...  # type: ignore[override]

class QAsyncioHandle:
    class HandleState(enum.Enum):
        PENDING = ...
        CANCELLED = ...
        DONE = ...
    _callback: Incomplete
    _cb_args: Incomplete
    _loop: Incomplete
    _context: Incomplete
    _is_threadsafe: Incomplete
    _timeout: int
    _state: Incomplete
    def __init__(self, callback: Callable, args: tuple, loop: QAsyncioEventLoop, context: contextvars.Context | None, is_threadsafe: bool | None = False) -> None: ...
    def _start(self) -> None: ...
    def _schedule_event(self, timeout: int, func: Callable) -> None: ...
    def _cb(self) -> None: ...
    def cancel(self) -> None: ...
    def cancelled(self) -> bool: ...

class QAsyncioTimerHandle(QAsyncioHandle, asyncio.TimerHandle):
    _when: Incomplete
    _timeout: Incomplete
    def __init__(self, when: float, callback: Callable, args: tuple, loop: QAsyncioEventLoop, context: contextvars.Context | None, is_threadsafe: bool | None = False) -> None: ...
    def _start(self) -> None: ...
    def when(self) -> float: ...

import asyncio
import collections.abc
import contextvars
from . import events as events, futures as futures
from _typeshed import Incomplete
from typing import Any

class QAsyncioTask(futures.QAsyncioFuture):
    _source_traceback: Incomplete
    _state: futures.QAsyncioFuture.FutureState
    _exception: BaseException | None
    _coro: Incomplete
    _name: Incomplete
    _future_to_await: asyncio.Future | None
    _cancelled: bool
    _cancel_count: int
    _cancel_message: str | None
    _tb: str | None
    def __init__(self, coro: collections.abc.Generator | collections.abc.Coroutine, *, loop: events.QAsyncioEventLoop | None = None, name: str | None = None, context: contextvars.Context | None = None) -> None: ...
    def __repr__(self) -> str: ...
    class QtTaskApiMisuseError(Exception): ...
    def set_result(self, result: Any) -> None: ...
    def set_exception(self, exception: Any) -> None: ...
    _result: Incomplete
    def _step(self, exception_or_future: BaseException | futures.QAsyncioFuture | None = None) -> None: ...
    def get_stack(self, *, limit=None) -> list[Any]: ...
    def print_stack(self, *, limit=None, file=None) -> None: ...
    def get_coro(self) -> collections.abc.Generator | collections.abc.Coroutine: ...
    def get_name(self) -> str: ...
    def set_name(self, value) -> None: ...
    def cancel(self, msg: str | None = None) -> bool: ...
    def uncancel(self) -> int: ...
    def cancelling(self) -> int: ...

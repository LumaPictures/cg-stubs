# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""

hou

Module containing all the sub-modules, classes, and functions to access
Houdini.

API



"""

from sys import version_info as _swig_python_version_info

if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from .. import _hou
else:
    import _hou

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (
        self.__class__.__module__,
        self.__class__.__name__,
        strthis,
    )


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)

    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)

    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""

    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())

    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _hou.SwigPyIterator_value(self)

    def incr(self, n: "size_t" = 1) -> "swig::SwigPyIterator *":
        return _hou.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t" = 1) -> "swig::SwigPyIterator *":
        return _hou.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _hou.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _hou.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _hou.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _hou.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _hou.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _hou.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _hou.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _hou.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _hou.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _hou.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _hou.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _hou.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _hou.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self


# Register SwigPyIterator in _hou:
_hou.SwigPyIterator_swigregister(SwigPyIterator)


class _StringTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._StringTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._StringTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._StringTuple___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _hou._StringTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< std::string >::difference_type",
        j: "std::vector< std::string >::difference_type",
    ) -> "std::vector< std::string,std::allocator< std::string > > *":
        return _hou._StringTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._StringTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< std::string >::difference_type",
        j: "std::vector< std::string >::difference_type",
    ) -> "void":
        return _hou._StringTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._StringTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _hou._StringTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._StringTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _hou._StringTuple_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _hou._StringTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._StringTuple_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _hou._StringTuple_size(self)

    def swap(self, v: "_StringTuple") -> "void":
        return _hou._StringTuple_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _hou._StringTuple_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _hou._StringTuple_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _hou._StringTuple_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _hou._StringTuple_rend(self)

    def clear(self) -> "void":
        return _hou._StringTuple_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _hou._StringTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._StringTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _hou._StringTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._StringTuple_swiginit(self, _hou.new__StringTuple(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _hou._StringTuple_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _hou._StringTuple_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _hou._StringTuple_back(self)

    def assign(
        self,
        n: "std::vector< std::string >::size_type",
        x: "std::vector< std::string >::value_type const &",
    ) -> "void":
        return _hou._StringTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._StringTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._StringTuple_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _hou._StringTuple_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _hou._StringTuple_capacity(self)

    __swig_destroy__ = _hou.delete__StringTuple


# Register _StringTuple in _hou:
_hou._StringTuple_swigregister(_StringTuple)


class _StringTupleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._StringTupleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._StringTupleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._StringTupleTuple___bool__(self)

    def __len__(self) -> "std::vector< std::vector< std::string > >::size_type":
        return _hou._StringTupleTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< std::vector< std::string > >::difference_type",
        j: "std::vector< std::vector< std::string > >::difference_type",
    ) -> "std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > > *":
        return _hou._StringTupleTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._StringTupleTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< std::vector< std::string > >::difference_type",
        j: "std::vector< std::vector< std::string > >::difference_type",
    ) -> "void":
        return _hou._StringTupleTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._StringTupleTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< std::vector< std::string > >::value_type const &":
        return _hou._StringTupleTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._StringTupleTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< std::string > >::value_type":
        return _hou._StringTupleTuple_pop(self)

    def append(self, x: "_StringTuple") -> "void":
        return _hou._StringTupleTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._StringTupleTuple_empty(self)

    def size(self) -> "std::vector< std::vector< std::string > >::size_type":
        return _hou._StringTupleTuple_size(self)

    def swap(self, v: "_StringTupleTuple") -> "void":
        return _hou._StringTupleTuple_swap(self, v)

    def begin(self) -> "std::vector< std::vector< std::string > >::iterator":
        return _hou._StringTupleTuple_begin(self)

    def end(self) -> "std::vector< std::vector< std::string > >::iterator":
        return _hou._StringTupleTuple_end(self)

    def rbegin(self) -> "std::vector< std::vector< std::string > >::reverse_iterator":
        return _hou._StringTupleTuple_rbegin(self)

    def rend(self) -> "std::vector< std::vector< std::string > >::reverse_iterator":
        return _hou._StringTupleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._StringTupleTuple_clear(self)

    def get_allocator(
        self,
    ) -> "std::vector< std::vector< std::string > >::allocator_type":
        return _hou._StringTupleTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._StringTupleTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< std::string > >::iterator":
        return _hou._StringTupleTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._StringTupleTuple_swiginit(self, _hou.new__StringTupleTuple(*args))

    def push_back(self, x: "_StringTuple") -> "void":
        return _hou._StringTupleTuple_push_back(self, x)

    def front(self) -> "std::vector< std::vector< std::string > >::value_type const &":
        return _hou._StringTupleTuple_front(self)

    def back(self) -> "std::vector< std::vector< std::string > >::value_type const &":
        return _hou._StringTupleTuple_back(self)

    def assign(
        self,
        n: "std::vector< std::vector< std::string > >::size_type",
        x: "_StringTuple",
    ) -> "void":
        return _hou._StringTupleTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._StringTupleTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._StringTupleTuple_insert(self, *args)

    def reserve(
        self, n: "std::vector< std::vector< std::string > >::size_type"
    ) -> "void":
        return _hou._StringTupleTuple_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< std::string > >::size_type":
        return _hou._StringTupleTuple_capacity(self)

    __swig_destroy__ = _hou.delete__StringTupleTuple


# Register _StringTupleTuple in _hou:
_hou._StringTupleTuple_swigregister(_StringTupleTuple)


class _IntTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._IntTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._IntTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._IntTuple___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _hou._IntTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< int >::difference_type",
        j: "std::vector< int >::difference_type",
    ) -> "std::vector< int,std::allocator< int > > *":
        return _hou._IntTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._IntTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< int >::difference_type",
        j: "std::vector< int >::difference_type",
    ) -> "void":
        return _hou._IntTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._IntTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _hou._IntTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._IntTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _hou._IntTuple_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _hou._IntTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._IntTuple_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _hou._IntTuple_size(self)

    def swap(self, v: "_IntTuple") -> "void":
        return _hou._IntTuple_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _hou._IntTuple_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _hou._IntTuple_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _hou._IntTuple_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _hou._IntTuple_rend(self)

    def clear(self) -> "void":
        return _hou._IntTuple_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _hou._IntTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._IntTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _hou._IntTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._IntTuple_swiginit(self, _hou.new__IntTuple(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _hou._IntTuple_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _hou._IntTuple_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _hou._IntTuple_back(self)

    def assign(
        self,
        n: "std::vector< int >::size_type",
        x: "std::vector< int >::value_type const &",
    ) -> "void":
        return _hou._IntTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._IntTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._IntTuple_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _hou._IntTuple_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _hou._IntTuple_capacity(self)

    __swig_destroy__ = _hou.delete__IntTuple


# Register _IntTuple in _hou:
_hou._IntTuple_swigregister(_IntTuple)


class _IntTupleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._IntTupleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._IntTupleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._IntTupleTuple___bool__(self)

    def __len__(self) -> "std::vector< std::vector< int > >::size_type":
        return _hou._IntTupleTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< std::vector< int > >::difference_type",
        j: "std::vector< std::vector< int > >::difference_type",
    ) -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *":
        return _hou._IntTupleTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._IntTupleTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< std::vector< int > >::difference_type",
        j: "std::vector< std::vector< int > >::difference_type",
    ) -> "void":
        return _hou._IntTupleTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._IntTupleTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< std::vector< int > >::value_type const &":
        return _hou._IntTupleTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._IntTupleTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< int > >::value_type":
        return _hou._IntTupleTuple_pop(self)

    def append(self, x: "_IntTuple") -> "void":
        return _hou._IntTupleTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._IntTupleTuple_empty(self)

    def size(self) -> "std::vector< std::vector< int > >::size_type":
        return _hou._IntTupleTuple_size(self)

    def swap(self, v: "_IntTupleTuple") -> "void":
        return _hou._IntTupleTuple_swap(self, v)

    def begin(self) -> "std::vector< std::vector< int > >::iterator":
        return _hou._IntTupleTuple_begin(self)

    def end(self) -> "std::vector< std::vector< int > >::iterator":
        return _hou._IntTupleTuple_end(self)

    def rbegin(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _hou._IntTupleTuple_rbegin(self)

    def rend(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _hou._IntTupleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._IntTupleTuple_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< int > >::allocator_type":
        return _hou._IntTupleTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._IntTupleTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< int > >::iterator":
        return _hou._IntTupleTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._IntTupleTuple_swiginit(self, _hou.new__IntTupleTuple(*args))

    def push_back(self, x: "_IntTuple") -> "void":
        return _hou._IntTupleTuple_push_back(self, x)

    def front(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _hou._IntTupleTuple_front(self)

    def back(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _hou._IntTupleTuple_back(self)

    def assign(
        self, n: "std::vector< std::vector< int > >::size_type", x: "_IntTuple"
    ) -> "void":
        return _hou._IntTupleTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._IntTupleTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._IntTupleTuple_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< int > >::size_type") -> "void":
        return _hou._IntTupleTuple_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< int > >::size_type":
        return _hou._IntTupleTuple_capacity(self)

    __swig_destroy__ = _hou.delete__IntTupleTuple


# Register _IntTupleTuple in _hou:
_hou._IntTupleTuple_swigregister(_IntTupleTuple)


class _Int64Tuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._Int64Tuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._Int64Tuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._Int64Tuple___bool__(self)

    def __len__(self) -> "std::vector< int64 >::size_type":
        return _hou._Int64Tuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< int64 >::difference_type",
        j: "std::vector< int64 >::difference_type",
    ) -> "std::vector< int64,std::allocator< int64 > > *":
        return _hou._Int64Tuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._Int64Tuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< int64 >::difference_type",
        j: "std::vector< int64 >::difference_type",
    ) -> "void":
        return _hou._Int64Tuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._Int64Tuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int64 >::value_type const &":
        return _hou._Int64Tuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._Int64Tuple___setitem__(self, *args)

    def pop(self) -> "std::vector< int64 >::value_type":
        return _hou._Int64Tuple_pop(self)

    def append(self, x: "std::vector< int64 >::value_type const &") -> "void":
        return _hou._Int64Tuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._Int64Tuple_empty(self)

    def size(self) -> "std::vector< int64 >::size_type":
        return _hou._Int64Tuple_size(self)

    def swap(self, v: "_Int64Tuple") -> "void":
        return _hou._Int64Tuple_swap(self, v)

    def begin(self) -> "std::vector< int64 >::iterator":
        return _hou._Int64Tuple_begin(self)

    def end(self) -> "std::vector< int64 >::iterator":
        return _hou._Int64Tuple_end(self)

    def rbegin(self) -> "std::vector< int64 >::reverse_iterator":
        return _hou._Int64Tuple_rbegin(self)

    def rend(self) -> "std::vector< int64 >::reverse_iterator":
        return _hou._Int64Tuple_rend(self)

    def clear(self) -> "void":
        return _hou._Int64Tuple_clear(self)

    def get_allocator(self) -> "std::vector< int64 >::allocator_type":
        return _hou._Int64Tuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._Int64Tuple_pop_back(self)

    def erase(self, *args) -> "std::vector< int64 >::iterator":
        return _hou._Int64Tuple_erase(self, *args)

    def __init__(self, *args):
        _hou._Int64Tuple_swiginit(self, _hou.new__Int64Tuple(*args))

    def push_back(self, x: "std::vector< int64 >::value_type const &") -> "void":
        return _hou._Int64Tuple_push_back(self, x)

    def front(self) -> "std::vector< int64 >::value_type const &":
        return _hou._Int64Tuple_front(self)

    def back(self) -> "std::vector< int64 >::value_type const &":
        return _hou._Int64Tuple_back(self)

    def assign(
        self,
        n: "std::vector< int64 >::size_type",
        x: "std::vector< int64 >::value_type const &",
    ) -> "void":
        return _hou._Int64Tuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._Int64Tuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._Int64Tuple_insert(self, *args)

    def reserve(self, n: "std::vector< int64 >::size_type") -> "void":
        return _hou._Int64Tuple_reserve(self, n)

    def capacity(self) -> "std::vector< int64 >::size_type":
        return _hou._Int64Tuple_capacity(self)

    __swig_destroy__ = _hou.delete__Int64Tuple


# Register _Int64Tuple in _hou:
_hou._Int64Tuple_swigregister(_Int64Tuple)


class _BoolTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._BoolTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._BoolTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._BoolTuple___bool__(self)

    def __len__(self) -> "std::vector< bool >::size_type":
        return _hou._BoolTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< bool >::difference_type",
        j: "std::vector< bool >::difference_type",
    ) -> "std::vector< bool,std::allocator< bool > > *":
        return _hou._BoolTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._BoolTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< bool >::difference_type",
        j: "std::vector< bool >::difference_type",
    ) -> "void":
        return _hou._BoolTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._BoolTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bool >::value_type":
        return _hou._BoolTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._BoolTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< bool >::value_type":
        return _hou._BoolTuple_pop(self)

    def append(self, x: "std::vector< bool >::value_type") -> "void":
        return _hou._BoolTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._BoolTuple_empty(self)

    def size(self) -> "std::vector< bool >::size_type":
        return _hou._BoolTuple_size(self)

    def swap(self, v: "_BoolTuple") -> "void":
        return _hou._BoolTuple_swap(self, v)

    def begin(self) -> "std::vector< bool >::iterator":
        return _hou._BoolTuple_begin(self)

    def end(self) -> "std::vector< bool >::iterator":
        return _hou._BoolTuple_end(self)

    def rbegin(self) -> "std::vector< bool >::reverse_iterator":
        return _hou._BoolTuple_rbegin(self)

    def rend(self) -> "std::vector< bool >::reverse_iterator":
        return _hou._BoolTuple_rend(self)

    def clear(self) -> "void":
        return _hou._BoolTuple_clear(self)

    def get_allocator(self) -> "std::vector< bool >::allocator_type":
        return _hou._BoolTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._BoolTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< bool >::iterator":
        return _hou._BoolTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._BoolTuple_swiginit(self, _hou.new__BoolTuple(*args))

    def push_back(self, x: "std::vector< bool >::value_type") -> "void":
        return _hou._BoolTuple_push_back(self, x)

    def front(self) -> "std::vector< bool >::value_type":
        return _hou._BoolTuple_front(self)

    def back(self) -> "std::vector< bool >::value_type":
        return _hou._BoolTuple_back(self)

    def assign(
        self, n: "std::vector< bool >::size_type", x: "std::vector< bool >::value_type"
    ) -> "void":
        return _hou._BoolTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._BoolTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._BoolTuple_insert(self, *args)

    def reserve(self, n: "std::vector< bool >::size_type") -> "void":
        return _hou._BoolTuple_reserve(self, n)

    def capacity(self) -> "std::vector< bool >::size_type":
        return _hou._BoolTuple_capacity(self)

    __swig_destroy__ = _hou.delete__BoolTuple


# Register _BoolTuple in _hou:
_hou._BoolTuple_swigregister(_BoolTuple)


class _FloatTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._FloatTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._FloatTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._FloatTuple___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _hou._FloatTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< float >::difference_type",
        j: "std::vector< float >::difference_type",
    ) -> "std::vector< float,std::allocator< float > > *":
        return _hou._FloatTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._FloatTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< float >::difference_type",
        j: "std::vector< float >::difference_type",
    ) -> "void":
        return _hou._FloatTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._FloatTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _hou._FloatTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._FloatTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _hou._FloatTuple_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _hou._FloatTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._FloatTuple_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _hou._FloatTuple_size(self)

    def swap(self, v: "_FloatTuple") -> "void":
        return _hou._FloatTuple_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _hou._FloatTuple_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _hou._FloatTuple_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _hou._FloatTuple_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _hou._FloatTuple_rend(self)

    def clear(self) -> "void":
        return _hou._FloatTuple_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _hou._FloatTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._FloatTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _hou._FloatTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._FloatTuple_swiginit(self, _hou.new__FloatTuple(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _hou._FloatTuple_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _hou._FloatTuple_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _hou._FloatTuple_back(self)

    def assign(
        self,
        n: "std::vector< float >::size_type",
        x: "std::vector< float >::value_type const &",
    ) -> "void":
        return _hou._FloatTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._FloatTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._FloatTuple_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _hou._FloatTuple_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _hou._FloatTuple_capacity(self)

    __swig_destroy__ = _hou.delete__FloatTuple


# Register _FloatTuple in _hou:
_hou._FloatTuple_swigregister(_FloatTuple)


class _FloatTupleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._FloatTupleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._FloatTupleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._FloatTupleTuple___bool__(self)

    def __len__(self) -> "std::vector< std::vector< float > >::size_type":
        return _hou._FloatTupleTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< std::vector< float > >::difference_type",
        j: "std::vector< std::vector< float > >::difference_type",
    ) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > *":
        return _hou._FloatTupleTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._FloatTupleTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< std::vector< float > >::difference_type",
        j: "std::vector< std::vector< float > >::difference_type",
    ) -> "void":
        return _hou._FloatTupleTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._FloatTupleTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< std::vector< float > >::value_type const &":
        return _hou._FloatTupleTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._FloatTupleTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< float > >::value_type":
        return _hou._FloatTupleTuple_pop(self)

    def append(self, x: "_FloatTuple") -> "void":
        return _hou._FloatTupleTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._FloatTupleTuple_empty(self)

    def size(self) -> "std::vector< std::vector< float > >::size_type":
        return _hou._FloatTupleTuple_size(self)

    def swap(self, v: "_FloatTupleTuple") -> "void":
        return _hou._FloatTupleTuple_swap(self, v)

    def begin(self) -> "std::vector< std::vector< float > >::iterator":
        return _hou._FloatTupleTuple_begin(self)

    def end(self) -> "std::vector< std::vector< float > >::iterator":
        return _hou._FloatTupleTuple_end(self)

    def rbegin(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        return _hou._FloatTupleTuple_rbegin(self)

    def rend(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        return _hou._FloatTupleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._FloatTupleTuple_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< float > >::allocator_type":
        return _hou._FloatTupleTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._FloatTupleTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< float > >::iterator":
        return _hou._FloatTupleTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._FloatTupleTuple_swiginit(self, _hou.new__FloatTupleTuple(*args))

    def push_back(self, x: "_FloatTuple") -> "void":
        return _hou._FloatTupleTuple_push_back(self, x)

    def front(self) -> "std::vector< std::vector< float > >::value_type const &":
        return _hou._FloatTupleTuple_front(self)

    def back(self) -> "std::vector< std::vector< float > >::value_type const &":
        return _hou._FloatTupleTuple_back(self)

    def assign(
        self, n: "std::vector< std::vector< float > >::size_type", x: "_FloatTuple"
    ) -> "void":
        return _hou._FloatTupleTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._FloatTupleTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._FloatTupleTuple_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< float > >::size_type") -> "void":
        return _hou._FloatTupleTuple_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< float > >::size_type":
        return _hou._FloatTupleTuple_capacity(self)

    __swig_destroy__ = _hou.delete__FloatTupleTuple


# Register _FloatTupleTuple in _hou:
_hou._FloatTupleTuple_swigregister(_FloatTupleTuple)


class _DoubleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._DoubleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._DoubleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._DoubleTuple___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _hou._DoubleTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< double >::difference_type",
        j: "std::vector< double >::difference_type",
    ) -> "std::vector< double,std::allocator< double > > *":
        return _hou._DoubleTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._DoubleTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< double >::difference_type",
        j: "std::vector< double >::difference_type",
    ) -> "void":
        return _hou._DoubleTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._DoubleTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _hou._DoubleTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._DoubleTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _hou._DoubleTuple_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _hou._DoubleTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._DoubleTuple_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _hou._DoubleTuple_size(self)

    def swap(self, v: "_DoubleTuple") -> "void":
        return _hou._DoubleTuple_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _hou._DoubleTuple_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _hou._DoubleTuple_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _hou._DoubleTuple_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _hou._DoubleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._DoubleTuple_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _hou._DoubleTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._DoubleTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _hou._DoubleTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._DoubleTuple_swiginit(self, _hou.new__DoubleTuple(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _hou._DoubleTuple_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _hou._DoubleTuple_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _hou._DoubleTuple_back(self)

    def assign(
        self,
        n: "std::vector< double >::size_type",
        x: "std::vector< double >::value_type const &",
    ) -> "void":
        return _hou._DoubleTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._DoubleTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._DoubleTuple_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _hou._DoubleTuple_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _hou._DoubleTuple_capacity(self)

    __swig_destroy__ = _hou.delete__DoubleTuple


# Register _DoubleTuple in _hou:
_hou._DoubleTuple_swigregister(_DoubleTuple)


class _DoubleTupleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._DoubleTupleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._DoubleTupleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._DoubleTupleTuple___bool__(self)

    def __len__(self) -> "std::vector< std::vector< double > >::size_type":
        return _hou._DoubleTupleTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< std::vector< double > >::difference_type",
        j: "std::vector< std::vector< double > >::difference_type",
    ) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *":
        return _hou._DoubleTupleTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._DoubleTupleTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< std::vector< double > >::difference_type",
        j: "std::vector< std::vector< double > >::difference_type",
    ) -> "void":
        return _hou._DoubleTupleTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._DoubleTupleTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< std::vector< double > >::value_type const &":
        return _hou._DoubleTupleTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._DoubleTupleTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< double > >::value_type":
        return _hou._DoubleTupleTuple_pop(self)

    def append(self, x: "_DoubleTuple") -> "void":
        return _hou._DoubleTupleTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._DoubleTupleTuple_empty(self)

    def size(self) -> "std::vector< std::vector< double > >::size_type":
        return _hou._DoubleTupleTuple_size(self)

    def swap(self, v: "_DoubleTupleTuple") -> "void":
        return _hou._DoubleTupleTuple_swap(self, v)

    def begin(self) -> "std::vector< std::vector< double > >::iterator":
        return _hou._DoubleTupleTuple_begin(self)

    def end(self) -> "std::vector< std::vector< double > >::iterator":
        return _hou._DoubleTupleTuple_end(self)

    def rbegin(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _hou._DoubleTupleTuple_rbegin(self)

    def rend(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _hou._DoubleTupleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._DoubleTupleTuple_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< double > >::allocator_type":
        return _hou._DoubleTupleTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._DoubleTupleTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< double > >::iterator":
        return _hou._DoubleTupleTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._DoubleTupleTuple_swiginit(self, _hou.new__DoubleTupleTuple(*args))

    def push_back(self, x: "_DoubleTuple") -> "void":
        return _hou._DoubleTupleTuple_push_back(self, x)

    def front(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _hou._DoubleTupleTuple_front(self)

    def back(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _hou._DoubleTupleTuple_back(self)

    def assign(
        self, n: "std::vector< std::vector< double > >::size_type", x: "_DoubleTuple"
    ) -> "void":
        return _hou._DoubleTupleTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._DoubleTupleTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._DoubleTupleTuple_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< double > >::size_type") -> "void":
        return _hou._DoubleTupleTuple_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< double > >::size_type":
        return _hou._DoubleTupleTuple_capacity(self)

    __swig_destroy__ = _hou.delete__DoubleTupleTuple


# Register _DoubleTupleTuple in _hou:
_hou._DoubleTupleTuple_swigregister(_DoubleTupleTuple)


class _AgentClipTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentClipTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._AgentClipTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._AgentClipTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_AgentClip * >::size_type":
        return _hou._AgentClipTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_AgentClip * >::difference_type",
        j: "std::vector< HOM_AgentClip * >::difference_type",
    ) -> "std::vector< HOM_AgentClip *,std::allocator< HOM_AgentClip * > > *":
        return _hou._AgentClipTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._AgentClipTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_AgentClip * >::difference_type",
        j: "std::vector< HOM_AgentClip * >::difference_type",
    ) -> "void":
        return _hou._AgentClipTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._AgentClipTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_AgentClip * >::value_type":
        return _hou._AgentClipTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._AgentClipTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_AgentClip * >::value_type":
        return _hou._AgentClipTuple_pop(self)

    def append(self, x: "AgentClip") -> "void":
        return _hou._AgentClipTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._AgentClipTuple_empty(self)

    def size(self) -> "std::vector< HOM_AgentClip * >::size_type":
        return _hou._AgentClipTuple_size(self)

    def swap(self, v: "_AgentClipTuple") -> "void":
        return _hou._AgentClipTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_AgentClip * >::iterator":
        return _hou._AgentClipTuple_begin(self)

    def end(self) -> "std::vector< HOM_AgentClip * >::iterator":
        return _hou._AgentClipTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_AgentClip * >::reverse_iterator":
        return _hou._AgentClipTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_AgentClip * >::reverse_iterator":
        return _hou._AgentClipTuple_rend(self)

    def clear(self) -> "void":
        return _hou._AgentClipTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_AgentClip * >::allocator_type":
        return _hou._AgentClipTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._AgentClipTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_AgentClip * >::iterator":
        return _hou._AgentClipTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._AgentClipTuple_swiginit(self, _hou.new__AgentClipTuple(*args))

    def push_back(self, x: "AgentClip") -> "void":
        return _hou._AgentClipTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_AgentClip * >::value_type":
        return _hou._AgentClipTuple_front(self)

    def back(self) -> "std::vector< HOM_AgentClip * >::value_type":
        return _hou._AgentClipTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_AgentClip * >::size_type", x: "AgentClip"
    ) -> "void":
        return _hou._AgentClipTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._AgentClipTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._AgentClipTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_AgentClip * >::size_type") -> "void":
        return _hou._AgentClipTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_AgentClip * >::size_type":
        return _hou._AgentClipTuple_capacity(self)

    __swig_destroy__ = _hou.delete__AgentClipTuple


# Register _AgentClipTuple in _hou:
_hou._AgentClipTuple_swigregister(_AgentClipTuple)


class _AgentLayerTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentLayerTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._AgentLayerTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._AgentLayerTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_AgentLayer * >::size_type":
        return _hou._AgentLayerTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_AgentLayer * >::difference_type",
        j: "std::vector< HOM_AgentLayer * >::difference_type",
    ) -> "std::vector< HOM_AgentLayer *,std::allocator< HOM_AgentLayer * > > *":
        return _hou._AgentLayerTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._AgentLayerTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_AgentLayer * >::difference_type",
        j: "std::vector< HOM_AgentLayer * >::difference_type",
    ) -> "void":
        return _hou._AgentLayerTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._AgentLayerTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_AgentLayer * >::value_type":
        return _hou._AgentLayerTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._AgentLayerTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_AgentLayer * >::value_type":
        return _hou._AgentLayerTuple_pop(self)

    def append(self, x: "AgentLayer") -> "void":
        return _hou._AgentLayerTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._AgentLayerTuple_empty(self)

    def size(self) -> "std::vector< HOM_AgentLayer * >::size_type":
        return _hou._AgentLayerTuple_size(self)

    def swap(self, v: "_AgentLayerTuple") -> "void":
        return _hou._AgentLayerTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_AgentLayer * >::iterator":
        return _hou._AgentLayerTuple_begin(self)

    def end(self) -> "std::vector< HOM_AgentLayer * >::iterator":
        return _hou._AgentLayerTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_AgentLayer * >::reverse_iterator":
        return _hou._AgentLayerTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_AgentLayer * >::reverse_iterator":
        return _hou._AgentLayerTuple_rend(self)

    def clear(self) -> "void":
        return _hou._AgentLayerTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_AgentLayer * >::allocator_type":
        return _hou._AgentLayerTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._AgentLayerTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_AgentLayer * >::iterator":
        return _hou._AgentLayerTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._AgentLayerTuple_swiginit(self, _hou.new__AgentLayerTuple(*args))

    def push_back(self, x: "AgentLayer") -> "void":
        return _hou._AgentLayerTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_AgentLayer * >::value_type":
        return _hou._AgentLayerTuple_front(self)

    def back(self) -> "std::vector< HOM_AgentLayer * >::value_type":
        return _hou._AgentLayerTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_AgentLayer * >::size_type", x: "AgentLayer"
    ) -> "void":
        return _hou._AgentLayerTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._AgentLayerTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._AgentLayerTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_AgentLayer * >::size_type") -> "void":
        return _hou._AgentLayerTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_AgentLayer * >::size_type":
        return _hou._AgentLayerTuple_capacity(self)

    __swig_destroy__ = _hou.delete__AgentLayerTuple


# Register _AgentLayerTuple in _hou:
_hou._AgentLayerTuple_swigregister(_AgentLayerTuple)


class _AgentShapeTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentShapeTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._AgentShapeTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._AgentShapeTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_AgentShape * >::size_type":
        return _hou._AgentShapeTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_AgentShape * >::difference_type",
        j: "std::vector< HOM_AgentShape * >::difference_type",
    ) -> "std::vector< HOM_AgentShape *,std::allocator< HOM_AgentShape * > > *":
        return _hou._AgentShapeTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._AgentShapeTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_AgentShape * >::difference_type",
        j: "std::vector< HOM_AgentShape * >::difference_type",
    ) -> "void":
        return _hou._AgentShapeTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._AgentShapeTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_AgentShape * >::value_type":
        return _hou._AgentShapeTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._AgentShapeTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_AgentShape * >::value_type":
        return _hou._AgentShapeTuple_pop(self)

    def append(self, x: "AgentShape") -> "void":
        return _hou._AgentShapeTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._AgentShapeTuple_empty(self)

    def size(self) -> "std::vector< HOM_AgentShape * >::size_type":
        return _hou._AgentShapeTuple_size(self)

    def swap(self, v: "_AgentShapeTuple") -> "void":
        return _hou._AgentShapeTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_AgentShape * >::iterator":
        return _hou._AgentShapeTuple_begin(self)

    def end(self) -> "std::vector< HOM_AgentShape * >::iterator":
        return _hou._AgentShapeTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_AgentShape * >::reverse_iterator":
        return _hou._AgentShapeTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_AgentShape * >::reverse_iterator":
        return _hou._AgentShapeTuple_rend(self)

    def clear(self) -> "void":
        return _hou._AgentShapeTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_AgentShape * >::allocator_type":
        return _hou._AgentShapeTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._AgentShapeTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_AgentShape * >::iterator":
        return _hou._AgentShapeTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._AgentShapeTuple_swiginit(self, _hou.new__AgentShapeTuple(*args))

    def push_back(self, x: "AgentShape") -> "void":
        return _hou._AgentShapeTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_AgentShape * >::value_type":
        return _hou._AgentShapeTuple_front(self)

    def back(self) -> "std::vector< HOM_AgentShape * >::value_type":
        return _hou._AgentShapeTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_AgentShape * >::size_type", x: "AgentShape"
    ) -> "void":
        return _hou._AgentShapeTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._AgentShapeTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._AgentShapeTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_AgentShape * >::size_type") -> "void":
        return _hou._AgentShapeTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_AgentShape * >::size_type":
        return _hou._AgentShapeTuple_capacity(self)

    __swig_destroy__ = _hou.delete__AgentShapeTuple


# Register _AgentShapeTuple in _hou:
_hou._AgentShapeTuple_swigregister(_AgentShapeTuple)


class _AgentShapeBindingTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentShapeBindingTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._AgentShapeBindingTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._AgentShapeBindingTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_AgentShapeBinding * >::size_type":
        return _hou._AgentShapeBindingTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_AgentShapeBinding * >::difference_type",
        j: "std::vector< HOM_AgentShapeBinding * >::difference_type",
    ) -> "std::vector< HOM_AgentShapeBinding *,std::allocator< HOM_AgentShapeBinding * > > *":
        return _hou._AgentShapeBindingTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._AgentShapeBindingTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_AgentShapeBinding * >::difference_type",
        j: "std::vector< HOM_AgentShapeBinding * >::difference_type",
    ) -> "void":
        return _hou._AgentShapeBindingTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._AgentShapeBindingTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< HOM_AgentShapeBinding * >::value_type":
        return _hou._AgentShapeBindingTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._AgentShapeBindingTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_AgentShapeBinding * >::value_type":
        return _hou._AgentShapeBindingTuple_pop(self)

    def append(self, x: "AgentShapeBinding") -> "void":
        return _hou._AgentShapeBindingTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._AgentShapeBindingTuple_empty(self)

    def size(self) -> "std::vector< HOM_AgentShapeBinding * >::size_type":
        return _hou._AgentShapeBindingTuple_size(self)

    def swap(self, v: "_AgentShapeBindingTuple") -> "void":
        return _hou._AgentShapeBindingTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_AgentShapeBinding * >::iterator":
        return _hou._AgentShapeBindingTuple_begin(self)

    def end(self) -> "std::vector< HOM_AgentShapeBinding * >::iterator":
        return _hou._AgentShapeBindingTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_AgentShapeBinding * >::reverse_iterator":
        return _hou._AgentShapeBindingTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_AgentShapeBinding * >::reverse_iterator":
        return _hou._AgentShapeBindingTuple_rend(self)

    def clear(self) -> "void":
        return _hou._AgentShapeBindingTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_AgentShapeBinding * >::allocator_type":
        return _hou._AgentShapeBindingTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._AgentShapeBindingTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_AgentShapeBinding * >::iterator":
        return _hou._AgentShapeBindingTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._AgentShapeBindingTuple_swiginit(
            self, _hou.new__AgentShapeBindingTuple(*args)
        )

    def push_back(self, x: "AgentShapeBinding") -> "void":
        return _hou._AgentShapeBindingTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_AgentShapeBinding * >::value_type":
        return _hou._AgentShapeBindingTuple_front(self)

    def back(self) -> "std::vector< HOM_AgentShapeBinding * >::value_type":
        return _hou._AgentShapeBindingTuple_back(self)

    def assign(
        self,
        n: "std::vector< HOM_AgentShapeBinding * >::size_type",
        x: "AgentShapeBinding",
    ) -> "void":
        return _hou._AgentShapeBindingTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._AgentShapeBindingTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._AgentShapeBindingTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_AgentShapeBinding * >::size_type") -> "void":
        return _hou._AgentShapeBindingTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_AgentShapeBinding * >::size_type":
        return _hou._AgentShapeBindingTuple_capacity(self)

    __swig_destroy__ = _hou.delete__AgentShapeBindingTuple


# Register _AgentShapeBindingTuple in _hou:
_hou._AgentShapeBindingTuple_swigregister(_AgentShapeBindingTuple)


class _AgentTransformGroupTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentTransformGroupTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._AgentTransformGroupTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._AgentTransformGroupTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_AgentTransformGroup * >::size_type":
        return _hou._AgentTransformGroupTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_AgentTransformGroup * >::difference_type",
        j: "std::vector< HOM_AgentTransformGroup * >::difference_type",
    ) -> "std::vector< HOM_AgentTransformGroup *,std::allocator< HOM_AgentTransformGroup * > > *":
        return _hou._AgentTransformGroupTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._AgentTransformGroupTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_AgentTransformGroup * >::difference_type",
        j: "std::vector< HOM_AgentTransformGroup * >::difference_type",
    ) -> "void":
        return _hou._AgentTransformGroupTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._AgentTransformGroupTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< HOM_AgentTransformGroup * >::value_type":
        return _hou._AgentTransformGroupTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._AgentTransformGroupTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_AgentTransformGroup * >::value_type":
        return _hou._AgentTransformGroupTuple_pop(self)

    def append(self, x: "AgentTransformGroup") -> "void":
        return _hou._AgentTransformGroupTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._AgentTransformGroupTuple_empty(self)

    def size(self) -> "std::vector< HOM_AgentTransformGroup * >::size_type":
        return _hou._AgentTransformGroupTuple_size(self)

    def swap(self, v: "_AgentTransformGroupTuple") -> "void":
        return _hou._AgentTransformGroupTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_AgentTransformGroup * >::iterator":
        return _hou._AgentTransformGroupTuple_begin(self)

    def end(self) -> "std::vector< HOM_AgentTransformGroup * >::iterator":
        return _hou._AgentTransformGroupTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_AgentTransformGroup * >::reverse_iterator":
        return _hou._AgentTransformGroupTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_AgentTransformGroup * >::reverse_iterator":
        return _hou._AgentTransformGroupTuple_rend(self)

    def clear(self) -> "void":
        return _hou._AgentTransformGroupTuple_clear(self)

    def get_allocator(
        self,
    ) -> "std::vector< HOM_AgentTransformGroup * >::allocator_type":
        return _hou._AgentTransformGroupTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._AgentTransformGroupTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_AgentTransformGroup * >::iterator":
        return _hou._AgentTransformGroupTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._AgentTransformGroupTuple_swiginit(
            self, _hou.new__AgentTransformGroupTuple(*args)
        )

    def push_back(self, x: "AgentTransformGroup") -> "void":
        return _hou._AgentTransformGroupTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_AgentTransformGroup * >::value_type":
        return _hou._AgentTransformGroupTuple_front(self)

    def back(self) -> "std::vector< HOM_AgentTransformGroup * >::value_type":
        return _hou._AgentTransformGroupTuple_back(self)

    def assign(
        self,
        n: "std::vector< HOM_AgentTransformGroup * >::size_type",
        x: "AgentTransformGroup",
    ) -> "void":
        return _hou._AgentTransformGroupTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._AgentTransformGroupTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._AgentTransformGroupTuple_insert(self, *args)

    def reserve(
        self, n: "std::vector< HOM_AgentTransformGroup * >::size_type"
    ) -> "void":
        return _hou._AgentTransformGroupTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_AgentTransformGroup * >::size_type":
        return _hou._AgentTransformGroupTuple_capacity(self)

    __swig_destroy__ = _hou.delete__AgentTransformGroupTuple


# Register _AgentTransformGroupTuple in _hou:
_hou._AgentTransformGroupTuple_swigregister(_AgentTransformGroupTuple)


class _EnumTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._EnumTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._EnumTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._EnumTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_EnumValue * >::size_type":
        return _hou._EnumTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_EnumValue * >::difference_type",
        j: "std::vector< HOM_EnumValue * >::difference_type",
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > > *":
        return _hou._EnumTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._EnumTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_EnumValue * >::difference_type",
        j: "std::vector< HOM_EnumValue * >::difference_type",
    ) -> "void":
        return _hou._EnumTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._EnumTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_EnumValue * >::value_type":
        return _hou._EnumTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._EnumTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_EnumValue * >::value_type":
        return _hou._EnumTuple_pop(self)

    def append(self, x: "EnumValue") -> "void":
        return _hou._EnumTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._EnumTuple_empty(self)

    def size(self) -> "std::vector< HOM_EnumValue * >::size_type":
        return _hou._EnumTuple_size(self)

    def swap(self, v: "_EnumTuple") -> "void":
        return _hou._EnumTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_EnumValue * >::iterator":
        return _hou._EnumTuple_begin(self)

    def end(self) -> "std::vector< HOM_EnumValue * >::iterator":
        return _hou._EnumTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_EnumValue * >::reverse_iterator":
        return _hou._EnumTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_EnumValue * >::reverse_iterator":
        return _hou._EnumTuple_rend(self)

    def clear(self) -> "void":
        return _hou._EnumTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_EnumValue * >::allocator_type":
        return _hou._EnumTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._EnumTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_EnumValue * >::iterator":
        return _hou._EnumTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._EnumTuple_swiginit(self, _hou.new__EnumTuple(*args))

    def push_back(self, x: "EnumValue") -> "void":
        return _hou._EnumTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_EnumValue * >::value_type":
        return _hou._EnumTuple_front(self)

    def back(self) -> "std::vector< HOM_EnumValue * >::value_type":
        return _hou._EnumTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_EnumValue * >::size_type", x: "EnumValue"
    ) -> "void":
        return _hou._EnumTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._EnumTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._EnumTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_EnumValue * >::size_type") -> "void":
        return _hou._EnumTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_EnumValue * >::size_type":
        return _hou._EnumTuple_capacity(self)

    __swig_destroy__ = _hou.delete__EnumTuple


# Register _EnumTuple in _hou:
_hou._EnumTuple_swigregister(_EnumTuple)


class _NetworkMovableItemTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._NetworkMovableItemTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._NetworkMovableItemTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._NetworkMovableItemTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_NetworkMovableItem * >::size_type":
        return _hou._NetworkMovableItemTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_NetworkMovableItem * >::difference_type",
        j: "std::vector< HOM_NetworkMovableItem * >::difference_type",
    ) -> "std::vector< HOM_NetworkMovableItem *,std::allocator< HOM_NetworkMovableItem * > > *":
        return _hou._NetworkMovableItemTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._NetworkMovableItemTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_NetworkMovableItem * >::difference_type",
        j: "std::vector< HOM_NetworkMovableItem * >::difference_type",
    ) -> "void":
        return _hou._NetworkMovableItemTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._NetworkMovableItemTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< HOM_NetworkMovableItem * >::value_type":
        return _hou._NetworkMovableItemTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._NetworkMovableItemTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_NetworkMovableItem * >::value_type":
        return _hou._NetworkMovableItemTuple_pop(self)

    def append(self, x: "NetworkMovableItem") -> "void":
        return _hou._NetworkMovableItemTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._NetworkMovableItemTuple_empty(self)

    def size(self) -> "std::vector< HOM_NetworkMovableItem * >::size_type":
        return _hou._NetworkMovableItemTuple_size(self)

    def swap(self, v: "_NetworkMovableItemTuple") -> "void":
        return _hou._NetworkMovableItemTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_NetworkMovableItem * >::iterator":
        return _hou._NetworkMovableItemTuple_begin(self)

    def end(self) -> "std::vector< HOM_NetworkMovableItem * >::iterator":
        return _hou._NetworkMovableItemTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_NetworkMovableItem * >::reverse_iterator":
        return _hou._NetworkMovableItemTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_NetworkMovableItem * >::reverse_iterator":
        return _hou._NetworkMovableItemTuple_rend(self)

    def clear(self) -> "void":
        return _hou._NetworkMovableItemTuple_clear(self)

    def get_allocator(
        self,
    ) -> "std::vector< HOM_NetworkMovableItem * >::allocator_type":
        return _hou._NetworkMovableItemTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._NetworkMovableItemTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_NetworkMovableItem * >::iterator":
        return _hou._NetworkMovableItemTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._NetworkMovableItemTuple_swiginit(
            self, _hou.new__NetworkMovableItemTuple(*args)
        )

    def push_back(self, x: "NetworkMovableItem") -> "void":
        return _hou._NetworkMovableItemTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_NetworkMovableItem * >::value_type":
        return _hou._NetworkMovableItemTuple_front(self)

    def back(self) -> "std::vector< HOM_NetworkMovableItem * >::value_type":
        return _hou._NetworkMovableItemTuple_back(self)

    def assign(
        self,
        n: "std::vector< HOM_NetworkMovableItem * >::size_type",
        x: "NetworkMovableItem",
    ) -> "void":
        return _hou._NetworkMovableItemTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._NetworkMovableItemTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._NetworkMovableItemTuple_insert(self, *args)

    def reserve(
        self, n: "std::vector< HOM_NetworkMovableItem * >::size_type"
    ) -> "void":
        return _hou._NetworkMovableItemTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_NetworkMovableItem * >::size_type":
        return _hou._NetworkMovableItemTuple_capacity(self)

    __swig_destroy__ = _hou.delete__NetworkMovableItemTuple


# Register _NetworkMovableItemTuple in _hou:
_hou._NetworkMovableItemTuple_swigregister(_NetworkMovableItemTuple)


class _NodeTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._NodeTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._NodeTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._NodeTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Node * >::size_type":
        return _hou._NodeTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Node * >::difference_type",
        j: "std::vector< HOM_Node * >::difference_type",
    ) -> "std::vector< HOM_Node *,std::allocator< HOM_Node * > > *":
        return _hou._NodeTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._NodeTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Node * >::difference_type",
        j: "std::vector< HOM_Node * >::difference_type",
    ) -> "void":
        return _hou._NodeTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._NodeTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Node * >::value_type":
        return _hou._NodeTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._NodeTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Node * >::value_type":
        return _hou._NodeTuple_pop(self)

    def append(self, x: "Node") -> "void":
        return _hou._NodeTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._NodeTuple_empty(self)

    def size(self) -> "std::vector< HOM_Node * >::size_type":
        return _hou._NodeTuple_size(self)

    def swap(self, v: "_NodeTuple") -> "void":
        return _hou._NodeTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Node * >::iterator":
        return _hou._NodeTuple_begin(self)

    def end(self) -> "std::vector< HOM_Node * >::iterator":
        return _hou._NodeTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Node * >::reverse_iterator":
        return _hou._NodeTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Node * >::reverse_iterator":
        return _hou._NodeTuple_rend(self)

    def clear(self) -> "void":
        return _hou._NodeTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Node * >::allocator_type":
        return _hou._NodeTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._NodeTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Node * >::iterator":
        return _hou._NodeTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._NodeTuple_swiginit(self, _hou.new__NodeTuple(*args))

    def push_back(self, x: "Node") -> "void":
        return _hou._NodeTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Node * >::value_type":
        return _hou._NodeTuple_front(self)

    def back(self) -> "std::vector< HOM_Node * >::value_type":
        return _hou._NodeTuple_back(self)

    def assign(self, n: "std::vector< HOM_Node * >::size_type", x: "Node") -> "void":
        return _hou._NodeTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._NodeTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._NodeTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Node * >::size_type") -> "void":
        return _hou._NodeTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Node * >::size_type":
        return _hou._NodeTuple_capacity(self)

    __swig_destroy__ = _hou.delete__NodeTuple


# Register _NodeTuple in _hou:
_hou._NodeTuple_swigregister(_NodeTuple)


class _PointTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._PointTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._PointTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._PointTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Point * >::size_type":
        return _hou._PointTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Point * >::difference_type",
        j: "std::vector< HOM_Point * >::difference_type",
    ) -> "std::vector< HOM_Point *,std::allocator< HOM_Point * > > *":
        return _hou._PointTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._PointTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Point * >::difference_type",
        j: "std::vector< HOM_Point * >::difference_type",
    ) -> "void":
        return _hou._PointTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._PointTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Point * >::value_type":
        return _hou._PointTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._PointTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Point * >::value_type":
        return _hou._PointTuple_pop(self)

    def append(self, x: "Point") -> "void":
        return _hou._PointTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._PointTuple_empty(self)

    def size(self) -> "std::vector< HOM_Point * >::size_type":
        return _hou._PointTuple_size(self)

    def swap(self, v: "_PointTuple") -> "void":
        return _hou._PointTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Point * >::iterator":
        return _hou._PointTuple_begin(self)

    def end(self) -> "std::vector< HOM_Point * >::iterator":
        return _hou._PointTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Point * >::reverse_iterator":
        return _hou._PointTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Point * >::reverse_iterator":
        return _hou._PointTuple_rend(self)

    def clear(self) -> "void":
        return _hou._PointTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Point * >::allocator_type":
        return _hou._PointTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._PointTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Point * >::iterator":
        return _hou._PointTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._PointTuple_swiginit(self, _hou.new__PointTuple(*args))

    def push_back(self, x: "Point") -> "void":
        return _hou._PointTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Point * >::value_type":
        return _hou._PointTuple_front(self)

    def back(self) -> "std::vector< HOM_Point * >::value_type":
        return _hou._PointTuple_back(self)

    def assign(self, n: "std::vector< HOM_Point * >::size_type", x: "Point") -> "void":
        return _hou._PointTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._PointTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._PointTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Point * >::size_type") -> "void":
        return _hou._PointTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Point * >::size_type":
        return _hou._PointTuple_capacity(self)

    __swig_destroy__ = _hou.delete__PointTuple


# Register _PointTuple in _hou:
_hou._PointTuple_swigregister(_PointTuple)


class _PointTupleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._PointTupleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._PointTupleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._PointTupleTuple___bool__(self)

    def __len__(self) -> "std::vector< std::vector< HOM_Point * > >::size_type":
        return _hou._PointTupleTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< std::vector< HOM_Point * > >::difference_type",
        j: "std::vector< std::vector< HOM_Point * > >::difference_type",
    ) -> "std::vector< std::vector< HOM_Point *,std::allocator< HOM_Point * > >,std::allocator< std::vector< HOM_Point *,std::allocator< HOM_Point * > > > > *":
        return _hou._PointTupleTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._PointTupleTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< std::vector< HOM_Point * > >::difference_type",
        j: "std::vector< std::vector< HOM_Point * > >::difference_type",
    ) -> "void":
        return _hou._PointTupleTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._PointTupleTuple___delitem__(self, *args)

    def __getitem__(
        self, *args
    ) -> "std::vector< std::vector< HOM_Point * > >::value_type const &":
        return _hou._PointTupleTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._PointTupleTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< HOM_Point * > >::value_type":
        return _hou._PointTupleTuple_pop(self)

    def append(self, x: "_PointTuple") -> "void":
        return _hou._PointTupleTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._PointTupleTuple_empty(self)

    def size(self) -> "std::vector< std::vector< HOM_Point * > >::size_type":
        return _hou._PointTupleTuple_size(self)

    def swap(self, v: "_PointTupleTuple") -> "void":
        return _hou._PointTupleTuple_swap(self, v)

    def begin(self) -> "std::vector< std::vector< HOM_Point * > >::iterator":
        return _hou._PointTupleTuple_begin(self)

    def end(self) -> "std::vector< std::vector< HOM_Point * > >::iterator":
        return _hou._PointTupleTuple_end(self)

    def rbegin(self) -> "std::vector< std::vector< HOM_Point * > >::reverse_iterator":
        return _hou._PointTupleTuple_rbegin(self)

    def rend(self) -> "std::vector< std::vector< HOM_Point * > >::reverse_iterator":
        return _hou._PointTupleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._PointTupleTuple_clear(self)

    def get_allocator(
        self,
    ) -> "std::vector< std::vector< HOM_Point * > >::allocator_type":
        return _hou._PointTupleTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._PointTupleTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< HOM_Point * > >::iterator":
        return _hou._PointTupleTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._PointTupleTuple_swiginit(self, _hou.new__PointTupleTuple(*args))

    def push_back(self, x: "_PointTuple") -> "void":
        return _hou._PointTupleTuple_push_back(self, x)

    def front(self) -> "std::vector< std::vector< HOM_Point * > >::value_type const &":
        return _hou._PointTupleTuple_front(self)

    def back(self) -> "std::vector< std::vector< HOM_Point * > >::value_type const &":
        return _hou._PointTupleTuple_back(self)

    def assign(
        self,
        n: "std::vector< std::vector< HOM_Point * > >::size_type",
        x: "_PointTuple",
    ) -> "void":
        return _hou._PointTupleTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._PointTupleTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._PointTupleTuple_insert(self, *args)

    def reserve(
        self, n: "std::vector< std::vector< HOM_Point * > >::size_type"
    ) -> "void":
        return _hou._PointTupleTuple_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< HOM_Point * > >::size_type":
        return _hou._PointTupleTuple_capacity(self)

    __swig_destroy__ = _hou.delete__PointTupleTuple


# Register _PointTupleTuple in _hou:
_hou._PointTupleTuple_swigregister(_PointTupleTuple)


class _PrimTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._PrimTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._PrimTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._PrimTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Prim * >::size_type":
        return _hou._PrimTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Prim * >::difference_type",
        j: "std::vector< HOM_Prim * >::difference_type",
    ) -> "std::vector< HOM_Prim *,std::allocator< HOM_Prim * > > *":
        return _hou._PrimTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._PrimTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Prim * >::difference_type",
        j: "std::vector< HOM_Prim * >::difference_type",
    ) -> "void":
        return _hou._PrimTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._PrimTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Prim * >::value_type":
        return _hou._PrimTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._PrimTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Prim * >::value_type":
        return _hou._PrimTuple_pop(self)

    def append(self, x: "Prim") -> "void":
        return _hou._PrimTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._PrimTuple_empty(self)

    def size(self) -> "std::vector< HOM_Prim * >::size_type":
        return _hou._PrimTuple_size(self)

    def swap(self, v: "_PrimTuple") -> "void":
        return _hou._PrimTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Prim * >::iterator":
        return _hou._PrimTuple_begin(self)

    def end(self) -> "std::vector< HOM_Prim * >::iterator":
        return _hou._PrimTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Prim * >::reverse_iterator":
        return _hou._PrimTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Prim * >::reverse_iterator":
        return _hou._PrimTuple_rend(self)

    def clear(self) -> "void":
        return _hou._PrimTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Prim * >::allocator_type":
        return _hou._PrimTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._PrimTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Prim * >::iterator":
        return _hou._PrimTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._PrimTuple_swiginit(self, _hou.new__PrimTuple(*args))

    def push_back(self, x: "Prim") -> "void":
        return _hou._PrimTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Prim * >::value_type":
        return _hou._PrimTuple_front(self)

    def back(self) -> "std::vector< HOM_Prim * >::value_type":
        return _hou._PrimTuple_back(self)

    def assign(self, n: "std::vector< HOM_Prim * >::size_type", x: "Prim") -> "void":
        return _hou._PrimTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._PrimTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._PrimTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Prim * >::size_type") -> "void":
        return _hou._PrimTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Prim * >::size_type":
        return _hou._PrimTuple_capacity(self)

    __swig_destroy__ = _hou.delete__PrimTuple


# Register _PrimTuple in _hou:
_hou._PrimTuple_swigregister(_PrimTuple)


class _EdgeTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._EdgeTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._EdgeTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._EdgeTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Edge * >::size_type":
        return _hou._EdgeTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Edge * >::difference_type",
        j: "std::vector< HOM_Edge * >::difference_type",
    ) -> "std::vector< HOM_Edge *,std::allocator< HOM_Edge * > > *":
        return _hou._EdgeTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._EdgeTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Edge * >::difference_type",
        j: "std::vector< HOM_Edge * >::difference_type",
    ) -> "void":
        return _hou._EdgeTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._EdgeTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Edge * >::value_type":
        return _hou._EdgeTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._EdgeTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Edge * >::value_type":
        return _hou._EdgeTuple_pop(self)

    def append(self, x: "Edge") -> "void":
        return _hou._EdgeTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._EdgeTuple_empty(self)

    def size(self) -> "std::vector< HOM_Edge * >::size_type":
        return _hou._EdgeTuple_size(self)

    def swap(self, v: "_EdgeTuple") -> "void":
        return _hou._EdgeTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Edge * >::iterator":
        return _hou._EdgeTuple_begin(self)

    def end(self) -> "std::vector< HOM_Edge * >::iterator":
        return _hou._EdgeTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Edge * >::reverse_iterator":
        return _hou._EdgeTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Edge * >::reverse_iterator":
        return _hou._EdgeTuple_rend(self)

    def clear(self) -> "void":
        return _hou._EdgeTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Edge * >::allocator_type":
        return _hou._EdgeTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._EdgeTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Edge * >::iterator":
        return _hou._EdgeTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._EdgeTuple_swiginit(self, _hou.new__EdgeTuple(*args))

    def push_back(self, x: "Edge") -> "void":
        return _hou._EdgeTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Edge * >::value_type":
        return _hou._EdgeTuple_front(self)

    def back(self) -> "std::vector< HOM_Edge * >::value_type":
        return _hou._EdgeTuple_back(self)

    def assign(self, n: "std::vector< HOM_Edge * >::size_type", x: "Edge") -> "void":
        return _hou._EdgeTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._EdgeTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._EdgeTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Edge * >::size_type") -> "void":
        return _hou._EdgeTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Edge * >::size_type":
        return _hou._EdgeTuple_capacity(self)

    __swig_destroy__ = _hou.delete__EdgeTuple


# Register _EdgeTuple in _hou:
_hou._EdgeTuple_swigregister(_EdgeTuple)


class _PointGroupTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._PointGroupTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._PointGroupTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._PointGroupTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_PointGroup * >::size_type":
        return _hou._PointGroupTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_PointGroup * >::difference_type",
        j: "std::vector< HOM_PointGroup * >::difference_type",
    ) -> "std::vector< HOM_PointGroup *,std::allocator< HOM_PointGroup * > > *":
        return _hou._PointGroupTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._PointGroupTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_PointGroup * >::difference_type",
        j: "std::vector< HOM_PointGroup * >::difference_type",
    ) -> "void":
        return _hou._PointGroupTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._PointGroupTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_PointGroup * >::value_type":
        return _hou._PointGroupTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._PointGroupTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_PointGroup * >::value_type":
        return _hou._PointGroupTuple_pop(self)

    def append(self, x: "PointGroup") -> "void":
        return _hou._PointGroupTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._PointGroupTuple_empty(self)

    def size(self) -> "std::vector< HOM_PointGroup * >::size_type":
        return _hou._PointGroupTuple_size(self)

    def swap(self, v: "_PointGroupTuple") -> "void":
        return _hou._PointGroupTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_PointGroup * >::iterator":
        return _hou._PointGroupTuple_begin(self)

    def end(self) -> "std::vector< HOM_PointGroup * >::iterator":
        return _hou._PointGroupTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_PointGroup * >::reverse_iterator":
        return _hou._PointGroupTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_PointGroup * >::reverse_iterator":
        return _hou._PointGroupTuple_rend(self)

    def clear(self) -> "void":
        return _hou._PointGroupTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_PointGroup * >::allocator_type":
        return _hou._PointGroupTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._PointGroupTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_PointGroup * >::iterator":
        return _hou._PointGroupTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._PointGroupTuple_swiginit(self, _hou.new__PointGroupTuple(*args))

    def push_back(self, x: "PointGroup") -> "void":
        return _hou._PointGroupTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_PointGroup * >::value_type":
        return _hou._PointGroupTuple_front(self)

    def back(self) -> "std::vector< HOM_PointGroup * >::value_type":
        return _hou._PointGroupTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_PointGroup * >::size_type", x: "PointGroup"
    ) -> "void":
        return _hou._PointGroupTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._PointGroupTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._PointGroupTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_PointGroup * >::size_type") -> "void":
        return _hou._PointGroupTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_PointGroup * >::size_type":
        return _hou._PointGroupTuple_capacity(self)

    __swig_destroy__ = _hou.delete__PointGroupTuple


# Register _PointGroupTuple in _hou:
_hou._PointGroupTuple_swigregister(_PointGroupTuple)


class _PrimGroupTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._PrimGroupTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._PrimGroupTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._PrimGroupTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_PrimGroup * >::size_type":
        return _hou._PrimGroupTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_PrimGroup * >::difference_type",
        j: "std::vector< HOM_PrimGroup * >::difference_type",
    ) -> "std::vector< HOM_PrimGroup *,std::allocator< HOM_PrimGroup * > > *":
        return _hou._PrimGroupTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._PrimGroupTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_PrimGroup * >::difference_type",
        j: "std::vector< HOM_PrimGroup * >::difference_type",
    ) -> "void":
        return _hou._PrimGroupTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._PrimGroupTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_PrimGroup * >::value_type":
        return _hou._PrimGroupTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._PrimGroupTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_PrimGroup * >::value_type":
        return _hou._PrimGroupTuple_pop(self)

    def append(self, x: "PrimGroup") -> "void":
        return _hou._PrimGroupTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._PrimGroupTuple_empty(self)

    def size(self) -> "std::vector< HOM_PrimGroup * >::size_type":
        return _hou._PrimGroupTuple_size(self)

    def swap(self, v: "_PrimGroupTuple") -> "void":
        return _hou._PrimGroupTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_PrimGroup * >::iterator":
        return _hou._PrimGroupTuple_begin(self)

    def end(self) -> "std::vector< HOM_PrimGroup * >::iterator":
        return _hou._PrimGroupTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_PrimGroup * >::reverse_iterator":
        return _hou._PrimGroupTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_PrimGroup * >::reverse_iterator":
        return _hou._PrimGroupTuple_rend(self)

    def clear(self) -> "void":
        return _hou._PrimGroupTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_PrimGroup * >::allocator_type":
        return _hou._PrimGroupTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._PrimGroupTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_PrimGroup * >::iterator":
        return _hou._PrimGroupTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._PrimGroupTuple_swiginit(self, _hou.new__PrimGroupTuple(*args))

    def push_back(self, x: "PrimGroup") -> "void":
        return _hou._PrimGroupTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_PrimGroup * >::value_type":
        return _hou._PrimGroupTuple_front(self)

    def back(self) -> "std::vector< HOM_PrimGroup * >::value_type":
        return _hou._PrimGroupTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_PrimGroup * >::size_type", x: "PrimGroup"
    ) -> "void":
        return _hou._PrimGroupTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._PrimGroupTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._PrimGroupTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_PrimGroup * >::size_type") -> "void":
        return _hou._PrimGroupTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_PrimGroup * >::size_type":
        return _hou._PrimGroupTuple_capacity(self)

    __swig_destroy__ = _hou.delete__PrimGroupTuple


# Register _PrimGroupTuple in _hou:
_hou._PrimGroupTuple_swigregister(_PrimGroupTuple)


class _EdgeGroupTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._EdgeGroupTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._EdgeGroupTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._EdgeGroupTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_EdgeGroup * >::size_type":
        return _hou._EdgeGroupTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_EdgeGroup * >::difference_type",
        j: "std::vector< HOM_EdgeGroup * >::difference_type",
    ) -> "std::vector< HOM_EdgeGroup *,std::allocator< HOM_EdgeGroup * > > *":
        return _hou._EdgeGroupTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._EdgeGroupTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_EdgeGroup * >::difference_type",
        j: "std::vector< HOM_EdgeGroup * >::difference_type",
    ) -> "void":
        return _hou._EdgeGroupTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._EdgeGroupTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_EdgeGroup * >::value_type":
        return _hou._EdgeGroupTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._EdgeGroupTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_EdgeGroup * >::value_type":
        return _hou._EdgeGroupTuple_pop(self)

    def append(self, x: "EdgeGroup") -> "void":
        return _hou._EdgeGroupTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._EdgeGroupTuple_empty(self)

    def size(self) -> "std::vector< HOM_EdgeGroup * >::size_type":
        return _hou._EdgeGroupTuple_size(self)

    def swap(self, v: "_EdgeGroupTuple") -> "void":
        return _hou._EdgeGroupTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_EdgeGroup * >::iterator":
        return _hou._EdgeGroupTuple_begin(self)

    def end(self) -> "std::vector< HOM_EdgeGroup * >::iterator":
        return _hou._EdgeGroupTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_EdgeGroup * >::reverse_iterator":
        return _hou._EdgeGroupTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_EdgeGroup * >::reverse_iterator":
        return _hou._EdgeGroupTuple_rend(self)

    def clear(self) -> "void":
        return _hou._EdgeGroupTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_EdgeGroup * >::allocator_type":
        return _hou._EdgeGroupTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._EdgeGroupTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_EdgeGroup * >::iterator":
        return _hou._EdgeGroupTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._EdgeGroupTuple_swiginit(self, _hou.new__EdgeGroupTuple(*args))

    def push_back(self, x: "EdgeGroup") -> "void":
        return _hou._EdgeGroupTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_EdgeGroup * >::value_type":
        return _hou._EdgeGroupTuple_front(self)

    def back(self) -> "std::vector< HOM_EdgeGroup * >::value_type":
        return _hou._EdgeGroupTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_EdgeGroup * >::size_type", x: "EdgeGroup"
    ) -> "void":
        return _hou._EdgeGroupTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._EdgeGroupTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._EdgeGroupTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_EdgeGroup * >::size_type") -> "void":
        return _hou._EdgeGroupTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_EdgeGroup * >::size_type":
        return _hou._EdgeGroupTuple_capacity(self)

    __swig_destroy__ = _hou.delete__EdgeGroupTuple


# Register _EdgeGroupTuple in _hou:
_hou._EdgeGroupTuple_swigregister(_EdgeGroupTuple)


class _VertexGroupTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._VertexGroupTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._VertexGroupTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._VertexGroupTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_VertexGroup * >::size_type":
        return _hou._VertexGroupTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_VertexGroup * >::difference_type",
        j: "std::vector< HOM_VertexGroup * >::difference_type",
    ) -> "std::vector< HOM_VertexGroup *,std::allocator< HOM_VertexGroup * > > *":
        return _hou._VertexGroupTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._VertexGroupTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_VertexGroup * >::difference_type",
        j: "std::vector< HOM_VertexGroup * >::difference_type",
    ) -> "void":
        return _hou._VertexGroupTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._VertexGroupTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_VertexGroup * >::value_type":
        return _hou._VertexGroupTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._VertexGroupTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_VertexGroup * >::value_type":
        return _hou._VertexGroupTuple_pop(self)

    def append(self, x: "VertexGroup") -> "void":
        return _hou._VertexGroupTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._VertexGroupTuple_empty(self)

    def size(self) -> "std::vector< HOM_VertexGroup * >::size_type":
        return _hou._VertexGroupTuple_size(self)

    def swap(self, v: "_VertexGroupTuple") -> "void":
        return _hou._VertexGroupTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_VertexGroup * >::iterator":
        return _hou._VertexGroupTuple_begin(self)

    def end(self) -> "std::vector< HOM_VertexGroup * >::iterator":
        return _hou._VertexGroupTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_VertexGroup * >::reverse_iterator":
        return _hou._VertexGroupTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_VertexGroup * >::reverse_iterator":
        return _hou._VertexGroupTuple_rend(self)

    def clear(self) -> "void":
        return _hou._VertexGroupTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_VertexGroup * >::allocator_type":
        return _hou._VertexGroupTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._VertexGroupTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_VertexGroup * >::iterator":
        return _hou._VertexGroupTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._VertexGroupTuple_swiginit(self, _hou.new__VertexGroupTuple(*args))

    def push_back(self, x: "VertexGroup") -> "void":
        return _hou._VertexGroupTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_VertexGroup * >::value_type":
        return _hou._VertexGroupTuple_front(self)

    def back(self) -> "std::vector< HOM_VertexGroup * >::value_type":
        return _hou._VertexGroupTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_VertexGroup * >::size_type", x: "VertexGroup"
    ) -> "void":
        return _hou._VertexGroupTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._VertexGroupTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._VertexGroupTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_VertexGroup * >::size_type") -> "void":
        return _hou._VertexGroupTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_VertexGroup * >::size_type":
        return _hou._VertexGroupTuple_capacity(self)

    __swig_destroy__ = _hou.delete__VertexGroupTuple


# Register _VertexGroupTuple in _hou:
_hou._VertexGroupTuple_swigregister(_VertexGroupTuple)


class _VertexTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._VertexTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._VertexTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._VertexTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Vertex * >::size_type":
        return _hou._VertexTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Vertex * >::difference_type",
        j: "std::vector< HOM_Vertex * >::difference_type",
    ) -> "std::vector< HOM_Vertex *,std::allocator< HOM_Vertex * > > *":
        return _hou._VertexTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._VertexTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Vertex * >::difference_type",
        j: "std::vector< HOM_Vertex * >::difference_type",
    ) -> "void":
        return _hou._VertexTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._VertexTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Vertex * >::value_type":
        return _hou._VertexTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._VertexTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Vertex * >::value_type":
        return _hou._VertexTuple_pop(self)

    def append(self, x: "Vertex") -> "void":
        return _hou._VertexTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._VertexTuple_empty(self)

    def size(self) -> "std::vector< HOM_Vertex * >::size_type":
        return _hou._VertexTuple_size(self)

    def swap(self, v: "_VertexTuple") -> "void":
        return _hou._VertexTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Vertex * >::iterator":
        return _hou._VertexTuple_begin(self)

    def end(self) -> "std::vector< HOM_Vertex * >::iterator":
        return _hou._VertexTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Vertex * >::reverse_iterator":
        return _hou._VertexTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Vertex * >::reverse_iterator":
        return _hou._VertexTuple_rend(self)

    def clear(self) -> "void":
        return _hou._VertexTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Vertex * >::allocator_type":
        return _hou._VertexTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._VertexTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Vertex * >::iterator":
        return _hou._VertexTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._VertexTuple_swiginit(self, _hou.new__VertexTuple(*args))

    def push_back(self, x: "Vertex") -> "void":
        return _hou._VertexTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Vertex * >::value_type":
        return _hou._VertexTuple_front(self)

    def back(self) -> "std::vector< HOM_Vertex * >::value_type":
        return _hou._VertexTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_Vertex * >::size_type", x: "Vertex"
    ) -> "void":
        return _hou._VertexTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._VertexTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._VertexTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Vertex * >::size_type") -> "void":
        return _hou._VertexTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Vertex * >::size_type":
        return _hou._VertexTuple_capacity(self)

    __swig_destroy__ = _hou.delete__VertexTuple


# Register _VertexTuple in _hou:
_hou._VertexTuple_swigregister(_VertexTuple)


class _RampTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._RampTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._RampTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._RampTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Ramp * >::size_type":
        return _hou._RampTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Ramp * >::difference_type",
        j: "std::vector< HOM_Ramp * >::difference_type",
    ) -> "std::vector< HOM_Ramp *,std::allocator< HOM_Ramp * > > *":
        return _hou._RampTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._RampTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Ramp * >::difference_type",
        j: "std::vector< HOM_Ramp * >::difference_type",
    ) -> "void":
        return _hou._RampTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._RampTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Ramp * >::value_type":
        return _hou._RampTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._RampTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Ramp * >::value_type":
        return _hou._RampTuple_pop(self)

    def append(self, x: "Ramp") -> "void":
        return _hou._RampTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._RampTuple_empty(self)

    def size(self) -> "std::vector< HOM_Ramp * >::size_type":
        return _hou._RampTuple_size(self)

    def swap(self, v: "_RampTuple") -> "void":
        return _hou._RampTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Ramp * >::iterator":
        return _hou._RampTuple_begin(self)

    def end(self) -> "std::vector< HOM_Ramp * >::iterator":
        return _hou._RampTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Ramp * >::reverse_iterator":
        return _hou._RampTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Ramp * >::reverse_iterator":
        return _hou._RampTuple_rend(self)

    def clear(self) -> "void":
        return _hou._RampTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Ramp * >::allocator_type":
        return _hou._RampTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._RampTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Ramp * >::iterator":
        return _hou._RampTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._RampTuple_swiginit(self, _hou.new__RampTuple(*args))

    def push_back(self, x: "Ramp") -> "void":
        return _hou._RampTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Ramp * >::value_type":
        return _hou._RampTuple_front(self)

    def back(self) -> "std::vector< HOM_Ramp * >::value_type":
        return _hou._RampTuple_back(self)

    def assign(self, n: "std::vector< HOM_Ramp * >::size_type", x: "Ramp") -> "void":
        return _hou._RampTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._RampTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._RampTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Ramp * >::size_type") -> "void":
        return _hou._RampTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Ramp * >::size_type":
        return _hou._RampTuple_capacity(self)

    __swig_destroy__ = _hou.delete__RampTuple


# Register _RampTuple in _hou:
_hou._RampTuple_swigregister(_RampTuple)


class _ParmTemplateTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._ParmTemplateTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._ParmTemplateTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._ParmTemplateTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_ParmTemplate * >::size_type":
        return _hou._ParmTemplateTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_ParmTemplate * >::difference_type",
        j: "std::vector< HOM_ParmTemplate * >::difference_type",
    ) -> "std::vector< HOM_ParmTemplate *,std::allocator< HOM_ParmTemplate * > > *":
        return _hou._ParmTemplateTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._ParmTemplateTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_ParmTemplate * >::difference_type",
        j: "std::vector< HOM_ParmTemplate * >::difference_type",
    ) -> "void":
        return _hou._ParmTemplateTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._ParmTemplateTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_ParmTemplate * >::value_type":
        return _hou._ParmTemplateTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._ParmTemplateTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_ParmTemplate * >::value_type":
        return _hou._ParmTemplateTuple_pop(self)

    def append(self, x: "ParmTemplate") -> "void":
        return _hou._ParmTemplateTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._ParmTemplateTuple_empty(self)

    def size(self) -> "std::vector< HOM_ParmTemplate * >::size_type":
        return _hou._ParmTemplateTuple_size(self)

    def swap(self, v: "_ParmTemplateTuple") -> "void":
        return _hou._ParmTemplateTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_ParmTemplate * >::iterator":
        return _hou._ParmTemplateTuple_begin(self)

    def end(self) -> "std::vector< HOM_ParmTemplate * >::iterator":
        return _hou._ParmTemplateTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_ParmTemplate * >::reverse_iterator":
        return _hou._ParmTemplateTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_ParmTemplate * >::reverse_iterator":
        return _hou._ParmTemplateTuple_rend(self)

    def clear(self) -> "void":
        return _hou._ParmTemplateTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_ParmTemplate * >::allocator_type":
        return _hou._ParmTemplateTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._ParmTemplateTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_ParmTemplate * >::iterator":
        return _hou._ParmTemplateTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._ParmTemplateTuple_swiginit(self, _hou.new__ParmTemplateTuple(*args))

    def push_back(self, x: "ParmTemplate") -> "void":
        return _hou._ParmTemplateTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_ParmTemplate * >::value_type":
        return _hou._ParmTemplateTuple_front(self)

    def back(self) -> "std::vector< HOM_ParmTemplate * >::value_type":
        return _hou._ParmTemplateTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_ParmTemplate * >::size_type", x: "ParmTemplate"
    ) -> "void":
        return _hou._ParmTemplateTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._ParmTemplateTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._ParmTemplateTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_ParmTemplate * >::size_type") -> "void":
        return _hou._ParmTemplateTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_ParmTemplate * >::size_type":
        return _hou._ParmTemplateTuple_capacity(self)

    __swig_destroy__ = _hou.delete__ParmTemplateTuple


# Register _ParmTemplateTuple in _hou:
_hou._ParmTemplateTuple_swigregister(_ParmTemplateTuple)


class _InterpreterObjectTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._InterpreterObjectTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._InterpreterObjectTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._InterpreterObjectTuple___bool__(self)

    def __len__(self) -> "std::vector< PyObject * >::size_type":
        return _hou._InterpreterObjectTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< PyObject * >::difference_type",
        j: "std::vector< PyObject * >::difference_type",
    ) -> "std::vector< PyObject *,std::allocator< PyObject * > > *":
        return _hou._InterpreterObjectTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._InterpreterObjectTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< PyObject * >::difference_type",
        j: "std::vector< PyObject * >::difference_type",
    ) -> "void":
        return _hou._InterpreterObjectTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._InterpreterObjectTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< PyObject * >::value_type":
        return _hou._InterpreterObjectTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._InterpreterObjectTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< PyObject * >::value_type":
        return _hou._InterpreterObjectTuple_pop(self)

    def append(self, x: "std::vector< PyObject * >::value_type") -> "void":
        return _hou._InterpreterObjectTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._InterpreterObjectTuple_empty(self)

    def size(self) -> "std::vector< PyObject * >::size_type":
        return _hou._InterpreterObjectTuple_size(self)

    def swap(self, v: "_InterpreterObjectTuple") -> "void":
        return _hou._InterpreterObjectTuple_swap(self, v)

    def begin(self) -> "std::vector< PyObject * >::iterator":
        return _hou._InterpreterObjectTuple_begin(self)

    def end(self) -> "std::vector< PyObject * >::iterator":
        return _hou._InterpreterObjectTuple_end(self)

    def rbegin(self) -> "std::vector< PyObject * >::reverse_iterator":
        return _hou._InterpreterObjectTuple_rbegin(self)

    def rend(self) -> "std::vector< PyObject * >::reverse_iterator":
        return _hou._InterpreterObjectTuple_rend(self)

    def clear(self) -> "void":
        return _hou._InterpreterObjectTuple_clear(self)

    def get_allocator(self) -> "std::vector< PyObject * >::allocator_type":
        return _hou._InterpreterObjectTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._InterpreterObjectTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< PyObject * >::iterator":
        return _hou._InterpreterObjectTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._InterpreterObjectTuple_swiginit(
            self, _hou.new__InterpreterObjectTuple(*args)
        )

    def push_back(self, x: "std::vector< PyObject * >::value_type") -> "void":
        return _hou._InterpreterObjectTuple_push_back(self, x)

    def front(self) -> "std::vector< PyObject * >::value_type":
        return _hou._InterpreterObjectTuple_front(self)

    def back(self) -> "std::vector< PyObject * >::value_type":
        return _hou._InterpreterObjectTuple_back(self)

    def assign(
        self,
        n: "std::vector< PyObject * >::size_type",
        x: "std::vector< PyObject * >::value_type",
    ) -> "void":
        return _hou._InterpreterObjectTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._InterpreterObjectTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._InterpreterObjectTuple_insert(self, *args)

    def reserve(self, n: "std::vector< PyObject * >::size_type") -> "void":
        return _hou._InterpreterObjectTuple_reserve(self, n)

    def capacity(self) -> "std::vector< PyObject * >::size_type":
        return _hou._InterpreterObjectTuple_capacity(self)

    __swig_destroy__ = _hou.delete__InterpreterObjectTuple


# Register _InterpreterObjectTuple in _hou:
_hou._InterpreterObjectTuple_swigregister(_InterpreterObjectTuple)


class _GeometryTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._GeometryTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._GeometryTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._GeometryTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Geometry * >::size_type":
        return _hou._GeometryTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Geometry * >::difference_type",
        j: "std::vector< HOM_Geometry * >::difference_type",
    ) -> "std::vector< HOM_Geometry *,std::allocator< HOM_Geometry * > > *":
        return _hou._GeometryTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._GeometryTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Geometry * >::difference_type",
        j: "std::vector< HOM_Geometry * >::difference_type",
    ) -> "void":
        return _hou._GeometryTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._GeometryTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Geometry * >::value_type":
        return _hou._GeometryTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._GeometryTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Geometry * >::value_type":
        return _hou._GeometryTuple_pop(self)

    def append(self, x: "Geometry") -> "void":
        return _hou._GeometryTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._GeometryTuple_empty(self)

    def size(self) -> "std::vector< HOM_Geometry * >::size_type":
        return _hou._GeometryTuple_size(self)

    def swap(self, v: "_GeometryTuple") -> "void":
        return _hou._GeometryTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Geometry * >::iterator":
        return _hou._GeometryTuple_begin(self)

    def end(self) -> "std::vector< HOM_Geometry * >::iterator":
        return _hou._GeometryTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Geometry * >::reverse_iterator":
        return _hou._GeometryTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Geometry * >::reverse_iterator":
        return _hou._GeometryTuple_rend(self)

    def clear(self) -> "void":
        return _hou._GeometryTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Geometry * >::allocator_type":
        return _hou._GeometryTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._GeometryTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Geometry * >::iterator":
        return _hou._GeometryTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._GeometryTuple_swiginit(self, _hou.new__GeometryTuple(*args))

    def push_back(self, x: "Geometry") -> "void":
        return _hou._GeometryTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Geometry * >::value_type":
        return _hou._GeometryTuple_front(self)

    def back(self) -> "std::vector< HOM_Geometry * >::value_type":
        return _hou._GeometryTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_Geometry * >::size_type", x: "Geometry"
    ) -> "void":
        return _hou._GeometryTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._GeometryTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._GeometryTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Geometry * >::size_type") -> "void":
        return _hou._GeometryTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Geometry * >::size_type":
        return _hou._GeometryTuple_capacity(self)

    __swig_destroy__ = _hou.delete__GeometryTuple


# Register _GeometryTuple in _hou:
_hou._GeometryTuple_swigregister(_GeometryTuple)


class _IKTargetTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._IKTargetTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._IKTargetTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._IKTargetTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_ik_Target * >::size_type":
        return _hou._IKTargetTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_ik_Target * >::difference_type",
        j: "std::vector< HOM_ik_Target * >::difference_type",
    ) -> "std::vector< HOM_ik_Target *,std::allocator< HOM_ik_Target * > > *":
        return _hou._IKTargetTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._IKTargetTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_ik_Target * >::difference_type",
        j: "std::vector< HOM_ik_Target * >::difference_type",
    ) -> "void":
        return _hou._IKTargetTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._IKTargetTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_ik_Target * >::value_type":
        return _hou._IKTargetTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._IKTargetTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_ik_Target * >::value_type":
        return _hou._IKTargetTuple_pop(self)

    def append(self, x: "_ik_Target") -> "void":
        return _hou._IKTargetTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._IKTargetTuple_empty(self)

    def size(self) -> "std::vector< HOM_ik_Target * >::size_type":
        return _hou._IKTargetTuple_size(self)

    def swap(self, v: "_IKTargetTuple") -> "void":
        return _hou._IKTargetTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_ik_Target * >::iterator":
        return _hou._IKTargetTuple_begin(self)

    def end(self) -> "std::vector< HOM_ik_Target * >::iterator":
        return _hou._IKTargetTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_ik_Target * >::reverse_iterator":
        return _hou._IKTargetTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_ik_Target * >::reverse_iterator":
        return _hou._IKTargetTuple_rend(self)

    def clear(self) -> "void":
        return _hou._IKTargetTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_ik_Target * >::allocator_type":
        return _hou._IKTargetTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._IKTargetTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_ik_Target * >::iterator":
        return _hou._IKTargetTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._IKTargetTuple_swiginit(self, _hou.new__IKTargetTuple(*args))

    def push_back(self, x: "_ik_Target") -> "void":
        return _hou._IKTargetTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_ik_Target * >::value_type":
        return _hou._IKTargetTuple_front(self)

    def back(self) -> "std::vector< HOM_ik_Target * >::value_type":
        return _hou._IKTargetTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_ik_Target * >::size_type", x: "_ik_Target"
    ) -> "void":
        return _hou._IKTargetTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._IKTargetTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._IKTargetTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_ik_Target * >::size_type") -> "void":
        return _hou._IKTargetTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_ik_Target * >::size_type":
        return _hou._IKTargetTuple_capacity(self)

    __swig_destroy__ = _hou.delete__IKTargetTuple


# Register _IKTargetTuple in _hou:
_hou._IKTargetTuple_swigregister(_IKTargetTuple)


class _SimpleDrawableTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._SimpleDrawableTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._SimpleDrawableTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._SimpleDrawableTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_SimpleDrawable * >::size_type":
        return _hou._SimpleDrawableTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_SimpleDrawable * >::difference_type",
        j: "std::vector< HOM_SimpleDrawable * >::difference_type",
    ) -> "std::vector< HOM_SimpleDrawable *,std::allocator< HOM_SimpleDrawable * > > *":
        return _hou._SimpleDrawableTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._SimpleDrawableTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_SimpleDrawable * >::difference_type",
        j: "std::vector< HOM_SimpleDrawable * >::difference_type",
    ) -> "void":
        return _hou._SimpleDrawableTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._SimpleDrawableTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_SimpleDrawable * >::value_type":
        return _hou._SimpleDrawableTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._SimpleDrawableTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_SimpleDrawable * >::value_type":
        return _hou._SimpleDrawableTuple_pop(self)

    def append(self, x: "SimpleDrawable") -> "void":
        return _hou._SimpleDrawableTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._SimpleDrawableTuple_empty(self)

    def size(self) -> "std::vector< HOM_SimpleDrawable * >::size_type":
        return _hou._SimpleDrawableTuple_size(self)

    def swap(self, v: "_SimpleDrawableTuple") -> "void":
        return _hou._SimpleDrawableTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_SimpleDrawable * >::iterator":
        return _hou._SimpleDrawableTuple_begin(self)

    def end(self) -> "std::vector< HOM_SimpleDrawable * >::iterator":
        return _hou._SimpleDrawableTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_SimpleDrawable * >::reverse_iterator":
        return _hou._SimpleDrawableTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_SimpleDrawable * >::reverse_iterator":
        return _hou._SimpleDrawableTuple_rend(self)

    def clear(self) -> "void":
        return _hou._SimpleDrawableTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_SimpleDrawable * >::allocator_type":
        return _hou._SimpleDrawableTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._SimpleDrawableTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_SimpleDrawable * >::iterator":
        return _hou._SimpleDrawableTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._SimpleDrawableTuple_swiginit(self, _hou.new__SimpleDrawableTuple(*args))

    def push_back(self, x: "SimpleDrawable") -> "void":
        return _hou._SimpleDrawableTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_SimpleDrawable * >::value_type":
        return _hou._SimpleDrawableTuple_front(self)

    def back(self) -> "std::vector< HOM_SimpleDrawable * >::value_type":
        return _hou._SimpleDrawableTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_SimpleDrawable * >::size_type", x: "SimpleDrawable"
    ) -> "void":
        return _hou._SimpleDrawableTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._SimpleDrawableTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._SimpleDrawableTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_SimpleDrawable * >::size_type") -> "void":
        return _hou._SimpleDrawableTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_SimpleDrawable * >::size_type":
        return _hou._SimpleDrawableTuple_capacity(self)

    __swig_destroy__ = _hou.delete__SimpleDrawableTuple


# Register _SimpleDrawableTuple in _hou:
_hou._SimpleDrawableTuple_swigregister(_SimpleDrawableTuple)


class _DrawableTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._DrawableTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._DrawableTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._DrawableTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_Drawable * >::size_type":
        return _hou._DrawableTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_Drawable * >::difference_type",
        j: "std::vector< HOM_Drawable * >::difference_type",
    ) -> "std::vector< HOM_Drawable *,std::allocator< HOM_Drawable * > > *":
        return _hou._DrawableTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._DrawableTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_Drawable * >::difference_type",
        j: "std::vector< HOM_Drawable * >::difference_type",
    ) -> "void":
        return _hou._DrawableTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._DrawableTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_Drawable * >::value_type":
        return _hou._DrawableTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._DrawableTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_Drawable * >::value_type":
        return _hou._DrawableTuple_pop(self)

    def append(self, x: "Drawable") -> "void":
        return _hou._DrawableTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._DrawableTuple_empty(self)

    def size(self) -> "std::vector< HOM_Drawable * >::size_type":
        return _hou._DrawableTuple_size(self)

    def swap(self, v: "_DrawableTuple") -> "void":
        return _hou._DrawableTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_Drawable * >::iterator":
        return _hou._DrawableTuple_begin(self)

    def end(self) -> "std::vector< HOM_Drawable * >::iterator":
        return _hou._DrawableTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_Drawable * >::reverse_iterator":
        return _hou._DrawableTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_Drawable * >::reverse_iterator":
        return _hou._DrawableTuple_rend(self)

    def clear(self) -> "void":
        return _hou._DrawableTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_Drawable * >::allocator_type":
        return _hou._DrawableTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._DrawableTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_Drawable * >::iterator":
        return _hou._DrawableTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._DrawableTuple_swiginit(self, _hou.new__DrawableTuple(*args))

    def push_back(self, x: "Drawable") -> "void":
        return _hou._DrawableTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_Drawable * >::value_type":
        return _hou._DrawableTuple_front(self)

    def back(self) -> "std::vector< HOM_Drawable * >::value_type":
        return _hou._DrawableTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_Drawable * >::size_type", x: "Drawable"
    ) -> "void":
        return _hou._DrawableTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._DrawableTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._DrawableTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_Drawable * >::size_type") -> "void":
        return _hou._DrawableTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_Drawable * >::size_type":
        return _hou._DrawableTuple_capacity(self)

    __swig_destroy__ = _hou.delete__DrawableTuple


# Register _DrawableTuple in _hou:
_hou._DrawableTuple_swigregister(_DrawableTuple)


class _StringMapDoubleTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._StringMapDoubleTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._StringMapDoubleTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._StringMapDoubleTuple___bool__(self)

    def __len__(self) -> "std::map< std::string,std::vector< double > >::size_type":
        return _hou._StringMapDoubleTuple___len__(self)

    def __iter__(self):
        return self.key_iterator()

    def iterkeys(self):
        return self.key_iterator()

    def itervalues(self):
        return self.value_iterator()

    def iteritems(self):
        return self.iterator()

    def __getitem__(
        self, key: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "std::map< std::string,std::vector< double > >::mapped_type const &":
        return _hou._StringMapDoubleTuple___getitem__(self, key)

    def __delitem__(
        self, key: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "void":
        return _hou._StringMapDoubleTuple___delitem__(self, key)

    def has_key(
        self, key: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "bool":
        return _hou._StringMapDoubleTuple_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _hou._StringMapDoubleTuple_keys(self)

    def values(self) -> "PyObject *":
        return _hou._StringMapDoubleTuple_values(self)

    def items(self) -> "PyObject *":
        return _hou._StringMapDoubleTuple_items(self)

    def __contains__(
        self, key: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "bool":
        return _hou._StringMapDoubleTuple___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _hou._StringMapDoubleTuple_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _hou._StringMapDoubleTuple_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _hou._StringMapDoubleTuple___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _hou._StringMapDoubleTuple_asdict(self)

    def __init__(self, *args):
        _hou._StringMapDoubleTuple_swiginit(self, _hou.new__StringMapDoubleTuple(*args))

    def empty(self) -> "bool":
        return _hou._StringMapDoubleTuple_empty(self)

    def size(self) -> "std::map< std::string,std::vector< double > >::size_type":
        return _hou._StringMapDoubleTuple_size(self)

    def swap(self, v: "_StringMapDoubleTuple") -> "void":
        return _hou._StringMapDoubleTuple_swap(self, v)

    def begin(self) -> "std::map< std::string,std::vector< double > >::iterator":
        return _hou._StringMapDoubleTuple_begin(self)

    def end(self) -> "std::map< std::string,std::vector< double > >::iterator":
        return _hou._StringMapDoubleTuple_end(self)

    def rbegin(
        self,
    ) -> "std::map< std::string,std::vector< double > >::reverse_iterator":
        return _hou._StringMapDoubleTuple_rbegin(self)

    def rend(self) -> "std::map< std::string,std::vector< double > >::reverse_iterator":
        return _hou._StringMapDoubleTuple_rend(self)

    def clear(self) -> "void":
        return _hou._StringMapDoubleTuple_clear(self)

    def get_allocator(
        self,
    ) -> "std::map< std::string,std::vector< double > >::allocator_type":
        return _hou._StringMapDoubleTuple_get_allocator(self)

    def count(
        self, x: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "std::map< std::string,std::vector< double > >::size_type":
        return _hou._StringMapDoubleTuple_count(self, x)

    def erase(self, *args) -> "void":
        return _hou._StringMapDoubleTuple_erase(self, *args)

    def find(
        self, x: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "std::map< std::string,std::vector< double > >::iterator":
        return _hou._StringMapDoubleTuple_find(self, x)

    def lower_bound(
        self, x: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "std::map< std::string,std::vector< double > >::iterator":
        return _hou._StringMapDoubleTuple_lower_bound(self, x)

    def upper_bound(
        self, x: "std::map< std::string,std::vector< double > >::key_type const &"
    ) -> "std::map< std::string,std::vector< double > >::iterator":
        return _hou._StringMapDoubleTuple_upper_bound(self, x)

    __swig_destroy__ = _hou.delete__StringMapDoubleTuple


# Register _StringMapDoubleTuple in _hou:
_hou._StringMapDoubleTuple_swigregister(_StringMapDoubleTuple)


class _StringTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__StringTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._StringTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._StringTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._StringTupleGenerator___repr__(self)


# Register _StringTupleGenerator in _hou:
_hou._StringTupleGenerator_swigregister(_StringTupleGenerator)


class _NetworkBoxTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__NetworkBoxTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._NetworkBoxTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._NetworkBoxTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._NetworkBoxTupleGenerator___repr__(self)


# Register _NetworkBoxTupleGenerator in _hou:
_hou._NetworkBoxTupleGenerator_swigregister(_NetworkBoxTupleGenerator)


class _StickyNoteTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__StickyNoteTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._StickyNoteTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._StickyNoteTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._StickyNoteTupleGenerator___repr__(self)


# Register _StickyNoteTupleGenerator in _hou:
_hou._StickyNoteTupleGenerator_swigregister(_StickyNoteTupleGenerator)


class _NodeTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__NodeTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._NodeTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._NodeTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._NodeTupleGenerator___repr__(self)


# Register _NodeTupleGenerator in _hou:
_hou._NodeTupleGenerator_swigregister(_NodeTupleGenerator)


class _PointTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__PointTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._PointTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._PointTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._PointTupleGenerator___repr__(self)


# Register _PointTupleGenerator in _hou:
_hou._PointTupleGenerator_swigregister(_PointTupleGenerator)


class _PrimTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__PrimTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._PrimTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._PrimTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._PrimTupleGenerator___repr__(self)


# Register _PrimTupleGenerator in _hou:
_hou._PrimTupleGenerator_swigregister(_PrimTupleGenerator)


class _EdgeTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__EdgeTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._EdgeTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._EdgeTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._EdgeTupleGenerator___repr__(self)


# Register _EdgeTupleGenerator in _hou:
_hou._EdgeTupleGenerator_swigregister(_EdgeTupleGenerator)


class _VertexTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__VertexTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._VertexTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._VertexTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._VertexTupleGenerator___repr__(self)


# Register _VertexTupleGenerator in _hou:
_hou._VertexTupleGenerator_swigregister(_VertexTupleGenerator)


class _DopDataTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__DopDataTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._DopDataTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._DopDataTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._DopDataTupleGenerator___repr__(self)


# Register _DopDataTupleGenerator in _hou:
_hou._DopDataTupleGenerator_swigregister(_DopDataTupleGenerator)


class _DopRecordTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__DopRecordTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._DopRecordTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._DopRecordTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._DopRecordTupleGenerator___repr__(self)


# Register _DopRecordTupleGenerator in _hou:
_hou._DopRecordTupleGenerator_swigregister(_DopRecordTupleGenerator)


class _NodeConnectionTupleOfTuplesGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__NodeConnectionTupleOfTuplesGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._NodeConnectionTupleOfTuplesGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._NodeConnectionTupleOfTuplesGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._NodeConnectionTupleOfTuplesGenerator___repr__(self)


# Register _NodeConnectionTupleOfTuplesGenerator in _hou:
_hou._NodeConnectionTupleOfTuplesGenerator_swigregister(
    _NodeConnectionTupleOfTuplesGenerator
)


class _AgentClipTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__AgentClipTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._AgentClipTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._AgentClipTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._AgentClipTupleGenerator___repr__(self)


# Register _AgentClipTupleGenerator in _hou:
_hou._AgentClipTupleGenerator_swigregister(_AgentClipTupleGenerator)


class _AgentLayerTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__AgentLayerTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._AgentLayerTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._AgentLayerTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._AgentLayerTupleGenerator___repr__(self)


# Register _AgentLayerTupleGenerator in _hou:
_hou._AgentLayerTupleGenerator_swigregister(_AgentLayerTupleGenerator)


class _AgentGroupTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__AgentGroupTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._AgentGroupTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._AgentGroupTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._AgentGroupTupleGenerator___repr__(self)


# Register _AgentGroupTupleGenerator in _hou:
_hou._AgentGroupTupleGenerator_swigregister(_AgentGroupTupleGenerator)


class _GeometryTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__GeometryTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._GeometryTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._GeometryTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._GeometryTupleGenerator___repr__(self)


# Register _GeometryTupleGenerator in _hou:
_hou._GeometryTupleGenerator_swigregister(_GeometryTupleGenerator)


class _IKJointTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__IKJointTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._IKJointTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._IKJointTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._IKJointTupleGenerator___repr__(self)


# Register _IKJointTupleGenerator in _hou:
_hou._IKJointTupleGenerator_swigregister(_IKJointTupleGenerator)


class _LogEntryTupleGenerator(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__LogEntryTupleGenerator

    def __getitem__(self, key: "int") -> "InterpreterObject":
        return _hou._LogEntryTupleGenerator___getitem__(self, key)

    def __len__(self) -> "int":
        return _hou._LogEntryTupleGenerator___len__(self)

    def __repr__(self) -> "std::string":
        return _hou._LogEntryTupleGenerator___repr__(self)


# Register _LogEntryTupleGenerator in _hou:
_hou._LogEntryTupleGenerator_swigregister(_LogEntryTupleGenerator)


class _AgentDefnMap(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentDefnMap_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._AgentDefnMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._AgentDefnMap___bool__(self)

    def __len__(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::size_type":
        return _hou._AgentDefnMap___len__(self)

    def __iter__(self):
        return self.key_iterator()

    def iterkeys(self):
        return self.key_iterator()

    def itervalues(self):
        return self.value_iterator()

    def iteritems(self):
        return self.iterator()

    def __getitem__(
        self, key: "AgentDefinition"
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::mapped_type const &":
        return _hou._AgentDefnMap___getitem__(self, key)

    def __delitem__(self, key: "AgentDefinition") -> "void":
        return _hou._AgentDefnMap___delitem__(self, key)

    def has_key(self, key: "AgentDefinition") -> "bool":
        return _hou._AgentDefnMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _hou._AgentDefnMap_keys(self)

    def values(self) -> "PyObject *":
        return _hou._AgentDefnMap_values(self)

    def items(self) -> "PyObject *":
        return _hou._AgentDefnMap_items(self)

    def __contains__(self, key: "AgentDefinition") -> "bool":
        return _hou._AgentDefnMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentDefnMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _hou._AgentDefnMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _hou._AgentDefnMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _hou._AgentDefnMap_asdict(self)

    def __init__(self, *args):
        _hou._AgentDefnMap_swiginit(self, _hou.new__AgentDefnMap(*args))

    def empty(self) -> "bool":
        return _hou._AgentDefnMap_empty(self)

    def size(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::size_type":
        return _hou._AgentDefnMap_size(self)

    def swap(self, v: "_AgentDefnMap") -> "void":
        return _hou._AgentDefnMap_swap(self, v)

    def begin(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::iterator":
        return _hou._AgentDefnMap_begin(self)

    def end(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::iterator":
        return _hou._AgentDefnMap_end(self)

    def rbegin(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::reverse_iterator":
        return _hou._AgentDefnMap_rbegin(self)

    def rend(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::reverse_iterator":
        return _hou._AgentDefnMap_rend(self)

    def clear(self) -> "void":
        return _hou._AgentDefnMap_clear(self)

    def get_allocator(
        self,
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::allocator_type":
        return _hou._AgentDefnMap_get_allocator(self)

    def count(
        self, x: "AgentDefinition"
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::size_type":
        return _hou._AgentDefnMap_count(self, x)

    def erase(self, *args) -> "void":
        return _hou._AgentDefnMap_erase(self, *args)

    def find(
        self, x: "AgentDefinition"
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::iterator":
        return _hou._AgentDefnMap_find(self, x)

    def lower_bound(
        self, x: "AgentDefinition"
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::iterator":
        return _hou._AgentDefnMap_lower_bound(self, x)

    def upper_bound(
        self, x: "AgentDefinition"
    ) -> "std::map< HOM_AgentDefinition *,HOM_AgentDefinition * >::iterator":
        return _hou._AgentDefnMap_upper_bound(self, x)

    __swig_destroy__ = _hou.delete__AgentDefnMap


# Register _AgentDefnMap in _hou:
_hou._AgentDefnMap_swigregister(_AgentDefnMap)


class _DopObjectTuple(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _hou._DopObjectTuple_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _hou._DopObjectTuple___nonzero__(self)

    def __bool__(self) -> "bool":
        return _hou._DopObjectTuple___bool__(self)

    def __len__(self) -> "std::vector< HOM_DopObject * >::size_type":
        return _hou._DopObjectTuple___len__(self)

    def __getslice__(
        self,
        i: "std::vector< HOM_DopObject * >::difference_type",
        j: "std::vector< HOM_DopObject * >::difference_type",
    ) -> "std::vector< HOM_DopObject *,std::allocator< HOM_DopObject * > > *":
        return _hou._DopObjectTuple___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _hou._DopObjectTuple___setslice__(self, *args)

    def __delslice__(
        self,
        i: "std::vector< HOM_DopObject * >::difference_type",
        j: "std::vector< HOM_DopObject * >::difference_type",
    ) -> "void":
        return _hou._DopObjectTuple___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _hou._DopObjectTuple___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< HOM_DopObject * >::value_type":
        return _hou._DopObjectTuple___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _hou._DopObjectTuple___setitem__(self, *args)

    def pop(self) -> "std::vector< HOM_DopObject * >::value_type":
        return _hou._DopObjectTuple_pop(self)

    def append(self, x: "DopObject") -> "void":
        return _hou._DopObjectTuple_append(self, x)

    def empty(self) -> "bool":
        return _hou._DopObjectTuple_empty(self)

    def size(self) -> "std::vector< HOM_DopObject * >::size_type":
        return _hou._DopObjectTuple_size(self)

    def swap(self, v: "_DopObjectTuple") -> "void":
        return _hou._DopObjectTuple_swap(self, v)

    def begin(self) -> "std::vector< HOM_DopObject * >::iterator":
        return _hou._DopObjectTuple_begin(self)

    def end(self) -> "std::vector< HOM_DopObject * >::iterator":
        return _hou._DopObjectTuple_end(self)

    def rbegin(self) -> "std::vector< HOM_DopObject * >::reverse_iterator":
        return _hou._DopObjectTuple_rbegin(self)

    def rend(self) -> "std::vector< HOM_DopObject * >::reverse_iterator":
        return _hou._DopObjectTuple_rend(self)

    def clear(self) -> "void":
        return _hou._DopObjectTuple_clear(self)

    def get_allocator(self) -> "std::vector< HOM_DopObject * >::allocator_type":
        return _hou._DopObjectTuple_get_allocator(self)

    def pop_back(self) -> "void":
        return _hou._DopObjectTuple_pop_back(self)

    def erase(self, *args) -> "std::vector< HOM_DopObject * >::iterator":
        return _hou._DopObjectTuple_erase(self, *args)

    def __init__(self, *args):
        _hou._DopObjectTuple_swiginit(self, _hou.new__DopObjectTuple(*args))

    def push_back(self, x: "DopObject") -> "void":
        return _hou._DopObjectTuple_push_back(self, x)

    def front(self) -> "std::vector< HOM_DopObject * >::value_type":
        return _hou._DopObjectTuple_front(self)

    def back(self) -> "std::vector< HOM_DopObject * >::value_type":
        return _hou._DopObjectTuple_back(self)

    def assign(
        self, n: "std::vector< HOM_DopObject * >::size_type", x: "DopObject"
    ) -> "void":
        return _hou._DopObjectTuple_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _hou._DopObjectTuple_resize(self, *args)

    def insert(self, *args) -> "void":
        return _hou._DopObjectTuple_insert(self, *args)

    def reserve(self, n: "std::vector< HOM_DopObject * >::size_type") -> "void":
        return _hou._DopObjectTuple_reserve(self, n)

    def capacity(self) -> "std::vector< HOM_DopObject * >::size_type":
        return _hou._DopObjectTuple_capacity(self)

    __swig_destroy__ = _hou.delete__DopObjectTuple


# Register _DopObjectTuple in _hou:
_hou._DopObjectTuple_swigregister(_DopObjectTuple)


class EnumValue(object):
    r"""

    hou.EnumValue

    This class is the base class for an enumeration value. It cannot be
    instanced and is not meant to be used directly by the user.

    All the built-in HOM enumeration values are derived from this class such
    as hou.paneTabType.*, hou.severityType.*, and hou.connectivityType.*.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def __eq__(self, value: "HOM_PtrOrNull< HOM_EnumValue >") -> "bool":
        return _hou.EnumValue___eq__(self, value)

    def __ne__(self, value: "HOM_PtrOrNull< HOM_EnumValue >") -> "bool":
        return _hou.EnumValue___ne__(self, value)

    def __repr__(self) -> "std::string":
        return _hou.EnumValue___repr__(self)

    def __hash__(self) -> "int":
        return _hou.EnumValue___hash__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> string

            Returns the name of the enumeration value.


        """
        return _hou.EnumValue_name(self)

    def __lt__(self, value: "EnumValue") -> "bool":
        return _hou.EnumValue___lt__(self, value)


# Register EnumValue in _hou:
_hou.EnumValue_swigregister(EnumValue)


class numericData(object):
    r"""

    hou.numericData

    Enumeration of numeric value types.

    VALUES


        Int8
        Int16
        Int32
        Int64
        Float16
        Float32
        Float64


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_numericData


# Register numericData in _hou:
_hou.numericData_swigregister(numericData)
cvar = _hou.cvar
numericData.Int8 = _hou.cvar.numericData_Int8
numericData.Int16 = _hou.cvar.numericData_Int16
numericData.Int32 = _hou.cvar.numericData_Int32
numericData.Int64 = _hou.cvar.numericData_Int64
numericData.Float16 = _hou.cvar.numericData_Float16
numericData.Float32 = _hou.cvar.numericData_Float32
numericData.Float64 = _hou.cvar.numericData_Float64


class attribData(object):
    r"""

    hou.attribData

    Enumeration of attribute data types.

    VALUES


        Int
        Float
        String
        Dict


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_attribData


# Register attribData in _hou:
_hou.attribData_swigregister(attribData)
attribData.Int = _hou.cvar.attribData_Int
attribData.Float = _hou.cvar.attribData_Float
attribData.String = _hou.cvar.attribData_String
attribData.Dict = _hou.cvar.attribData_Dict


class attribType(object):
    r"""

    hou.attribType

    Enumeration of geometry attribute types.

    Note that global attributes are also known as detail attributes.

    The type of data (e.g. int, float, string) is called the attribute data
    type, can correspond to hou.attribData.

    See hou.Geometry.addAttrib and hou.Attrib for more information.

    VALUES


        Point
        Prim
        Vertex
        Global


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_attribType


# Register attribType in _hou:
_hou.attribType_swigregister(attribType)
attribType.Point = _hou.cvar.attribType_Point
attribType.Prim = _hou.cvar.attribType_Prim
attribType.Vertex = _hou.cvar.attribType_Vertex
attribType.Global = _hou.cvar.attribType_Global


class primType(object):
    r"""

    hou.primType

    Enumeration of primitive types.

    VALUES


        Agent
        AlembicRef
        BezierCurve
        BezierSurface
        Circle
        Custom
            Catch-all for all HDK-defined primitives types.

        Hexahedron
            Eight points that deform a cubic volume.

        Mesh
        Metaball
        NURBSCurve
        NURBSSurface
        PackedFragment
        PackedGeometry
        PackedPrim
        ParticleSystem
            Obsolete type that represented particles, unconnected points are
            currently used for particles.

        PastedSurface
            Obsolete type to support NURBS that lie in the domain of other
            NURBS.

        Polygon
        PolySoup
        Sphere
        Tetrahedron
            Four points that define a pyrmadial volume.

        TriangleBezier
        TriangleFan
            Defines a triangle between the first point and each consecutive
            pair of points.

        TriangleStrip
            Defines a triangle between each consecutive triple of points.

        Tube
        Unknown
        VDB
        Volume


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_primType


# Register primType in _hou:
_hou.primType_swigregister(primType)
primType.Polygon = _hou.cvar.primType_Polygon
primType.NURBSCurve = _hou.cvar.primType_NURBSCurve
primType.BezierCurve = _hou.cvar.primType_BezierCurve
primType.Mesh = _hou.cvar.primType_Mesh
primType.NURBSSurface = _hou.cvar.primType_NURBSSurface
primType.BezierSurface = _hou.cvar.primType_BezierSurface
primType.Circle = _hou.cvar.primType_Circle
primType.Sphere = _hou.cvar.primType_Sphere
primType.Tube = _hou.cvar.primType_Tube
primType.Metaball = _hou.cvar.primType_Metaball
primType.TriangleFan = _hou.cvar.primType_TriangleFan
primType.TriangleStrip = _hou.cvar.primType_TriangleStrip
primType.TriangleBezier = _hou.cvar.primType_TriangleBezier
primType.PastedSurface = _hou.cvar.primType_PastedSurface
primType.Volume = _hou.cvar.primType_Volume
primType.ParticleSystem = _hou.cvar.primType_ParticleSystem
primType.Unknown = _hou.cvar.primType_Unknown
primType.Tetrahedron = _hou.cvar.primType_Tetrahedron
primType.PolySoup = _hou.cvar.primType_PolySoup
primType.VDB = _hou.cvar.primType_VDB
primType.AlembicRef = _hou.cvar.primType_AlembicRef
primType.Custom = _hou.cvar.primType_Custom
primType.PackedPrim = _hou.cvar.primType_PackedPrim
primType.Agent = _hou.cvar.primType_Agent
primType.PackedFragment = _hou.cvar.primType_PackedFragment
primType.PackedGeometry = _hou.cvar.primType_PackedGeometry
primType.Hexahedron = _hou.cvar.primType_Hexahedron


class parmData(object):
    r"""

    hou.parmData

    Enumeration of parameter data types.

    VALUES


        Int
        Float
        String
        Ramp


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmData


# Register parmData in _hou:
_hou.parmData_swigregister(parmData)
parmData.Int = _hou.cvar.parmData_Int
parmData.Float = _hou.cvar.parmData_Float
parmData.String = _hou.cvar.parmData_String
parmData.Ramp = _hou.cvar.parmData_Ramp
parmData.Data = _hou.cvar.parmData_Data


class parmTemplateType(object):
    r"""

    hou.parmTemplateType

    Enumeration of parameter template types.

    VALUES


        Int
        Float
        String
        Toggle
        Menu
        Button
        FolderSet
        Folder
        Separator
        Label
        Ramp
        Data


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmTemplateType


# Register parmTemplateType in _hou:
_hou.parmTemplateType_swigregister(parmTemplateType)
parmTemplateType.Int = _hou.cvar.parmTemplateType_Int
parmTemplateType.Float = _hou.cvar.parmTemplateType_Float
parmTemplateType.String = _hou.cvar.parmTemplateType_String
parmTemplateType.Toggle = _hou.cvar.parmTemplateType_Toggle
parmTemplateType.Menu = _hou.cvar.parmTemplateType_Menu
parmTemplateType.Button = _hou.cvar.parmTemplateType_Button
parmTemplateType.FolderSet = _hou.cvar.parmTemplateType_FolderSet
parmTemplateType.Folder = _hou.cvar.parmTemplateType_Folder
parmTemplateType.Separator = _hou.cvar.parmTemplateType_Separator
parmTemplateType.Label = _hou.cvar.parmTemplateType_Label
parmTemplateType.Ramp = _hou.cvar.parmTemplateType_Ramp
parmTemplateType.Data = _hou.cvar.parmTemplateType_Data


class parmLook(object):
    r"""

    hou.parmLook

    Enumeration of available looks for a parameter

    These looks are used by hou.ParmTemplate objects and control the user
    interface of the parameter in parameter editors.

    VALUES


        Regular
            The default parameter look.

        Logarithmic
            The parameter displays a slider that changes the value on a
            logarithmic scale.

        Angle
            The parameter has an arc control to enter an angle.

            If you use this look, set your parameter's naming scheme to
            hou.parmNamingScheme.Base1.

        Vector
            The parameter has a handle beside the label to edit the vector
            direction.

            If you use this look, set your parameter's naming scheme to
            hou.parmNamingScheme.XYZW.

        ColorSquare
            The parameter has a square button beside the label to display
            the current color. You can click on the square to edit the
            color.

            If you use this look, set your parameter's naming scheme to
            hou.parmNamingScheme.RGBA.

        HueCircle
            The parameter has a hue circle with a pie-shaped region, like
            the keying nodes in COPs have.

        CRGBAPlaneChooser
            The parameter has an RGBA mask, with buttons to toggle the red,
            green, blue, and alpha planes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmLook


# Register parmLook in _hou:
_hou.parmLook_swigregister(parmLook)
parmLook.Regular = _hou.cvar.parmLook_Regular
parmLook.Angle = _hou.cvar.parmLook_Angle
parmLook.Vector = _hou.cvar.parmLook_Vector
parmLook.ColorSquare = _hou.cvar.parmLook_ColorSquare
parmLook.HueCircle = _hou.cvar.parmLook_HueCircle
parmLook.CRGBAPlaneChooser = _hou.cvar.parmLook_CRGBAPlaneChooser
parmLook.Logarithmic = _hou.cvar.parmLook_Logarithmic


class parmNamingScheme(object):
    r"""

    hou.parmNamingScheme

    Enumeration of available naming schemes for a parameter.

    These naming schemes are stored inside hou.ParmTemplate objects and
    determine the names of hou.Parm objects inside hou.ParmTuple objects.

    The number of components in the parm template determines the number of
    parms inside the parm tuple. If this number is 1, the parm name is the
    same as the parm tuple name. If the naming scheme is Base1, the number
    of components may be more than 4. Otherwise, the component may have from
    2 components up to the maximum number allowed by the naming scheme.

    The following restrictions exist on naming schemes:

      * You cannot use the following naming schemes when editing the
        parameter interface on a node or a digital asset: MinMax, MaxMin,
        StartEnd, BeginEnd, XYWH. However, some built-in node types use
        parameters with these naming schemes, so asking these node types for
        their parm templates may return ones using these naming schemes.

      * String and toggle parameters only support the Base1 naming scheme.

      * Parameters with the hou.parmLook.Vector look must use the XYZW
        naming scheme.

      * Parameters with the hou.parmLook.Angle look must use the Base1
        naming scheme.

      * Parameters with the hou.parmLook.ColorSquare look must use an RGBA
        naming scheme.

    The example names below are for a parm template named \"foo\":

    VALUES


        Base1
            \"foo1\", \"foo2\", \"foo3\", ...

        XYZW
            \"foox\", \"fooy\", \"fooz\", \"foow\"

        XYWH
            \"foox\", \"fooy\", \"foow\", \"fooh\"

        UVW
            \"foou\", \"foov\", \"foow\"

        RGBA
            \"foor\", \"foog\", \"foob\", \"fooa\"

        MinMax
            \"foomin\", \"foomax\"

        MaxMin
            \"foomax\", \"foomin\"

        StartEnd
            \"foostart\", \"fooend\"

        BeginEnd
            \"foobegin\", \"fooend\"


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmNamingScheme


# Register parmNamingScheme in _hou:
_hou.parmNamingScheme_swigregister(parmNamingScheme)
parmNamingScheme.Base1 = _hou.cvar.parmNamingScheme_Base1
parmNamingScheme.XYZW = _hou.cvar.parmNamingScheme_XYZW
parmNamingScheme.XYWH = _hou.cvar.parmNamingScheme_XYWH
parmNamingScheme.UVW = _hou.cvar.parmNamingScheme_UVW
parmNamingScheme.RGBA = _hou.cvar.parmNamingScheme_RGBA
parmNamingScheme.MinMax = _hou.cvar.parmNamingScheme_MinMax
parmNamingScheme.MaxMin = _hou.cvar.parmNamingScheme_MaxMin
parmNamingScheme.StartEnd = _hou.cvar.parmNamingScheme_StartEnd
parmNamingScheme.BeginEnd = _hou.cvar.parmNamingScheme_BeginEnd


class parmCondType(object):
    r"""

    hou.parmCondType

    Enumeration of available parameter conditional types.

    VALUES


        DisableWhen
        HideWhen
        NoCookWhen


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmCondType


# Register parmCondType in _hou:
_hou.parmCondType_swigregister(parmCondType)
parmCondType.DisableWhen = _hou.cvar.parmCondType_DisableWhen
parmCondType.HideWhen = _hou.cvar.parmCondType_HideWhen
parmCondType.NoCookWhen = _hou.cvar.parmCondType_NoCookWhen


class parmExtrapolate(object):
    r"""

    hou.parmExtrapolate

    Enumeration of Extrapolation methods when evaluating value outside the
    keyframe range.

    VALUES


        Default
        Hold
        Cycle
        Extend
        Slope
        CycleOffset
        Oscillate


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmExtrapolate


# Register parmExtrapolate in _hou:
_hou.parmExtrapolate_swigregister(parmExtrapolate)
parmExtrapolate.Default = _hou.cvar.parmExtrapolate_Default
parmExtrapolate.Hold = _hou.cvar.parmExtrapolate_Hold
parmExtrapolate.Cycle = _hou.cvar.parmExtrapolate_Cycle
parmExtrapolate.Extend = _hou.cvar.parmExtrapolate_Extend
parmExtrapolate.Slope = _hou.cvar.parmExtrapolate_Slope
parmExtrapolate.CycleOffset = _hou.cvar.parmExtrapolate_CycleOffset
parmExtrapolate.Oscillate = _hou.cvar.parmExtrapolate_Oscillate


class parmBakeChop(object):
    r"""

    hou.parmBakeChop

    Enumeration of Bake Chop modes.

    See hou.Parm.keyframesRefit.

    VALUES


        Off
        KeepExportFlag
        DisableExportFlag
        CreateDeleteChop


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmBakeChop


# Register parmBakeChop in _hou:
_hou.parmBakeChop_swigregister(parmBakeChop)
parmBakeChop.Off = _hou.cvar.parmBakeChop_Off
parmBakeChop.KeepExportFlag = _hou.cvar.parmBakeChop_KeepExportFlag
parmBakeChop.DisableExportFlag = _hou.cvar.parmBakeChop_DisableExportFlag
parmBakeChop.CreateDeleteChop = _hou.cvar.parmBakeChop_CreateDeleteChop


class stringParmType(object):
    r"""

    hou.stringParmType

    Enumeration of string parameter types.

    A hou.StringParmTemplate is set to one of these types to specify whether
    a string parameter will hold an arbitrary string, a reference to a file,
    a reference to a node, or a reference to multiple nodes.

    VALUES


        Regular
        FileReference
        NodeReference
        NodeReferenceList


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_stringParmType


# Register stringParmType in _hou:
_hou.stringParmType_swigregister(stringParmType)
stringParmType.Regular = _hou.cvar.stringParmType_Regular
stringParmType.FileReference = _hou.cvar.stringParmType_FileReference
stringParmType.NodeReference = _hou.cvar.stringParmType_NodeReference
stringParmType.NodeReferenceList = _hou.cvar.stringParmType_NodeReferenceList


class labelParmType(object):
    r"""

    hou.labelParmType

    Enumeration of label parameter types.

    A hou.LabelParmTemplate is set to one of these types to specify whether
    a label parameter will be a plain label, a heading, or a multi-line
    message block.

    VALUES


        Heading
        Label
        Message


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_labelParmType


# Register labelParmType in _hou:
_hou.labelParmType_swigregister(labelParmType)
labelParmType.Label = _hou.cvar.labelParmType_Label
labelParmType.Heading = _hou.cvar.labelParmType_Heading
labelParmType.Message = _hou.cvar.labelParmType_Message


class dataParmType(object):
    r"""

    hou.dataParmType

    Enumeration of data parameter types.

    A hou.DataParmTemplate is set to one of these types to specify whether a
    data parameter will hold geometry data or a key-value dictionary
    structure.

    VALUES


        Geometry
        KeyValueDictionary


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_dataParmType


# Register dataParmType in _hou:
_hou.dataParmType_swigregister(dataParmType)
dataParmType.Geometry = _hou.cvar.dataParmType_Geometry
dataParmType.KeyValueDictionary = _hou.cvar.dataParmType_KeyValueDictionary


class exprLanguage(object):
    r"""

    hou.exprLanguage

    Enumeration of available expression languages.

    VALUES


        Python
        Hscript


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_exprLanguage


# Register exprLanguage in _hou:
_hou.exprLanguage_swigregister(exprLanguage)
exprLanguage.Python = _hou.cvar.exprLanguage_Python
exprLanguage.Hscript = _hou.cvar.exprLanguage_Hscript


class scriptLanguage(object):
    r"""

    hou.scriptLanguage

    Enumeration of available script languages.

    VALUES


        Python
        Hscript


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_scriptLanguage


# Register scriptLanguage in _hou:
_hou.scriptLanguage_swigregister(scriptLanguage)
scriptLanguage.Python = _hou.cvar.scriptLanguage_Python
scriptLanguage.Hscript = _hou.cvar.scriptLanguage_Hscript


class fileType(object):
    r"""

    hou.fileType

    Enumeration of file types.

    VALUES


        Any
        Image
        Geometry
        Ramp
        Capture
        Clip
        Lut
        Cmd
        Midi
        I3d
        Chan
        Sim
        SimData
        Hip
        Otl
        Dae
        Gallery
        Directory
        Icon
        Ds
        Alembic
        Psd
        LightRig
        Gltf
        Movie
        Fbx
        Usd
        Sqlite


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_fileType


# Register fileType in _hou:
_hou.fileType_swigregister(fileType)
fileType.Any = _hou.cvar.fileType_Any
fileType.Image = _hou.cvar.fileType_Image
fileType.Geometry = _hou.cvar.fileType_Geometry
fileType.Ramp = _hou.cvar.fileType_Ramp
fileType.Capture = _hou.cvar.fileType_Capture
fileType.Clip = _hou.cvar.fileType_Clip
fileType.Lut = _hou.cvar.fileType_Lut
fileType.Cmd = _hou.cvar.fileType_Cmd
fileType.Midi = _hou.cvar.fileType_Midi
fileType.I3d = _hou.cvar.fileType_I3d
fileType.Chan = _hou.cvar.fileType_Chan
fileType.Sim = _hou.cvar.fileType_Sim
fileType.SimData = _hou.cvar.fileType_SimData
fileType.Hip = _hou.cvar.fileType_Hip
fileType.Otl = _hou.cvar.fileType_Otl
fileType.Dae = _hou.cvar.fileType_Dae
fileType.Gallery = _hou.cvar.fileType_Gallery
fileType.Directory = _hou.cvar.fileType_Directory
fileType.Icon = _hou.cvar.fileType_Icon
fileType.Alembic = _hou.cvar.fileType_Alembic
fileType.Psd = _hou.cvar.fileType_Psd
fileType.LightRig = _hou.cvar.fileType_LightRig
fileType.Ds = _hou.cvar.fileType_Ds
fileType.Gltf = _hou.cvar.fileType_Gltf
fileType.Movie = _hou.cvar.fileType_Movie
fileType.Fbx = _hou.cvar.fileType_Fbx
fileType.Usd = _hou.cvar.fileType_Usd
fileType.Sqlite = _hou.cvar.fileType_Sqlite


class fileChooserMode(object):
    r"""

    hou.fileChooserMode

    Enumeration of possible read/write modes for the file chooser.

    See hou.ui.selectFile.

    VALUES


        Read
        Write
        ReadAndWrite


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_fileChooserMode


# Register fileChooserMode in _hou:
_hou.fileChooserMode_swigregister(fileChooserMode)
fileChooserMode.Read = _hou.cvar.fileChooserMode_Read
fileChooserMode.Write = _hou.cvar.fileChooserMode_Write
fileChooserMode.ReadAndWrite = _hou.cvar.fileChooserMode_ReadAndWrite


class folderType(object):
    r"""

    hou.folderType

    Enumeration of folder types for FolderParmTemplates.

    See also hou.FolderParmTemplate.

    VALUES


        Collapsible
            A folder that expands and collapses to show and hide its
            contents respectively.

        Simple
            A simple folder for organizing parameters in the form of a group
            box.

        Tabs
            A normal folder represented by a tab.

        RadioButtons
            A folder with a radio button. The open folder is the selected
            radio button in the set of buttons.

        MultiparmBlock
            A block of multiparms. The user can add or remove instances of
            this parameter block.

        ScrollingMultiparmBlock
            A multiparm block inside a smaller region with scroll bars.

        TabbedMultiparmBlock
            A multiparm block where each instance of the parameters in the
            block appears in its own tab.

        ImportBlock
            A block containing parameters imported from another node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_folderType


# Register folderType in _hou:
_hou.folderType_swigregister(folderType)
folderType.Simple = _hou.cvar.folderType_Simple
folderType.Collapsible = _hou.cvar.folderType_Collapsible
folderType.Tabs = _hou.cvar.folderType_Tabs
folderType.RadioButtons = _hou.cvar.folderType_RadioButtons
folderType.MultiparmBlock = _hou.cvar.folderType_MultiparmBlock
folderType.ScrollingMultiparmBlock = _hou.cvar.folderType_ScrollingMultiparmBlock
folderType.TabbedMultiparmBlock = _hou.cvar.folderType_TabbedMultiparmBlock
folderType.ImportBlock = _hou.cvar.folderType_ImportBlock


class menuType(object):
    r"""

    hou.menuType

    Enumeration of parameter menu types.

    See also hou.MenuParmTemplate and hou.StringParmTemplate.

    VALUES


        Normal
            A standard menu that displays the currently selected menu item.

        Mini
            A condensed menu that only displays a dropdown arrow. Houdini
            lets you choose a menu entry when you click on this arrow.

        ControlNextParameter
            A standard menu that displays the currently selected menu item.
            This menu always joins horizontally to the next parameter and is
            displayed without a label. However unlike simply turning off the
            label and joining to the next parameter, the layout of the next
            parameter is such that a series of parameters preceded by menus
            of this type will align in a much more appealing way.

        StringReplace
            A menu that also displays an input field. Selecting an entry
            from this menu will replace the contents of the field with the
            menu item. This type of menu only has meaning for string
            parameters.

        StringToggle
            A menu that also displays an input field. Selecting an entry
            from this menu will add the menu item to the field if it was not
            already there, and will remove it from the field it if was. This
            type of menu only has meaning for string parameters.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_menuType


# Register menuType in _hou:
_hou.menuType_swigregister(menuType)
menuType.Normal = _hou.cvar.menuType_Normal
menuType.Mini = _hou.cvar.menuType_Mini
menuType.StringReplace = _hou.cvar.menuType_StringReplace
menuType.StringToggle = _hou.cvar.menuType_StringToggle
menuType.ControlNextParameter = _hou.cvar.menuType_ControlNextParameter


class paneTabType(object):
    r"""

    hou.paneTabType

    Enumeration of pane tab types.

    VALUES


        AssetBrowser
        BundleList
        ChannelEditor
        ChannelList
        ChannelViewer
        CompositorViewer
        ContextViewer
        DataTree
        DetailsView
        EngineSessionSync
        HandleList
        HelpBrowser
        IPRViewer
        LightLinker
        MaterialPalette
        NetworkEditor
        OutputViewer
        Parm
        ParmSpreadsheet
        PerformanceMonitor
        PythonPanel
        PythonShell
        RenderGallery
        SceneViewer
        ShaderViewer
        TakeList
        Textport
        TreeView


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_paneTabType


# Register paneTabType in _hou:
_hou.paneTabType_swigregister(paneTabType)
paneTabType.SceneViewer = _hou.cvar.paneTabType_SceneViewer
paneTabType.ContextViewer = _hou.cvar.paneTabType_ContextViewer
paneTabType.ChannelViewer = _hou.cvar.paneTabType_ChannelViewer
paneTabType.CompositorViewer = _hou.cvar.paneTabType_CompositorViewer
paneTabType.OutputViewer = _hou.cvar.paneTabType_OutputViewer
paneTabType.MaterialPalette = _hou.cvar.paneTabType_MaterialPalette
paneTabType.ShaderViewer = _hou.cvar.paneTabType_ShaderViewer
paneTabType.IPRViewer = _hou.cvar.paneTabType_IPRViewer
paneTabType.NetworkEditor = _hou.cvar.paneTabType_NetworkEditor
paneTabType.Parm = _hou.cvar.paneTabType_Parm
paneTabType.DetailsView = _hou.cvar.paneTabType_DetailsView
paneTabType.ChannelEditor = _hou.cvar.paneTabType_ChannelEditor
paneTabType.ChannelList = _hou.cvar.paneTabType_ChannelList
paneTabType.Textport = _hou.cvar.paneTabType_Textport
paneTabType.PythonShell = _hou.cvar.paneTabType_PythonShell
paneTabType.HandleList = _hou.cvar.paneTabType_HandleList
paneTabType.BundleList = _hou.cvar.paneTabType_BundleList
paneTabType.TakeList = _hou.cvar.paneTabType_TakeList
paneTabType.TreeView = _hou.cvar.paneTabType_TreeView
paneTabType.PythonPanel = _hou.cvar.paneTabType_PythonPanel
paneTabType.HelpBrowser = _hou.cvar.paneTabType_HelpBrowser
paneTabType.ParmSpreadsheet = _hou.cvar.paneTabType_ParmSpreadsheet
paneTabType.LightLinker = _hou.cvar.paneTabType_LightLinker
paneTabType.AssetBrowser = _hou.cvar.paneTabType_AssetBrowser
paneTabType.PerformanceMonitor = _hou.cvar.paneTabType_PerformanceMonitor
paneTabType.RenderGallery = _hou.cvar.paneTabType_RenderGallery
paneTabType.DataTree = _hou.cvar.paneTabType_DataTree
paneTabType.SceneGraphTree = _hou.cvar.paneTabType_SceneGraphTree
paneTabType.EngineSessionSync = _hou.cvar.paneTabType_EngineSessionSync


class stateViewerType(object):
    r"""

    hou.stateViewerType

    Enumeration of state viewer types.

    VALUES


        Scene
        Compositor


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_stateViewerType


# Register stateViewerType in _hou:
_hou.stateViewerType_swigregister(stateViewerType)
stateViewerType.Scene = _hou.cvar.stateViewerType_Scene
stateViewerType.Compositor = _hou.cvar.stateViewerType_Compositor
stateViewerType.SceneGraph = _hou.cvar.stateViewerType_SceneGraph


class paneLinkType(object):
    r"""

    hou.paneLinkType

    Enumeration of possible pane link values.

    VALUES


        Pinned
        Group1
        Group2
        Group3
        Group4
        Group5
        Group6
        Group7
        Group8
        FollowSelection


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_paneLinkType


# Register paneLinkType in _hou:
_hou.paneLinkType_swigregister(paneLinkType)
paneLinkType.Pinned = _hou.cvar.paneLinkType_Pinned
paneLinkType.Group1 = _hou.cvar.paneLinkType_Group1
paneLinkType.Group2 = _hou.cvar.paneLinkType_Group2
paneLinkType.Group3 = _hou.cvar.paneLinkType_Group3
paneLinkType.Group4 = _hou.cvar.paneLinkType_Group4
paneLinkType.Group5 = _hou.cvar.paneLinkType_Group5
paneLinkType.Group6 = _hou.cvar.paneLinkType_Group6
paneLinkType.Group7 = _hou.cvar.paneLinkType_Group7
paneLinkType.Group8 = _hou.cvar.paneLinkType_Group8
paneLinkType.Group9 = _hou.cvar.paneLinkType_Group9
paneLinkType.FollowSelection = _hou.cvar.paneLinkType_FollowSelection


class networkItemType(object):
    r"""

    hou.networkItemType

    <Summary>

    <Description>

    VALUES


        Connection
        NetworkBox
        NetworkDot
        Node
        StickyNote
        SubnetIndirectInput


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_networkItemType


# Register networkItemType in _hou:
_hou.networkItemType_swigregister(networkItemType)
networkItemType.Connection = _hou.cvar.networkItemType_Connection
networkItemType.NetworkBox = _hou.cvar.networkItemType_NetworkBox
networkItemType.Node = _hou.cvar.networkItemType_Node
networkItemType.StickyNote = _hou.cvar.networkItemType_StickyNote
networkItemType.SubnetIndirectInput = _hou.cvar.networkItemType_SubnetIndirectInput
networkItemType.NetworkDot = _hou.cvar.networkItemType_NetworkDot


class colorItemType(object):
    r"""

    hou.colorItemType

    <Summary>

    <Description>

    VALUES


        NetworkBox
        StickyNote
        StickyNoteText


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_colorItemType


# Register colorItemType in _hou:
_hou.colorItemType_swigregister(colorItemType)
colorItemType.NetworkBox = _hou.cvar.colorItemType_NetworkBox
colorItemType.StickyNote = _hou.cvar.colorItemType_StickyNote
colorItemType.StickyNoteText = _hou.cvar.colorItemType_StickyNoteText


class geometryViewportType(object):
    r"""

    hou.geometryViewportType

    Enumeration of scene viewer viewport types.

    VALUES


        Perspective
        Top
        Bottom
        Front
        Back
        Right
        Left
        UV


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_geometryViewportType


# Register geometryViewportType in _hou:
_hou.geometryViewportType_swigregister(geometryViewportType)
geometryViewportType.Perspective = _hou.cvar.geometryViewportType_Perspective
geometryViewportType.Top = _hou.cvar.geometryViewportType_Top
geometryViewportType.Bottom = _hou.cvar.geometryViewportType_Bottom
geometryViewportType.Front = _hou.cvar.geometryViewportType_Front
geometryViewportType.Back = _hou.cvar.geometryViewportType_Back
geometryViewportType.Right = _hou.cvar.geometryViewportType_Right
geometryViewportType.Left = _hou.cvar.geometryViewportType_Left
geometryViewportType.UV = _hou.cvar.geometryViewportType_UV


class glShadingType(object):
    r"""

    hou.glShadingType

    Enum for viewport shading modes

    VALUES


        hou.glShadingType.WireBoundingBox
            Objects displayed as wireframe bounding boxes.

        hou.glShadingType.ShadedBoundingBox
            Objects displayed as solid bounding boxes.

        hou.glShadingType.Wire
            Geometry displayed as regular wireframe.

        hou.glShadingType.WireGhost
            Geometry displayed as wireframe with occluded wires dimmed.

        hou.glShadingType.HiddenLineGhost
            Geometry displayed as wireframe with constant filled polygons.

        hou.glShadingType.HiddenLineInvisible
            Geometry displayed as wireframe hidden occluded wires.

        hou.glShadingType.MatCap
            Geometry displayed with a Material Capture texture (MatCap)
            which replaces the usual lighting and shading.

        hou.glShadingType.MatCapWire
            Geometry displayed with a Material Capture texture (MatCap)
            which replaces the usual lighting and shading, with outlined
            polygons.

        hou.glShadingType.Flat
            Geometry displayed as lit, but with flat shaded polygons.

        hou.glShadingType.FlatWire
            Geometry displayed as lit, but with flat shaded, outlined
            polygons.

        hou.glShadingType.Smooth
            Geometry displayed as shaded and lit.

        hou.glShadingType.SmoothWire
            Geometry displayed as shaded and lit with outlined polygons.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_glShadingType


# Register glShadingType in _hou:
_hou.glShadingType_swigregister(glShadingType)
glShadingType.WireBoundingBox = _hou.cvar.glShadingType_WireBoundingBox
glShadingType.ShadedBoundingBox = _hou.cvar.glShadingType_ShadedBoundingBox
glShadingType.Wire = _hou.cvar.glShadingType_Wire
glShadingType.WireGhost = _hou.cvar.glShadingType_WireGhost
glShadingType.HiddenLineInvisible = _hou.cvar.glShadingType_HiddenLineInvisible
glShadingType.HiddenLineGhost = _hou.cvar.glShadingType_HiddenLineGhost
glShadingType.MatCap = _hou.cvar.glShadingType_MatCap
glShadingType.MatCapWire = _hou.cvar.glShadingType_MatCapWire
glShadingType.Flat = _hou.cvar.glShadingType_Flat
glShadingType.FlatWire = _hou.cvar.glShadingType_FlatWire
glShadingType.Smooth = _hou.cvar.glShadingType_Smooth
glShadingType.SmoothWire = _hou.cvar.glShadingType_SmoothWire


class viewportStereoMode(object):
    r"""

    hou.viewportStereoMode

    Stereoscopic viewport display modes

    The stereoscopic viewport display modes available when viewing through a
    stereo camera rig.

    VALUES


        hou.viewportStereoMode.Anaglyph
            Anaglyph display of left/right as red/cyan.

        hou.viewportStereoMode.HorizontalInterlace
            Interlace left and right on alternating scanlines. Only useful
            for 3D monitors which support this.

        hou.viewportStereoMode.HorizontalInterlaceReverse
            Interlace left and right on alternating scanlines, swapping
            which scanlines are used for left and right.

        hou.viewportStereoMode.QuadBufferGL
            Use OpenGL quad buffer stereo, generally only available on
            professional cards.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportStereoMode


# Register viewportStereoMode in _hou:
_hou.viewportStereoMode_swigregister(viewportStereoMode)
viewportStereoMode.Anaglyph = _hou.cvar.viewportStereoMode_Anaglyph
viewportStereoMode.HorizontalInterlace = (
    _hou.cvar.viewportStereoMode_HorizontalInterlace
)
viewportStereoMode.HorizontalInterlaceReverse = (
    _hou.cvar.viewportStereoMode_HorizontalInterlaceReverse
)
viewportStereoMode.QuadBufferGL = _hou.cvar.viewportStereoMode_QuadBufferGL


class viewportHomeClipMode(object):
    r"""

    hou.viewportHomeClipMode

    Automatic viewport clip plane adjustment during homing

    Homing the viewport can adjust the viewport's near and far clip planes
    to adapt to what is being homed onto, so that geometry is fully visible
    in the viewport.

    VALUES


        hou.viewportHomeClipMode.Neither
            No clip planes are adjusted.

        hou.viewportHomeClipMode.NearOnly
            Only the near clip plane is adjusted. Far is left as is.

        hou.viewportHomeClipMode.FarOnly
            Only the far clip plane is adjusted. Near is left as is.

        hou.viewportHomeClipMode.NearAndFar
            Both clip planes are adjusted.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportHomeClipMode


# Register viewportHomeClipMode in _hou:
_hou.viewportHomeClipMode_swigregister(viewportHomeClipMode)
viewportHomeClipMode.Neither = _hou.cvar.viewportHomeClipMode_Neither
viewportHomeClipMode.FarOnly = _hou.cvar.viewportHomeClipMode_FarOnly
viewportHomeClipMode.NearOnly = _hou.cvar.viewportHomeClipMode_NearOnly
viewportHomeClipMode.NearAndFar = _hou.cvar.viewportHomeClipMode_NearAndFar


class geometryViewportLayout(object):
    r"""

    hou.geometryViewportLayout

    Enumeration of viewport layouts.

    > # Get a reference to the 3D viewer pane tab
    > desktop = hou.ui.curDesktop()
    > viewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer)
    >
    > # Get the current layout
    > current_layout = viewer.viewportLayout()
    > # Change the layout to \"quad view\"
    > viewer.setViewportLayout(hou.geometryViewportLayout.)

    See the viewport methods on the SceneViewer object.

    VALUES


        DoubleSide

        DoubleStack

        Quad

        QuadBottomSplit

        QuadLeftSplit

        Single

        TripleBottomSplit

        TripleLeftSplit


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_geometryViewportLayout


# Register geometryViewportLayout in _hou:
_hou.geometryViewportLayout_swigregister(geometryViewportLayout)
geometryViewportLayout.Single = _hou.cvar.geometryViewportLayout_Single
geometryViewportLayout.Quad = _hou.cvar.geometryViewportLayout_Quad
geometryViewportLayout.DoubleStack = _hou.cvar.geometryViewportLayout_DoubleStack
geometryViewportLayout.DoubleSide = _hou.cvar.geometryViewportLayout_DoubleSide
geometryViewportLayout.TripleBottomSplit = (
    _hou.cvar.geometryViewportLayout_TripleBottomSplit
)
geometryViewportLayout.TripleLeftSplit = (
    _hou.cvar.geometryViewportLayout_TripleLeftSplit
)
geometryViewportLayout.QuadBottomSplit = (
    _hou.cvar.geometryViewportLayout_QuadBottomSplit
)
geometryViewportLayout.QuadLeftSplit = _hou.cvar.geometryViewportLayout_QuadLeftSplit


class snappingMode(object):
    r"""

    hou.snappingMode

    Enumeration of snapping modes.

    See hou.SceneViewer.snappingMode.

    VALUES


        Off
        Grid
        Prim
        Point
        Multi


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_snappingMode


# Register snappingMode in _hou:
_hou.snappingMode_swigregister(snappingMode)
snappingMode.Off = _hou.cvar.snappingMode_Off
snappingMode.Grid = _hou.cvar.snappingMode_Grid
snappingMode.Prim = _hou.cvar.snappingMode_Prim
snappingMode.Point = _hou.cvar.snappingMode_Point
snappingMode.Multi = _hou.cvar.snappingMode_Multi


class snapSelectionMode(object):
    r"""

    hou.snapSelectionMode

    Filter for primitive snapping in the LOPs viewer

    Restricts the primitives that can be snapped to by their selection
    status. This only affects the LOP viewer.

    VALUES


        hou.snapSelectionMode.SnapToAll
            Snapping is not restricted by selection; all primitives can be
            snapped.

        hou.snapSelectionMode.SnapToSelected
            Restrict snapping to only selected primitives. This can be
            useful to picking a pivot point on a primitive.

        hou.snapSelectionMode.SnapToNonSelected
            Restrict snapping to only non-selected primtives. This is
            normally used when transforming a selection, to avoid self-
            snapping.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_snapSelectionMode


# Register snapSelectionMode in _hou:
_hou.snapSelectionMode_swigregister(snapSelectionMode)
snapSelectionMode.SnapToAll = _hou.cvar.snapSelectionMode_SnapToAll
snapSelectionMode.SnapToSelected = _hou.cvar.snapSelectionMode_SnapToSelected
snapSelectionMode.SnapToNonSelected = _hou.cvar.snapSelectionMode_SnapToNonSelected


class selectionMode(object):
    r"""

    hou.selectionMode

    Enumeration of selection modes.

    See hou.SceneViewer.selectionMode.

    VALUES


        Object
        Geometry
        Dynamics


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_selectionMode


# Register selectionMode in _hou:
_hou.selectionMode_swigregister(selectionMode)
selectionMode.Object = _hou.cvar.selectionMode_Object
selectionMode.Geometry = _hou.cvar.selectionMode_Geometry
selectionMode.Dynamics = _hou.cvar.selectionMode_Dynamics


class pickStyle(object):
    r"""

    hou.pickStyle

    Enumeration of pick styles.

    VALUES


        Box
        Lasso
        Brush
        Laser


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_pickStyle


# Register pickStyle in _hou:
_hou.pickStyle_swigregister(pickStyle)
pickStyle.Box = _hou.cvar.pickStyle_Box
pickStyle.Lasso = _hou.cvar.pickStyle_Lasso
pickStyle.Brush = _hou.cvar.pickStyle_Brush
pickStyle.Laser = _hou.cvar.pickStyle_Laser


class pickModifier(object):
    r"""

    hou.pickModifier

    Enumeration of methods for modifying selections with new components.

    VALUES


        Add
        Toggle
        Remove
        Replace
        Intersect


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_pickModifier


# Register pickModifier in _hou:
_hou.pickModifier_swigregister(pickModifier)
pickModifier.Add = _hou.cvar.pickModifier_Add
pickModifier.Toggle = _hou.cvar.pickModifier_Toggle
pickModifier.Remove = _hou.cvar.pickModifier_Remove
pickModifier.Replace = _hou.cvar.pickModifier_Replace
pickModifier.Intersect = _hou.cvar.pickModifier_Intersect


class pickFacing(object):
    r"""

    hou.pickFacing

    Enumeration for describing the facing direction of pickable components.

    VALUES


        Front
        Back
        FrontAndBack


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_pickFacing


# Register pickFacing in _hou:
_hou.pickFacing_swigregister(pickFacing)
pickFacing.Front = _hou.cvar.pickFacing_Front
pickFacing.Back = _hou.cvar.pickFacing_Back
pickFacing.FrontAndBack = _hou.cvar.pickFacing_FrontAndBack


class displaySetType(object):
    r"""

    hou.displaySetType

    Enum of viewport geometry contexts.

    There are several contexts for controlling shading and marker display
    which allow geometries from different operators to be distinguished from
    one another.

    VALUES


        hou.displaySetType.SceneObject
            Objects which are displayed but not selected, when the scene is
            viewing objects.

        hou.displaySetType.SelectedObject
            Objects which are displayed and selected, when the scene is
            viewing objects.

        hou.displaySetType.GhostObject
            Objects which are not the currently edited object when Ghost
            other Objects display mode is active.

        hou.displaySetType.DisplayModel
            The currently displayed surface operater when editing an object.

        hou.displaySetType.CurrentModel
            The currently selected surface operater when editing an object.

        hou.displaySetType.TemplateModel
            Surface operaters that have their template flag set when editing
            an object.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_displaySetType


# Register displaySetType in _hou:
_hou.displaySetType_swigregister(displaySetType)
displaySetType.SceneObject = _hou.cvar.displaySetType_SceneObject
displaySetType.SelectedObject = _hou.cvar.displaySetType_SelectedObject
displaySetType.GhostObject = _hou.cvar.displaySetType_GhostObject
displaySetType.DisplayModel = _hou.cvar.displaySetType_DisplayModel
displaySetType.CurrentModel = _hou.cvar.displaySetType_CurrentModel
displaySetType.TemplateModel = _hou.cvar.displaySetType_TemplateModel


class topCookState(object):
    r"""

    hou.topCookState

    Enumeration of TOP Node cook states.

    VALUES


        Uncooked
            The node is uncooked. This occurs when it has no work items
            because it has never cooked before, or if it was dirtied.

        Cooking
            The node has work items that are currently cooking.

        Cooked
            All work items in the node are cooked.

        Failed
            One or more work items in the node has failed to cook.

        Warning
            One or more work items in the node have been canceled or issued
            a warning during the cook

        Waiting
            The node has no cooking work items, but may still generate new
            work from an input node.

        Incomplete
            The node has cooked work items, but one or more work items are
            in an uncooked state.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_topCookState


# Register topCookState in _hou:
_hou.topCookState_swigregister(topCookState)
topCookState.Uncooked = _hou.cvar.topCookState_Uncooked
topCookState.Cooking = _hou.cvar.topCookState_Cooking
topCookState.Cooked = _hou.cvar.topCookState_Cooked
topCookState.Failed = _hou.cvar.topCookState_Failed
topCookState.Warning = _hou.cvar.topCookState_Warning
topCookState.Waiting = _hou.cvar.topCookState_Waiting
topCookState.Incomplete = _hou.cvar.topCookState_Incomplete


class markerVisibility(object):
    r"""

    hou.markerVisibility

    Enum of visibility options for marker visualizers.

    VALUES


        hou.markerVisibility.Always
            Display the markers without restriction.

        hou.markerVisibility.Selected
            Only display the marker if its component is selected.

        hou.markerVisibility.AroundPointer
            Display markers around the mouse pointer in 3D space.

        hou.markerVisibility.UnderPointer
            Display markers under the mouse pointer in screen space.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_markerVisibility


# Register markerVisibility in _hou:
_hou.markerVisibility_swigregister(markerVisibility)
markerVisibility.Always = _hou.cvar.markerVisibility_Always
markerVisibility.Selected = _hou.cvar.markerVisibility_Selected
markerVisibility.AroundPointer = _hou.cvar.markerVisibility_AroundPointer
markerVisibility.UnderPointer = _hou.cvar.markerVisibility_UnderPointer


class viewportGuide(object):
    r"""

    hou.viewportGuide

    Viewport guides

    List of viewport guides that can be queried, enabled or disabled.

    VALUES


        hou.viewportGuide.CameraMask
            The mask which dims out areas outside the camera aspect ratio.

        hou.viewportGuide.CurrentGeometry
            Geometry from the current modelling operator (SOP)

        hou.viewportGuide.DisplayNodes
            Geometry from the currently displayed modelling operator (SOP)

        hou.viewportGuide.FieldGuide
        hou.viewportGuide.FillSelections
            Polygon selections are highlighted with a solid color rather
            than just an outline when in Wire-Over shading modes.

        hou.viewportGuide.FloatingGnomon
            Show the orientation axes in the lower left corner of the
            viewport.

        hou.viewportGuide.FollowSelection
            Show point or vertex markers when point or selection is active.

        hou.viewportGuide.GroupList
            Show the group list in the top right corner of the viewport.

        hou.viewportGuide.IKCriticalZone
            Show the critical zone for IK bones.

        hou.viewportGuide.NodeGuides
            Show any node guides that are available.

        hou.viewportGuide.NodeHandles
            Show any handles that are available.

        hou.viewportGuide.ObjectNames
            Show object names for visible objects.

        hou.viewportGuide.ObjectPaths
            Show full objects paths for visible objects. Object names must
            be displayed.

        hou.viewportGuide.ObjectSelection
            Show object selections.

        hou.viewportGuide.OriginGnomon
            Show the axes at the world origin.

        hou.viewportGuide.ParticleGnomon
            Show axes per particle.

        hou.viewportGuide.SafeArea
            Show the safe area overlay for broadcast.

        hou.viewportGuide.SelectableTemplates
            Show geometry from modelling operators with their selectable
            template flags set.

        hou.viewportGuide.ShowDrawTime
            Show the time to update and render the viewport.

        hou.viewportGuide.TemplateGeometry
            Show geometry from modelling operators with their template flags
            set.

        hou.viewportGuide.ViewPivot
            Show the camera pivot where tumbling will rotate about.

        hou.viewportGuide.XYPlane
            Show a grid along the XY plane.

        hou.viewportGuide.XZPlane
            Show a grid along the XZ plane.

        hou.viewportGuide.YZPlane
            Show a grid along the YZ plane.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportGuide


# Register viewportGuide in _hou:
_hou.viewportGuide_swigregister(viewportGuide)
viewportGuide.FloatingGnomon = _hou.cvar.viewportGuide_FloatingGnomon
viewportGuide.OriginGnomon = _hou.cvar.viewportGuide_OriginGnomon
viewportGuide.ParticleGnomon = _hou.cvar.viewportGuide_ParticleGnomon
viewportGuide.ViewPivot = _hou.cvar.viewportGuide_ViewPivot
viewportGuide.GroupList = _hou.cvar.viewportGuide_GroupList
viewportGuide.SafeArea = _hou.cvar.viewportGuide_SafeArea
viewportGuide.FieldGuide = _hou.cvar.viewportGuide_FieldGuide
viewportGuide.CameraMask = _hou.cvar.viewportGuide_CameraMask
viewportGuide.XZPlane = _hou.cvar.viewportGuide_XZPlane
viewportGuide.XYPlane = _hou.cvar.viewportGuide_XYPlane
viewportGuide.YZPlane = _hou.cvar.viewportGuide_YZPlane
viewportGuide.NodeGuides = _hou.cvar.viewportGuide_NodeGuides
viewportGuide.NodeHandles = _hou.cvar.viewportGuide_NodeHandles
viewportGuide.FollowSelection = _hou.cvar.viewportGuide_FollowSelection
viewportGuide.IKCriticalZone = _hou.cvar.viewportGuide_IKCriticalZone
viewportGuide.ObjectNames = _hou.cvar.viewportGuide_ObjectNames
viewportGuide.ObjectPaths = _hou.cvar.viewportGuide_ObjectPaths
viewportGuide.DisplayNodes = _hou.cvar.viewportGuide_DisplayNodes
viewportGuide.CurrentGeometry = _hou.cvar.viewportGuide_CurrentGeometry
viewportGuide.TemplateGeometry = _hou.cvar.viewportGuide_TemplateGeometry
viewportGuide.SelectableTemplates = _hou.cvar.viewportGuide_SelectableTemplates
viewportGuide.ShowDrawTime = _hou.cvar.viewportGuide_ShowDrawTime
viewportGuide.ObjectSelection = _hou.cvar.viewportGuide_ObjectSelection
viewportGuide.FillSelections = _hou.cvar.viewportGuide_FillSelections


class viewportGeometryInfo(object):
    r"""

    hou.viewportGeometryInfo

    Geometry information display state

    The state of the geometry information displayed in the lower right
    corner of the viewport. This information takes additional time to
    generate.

    VALUES


        hou.viewportGeometryInfo.Off
            Do not show geometry information.

        hou.viewportGeometryInfo.SelectedOnly
            Only show information when a selection is present.

        hou.viewportGeometryInfo.AlwaysOn
            Always show information on the displayed geometry.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportGeometryInfo


# Register viewportGeometryInfo in _hou:
_hou.viewportGeometryInfo_swigregister(viewportGeometryInfo)
viewportGeometryInfo.Off = _hou.cvar.viewportGeometryInfo_Off
viewportGeometryInfo.SelectedOnly = _hou.cvar.viewportGeometryInfo_SelectedOnly
viewportGeometryInfo.AlwaysOn = _hou.cvar.viewportGeometryInfo_AlwaysOn


class viewportDefaultMaterial(object):
    r"""

    hou.viewportDefaultMaterial

    The default material shader for the 3D viewer

    This enum is used by GeometryViewportSettings.setDefaultMaterialType()
    to select the GLSL shader used when no materials are assigned to
    geometry.

    VALUES


        hou.viewportDefaultMaterial.Simple
            An untextured material with variable roughness and color
            settings for diffuse, specular, emission, and ambient values.

        hou.viewportDefaultMaterial.MatCap
            A material that uses a MatCap texture (Material Capture) to
            define the lighting and shading of the surface rather than the
            lights in the scene.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportDefaultMaterial


# Register viewportDefaultMaterial in _hou:
_hou.viewportDefaultMaterial_swigregister(viewportDefaultMaterial)
viewportDefaultMaterial.Simple = _hou.cvar.viewportDefaultMaterial_Simple
viewportDefaultMaterial.MatCap = _hou.cvar.viewportDefaultMaterial_MatCap


class viewportHandleHighlight(object):
    r"""

    hou.viewportHandleHighlight

    Handle highlight size

    Highlight size when moving the mouse over a handle.

    VALUES


        hou.viewportHandleHighlight.Off
            Don't display any highlights.

        hou.viewportHandleHighlight.Small
            Show a half-width highlight.

        hou.viewportHandleHighlight.Normal
            Show a full highlight.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportHandleHighlight


# Register viewportHandleHighlight in _hou:
_hou.viewportHandleHighlight_swigregister(viewportHandleHighlight)
viewportHandleHighlight.Off = _hou.cvar.viewportHandleHighlight_Off
viewportHandleHighlight.Small = _hou.cvar.viewportHandleHighlight_Small
viewportHandleHighlight.Normal = _hou.cvar.viewportHandleHighlight_Normal


class viewportClosureSelection(object):
    r"""

    hou.viewportClosureSelection

    Viewport highlight of primitives with selected components

    When components of a primitive are selected (points, vertices, edges),
    the primitive can be highlighted as well to indicate which primitives
    will be affected by the current selection.

    VALUES


        hou.viewportClosureSelection.Hide
            Primitives are not highlighted.

        hou.viewportClosureSelection.HullPrimitives
            Only primitives whose points and edges reside on separate hull
            geometry will be highlighted when those are selected (NURBS
            surfaces, Bezier surfaces).

        hou.viewportClosureSelection.Show
            Highlight all primitives whose points, edges, or vertices belong
            to the current selection.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportClosureSelection


# Register viewportClosureSelection in _hou:
_hou.viewportClosureSelection_swigregister(viewportClosureSelection)
viewportClosureSelection.Hide = _hou.cvar.viewportClosureSelection_Hide
viewportClosureSelection.HullPrimitives = (
    _hou.cvar.viewportClosureSelection_HullPrimitives
)
viewportClosureSelection.Show = _hou.cvar.viewportClosureSelection_Show


class viewportGuideFont(object):
    r"""

    hou.viewportGuideFont

    Viewport font sizes for visualizer text

    Font sizes for displaying text-based visualizers.

    VALUES


        hou.viewportGuideFont.Tiny
            Tiny font.

        hou.viewportGuideFont.Small
            Small font.

        hou.viewportGuideFont.Medium
            The just right font.

        hou.viewportGuideFont.Large
            Largest font.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportGuideFont


# Register viewportGuideFont in _hou:
_hou.viewportGuideFont_swigregister(viewportGuideFont)
viewportGuideFont.Tiny = _hou.cvar.viewportGuideFont_Tiny
viewportGuideFont.Small = _hou.cvar.viewportGuideFont_Small
viewportGuideFont.Medium = _hou.cvar.viewportGuideFont_Medium
viewportGuideFont.Large = _hou.cvar.viewportGuideFont_Large


class viewportVolumeQuality(object):
    r"""

    hou.viewportVolumeQuality

    Display options for viewport volume rendering quality

    Volume display in the viewport can be an expensive drawing operation.
    The volume quality can be adjusted to provide better viewport
    performance or better volume quality.

    VALUES


        VeryLow
            Quick volume preview.

        Low
            Minor quality loss for performance.

        Normal
            Balanced quality/performance setting.

        High
            Jittered, high quality volume with more passes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportVolumeQuality


# Register viewportVolumeQuality in _hou:
_hou.viewportVolumeQuality_swigregister(viewportVolumeQuality)
viewportVolumeQuality.VeryLow = _hou.cvar.viewportVolumeQuality_VeryLow
viewportVolumeQuality.Low = _hou.cvar.viewportVolumeQuality_Low
viewportVolumeQuality.Normal = _hou.cvar.viewportVolumeQuality_Normal
viewportVolumeQuality.High = _hou.cvar.viewportVolumeQuality_High


class viewportVolumeBSplines(object):
    r"""

    hou.viewportVolumeBSplines

    Display options for viewport volume sampling quality

    When displaying fog volumes, the viewport can sample the underlying
    textures using either fast trilinear interpolation or slower (but
    smoother) b-spline interpolation. This enumeration contains the various
    sampling modes supported by the viewport.


    NOTE
        The equivalent setting in the viewport display options can be found
        in the Geometry tab and is labelled Volume Filtering.

    VALUES


        Off
            The viewport will never use higher-order volume interpolation.
            This is the fastest to draw, but low resolution volumes may
            appear blocky in the viewport.

        NonInteractive
            The viewport will use the higher-order interpolation when not
            interacting with the viewport. This mode falls back to linear
            interpolation while interacting with the viewport to speed up
            draws.

        On
            The viewport will always use higher-order volume interpolation.
            This is the slowest, highest quality option.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportVolumeBSplines


# Register viewportVolumeBSplines in _hou:
_hou.viewportVolumeBSplines_swigregister(viewportVolumeBSplines)
viewportVolumeBSplines.Off = _hou.cvar.viewportVolumeBSplines_Off
viewportVolumeBSplines.NonInteractive = _hou.cvar.viewportVolumeBSplines_NonInteractive
viewportVolumeBSplines.On = _hou.cvar.viewportVolumeBSplines_On


class viewportBGImageView(object):
    r"""

    hou.viewportBGImageView

    Background image view target for the viewport display options

    Selects a view target when choosing which background image to edit in
    GeometryViewportSettings.

    VALUES


        hou.viewportBGImageView.Perspective
            The 3D view not attached to a camera (No cam).

        hou.viewportBGImageView.Camera
            The 3D view looking through a camera.

        hou.viewportBGImageView.Top
            The orthographic top view.

        hou.viewportBGImageView.Front
            The orthographic front view.

        hou.viewportBGImageView.Right
            The orthographic right view.

        hou.viewportBGImageView.Bottom
            The orthographic bottom view.

        hou.viewportBGImageView.Back
            The orthographic back view.

        hou.viewportBGImageView.Left
            The orthographic left view.

        hou.viewportBGImageView.UV
            The UV texture viewport.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportBGImageView


# Register viewportBGImageView in _hou:
_hou.viewportBGImageView_swigregister(viewportBGImageView)
viewportBGImageView.Perspective = _hou.cvar.viewportBGImageView_Perspective
viewportBGImageView.Camera = _hou.cvar.viewportBGImageView_Camera
viewportBGImageView.Top = _hou.cvar.viewportBGImageView_Top
viewportBGImageView.Front = _hou.cvar.viewportBGImageView_Front
viewportBGImageView.Right = _hou.cvar.viewportBGImageView_Right
viewportBGImageView.Bottom = _hou.cvar.viewportBGImageView_Bottom
viewportBGImageView.Back = _hou.cvar.viewportBGImageView_Back
viewportBGImageView.Left = _hou.cvar.viewportBGImageView_Left
viewportBGImageView.UV = _hou.cvar.viewportBGImageView_UV


class viewportColorScheme(object):
    r"""

    hou.viewportColorScheme

    Viewport Color Schemes

    List of available color schemes for the viewport.

    VALUES


        hou.viewportColorScheme.Dark
            Solid black backaground.

        hou.viewportColorScheme.Grey
            Solid grey background.

        hou.viewportColorScheme.Light
            Light blue gradient background.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportColorScheme


# Register viewportColorScheme in _hou:
_hou.viewportColorScheme_swigregister(viewportColorScheme)
viewportColorScheme.Light = _hou.cvar.viewportColorScheme_Light
viewportColorScheme.Dark = _hou.cvar.viewportColorScheme_Dark
viewportColorScheme.Grey = _hou.cvar.viewportColorScheme_Grey


class viewportParticleDisplay(object):
    r"""

    hou.viewportParticleDisplay

    Viewport display option for particle display visualization.

    Specifies the visualization for particles and points in the viewport.

    VALUES


        Points
            Fixed size points in screen space.

        Lines
            Points with streaks indicating velocity.

        Pixels
            Single pixel particle (fixed size)

        Discs
            Circular disc, variable world size.

        Spheres
            Spheres which have material assignments and lighting, variable
            world size.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportParticleDisplay


# Register viewportParticleDisplay in _hou:
_hou.viewportParticleDisplay_swigregister(viewportParticleDisplay)
viewportParticleDisplay.Points = _hou.cvar.viewportParticleDisplay_Points
viewportParticleDisplay.Pixels = _hou.cvar.viewportParticleDisplay_Pixels
viewportParticleDisplay.Lines = _hou.cvar.viewportParticleDisplay_Lines
viewportParticleDisplay.Discs = _hou.cvar.viewportParticleDisplay_Discs
viewportParticleDisplay.Spheres = _hou.cvar.viewportParticleDisplay_Spheres


class viewportStandInGeometry(object):
    r"""

    hou.viewportStandInGeometry

    Replacement geometry for instances culled in the viewport.

    When using point instancing, instances can be culled because of the
    Point Instancing Percent, or the Instancing Limit display options.
    Culled instances can be replaced by a marker or bounding box, or
    completely hidden.

    VALUES


        DisplayOff
            Don't show anything for culled instances.

        LocationMarker
            Show a point marker at the local space origin of the instance.

        BoundingBox
            Show the bounding box of the culled instance.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportStandInGeometry


# Register viewportStandInGeometry in _hou:
_hou.viewportStandInGeometry_swigregister(viewportStandInGeometry)
viewportStandInGeometry.DisplayOff = _hou.cvar.viewportStandInGeometry_DisplayOff
viewportStandInGeometry.LocationMarker = (
    _hou.cvar.viewportStandInGeometry_LocationMarker
)
viewportStandInGeometry.BoundingBox = _hou.cvar.viewportStandInGeometry_BoundingBox


class viewportLighting(object):
    r"""

    hou.viewportLighting

    Lighting modes for the viewport

    The viewport renderer supports several global lighting modes, from no
    lighting whatsoever to full lighting with shadows.

    VALUES


        hou.viewportLighting.Off
            No lighting, constant shaded.

        hou.viewportLighting.Headlight
            Basic lighting from a single directional light defined in the
            display options.

        hou.viewportLighting.Normal
            Good quality lighting from up to 10 basic lights (area lights
            modeled as point lights, limited environment lights).

        hou.viewportLighting.HighQuality
            High quality lighting from an unlimited number of lights
            including area, geometry, environment and ambient occlusion.

        hou.viewportLighting.HighQualityWithShadows
            High quality lighting with shadows.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportLighting


# Register viewportLighting in _hou:
_hou.viewportLighting_swigregister(viewportLighting)
viewportLighting.Off = _hou.cvar.viewportLighting_Off
viewportLighting.Headlight = _hou.cvar.viewportLighting_Headlight
viewportLighting.Normal = _hou.cvar.viewportLighting_Normal
viewportLighting.HighQuality = _hou.cvar.viewportLighting_HighQuality
viewportLighting.HighQualityWithShadows = (
    _hou.cvar.viewportLighting_HighQualityWithShadows
)


class viewportTransparency(object):
    r"""

    hou.viewportTransparency

    Transparency rendering quality for the viewport

    Quality levels for rendering objects with transparency in the viewport.

    VALUES


        hou.viewportTransparency.Cutout
            Fast test to render the transparent pixel as opaque (>0) or to
            discard it (0). This can be used for texture cards such as
            leaves. This doesn't require an additional pass for
            transparency.

        hou.viewportTransparency.Low
            Render transparent pixels in a separate pass. Only the front-
            most transparent pixel is rendered.

        hou.viewportTransparency.Medium
            Render transparent pixels in an Order-Independent buffer of 8
            samples, which is then sorted and composited together to do
            multi-layer transparency for up to 8 layers of overlapping
            transparency.

        hou.viewportTransparency.High
            Render transparent pixels in an Order-Independent buffer of 16
            samples, which is then sorted and composited together to do
            multi-layer transparency for up to 16 layers of overlapping
            transparency.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportTransparency


# Register viewportTransparency in _hou:
_hou.viewportTransparency_swigregister(viewportTransparency)
viewportTransparency.Cutout = _hou.cvar.viewportTransparency_Cutout
viewportTransparency.Low = _hou.cvar.viewportTransparency_Low
viewportTransparency.Medium = _hou.cvar.viewportTransparency_Medium
viewportTransparency.High = _hou.cvar.viewportTransparency_High


class viewportShadowQuality(object):
    r"""

    hou.viewportShadowQuality

    The quality of shadows produced in the viewport

    The viewport renderer can do various amounts of shadowmap sampling to
    produce a higher quality result.

    VALUES


        hou.viewportShadowQuality.Point
            Area lights are treated as point lights when generating and
            sampling shadow maps. This is the fastest option.

        hou.viewportShadowQuality.PointAA
            Do some antialiasing of shadow edges. Treat area lights as point
            lights when generating and sampling shadow maps.

        hou.viewportShadowQuality.Area
            Area lights generate multiple shadow maps which are sampled to
            generate an approximation of a blurred shadow from an area
            source.

        hou.viewportShadowQuality.AreaAA
            Area lights generate multiple maps and antialias the shadow
            lookups.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportShadowQuality


# Register viewportShadowQuality in _hou:
_hou.viewportShadowQuality_swigregister(viewportShadowQuality)
viewportShadowQuality.Point = _hou.cvar.viewportShadowQuality_Point
viewportShadowQuality.PointAA = _hou.cvar.viewportShadowQuality_PointAA
viewportShadowQuality.Area = _hou.cvar.viewportShadowQuality_Area
viewportShadowQuality.AreaAA = _hou.cvar.viewportShadowQuality_AreaAA


class viewportDOFBokeh(object):
    r"""

    hou.viewportDOFBokeh

    Viewport Depth of Field Bokeh Shape

    Defines the shape of the depth of field bokeh in the viewport.

    VALUES


        hou.viewportDOFBokeh.NoBokeh
            No extra bokeh effect.

        hou.viewportDOFBokeh.Circular
            Circular or oval bokeh.

        hou.viewportDOFBokeh.Texture
            Shape defined by a texture (image file or COP).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportDOFBokeh


# Register viewportDOFBokeh in _hou:
_hou.viewportDOFBokeh_swigregister(viewportDOFBokeh)
viewportDOFBokeh.NoBokeh = _hou.cvar.viewportDOFBokeh_NoBokeh
viewportDOFBokeh.Circular = _hou.cvar.viewportDOFBokeh_Circular
viewportDOFBokeh.Texture = _hou.cvar.viewportDOFBokeh_Texture


class viewportFogHeightMode(object):
    r"""

    hou.viewportFogHeightMode

    Viewport fog layer modes

    Defines the types of fog layering available for viewport fog.

    VALUES


        hou.viewportFogHeightMode.Off
            No layering; fog is the same density regardless of height.

        hou.viewportFogHeightMode.Above
            Fog exists only above a given height.

        hou.viewportFogHeightMode.Below
            Fog exists only below a given height.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportFogHeightMode


# Register viewportFogHeightMode in _hou:
_hou.viewportFogHeightMode_swigregister(viewportFogHeightMode)
viewportFogHeightMode.Off = _hou.cvar.viewportFogHeightMode_Off
viewportFogHeightMode.Above = _hou.cvar.viewportFogHeightMode_Above
viewportFogHeightMode.Below = _hou.cvar.viewportFogHeightMode_Below


class viewportFogQuality(object):
    r"""

    hou.viewportFogQuality

    Viewport volume fog quality

    Defines the quality settings for volumetric fog in the viewport.

    VALUES


        hou.viewportFogQuality.Low
            Uses a small volume for fog lighting. Fast but low quality.

        hou.viewportFogQuality.Medium
            Uses a bigger volume for fog lighting. Balanced between quality
            and speed.

        hou.viewportFogQuality.High
            Uses a large volume for fog lighting. Slow but good quality.

        hou.viewportFogQuality.VeryHigh
            Uses a large volume for fog lighting. Slowest but best quality.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportFogQuality


# Register viewportFogQuality in _hou:
_hou.viewportFogQuality_swigregister(viewportFogQuality)
viewportFogQuality.Low = _hou.cvar.viewportFogQuality_Low
viewportFogQuality.Medium = _hou.cvar.viewportFogQuality_Medium
viewportFogQuality.High = _hou.cvar.viewportFogQuality_High
viewportFogQuality.VeryHigh = _hou.cvar.viewportFogQuality_VeryHigh


class viewportMaterialUpdate(object):
    r"""

    hou.viewportMaterialUpdate

    Enum for the update frequency of viewport material assignments

    When material assignments are re-evaluated for a displayed object.

    VALUES


        hou.viewportMaterialUpdate.Always
            Update assignments whenever needeed.

        hou.viewportMaterialUpdate.Manual
            Only update assignments when Update Materials is pressed.

        hou.viewportMaterialUpdate.OffForPlayback
            Update assignments whenever needed, but not during playback.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportMaterialUpdate


# Register viewportMaterialUpdate in _hou:
_hou.viewportMaterialUpdate_swigregister(viewportMaterialUpdate)
viewportMaterialUpdate.Always = _hou.cvar.viewportMaterialUpdate_Always
viewportMaterialUpdate.OffForPlayback = _hou.cvar.viewportMaterialUpdate_OffForPlayback
viewportMaterialUpdate.Manual = _hou.cvar.viewportMaterialUpdate_Manual


class viewportAgentBoneDeform(object):
    r"""

    hou.viewportAgentBoneDeform

    Enum for deforming agent quality

    Defines the quality vs. performance tradeoff for deforming agent
    geometry.

    VALUES


        hou.viewportAgentBoneDeform.Always
            Only use 1 bone to deform on all agent instances (the one with
            the most influence).

        hou.viewportAgentBoneDeform.Disabled
            Use up to 4 bones to deform the highest LOD agent instances, and
            1 bone on all the reduced LOD instances.

        hou.viewportAgentBoneDeform.ReducedLOD
            Use up to 4 bones to deform on all agent instances.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportAgentBoneDeform


# Register viewportAgentBoneDeform in _hou:
_hou.viewportAgentBoneDeform_swigregister(viewportAgentBoneDeform)
viewportAgentBoneDeform.Disabled = _hou.cvar.viewportAgentBoneDeform_Disabled
viewportAgentBoneDeform.ReducedLOD = _hou.cvar.viewportAgentBoneDeform_ReducedLOD
viewportAgentBoneDeform.Always = _hou.cvar.viewportAgentBoneDeform_Always


class viewportAgentWireframe(object):
    r"""

    hou.viewportAgentWireframe

    Enum for agent wireframe mode display

    The look of agents in wireframe mode.

    VALUES


        hou.viewportAgentWireframe.Bone
            Agents are rendered as bone-based skeletons.

        hou.viewportAgentWireframe.Line
            Agents are rendered as line-based skeletons.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportAgentWireframe


# Register viewportAgentWireframe in _hou:
_hou.viewportAgentWireframe_swigregister(viewportAgentWireframe)
viewportAgentWireframe.Line = _hou.cvar.viewportAgentWireframe_Line
viewportAgentWireframe.Bone = _hou.cvar.viewportAgentWireframe_Bone


class viewportPackedBoxMode(object):
    r"""

    hou.viewportPackedBoxMode

    Enum for the culled packed geometry display mode.

    Defines how culled packed primitives are displayed in the viewport.

    VALUES


        hou.viewportPackedBoxMode.NoDisplay
            Culled packed primitives are not displayed at all.

        hou.viewportPackedBoxMode.Wireframe
            A wireframe bounding box replaces the packed primitive.

        hou.viewportPackedBoxMode.Shaded
            A shaded bounding box replaces the packed primitive.

        hou.viewportPackedBoxMode.CurrentShadingMode
            A bounding box replaces the packed primitive, drawn wireframe in
            wireframe shading modes and shaded otherwise.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportPackedBoxMode


# Register viewportPackedBoxMode in _hou:
_hou.viewportPackedBoxMode_swigregister(viewportPackedBoxMode)
viewportPackedBoxMode.NoDisplay = _hou.cvar.viewportPackedBoxMode_NoDisplay
viewportPackedBoxMode.Wireframe = _hou.cvar.viewportPackedBoxMode_Wireframe
viewportPackedBoxMode.Shaded = _hou.cvar.viewportPackedBoxMode_Shaded
viewportPackedBoxMode.CurrentShadingMode = (
    _hou.cvar.viewportPackedBoxMode_CurrentShadingMode
)


class viewportGridRuler(object):
    r"""

    hou.viewportGridRuler

    Enum for grid numbering on viewport grids.

    Specifies where the grid numbering occurs on viewport grids.

    VALUES


        hou.viewportGridRuler.Hide
            No grid numbers are displayed.

        hou.viewportGridRuler.MainAxis
            Numbers appear along the max axes at grid line intersections.

        hou.viewportGridRuler.GridPoints
            Numbers appear at grid line intersections.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportGridRuler


# Register viewportGridRuler in _hou:
_hou.viewportGridRuler_swigregister(viewportGridRuler)
viewportGridRuler.Hide = _hou.cvar.viewportGridRuler_Hide
viewportGridRuler.MainAxis = _hou.cvar.viewportGridRuler_MainAxis
viewportGridRuler.GridPoints = _hou.cvar.viewportGridRuler_GridPoints


class viewportTextureDepth(object):
    r"""

    hou.viewportTextureDepth

    Enum for the viewport texture bit depth limit

    Specifies the maximum bit depth that can be used for textures in the
    viewport.

    VALUES


        hou.viewportTextureDepth.Compressed8
            Compressed, 8b SDR texture format. Smallest memory use.

        hou.viewportTextureDepth.Fixed8
            8b SDR texture format. Good balance between memory and quality.

        hou.viewportTextureDepth.FullHDR
            16b HDR texture format. Excellent dynamic range, but more memory
            use and slower texturing performance.

        hou.viewportTextureDepth.HDR16
            32b HDR texture format. Extreme dynamic range, but very high
            memory use and slow texturing performance. Use with care.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportTextureDepth


# Register viewportTextureDepth in _hou:
_hou.viewportTextureDepth_swigregister(viewportTextureDepth)
viewportTextureDepth.FullHDR = _hou.cvar.viewportTextureDepth_FullHDR
viewportTextureDepth.HDR16 = _hou.cvar.viewportTextureDepth_HDR16
viewportTextureDepth.Fixed8 = _hou.cvar.viewportTextureDepth_Fixed8
viewportTextureDepth.Compressed8 = _hou.cvar.viewportTextureDepth_Compressed8


class boundaryDisplay(object):
    r"""

    hou.boundaryDisplay

    Enum for viewport boundary overlay.

    Boundaries are used to show the edges of polygon mesh islands, for
    either position or UV coordinates.

    VALUES


        hou.boundaryDisplay.Off
            The boundary is disabled.

        hou.boundaryDisplay.View3D
            The boundary is shown in 3D viewports only.

        hou.boundaryDisplay.ViewUV
            The boundary is shown in UV viewports only.

        hou.boundaryDisplay.On
            The boundary is shown in all viewports.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_boundaryDisplay


# Register boundaryDisplay in _hou:
_hou.boundaryDisplay_swigregister(boundaryDisplay)
boundaryDisplay.Off = _hou.cvar.boundaryDisplay_Off
boundaryDisplay.View3D = _hou.cvar.boundaryDisplay_View3D
boundaryDisplay.ViewUV = _hou.cvar.boundaryDisplay_ViewUV
boundaryDisplay.On = _hou.cvar.boundaryDisplay_On


class flipbookObjectType(object):
    r"""

    hou.flipbookObjectType

    Enum values for setting the flipbook's visible object types.

    Used by FlipbookSettings.visibleTypes() to set the visible object types
    when doing a flipbook.

    VALUES


        hou.flipbookObjectType.Visible
            All object types that are currently visible will be rendered.

        hou.flipbookObjectType.GeoOnly
            Only geometry objects will be rendered, which excludes bone,
            muscle, null, camera, light, and blend objects.

        hou.flipbookObjectType.GeoExcluded
            All object types other than Geometry that are currently visible
            will be rendered.

        hou.flipbookObjectType.AllObjects
            All object types will be rendered, even if their type is not
            currently visible.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_flipbookObjectType


# Register flipbookObjectType in _hou:
_hou.flipbookObjectType_swigregister(flipbookObjectType)
flipbookObjectType.Visible = _hou.cvar.flipbookObjectType_Visible
flipbookObjectType.GeoOnly = _hou.cvar.flipbookObjectType_GeoOnly
flipbookObjectType.GeoExcluded = _hou.cvar.flipbookObjectType_GeoExcluded
flipbookObjectType.AllObjects = _hou.cvar.flipbookObjectType_AllObjects


class groupListType(object):
    r"""

    hou.groupListType

    Enumeration of group list types.

    VALUES


        Points
        Vertices
        Edges
        Breakpoints
        Primitives
        MatchPickType


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_groupListType


# Register groupListType in _hou:
_hou.groupListType_swigregister(groupListType)
groupListType.Points = _hou.cvar.groupListType_Points
groupListType.Vertices = _hou.cvar.groupListType_Vertices
groupListType.Edges = _hou.cvar.groupListType_Edges
groupListType.Breakpoints = _hou.cvar.groupListType_Breakpoints
groupListType.Primitives = _hou.cvar.groupListType_Primitives
groupListType.MatchPickType = _hou.cvar.groupListType_MatchPickType


class geometryType(object):
    r"""

    hou.geometryType

    Enumeration of geometry component types.

    VALUES


        Points
        Vertices
        Edges
        Breakpoints
        Primitives


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_geometryType


# Register geometryType in _hou:
_hou.geometryType_swigregister(geometryType)
geometryType.Points = _hou.cvar.geometryType_Points
geometryType.Vertices = _hou.cvar.geometryType_Vertices
geometryType.Edges = _hou.cvar.geometryType_Edges
geometryType.Breakpoints = _hou.cvar.geometryType_Breakpoints
geometryType.Primitives = _hou.cvar.geometryType_Primitives


class connectivityType(object):
    r"""

    hou.connectivityType

    Enumeration of connectivity types.

    VALUES


        NoConnectivity
        Texture
        Position


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_connectivityType


# Register connectivityType in _hou:
_hou.connectivityType_swigregister(connectivityType)
connectivityType.NoConnectivity = _hou.cvar.connectivityType_NoConnectivity
connectivityType.Texture = _hou.cvar.connectivityType_Texture
connectivityType.Position = _hou.cvar.connectivityType_Position


class severityType(object):
    r"""

    hou.severityType

    Enumeration of dialog message severities.

    VALUES


        Message
        ImportantMessage
        Warning
        Error
        Fatal


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_severityType


# Register severityType in _hou:
_hou.severityType_swigregister(severityType)
severityType.Message = _hou.cvar.severityType_Message
severityType.ImportantMessage = _hou.cvar.severityType_ImportantMessage
severityType.Warning = _hou.cvar.severityType_Warning
severityType.Error = _hou.cvar.severityType_Error
severityType.Fatal = _hou.cvar.severityType_Fatal


class confirmType(object):
    r"""

    hou.confirmType

    Enumeration of confirmation dialog suppression options.

    VALUES


        OverwriteFile
        UnlockNode
        DeleteSpareParameters
        DeleteWithoutReferences
        NestedChannelGroups
        SiblingChannelGroups
        DeleteShelfElement
        DeleteGalleryEntry
        InactiveSnapMode
        BackgroundSave
        LockMultiNode
        SaveEmbeddedDefinitions
        TopCookSave
        TopDeleteResults
        TopDeleteTempDir
        TopHotKeyCancelCook
        TopViewResults
        TopTerminateRemoteSession


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_confirmType


# Register confirmType in _hou:
_hou.confirmType_swigregister(confirmType)
confirmType.OverwriteFile = _hou.cvar.confirmType_OverwriteFile
confirmType.UnlockNode = _hou.cvar.confirmType_UnlockNode
confirmType.DeleteSpareParameters = _hou.cvar.confirmType_DeleteSpareParameters
confirmType.DeleteWithoutReferences = _hou.cvar.confirmType_DeleteWithoutReferences
confirmType.NestedChannelGroups = _hou.cvar.confirmType_NestedChannelGroups
confirmType.SiblingChannelGroups = _hou.cvar.confirmType_SiblingChannelGroups
confirmType.DeleteShelfElement = _hou.cvar.confirmType_DeleteShelfElement
confirmType.DeleteGalleryEntry = _hou.cvar.confirmType_DeleteGalleryEntry
confirmType.InactiveSnapMode = _hou.cvar.confirmType_InactiveSnapMode
confirmType.BackgroundSave = _hou.cvar.confirmType_BackgroundSave
confirmType.LockMultiNode = _hou.cvar.confirmType_LockMultiNode
confirmType.SaveEmbeddedDefinitions = _hou.cvar.confirmType_SaveEmbeddedDefinitions
confirmType.TopCookSave = _hou.cvar.confirmType_TopCookSave
confirmType.TopDeleteResults = _hou.cvar.confirmType_TopDeleteResults
confirmType.TopDeleteTempDir = _hou.cvar.confirmType_TopDeleteTempDir
confirmType.TopHotKeyCancelCook = _hou.cvar.confirmType_TopHotKeyCancelCook
confirmType.TopViewResults = _hou.cvar.confirmType_TopViewResults
confirmType.TopTerminateRemoteSession = _hou.cvar.confirmType_TopTerminateRemoteSession


class positionType(object):
    r"""

    hou.positionType

    Enumeration of spaces.

    VALUES


        WorldSpace
        ViewportXY
        ViewportUV


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_positionType


# Register positionType in _hou:
_hou.positionType_swigregister(positionType)
positionType.WorldSpace = _hou.cvar.positionType_WorldSpace
positionType.ViewportXY = _hou.cvar.positionType_ViewportXY
positionType.ViewportUV = _hou.cvar.positionType_ViewportUV


class componentLoopType(object):
    r"""

    hou.componentLoopType

    Enumeration of component loop types.

    VALUES


        Partial
            A partial loop connects the components provided in a path with
            each input component acting as a way-point on the path. The loop
            will always start with the first provided component and end with
            the last.

        Extended
            An extended loop is always created from just two components (or
            possibly one edge component). It finds a path between these two
            components, then extends that path at both ends. It extends each
            direction until it either hits a boundary in the geometry, or
            finds its way back to the existing path. Often the resulting
            path will neither start with the start component or end with the
            end component.

        Closed
            A closed loop is always created from just two components (or
            possibly one edge component). It always tries to find a path the
            goes from the starting component, passes through the end
            component, and then continues on looking for a path back to the
            starting component. The paths returned will generally both start
            and end with the starting component.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_componentLoopType


# Register componentLoopType in _hou:
_hou.componentLoopType_swigregister(componentLoopType)
componentLoopType.Partial = _hou.cvar.componentLoopType_Partial
componentLoopType.Extended = _hou.cvar.componentLoopType_Extended
componentLoopType.Closed = _hou.cvar.componentLoopType_Closed


class flipbookAntialias(object):
    r"""

    hou.flipbookAntialias

    Enum values for flipbook antialiasing settings.

    See hou.FlipbookSettings.antialias.

    VALUES


        UseViewportSetting
            Use the current viewport's antialiasing setting.

        Off
            No antialiasing.

        Fast
            Fast 2-sample antialiasing.

        Good
            4-sample antialiasing.

        HighQuality
            High-quality 8-sample antialiasing.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_flipbookAntialias


# Register flipbookAntialias in _hou:
_hou.flipbookAntialias_swigregister(flipbookAntialias)
flipbookAntialias.UseViewportSetting = _hou.cvar.flipbookAntialias_UseViewportSetting
flipbookAntialias.Off = _hou.cvar.flipbookAntialias_Off
flipbookAntialias.Fast = _hou.cvar.flipbookAntialias_Fast
flipbookAntialias.Good = _hou.cvar.flipbookAntialias_Good
flipbookAntialias.HighQuality = _hou.cvar.flipbookAntialias_HighQuality


class flipbookMotionBlurBias(object):
    r"""

    hou.flipbookMotionBlurBias

    Enum values used to specify the motion blur subframe range.

    See hou.FlipbookSettings.motionBlurFrameRange.

    VALUES


        Centered
            Subframe range is centered around the currently rendering frame.

        Forward
            Subframe range begins at the currently rendering frame.

        Previous
            Subframe range ends at the currently rendering frame.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_flipbookMotionBlurBias


# Register flipbookMotionBlurBias in _hou:
_hou.flipbookMotionBlurBias_swigregister(flipbookMotionBlurBias)
flipbookMotionBlurBias.Previous = _hou.cvar.flipbookMotionBlurBias_Previous
flipbookMotionBlurBias.Centered = _hou.cvar.flipbookMotionBlurBias_Centered
flipbookMotionBlurBias.Forward = _hou.cvar.flipbookMotionBlurBias_Forward


class parameterInterfaceTabType(object):
    r"""

    hou.parameterInterfaceTabType

    Enum values for selecting a specific parameter source tab in the
    parameter interface dialog.

    See hou.ui.openParameterInterfaceDialog.

    VALUES


        ParameterTypes
            The tab that provides a flat list of all available parameter
            types.

        RenderProperties
            The Render Properties tab, containing options parameters for
            controlling object rendering.

        NodeProperties
            The Node Properties tab, which contains definitions for spare
            parameters commonly used on specific node types.

        NodeParameters
            The Node Parameters tab, which displays a tree view of the
            current hip file, and all parameters on all existing nodes.

        UsdProperties
            The USD Properties tab which lists the current USD stage, all
            concrete USD schemas, and custom properties for every supported
            USD property data type.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parameterInterfaceTabType


# Register parameterInterfaceTabType in _hou:
_hou.parameterInterfaceTabType_swigregister(parameterInterfaceTabType)
parameterInterfaceTabType.ParameterTypes = (
    _hou.cvar.parameterInterfaceTabType_ParameterTypes
)
parameterInterfaceTabType.RenderProperties = (
    _hou.cvar.parameterInterfaceTabType_RenderProperties
)
parameterInterfaceTabType.NodeProperties = (
    _hou.cvar.parameterInterfaceTabType_NodeProperties
)
parameterInterfaceTabType.NodeParameters = (
    _hou.cvar.parameterInterfaceTabType_NodeParameters
)
parameterInterfaceTabType.UsdProperties = (
    _hou.cvar.parameterInterfaceTabType_UsdProperties
)


class shaderType(object):
    r"""

    hou.shaderType

    Enumeration of SHOP shader types.

    Each SHOP type defines a particular type of shader. For example, it
    might be a surface shader or a displacement shader. This enumeration
    contains all the possible shader types.

    Use hou.ShopNodeType.shaderType to determine what type of shader a
    particular SHOP type is.

    VALUES


        Invalid
        Surface
        SurfaceShadow
        Displacement
        Geometry
        Interior
        Light
        LightShadow
        Atmosphere
        Lens
        Output
        Background
        Photon
        Image3D
        BSDF
        CVEX
        Mutable
        Properties
        Material
        VopMaterial
        ShaderClass


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_shaderType


# Register shaderType in _hou:
_hou.shaderType_swigregister(shaderType)
shaderType.Surface = _hou.cvar.shaderType_Surface
shaderType.SurfaceShadow = _hou.cvar.shaderType_SurfaceShadow
shaderType.Displacement = _hou.cvar.shaderType_Displacement
shaderType.Geometry = _hou.cvar.shaderType_Geometry
shaderType.Interior = _hou.cvar.shaderType_Interior
shaderType.Light = _hou.cvar.shaderType_Light
shaderType.LightShadow = _hou.cvar.shaderType_LightShadow
shaderType.Atmosphere = _hou.cvar.shaderType_Atmosphere
shaderType.Lens = _hou.cvar.shaderType_Lens
shaderType.Output = _hou.cvar.shaderType_Output
shaderType.Background = _hou.cvar.shaderType_Background
shaderType.Photon = _hou.cvar.shaderType_Photon
shaderType.Image3D = _hou.cvar.shaderType_Image3D
shaderType.CVex = _hou.cvar.shaderType_CVex
shaderType.CoShader = _hou.cvar.shaderType_CoShader
shaderType.Mutable = _hou.cvar.shaderType_Mutable
shaderType.Properties = _hou.cvar.shaderType_Properties
shaderType.Material = _hou.cvar.shaderType_Material
shaderType.VopMaterial = _hou.cvar.shaderType_VopMaterial
shaderType.ShaderClass = _hou.cvar.shaderType_ShaderClass
shaderType.StructDef = _hou.cvar.shaderType_StructDef
shaderType.CoShaderArray = _hou.cvar.shaderType_CoShaderArray
shaderType.Integrator = _hou.cvar.shaderType_Integrator
shaderType.Generic = _hou.cvar.shaderType_Generic
shaderType.BSDF = _hou.cvar.shaderType_BSDF
shaderType.LightFilter = _hou.cvar.shaderType_LightFilter
shaderType.Invalid = _hou.cvar.shaderType_Invalid


class rampBasis(object):
    r"""

    hou.rampBasis

    Enumeration of ramp interpolation types.

    These interpolation types specify how Houdini interpolates between
    keyframed values in a hou.Ramp. See hou.Ramp.basis and hou.Ramp.__init__
    for more information about how to get and set ramp interpolation types.

    VALUES


        Linear
            Does a linear (straight line) interpolation between keys.

        Constant
            Holds the value constant until the next key.

        CatmullRom
            Interpolates smoothly between the keys. See Catmull-Rom_spline.

        MonotoneCubic
            Another smooth interpolation that ensures that there is no
            overshoot. For example, if a key's value is smaller than the
            values in the adjacent keys, this type ensures that the
            interpolated value is never less than the key's value.

        Bezier
            Cubic Bezier curve that interpolates every third control point
            and uses the other points to shape the curve. See Bezier curve.

        BSpline
            Cubic curve where the control points influence the shape of the
            curve locally (that is, they influence only a section of the
            curve). See B-Spline.

        Hermite
            Cubic Hermite curve that interpolates the odd control points,
            while even control points control the tangent at the previous
            interpolation point. See Hermite spline.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_rampBasis


# Register rampBasis in _hou:
_hou.rampBasis_swigregister(rampBasis)
rampBasis.Constant = _hou.cvar.rampBasis_Constant
rampBasis.Linear = _hou.cvar.rampBasis_Linear
rampBasis.CatmullRom = _hou.cvar.rampBasis_CatmullRom
rampBasis.MonotoneCubic = _hou.cvar.rampBasis_MonotoneCubic
rampBasis.Bezier = _hou.cvar.rampBasis_Bezier
rampBasis.BSpline = _hou.cvar.rampBasis_BSpline
rampBasis.Hermite = _hou.cvar.rampBasis_Hermite


class rampParmType(object):
    r"""

    hou.rampParmType

    Enumeration of ramp types.

    VALUES


        Color
        Float

    :

      * hou.RampParmTemplate


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_rampParmType


# Register rampParmType in _hou:
_hou.rampParmType_swigregister(rampParmType)
rampParmType.Color = _hou.cvar.rampParmType_Color
rampParmType.Float = _hou.cvar.rampParmType_Float


class colorType(object):
    r"""

    hou.colorType

    Enumeration of color spaces.

    VALUES


        RGB
            The red green blue color model.

        HSV
            The hue saturation value color model.

        HSL
            The hue saturation lightness color model.

        LAB
            The CIE L* a* b* color space model.

        XYZ
            The CIE XYZ color space model.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_colorType


# Register colorType in _hou:
_hou.colorType_swigregister(colorType)
colorType.HSL = _hou.cvar.colorType_HSL
colorType.HSV = _hou.cvar.colorType_HSV
colorType.RGB = _hou.cvar.colorType_RGB
colorType.XYZ = _hou.cvar.colorType_XYZ
colorType.LAB = _hou.cvar.colorType_LAB
colorType.TMI = _hou.cvar.colorType_TMI


class nodeTypeSource(object):
    r"""

    hou.nodeTypeSource

    Enumeration of node type sources.

    VALUES


        Internal
        CompiledCode
        VexCode
        RslCode
        Subnet


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_nodeTypeSource


# Register nodeTypeSource in _hou:
_hou.nodeTypeSource_swigregister(nodeTypeSource)
nodeTypeSource.Internal = _hou.cvar.nodeTypeSource_Internal
nodeTypeSource.Subnet = _hou.cvar.nodeTypeSource_Subnet
nodeTypeSource.CompiledCode = _hou.cvar.nodeTypeSource_CompiledCode
nodeTypeSource.VexCode = _hou.cvar.nodeTypeSource_VexCode
nodeTypeSource.RslCode = _hou.cvar.nodeTypeSource_RslCode


class fieldType(object):
    r"""

    hou.fieldType

    Enumeration of field types.

    VALUES


        NoSuchField
        Integer
        Boolean
        Float
        String
        Dict
        Vector2
        Vector3
        Vector4
        Quaternion
        Matrix3
        Matrix4
        UV
        UVW
        IntArray
        FloatArray
        DictArray


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_fieldType


# Register fieldType in _hou:
_hou.fieldType_swigregister(fieldType)
fieldType.NoSuchField = _hou.cvar.fieldType_NoSuchField
fieldType.Integer = _hou.cvar.fieldType_Integer
fieldType.Boolean = _hou.cvar.fieldType_Boolean
fieldType.Float = _hou.cvar.fieldType_Float
fieldType.String = _hou.cvar.fieldType_String
fieldType.Vector2 = _hou.cvar.fieldType_Vector2
fieldType.Vector3 = _hou.cvar.fieldType_Vector3
fieldType.Vector4 = _hou.cvar.fieldType_Vector4
fieldType.Quaternion = _hou.cvar.fieldType_Quaternion
fieldType.Matrix3 = _hou.cvar.fieldType_Matrix3
fieldType.Matrix4 = _hou.cvar.fieldType_Matrix4
fieldType.UV = _hou.cvar.fieldType_UV
fieldType.UVW = _hou.cvar.fieldType_UVW
fieldType.IntArray = _hou.cvar.fieldType_IntArray
fieldType.FloatArray = _hou.cvar.fieldType_FloatArray
fieldType.Matrix2 = _hou.cvar.fieldType_Matrix2
fieldType.StringArray = _hou.cvar.fieldType_StringArray
fieldType.Dict = _hou.cvar.fieldType_Dict
fieldType.DictArray = _hou.cvar.fieldType_DictArray


class renderMethod(object):
    r"""

    hou.renderMethod

    Enumeration of dependency rendering methods.

    VALUES


        RopByRop
        FrameByFrame


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_renderMethod


# Register renderMethod in _hou:
_hou.renderMethod_swigregister(renderMethod)
renderMethod.RopByRop = _hou.cvar.renderMethod_RopByRop
renderMethod.FrameByFrame = _hou.cvar.renderMethod_FrameByFrame


class updateMode(object):
    r"""

    hou.updateMode

    Enumeration of interface update modes.

    See hou.updateModeSetting.

    VALUES


        AutoUpdate
        OnMouseUp
        Manual


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_updateMode


# Register updateMode in _hou:
_hou.updateMode_swigregister(updateMode)
updateMode.AutoUpdate = _hou.cvar.updateMode_AutoUpdate
updateMode.OnMouseUp = _hou.cvar.updateMode_OnMouseUp
updateMode.Manual = _hou.cvar.updateMode_Manual


class licenseCategoryType(object):
    r"""

    hou.licenseCategoryType

    Enumeration of license category values.

    VALUES


        Commercial
        Indie
        Education
        ApprenticeHD
        Apprentice


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_licenseCategoryType


# Register licenseCategoryType in _hou:
_hou.licenseCategoryType_swigregister(licenseCategoryType)
licenseCategoryType.Commercial = _hou.cvar.licenseCategoryType_Commercial
licenseCategoryType.Indie = _hou.cvar.licenseCategoryType_Indie
licenseCategoryType.Education = _hou.cvar.licenseCategoryType_Education
licenseCategoryType.ApprenticeHD = _hou.cvar.licenseCategoryType_ApprenticeHD
licenseCategoryType.Apprentice = _hou.cvar.licenseCategoryType_Apprentice


class hdaLicenseType(object):
    r"""

    hou.hdaLicenseType

    Enumeration of digital asset license permission levels.

    VALUES


        Execute
        Read
        Full


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_hdaLicenseType


# Register hdaLicenseType in _hou:
_hou.hdaLicenseType_swigregister(hdaLicenseType)
hdaLicenseType.Execute = _hou.cvar.hdaLicenseType_Execute
hdaLicenseType.Read = _hou.cvar.hdaLicenseType_Read
hdaLicenseType.Full = _hou.cvar.hdaLicenseType_Full


class orientUpAxis(object):
    r"""

    hou.orientUpAxis

    Enumeration of global orientation mode.

    See hou.ui.orientationUpAxis for more information.

    VALUES


        Y
        Z


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_orientUpAxis


# Register orientUpAxis in _hou:
_hou.orientUpAxis_swigregister(orientUpAxis)
orientUpAxis.Y = _hou.cvar.orientUpAxis_Y
orientUpAxis.Z = _hou.cvar.orientUpAxis_Z


class handleOrientToNormalAxis(object):
    r"""

    hou.handleOrientToNormalAxis

    Enumeration of handle axes that can be aligned to a geometry normal.

    See hou.ui.handleOrientToNormalAxis for more information.

    VALUES


        Y
        Z


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_handleOrientToNormalAxis


# Register handleOrientToNormalAxis in _hou:
_hou.handleOrientToNormalAxis_swigregister(handleOrientToNormalAxis)
handleOrientToNormalAxis.Y = _hou.cvar.handleOrientToNormalAxis_Y
handleOrientToNormalAxis.Z = _hou.cvar.handleOrientToNormalAxis_Z


class nodeEventType(object):
    r"""

    hou.nodeEventType

    Enumeration of types of events that can happen to nodes.

    Node event callbacks let you run code when events occur on an individual
    node instance. See hou.Node.addEventCallback.

    For all event types, the callback is called with a node keyword argument
    (containing a hou.Node reference to the node) and an event_type argument
    (containing one of the values below, indicating the type of event that
    occurred).

    Some event types pass additional keyword arguments to the callback
    function, as noted below.

    VALUES


        BeingDeleted
            Runs before a node is deleted. You cannot cancel the deletion.

        NameChanged
            Runs after a node was renamed. You can get the new name using
            hou.Node.name.

        FlagChanged
            Runs after one of the node's flags was turned on or off.

        AppearanceChanged
            Runs after the an event occurs that changes what the node looks
            like in the network editor. This includes but is not limited to:

          * Color or shape changed

          * Error triggered or cleared

          * Selected or deselected

          * Asset locked or unlocked

            Extra keyword argument: change_type (hou.appearanceChangeType)

        PositionChanged
            Runs after the node is moved in the network editor. You can get
            the node's new position using hou.Node.position.

        InputRewired
            Runs after one of the node's inputs are connected or
            disconnected.

            Extra keyword argument: input_index (int) -- the input number
            (starting at 0) that changed.

        InputDataChanged
            The data changed on an input node that this node depends on.
            Changes to an input node that is not used (due to a Switch node,
            for example) will not trigger this callback. Houdini also does
            not trigger this event when a node changes if that node's data
            or parameters are referenced through expressions. Only nodes
            connected to this node as an input will trigger this callback.

        ParmTupleChanged
            Runs after a parameter value changes. You can get the new value
            using hou.ParmTuple.eval.

            Extra keyword argument: parm_tuple (hou.ParmTuple).


            NOTE
                If many/all parameters on the node change at the same time,
                instead of calling the handler for each one, Houdini will
                call the handler once with a parm_tuple argument of None.
                Your callback code should be handle this possibility.

        ParmTupleAnimated
            Runs after a parameter value changes from an undo/redo change or
            a major animation editor change. It isn't called during
            playback. You can get the new value using hou.ParmTuple.eval.

            Extra keyword argument: parm_tuple (hou.ParmTuple).


            NOTE
                If many/all parameters on the node change at the same time,
                instead of calling the handler for each one, Houdini will
                call the handler once with a parm_tuple argument of None.
                Your callback code should be handle this possibility.

        ParmTupleChannelChanged
            Runs after a parameter value changes from a minor animation
            editor change. It isn't called during playback. You can get the
            new value using hou.ParmTuple.eval.

            Extra keyword argument: parm_tuple (hou.ParmTuple).


            NOTE
                If many/all parameters on the node change at the same time,
                instead of calling the handler for each one, Houdini will
                call the handler once with a parm_tuple argument of None.
                Your callback code should be handle this possibility.

        ChildCreated
            For a subnet node (for example, a Geometry object), runs after a
            new node is created inside.

            Extra keyword argument: child_node (hou.Node)

        ChildDeleted
            For a subnet node (for example, a Geometry object), runs before
            a node is deleted inside. You cannot cancel the deletion.

            Extra keyword argument: child_node (hou.Node)

        ChildSwitched
            For a subnet node (for example, a Geometry object), runs after
            the current node, display flag, or render flag changes inside
            (meaning the 3D view will change).

            Extra keyword argument: child_node (hou.Node) -- the newly
            selected child node.

        ChildSelectionChanged
            For a subnet node (for example, a Geometry object), runs after
            the selection changes inside. You can get the new selection with
            hou.Node.selectedChildren.

        NetworkBoxCreated
            Runs after a new network box is created inside this node.

        NetworkBoxChanged
            Runs after an item is added to or removed from a network box
            inside this node. In some cases is may be possible to receive a
            NetworkBoxChanged callback for a new network box before
            receiving the NetworkBoxCreated callback.

        NetworkBoxDeleted
            Runs right before a network box is deleted from inside this
            node.

        StickyNoteCreated
            Runs after a new network box is created inside this node.

        StickyNoteChanged
            Runs after a new sticky note's text is changed inside this node.
            In some cases is may be possible to receive a StickyNoteChanged
            callback for a new network box before receiving the
            StickyNoteCreated callback.

        StickyNoteDeleted
            Runs right before a sticky note is deleted from inside this
            node.

        IndirectInputCreated
            Runs after a new indirect input is created inside this node.
            This will generally be a Network Dot, but may in some cases be a
            Subnet Indirect Input.

        IndirectInputDeleted
            Runs before an indirect input is deleted from inside this node.
            This will generally be a Network Dot, but may in some cases be a
            Subnet Indirect Input.

        SpareParmTemplatesChanged
            Runs after a spare parameter is modified on, added to, or
            removed from the node.


            NOTE
                If the node has spare parameters, this event triggers when
                any parameter is modified, not just a spare parameter.

        SelectionChanged
            Runs after the selection associated with a node changes. This
            only applies to the geometry selected on a SOP node, or the
            scene graph primitives selected in a LOP Network.

        CustomDataChanged
            Runs after some custom data on a node is changed. The custom
            data available, and the methods for accessing it, will depend on
            the hou.NodeType of the node that is changing. One example of
            custom node data is the viewport scene overrides that can be
            applied to a LOP Network.

        WorkItemSelectionChanged
            For a TOP network, runs after the selected work item has a
            changed.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_nodeEventType


# Register nodeEventType in _hou:
_hou.nodeEventType_swigregister(nodeEventType)
nodeEventType.BeingDeleted = _hou.cvar.nodeEventType_BeingDeleted
nodeEventType.NameChanged = _hou.cvar.nodeEventType_NameChanged
nodeEventType.InputRewired = _hou.cvar.nodeEventType_InputRewired
nodeEventType.FlagChanged = _hou.cvar.nodeEventType_FlagChanged
nodeEventType.ParmTupleChanged = _hou.cvar.nodeEventType_ParmTupleChanged
nodeEventType.AppearanceChanged = _hou.cvar.nodeEventType_AppearanceChanged
nodeEventType.PositionChanged = _hou.cvar.nodeEventType_PositionChanged
nodeEventType.ChildCreated = _hou.cvar.nodeEventType_ChildCreated
nodeEventType.ChildDeleted = _hou.cvar.nodeEventType_ChildDeleted
nodeEventType.ChildSwitched = _hou.cvar.nodeEventType_ChildSwitched
nodeEventType.ChildSelectionChanged = _hou.cvar.nodeEventType_ChildSelectionChanged
nodeEventType.InputDataChanged = _hou.cvar.nodeEventType_InputDataChanged
nodeEventType.SpareParmTemplatesChanged = (
    _hou.cvar.nodeEventType_SpareParmTemplatesChanged
)
nodeEventType.SelectionChanged = _hou.cvar.nodeEventType_SelectionChanged
nodeEventType.CustomDataChanged = _hou.cvar.nodeEventType_CustomDataChanged
nodeEventType.WorkItemSelectionChanged = (
    _hou.cvar.nodeEventType_WorkItemSelectionChanged
)
nodeEventType.NetworkBoxCreated = _hou.cvar.nodeEventType_NetworkBoxCreated
nodeEventType.NetworkBoxChanged = _hou.cvar.nodeEventType_NetworkBoxChanged
nodeEventType.NetworkBoxDeleted = _hou.cvar.nodeEventType_NetworkBoxDeleted
nodeEventType.IndirectInputCreated = _hou.cvar.nodeEventType_IndirectInputCreated
nodeEventType.IndirectInputDeleted = _hou.cvar.nodeEventType_IndirectInputDeleted
nodeEventType.StickyNoteCreated = _hou.cvar.nodeEventType_StickyNoteCreated
nodeEventType.StickyNoteChanged = _hou.cvar.nodeEventType_StickyNoteChanged
nodeEventType.StickyNoteDeleted = _hou.cvar.nodeEventType_StickyNoteDeleted
nodeEventType.ParmTupleAnimated = _hou.cvar.nodeEventType_ParmTupleAnimated
nodeEventType.ParmTupleChannelChanged = _hou.cvar.nodeEventType_ParmTupleChannelChanged


class hdaEventType(object):
    r"""

    hou.hdaEventType

    Enumeration of types of events that can happen for digital asset
    libraries.

    See hou.hda.addEventCallback.


    NOTE
        The AssetCreated and AssetDeleted events do not fire when a library
        file is installed or uninstalled.

    VALUES


        AssetCreated
            A new asset was created (using the Create Digital Asset context
            menu item in the network editor or through HOM).

            The callback function is called with this event type and the
            following additional argument:


            asset_definition
                An hou.HDADefinition object representing the newly created
                asset.

        AssetDeleted
            An asset was deleted (using the Asset Manager UI or through
            HOM). Note that the asset no longer exists when this event type
            occurs.

            The callback function is called with this event type and the
            following additional arguments:


            asset_name
                A string containing the name of the deleted asset.

            library_path
                A string containing the file path of the asset library
                (.hda) file that contained the asset.

            node_type_category
                A hou.NodeTypeCategory representing the type category (for
                example, Object, SOP, DOP) of the deleted asset.

        AssetSaved
            An asset was saved.

            The callback function is called with this event type and the
            following additional argument:


            asset_definition
                An hou.HDADefinition object representing the saved asset.

        BeforeAssetCreated
            A new asset is about to be created (using the Create Digital
            Asset context menu item in the network editor or through HOM).

            The callback function is called with this event type and the
            following additional argument:


            asset_name
                A string containing the name of the asset to be created.

            library_path
                A string containing the file path of the asset library
                (.hda) file that will contain the asset.

            node_type_category
                A hou.NodeTypeCategory representing the type category (for
                example, Object, SOP, DOP) of the asset to be created.

        BeforeAssetDeleted
            An asset is about to be deleted (using the Asset Manager UI or
            through HOM). Note that the asset still exists when this event
            occurs.

            The callback function is called with this event type and the
            following additional arguments:


            asset_definition
                An hou.HDADefinition object representing the asset to be
                deleted.

        BeforeAssetSaved
            An asset is about to be saved.

            The callback function is called with this event type and the
            following additional argument:


            asset_definition
                An hou.HDADefinition object representing the asset to be
                saved.

        LibraryInstalled
            A digital asset library has been installed into the current
            Houdini session.

            The callback function is called with this event type and the
            following additional argument:


            library_path
                The file path to the installed asset library (.hda) file.

        LibraryUninstalled
            A digital asset library has been uninstalled from the current
            Houdini session.

            The callback function is called with this event type and the
            following additional argument:


            library_path
                The file path to the uninstalled asset library (.hda) file.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_hdaEventType


# Register hdaEventType in _hou:
_hou.hdaEventType_swigregister(hdaEventType)
hdaEventType.AssetCreated = _hou.cvar.hdaEventType_AssetCreated
hdaEventType.AssetDeleted = _hou.cvar.hdaEventType_AssetDeleted
hdaEventType.AssetSaved = _hou.cvar.hdaEventType_AssetSaved
hdaEventType.LibraryInstalled = _hou.cvar.hdaEventType_LibraryInstalled
hdaEventType.LibraryUninstalled = _hou.cvar.hdaEventType_LibraryUninstalled
hdaEventType.BeforeAssetCreated = _hou.cvar.hdaEventType_BeforeAssetCreated
hdaEventType.BeforeAssetDeleted = _hou.cvar.hdaEventType_BeforeAssetDeleted
hdaEventType.BeforeAssetSaved = _hou.cvar.hdaEventType_BeforeAssetSaved


class hipFileEventType(object):
    r"""

    hou.hipFileEventType

    Enumeration of the hip file event types that can be handled by callback
    functions.

    See hou.hipFile.addEventCallback.

    VALUES


        BeforeClear
            This event is triggered immediately before the current .hip file
            is cleared. For example, when selecting File -> New in the main
            menu bar.

        AfterClear
            This event is triggered immediately after the current .hip file
            is cleared. For example, when selecting File -> New in the main
            menu bar.

        BeforeLoad
            This event is triggered immediately before a .hip file is loaded
            into Houdini.

        AfterLoad
            This event is triggered immediately after a .hip file is loaded
            into Houdini.

        BeforeMerge
            This event is triggered immediately before a .hip file is merged
            into the current Houdini session.

        AfterMerge
            This event is triggered immediately after a .hip file is merged
            into the current Houdini session.

        BeforeSave
            This event is triggered immediately before the current .hip file
            is saved.

        AfterSave
            This event is triggered immediately after the current .hip file
            is saved.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_hipFileEventType


# Register hipFileEventType in _hou:
_hou.hipFileEventType_swigregister(hipFileEventType)
hipFileEventType.BeforeClear = _hou.cvar.hipFileEventType_BeforeClear
hipFileEventType.AfterClear = _hou.cvar.hipFileEventType_AfterClear
hipFileEventType.BeforeLoad = _hou.cvar.hipFileEventType_BeforeLoad
hipFileEventType.AfterLoad = _hou.cvar.hipFileEventType_AfterLoad
hipFileEventType.BeforeMerge = _hou.cvar.hipFileEventType_BeforeMerge
hipFileEventType.AfterMerge = _hou.cvar.hipFileEventType_AfterMerge
hipFileEventType.BeforeSave = _hou.cvar.hipFileEventType_BeforeSave
hipFileEventType.AfterSave = _hou.cvar.hipFileEventType_AfterSave


class appearanceChangeType(object):
    r"""

    hou.appearanceChangeType

    Enumeration of types of appearance change events that can happen to
    nodes.

    See hou.Node.addEventCallback.

    VALUES


        Any
        ErrorState
        Pick
        Color
        DeleteScript
        CommentLockFlag
        CompressFlag
        OTLMatchState
        ActiveInput
        Connections
        ExpressionLanguage
        NetworkBox
        PostIt


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_appearanceChangeType


# Register appearanceChangeType in _hou:
_hou.appearanceChangeType_swigregister(appearanceChangeType)
appearanceChangeType.Any = _hou.cvar.appearanceChangeType_Any
appearanceChangeType.ErrorState = _hou.cvar.appearanceChangeType_ErrorState
appearanceChangeType.Pick = _hou.cvar.appearanceChangeType_Pick
appearanceChangeType.Color = _hou.cvar.appearanceChangeType_Color
appearanceChangeType.DeleteScript = _hou.cvar.appearanceChangeType_DeleteScript
appearanceChangeType.Comment = _hou.cvar.appearanceChangeType_Comment
appearanceChangeType.LockFlag = _hou.cvar.appearanceChangeType_LockFlag
appearanceChangeType.CompressFlag = _hou.cvar.appearanceChangeType_CompressFlag
appearanceChangeType.OTLMatchState = _hou.cvar.appearanceChangeType_OTLMatchState
appearanceChangeType.ActiveInput = _hou.cvar.appearanceChangeType_ActiveInput
appearanceChangeType.Connections = _hou.cvar.appearanceChangeType_Connections
appearanceChangeType.ExpressionLanguage = (
    _hou.cvar.appearanceChangeType_ExpressionLanguage
)
appearanceChangeType.NetworkBox = _hou.cvar.appearanceChangeType_NetworkBox
appearanceChangeType.PostIt = _hou.cvar.appearanceChangeType_PostIt
appearanceChangeType.Dot = _hou.cvar.appearanceChangeType_Dot


class ropRenderEventType(object):
    r"""

    hou.ropRenderEventType

    Enumeration of types of events that can happen when a ROP node is
    rendering.

    ROP render event callbacks let you run code when a render events occur
    on an individual ROP node instance. See
    hou.RopNode.addRenderEventCallback.

    The event callback is called with the hou.RopNode that produced the
    event as the first argument, an enum value from this enum as the second
    argument, and the time value that event occured as the last argument.

    VALUES


        PreRender
            Runs exactly once, before the ROP node begins rendering.

        PreFrame
            Runs before each frame is rendered.

        PostFrame
            Runs after each frame finishes rendering.

        PostWrite
            Runs after output files for a frame have been written to disk.
            This is primarly used with nodes like the , which write output
            files in the background.

        PostRender
            Runs exactly once, after the ROP has finished rendering.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_ropRenderEventType


# Register ropRenderEventType in _hou:
_hou.ropRenderEventType_swigregister(ropRenderEventType)
ropRenderEventType.PreRender = _hou.cvar.ropRenderEventType_PreRender
ropRenderEventType.PreFrame = _hou.cvar.ropRenderEventType_PreFrame
ropRenderEventType.PostFrame = _hou.cvar.ropRenderEventType_PostFrame
ropRenderEventType.PostWrite = _hou.cvar.ropRenderEventType_PostWrite
ropRenderEventType.PostRender = _hou.cvar.ropRenderEventType_PostRender


class imageDepth(object):
    r"""

    hou.imageDepth

    Enumeration of image depths (data formats) for representing the pixels
    in an image plane.

    See hou.CopNode.depth.

    VALUES


        Int8
        Int16
        Int32
        Float16
        Float32


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_imageDepth


# Register imageDepth in _hou:
_hou.imageDepth_swigregister(imageDepth)
imageDepth.Int8 = _hou.cvar.imageDepth_Int8
imageDepth.Int16 = _hou.cvar.imageDepth_Int16
imageDepth.Int32 = _hou.cvar.imageDepth_Int32
imageDepth.Float16 = _hou.cvar.imageDepth_Float16
imageDepth.Float32 = _hou.cvar.imageDepth_Float32


class playMode(object):
    r"""

    hou.playMode

    Enumeration of play modes for the main playbar in Houdini.

    VALUES


        Loop
            Play through the frame range and when reaching the end of the
            range loop back to the beginning and continue the playback.

        Once
            Play through the frame range and when reaching the end of the
            range stop the playback.

        Zigzag
            Play through the frame range and when reaching the end of the
            range reverse the playback. When the reverse playback reaches
            the beginning of the range, then continue playback in the
            forward direction, etc.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_playMode


# Register playMode in _hou:
_hou.playMode_swigregister(playMode)
playMode.Loop = _hou.cvar.playMode_Loop
playMode.Once = _hou.cvar.playMode_Once
playMode.Zigzag = _hou.cvar.playMode_Zigzag


class playbarEvent(object):
    r"""

    hou.playbarEvent

    Enumeration of the playbar events that can be handled by callback
    functions.

    See hou.playbar.addEventCallback.

    VALUES


        Started
            This event is triggered when the playbar has started playback
            either in the forward or reverse direction.

        Stopped
            This event is triggered when running playback has stopped.

        FrameChanged
            This event is triggered when the playbar has changed to another
            frame and after the scene has been cooked for the new frame.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_playbarEvent


# Register playbarEvent in _hou:
_hou.playbarEvent_swigregister(playbarEvent)
playbarEvent.Started = _hou.cvar.playbarEvent_Started
playbarEvent.Stopped = _hou.cvar.playbarEvent_Stopped
playbarEvent.FrameChanged = _hou.cvar.playbarEvent_FrameChanged


class perfMonTimeFormat(object):
    r"""

    hou.perfMonTimeFormat

    Enumeration of the different formats used when viewing times in the
    Performance Monitor panetab.

    VALUES


        Absolute
        Percent


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_perfMonTimeFormat


# Register perfMonTimeFormat in _hou:
_hou.perfMonTimeFormat_swigregister(perfMonTimeFormat)
perfMonTimeFormat.Absolute = _hou.cvar.perfMonTimeFormat_Absolute
perfMonTimeFormat.Percent = _hou.cvar.perfMonTimeFormat_Percent


class perfMonTimeUnit(object):
    r"""

    hou.perfMonTimeUnit

    Enumeration of the different units used when viewing times in the
    Performance Monitor panetab.

    VALUES


        Seconds
            Display times in seconds.

        Milliseconds
            Display times in milliseconds.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_perfMonTimeUnit


# Register perfMonTimeUnit in _hou:
_hou.perfMonTimeUnit_swigregister(perfMonTimeUnit)
perfMonTimeUnit.Seconds = _hou.cvar.perfMonTimeUnit_Seconds
perfMonTimeUnit.Milliseconds = _hou.cvar.perfMonTimeUnit_Milliseconds


class perfMonObjectView(object):
    r"""

    hou.perfMonObjectView

    Enumeration of the different structures that are used to view objects in
    the Performance Monitor panetab.

    VALUES


        List
        Tree
        EventLog


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_perfMonObjectView


# Register perfMonObjectView in _hou:
_hou.perfMonObjectView_swigregister(perfMonObjectView)
perfMonObjectView.List = _hou.cvar.perfMonObjectView_List
perfMonObjectView.Tree = _hou.cvar.perfMonObjectView_Tree
perfMonObjectView.EventLog = _hou.cvar.perfMonObjectView_EventLog


class compressionType(object):
    r"""

    hou.compressionType

    Enumeration of compression types.

    VALUES


        Gzip
            Compress using Gzip.

        Blosc
            Compress using Blosc.

        NoCompression
            Do not compress.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_compressionType


# Register compressionType in _hou:
_hou.compressionType_swigregister(compressionType)
compressionType.NoCompression = _hou.cvar.compressionType_NoCompression
compressionType.Gzip = _hou.cvar.compressionType_Gzip
compressionType.Blosc = _hou.cvar.compressionType_Blosc


class nodeTypeFilter(object):
    r"""

    hou.nodeTypeFilter

    Enumeration of available node type filters.

    These filters are used by node bundles to limit the nodes in the bundle
    based on type.

    VALUES


        NoFilter
            Any node

        Sop
            Any SOP

        Dop
            Any DOP

        Chop
            Any CHOP

        Chopnet
            Any CHOP Network

        Cop
            Any COP

        Copnet
            Any COP Network

        Vop
            Any VOP

        Vopnet
            Any VOP Network

        Rop
            Any ROP

        Lop
            Any LOP

        Top
            Any TOP

        Shop
            Any SHOP

        Obj
            Any Object

        ObjBone
            Object: Bone Only

        ObjCamera
            Object: Camera Only

        ObjFog
            Object: Fog Only

        ObjGeometry
            Object: Geometry Only

        ObjGeometryOrFog
            Object: Geometry and Fog Only

        ObjLight
            Object: Light Only

        ObjMuscle
            Object: Muscle Only

        ObjSubnet
            Object: Muscle Only

        ShopAtmosphere
            Shop: Atmosphere Only

        ShopCVEX
            Shop: CVEX Only

        ShopDisplacement
            Shop: Displacement Only

        ShopImage3D
            Shop: Image3D Only

        ShopInterior
            Shop: Interior Only

        ShopLight
            Shop: Light Only

        ShopLightShadow
            Shop: Light Shadow Only

        ShopMaterial
            Shop: Material Only

        ShopPhoton
            Shop: Photon Only

        ShopProperties
            Shop: Properties Only

        ShopSurface
            Shop: Surface Only

        TopScheduler
            Top: Schedulers Only

        TopPartitioner
            Top: Partitioners Only

        TopProcessor
            Top: Processors Only


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_nodeTypeFilter


# Register nodeTypeFilter in _hou:
_hou.nodeTypeFilter_swigregister(nodeTypeFilter)
nodeTypeFilter.NoFilter = _hou.cvar.nodeTypeFilter_NoFilter
nodeTypeFilter.Sop = _hou.cvar.nodeTypeFilter_Sop
nodeTypeFilter.Chop = _hou.cvar.nodeTypeFilter_Chop
nodeTypeFilter.Chopnet = _hou.cvar.nodeTypeFilter_Chopnet
nodeTypeFilter.Cop = _hou.cvar.nodeTypeFilter_Cop
nodeTypeFilter.Copnet = _hou.cvar.nodeTypeFilter_Copnet
nodeTypeFilter.Vop = _hou.cvar.nodeTypeFilter_Vop
nodeTypeFilter.Vopnet = _hou.cvar.nodeTypeFilter_Vopnet
nodeTypeFilter.Rop = _hou.cvar.nodeTypeFilter_Rop
nodeTypeFilter.Obj = _hou.cvar.nodeTypeFilter_Obj
nodeTypeFilter.ObjGeometry = _hou.cvar.nodeTypeFilter_ObjGeometry
nodeTypeFilter.ObjFog = _hou.cvar.nodeTypeFilter_ObjFog
nodeTypeFilter.ObjGeometryOrFog = _hou.cvar.nodeTypeFilter_ObjGeometryOrFog
nodeTypeFilter.ObjLight = _hou.cvar.nodeTypeFilter_ObjLight
nodeTypeFilter.ObjCamera = _hou.cvar.nodeTypeFilter_ObjCamera
nodeTypeFilter.ObjBone = _hou.cvar.nodeTypeFilter_ObjBone
nodeTypeFilter.ObjMuscle = _hou.cvar.nodeTypeFilter_ObjMuscle
nodeTypeFilter.ObjSubnet = _hou.cvar.nodeTypeFilter_ObjSubnet
nodeTypeFilter.Shop = _hou.cvar.nodeTypeFilter_Shop
nodeTypeFilter.ShopMaterial = _hou.cvar.nodeTypeFilter_ShopMaterial
nodeTypeFilter.ShopProperties = _hou.cvar.nodeTypeFilter_ShopProperties
nodeTypeFilter.ShopSurface = _hou.cvar.nodeTypeFilter_ShopSurface
nodeTypeFilter.ShopDisplacement = _hou.cvar.nodeTypeFilter_ShopDisplacement
nodeTypeFilter.ShopInterior = _hou.cvar.nodeTypeFilter_ShopInterior
nodeTypeFilter.ShopLight = _hou.cvar.nodeTypeFilter_ShopLight
nodeTypeFilter.ShopLightShadow = _hou.cvar.nodeTypeFilter_ShopLightShadow
nodeTypeFilter.ShopAtmosphere = _hou.cvar.nodeTypeFilter_ShopAtmosphere
nodeTypeFilter.ShopPhoton = _hou.cvar.nodeTypeFilter_ShopPhoton
nodeTypeFilter.ShopImage3D = _hou.cvar.nodeTypeFilter_ShopImage3D
nodeTypeFilter.ShopCVEX = _hou.cvar.nodeTypeFilter_ShopCVEX
nodeTypeFilter.Dop = _hou.cvar.nodeTypeFilter_Dop
nodeTypeFilter.Lop = _hou.cvar.nodeTypeFilter_Lop
nodeTypeFilter.Top = _hou.cvar.nodeTypeFilter_Top
nodeTypeFilter.TopScheduler = _hou.cvar.nodeTypeFilter_TopScheduler
nodeTypeFilter.TopProcessor = _hou.cvar.nodeTypeFilter_TopProcessor
nodeTypeFilter.TopPartitioner = _hou.cvar.nodeTypeFilter_TopPartitioner


class vdbData(object):
    r"""

    hou.vdbData

    Enumeration of voxel data types.

    See hou.VDB.

    VALUES


        Boolean
        Float
        Int
        Vector3


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_vdbData


# Register vdbData in _hou:
_hou.vdbData_swigregister(vdbData)
vdbData.Boolean = _hou.cvar.vdbData_Boolean
vdbData.Float = _hou.cvar.vdbData_Float
vdbData.Int = _hou.cvar.vdbData_Int
vdbData.Vector3 = _hou.cvar.vdbData_Vector3


class lopViewportOverridesLayer(object):
    r"""

    hou.lopViewportOverridesLayer

    Specifies a choice between the various pxr.Sdf.Layer objects available
    in a hou.LopViewportOverrides object.

    VALUES


        Base
        Selectable
        SoloLights
        SoloGeometry
        Custom


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_lopViewportOverridesLayer


# Register lopViewportOverridesLayer in _hou:
_hou.lopViewportOverridesLayer_swigregister(lopViewportOverridesLayer)
lopViewportOverridesLayer.Base = _hou.cvar.lopViewportOverridesLayer_Base
lopViewportOverridesLayer.Selectable = _hou.cvar.lopViewportOverridesLayer_Selectable
lopViewportOverridesLayer.SoloLights = _hou.cvar.lopViewportOverridesLayer_SoloLights
lopViewportOverridesLayer.SoloGeometry = (
    _hou.cvar.lopViewportOverridesLayer_SoloGeometry
)
lopViewportOverridesLayer.Custom = _hou.cvar.lopViewportOverridesLayer_Custom


class channelEditorMode(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_channelEditorMode


# Register channelEditorMode in _hou:
_hou.channelEditorMode_swigregister(channelEditorMode)
channelEditorMode.Graph = _hou.cvar.channelEditorMode_Graph
channelEditorMode.Table = _hou.cvar.channelEditorMode_Table
channelEditorMode.Dopesheet = _hou.cvar.channelEditorMode_Dopesheet


class vopParmGenType(object):
    r"""

    hou.vopParmGenType

    Enumeration of the different node configurations that can be created for
    the inputs of a VOP node.

    See hou.VopNode.insertParmGenerator and
    hou.VopNode.insertParmGeneratorsForAllInputs.

    VALUES


        Constant
            Create a Constant VOP and connect it to the VOP node's input.

        Parameter
            Create a Parameter VOP and connect it to the VOP node's input.
            The input parameter is automatically promoted to the VOP
            network's parameter interface.

        SubnetInput
            Create a Parameter VOP and connect it to the VOP node's input.
            Additionally set the Parameter VOP's Scope parameter to Subnet.
            The input parameter is automatically promoted to the owning
            Subnet VOP's parameter interface.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_vopParmGenType


# Register vopParmGenType in _hou:
_hou.vopParmGenType_swigregister(vopParmGenType)
vopParmGenType.Constant = _hou.cvar.vopParmGenType_Constant
vopParmGenType.Parameter = _hou.cvar.vopParmGenType_Parameter
vopParmGenType.SubnetInput = _hou.cvar.vopParmGenType_SubnetInput


class stateGenerateMode(object):
    r"""

    hou.stateGenerateMode

    Enumeration of possible node generation modes by states.

    See hou.SceneViewer.setCurrentState for more information.

    VALUES


        Insert
        Branch
        Enter


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_stateGenerateMode


# Register stateGenerateMode in _hou:
_hou.stateGenerateMode_swigregister(stateGenerateMode)
stateGenerateMode.Insert = _hou.cvar.stateGenerateMode_Insert
stateGenerateMode.Branch = _hou.cvar.stateGenerateMode_Branch
stateGenerateMode.Enter = _hou.cvar.stateGenerateMode_Enter


class scenePrimMask(object):
    r"""

    hou.scenePrimMask

    Scene Graph Selection Mask

    Defines the primitive types that can be selected by
    SceneViewer.selectSceneGraph() if the caller wishes to override the
    current scene viewer selection mask.

    VALUES


        hou.scenePrimMask.All
            All primitive types can be selected.

        hou.scenePrimMask.Camera
            Only camera primitive types can be selected.

        hou.scenePrimMask.Geometry
            Only geometry primitive types can be selected.

        hou.scenePrimMask.Light
            Only light primitive types can be selected.

        hou.scenePrimMask.LightAndCamera
            Only light and camera primitive types can be selected.

        hou.scenePrimMask.ViewerSetting
            Use the viewer setting for the primitive selection mask
            (default).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_scenePrimMask


# Register scenePrimMask in _hou:
_hou.scenePrimMask_swigregister(scenePrimMask)
scenePrimMask.All = _hou.cvar.scenePrimMask_All
scenePrimMask.Geometry = _hou.cvar.scenePrimMask_Geometry
scenePrimMask.Light = _hou.cvar.scenePrimMask_Light
scenePrimMask.Camera = _hou.cvar.scenePrimMask_Camera
scenePrimMask.LightAndCamera = _hou.cvar.scenePrimMask_LightAndCamera
scenePrimMask.ViewerSetting = _hou.cvar.scenePrimMask_ViewerSetting


class viewportVisualizerCategory(object):
    r"""

    hou.viewportVisualizerCategory

    Enumeration of the different categories of viewport visualizers.

    VALUES


        Common
            Viewport visualizers in the common category are available across
            all scene files.

        Scene
            Viewport visualizers in the scene category are saved to the
            scene file and are only available in the specific scene file in
            which they are created or saved.

        Node
            Node visualizers are installed on individual nodes in Houdini
            and have a limited scope.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportVisualizerCategory


# Register viewportVisualizerCategory in _hou:
_hou.viewportVisualizerCategory_swigregister(viewportVisualizerCategory)
viewportVisualizerCategory.Node = _hou.cvar.viewportVisualizerCategory_Node
viewportVisualizerCategory.Scene = _hou.cvar.viewportVisualizerCategory_Scene
viewportVisualizerCategory.Common = _hou.cvar.viewportVisualizerCategory_Common


class viewportVisualizerScope(object):
    r"""

    hou.viewportVisualizerScope

    Enumeration of the different scopes of viewport visualizers.

    VALUES


        NodeOnly
            The visualizer affects only the geometry produced by the node on
            which it is installed. This value only applies to visualizers in
            the hou.viewportVisualizerCategory.Node category.

        SameNetworkTypeDescendents
            The visualizer affects only the geometries produced by the node
            and its descendent nodes of the same network type. This value
            only applies to visualizers in the
            hou.viewportVisualizerCategory.Node category.

        AllDescendents
            The visualizer affects the geometries produced by the node and
            its descendent nodes regardless of the network type. This value
            only applies to visualizers in the
            hou.viewportVisualizerCategory.Node category.

        Global
            The visualizer affects any geometry that is displayed in the
            viewport. This value only applies to visualizers in the
            hou.viewportVisualizerCategory.Common and
            hou.viewportVisualizerCategory.Scene categories.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_viewportVisualizerScope


# Register viewportVisualizerScope in _hou:
_hou.viewportVisualizerScope_swigregister(viewportVisualizerScope)
viewportVisualizerScope.NodeOnly = _hou.cvar.viewportVisualizerScope_NodeOnly
viewportVisualizerScope.SameNetworkTypeDescendents = (
    _hou.cvar.viewportVisualizerScope_SameNetworkTypeDescendents
)
viewportVisualizerScope.AllDescendents = (
    _hou.cvar.viewportVisualizerScope_AllDescendents
)
viewportVisualizerScope.Global = _hou.cvar.viewportVisualizerScope_Global


class nodeFlag(object):
    r"""

    hou.nodeFlag

    Enumeration of the different node flags.

    VALUES


        Audio
        Bypass
        ColorDefault
        Compress
        Current
        Debug
        Display
        DisplayComment
        DisplayDescriptiveName
        Export
        Expose
        Footprint
        Highlight
        InOutDetailLow
        InOutDetailMedium
        InOutDetailHigh
        Material
        Lock
        SoftLock
        Origin
        OutputForDisplay
        Pick
        Render
        Selectable
        Template
        Unload
        Visible
        XRay


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_nodeFlag


# Register nodeFlag in _hou:
_hou.nodeFlag_swigregister(nodeFlag)
nodeFlag.Audio = _hou.cvar.nodeFlag_Audio
nodeFlag.Bypass = _hou.cvar.nodeFlag_Bypass
nodeFlag.ColorDefault = _hou.cvar.nodeFlag_ColorDefault
nodeFlag.Compress = _hou.cvar.nodeFlag_Compress
nodeFlag.Current = _hou.cvar.nodeFlag_Current
nodeFlag.Debug = _hou.cvar.nodeFlag_Debug
nodeFlag.Display = _hou.cvar.nodeFlag_Display
nodeFlag.DisplayDescriptiveName = _hou.cvar.nodeFlag_DisplayDescriptiveName
nodeFlag.DisplayComment = _hou.cvar.nodeFlag_DisplayComment
nodeFlag.Export = _hou.cvar.nodeFlag_Export
nodeFlag.Expose = _hou.cvar.nodeFlag_Expose
nodeFlag.Footprint = _hou.cvar.nodeFlag_Footprint
nodeFlag.Highlight = _hou.cvar.nodeFlag_Highlight
nodeFlag.InOutDetailLow = _hou.cvar.nodeFlag_InOutDetailLow
nodeFlag.InOutDetailMedium = _hou.cvar.nodeFlag_InOutDetailMedium
nodeFlag.InOutDetailHigh = _hou.cvar.nodeFlag_InOutDetailHigh
nodeFlag.Material = _hou.cvar.nodeFlag_Material
nodeFlag.Lock = _hou.cvar.nodeFlag_Lock
nodeFlag.Origin = _hou.cvar.nodeFlag_Origin
nodeFlag.OutputForDisplay = _hou.cvar.nodeFlag_OutputForDisplay
nodeFlag.Pick = _hou.cvar.nodeFlag_Pick
nodeFlag.Render = _hou.cvar.nodeFlag_Render
nodeFlag.Selectable = _hou.cvar.nodeFlag_Selectable
nodeFlag.SoftLock = _hou.cvar.nodeFlag_SoftLock
nodeFlag.Template = _hou.cvar.nodeFlag_Template
nodeFlag.Unload = _hou.cvar.nodeFlag_Unload
nodeFlag.Visible = _hou.cvar.nodeFlag_Visible
nodeFlag.XRay = _hou.cvar.nodeFlag_XRay


class nodeFootprint(object):
    r"""

    hou.nodeFootprint

    Enumeration of the specialized node footprints supported by the network
    editor.

    These values can be used to initialize a hou.NetworkFootprint object to
    be passed to a hou.NetworkEditor object specifying which nodes should be
    drawn with footprint circles around them.

    VALUES


        InsertionPoint
            Draw a footprint around the LOP node that is currently set as
            the insertion point on the containing LOP Network.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_nodeFootprint


# Register nodeFootprint in _hou:
_hou.nodeFootprint_swigregister(nodeFootprint)
nodeFootprint.InsertionPoint = _hou.cvar.nodeFootprint_InsertionPoint


class fbxCompatibilityMode(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_fbxCompatibilityMode


# Register fbxCompatibilityMode in _hou:
_hou.fbxCompatibilityMode_swigregister(fbxCompatibilityMode)
fbxCompatibilityMode.FBXStandard = _hou.cvar.fbxCompatibilityMode_FBXStandard
fbxCompatibilityMode.Maya = _hou.cvar.fbxCompatibilityMode_Maya


class fbxMaterialMode(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_fbxMaterialMode


# Register fbxMaterialMode in _hou:
_hou.fbxMaterialMode_swigregister(fbxMaterialMode)
fbxMaterialMode.FBXShaderNodes = _hou.cvar.fbxMaterialMode_FBXShaderNodes
fbxMaterialMode.VopNetworks = _hou.cvar.fbxMaterialMode_VopNetworks
fbxMaterialMode.PrincipledShaders = _hou.cvar.fbxMaterialMode_PrincipledShaders


class saveMode(object):
    r"""

    hou.saveMode

    Enumeration of hip file save modes.

    VALUES


        Text
            Save in an ASCII format that is friendly to version control and
            can be viewed and edited as plain text. This format is
            compatible with Houdini 16 and above only and is only available
            with a full commercial license.

        Binary
            Traditional binary hip file format. This is both smaller and
            more performant than the text format.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_saveMode


# Register saveMode in _hou:
_hou.saveMode_swigregister(saveMode)
saveMode.Binary = _hou.cvar.saveMode_Binary
saveMode.Text = _hou.cvar.saveMode_Text


class radialItemType(object):
    r"""

    hou.radialItemType

    Enumeration of types for radial menu items in Houdini.

    VALUES


        Script
            Specifies a script radial menu item.

        Submenu
            Specifies a submenu radial menu item.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_radialItemType


# Register radialItemType in _hou:
_hou.radialItemType_swigregister(radialItemType)
radialItemType.Script = _hou.cvar.radialItemType_Script
radialItemType.Submenu = _hou.cvar.radialItemType_Submenu


class radialItemLocation(object):
    r"""

    hou.radialItemLocation

    Enumeration of locations for radial menu items in Houdini.

    VALUES


        Top
            Specifies top location of a radial menu item.

        TopLeft
            Specifies top left location of a radial menu item.

        Left
            Specifies left location of a radial menu item.

        BottomLeft
            Specifies bottom left location of a radial menu item.

        Bottom
            Specifies bottom location of a radial menu item.

        BottomRight
            Specifies bottom right location of a radial menu item.

        Right
            Specifies right location of a radial menu item.

        TopRight
            Specifies top right location of a radial menu item.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_radialItemLocation


# Register radialItemLocation in _hou:
_hou.radialItemLocation_swigregister(radialItemLocation)
radialItemLocation.TopLeft = _hou.cvar.radialItemLocation_TopLeft
radialItemLocation.Top = _hou.cvar.radialItemLocation_Top
radialItemLocation.TopRight = _hou.cvar.radialItemLocation_TopRight
radialItemLocation.Left = _hou.cvar.radialItemLocation_Left
radialItemLocation.Right = _hou.cvar.radialItemLocation_Right
radialItemLocation.BottomLeft = _hou.cvar.radialItemLocation_BottomLeft
radialItemLocation.Bottom = _hou.cvar.radialItemLocation_Bottom
radialItemLocation.BottomRight = _hou.cvar.radialItemLocation_BottomRight


class valueLadderType(object):
    r"""

    hou.valueLadderType

    Enumeration of the different value ladder types.

    See hou.ui.openValueLadder.

    VALUES


        Generic
            The ladder is being used to manipulate a generic numeric value.
            The step sizes for this ladder type range from 0.0001 to 100.0.

        Angle
            The ladder is being used to manipulate a value representing an
            angle. The step sizes for this ladder type range from 1.0 to
            45.0.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_valueLadderType


# Register valueLadderType in _hou:
_hou.valueLadderType_swigregister(valueLadderType)
valueLadderType.Generic = _hou.cvar.valueLadderType_Generic
valueLadderType.Angle = _hou.cvar.valueLadderType_Angle


class valueLadderDataType(object):
    r"""

    hou.valueLadderDataType

    Enumeration of the different data types that may be manipulated by a
    value ladder.

    See hou.ui.openValueLadder.

    VALUES


        Float
            The ladder is being used to manipulate a single floating point
            value.

        Int
            The ladder is being used to manipulate a single integer value.

        FloatArray
            The ladder is being used to manipulate an array of floating
            point values.

        IntArray
            The ladder is being used to manipulate an array of integer
            values.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_valueLadderDataType


# Register valueLadderDataType in _hou:
_hou.valueLadderDataType_swigregister(valueLadderDataType)
valueLadderDataType.Float = _hou.cvar.valueLadderDataType_Float
valueLadderDataType.Int = _hou.cvar.valueLadderDataType_Int
valueLadderDataType.FloatArray = _hou.cvar.valueLadderDataType_FloatArray
valueLadderDataType.IntArray = _hou.cvar.valueLadderDataType_IntArray


class promptMessageType(object):
    r"""

    hou.promptMessageType

    Viewport Prompt Message Type

    Defines the type of messages that can be used with
    hou.SceneViewer.setPromptMessage.

    VALUES


        hou.promptMessageType.Error
            Specifies an error message displayed in bold red.

        hou.promptMessageType.Message
            Specifies a regular message displayed in black.

        hou.promptMessageType.Prompt
            Specifies a prompt message displayed in bold blue.

        hou.promptMessageType.Warning
            Specifies a warning message displayed in bold yellow.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_promptMessageType


# Register promptMessageType in _hou:
_hou.promptMessageType_swigregister(promptMessageType)
promptMessageType.Error = _hou.cvar.promptMessageType_Error
promptMessageType.Message = _hou.cvar.promptMessageType_Message
promptMessageType.Prompt = _hou.cvar.promptMessageType_Prompt
promptMessageType.Warning = _hou.cvar.promptMessageType_Warning


class drawableDisplayMode(object):
    r"""

    hou.drawableDisplayMode

    Enumerator for the drawable display mode.

    VALUES


        hou.drawableDisplayMode.CurrentViewportMode
            Specifies the display mode currently active in the viewport.

        hou.drawableDisplayMode.WireframeMode
            Specifies the display mode as wireframe.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableDisplayMode


# Register drawableDisplayMode in _hou:
_hou.drawableDisplayMode_swigregister(drawableDisplayMode)
drawableDisplayMode.CurrentViewportMode = (
    _hou.cvar.drawableDisplayMode_CurrentViewportMode
)
drawableDisplayMode.WireframeMode = _hou.cvar.drawableDisplayMode_WireframeMode


class scaleInheritanceMode(object):
    r"""

    hou.scaleInheritanceMode

    Enumeration of scale inheritance modes for transforms.

    VALUES


        Default
            Simple inheritance: world = local * parent_world

        OffsetOnly
            Child doesn't scale with the parent local scales, but local
            translation is scaled: world = local_scale_rotates *
            parent_local_scales.inverted() * local_translates * parent_world

        OffsetAndScale
            Local translation is scaled as before but parent local scaling
            is also reapplied by the child in local space: world =
            parent_local_scales * local_scale_rotates *
            parent_local_scales.inverted() * local_translates * parent_world

        ScaleOnly
            Local translation is not scaled, but parent local scaling is
            reapplied by the child in local space: world =
            parent_local_scales * local * parent_local_scales.inverted() *
            parent_world

        Ignore
            Child completely ignores any parent local scaling: world = local
            * parent_local_scales.inverted() * parent_world


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_scaleInheritanceMode


# Register scaleInheritanceMode in _hou:
_hou.scaleInheritanceMode_swigregister(scaleInheritanceMode)
scaleInheritanceMode.Default = _hou.cvar.scaleInheritanceMode_Default
scaleInheritanceMode.OffsetOnly = _hou.cvar.scaleInheritanceMode_OffsetOnly
scaleInheritanceMode.OffsetAndScale = _hou.cvar.scaleInheritanceMode_OffsetAndScale
scaleInheritanceMode.ScaleOnly = _hou.cvar.scaleInheritanceMode_ScaleOnly
scaleInheritanceMode.Ignore = _hou.cvar.scaleInheritanceMode_Ignore


class uiEventValueType(object):
    r"""

    hou.uiEventValueType

    Enumerator for UI event value types.

    Represents the type of value stored in a hou.UIEvent object.

    VALUES


        hou.uiEventValueType.Float
            float value type.

        hou.uiEventValueType.FloatArray
            Array of float values.

        hou.uiEventValueType.IntArray
            Array of int values.

        hou.uiEventValueType.Integer
            int value type.

        hou.uiEventValueType.NoType
            invalid value type.

        hou.uiEventValueType.String
            string value type.

        hou.uiEventValueType.StringArray
            Array of string values.

    RELATED

        hou.UIEvent.valueType


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_uiEventValueType


# Register uiEventValueType in _hou:
_hou.uiEventValueType_swigregister(uiEventValueType)
uiEventValueType.Float = _hou.cvar.uiEventValueType_Float
uiEventValueType.Integer = _hou.cvar.uiEventValueType_Integer
uiEventValueType.String = _hou.cvar.uiEventValueType_String
uiEventValueType.FloatArray = _hou.cvar.uiEventValueType_FloatArray
uiEventValueType.IntArray = _hou.cvar.uiEventValueType_IntArray
uiEventValueType.StringArray = _hou.cvar.uiEventValueType_StringArray
uiEventValueType.NoType = _hou.cvar.uiEventValueType_NoType


class uiEventReason(object):
    r"""

    hou.uiEventReason

    Values representing reasons Houdini generated a particular UI event.

    Calling hou.UIEvent.reason returns one of the following values.

    VALUES


        Picked
            Quick mouse click without dragging.

        Start
            Left mouse button pressed (mouse down)

        Active
            Mouse dragged with the left mouse button down.

        Changed
            Left mouse button released (mouse up).

        Located
            Mouse pointer hovered over something in the interface. In a
            viewer state, this is the reason associated with mouse moves.

        ItemsChanged
            Event generated as a change of values in hou.UIEvent

        New
            Event generated when a UI element was assigned a different
            value.

        RangeChanged
            Event generated when a slider or scrollbar has changed.

        NoReason
            Event was likely explicitly generated.

    RELATED

        hou.UIEvent.reason


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_uiEventReason


# Register uiEventReason in _hou:
_hou.uiEventReason_swigregister(uiEventReason)
uiEventReason.NoReason = _hou.cvar.uiEventReason_NoReason
uiEventReason.Changed = _hou.cvar.uiEventReason_Changed
uiEventReason.Active = _hou.cvar.uiEventReason_Active
uiEventReason.Start = _hou.cvar.uiEventReason_Start
uiEventReason.New = _hou.cvar.uiEventReason_New
uiEventReason.RangeChanged = _hou.cvar.uiEventReason_RangeChanged
uiEventReason.Picked = _hou.cvar.uiEventReason_Picked
uiEventReason.Located = _hou.cvar.uiEventReason_Located
uiEventReason.ItemsChanged = _hou.cvar.uiEventReason_ItemsChanged


class drawablePrimitive(object):
    r"""

    hou.drawablePrimitive

    Enumerator for the drawable primitive types.

    VALUES


        hou.drawablePrimitive.Circle
        hou.drawablePrimitive.Sphere
        hou.drawablePrimitive.Tube


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawablePrimitive


# Register drawablePrimitive in _hou:
_hou.drawablePrimitive_swigregister(drawablePrimitive)
drawablePrimitive.Circle = _hou.cvar.drawablePrimitive_Circle
drawablePrimitive.Sphere = _hou.cvar.drawablePrimitive_Sphere
drawablePrimitive.Tube = _hou.cvar.drawablePrimitive_Tube


class resourceEventMessage(object):
    r"""

    hou.resourceEventMessage

    Enumeration of the resource events that can be handled by callback
    functions.

    See hou.ui.addResourceEventCallback.

    VALUES


        OnActivate
            Event triggered after a viewer handle has been activated.

        OnCustomEvent
            Event triggered when hou.ui.fireResourceCustomEvent is called.

        OnDeactivate
            Event triggered after a viewer handle has been deactivated.

        OnExit
            Event triggered after a viewer state ends.

        OnEnter
            Event triggered after a viewer state begins.

        OnExit
            Event triggered after a viewer state ends.

        OnGenerate
            Event triggered after a nodeless viewer state begins.

        OnInterrupt
            Event triggered after a viewer state has been interrupted.

        OnLoad
            Event triggered after a package has been successsfully loaded.

        OnPreEnter
            Event triggered before a viewer state begins.

        OnPrintMessage
            Event triggered when hou.ui.printViewerStateMessage is called.

        OnReload
            Event triggered after a viewer state or package has been
            successsfully reloaded.

        OnResume
            Event triggered after a viewer state has resumed after an
            interruption.

        OnRegister
            Event triggered after a viewer state has been successfully
            registered.

        OnUnload
            Event triggered after a package has been successsfully unloaded.

        OnUnregister
            Event triggered after a viewer state has been successfully un-
            registered.

        OnRuntimeError
            Event triggered when a runtime error occurs during a viewer
            state operation.

        NoEventType
            An invalid viewer state event type.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_resourceEventMessage


# Register resourceEventMessage in _hou:
_hou.resourceEventMessage_swigregister(resourceEventMessage)
resourceEventMessage.NoEventType = _hou.cvar.resourceEventMessage_NoEventType
resourceEventMessage.OnCustomEvent = _hou.cvar.resourceEventMessage_OnCustomEvent
resourceEventMessage.OnEnter = _hou.cvar.resourceEventMessage_OnEnter
resourceEventMessage.OnExit = _hou.cvar.resourceEventMessage_OnExit
resourceEventMessage.OnGenerate = _hou.cvar.resourceEventMessage_OnGenerate
resourceEventMessage.OnInterrupt = _hou.cvar.resourceEventMessage_OnInterrupt
resourceEventMessage.OnPreEnter = _hou.cvar.resourceEventMessage_OnPreEnter
resourceEventMessage.OnPrintMessage = _hou.cvar.resourceEventMessage_OnPrintMessage
resourceEventMessage.OnRegister = _hou.cvar.resourceEventMessage_OnRegister
resourceEventMessage.OnReload = _hou.cvar.resourceEventMessage_OnReload
resourceEventMessage.OnResume = _hou.cvar.resourceEventMessage_OnResume
resourceEventMessage.OnRuntimeError = _hou.cvar.resourceEventMessage_OnRuntimeError
resourceEventMessage.OnUnregister = _hou.cvar.resourceEventMessage_OnUnregister
resourceEventMessage.OnActivate = _hou.cvar.resourceEventMessage_OnActivate
resourceEventMessage.OnDeactivate = _hou.cvar.resourceEventMessage_OnDeactivate
resourceEventMessage.OnLoad = _hou.cvar.resourceEventMessage_OnLoad
resourceEventMessage.OnUnload = _hou.cvar.resourceEventMessage_OnUnload


class snappingPriority(object):
    r"""

    hou.snappingPriority

    Enumeration of snapping priority.

    See hou.SceneViewer.snappingPriority.

    VALUES


        GeoEdge
            Edge between two GeoPoints

        GeoPoint
            Point on a geometry

        Midpoint
            Midpoint of a GeoEdge

        GeoPrim
            Primitive on a geometry

        Breakpoint
            Control point on a NURBS curve or surface

        GridPoint
            Point on the construction plane, reference plane, or on the grid
            in the ortho/uv viewports

        GridEdge
            Edge of the construction plane, reference plane, or of the grid
            in the ortho/uv viewports

        PrimGuidePoint
            Point on the guide geometry for a primitive sphere/tube/etc.

        PrimGuideEdge
            Edge on the guide geometry for a primitive sphere/tube/etc.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_snappingPriority


# Register snappingPriority in _hou:
_hou.snappingPriority_swigregister(snappingPriority)
snappingPriority.GeoEdge = _hou.cvar.snappingPriority_GeoEdge
snappingPriority.GeoPoint = _hou.cvar.snappingPriority_GeoPoint
snappingPriority.GeoPrim = _hou.cvar.snappingPriority_GeoPrim
snappingPriority.Midpoint = _hou.cvar.snappingPriority_Midpoint
snappingPriority.Breakpoint = _hou.cvar.snappingPriority_Breakpoint
snappingPriority.GridPoint = _hou.cvar.snappingPriority_GridPoint
snappingPriority.GridEdge = _hou.cvar.snappingPriority_GridEdge
snappingPriority.PrimGuidePoint = _hou.cvar.snappingPriority_PrimGuidePoint
snappingPriority.PrimGuideEdge = _hou.cvar.snappingPriority_PrimGuideEdge


class triggerSelectorAction(object):
    r"""

    hou.triggerSelectorAction

    Enumerator representing the type of action a state selector can perform
    if triggered with hou.SceneViewer.triggerStateSelector.

    VALUES


        Start
            Activate a selector.

        Stop
            Deactivate a selector.

        Toggle
            Start or stop a selector depending of the current selector
            state. If currently stopped, the selector is started otherwise
            it is stopped.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_triggerSelectorAction


# Register triggerSelectorAction in _hou:
_hou.triggerSelectorAction_swigregister(triggerSelectorAction)
triggerSelectorAction.Start = _hou.cvar.triggerSelectorAction_Start
triggerSelectorAction.Stop = _hou.cvar.triggerSelectorAction_Stop
triggerSelectorAction.Toggle = _hou.cvar.triggerSelectorAction_Toggle


class drawableGeometryType(object):
    r"""

    hou.drawableGeometryType

    Enumeration of Geometry Drawable types.

    See hou.AdvancedDrawable See hou.GeometryDrawable

    VALUES


        Face
            Face drawable type. This drawable allows you to highlight the
            polygons of the attached geometry.

        Line
            Line drawable type. This drawable allows you to highlight the
            polygon edges of the attached geometry.

        Point
            Point drawable type. This drawable allows you to highlight the
            polygon vertices of the attached geometry.

        Vector
            Vector drawable type. This drawable works with point geometries
            and allows you to draw vectors at each point. Note that a point
            attribute N is required for the Vector drawable type.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableGeometryType


# Register drawableGeometryType in _hou:
_hou.drawableGeometryType_swigregister(drawableGeometryType)
drawableGeometryType.Line = _hou.cvar.drawableGeometryType_Line
drawableGeometryType.Face = _hou.cvar.drawableGeometryType_Face
drawableGeometryType.Point = _hou.cvar.drawableGeometryType_Point
drawableGeometryType.Vector = _hou.cvar.drawableGeometryType_Vector


class drawableTextOrigin(object):
    r"""

    hou.drawableTextOrigin

    Enumeration used with hou.TextDrawable to specify the reference point of
    the text within its bounding box.

    VALUES


        BottomLeft
            Set the text reference point at the bottom left position of the
            bounding box.

        BottomCenter
            Set the text reference point at the bottom center position of
            the bounding box.

        BottomRight
            Set the text reference point at the bottom right position of the
            bounding box.

        LeftCenter
            Set the text reference point at the left center position of the
            bounding box.

        RightCenter
            Set the text reference point at the right center position of the
            bounding box.

        UpperLeft
            Set the text reference point at the upper left position of the
            bounding box.

        UpperCenter
            Set the text reference point at the upper center position of the
            bounding box.

        UpperRight
            Set the text reference point at the upper right position of the
            bounding box.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableTextOrigin


# Register drawableTextOrigin in _hou:
_hou.drawableTextOrigin_swigregister(drawableTextOrigin)
drawableTextOrigin.BottomLeft = _hou.cvar.drawableTextOrigin_BottomLeft
drawableTextOrigin.BottomCenter = _hou.cvar.drawableTextOrigin_BottomCenter
drawableTextOrigin.BottomRight = _hou.cvar.drawableTextOrigin_BottomRight
drawableTextOrigin.LeftCenter = _hou.cvar.drawableTextOrigin_LeftCenter
drawableTextOrigin.RightCenter = _hou.cvar.drawableTextOrigin_RightCenter
drawableTextOrigin.UpperLeft = _hou.cvar.drawableTextOrigin_UpperLeft
drawableTextOrigin.UpperCenter = _hou.cvar.drawableTextOrigin_UpperCenter
drawableTextOrigin.UpperRight = _hou.cvar.drawableTextOrigin_UpperRight


class drawableGeometryFaceStyle(object):
    r"""

    hou.drawableGeometryFaceStyle

    Enumeration used with hou.GeometryDrawable to specify the style of faces
    to draw.

    VALUES


        Plain
            Regular face

        Checker
            Draws faces in a checker patterm.

        Circle
            Draws faces in a circle patterm.

        Columns
            Draws faces in columns.

        Rows
            Draws faces in rows.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableGeometryFaceStyle


# Register drawableGeometryFaceStyle in _hou:
_hou.drawableGeometryFaceStyle_swigregister(drawableGeometryFaceStyle)
drawableGeometryFaceStyle.Plain = _hou.cvar.drawableGeometryFaceStyle_Plain
drawableGeometryFaceStyle.Columns = _hou.cvar.drawableGeometryFaceStyle_Columns
drawableGeometryFaceStyle.Rows = _hou.cvar.drawableGeometryFaceStyle_Rows
drawableGeometryFaceStyle.Checker = _hou.cvar.drawableGeometryFaceStyle_Checker
drawableGeometryFaceStyle.Circle = _hou.cvar.drawableGeometryFaceStyle_Circle


class drawableGeometryLineStyle(object):
    r"""

    hou.drawableGeometryLineStyle

    Enumeration used with hou.GeometryDrawable to specify the style of lines
    to draw.

    VALUES


        Plain
            Regular line.

        Dash1
            Draw half of the line.

        Dash2
            Draw one third of the line.

        Dash3
            Draw one quarter of the line.

        Dot1
            Draw a continuous line of dots.

        Dot2
            Draw every second dot.

        Dot3
            Draw every fourth dot.

        Dot4
            Draw every eighth dot.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableGeometryLineStyle


# Register drawableGeometryLineStyle in _hou:
_hou.drawableGeometryLineStyle_swigregister(drawableGeometryLineStyle)
drawableGeometryLineStyle.Plain = _hou.cvar.drawableGeometryLineStyle_Plain
drawableGeometryLineStyle.Dash1 = _hou.cvar.drawableGeometryLineStyle_Dash1
drawableGeometryLineStyle.Dash2 = _hou.cvar.drawableGeometryLineStyle_Dash2
drawableGeometryLineStyle.Dash3 = _hou.cvar.drawableGeometryLineStyle_Dash3
drawableGeometryLineStyle.Dot1 = _hou.cvar.drawableGeometryLineStyle_Dot1
drawableGeometryLineStyle.Dot2 = _hou.cvar.drawableGeometryLineStyle_Dot2
drawableGeometryLineStyle.Dot3 = _hou.cvar.drawableGeometryLineStyle_Dot3
drawableGeometryLineStyle.Dot4 = _hou.cvar.drawableGeometryLineStyle_Dot4


class drawableGeometryPointStyle(object):
    r"""

    hou.drawableGeometryPointStyle

    Enumeration used with hou.GeometryDrawable to specify the style of
    points to draw.

    VALUES


        LinearCircle
            Linear circle

        LinearSquare
            Linear square

        RingsCircle
            Circular rings

        RingsSquare
            Square rings

        SmoothCircle
            Smooth circle

        SmoothSquare
            Smooth square

        ArrowUp
            Arrow pointing up.

        Cross
            Cross

        Cube
            3D cube

        Diamond
            Diamond shape

        Diamond2
            Diamond shape with dash lines.

        Diamond3
            Diamond-cross shape with dash lines.

        Flare
            Flare shape.

        Frame
            Simple frame.

        Frame2
            Frame with dash lines.

        Frame3
            Frame with dotted line.

        Locate
            Locate-arrow shape.

        Locate2
            Simple locate shape.

        Plus
            Plus sign.

        Ring
            Simple ring.

        Ring2
            Simple ring with dashed line.

        Ring3
            Two color ring.

        Ring4
            Ring with triple lines.

        Ring5
            Dotted ring.

        Target1
            Target shape 1.

        Target2
            Target shape 2.

        Target3
            Target shape 3.

        Target4
            Target shape 4.

        TriangleDown
            Triangle pointing down.

        TriangleUp
            Triangle pointing up.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableGeometryPointStyle


# Register drawableGeometryPointStyle in _hou:
_hou.drawableGeometryPointStyle_swigregister(drawableGeometryPointStyle)
drawableGeometryPointStyle.LinearCircle = (
    _hou.cvar.drawableGeometryPointStyle_LinearCircle
)
drawableGeometryPointStyle.LinearSquare = (
    _hou.cvar.drawableGeometryPointStyle_LinearSquare
)
drawableGeometryPointStyle.SmoothCircle = (
    _hou.cvar.drawableGeometryPointStyle_SmoothCircle
)
drawableGeometryPointStyle.SmoothSquare = (
    _hou.cvar.drawableGeometryPointStyle_SmoothSquare
)
drawableGeometryPointStyle.RingsCircle = (
    _hou.cvar.drawableGeometryPointStyle_RingsCircle
)
drawableGeometryPointStyle.RingsSquare = (
    _hou.cvar.drawableGeometryPointStyle_RingsSquare
)
drawableGeometryPointStyle.ArrowUp = _hou.cvar.drawableGeometryPointStyle_ArrowUp
drawableGeometryPointStyle.Cross = _hou.cvar.drawableGeometryPointStyle_Cross
drawableGeometryPointStyle.Cube = _hou.cvar.drawableGeometryPointStyle_Cube
drawableGeometryPointStyle.Diamond = _hou.cvar.drawableGeometryPointStyle_Diamond
drawableGeometryPointStyle.Diamond2 = _hou.cvar.drawableGeometryPointStyle_Diamond2
drawableGeometryPointStyle.Diamond3 = _hou.cvar.drawableGeometryPointStyle_Diamond3
drawableGeometryPointStyle.Flare = _hou.cvar.drawableGeometryPointStyle_Flare
drawableGeometryPointStyle.Frame = _hou.cvar.drawableGeometryPointStyle_Frame
drawableGeometryPointStyle.Frame2 = _hou.cvar.drawableGeometryPointStyle_Frame2
drawableGeometryPointStyle.Frame3 = _hou.cvar.drawableGeometryPointStyle_Frame3
drawableGeometryPointStyle.Locate = _hou.cvar.drawableGeometryPointStyle_Locate
drawableGeometryPointStyle.Locate2 = _hou.cvar.drawableGeometryPointStyle_Locate2
drawableGeometryPointStyle.Plus = _hou.cvar.drawableGeometryPointStyle_Plus
drawableGeometryPointStyle.Ring = _hou.cvar.drawableGeometryPointStyle_Ring
drawableGeometryPointStyle.Ring2 = _hou.cvar.drawableGeometryPointStyle_Ring2
drawableGeometryPointStyle.Ring3 = _hou.cvar.drawableGeometryPointStyle_Ring3
drawableGeometryPointStyle.Ring4 = _hou.cvar.drawableGeometryPointStyle_Ring4
drawableGeometryPointStyle.Ring5 = _hou.cvar.drawableGeometryPointStyle_Ring5
drawableGeometryPointStyle.Target1 = _hou.cvar.drawableGeometryPointStyle_Target1
drawableGeometryPointStyle.Target2 = _hou.cvar.drawableGeometryPointStyle_Target2
drawableGeometryPointStyle.Target3 = _hou.cvar.drawableGeometryPointStyle_Target3
drawableGeometryPointStyle.Target4 = _hou.cvar.drawableGeometryPointStyle_Target4
drawableGeometryPointStyle.TriangleDown = (
    _hou.cvar.drawableGeometryPointStyle_TriangleDown
)
drawableGeometryPointStyle.TriangleUp = _hou.cvar.drawableGeometryPointStyle_TriangleUp


class drawableRampClamp(object):
    r"""

    hou.drawableRampClamp

    Enumeration used with hou.GeometryDrawable to specify how to wrap the
    texture generated when using a ramp color (similar to OpenGL texture
    settings).

    VALUES


        Border
            Border texture clamping.

        Edge
            Edge texture clamping.

        Mirror
            Mirror repeat texture clamping.

        Repeat
            Repeat texture clamping.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableRampClamp


# Register drawableRampClamp in _hou:
_hou.drawableRampClamp_swigregister(drawableRampClamp)
drawableRampClamp.Repeat = _hou.cvar.drawableRampClamp_Repeat
drawableRampClamp.Border = _hou.cvar.drawableRampClamp_Border
drawableRampClamp.Edge = _hou.cvar.drawableRampClamp_Edge
drawableRampClamp.Mirror = _hou.cvar.drawableRampClamp_Mirror


class drawableHighlightMode(object):
    r"""

    hou.drawableHighlightMode

    Enumeration used with hou.AdvancedDrawable to specify the highlight mode
    of a drawable matte.

    VALUES


        Glow
            Display the drawable with a glow by using the color2 parameter.

        Matte
            Display the drawable matte only by using the color1 parameter.

        GlowMinusMatte
            Display a glow around the drawable without drawing the matte,
            typically used to draw a silhouette.

        MatteOverGlow
            Display the matte over the glow.

        Transparent
            Make the drawable completely transparent. Useful to hide parts
            of other drawables.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_drawableHighlightMode


# Register drawableHighlightMode in _hou:
_hou.drawableHighlightMode_swigregister(drawableHighlightMode)
drawableHighlightMode.Glow = _hou.cvar.drawableHighlightMode_Glow
drawableHighlightMode.Matte = _hou.cvar.drawableHighlightMode_Matte
drawableHighlightMode.GlowMinusMatte = _hou.cvar.drawableHighlightMode_GlowMinusMatte
drawableHighlightMode.MatteOverGlow = _hou.cvar.drawableHighlightMode_MatteOverGlow
drawableHighlightMode.Transparent = _hou.cvar.drawableHighlightMode_Transparent


class secureSelectionOption(object):
    r"""

    hou.secureSelectionOption

    Enumeration of the secure selection options used by viewer state
    selectors.

    Used by:

      * hou.ViewerStateTemplate.bindGeometrySelector

      * hou.ViewerStateTemplate.bindObjectSelector

      * hou.ViewerStateTemplate.bindSceneGraphSelector

      * hou.ViewerStateTemplate.bindDynamicsSelector

      * hou.ViewerStateTemplate.bindDynamicsPointSelector

      * hou.ViewerStateTemplate.bindDynamicsPolygonSelector

    VALUES


        Ignore
            Selector ignores the viewer's secure selection setting.

        Obey
            Selector obeys the viewer's secure selection setting.

        On
            Selector sets the viewer's secure selection to On when it
            starts.

        Off
            Selector sets the viewer's secure selection to Off when it
            starts.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_secureSelectionOption


# Register secureSelectionOption in _hou:
_hou.secureSelectionOption_swigregister(secureSelectionOption)
secureSelectionOption.Ignore = _hou.cvar.secureSelectionOption_Ignore
secureSelectionOption.Obey = _hou.cvar.secureSelectionOption_Obey
secureSelectionOption.On = _hou.cvar.secureSelectionOption_On
secureSelectionOption.Off = _hou.cvar.secureSelectionOption_Off


class resourceType(object):
    r"""

    hou.resourceType

    Enumeration of resources such as viewer states and viewer handles.

    See hou.ui.addResourceEventCallback

    VALUES


        ViewerState
            Viewer State resource.

        ViewerHandle
            Viewer Handle resource.

        Package
            Package resource.

        NoType
            Not a valid type.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_resourceType


# Register resourceType in _hou:
_hou.resourceType_swigregister(resourceType)
resourceType.NoType = _hou.cvar.resourceType_NoType
resourceType.ViewerState = _hou.cvar.resourceType_ViewerState
resourceType.ViewerHandle = _hou.cvar.resourceType_ViewerHandle
resourceType.Package = _hou.cvar.resourceType_Package


class geometryViewportEvent(object):
    r"""

    hou.geometryViewportEvent

    Enumeration of the geometry viewport events that can be handled by
    callback functions.

    See hou.GeometryViewport.addEventCallback.

    VALUES


        CameraSwitched
            This event is triggered when the viewport camera has been
            switched to a different one.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_geometryViewportEvent


# Register geometryViewportEvent in _hou:
_hou.geometryViewportEvent_swigregister(geometryViewportEvent)
geometryViewportEvent.CameraSwitched = _hou.cvar.geometryViewportEvent_CameraSwitched


class sceneViewerEvent(object):
    r"""

    hou.sceneViewerEvent

    Enumeration of the UI events a scene viewer can listen to via a
    callback.

    See hou.SceneViewer.addEventCallback.

    VALUES


        BeginResize
            Sent when the user has started resizing a viewer window when
            dragging the viewer frame.

        EndResize
            This event is sent when the user has ended resizing a viewer
            window when dragging the viewer frame.

        SizeChanged
            This event is sent whenever a viewer window is being resized,
            maximized or minimized.

        LayoutChanged
            Sent when the viewport layout has been changed.

        ColorSchemeChanged
            Sent when the viewer color scheme has changed. The color scheme
            can be changed in the Display options.

        SelectedViewportChanged
            Sent when a viewport has been selected. Viewports can be
            selected by holding [Space] and pressing the [N] key.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_sceneViewerEvent


# Register sceneViewerEvent in _hou:
_hou.sceneViewerEvent_swigregister(sceneViewerEvent)
sceneViewerEvent.BeginResize = _hou.cvar.sceneViewerEvent_BeginResize
sceneViewerEvent.EndResize = _hou.cvar.sceneViewerEvent_EndResize
sceneViewerEvent.SizeChanged = _hou.cvar.sceneViewerEvent_SizeChanged
sceneViewerEvent.LayoutChanged = _hou.cvar.sceneViewerEvent_LayoutChanged
sceneViewerEvent.ColorSchemeChanged = _hou.cvar.sceneViewerEvent_ColorSchemeChanged
sceneViewerEvent.SelectedViewportChanged = (
    _hou.cvar.sceneViewerEvent_SelectedViewportChanged
)


class hudInfoState(object):
    r"""

    hou.hudInfoState

    Enumeration of states for controling the hou.hudPanel.ToolInfo panel.

    See hou.SceneViewer.hudInfo.

    VALUES


        Maximize
            Use this state to maximize the panel display.

        Minimize
            Use this state to minimize the panel display.

        Toggle
            Switch between the Minimize and Maximize state.

        NoState
            Not a valid state.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_hudInfoState


# Register hudInfoState in _hou:
_hou.hudInfoState_swigregister(hudInfoState)
hudInfoState.NoState = _hou.cvar.hudInfoState_NoState
hudInfoState.Maximize = _hou.cvar.hudInfoState_Maximize
hudInfoState.Minimize = _hou.cvar.hudInfoState_Minimize
hudInfoState.Toggle = _hou.cvar.hudInfoState_Toggle


class hudPanel(object):
    r"""

    hou.hudPanel

    Enumeration to identify the HUD panel types.

    See hou.SceneViewer.hudInfo.

    VALUES


        ToolInfo
            Panel for displaying settings and usage hints for the running
            state. The HUD is located at the viewport top-left.

        User
            Displays user-defined information. The User HUD is located at
            the viewport bottom-left.

        NoPanel
            Not a valid panel.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_hudPanel


# Register hudPanel in _hou:
_hou.hudPanel_swigregister(hudPanel)
hudPanel.NoPanel = _hou.cvar.hudPanel_NoPanel
hudPanel.ToolInfo = _hou.cvar.hudPanel_ToolInfo
hudPanel.User = _hou.cvar.hudPanel_User


class scrollPosition(object):
    r"""

    hou.scrollPosition

    Enumeration of scrolling position modes.

    See hou.NetworkEditor.parmScrollTo. See hou.ParameterEditor.scrollTo.

    VALUES


        Auto
            Adjust the scroll only when the parameter bounding box is
            outside the current scroll window. Uses top alignment if the
            bounding box was above the scroll window or bottom alignment
            otherwise.

        Top
            Adjust the scroll aligning the top of the parameter bounding box
            to the top of the scroll window.

        Center
            Adjust the scroll aligning the center of the parameter bounding
            box to the center of the scroll window.

        Bottom
            Adjust the scroll aligning the bottom of the parameter bounding
            box to the bottom of the scroll window.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_scrollPosition


# Register scrollPosition in _hou:
_hou.scrollPosition_swigregister(scrollPosition)
scrollPosition.Auto = _hou.cvar.scrollPosition_Auto
scrollPosition.Top = _hou.cvar.scrollPosition_Top
scrollPosition.Center = _hou.cvar.scrollPosition_Center
scrollPosition.Bottom = _hou.cvar.scrollPosition_Bottom


class parmFilterMode(object):
    r"""

    hou.parmFilterMode

    Enumeration of Parameter filter modes.

    See Searching and filtering parameters See
    hou.NetworkEditor.parmFilterMode. See
    hou.NetworkEditor.setParmFilterMode. See hou.ParameterEditor.filterMode.
    See hou.ParameterEditor.setFilterMode.

    VALUES


        AllParms
        AllParmsAndHeadings
        TimeDependentParms
        ScopedParms
        AutoScopedParms
        GraphSelectedParms
        NonDefaultParms
        ParmsWithExpressions
        ParmsWithOverrides
        InvisibleParms
        VisibleAndInvisibleParms
        SearchNoControlMenus


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmFilterMode


# Register parmFilterMode in _hou:
_hou.parmFilterMode_swigregister(parmFilterMode)
parmFilterMode.AllParms = _hou.cvar.parmFilterMode_AllParms
parmFilterMode.AllParmsAndHeadings = _hou.cvar.parmFilterMode_AllParmsAndHeadings
parmFilterMode.TimeDependentParms = _hou.cvar.parmFilterMode_TimeDependentParms
parmFilterMode.ScopedParms = _hou.cvar.parmFilterMode_ScopedParms
parmFilterMode.AutoScopedParms = _hou.cvar.parmFilterMode_AutoScopedParms
parmFilterMode.GraphSelectedParms = _hou.cvar.parmFilterMode_GraphSelectedParms
parmFilterMode.NonDefaultParms = _hou.cvar.parmFilterMode_NonDefaultParms
parmFilterMode.ParmsWithExpressions = _hou.cvar.parmFilterMode_ParmsWithExpressions
parmFilterMode.ParmsWithOverrides = _hou.cvar.parmFilterMode_ParmsWithOverrides
parmFilterMode.InvisibleParms = _hou.cvar.parmFilterMode_InvisibleParms
parmFilterMode.VisibleAndInvisibleParms = (
    _hou.cvar.parmFilterMode_VisibleAndInvisibleParms
)
parmFilterMode.SearchNoControlMenus = _hou.cvar.parmFilterMode_SearchNoControlMenus


class parmFilterCriteria(object):
    r"""

    hou.parmFilterCriteria

    Enumeration of Parameter filter criteria.

    See Searching and filtering parameters See
    hou.NetworkEditor.parmFilterCriteria. See
    hou.NetworkEditor.setParmFilterCriteria. See
    hou.ParameterEditor.filterCriteria. See
    hou.ParameterEditor.setFilterCriteria.

    VALUES


        NameOrLabel
        Name
        Label
        RawValue
        EvaluatedValue


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_parmFilterCriteria


# Register parmFilterCriteria in _hou:
_hou.parmFilterCriteria_swigregister(parmFilterCriteria)
parmFilterCriteria.NameOrLabel = _hou.cvar.parmFilterCriteria_NameOrLabel
parmFilterCriteria.Name = _hou.cvar.parmFilterCriteria_Name
parmFilterCriteria.Label = _hou.cvar.parmFilterCriteria_Label
parmFilterCriteria.RawValue = _hou.cvar.parmFilterCriteria_RawValue
parmFilterCriteria.EvaluatedValue = _hou.cvar.parmFilterCriteria_EvaluatedValue


class _ik_targetType(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete__ik_targetType


# Register _ik_targetType in _hou:
_hou._ik_targetType_swigregister(_ik_targetType)
_ik_targetType.Position = _hou.cvar._ik_targetType_Position
_ik_targetType.Orientation = _hou.cvar._ik_targetType_Orientation
_ik_targetType.All = _hou.cvar._ik_targetType_All


class agentShapeDeformerType(object):
    r"""

    hou.agentShapeDeformerType

    Enumeration of agent shape deformer types.

    Specifies the built-in shape deformer types, which can be used when
    creating a hou.AgentShapeDeformer.

    VALUES


        LinearSkinning
        DualQuatSkinning
        DualQuatBlendSkinning
        BlendShape
        BlendShapeAndLinearSkinning
        BlendShapeAndDualQuatSkinning
        BlendShapeAndDualQuatBlendSkinning


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_agentShapeDeformerType


# Register agentShapeDeformerType in _hou:
_hou.agentShapeDeformerType_swigregister(agentShapeDeformerType)
agentShapeDeformerType.LinearSkinning = _hou.cvar.agentShapeDeformerType_LinearSkinning
agentShapeDeformerType.DualQuatSkinning = (
    _hou.cvar.agentShapeDeformerType_DualQuatSkinning
)
agentShapeDeformerType.DualQuatBlendSkinning = (
    _hou.cvar.agentShapeDeformerType_DualQuatBlendSkinning
)
agentShapeDeformerType.BlendShape = _hou.cvar.agentShapeDeformerType_BlendShape
agentShapeDeformerType.BlendShapeAndLinearSkinning = (
    _hou.cvar.agentShapeDeformerType_BlendShapeAndLinearSkinning
)
agentShapeDeformerType.BlendShapeAndDualQuatSkinning = (
    _hou.cvar.agentShapeDeformerType_BlendShapeAndDualQuatSkinning
)
agentShapeDeformerType.BlendShapeAndDualQuatBlendSkinning = (
    _hou.cvar.agentShapeDeformerType_BlendShapeAndDualQuatBlendSkinning
)


class optionalBool(object):
    r"""

    hou.optionalBool

    Enumeration of a generic tri-state value.

    This enumeration is essentially a boolean value, but with the added
    possibility of expressing an explicit lack of opinion. As an example, a
    function may want to know the value of a toggle parameter. True or False
    values would turn the toggle on or off. A NoOpinion value would indicate
    that the parameter value should be left unchanged, because the caller
    has no opinion on what the value of the parameter should be.


    Yes
        Equivalent to a boolean True value.

    No
        Equivalent to a boolean False value.

    NoOpinion
        Indicates a lack of opinion.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_optionalBool


# Register optionalBool in _hou:
_hou.optionalBool_swigregister(optionalBool)
optionalBool.Yes = _hou.cvar.optionalBool_Yes
optionalBool.No = _hou.cvar.optionalBool_No
optionalBool.NoOpinion = _hou.cvar.optionalBool_NoOpinion


class SystemExit(Exception):
    r"""

    hou.SystemExit

    TIP
        Raising this exception yourself will have no effect. Call hou.exit
        to tell Houdini to quit.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def __init__(self, exit_code: "int"):
        r"""

        hou.SystemExit

        TIP
            Raising this exception yourself will have no effect. Call hou.exit
            to tell Houdini to quit.


        """
        _hou.SystemExit_swiginit(self, _hou.new_SystemExit(exit_code))

    def code(self) -> "int":
        r"""

        code(self) -> int

            The exit code Houdini will return to the OS when it exits.


        """
        return _hou.SystemExit_code(self)

    __swig_destroy__ = _hou.delete_SystemExit


# Register SystemExit in _hou:
_hou.SystemExit_swigregister(SystemExit)


class Error(Exception):
    r"""

    hou.Error

    Base class for all exceptions in the hou module.

    You can check if an exception instance is a Houdini-specific exception
    using isinstance(ex, hou.Error).

    You can catch all Houdini-specific exceptions in an except statement
    using except hou.Error:.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.Error

        Base class for all exceptions in the hou module.

        You can check if an exception instance is a Houdini-specific exception
        using isinstance(ex, hou.Error).

        You can catch all Houdini-specific exceptions in an except statement
        using except hou.Error:.


        """
        _hou.Error_swiginit(self, _hou.new_Error(*args))

    __swig_destroy__ = _hou.delete_Error

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.Error_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.Error_description(self)

    def instanceMessage(self) -> "std::string":
        r"""

        instanceMessage(self) -> str

            Return a message specific to the exception instance.


        """
        return _hou.Error_instanceMessage(self)

    def __repr__(self) -> "std::string":
        return _hou.Error___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.Error___str__(self)


# Register Error in _hou:
_hou.Error_swigregister(Error)


class NotAvailable(Error):
    r"""

    hou.NotAvailable

    Raised when you try to call an API function/method that is not
    available.

    A certain HOM function, class, or method may not be available due to
    Houdini running with a limited license.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.NotAvailable

        Raised when you try to call an API function/method that is not
        available.

        A certain HOM function, class, or method may not be available due to
        Houdini running with a limited license.


        """
        _hou.NotAvailable_swiginit(self, _hou.new_NotAvailable(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.NotAvailable_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.NotAvailable_description(self)

    def __repr__(self) -> "std::string":
        return _hou.NotAvailable___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.NotAvailable___str__(self)

    __swig_destroy__ = _hou.delete_NotAvailable


# Register NotAvailable in _hou:
_hou.NotAvailable_swigregister(NotAvailable)


class ObjectWasDeleted(Error):
    r"""

    hou.ObjectWasDeleted

    Raised when you try to access a reference to an object that has since
    been deleted.

    OVERVIEW

        For example, you might take a reference to a node:

      > >>> node = hou.node(\"/obj/geo1/sphere1\")

        If that node is later deleted, and then you try to use your
        reference to the deleted node, Houdini will raise this error:

      > >>> path = node.path()
      > hou.ObjectWasDeleted: ...

    TIPS AND TRICKS

      * There is no way to check if a reference is still valid, other than
        to try an operation and catch this error.

      * If you want to keep a long-ish term reference to a node, you might
        find it more convenient to instead keep a reference to the node's
        unique integer ID for the node in this session (hou.Node.sessionId).
        Then, when you want to use the node again, call hou.nodeBySessionId
        with the ID. It will return a reference to the node, or None if the
        node has since been deleted.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.ObjectWasDeleted

        Raised when you try to access a reference to an object that has since
        been deleted.

        OVERVIEW

            For example, you might take a reference to a node:

          > >>> node = hou.node(\"/obj/geo1/sphere1\")

            If that node is later deleted, and then you try to use your
            reference to the deleted node, Houdini will raise this error:

          > >>> path = node.path()
          > hou.ObjectWasDeleted: ...

        TIPS AND TRICKS

          * There is no way to check if a reference is still valid, other than
            to try an operation and catch this error.

          * If you want to keep a long-ish term reference to a node, you might
            find it more convenient to instead keep a reference to the node's
            unique integer ID for the node in this session (hou.Node.sessionId).
            Then, when you want to use the node again, call hou.nodeBySessionId
            with the ID. It will return a reference to the node, or None if the
            node has since been deleted.


        """
        _hou.ObjectWasDeleted_swiginit(self, _hou.new_ObjectWasDeleted(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.ObjectWasDeleted_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.ObjectWasDeleted_description(self)

    def __repr__(self) -> "std::string":
        return _hou.ObjectWasDeleted___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.ObjectWasDeleted___str__(self)

    __swig_destroy__ = _hou.delete_ObjectWasDeleted


# Register ObjectWasDeleted in _hou:
_hou.ObjectWasDeleted_swigregister(ObjectWasDeleted)


class InvalidInput(Error):
    r"""

    hou.InvalidInput

    Raised if you try to set a node's input to something invalid.

    The hou.Node API has various methods for wiring and un-wiring inputs and
    outputs in the network. If you try to wire an object into a node input
    that is not a node or is not allowed to be wired to that input, Houdini
    will raise this exception.

    Note that Houdini does allow certain wiring operations you might expect
    to fail (such as looping a node's output back into its own input) but
    then immediately flags them as errors in the network editor.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.InvalidInput

        Raised if you try to set a node's input to something invalid.

        The hou.Node API has various methods for wiring and un-wiring inputs and
        outputs in the network. If you try to wire an object into a node input
        that is not a node or is not allowed to be wired to that input, Houdini
        will raise this exception.

        Note that Houdini does allow certain wiring operations you might expect
        to fail (such as looping a node's output back into its own input) but
        then immediately flags them as errors in the network editor.


        """
        _hou.InvalidInput_swiginit(self, _hou.new_InvalidInput(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.InvalidInput_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.InvalidInput_description(self)

    def __repr__(self) -> "std::string":
        return _hou.InvalidInput___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.InvalidInput___str__(self)

    __swig_destroy__ = _hou.delete_InvalidInput


# Register InvalidInput in _hou:
_hou.InvalidInput_swigregister(InvalidInput)


class InvalidSize(Error):
    r"""

    hou.InvalidSize

    Raised when you pass a sequence of the wrong length to a function.

    There are occasionally methods in the HOM API where you must pass a
    sequence of values of an exact length... such as one value for each
    point in a geometry. If the sequence you pass to the method is the wrong
    size, Houdini raises this exception.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.InvalidSize

        Raised when you pass a sequence of the wrong length to a function.

        There are occasionally methods in the HOM API where you must pass a
        sequence of values of an exact length... such as one value for each
        point in a geometry. If the sequence you pass to the method is the wrong
        size, Houdini raises this exception.


        """
        _hou.InvalidSize_swiginit(self, _hou.new_InvalidSize(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.InvalidSize_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.InvalidSize_description(self)

    def __repr__(self) -> "std::string":
        return _hou.InvalidSize___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.InvalidSize___str__(self)

    __swig_destroy__ = _hou.delete_InvalidSize


# Register InvalidSize in _hou:
_hou.InvalidSize_swigregister(InvalidSize)


class OperationFailed(Error):
    r"""

    hou.OperationFailed

    Generic catch-all exception for various errors in Houdini that don't
    have their own dedicated exception classes.

    There are many ways for things to go wrong in Houdini. In general, types
    of errors only have a dedicated exception class if we anticipate a
    script author might need to detect that particular type of error in an
    exception handler, and take appropriate action.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.OperationFailed

        Generic catch-all exception for various errors in Houdini that don't
        have their own dedicated exception classes.

        There are many ways for things to go wrong in Houdini. In general, types
        of errors only have a dedicated exception class if we anticipate a
        script author might need to detect that particular type of error in an
        exception handler, and take appropriate action.


        """
        _hou.OperationFailed_swiginit(self, _hou.new_OperationFailed(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.OperationFailed_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.OperationFailed_description(self)

    def __repr__(self) -> "std::string":
        return _hou.OperationFailed___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.OperationFailed___str__(self)

    __swig_destroy__ = _hou.delete_OperationFailed


# Register OperationFailed in _hou:
_hou.OperationFailed_swigregister(OperationFailed)


class InvalidNodeType(Error):
    r"""

    hou.InvalidNodeType

    Raised if you try to call a method on a Node that doesn't support it.

    Even though subclassing generally makes it so methods only appear on
    objects that support them, there are node types that have optional
    features, or node types that might work differently from normal nodes
    (such as subnetworks and managers).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.InvalidNodeType

        Raised if you try to call a method on a Node that doesn't support it.

        Even though subclassing generally makes it so methods only appear on
        objects that support them, there are node types that have optional
        features, or node types that might work differently from normal nodes
        (such as subnetworks and managers).


        """
        _hou.InvalidNodeType_swiginit(self, _hou.new_InvalidNodeType(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.InvalidNodeType_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.InvalidNodeType_description(self)

    def __repr__(self) -> "std::string":
        return _hou.InvalidNodeType___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.InvalidNodeType___str__(self)

    __swig_destroy__ = _hou.delete_InvalidNodeType


# Register InvalidNodeType in _hou:
_hou.InvalidNodeType_swigregister(InvalidNodeType)


class InitScriptFailed(Error):
    r"""

    hou.InitScriptFailed

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.InitScriptFailed

        """
        _hou.InitScriptFailed_swiginit(self, _hou.new_InitScriptFailed(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.InitScriptFailed_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.InitScriptFailed_description(self)

    def __repr__(self) -> "std::string":
        return _hou.InitScriptFailed___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.InitScriptFailed___str__(self)

    __swig_destroy__ = _hou.delete_InitScriptFailed


# Register InitScriptFailed in _hou:
_hou.InitScriptFailed_swigregister(InitScriptFailed)


class MatchDefinitionError(Error):
    r"""

    hou.MatchDefinitionError

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.MatchDefinitionError

        """
        _hou.MatchDefinitionError_swiginit(self, _hou.new_MatchDefinitionError(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.MatchDefinitionError_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.MatchDefinitionError_description(self)

    def __repr__(self) -> "std::string":
        return _hou.MatchDefinitionError___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.MatchDefinitionError___str__(self)

    __swig_destroy__ = _hou.delete_MatchDefinitionError


# Register MatchDefinitionError in _hou:
_hou.MatchDefinitionError_swigregister(MatchDefinitionError)


class PermissionError(Error):
    r"""

    hou.PermissionError

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.PermissionError

        """
        _hou.PermissionError_swiginit(self, _hou.new_PermissionError(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.PermissionError_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.PermissionError_description(self)

    def instanceMessage(self) -> "std::string":
        r"""

        instanceMessage(self) -> str

            Return a message specific to the exception instance.


        """
        return _hou.PermissionError_instanceMessage(self)

    def __repr__(self) -> "std::string":
        return _hou.PermissionError___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.PermissionError___str__(self)

    __swig_destroy__ = _hou.delete_PermissionError


# Register PermissionError in _hou:
_hou.PermissionError_swigregister(PermissionError)


class GeometryPermissionError(Error):
    r"""

    hou.GeometryPermissionError

    Raised if you try to modify SOP geometry from outside of a Python SOP.

    OVERVIEW

      * Outside of the cook process, you can create your own hou.Geometry
        object and use methods and node verbs to manipulate the geometry.

      * When you get a Geometry object reference to the output of a geometry
        node (SOP), that reference is read-only (it represents the cached
        output of the node an so can't be changed). You can read/inspect the
        geometry. To modify the geometry, you must make a writable copy
        first.

      * If try to modify a Geometry object from SOPs outside of a Python
        SOP, Houdini will raise this error.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.GeometryPermissionError

        Raised if you try to modify SOP geometry from outside of a Python SOP.

        OVERVIEW

          * Outside of the cook process, you can create your own hou.Geometry
            object and use methods and node verbs to manipulate the geometry.

          * When you get a Geometry object reference to the output of a geometry
            node (SOP), that reference is read-only (it represents the cached
            output of the node an so can't be changed). You can read/inspect the
            geometry. To modify the geometry, you must make a writable copy
            first.

          * If try to modify a Geometry object from SOPs outside of a Python
            SOP, Houdini will raise this error.


        """
        _hou.GeometryPermissionError_swiginit(
            self, _hou.new_GeometryPermissionError(*args)
        )

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.GeometryPermissionError_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.GeometryPermissionError_description(self)

    def __repr__(self) -> "std::string":
        return _hou.GeometryPermissionError___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.GeometryPermissionError___str__(self)

    __swig_destroy__ = _hou.delete_GeometryPermissionError


# Register GeometryPermissionError in _hou:
_hou.GeometryPermissionError_swigregister(GeometryPermissionError)


class KeyframeValueNotSet(Error):
    r"""

    hou.KeyframeValueNotSet

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.KeyframeValueNotSet

        """
        _hou.KeyframeValueNotSet_swiginit(self, _hou.new_KeyframeValueNotSet(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.KeyframeValueNotSet_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.KeyframeValueNotSet_description(self)

    def __repr__(self) -> "std::string":
        return _hou.KeyframeValueNotSet___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.KeyframeValueNotSet___str__(self)

    __swig_destroy__ = _hou.delete_KeyframeValueNotSet


# Register KeyframeValueNotSet in _hou:
_hou.KeyframeValueNotSet_swigregister(KeyframeValueNotSet)


class OperationInterrupted(Error):
    r"""

    hou.OperationInterrupted

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.OperationInterrupted

        """
        _hou.OperationInterrupted_swiginit(self, _hou.new_OperationInterrupted(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.OperationInterrupted_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.OperationInterrupted_description(self)

    def __repr__(self) -> "std::string":
        return _hou.OperationInterrupted___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.OperationInterrupted___str__(self)

    __swig_destroy__ = _hou.delete_OperationInterrupted


# Register OperationInterrupted in _hou:
_hou.OperationInterrupted_swigregister(OperationInterrupted)


class LoadWarning(Error):
    r"""

    hou.LoadWarning

    Exception class for when loading a hip file in Houdini generates
    warnings.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.LoadWarning

        Exception class for when loading a hip file in Houdini generates
        warnings.


        """
        _hou.LoadWarning_swiginit(self, _hou.new_LoadWarning(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.LoadWarning_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.LoadWarning_description(self)

    def __repr__(self) -> "std::string":
        return _hou.LoadWarning___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.LoadWarning___str__(self)

    __swig_destroy__ = _hou.delete_LoadWarning


# Register LoadWarning in _hou:
_hou.LoadWarning_swigregister(LoadWarning)


class NodeError(Error):
    r"""

    hou.NodeError

    Raise this exception in a Python node to signal that the node is in
    error.

    OVERVIEW

        This is different from other exceptions that are typically raised by
        the system when something goes wrong, such as invalid inputs to a
        method call. This is an exception you, the author of a Python SOP,
        or Python Object, or Python LOP, etc., raise in the node's
        implementation script to set messages/warnings/errors on the node.

        Errors, warnings, and messages are part of a node's user interface.
        They show up in the network editor, parameter editor, and info
        window.

      * Errors signal to the node's user that the node has encountered an
        error. For example, invalid inputs or parameter values.

      * Warnings signal that the node was able to cook, but there was a
        problem the user might want to check. For example, a missing
        texture.

        See Writing Python SOPs for more information.


        TIP
            To mark the node with a warning instead of an error, raise
            hou.NodeWarning instead.

    EXAMPLE

        If you're writing a Python SOP, you might depend on information in
        an external file, specified by a parameter on the node:

      > thisnode = hou.pwd()
      > filepath = thisnode.parm(\"file\").evalAsString()
      > content = hou.readFile(filepath)
      > # ...

        If the file doesn't exist, you should raise this exception to signal
        to Houdini that the node could not cook, and specify an error
        message to help the user correct the problem:

      > import os.path
      >
      > thisnode = hou.pwd()
      > filepath = thisnode.parm(\"file\").evalAsString()
      >
      > if not os.path.exists(filepath):
      >     raise hou.NodeError(\"File {} does not exist\".format(filepath))
      >
      > content = hou.readFile()
      > # ...

    RELATED

      * hou.NodeWarning


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.NodeError

        Raise this exception in a Python node to signal that the node is in
        error.

        OVERVIEW

            This is different from other exceptions that are typically raised by
            the system when something goes wrong, such as invalid inputs to a
            method call. This is an exception you, the author of a Python SOP,
            or Python Object, or Python LOP, etc., raise in the node's
            implementation script to set messages/warnings/errors on the node.

            Errors, warnings, and messages are part of a node's user interface.
            They show up in the network editor, parameter editor, and info
            window.

          * Errors signal to the node's user that the node has encountered an
            error. For example, invalid inputs or parameter values.

          * Warnings signal that the node was able to cook, but there was a
            problem the user might want to check. For example, a missing
            texture.

            See Writing Python SOPs for more information.


            TIP
                To mark the node with a warning instead of an error, raise
                hou.NodeWarning instead.

        EXAMPLE

            If you're writing a Python SOP, you might depend on information in
            an external file, specified by a parameter on the node:

          > thisnode = hou.pwd()
          > filepath = thisnode.parm(\"file\").evalAsString()
          > content = hou.readFile(filepath)
          > # ...

            If the file doesn't exist, you should raise this exception to signal
            to Houdini that the node could not cook, and specify an error
            message to help the user correct the problem:

          > import os.path
          >
          > thisnode = hou.pwd()
          > filepath = thisnode.parm(\"file\").evalAsString()
          >
          > if not os.path.exists(filepath):
          >     raise hou.NodeError(\"File {} does not exist\".format(filepath))
          >
          > content = hou.readFile()
          > # ...

        RELATED

          * hou.NodeWarning


        """
        _hou.NodeError_swiginit(self, _hou.new_NodeError(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.NodeError_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.NodeError_description(self)

    def __repr__(self) -> "std::string":
        return _hou.NodeError___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.NodeError___str__(self)

    __swig_destroy__ = _hou.delete_NodeError


# Register NodeError in _hou:
_hou.NodeError_swigregister(NodeError)


class NodeWarning(Error):
    r"""

    hou.NodeWarning

    Raise this exception in a Python node to signal that the node has a
    warning.

    OVERVIEW

        This is different from other exceptions that are typically raised by
        the system when something goes wrong, such as invalid inputs to a
        method call. This is an exception you, the author of a Python SOP,
        or Python Object, or Python LOP, etc., raise in the node's
        implementation script to set messages/warnings/errors on the node.

        Errors, warnings, and messages are part of a node's user interface.
        They show up in the network editor, parameter editor, and info
        window.

      * Errors signal to the node's user that the node has encountered an
        error. For example, invalid inputs or parameter values.

      * Warnings signal that the node was able to cook, but there was a
        problem the user might want to check. For example, a missing
        texture.

        See Writing Python SOPs for more information.


        TIP
            To mark the node with an error instead of an error, raise
            hou.NodeError instead.


        NOTE
            Raise a warning exception at the end of the script, so the node
            script otherwise completes cooking.

    EXAMPLE

        If you're writing a Python SOP, you might use the content of an
        external file (referenced in a parameter on the node), even though
        the node can work without the file:

      > import os.path
      >
      > thisnode = hou.pwd()
      > filepath = thisnode.parm(\"file\").evalAsString()
      > content = hou.readFile()
      > if content:
      >     # Use the file contents
      >     # ...
      >
      > # Continue script operation
      > # ...
      >
      > # At the end of the script, raise any warning that might have
      > # come up during the script
      > if not content:
      >     raise NodeWarning(\"The texture file is missing or empty\")

    RELATED

      * hou.NodeWarning


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.NodeWarning

        Raise this exception in a Python node to signal that the node has a
        warning.

        OVERVIEW

            This is different from other exceptions that are typically raised by
            the system when something goes wrong, such as invalid inputs to a
            method call. This is an exception you, the author of a Python SOP,
            or Python Object, or Python LOP, etc., raise in the node's
            implementation script to set messages/warnings/errors on the node.

            Errors, warnings, and messages are part of a node's user interface.
            They show up in the network editor, parameter editor, and info
            window.

          * Errors signal to the node's user that the node has encountered an
            error. For example, invalid inputs or parameter values.

          * Warnings signal that the node was able to cook, but there was a
            problem the user might want to check. For example, a missing
            texture.

            See Writing Python SOPs for more information.


            TIP
                To mark the node with an error instead of an error, raise
                hou.NodeError instead.


            NOTE
                Raise a warning exception at the end of the script, so the node
                script otherwise completes cooking.

        EXAMPLE

            If you're writing a Python SOP, you might use the content of an
            external file (referenced in a parameter on the node), even though
            the node can work without the file:

          > import os.path
          >
          > thisnode = hou.pwd()
          > filepath = thisnode.parm(\"file\").evalAsString()
          > content = hou.readFile()
          > if content:
          >     # Use the file contents
          >     # ...
          >
          > # Continue script operation
          > # ...
          >
          > # At the end of the script, raise any warning that might have
          > # come up during the script
          > if not content:
          >     raise NodeWarning(\"The texture file is missing or empty\")

        RELATED

          * hou.NodeWarning


        """
        _hou.NodeWarning_swiginit(self, _hou.new_NodeWarning(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.NodeWarning_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.NodeWarning_description(self)

    def __repr__(self) -> "std::string":
        return _hou.NodeWarning___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.NodeWarning___str__(self)

    __swig_destroy__ = _hou.delete_NodeWarning


# Register NodeWarning in _hou:
_hou.NodeWarning_swigregister(NodeWarning)


class NameConflict(Error):
    r"""

    hou.NameConflict

    Exception raised when a name conflict is detected during an operation.

    Often, Houdini can resolve name conflicts automatically (for example, if
    you try to create a node named sphere1 and a node with that name already
    exists, by default most API calls will create a node named sphere2
    instead). In cases where a naming conflict prevents an API call from
    working, and it can't be automatically resolved (or automatic resolution
    is an option you have disabled in an argument), Houdini will raise this
    exception.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.NameConflict

        Exception raised when a name conflict is detected during an operation.

        Often, Houdini can resolve name conflicts automatically (for example, if
        you try to create a node named sphere1 and a node with that name already
        exists, by default most API calls will create a node named sphere2
        instead). In cases where a naming conflict prevents an API call from
        working, and it can't be automatically resolved (or automatic resolution
        is an option you have disabled in an argument), Houdini will raise this
        exception.


        """
        _hou.NameConflict_swiginit(self, _hou.new_NameConflict(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.NameConflict_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.NameConflict_description(self)

    def __repr__(self) -> "std::string":
        return _hou.NameConflict___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.NameConflict___str__(self)

    __swig_destroy__ = _hou.delete_NameConflict


# Register NameConflict in _hou:
_hou.NameConflict_swigregister(NameConflict)


class TypeConflict(Error):
    r"""

    hou.TypeConflict

    Raised if a type conflict occurs during an operation. For instance, type
    conflicts may occur during the registration of a python state or python
    handle.

    See Python States for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.TypeConflict

        Raised if a type conflict occurs during an operation. For instance, type
        conflicts may occur during the registration of a python state or python
        handle.

        See Python States for more information.


        """
        _hou.TypeConflict_swiginit(self, _hou.new_TypeConflict(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.TypeConflict_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.TypeConflict_description(self)

    def __repr__(self) -> "std::string":
        return _hou.TypeConflict___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.TypeConflict___str__(self)

    __swig_destroy__ = _hou.delete_TypeConflict


# Register TypeConflict in _hou:
_hou.TypeConflict_swigregister(TypeConflict)


class StateNotRegistered(Error):
    r"""

    hou.StateNotRegistered

    Raised if you try to unregister a Python state that was never
    registered.

    See Python States for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.StateNotRegistered

        Raised if you try to unregister a Python state that was never
        registered.

        See Python States for more information.


        """
        _hou.StateNotRegistered_swiginit(self, _hou.new_StateNotRegistered(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.StateNotRegistered_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.StateNotRegistered_description(self)

    def __repr__(self) -> "std::string":
        return _hou.StateNotRegistered___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.StateNotRegistered___str__(self)

    __swig_destroy__ = _hou.delete_StateNotRegistered


# Register StateNotRegistered in _hou:
_hou.StateNotRegistered_swigregister(StateNotRegistered)


class HandleNotRegistered(Error):
    r"""

    hou.HandleNotRegistered

    Raised if you try to use a custom handle that is not registered with the
    system.

    See Python handles for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.HandleNotRegistered

        Raised if you try to use a custom handle that is not registered with the
        system.

        See Python handles for more information.


        """
        _hou.HandleNotRegistered_swiginit(self, _hou.new_HandleNotRegistered(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.HandleNotRegistered_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.HandleNotRegistered_description(self)

    def __repr__(self) -> "std::string":
        return _hou.HandleNotRegistered___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.HandleNotRegistered___str__(self)

    __swig_destroy__ = _hou.delete_HandleNotRegistered


# Register HandleNotRegistered in _hou:
_hou.HandleNotRegistered_swigregister(HandleNotRegistered)


class InvalidGeometry(OperationFailed):
    r"""

    hou.InvalidGeometry

    Exception raised when you try to access a reference to SOP Geometry that
    has since failed to cook.

    OVERVIEW

        For example, you might take a reference to a geometry node's output:

      > >>> mygeo = hou.node(\"/obj/geo1/sphere1\").geometry()

        If after you take the reference something changes which causes the
        node to recook, and the recook fails, the geometry referred to by
        mygeo is now invalid. Trying to access it will raise this exception.

      > >>> points = mygeo.points()
      > hou.InvalidGeometry: ...

    TIPS AND NOTES

      * If you call .geometry() on a node that's currently in error, you
        will get None instead of an invalid hou.Geometry object.

      * You can check if a Geometry object is valid before you use it with
        hou.Geometry.isValid.

          > if mygeo.isValid():
          >     points = mygeo.points()
      * A Geometry reference turning invalid might happen if you grab
        geometry in code outside the cooking mechanism. If your code runs as
        part of the cook (for example, in a Python SOP), a valid Geometry
        reference should stay valid for the duration of your script.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.InvalidGeometry

        Exception raised when you try to access a reference to SOP Geometry that
        has since failed to cook.

        OVERVIEW

            For example, you might take a reference to a geometry node's output:

          > >>> mygeo = hou.node(\"/obj/geo1/sphere1\").geometry()

            If after you take the reference something changes which causes the
            node to recook, and the recook fails, the geometry referred to by
            mygeo is now invalid. Trying to access it will raise this exception.

          > >>> points = mygeo.points()
          > hou.InvalidGeometry: ...

        TIPS AND NOTES

          * If you call .geometry() on a node that's currently in error, you
            will get None instead of an invalid hou.Geometry object.

          * You can check if a Geometry object is valid before you use it with
            hou.Geometry.isValid.

              > if mygeo.isValid():
              >     points = mygeo.points()
          * A Geometry reference turning invalid might happen if you grab
            geometry in code outside the cooking mechanism. If your code runs as
            part of the cook (for example, in a Python SOP), a valid Geometry
            reference should stay valid for the duration of your script.


        """
        _hou.InvalidGeometry_swiginit(self, _hou.new_InvalidGeometry(*args))

    def exceptionTypeName(self) -> "std::string":
        r"""

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \"Error\".

            You can also use str(e.__class__) to get the name of the subclass.


        """
        return _hou.InvalidGeometry_exceptionTypeName(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
        return _hou.InvalidGeometry_description(self)

    def __repr__(self) -> "std::string":
        return _hou.InvalidGeometry___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.InvalidGeometry___str__(self)

    __swig_destroy__ = _hou.delete_InvalidGeometry


# Register InvalidGeometry in _hou:
_hou.InvalidGeometry_swigregister(InvalidGeometry)


class NetworkItem(object):
    r"""

    hou.NetworkItem

    The base class for all visible elements within a network.

    This class has no methods, and only exists as a base class for
    hou.NetworkMovableItem and hou.NodeConnection, both of which are visible
    in the network editor, but which have no real meaningful base class. By
    providing a common base class, items of these two types can be passed in
    or returned from hou.NetworkEditor functions.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        hou.NetworkItem

        The base class for all visible elements within a network.

        This class has no methods, and only exists as a base class for
        hou.NetworkMovableItem and hou.NodeConnection, both of which are visible
        in the network editor, but which have no real meaningful base class. By
        providing a common base class, items of these two types can be passed in
        or returned from hou.NetworkEditor functions.


        """
        _hou.NetworkItem_swiginit(self, _hou.new_NetworkItem(*args))

    __swig_destroy__ = _hou.delete_NetworkItem

    def networkItemType(self) -> "HOM_EnumValue &":
        return _hou.NetworkItem_networkItemType(self)


# Register NetworkItem in _hou:
_hou.NetworkItem_swigregister(NetworkItem)


class NetworkMovableItem(NetworkItem):
    r"""

    hou.NetworkMovableItem

    The base class for all visible elements within a network, such as Nodes,
    Network Boxes, and Sticky Notes.

    Each movable item has a position, color, and other attributes that allow
    for common interactions in the network editor. All movable items will
    have a parent network (except the node represented by hou.node('/')),
    and may be contained by a hou.NetworkBox. Not all movable items have a
    name, but all have a numeric session id, which is a unique number within
    a given Houdini session for a given subclass of NetworkMovableItem.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_NetworkMovableItem

    def __hash__(self) -> "int":
        return _hou.NetworkMovableItem___hash__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return this node's name. See also hou.NetworkMovableItem.path.


        """
        return _hou.NetworkMovableItem_name(self)

    def setName(self, name: "char const *", unique_name: "bool" = False) -> "void":
        r"""

        setName(self, name, unique_name=False)

            Set the name of this node. Raises hou.OperationFailed if the new
            name contains characters other than letters, numbers, periods,
            dashes, or underscores. Raises hou.OperationFailed if the node could
            not be renamed (for example, another node already exists with the
            name, the node is the root node or top-level manager (e.g. /obj), or
            the node is inside a locked asset). If the unique_name parameter is
            set to True, the supplied name may be changed to ensure that it
            doesn't match the name of any existing node.


        """
        return _hou.NetworkMovableItem_setName(self, name, unique_name)

    def digitsInName(self) -> "int":
        r"""

        digitsInName(self) -> int

            Return the value of the last set of digits inside the node's name,
            or 0 if there are no digits.

            For example, the result is 102 for a node named geo102, and 34 for a
            node named light12to34.


        """
        return _hou.NetworkMovableItem_digitsInName(self)

    def path(self) -> "std::string":
        r"""

        path(self) -> str

            Return the full path (i.e. starting with /) of this node in the
            network.


        """
        return _hou.NetworkMovableItem_path(self)

    def relativePathTo(self, base_item: "NetworkMovableItem") -> "std::string":
        r"""

        relativePathTo(self, base_node) -> str

            Return a relative path to another node object from this node.

          > >>> box1 = hou.node(\"/obj/box_object1/box1\")
          > >>> sphere1 = hou.node(\"/obj/sphere_object1/sphere1\")
          > >>> box1.relativePathTo(sphere1)
          > '../../sphere_object1/sphere1'
          > >>> hou.node(\"/obj\").relativePathTo(box1)
          > 'box_object1/box1'
          > >>> box1.relativePathTo(box1)
          > '.'

        """
        return _hou.NetworkMovableItem_relativePathTo(self, base_item)

    def isSelected(self) -> "bool":
        r"""

        isSelected(self) -> bool

            Return whether this item is selected.

            See also hou.selectedNodes.


        """
        return _hou.NetworkMovableItem_isSelected(self)

    def setSelected(
        self,
        on: "bool",
        clear_all_selected: "bool" = False,
        show_asset_if_selected: "bool" = False,
    ) -> "void":
        r"""

        setSelected(self, on, clear_all_selected=False,
        show_asset_if_selected=False)

            Select or deselect this item, optionally deselecting all other
            selected items in this network. If show_asset_if_selected is True,
            and this item is a Node, then the panes will show the top-level
            asset of the selected item instead.


        """
        return _hou.NetworkMovableItem_setSelected(
            self, on, clear_all_selected, show_asset_if_selected
        )

    def color(self) -> "HOM_Color":
        r"""

        color(self) -> hou.Color

            Return the color of this item's tile in the network editor.


        """
        return _hou.NetworkMovableItem_color(self)

    def setColor(self, color: "Color") -> "void":
        r"""

        setColor(self, color)

            Sets the color of this item's tile in the network editor to the
            given hou.Color.


        """
        return _hou.NetworkMovableItem_setColor(self, color)

    def size(self) -> "HOM_Vector2":
        r"""

        size(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph as a
            Vector2.


        """
        return _hou.NetworkMovableItem_size(self)

    def position(self) -> "HOM_Vector2":
        r"""

        position(self) -> hou.Vector2

            Return the position of this item's tile in the network editor graph
            as a Vector2. See also move() and setPosition().


        """
        return _hou.NetworkMovableItem_position(self)

    def setPosition(self, position: "_DoubleTuple") -> "void":
        r"""

        setPosition(self, vector2)

            Sets the position of this item's tile in the network editor graph.
            Raises hou.InvalidInput if the item cannot have the given position.


        """
        return _hou.NetworkMovableItem_setPosition(self, position)

    def move(self, amount: "_DoubleTuple") -> "void":
        r"""

        move(self, vector2)

            Moves this item's tile in the network editor graph by the increments
            in the given hou.Vector2.

            To position a item absolutely, use setPosition().

            To get the item's current graph position, use position().

            Raises hou.InvalidInput if the item cannot move to the position
            specified.


        """
        return _hou.NetworkMovableItem_move(self, amount)

    def parent(self) -> "HOM_Node *":
        r"""

        parent(self) -> hou.Node

            Return the node that contains this item.

            Note that this method returns None if the item is the root node
            (i.e. /).

          > >>> hou.node(\"/obj/box_object1\").parent()
          > <hou.Node at /obj>
          > >>> print hou.node(\"/\").parent()
          > None

        """
        return _hou.NetworkMovableItem_parent(self)

    def parentNetworkBox(self) -> "HOM_NetworkBox *":
        r"""

        parentNetworkBox(self) -> hou.NetworkBox or None

            Returns the parent network box which contains this item, or None if
            it is not inside a network box.


        """
        return _hou.NetworkMovableItem_parentNetworkBox(self)

    def sessionId(self) -> "int64":
        r"""

        sessionId(self)

            Returns an integer value that uniquely identifies this item in a
            given Houdini session. This id is only guaranteed to be unique in a
            single Houdini process. It is useful as a quick and easy way to save
            a restore a reference to an item. It is also only unique for a
            specific item subclass. So there may be a Node with the same session
            id as a NetworkBox.

            See hou.nodeBySessionId to turn a session id back into a node, or
            hou.networkBoxBySessionId to turn a session id back into a network
            box, or more generally, hou.itemBySessionId to turn a session id
            combined with an enum value indicating the item subclass into an
            item of that type.


        """
        return _hou.NetworkMovableItem_sessionId(self)


# Register NetworkMovableItem in _hou:
_hou.NetworkMovableItem_swigregister(NetworkMovableItem)


class NetworkBox(NetworkMovableItem):
    r"""

    hou.NetworkBox

    Represents a network box.

    To create a network box, use the hou.Node.createNetworkBox method on the
    node inside which you want to create the box. To get an existing network
    box, use the hou.Node.findNetworkBox method on the node containing the
    network box. To get a list of all network boxes in a network, use the
    hou.Node.networkBoxes method on the containing node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NetworkBox

    def __repr__(self) -> "std::string":
        return _hou.NetworkBox___repr__(self)

    def __hash__(self) -> "int":
        return _hou.NetworkBox___hash__(self)

    def __eq__(self, networkbox: "HOM_PtrOrNull< HOM_NetworkBox >") -> "bool":
        return _hou.NetworkBox___eq__(self, networkbox)

    def __ne__(self, networkbox: "HOM_PtrOrNull< HOM_NetworkBox >") -> "bool":
        return _hou.NetworkBox___ne__(self, networkbox)

    def comment(self) -> "std::string":
        r"""

        comment(self) -> str

            Returns the comment for this network box.


        """
        return _hou.NetworkBox_comment(self)

    def setComment(self, comment: "char const *") -> "void":
        r"""

        setComment(self, comment)

            Set the comment string for this network box. This comment is visible
            in the network editor and can be used to describe the purpose of the
            box.


        """
        return _hou.NetworkBox_setComment(self, comment)

    def autoFit(self) -> "bool":
        r"""

        autoFit(self) -> bool

            Returns the value of the auto fit flag on this network box.


        """
        return _hou.NetworkBox_autoFit(self)

    def setAutoFit(self, auto_fit: "bool") -> "void":
        r"""

        setAutoFit(self, auto_fit)

            Set the value of the auto fit flag on this network box. The default
            value is True which causes the network box to resize itself when
            nodes that belong to the network box are moved outside the bounds of
            the box. Setting this values to False prevents this automatic
            resizing. The Network View will draw the network box around it's
            contents in any case. The default setting of True is primarily
            useful for backward compatibility with the old network editor which
            relies on this automatic resizing to draw the network box properly.


        """
        return _hou.NetworkBox_setAutoFit(self, auto_fit)

    def setBounds(self, bounds: "BoundingRect") -> "void":
        r"""

        setBounds(self, bounds)

            Sets the size and position of this sticky note to the given
            hou.BoundingRect bounds argument. Equivalent to calling setSize then
            setPosition.


        """
        return _hou.NetworkBox_setBounds(self, bounds)

    def setSize(self, size: "_DoubleTuple") -> "void":
        r"""

        setSize(self, size)

            Sets the size of this network box to the given hou.Vector2 size
            parameter. Use resize() to set the box's size relative to its
            current size.


        """
        return _hou.NetworkBox_setSize(self, size)

    def resize(self, amount: "_DoubleTuple") -> "void":
        r"""

        resize(self, vector2)

            Resizes a network box by the increments in the given hou.Vector2.
            Use setSize() to set the box's absolute size.


        """
        return _hou.NetworkBox_resize(self, amount)

    def fitAroundContents(self) -> "void":
        r"""

        fitAroundContents(self)

            Resizes the network box to fit its contents.


        """
        return _hou.NetworkBox_fitAroundContents(self)

    def minimizedSize(self) -> "HOM_Vector2":
        r"""

        minimizedSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is minimized. Returned as a Vector2.


        """
        return _hou.NetworkBox_minimizedSize(self)

    def restoredSize(self) -> "HOM_Vector2":
        r"""

        restoredSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is not minimized. Returned as a Vector2.


        """
        return _hou.NetworkBox_restoredSize(self)

    def isMinimized(self) -> "bool":
        r"""

        isMinimized(self) -> bool

            Returns whether the network box is minimized.


        """
        return _hou.NetworkBox_isMinimized(self)

    def setMinimized(self, on: "bool") -> "void":
        r"""

        setMinimized(self, on)

            Minimizes or restores the network box.


        """
        return _hou.NetworkBox_setMinimized(self, on)

    def nodes(
        self, recurse: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        nodes(self, recurse=True) -> tuple of hou.Node

            Returns the nodes inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
        return _hou.NetworkBox_nodes(self, recurse)

    def addNode(self, node: "Node") -> "void":
        r"""

        addNode(self, node)

            Adds a hou.Node to the network box. This method is deprecated. Use
            hou.NetworkBox.addItem instead.


        """
        return _hou.NetworkBox_addNode(self, node)

    def removeNode(self, node: "Node") -> "void":
        r"""

        removeNode(self, node)

            Removes the given node from the network box. This method if
            deprecated. Use hou.NetworkBox.removeItem instead.


        """
        return _hou.NetworkBox_removeNode(self, node)

    def removeAllNodes(self) -> "void":
        r"""

        removeAllNodes(self)

            Removes all nodes from the network box. This method if deprecated.
            Use hou.NetworkBox.removaAllItems or hou.NetworkBox.removeItems
            instead.


        """
        return _hou.NetworkBox_removeAllNodes(self)

    def networkBoxes(
        self, recurse: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkBox >,std::allocator< HOM_ElemPtr< HOM_NetworkBox > > >":
        r"""

        networkBoxes(self, recurse=True) -> tuple of hou.NetworkBox

            Returns the network boxes inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
        return _hou.NetworkBox_networkBoxes(self, recurse)

    def addNetworkBox(self, networkbox: "NetworkBox") -> "void":
        r"""

        addNetworkBox(self, netbox)

            Adds a hou.NetworkDot to the network box. This method is deprecated.
            Use hou.NetworkBox.addItem instead.


        """
        return _hou.NetworkBox_addNetworkBox(self, networkbox)

    def removeNetworkBox(self, networkbox: "NetworkBox") -> "void":
        r"""

        removeNetworkBox(self, netbox)

            Removes the given network box from the network box. This method if
            deprecated. Use hou.NetworkBox.removeItem instead.


        """
        return _hou.NetworkBox_removeNetworkBox(self, networkbox)

    def stickyNotes(
        self, recurse: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_StickyNote >,std::allocator< HOM_ElemPtr< HOM_StickyNote > > >":
        r"""

        stickyNotes(self, recurse=True) -> tuple of hou.StickyNote

            Returns the sticky notes inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
        return _hou.NetworkBox_stickyNotes(self, recurse)

    def addStickyNote(self, stickynote: "StickyNote") -> "void":
        r"""

        addStickyNote(self, stickynote)

            Adds a hou.StickyNote to the network box. This method is deprecated.
            Use hou.NetworkBox.addItem instead.


        """
        return _hou.NetworkBox_addStickyNote(self, stickynote)

    def removeStickyNote(self, stickynote: "StickyNote") -> "void":
        r"""

        removeStickyNote(self, stickynote)

            Removes the given sticky note from the network box. This method if
            deprecated. Use hou.NetworkBox.removeItem instead.


        """
        return _hou.NetworkBox_removeStickyNote(self, stickynote)

    def subnetIndirectInputs(
        self, recurse: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_SubnetIndirectInput >,std::allocator< HOM_ElemPtr< HOM_SubnetIndirectInput > > >":
        r"""

        subnetIndirectInputs(self, recurse=True) -> tuple of
        hou.SubnetIndirectInput

            Returns the subnet indirect inputs inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
        return _hou.NetworkBox_subnetIndirectInputs(self, recurse)

    def addSubnetIndirectInput(self, indirect: "SubnetIndirectInput") -> "void":
        r"""

        addSubnetIndirectInput(self, indirect)

            Adds a hou.SubnetIndirectInput to the network box. This method is
            deprecated. Use hou.NetworkBox.addItem instead.


        """
        return _hou.NetworkBox_addSubnetIndirectInput(self, indirect)

    def removeSubnetIndirectInput(self, indirect: "SubnetIndirectInput") -> "void":
        r"""

        removeSubnetIndirectInput(self, indirect)

            Removes the given indirect input from the network box. This method
            if deprecated. Use hou.NetworkBox.removeItem instead.


        """
        return _hou.NetworkBox_removeSubnetIndirectInput(self, indirect)

    def items(
        self, recurse: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        items(self, recurse=True) -> tuple of hou.NetworkMovableItem

            Returns the items of any type inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
        return _hou.NetworkBox_items(self, recurse)

    def addItem(self, item: "NetworkMovableItem") -> "void":
        r"""

        addItem(self, item)

            Adds a hou.NetworkMovableItem of any kind to the network box.


        """
        return _hou.NetworkBox_addItem(self, item)

    def removeItem(self, item: "NetworkMovableItem") -> "void":
        r"""

        removeItem(self, item)

            Removes the given item from the network box.


        """
        return _hou.NetworkBox_removeItem(self, item)

    def removeAllItems(self) -> "void":
        r"""

        removeAllItems(self)

            Removes all items from the network box.


        """
        return _hou.NetworkBox_removeAllItems(self)

    def destroy(self, destroy_contents: "bool" = False) -> "void":
        r"""

        destroy(self, destroy_contents=False)

            Remove and delete the network box, optionally deleting the nodes it
            contains.


        """
        return _hou.NetworkBox_destroy(self, destroy_contents)

    def asCode(
        self,
        brief: "bool" = False,
        recurse: "bool" = False,
        save_box_contents: "bool" = False,
        save_channels_only: "bool" = False,
        save_creation_commands: "bool" = True,
        save_keys_in_frames: "bool" = False,
        save_parm_values_only: "bool" = False,
        save_spare_parms: "bool" = False,
        save_netbox_membership: "bool" = True,
        function_name: "char const *" = None,
    ) -> "std::string":
        r"""

        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, save_box_membership=True, function_name=None) ->
        string

            Prints the Python code necessary to recreate a network box.

            See hou.Node.asCode for information on the keyword arguments.


        """
        return _hou.NetworkBox_asCode(
            self,
            brief,
            recurse,
            save_box_contents,
            save_channels_only,
            save_creation_commands,
            save_keys_in_frames,
            save_parm_values_only,
            save_spare_parms,
            save_netbox_membership,
            function_name,
        )


# Register NetworkBox in _hou:
_hou.NetworkBox_swigregister(NetworkBox)


class StickyNote(NetworkMovableItem):
    r"""

    hou.StickyNote

    Represents a sticky note.

    To create a sticky note, use the hou.Node.createStickyNote method on the
    node inside which you want to create the note. To get an existing sticky
    note, use the hou.Node.findStickyNote method on the node containing the
    sticky note. To get a list of all notes in a network, use the
    hou.Node.stickyNotes method on the containing node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_StickyNote

    def __repr__(self) -> "std::string":
        return _hou.StickyNote___repr__(self)

    def __hash__(self) -> "int":
        return _hou.StickyNote___hash__(self)

    def __eq__(self, stickynote: "HOM_PtrOrNull< HOM_StickyNote >") -> "bool":
        return _hou.StickyNote___eq__(self, stickynote)

    def __ne__(self, stickynote: "HOM_PtrOrNull< HOM_StickyNote >") -> "bool":
        return _hou.StickyNote___ne__(self, stickynote)

    def text(self) -> "std::string":
        r"""

        text(self) -> str

            Return the text displayed in the sticky note.


        """
        return _hou.StickyNote_text(self)

    def setText(self, new_text: "char const *") -> "void":
        r"""

        setText(self, str)

            Sets the text of the sticky note.


        """
        return _hou.StickyNote_setText(self, new_text)

    def textSize(self) -> "float":
        r"""

        textSize(self) -> float

            Return the size of the text displayed in the sticky note, expressed
            as the height of the font in network units.


        """
        return _hou.StickyNote_textSize(self)

    def setTextSize(self, size: "float") -> "void":
        r"""

        setTextSize(self, size)

            Sets the size of the text of the sticky note. The size value
            specifies the height (in network units) of the font.


        """
        return _hou.StickyNote_setTextSize(self, size)

    def textColor(self) -> "HOM_Color":
        r"""

        textColor(self) -> hou.Color

            Return the color of the text displayed in the sticky note.


        """
        return _hou.StickyNote_textColor(self)

    def setTextColor(self, color: "Color") -> "void":
        r"""

        setTextColor(self, color)

            Sets the color of the text of the sticky note. The color parameter
            should be a hou.Color object.


        """
        return _hou.StickyNote_setTextColor(self, color)

    def drawBackground(self) -> "bool":
        r"""

        drawBackground(self) -> bool

            Returns whether the sticky note will draw a colored background and
            title bar.


        """
        return _hou.StickyNote_drawBackground(self)

    def setDrawBackground(self, on: "bool") -> "void":
        r"""

        setDrawBackground(self, on)

            Turns on or off the drawing of the colored background for the text
            and the title bar in the network editor. Turning this on makes the
            sticky note easier to see. Turning it off allows the text to be less
            obtrusive.


        """
        return _hou.StickyNote_setDrawBackground(self, on)

    def setBounds(self, bounds: "BoundingRect") -> "void":
        return _hou.StickyNote_setBounds(self, bounds)

    def setSize(self, size: "_DoubleTuple") -> "void":
        r"""

        setSize(self, size)

            Sets the size of this sticky note to the given hou.Vector2 size
            parameter. Use resize() to set the note's size relative to its
            current size.


        """
        return _hou.StickyNote_setSize(self, size)

    def resize(self, amount: "_DoubleTuple") -> "void":
        r"""

        resize(self, vector2)

            Resizes a sticky note by the increments in the given hou.Vector2.
            Use setSize() to set the note's absolute size.


        """
        return _hou.StickyNote_resize(self, amount)

    def minimizedSize(self) -> "HOM_Vector2":
        r"""

        minimizedSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is minimized. Returned as a Vector2.


        """
        return _hou.StickyNote_minimizedSize(self)

    def restoredSize(self) -> "HOM_Vector2":
        r"""

        restoredSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is not minimized. Returned as a Vector2.


        """
        return _hou.StickyNote_restoredSize(self)

    def isMinimized(self) -> "bool":
        r"""

        isMinimized(self) -> bool

            Returns whether the sticky note is minimized.


        """
        return _hou.StickyNote_isMinimized(self)

    def setMinimized(self, on: "bool") -> "void":
        r"""

        setMinimized(self, on)

            Minimizes or restores the sticky note.


        """
        return _hou.StickyNote_setMinimized(self, on)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove and delete the sticky note.


        """
        return _hou.StickyNote_destroy(self)

    def asCode(
        self,
        brief: "bool" = False,
        recurse: "bool" = False,
        save_box_contents: "bool" = False,
        save_channels_only: "bool" = False,
        save_creation_commands: "bool" = True,
        save_keys_in_frames: "bool" = False,
        save_parm_values_only: "bool" = False,
        save_spare_parms: "bool" = False,
        save_box_membership: "bool" = True,
        function_name: "char const *" = None,
    ) -> "std::string":
        r"""

        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, save_box_membership=True, function_name=None) ->
        str

            Prints the Python code necessary to recreate a sticky note.

            See hou.Node.asCode for information on the keyword arguments.


        """
        return _hou.StickyNote_asCode(
            self,
            brief,
            recurse,
            save_box_contents,
            save_channels_only,
            save_creation_commands,
            save_keys_in_frames,
            save_parm_values_only,
            save_spare_parms,
            save_box_membership,
            function_name,
        )


# Register StickyNote in _hou:
_hou.StickyNote_swigregister(StickyNote)


class Node(NetworkMovableItem):
    r"""

    hou.Node

    The base class for all nodes in Houdini (objects, SOPs, COPs, etc.) An
    instance of this class corresponds to exactly one instance of a node in
    Houdini.

    Each node has a unique path that defines its location in the tree of
    nodes. The node path hierarchy is similar to the hierarchy of folders
    and files in a file system. Some nodes, called networks, may contain
    other nodes inside them, much like a file folder would, while other
    nodes may not. For example, an object node instance and a SOP subnetwork
    node instance may contain SOP nodes, but a box SOP instance may not.


    TIP
        Be careful not to confuse nodes with node types. A node is an
        instance of a node type. For example suppose /obj/geo1/box1 is a box
        SOP. It has its own unique name (box1) and its own copies of
        parameter values. It is an instance of the box SOP node type. This
        node type defines what parameters are common to all box SOP node
        instances, as well as the algorithm that each BOX SOP performs. The
        class that represents a node type is hou.NodeType.

    You cannot create instances of hou.Node using hou.Node.__init__.
    Instead, you look up Node objects corresponding to existing Houdini
    nodes with hou.node(). To create a new Houdini node instance inside
    another node, use hou.Node.createNode. To delete a Houdini node, use
    hou.Node.destroy.

    Note that a Node object internally stores a reference to the
    corresponding Houdini node, and that their lifetimes are different. If a
    Python node object is deleted because its reference count in Python goes
    to zero, the Houdini node will be unaffected. On the other hand, if you
    have a Node object in a Python variable and the Houdini node is deleted,
    the Python variable will still exist, and Python will not crash.
    Instead, if you later call a method on that Python Node object, Houdini
    will raise a hou.ObjectWasDeleted exception.

    Be careful not to confuse this class with the function hou.node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Node

    def _getArgumentAutoComplete(
        self,
        method_name: "char const *",
        arguments: "char const *",
        meta_info_only: "bool" = False,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.Node__getArgumentAutoComplete(
            self, method_name, arguments, meta_info_only
        )

    def __hash__(self) -> "int":
        return _hou.Node___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Node___repr__(self)

    def __eq__(self, node: "HOM_PtrOrNull< HOM_Node >") -> "bool":
        return _hou.Node___eq__(self, node)

    def __ne__(self, node: "HOM_PtrOrNull< HOM_Node >") -> "bool":
        return _hou.Node___ne__(self, node)

    def __str__(self) -> "std::string":
        return _hou.Node___str__(self)

    def infoTree(
        self,
        verbose: "bool" = False,
        debug: "bool" = False,
        output_index: "int" = 0,
        force_cook: "bool" = False,
    ) -> "HOM_NodeInfoTree":
        r"""

        infoTree(self, verbose=False, debug=False, output_index=0,
        force_cook=False) -> hou.NodeInfoTree

            Returns a tree structure containing information about the node and
            its most recently cooked data. The contents of the tree vary widely
            depending on the node type, and the nature of its cooked data. This
            tree of data is used to generate the node information window
            contents.


            verbose
                Setting verbose to True will cause some additional information
                to be generated. In particular data that is expensive to
                calculate, or which will generate a large amount of information
                tends to be generated only if this option is turned on.

            debug
                Setting debug to True will, in a few cases, cause additional
                information to be displayed which generally will be most useful
                when debugging the internal operation of Houdini. For example,
                geometry attributes will display their data ids, which can be
                helpful when tracking down errors in SOPs written with the HDK.

            output_index
                Specifies which of the node's outputs to return information for.

            force_cook
                If True, ensures that output has been cooked before building the
                info tree. Note that if the node already has errors, this will
                attempt to recook the node.


        """
        return _hou.Node_infoTree(self, verbose, debug, output_index, force_cook)

    def isNetwork(self) -> "bool":
        r"""

        isNetwork(self) -> bool

            Return True if this node is a network, in other words a node that
            may contain child nodes. Otherwise return False which indicates that
            several other methods such as hou.Node.createNode will raise
            hou.OperationFailed if they are called.


        """
        return _hou.Node_isNetwork(self)

    def type(self) -> "HOM_NodeType *":
        r"""

        type(self) -> hou.NodeType

            Return the hou.NodeType object for this node.

            For example, all camera node instances share the same node type.


        """
        return _hou.Node_type(self)

    def childTypeCategory(self) -> "HOM_NodeTypeCategory *":
        r"""

        childTypeCategory(self) -> hou.NodeTypeCategory

            Return the hou.NodeTypeCategory corresponding to the children of
            this node. For example, if this node is a geometry object, the
            children are SOPs. If it is an object subnet, the children are
            objects.


        """
        return _hou.Node_childTypeCategory(self)

    def isFlagReadable(self, flag: "EnumValue") -> "bool":
        r"""

        isFlagReadable(self, flag) -> bool

            Return True if the specified flag is readable and False otherwise.

            flag must be a hou.nodeFlag value.


        """
        return _hou.Node_isFlagReadable(self, flag)

    def isFlagWritable(self, flag: "EnumValue") -> "bool":
        r"""

        isFlagWritable(self, flag) -> bool

            Return True if the specified flag is writable and False otherwise.

            flag must be a hou.nodeFlag value.


        """
        return _hou.Node_isFlagWritable(self, flag)

    def isGenericFlagSet(self, flag: "EnumValue") -> "bool":
        r"""

        isGenericFlagSet(self, flag) -> bool

            Returns the value of the specific flag.

            flag must be a hou.nodeFlag value.


        """
        return _hou.Node_isGenericFlagSet(self, flag)

    def setGenericFlag(self, flag: "EnumValue", value: "bool") -> "void":
        r"""

        setGenericFlag(self, flag, value)

            Sets the value of the specified flag based on the bool value
            argument.

            flag must be a hou.nodeFlag value.


        """
        return _hou.Node_setGenericFlag(self, flag, value)

    def isDisplayDescriptiveNameFlagSet(self) -> "bool":
        r"""

        isDisplayDescriptiveNameFlagSet(self) -> bool

            Return a boolean to indicate of the node should display its
            descriptive name in the network editor.


        """
        return _hou.Node_isDisplayDescriptiveNameFlagSet(self)

    def setDisplayDescriptiveNameFlag(self, on: "bool") -> "void":
        return _hou.Node_setDisplayDescriptiveNameFlag(self, on)

    def outputForViewFlag(self) -> "int":
        r"""

        outputForViewFlag(self) -> int

            Return an integer to indicate which output of the node should be
            used for display purposes.


        """
        return _hou.Node_outputForViewFlag(self)

    def setOutputForViewFlag(self, output: "int") -> "void":
        r"""

        setOutputForViewFlag(self, output)

            Sets which output should be used for display purposes on this node.


        """
        return _hou.Node_setOutputForViewFlag(self, output)

    def node(self, node_path: "char const *") -> "HOM_Node *":
        r"""

        node(self, node_path) -> hou.Node or None

            Return the node at the given path, or None if no such node exists.
            If you pass in a relative path (i.e. the path does not start with
            /), searches are performed relative to this node.

            For example, to get the parent node of a node in the variable n, use
            n.node(\"..\"). To get a child node named geo5, use n.node(\"geo5\"). To
            get a sibling node named light3, use n.node(\"../light3\").

            Note that the return value may be an instance of a subclass of Node.
            For example, if the node being found is an object node, the return
            value will be a hou.ObjNode instance.

            If the path is an absolute path (i.e. it starts with /), this method
            is a shortcut for hou.node(node_path). Otherwise, it is a shortcut
            for hou.node(self.path() + \"/\" + node_path). See also hou.node_.


        """
        return _hou.Node_node(self, node_path)

    def nodes(
        self, node_paths: "_StringTuple"
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        nodes(self, node_path_tuple) -> tuple of hou.Node or None

            This is like node() but takes multiple paths and returns multiple
            Node objects. This is the equivalent of:

          > nodes = [self.node(path) for path in paths]

        """
        return _hou.Node_nodes(self, node_paths)

    def cookPathNodes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        cookPathNodes(self) -> tuple of hou.Node

            Return a list of the nodes, including nodes in subnets, that were
            used in the last cook for the network this node belongs to.


        """
        return _hou.Node_cookPathNodes(self)

    def item(self, item_path: "char const *") -> "HOM_NetworkMovableItem *":
        r"""

        item(self, item_path) -> hou.NetworkMovableItem or None

            Return the network item at the given path, or None if no such item
            exists. If you pass in a relative path (i.e. the path does not start
            with /), searches are performed relative to this node.

            If the path is an absolute path (i.e. it starts with /), this method
            is a shortcut for hou.item(node_path). Otherwise, it is a shortcut
            for hou.item(self.path() + \"/\" + item_path). See also hou.item.

            Note that the return value may be an instance of a subclass of
            NetworkMovableItem. For example, if the item being found is an
            object node, the return value will be a hou.ObjNode instance. If the
            item is a network box, the return value will be a hou.NetworkBox
            instance.


        """
        return _hou.Node_item(self, item_path)

    def items(
        self, item_paths: "_StringTuple"
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        items(self, item_path_tuple) -> tuple of hou.NetworkMovableItem or None

            This is like item() but takes multiple paths and returns multiple
            NetworkMovableItem objects. This is the equivalent of:

          > items = [self.item(path) for path in paths]

        """
        return _hou.Node_items(self, item_paths)

    def glob(
        self, pattern: "char const *", ignore_case: "bool" = False
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        glob(self, pattern, ignore_case=False) -> tuple of hou.Node

            Return a tuple of children nodes name matches the pattern.

            The pattern may contain multiple pieces, separated by spaces. An
            asterisk (*) in a pattern piece will match any character. By
            default, Houdini will add the nodes from each pattern piece to those
            already matched. However, if the pattern piece begins with a caret
            (^), Houdini will remove the matches for that piece from the result.

            By default the pattern match is case-sensitive. Set ignore_case to
            True for case-insensitive pattern matching. Note that case
            insensitivity only applies when matching node names. It does not
            apply when matching group, network box or bundle names.

            This method returns an empty tuple if you pass in an empty pattern.

          > >>> obj = hou.node(\"/obj\")
          > >>> obj.createNode(\"geo\", \"geo1\")
          > <hou.ObjNode of type geo at /obj/geo1>
          > >>> obj.createNode(\"geo\", \"geo2\")
          > <hou.ObjNode of type geo at /obj/geo2>
          > >>> obj.createNode(\"geo\", \"grid\")
          > <hou.ObjNode of type geo at /obj/grid>
          > >>> obj.createNode(\"geo\", \"garbage\")
          > <hou.ObjNode of type geo at /obj/garbage>
          > >>> obj.createNode(\"geo\", \"box\")
          > <hou.ObjNode of type geo at /obj/box>
          >
          > >>> def names(nodes):
          > ... return [node.name() for node in nodes]
          >
          > >>> names(obj.glob(\"g*\"))
          > ['geo1', 'geo2', 'grid', 'garbage']
          > >>> names(obj.glob(\"ge* ga*\"))
          > ['geo1', 'geo2', 'garbage']
          > >>> names(obj.glob(\"g* ^ga*\"))
          > ['geo1', 'geo2', 'grid']

            See also hou.Node.recursiveGlob.


        """
        return _hou.Node_glob(self, pattern, ignore_case)

    def recursiveGlob(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        recursiveGlob(self, pattern, filter=hou.nodeTypeFilter.NoFilter,
        include_subnets=True) -> tuple of hou.Node

            Like hou.Node.glob, return a tuple of children nodes whose name
            matches the pattern. However, any matching child will have all its
            children added, recursively. As well, the result may be filtered by
            node type.

            Houdini first matches children nodes against the pattern, then
            recursively adds the subchildren of matching children, and then
            applies the filter.


            pattern
                Child node names will be matched against this string pattern.
                See hou.Node.glob and hou.NodeBundle for information about the
                pattern syntax. Note that if a child node matches the pattern
                and include_subnets is True, all of its subchildren will be
                added to the result (subject to filtering), regardless of the
                pattern.

            filter
                A hou.nodeTypeFilter enumeration value to limit matched nodes to
                a particular type (e.g. object nodes, geometry object nodes,
                surface shader SHOPs, etc.).

            include_subnets
                Specifies whether the children of a matching node will also be
                returned, regardless of the pattern.

            The pattern and filter behavior is very similar to that used by node
            bundles in Houdini. See hou.NodeBundle for more information.

            Raises hou.OperationFailed if the pattern is invalid.


        """
        return _hou.Node_recursiveGlob(self, *args, **kwargs)

    def createNode(
        self,
        node_type_name: "char const *",
        node_name: "char const *" = None,
        run_init_scripts: "bool" = True,
        load_contents: "bool" = True,
        exact_type_name: "bool" = False,
        force_valid_node_name: "bool" = False,
    ) -> "HOM_Node *":
        r"""

        createNode(self, node_type_name, node_name=None, run_init_scripts=True,
        load_contents=True, exact_type_name=False, force_valid_node_name=False)
        -> hou.Node

            Create a new node of type node_type_name as a child of this node.


            node_name
                The name of the new node. If not specified, Houdini appends a
                number to the node type name, incrementing that number until a
                unique node name is found. If you specify a name and a node
                already exists with that name, Houdini will append a number to
                create a unique name.

            run_init_scripts
                If True, the initialization script associated with the node type
                will be run on the new node.

            load_contents
                If True, any subnet contents will be loaded for custom subnet
                operators.

            exact_type_name
                If True, the node's type name will be exactly as specified in
                the node_type_name. Otherwise, a preferred operator type that
                matches the given node_type_name may be used. For example, the
                given hda may match a newer version hda::2.0, or if there are
                two available operators namespaceA::hda and namespaceB::hda, and
                the namespaceB has precedence, then the created node will be of
                type namespaceB::hda.

            force_valid_node_name
                If True, then create a new node with a valid name even if
                node_name is invalid. For example, if node_name is =foo bar=,
                then the new node name becomes =foo_bar=. If
                force_valid_node_name is False and node_name is invalid, then
                raise a hou.OperationFailed exception.

            Raises hou.OperationFailed if the given node name is invalid and
            force_valid_node_name is False. Raises hou.OperationFailed if this
            node cannot contain children. Raises hou.PermissionError if this
            node is inside a locked asset.

          > >>> obj = hou.node(\"/obj\")
          >
          > # Let Houdini choose a name based on the node type name.
          > >>> obj.createNode(\"geo\")
          > <hou.ObjNode of type geo at /obj/geo1>
          >
          > # Let Houdini choose a unique name.
          > >>> obj.createNode(\"geo\")
          > <hou.ObjNode of type geo at /obj/geo2>
          >
          > # Give the node a specific name.
          > >>> obj.createNode(\"geo\", \"foo\")
          > <hou.ObjNode of type geo at /obj/foo>
          >
          > # Let Houdini create a unique name from our suggested name.  Also, don't
          > # run the geometry object init scripts so the contents are empty.
          > >>> obj.createNode(\"geo\", \"geo1\", run_init_scripts=False)
          > <hou.ObjNode of type geo at /obj/geo3>
          > >>> obj.node(\"geo1\").children()
          > (<hou.SopNode of type file at /obj/geo1/file1>,)
          > >>> obj.node(\"geo3\").children()
          > ()

        """
        return _hou.Node_createNode(
            self,
            node_type_name,
            node_name,
            run_init_scripts,
            load_contents,
            exact_type_name,
            force_valid_node_name,
        )

    def runInitScripts(self) -> "void":
        r"""

        runInitScripts(self)

            Runs the initialization script associated with this node's type.


        """
        return _hou.Node_runInitScripts(self)

    def createOrMoveVisualizer(self, output_index: "int") -> "void":
        r"""

        createOrMoveVisualizer(self, output_index)

            Creates a node for visualizing the data from a particular output of
            this node. If a visualizer node already exists in the current
            network, it is moved and connected to the specified output_index.
            This method is only implemented for SOP and VOP nodes. Other node
            types do nothing when this method is called.


        """
        return _hou.Node_createOrMoveVisualizer(self, output_index)

    def inputIndex(self, input_name: "char const *") -> "int":
        r"""

        inputIndex(self, input_name)

            Obtains an index of a node input that has the given name.

            For the node categories that use input names, it returns the index
            of the input with the given name. For VOP nodes, the name may also
            be a node parameter name that has a corresponding input.


        """
        return _hou.Node_inputIndex(self, input_name)

    def outputIndex(self, output_name: "char const *") -> "int":
        r"""

        outputIndex(self, output_name)

            Obtains an index of a node output that has the given name.

            For the node categories that use input names, it returns the index
            of the output with the given name.


        """
        return _hou.Node_outputIndex(self, output_name)

    def setInput(
        self,
        input_index: "int",
        item_to_become_input: "NetworkMovableItem",
        output_index: "int" = 0,
    ) -> "void":
        r"""

        setInput(self, input_index, item_to_become_input, output_index=0)

            If item_to_become_input is not None, connect the output connector of
            another node to an input connector of this node. Otherwise,
            disconnect anything connected to the input connector.


            input_index
                The index of this node's input connector.

            item_to_become_input
                If None this method disconnects everything from the input
                connector. If a hou.Node or a hou.SubnetIndirectInput, this
                method connects its output to this node's input connector.

            output_index
                The index of the other node's output connector.

            Raises hou.InvalidInput if output_index is invalid. Raises
            hou.OperationFailed if item_to_become_input is not in the same
            network as this node. Raises hou.PermissionError if the node is
            inside a locked asset.


        """
        return _hou.Node_setInput(self, input_index, item_to_become_input, output_index)

    def setNamedInput(self, *args) -> "void":
        r"""

        setNamedInput(self, input_name, item_to_become_input,
        output_name_or_index)

            Connects an output on this node (specified by either an output name
            or an output index) to the input on the item_to_become_input
            specified by input_name.


        """
        return _hou.Node_setNamedInput(self, *args)

    def setFirstInput(
        self, item_to_become_input: "NetworkMovableItem", output_index: "int" = 0
    ) -> "void":
        r"""

        setFirstInput(self, item_to_become_input, output_index=0)

            A shortcut for self.setInput(0, item_to_become_input). See
            hou.Node.setInput for more information.


        """
        return _hou.Node_setFirstInput(self, item_to_become_input, output_index)

    def setNextInput(
        self,
        item_to_become_input: "NetworkMovableItem",
        output_index: "int" = 0,
        unordered_only: "bool" = False,
    ) -> "void":
        r"""

        setNextInput(self, item_to_become_input, output_index=0,
        unordered_only=False)

            Connect the output connector from another node into the first
            unconnected input connector or a multi-input connector of this node.
            If a node has some ordered inputs followed by a multi-input
            connector, the unordered_only parameter can be used to force the
            input to connect to the unordered multi-input connection instead of
            any of the ordered input which may not be connected.

            This method is roughly equivalent to:

          > for input_index, connectors in enumerate(self.inputConnectors()):
          >     if len(connectors) == 0:
          >         self.setInput(input_index, item_to_become_input, output_index)
          >     raise hou.InvalidInput(\"All inputs are connected\")

            Raises hou.InvalidInput if all inputs are connected. See
            hou.Node.setInput for more information.


        """
        return _hou.Node_setNextInput(
            self, item_to_become_input, output_index, unordered_only
        )

    def insertInput(
        self,
        input_index: "int",
        item_to_become_input: "NetworkMovableItem",
        output_index: "int" = 0,
    ) -> "void":
        r"""

        insertInput(self, input_index, item_to_become_input, output_index=0)

            Insert an input wire. In other words, for each input connector after
            input_index, shift the contents of that input connector to the next
            one, and then call hou.Node.setInput. See hou.Node.setInput for the
            meanings of the parameters.


        """
        return _hou.Node_insertInput(
            self, input_index, item_to_become_input, output_index
        )

    def numOrderedInputs(self) -> "int":
        r"""

        numOrderedInputs(self) -> int

            Some nodes can have a small number of dedicated inputs with specific
            meanings, followed by an arbitrary number of additional inputs,
            where gaps are not permitted between the inputs (these are referred
            to as unordered inputs). This is common in DOP nodes such as the
            Multiple Solver DOP. This function returns the number of dedicated
            (or ordered) inputs that occur before the unordered inputs begin.
            This function will only return non-zero values if the
            hou.NodeType.hasUnorderedInputs function for this node's
            hou.Node.type object returns True.


        """
        return _hou.Node_numOrderedInputs(self)

    def inputs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        inputs(self) -> tuple of hou.Node

            Return a tuple of the nodes connected to this node's inputs. If an
            input is connected to a hou.SubnetIndirectInput, the node connected
            to the corresponding input on the parent subnet is returned. In
            other words the presence of the indirect input is hidden. This means
            the resulting nodes may not all be siblings of the calling node.

            If a particular input is not connected (or is connected to an
            indirect input and the corresponding subnet parent input is not
            connected), a None value is placed in the tuple at that location.


        """
        return _hou.Node_inputs(self)

    def input(self, input_index: "int") -> "HOM_Node *":
        r"""

        input(self, inputidx) -> hou.Node

            Return a the node connected to specified input of this node. If an
            input is connected to a hou.SubnetIndirectInput, the node connected
            to the corresponding input on the parent subnet is returned. In
            other words the presence of the indirect input is hidden. This means
            the resulting nodes may not all be siblings of the calling node.

            If the input is not connected (or is connected to an indirect input
            and the corresponding subnet parent input is not connected), a None
            value is returned.


        """
        return _hou.Node_input(self, input_index)

    def inputFollowingOutputs(self, input_index: "int") -> "HOM_Node *":
        r"""

        inputFollowingOutputs(self, inputidx) -> hou.Node

            Return a the node connected to specified input of this node. If an
            input is connected to a hou.SubnetIndirectInput, the node connected
            to the corresponding input on the parent subnet is returned. In
            other words the presence of the indirect input is hidden. This means
            the resulting nodes may not all be siblings of the calling node.

            In addition, if the input is connected to a non-primary output in
            SOPs, the returned node will be the node inside of the SOP network
            rather than the subnet itself. This can be used for code that
            doesn't understand multiple outputs as it will attempt to resolve
            the node whose first output matches the input of this node.

            If the input is not connected (or is connected to an indirect input
            and the corresponding subnet parent input is not connected), a None
            value is returned.


        """
        return _hou.Node_inputFollowingOutputs(self, input_index)

    def inputConnections(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > >":
        r"""

        inputConnections(self) -> tuple of hou.NodeConnection

            Returns a tuple of hou.NodeConnection objects for the connections
            coming into the top of this node. The tuple will have a length equal
            to the number of connections coming into the node. Returns an empty
            tuple if nothing is connected to this node.

            To get a list of the connected nodes themselves, use
            hou.Node.inputs. To get a list of all possible connection sites
            (whether or not anything is connected to them), use
            hou.Node.inputConnectors.

          > >>> cookie = hou.node(\"/obj\").createNode(\"geo\").createNode(\"cookie\")
          > >>> cookie.setInput(1, cookie.parent().createNode(\"box\"))
          > >>> cookie.inputConnections()
          > (<hou.NodeConnection from grid1 output 0 to cookie input 1>,)
          > >>> cookie.inputConnectors()
          > ((), (<hou.NodeConnection from grid1 output 0 to cookie input 1>,))

            See also hou.Node.inputConnectors.


        """
        return _hou.Node_inputConnections(self)

    def inputConnectors(
        self,
    ) -> "HOM_IterableList< std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > > > *":
        r"""

        inputConnectors(self) -> tuple of tuple of hou.NodeConnection

            Return a tuple of tuples of hou.NodeConnection objects. The length
            of the result tuple is equal to the maximum number of inputs that
            can be connected to this node. Each subtuple contains exactly one
            node connection if something is wired into the connector; otherwise
            it is the empty tuple.

            See also hou.NodeConnection and hou.Node.inputConnections.


        """
        return _hou.Node_inputConnectors(self)

    def inputAncestors(
        self,
        include_ref_inputs: "bool" = True,
        follow_subnets: "bool" = False,
        only_used_inputs: "bool" = False,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        inputAncestors(self, include_ref_inputs=True, follow_subnets=False,
        only_used_inputs=False) -> tuple of hou.Node

            Return a tuple of all input ancestors of this node. If
            include_ref_inputs is False, then reference inputs are not
            traversed. If follow_subnets is True, then instead of treating
            subnetwork nodes as a single node, we also traverse its children
            starting with its display node. If only_used_inputs is True, we only
            traverse nodes that were involved in the last cook.

            See also the inputs() method.


        """
        return _hou.Node_inputAncestors(
            self, include_ref_inputs, follow_subnets, only_used_inputs
        )

    def inputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        inputNames(self) -> tuple of str

            Returns a tuple of all input names for this node. Names for input
            connectors that are hidden are also included.


        """
        return _hou.Node_inputNames(self)

    def inputLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        inputLabels(self) -> tuple of str

            Returns a tuple of all input labels for this node. Labels for input
            connectors that are hidden are also included.


        """
        return _hou.Node_inputLabels(self)

    def editableInputStrings(
        self, input_index: "int"
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        return _hou.Node_editableInputStrings(self, input_index)

    def editableInputString(
        self, input_index: "int", key: "char const *"
    ) -> "std::string":
        return _hou.Node_editableInputString(self, input_index, key)

    def setEditableInputString(
        self, input_index: "int", key: "char const *", value: "char const *"
    ) -> "void":
        return _hou.Node_setEditableInputString(self, input_index, key, value)

    def outputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        outputNames(self) -> tuple of str

            Returns a tuple of all output names for this node.


        """
        return _hou.Node_outputNames(self)

    def outputLabels(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        outputLabels(self) -> tuple of str

            Returns a tuple of all output labels for this node.


        """
        return _hou.Node_outputLabels(self)

    def outputs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        outputs(self) -> tuple of hou.Node

            Return a tuple of the nodes connected to this node's outputs.

            This method is a shortcut for [connection.outputNode() for
            connection in self.outputConnections()].


        """
        return _hou.Node_outputs(self)

    def outputConnections(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > >":
        r"""

        outputConnections(self) -> tuple of hou.NodeConnection

            Return a tuple of NodeConnection objects for the connections going
            out of the bottom of this node. If nothing is wired into the output
            of this node, return an empty tuple.

            To get a list of the connected nodes themselves, use
            hou.Node.outputs.

            Note that this method is a shortcut for: reduce(lambda a, b: a+b,
            self.outputConnectors(), ()). Since most nodes have only one output
            connector, though, this method is usually equivalent to
            self.outputConnectors()[0].

          > >>> box = hou.node(\"/obj\").createNode(\"geo\").createNode(\"box\")
          > >>> box.parent().createNode(\"xform\").setFirstInput(box)
          > >>> box.parent().createNode(\"subdivide\").setFirstInput(box)
          > >>> box.outputConnections()
          > (<hou.NodeConnection from box1 output 0 to xform1 output 0>, <hou.NodeConnection from box1 output 0 to subdivide1 input 0>)

            See also hou.node.outputConnectors.


        """
        return _hou.Node_outputConnections(self)

    def outputConnectors(
        self,
    ) -> "HOM_IterableList< std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > > > *":
        r"""

        outputConnectors(self) -> tuple of tuple of hou.NodeConnection

            Return a tuple of tuples of hou.NodeConnection objects. The length
            of the result tuple is equal to the number of output connectors on
            this node. Each subtuple contains all the connections going out of
            that connector, and is empty if nothing is wired to that connector.

          > >>> split = hou.node(\"/obj\").createNode(\"dopnet\").createNode(\"split\")
          > >>> split.parent().createNode(\"rbdsolver\").setFirstInput(split)
          > >>> split.parent().createNode(\"gravity\").setFirstInput(split, 1)
          > >>> split.parent().createNode(\"merge\").setFirstInput(split, 1)
          > >>> split.outputConnectors()
          > ((<hou.NodeConnection from split1 output 0 to rbdsolver1 input 0>,), (<hou.NodeConnection from split1 output 1 to gravity2 input 0>, <hou.NodeConnection from split1 output 1 to merge1 input 0>), (), ())

            See also hou.NodeConnection and hou.Node.outputConnections.


        """
        return _hou.Node_outputConnectors(self)

    def references(
        self, include_children: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        references(self, include_children = True) -> tuple of hou.Node

            Return a tuple of nodes that are referenced by this node, either
            through parameter expressions, referring to the node by name, or
            using expressions which rely on the data generated by another node.
            These reflect all the other ways (besides connecting to an input) in
            which one node may affect another.

            Note that the result can differ depending last cook of the nodes.
            It's recommended that you first call cook() on the node first.


        """
        return _hou.Node_references(self, include_children)

    def dependents(
        self, include_children: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        dependents(self, include_children = True) -> tuple of hou.Node

            Return a tuple of nodes that are reference this node, either through
            parameter expressions, referring to the node by name, or using
            expressions which rely on the data generated by this node. These
            reflect all the other ways (besides connecting to an input) in which
            one node may affect another.

            Note that the result can differ depending last cook of the nodes.


        """
        return _hou.Node_dependents(self, include_children)

    def children(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        children(self) -> tuple of hou.Node

            Return a list of nodes that are children of this node. Using the
            file system analogy, a node's children are like the contents of a
            folder/directory.

            To find the number of children nodes, use len(node.children()).

            The order of the children in the result is the same as the user
            defined ordering in Houdini. To see this order, switch the network
            view pane into list mode, and ensure that the list order is set to
            user defined. To reorder nodes, drag and drop them in the list.

          > def pc(node):
          >     '''Print the names of the children of a particular node.  This function
          >        can be handy when working interactively in the Python shell.'''
          >     for child in node.children():
          >         print child.name()
          >
          > def ls():
          >     '''Print the names of the nodes under the current node.'''
          >     pc(hou.pwd())

            The following expression evaluates to a list of children of a
            particular node type:

          > [c for c in node.children() if c.type() == node_type]

        """
        return _hou.Node_children(self)

    def allSubChildren(
        self,
        top_down: "bool" = True,
        recurse_in_locked_nodes: "bool" = True,
        sync_delayed_definition: "bool" = False,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        allSubChildren(self, top_down=True, recurse_in_locked_nodes=True,
        sync_delayed_definition=False) -> tuple of hou.Node

            Recursively return all sub children of this node. For example,
            hou.node(\"/\").allSubChildren() will return all the nodes in the hip
            file.


            top_down
                If True, this function will do a top-down traversal, placing a
                node in the returned tuple before its children. If False, it
                will do a bottom-up traversal, placing children before their
                parents.

            recurse_in_locked_nodes
                If True, the function will recurse inside locked child nodes
                (child nodes for which the isEditable() method returns False)
                and include children of the locked child nodes in the returned
                tuple.

                If False, the function will not recurse inside locked children
                nodes, and children of the locked child nodes will not be
                included in the returned tuple. (The locked child nodes,
                however, will be included.)

                For example if <recurse_in_locked_nodes> is True and
                hou.node(\"/obj/geo1\") contains a Platonic Solids node (a locked
                node), then the tuple returned by
                hou.node(\"/obj\").allSubChildren() will include the Platonic
                Solids node and its child nodes. If <recurse_in_locked_nodes> is
                False, the returned tuple will contain the Platonic Solids node,
                but not its child nodes.

            sync_delayed_definition
                The contents of nodes may some times not be loaded until the
                node is evaluated. To avoid expanding all nodes unnecessarily,
                by default these are left un-expanded so the contents will not
                be returned. Setting <sync_delayed_definition> to True will
                recursively sync all children, fully instantiating the entire
                network, and returning all the synced nodes.

            Note that a tuple is returned, not a generator. This means that it
            is safe to delete or create nodes while looping through the return
            value.

            The following function deletes all children of a particular type
            that appear anywhere inside a given node:

          > def removeSubChildrenOfType(node, node_type):
          >     '''Recursively delete all children of a particular type.'''
          >     for child in node.allSubChildren():
          >         if child.type() == node_type:
          >             child.destroy()

            This code, for example, removes all the visibility SOPs anywhere
            under /obj:

          > >>> removeSubChildrenOfType(hou.node(\"/obj\"), hou.sopNodeTypeCategory().nodeTypes()['visibility'])

        """
        return _hou.Node_allSubChildren(
            self, top_down, recurse_in_locked_nodes, sync_delayed_definition
        )

    def selectedChildren(
        self,
        include_hidden: "bool" = False,
        include_hidden_support_nodes: "bool" = False,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        selectedChildren(self, include_hidden=False,
        include_hidden_support_nodes=False) -> tuple of hou.Node

            Return a tuple containing the children of this node that are
            selected. Note that the last selected node has special meaning, and
            can also be retrieved with hou.Node.isCurrent.


            include_hidden
                If False, hidden nodes are not included in the result, even if
                they are selected.

            include_hidden_support_nodes
                If True, include in the returned tuple any hidden nodes that
                exist solely to support nodes that are actually selected. This
                specifically refers to VOP Parameter nodes, but may include
                other support nodes as well.

            The following example will print the names of all selected objects
            in /obj:

          > for n in hou.node(\"/obj\").selectedChildren():
          >     print n.name()

            To find the total number of selected children nodes, use
            len(node.selectedChildren()).


        """
        return _hou.Node_selectedChildren(
            self, include_hidden, include_hidden_support_nodes
        )

    def allItems(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        allItems(self) -> tuple of hou.NetworkMovableItem

            Return a tuple containing all the children of this node. Unlike
            children, this method will also return hou.NetworkBox,
            hou.SubnetIndirectInput, hou.StickyNote, and hou.NetworkDot objects.


        """
        return _hou.Node_allItems(self)

    def selectedItems(
        self,
        include_hidden: "bool" = False,
        include_hidden_support_nodes: "bool" = False,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        selectedItems(self, include_hidden=False,
        include_hidden_support_nodes=False) -> tuple of hou.NetworkMovableItem

            Return a tuple containing the children of this node that are
            selected. Unlike selectedChildren, this method will also return any
            selected hou.NetworkBox, hou.SubnetIndirectInput, hou.StickyNote,
            and hou.NetworkDot objects.


            include_hidden
                If False, hidden nodes are not included in the result, even if
                they are selected. Other network item types cannot be hidden,
                and so are unaffected by the value of this parameter.

            include_hidden_support_nodes
                If True, include in the returned tuple any hidden nodes that
                exist solely to support nodes that are actually selected. This
                specifically refers to VOP Parameter nodes, but may include
                other support nodes as well.

            The following example will print the positions of all selected items
            in /obj:

          > for n in hou.node(\"/obj\").selectedItems():
          >     print n.position()

        """
        return _hou.Node_selectedItems(
            self, include_hidden, include_hidden_support_nodes
        )

    def numItems(
        self,
        item_type: "EnumValue" = None,
        selected_only: "bool" = False,
        include_hidden: "bool" = False,
    ) -> "int":
        return _hou.Node_numItems(self, item_type, selected_only, include_hidden)

    def deleteItems(self, *args, **kwargs) -> "void":
        r"""

        deleteItems(self, items, disable_safety_checks=False)

            Destroys all the items in the provided tuple of
            hou.NetworkMovableItem objects. This is significantly more efficient
            than looping over the items and calling destroy() on each one. It
            also safely handles cases where one object may not be allowed to be
            deleted unless another object is also deleted.

            Raises hou.OperationFailed if one or more of the provided items is
            not a child of this node. Raises hou.PermissionError if this node is
            or is inside a locked digital asset.

            When disable_safety_checks is True, this disables safety checks that
            might otherwise crash Houdini when this method is called while nodes
            are cooking.


        """
        return _hou.Node_deleteItems(self, *args, **kwargs)

    def copyItemsToClipboard(self, *args) -> "void":
        r"""

        copyItemsToClipboard(self, items)

            Given a sequence of child items (nodes, network boxes, sticky notes,
            etc), save them to the clipboard so they can be pasted into this or
            another network.


            items
                A sequence of hou.NetworkMovableItems that are children of this
                node.

            Raises hou.OperationFailed if any of the nodes or network boxes are
            node children of this node. Raises hou.PermissionError if you do not
            have permission to read the contents of this node.


        """
        return _hou.Node_copyItemsToClipboard(self, *args)

    def pasteItemsFromClipboard(self, position: "Vector2" = None) -> "void":
        r"""

        pasteItemsFromClipboard(self, position = None)

            Load the contents of a file saved with hou.Node.copyItemsToClipboard
            into the contents of this node. If the position parameter is given
            as a tuple of two float values (or equivalent, like a hou.Vector2),
            the pasted items are moved such that they are centered around the
            provided position.

            Raises hou.OperationFailed if this node is not a network, or if
            there are errors loading the items from the clipboard. Raises
            hou.PermissionError if this node is a locked instance of a digital
            asset.


        """
        return _hou.Node_pasteItemsFromClipboard(self, position)

    def copyItems(
        self,
        items: "_NetworkMovableItemTuple",
        channel_reference_originals: "bool" = False,
        relative_references: "bool" = True,
        connect_outputs_to_multi_inputs: "bool" = False,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        copyItems(self, items, channel_reference_originals = False,
        relative_references = True, connect_outputs_to_multi_inputs = True) ->
        tuple of hou.NetworkMovableItem

            Create copies of all specified items in this network. The items do
            not need to be children of this network, but all items must be
            contained in the same parent network.

            If channel_reference_originals is True, the parameters of all new
            nodes are set to channel reference the original nodes. If a copied
            node is a sub-network, only the top level node establishes channel
            references to the original. Child nodes inside the sub-network will
            be simple copies of the original child nodes. The
            relative_references parameter controls whether the channel
            references use relative or absolute paths to the source nodes.

            If connect_outputs_to_multi_inputs is True, and any items being
            copied have outputs connected to a multi-input node (like a Merge),
            then the new item copies will also be connected to the multi-input
            node. Normally copied nodes do not have any outputs to nodes outside
            the copied set.

            Returns a tuple of all the new network items.

            Raises hou.OperationFailed if this node cannot contain children.
            Raises hou.PermissionError if this node is inside a locked asset.


        """
        return _hou.Node_copyItems(
            self,
            items,
            channel_reference_originals,
            relative_references,
            connect_outputs_to_multi_inputs,
        )

    def creator(self) -> "HOM_Node *":
        r"""

        isBuiltExplicitly(self) -> bool

            Return whether this node was built explicitly (defaults to True).
            Most nodes are built explicitly, but some are implicitly created by
            Houdini. For example, if you select geometry from multiple SOPs and
            then perform an operation, Houdini will put down an implicit merge
            SOP before performing that operation. When reselecting geometry in
            SOPs, Houdini will automatically delete any SOPs that were created
            implicitly.


        """
        return _hou.Node_creator(self)

    def isInsideLockedHDA(self) -> "bool":
        r"""

        isInsideLockedHDA(self) -> bool

            Return whether this node is inside a locked digital asset. If this
            node is not inside a locked HDA, the node may deviate from the HDA
            definition.


        """
        return _hou.Node_isInsideLockedHDA(self)

    def isEditableInsideLockedHDA(self) -> "bool":
        r"""

        isEditableInsideLockedHDA(self) -> bool

            Return False if the node is contained inside a locked HDA node and,
            is not marked as editable within that locked HDA, and True
            otherwise. In particular this function will return True for a node
            that is not inside a locked HDA (or not inside an HDA at all).


        """
        return _hou.Node_isEditableInsideLockedHDA(self)

    def isEditable(self) -> "bool":
        r"""

        isEditable(self) -> bool

            If this node is not an HDA and not inside an HDA, this method
            returns True.

            If this node is an HDA node, returns True if the node is unlocked,
            False if it is locked (this is equivalent to not
            node.matchesCurrentDefinition()).

            If this node is inside a locked HDA node, this method returns True
            if this node is or is inside an editable subnet within the locked
            HDA. Otherwise it returns False.

            This method reflects the ability of certain types of modifications
            to be made to the children of this node. These modifications, such
            as wiring nodes together, or setting flags are edits to the child
            nodes which also affect the behavior of the parent or surrounding
            nodes. For example, to determine if a node can have its display flag
            turned on, you would test node.parent().isEditable(). For
            modifications to a node that are purely internal to the node itself,
            such as modifying a parameter value, you should test if
            node.isEditableInsideLockedHDA().


        """
        return _hou.Node_isEditable(self)

    def isLockedHDA(self) -> "bool":
        r"""

        isLockedHDA(self) -> bool

            If this node is an instance of a digital asset, return whether or
            not it is locked. Otherwise, return False.

            To differentiate between unlocked digital assets and nodes that are
            not instances of digital assets, check if the node's type has a
            definition:

          > def isUnlockedAsset(node):
          >     return not node.isLockedHDA() and node.type().definition() is not None

            See hou.HDADefinition.updateFromNode for an example of how to save
            and lock all unlocked digital asset instances.


        """
        return _hou.Node_isLockedHDA(self)

    def isCompiled(self) -> "bool":
        return _hou.Node_isCompiled(self)

    def isMaterialManager(self) -> "bool":
        return _hou.Node_isMaterialManager(self)

    def hdaModule(self) -> "HOM_HDAModule *":
        r"""

        hm(self) -> hou.HDAModule

            This method is a shortcut for self.hdaModule().

            See also hou.phm.


        """
        return _hou.Node_hdaModule(self)

    def hdaViewerStateModule(self) -> "HOM_HDAViewerStateModule *":
        r"""

        hdaViewerStateModule(self) -> hou.HDAViewerStateModule

            This method creates an instance of hou.HDAViewerStateModule for this
            node type. Returns an empty object if the type is not for a digital
            asset.

            See also hou.Node.hdaViewerStateModule.


        """
        return _hou.Node_hdaViewerStateModule(self)

    def hdaViewerHandleModule(self) -> "HOM_HDAViewerHandleModule *":
        r"""

        hdaViewerHandleModule(self) -> hou.HDAViewerHandleModule

            This method creates an instance of hou.HDAViewerHandleModule for
            this node type. Returns an empty object if the type is not for a
            digital asset.

            See also hou.Node.hdaViewerHandleModule.


        """
        return _hou.Node_hdaViewerHandleModule(self)

    def hm(self) -> "HOM_HDAModule *":
        return _hou.Node_hm(self)

    def moveToGoodPosition(
        self,
        relative_to_inputs: "bool" = True,
        move_inputs: "bool" = True,
        move_outputs: "bool" = True,
        move_unconnected: "bool" = True,
    ) -> "HOM_Vector2 *":
        r"""

        moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True,
        move_outputs=True, move_unconnected=True) -> hou.Vector2

            Moves a node to a well-spaced position near its inputs or outputs
            and returns the new position of the node.


        """
        return _hou.Node_moveToGoodPosition(
            self, relative_to_inputs, move_inputs, move_outputs, move_unconnected
        )

    def layoutChildren(self, *args, **kwargs) -> "void":
        r"""

        layoutChildren(self, items=(), horizontal_spacing=-1.0,
        vertical_spacing=-1.0)

            Automatically position all or some children of this node in the
            network editor.


            items
                A sequence of child hou.NetworkMovableItem objects to position.
                This may include nodes, dots, and/or subnet inputs. If this
                sequence is empty, this method will reposition all child items
                of this node.

            horizontal_spacing
                A fraction of the width and height of a tile that affects the
                space between nodes with common inputs. If this parameter is -1,
                Houdini uses the default spacing.

            vertical_spacing
                A fraction of the width and height of a tile that affects the
                space between a node and its output nodes. If this parameter is
                -1, Houdini uses the default spacing.


        """
        return _hou.Node_layoutChildren(self, *args, **kwargs)

    def isCurrent(self) -> "bool":
        r"""

        isCurrent(self) -> bool

            Return a boolean to indicate of the node is the last selected node
            in its network.

            Each network (i.e. node containing children) stores its own list of
            selected nodes, and the last selected node has special meaning. For
            example, it is the node displayed in unpinned parameter panes.

            See also hou.selectedNodes to get a tuple of all the selected nodes
            in all networks in Houdini. The last node in this list also has
            special meaning in Houdini, and corresponds to the global current
            node.


        """
        return _hou.Node_isCurrent(self)

    def setCurrent(self, on: "bool", clear_all_selected: "bool" = False) -> "void":
        r"""

        setCurrent(self, on, clear_all_selected=False)

            Set or unset this node as the last selected one.

            Each network (i.e. node containing children) stores its own list of
            selected nodes, and the last selected node has special meaning. For
            example, it is the node displayed in unpinned parameter panes.

            If on is True, this node will become the last selected node. If it
            is False and this node was the last selected one, it will be
            unselected and the second-last selected node will become the last
            selected node.

            If clear_all_selected is true, Houdini will unselect every node in
            this network before performing the operation.

            See also hou.Node.setSelected and hou.selectedNodes.


        """
        return _hou.Node_setCurrent(self, on, clear_all_selected)

    def isHidden(self) -> "bool":
        r"""

        isHidden(self)

            Return whether the node is hidden in the network editor. Note that
            Houdini also uses the term exposed to refer to nodes that are not
            hidden.

            If a visible node is connected to a hidden node, the network editor
            will display dashed lines for the wire going from the visible node
            to the hidden node.

            See also hou.Node.hide.


        """
        return _hou.Node_isHidden(self)

    def hide(self, on: "bool") -> "void":
        r"""

        hide(self, on)

            Hide or show a node in the network editor. See hou.Node.isHidden for
            more information about hidden nodes.


        """
        return _hou.Node_hide(self, on)

    def comment(self) -> "std::string":
        r"""

        comment(self) -> str

            Return the node's comment string.


        """
        return _hou.Node_comment(self)

    def setComment(self, comment: "char const *") -> "void":
        r"""

        setComment(self, comment)

            Sets the comment associated with this node. See also
            appendComment().


        """
        return _hou.Node_setComment(self, comment)

    def appendComment(self, comment: "char const *") -> "void":
        r"""

        appendComment(self, comment)

            Appends the given text to the comment associated with this node.


        """
        return _hou.Node_appendComment(self, comment)

    def creatorState(self) -> "std::string":
        r"""

        creatorState(self) -> str

            This returns the name of the viewport tool that was used to be
            created. This name is not set by default and is usually the empty
            string.


        """
        return _hou.Node_creatorState(self)

    def setCreatorState(self, state: "char const *") -> "void":
        r"""

        setCreatorState(self, state)

            This sets the name of the tool that created this node. If you call
            this with a name that differs from the node type name, you should
            also call setBuiltExplicitly(False).


        """
        return _hou.Node_setCreatorState(self, state)

    def isBuiltExplicitly(self) -> "bool":
        return _hou.Node_isBuiltExplicitly(self)

    def setBuiltExplicitly(self, built_explicitly: "bool") -> "void":
        return _hou.Node_setBuiltExplicitly(self, built_explicitly)

    def expressionLanguage(self) -> "HOM_EnumValue *":
        r"""

        expressionLanguage(self) -> hou.exprLanguage enum value

            Return the node's default expression language.

            When you enter an expression in a parameter that does not already
            contain an expression, the node's expression language is used to
            determine how that expression should be evaluated. You can change a
            node's expression language in the parameter dialog in the GUI.

            Changing the node's expression language will not change the language
            in parameters already containing expressions (i.e. parameters with
            keyframes).

            Note that if a parameter already contains an expression and you
            change that expression in the GUI, the expression language will not
            change, regardless of the value of the node's expression language.
            To change the language of an existing expression in a parameter from
            Python, use hou.Parm.setExpression, as in
            parm.setExpression(parm.expression(), language).


        """
        return _hou.Node_expressionLanguage(self)

    def setExpressionLanguage(self, language: "EnumValue") -> "void":
        r"""

        setExpressionLanguage(self, language)

            Set the node's default expression language. See expressionLanguage()
            for more information.


        """
        return _hou.Node_setExpressionLanguage(self, language)

    def parm(self, parm_path: "char const *") -> "HOM_Parm *":
        r"""

        parm(self, parm_path) -> hou.Parm or None

            Return the parameter at the given path, or None if the parameter
            doesn't exist.


        """
        return _hou.Node_parm(self, parm_path)

    def parmTuple(self, parm_path: "char const *") -> "HOM_ParmTuple *":
        r"""

        parmTuple(self, parm_path) -> hou.ParmTuple or None

            Return the parm tuple at the given path, or None if it doesn't
            exist.

            This method is similar to parm(), except it returns a hou.ParmTuple
            instead of a hou.Parm.


        """
        return _hou.Node_parmTuple(self, parm_path)

    def globParms(
        self,
        pattern: "char const *",
        ignore_case: "bool" = False,
        search_label: "bool" = False,
        single_pattern: "bool" = False,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        globParms(self, pattern, ignore_case=False, search_label=False,
        single_pattern=False) -> tuple of hou.Parm

            Return a tuple of parameters matching the pattern.

            The pattern may contain multiple pieces, separated by spaces. An
            asterisk (*) in a pattern piece will match any character. By
            default, Houdini will add the parameters from each pattern piece to
            those already matched. However, if the pattern piece begins with a
            caret (^), Houdini will remove the matches for that piece from the
            result.

            By default the pattern match is case-sensitive. Set ignore_case to
            True for case-insensitive pattern matching. Note that case
            insensitivity only applies when matching node and parameter names.
            It does not apply when matching group, network box or bundle names.

            By default, only parameters with names matching the pattern are
            returned. Set search_label to True to also return parameters with
            labels matching the pattern.

            If single_pattern is True, the pattern will be treated as one
            pattern even if there are spaces in the pattern.

            This method returns an empty tuple if you pass in an empty pattern.


        """
        return _hou.Node_globParms(
            self, pattern, ignore_case, search_label, single_pattern
        )

    def parms(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        parms(self) -> tuple of hou.Parm

            Return a list of the parameters on this node.


        """
        return _hou.Node_parms(self)

    def parmsReferencingThis(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        parmsReferencingThis(self) -> tuple of hou.Parm

            Return a list of the parameters that reference this node.


        """
        return _hou.Node_parmsReferencingThis(self)

    def parmTuples(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        r"""

        parmTuples(self) -> tuple of hou.ParmTuple

            Return a list of all parameter tuples on this node.

            This method is similar to parms(), except it returns a list of
            hou.ParmTuple instead of hou.Parm.


        """
        return _hou.Node_parmTuples(self)

    def spareParms(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        spareParms(self) -> tuple of hou.Parm

            Return a list of the spare (user-defined) parameters on this node.


        """
        return _hou.Node_spareParms(self)

    def removeSpareParms(self) -> "void":
        r"""

        removeSpareParms(self)

            Removes all spare parameters from this node.


        """
        return _hou.Node_removeSpareParms(self)

    def syncNodeVersionIfNeeded(self, from_version: "std::string const &") -> "void":
        r"""

        syncNodeVersionIfNeeded(self, from_version)

            Synchronize the node from the specified version to the current
            version of its HDA definition. See also hou.HDADefinition.version.


        """
        return _hou.Node_syncNodeVersionIfNeeded(self, from_version)

    def setParmTemplateGroup(
        self,
        parm_template_group: "ParmTemplateGroup",
        rename_conflicting_parms: "bool" = False,
    ) -> "void":
        return _hou.Node_setParmTemplateGroup(
            self, parm_template_group, rename_conflicting_parms
        )

    def parmTuplesInFolder(
        self, folder_names: "_StringTuple"
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        r"""

        parmTuplesInFolder(self, folder_names) -> tuple of hou.ParmTuple

            Return a list of the parameter tuples in a folder on this node. This
            method is similar to parmsInFolder(), except it returns a list of
            hou.ParmTuple instead of hou.Parm. See parmsInFolder() above for
            information about the arguments.

            See also hou.Parm.containingFolders and
            hou.Parm.containingFolderSetParmTuples


        """
        return _hou.Node_parmTuplesInFolder(self, folder_names)

    def parmsInFolder(
        self, folder_names: "_StringTuple"
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        parmsInFolder(self, folder_names) -> tuple of hou.Parm

            Return a list of parameters in a folder on this node. Returns all
            parameters in the folder and its subfolders (if any).


            folder_names
                A sequence of folder name strings. For example, to get a list of
                the parameters in the Shading folder of the Render folder, use
                (\"Render\", \"Shading\"). Note that by folder name, we mean the
                label used in the parameter dialog, not the internal parameter
                name.

                If this sequence is empty, the method returns all parameters on
                the node, the same as if you called parms().

            Raises hou.OperationFailed if the folder specified by folder_names
            does not exist.

            For example, suppose a node had a Render folder that contained a
            Shading subfolder. Then this line of code would return the
            parameters in the Render folder:

          > # Note the trailing comma after \"Render\" to tell Python that \"Render\" is
          > # contained in a tuple/sequence as opposed to just a single string with
          > # parentheses around it.
          > >>> node.parmsInFolder((\"Render\", ))

            And this line of code would return the parameters in the Shading
            subfolder.

          > >>> node.parmsInFolder((\"Render\", \"Shading\"))

            See also hou.Parm.containingFolders and
            hou.Parm.containingFolderSetParmTuples

            Note that this method does not work for multi-parameters, which
            behave similar to folder parameters. To get a list of parameters in
            a multi-parameter, call hou.Parm.multiParmInstances.


        """
        return _hou.Node_parmsInFolder(self, folder_names)

    def parmTemplateGroup(self) -> "HOM_ParmTemplateGroup *":
        return _hou.Node_parmTemplateGroup(self)

    def localVariables(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        localVariables(self)

            Return a list of local variables that can be referenced in parameter
            expressions on this node using the $ prefix.


        """
        return _hou.Node_localVariables(self)

    def localAttributes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        localAttributes(self)

            Return a list of local variables that can be referenced in parameter
            expressions on this node using the @ prefix. This includes local
            variables defined in this node as attributes and any context options
            that were available to this node the last time it was cooked.


        """
        return _hou.Node_localAttributes(self)

    def isTimeDependent(self) -> "bool":
        r"""

        isTimeDependent(self) -> bool

            Return whether the node is time dependent. A time dependent node is
            re-evaluated every time the frame changes.


        """
        return _hou.Node_isTimeDependent(self)

    def destroy(self, disable_safety_checks: "bool" = False) -> "void":
        r"""

        destroy(self, disable_safety_checks=False)

            Delete this node.

            If you call methods on a Node instance after it has been destroyed,
            Houdini will raise hou.ObjectWasDeleted.

            Raises hou.OperationFailed if you try to delete a node inside a
            locked asset.

            When disable_safety_checks is True, this disables safety checks that
            might otherwise crash Houdini when this method is called while nodes
            are cooking.


        """
        return _hou.Node_destroy(self, disable_safety_checks)

    def allowEditingOfContents(self, propagate: "bool" = False) -> "void":
        r"""

        allowEditingOfContents(self, propagate=False)

            Unlocks a digital asset so its contents can be edited.

            To use this function, you must have permission to modify the HDA.


        """
        return _hou.Node_allowEditingOfContents(self, propagate)

    def matchCurrentDefinition(self) -> "void":
        r"""

        matchCurrentDefinition(self)

            If this node is an unlocked digital asset, change its contents to
            match what is stored in the definition and lock it. The parameter
            values are unchanged.

            If this node is locked or is not a digital asset, this method has no
            effect.

            See also hou.Node.matchesCurrentDefinition and hou.Node.isLocked.


        """
        return _hou.Node_matchCurrentDefinition(self)

    def matchesCurrentDefinition(self) -> "bool":
        r"""

        matchesCurrentDefinition(self) -> bool

            Return whether the contents of the node are locked to its type
            definition.


        """
        return _hou.Node_matchesCurrentDefinition(self)

    def syncDelayedDefinition(self) -> "void":
        r"""

        syncDelayedDefinition(self)

            If this node is a digital assets whose contents are currently in a
            delay-sync condition, the contents will be synced. If it is already
            synced or not a syncable asset, no effect occurs.


        """
        return _hou.Node_syncDelayedDefinition(self)

    def isDelayedDefinition(self) -> "bool":
        r"""

        isDelayedDefinition(self) -> bool

            If this node is a digital assets whose contents are currently in a
            delay-sync condition, returns true. Otherwise returns false, which
            will include nodes that are not syncable.


        """
        return _hou.Node_isDelayedDefinition(self)

    def parmAliases(
        self, recurse: "bool" = False
    ) -> "std::map< HOM_ElemPtr< HOM_Parm >,std::string,std::less< HOM_ElemPtr< HOM_Parm > >,std::allocator< std::pair< HOM_ElemPtr< HOM_Parm > const,std::string > > >":
        r"""

        parmAliases(self, recurse=False) -> dict of hou.Parm to str

            Return a dictionary of parameter aliases on the node's parameters.
            The keys in the dictionary are the parameters that have aliases and
            the values are the alias names.


            recurse
                Return the parameter aliases for this node and its children.


        """
        return _hou.Node_parmAliases(self, recurse)

    def clearParmAliases(self) -> "void":
        r"""

        clearParmAliases(self)

            Removes all alias names from parameters on the node.


        """
        return _hou.Node_clearParmAliases(self)

    def networkBoxes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkBox >,std::allocator< HOM_ElemPtr< HOM_NetworkBox > > >":
        r"""

        iterNetworkBoxes(self) -> generator of hou.NetworkBox

            Return a generator that iterates through all the network boxes
            inside this node.


        """
        return _hou.Node_networkBoxes(self)

    def iterNetworkBoxes(self) -> "HOM_IterableList< HOM_NetworkBox > *":
        return _hou.Node_iterNetworkBoxes(self)

    def createNetworkBox(self, name: "char const *" = None) -> "HOM_NetworkBox *":
        r"""

        createNetworkBox(self, name=None) -> hou.NetworkBox

            Creates a network box inside this network. Raises
            hou.OperationFailed if this node is not a network.

            If you don't specify a name, Houdini gives the box a default name.

            Network box names are not displayed in the network editor pane.
            Instead, a comment can be specified with the
            hou.NetworkBox.setComment method, and this comment will appear in
            the title bar of the network box.


        """
        return _hou.Node_createNetworkBox(self, name)

    def copyNetworkBox(
        self,
        network_box_to_copy: "NetworkBox",
        new_name: "char const *" = None,
        channel_reference_original: "bool" = False,
    ) -> "HOM_NetworkBox *":
        r"""

        copyNetworkBox(self, network_box_to_copy, new_name=None,
        channel_reference_original=False) -> hou.NetworkBox

            Copies a network box and returns the copy.

            If new_name is given, the network box will be copied to a new
            network box named new_name (a different name will be generated if
            there is already a network box with that name).

            If channel_reference_original is True, all operators created by the
            copy will have their animatable parameters set to reference the
            original operators.

            Raises hou.OperationFailed if this node is not a network or if the
            node child type does not match the network box's node type.


        """
        return _hou.Node_copyNetworkBox(
            self, network_box_to_copy, new_name, channel_reference_original
        )

    def findNetworkBox(self, name: "char const *") -> "HOM_NetworkBox *":
        r"""

        findNetworkBox(self, name) -> hou.NetworkBox

            Return a network box with the given name inside this node, or None
            if no network box with the given name exists.


        """
        return _hou.Node_findNetworkBox(self, name)

    def findNetworkBoxes(
        self, pattern: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkBox >,std::allocator< HOM_ElemPtr< HOM_NetworkBox > > >":
        r"""

        findNetworkBoxes(self, pattern) -> tuple of hou.NetworkBox

            Return a list of network boxes inside this node whose names match a
            pattern.


        """
        return _hou.Node_findNetworkBoxes(self, pattern)

    def networkDots(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkDot >,std::allocator< HOM_ElemPtr< HOM_NetworkDot > > >":
        r"""

        networkDots(self) -> tuple of hou.NetworkDot

            Returns a tuple of all dots in this network.


        """
        return _hou.Node_networkDots(self)

    def createNetworkDot(self) -> "HOM_NetworkDot *":
        r"""

        createNetworkDot(self) -> hou.NetworkDot

            Creates a network dot inside this network. Raises
            hou.OperationFailed if this node is not a network.


        """
        return _hou.Node_createNetworkDot(self)

    def changeNodeType(
        self,
        new_node_type: "char const *",
        keep_name: "bool" = True,
        keep_parms: "bool" = True,
        keep_network_contents: "bool" = True,
        force_change_on_node_type_match: "bool" = False,
    ) -> "HOM_Node *":
        r"""

        changeNodeType(self, new_node_type, keep_name=True, keep_parms=True,
        keep_network_contents=True, force_change_on_node_type_match=False) ->
        hou.Node

            Changes the node to a new type (within the same context).
            new_node_type is the internal string name of the type you want to
            change to.

            Keep_name, keep_parms, and keep_network_contents indicate that the
            node should keep the same name, parameter values, and contents,
            respectively, after its type has changed.
            force_change_on_node_type_match indicates whether to perform the
            change even when is already of the specified type.


        """
        return _hou.Node_changeNodeType(
            self,
            new_node_type,
            keep_name,
            keep_parms,
            keep_network_contents,
            force_change_on_node_type_match,
        )

    def canCreateDigitalAsset(self) -> "bool":
        r"""

        canCreateDigitalAsset(self) -> bool

            Return True if hou.Node.createDigitalAsset can succeed.


        """
        return _hou.Node_canCreateDigitalAsset(self)

    def createDigitalAsset(
        self,
        name: "char const *" = None,
        hda_file_name: "char const *" = None,
        description: "char const *" = None,
        min_num_inputs: "int" = 0,
        max_num_inputs: "int" = 0,
        compress_contents: "bool" = False,
        comment: "char const *" = None,
        version: "char const *" = None,
        save_as_embedded: "bool" = False,
        ignore_external_references: "bool" = False,
        compile_asset: "bool" = False,
        change_node_type: "bool" = True,
        create_backup: "bool" = True,
        install_path: "char const *" = None,
    ) -> "HOM_Node *":
        r"""

        createDigitalAsset(self, name=None, hda_file_name=None,
        description=None, min_num_inputs=0, max_num_inputs=0,
        compress_contents=False, comment=None, version=None,
        save_as_embedded=False, ignore_external_references=False,
        change_node_type=True, create_backup=True, install_path=None) -> Node

            Create a digital asset from this node. You would typically call this
            method on subnet nodes.


            name
                The name of the node type that the new digital asset will
                define.

            hda_file_name
                The name of the hda file where Houdini will save the digital
                asset. If None Houdini will use
                $HOME/houdiniX.Y/hda/OPcustom.hda.

            description
                The name that will appear in the tab menu. If None, Houdini will
                use the name for the description.

            min_num_inputs
                The minimum number of inputs that need to be wired into
                instances of the digital asset. See
                hou.HDADefinition.minNumInputs for more information.

            max_num_inputs
                The number of input connectors available on instances of the
                digital asset for input connections. See
                hou.HDADefinition.minNumInputs for more information.

            compress_contents
                Whether or not the contents of this digital asset are compressed
                inside the hda file. See hou.HDAOptions.compressContents for
                more information.

            comment
                A user-defined comment string. See hou.HDADefinition.comment for
                more information.

            version
                A user-defined version string. See hou.HDADefinition.version for
                more information.

            save_as_embedded
                Whether or not the digital asset's definition will be saved with
                the hip file instead of an hda file. When this parameter is
                True, Houdini ignores the hda_file_name parameter. Setting this
                parameter to True is equivalent to setting this parameter to
                False and setting the hda_file_name parameter to Embedded.

            ignore_external_references
                If True, Houdini will not generate warnings if the contents of
                this digital asset reference nodes outside the asset.

            change_node_type
                Normally, Houdini will change the node creating the digital
                asset into the new digital asset type. Setting this flag to
                false will cause the node to remain unchanged.

            create_backup
                Create a backup before modifying an existing hda file.

            install_path
                Where to install the new hda. When not specified, it will
                install to either Current HIP File or Scanned Asset Library
                Directories.


        """
        return _hou.Node_createDigitalAsset(
            self,
            name,
            hda_file_name,
            description,
            min_num_inputs,
            max_num_inputs,
            compress_contents,
            comment,
            version,
            save_as_embedded,
            ignore_external_references,
            compile_asset,
            change_node_type,
            create_backup,
            install_path,
        )

    def createCompiledDigitalAsset(
        self,
        name: "char const *" = None,
        hda_file_name: "char const *" = None,
        description: "char const *" = None,
    ) -> "void":
        r"""

        createCompiledDigitalAsset(self, name=None, hda_file_name=None,
        description=None)

            Create a compiled digital asset from this node. You would typically
            call this method on VOP network nodes, such as Material Shader
            Builder SHOP, Surface Shader Builder SHOP, or VEX Surface SHOP Type
            VOPNET. The digital asset does not have contents section, which
            means it does not have VOP network inside, but instead relies on the
            saved VEX code sections to provide the shader code.

            After the creation of a compiled HDA, if its VEX code section is
            ever changed manually, the corresponding vex object code section can
            be recompiled using hou.HDADefinition.compileCodeSection.


            name
                The name of the node type that the new digital asset will
                define.

            hda_file_name
                The name of the hda file where Houdini will save the digital
                asset. If None Houdini will use
                $HOME/houdiniX.Y/hda/OPcustom.hda.

            description
                The name that will appear in the tab menu. If None, Houdini will
                use the name for the description.


        """
        return _hou.Node_createCompiledDigitalAsset(
            self, name, hda_file_name, description
        )

    def collapseIntoSubnet(
        self,
        child_items: "_NetworkMovableItemTuple",
        subnet_name: "char const *" = None,
        subnet_type: "char const *" = None,
    ) -> "HOM_Node *":
        r"""

        collapseIntoSubnet(self, child_nodes, subnet_name=None,
        subnet_type=None) -> hou.Node

            Given a sequence of children nodes of this node, collapse them into
            a subnetwork. In other words, create a subnet inside this node's
            network and move the specified children of this network inside that
            subnet.


            child_nodes
                The children nodes of this node that will go in the new subnet.

            subnet_name
                The name for the new subnet node, or None if you want Houdini to
                automatically choose a name.

            subnet_type
                The type for the new subnet node, or None if you want Houdini to
                automatically choose a primary subnetwork type, which is
                recommended.

            Raises hou.OperationFailed if a node inside child_nodes is not a
            child of this network, or if child_nodes is an empty sequence.

            This example function takes a single node and replaces it with a
            subnet, moving the node into the subnet..

          > def collapseSingleNodeIntoSubnet(node, subnet_name=None):
          >     node.parent().collapseIntoSubnet((node,), subnet_name=None)

        """
        return _hou.Node_collapseIntoSubnet(self, child_items, subnet_name, subnet_type)

    def extractAndDelete(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        extractAndDelete(self) -> tuple of hou.NetworkMovableItem

            Move the children of this subnet node to become siblings of this
            node, and then delete this node. The method is the opposite of
            collapseIntoSubnet(). Returns a tuple containing all extracted
            items.

            Raises hou.InvalidNodeType if this node is not a subnetwork.


        """
        return _hou.Node_extractAndDelete(self)

    def indirectInputs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_SubnetIndirectInput >,std::allocator< HOM_ElemPtr< HOM_SubnetIndirectInput > > >":
        r"""

        indirectInputs(self) -> tuple of hou.SubnetIndirectInput

            Return the hou.SubnetIndirectInput objects of a subnet.

            Raises hou.InvalidNodeType if this node is not a subnetwork.


        """
        return _hou.Node_indirectInputs(self)

    def subnetOutputs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        subnetOutputs(self) -> tuple of hou.Node

            Return the child output nodes of a subnetwork.

            Certain networks, such as SOPs, have special Output nodes to
            override the canonical Display or Render nodes and allow multiple
            outputs. If any output nodes are present, this returns a list of
            those nodes. If no output nodes are present, either the display or
            render node is returned depending on if the target of cooking is the
            display or an output driver. If the node has no children, an empty
            list is returned.


        """
        return _hou.Node_subnetOutputs(self)

    def isSubNetwork(self) -> "bool":
        r"""

        isSubNetwork(self) -> bool

            Return True if the node is a sub-network and False otherwise.


        """
        return _hou.Node_isSubNetwork(self)

    def setUserData(self, name: "char const *", value: "std::string const &") -> "void":
        r"""

        setUserData(self, name, value)

            Add/set a named string on this node instance.


            name
                A unique name (key) for the user-defined data. By using
                different names, you can attach multiple pieces of user-defined
                data to a node.

            value
                The string to store.

            This name/value pair is stored with the hip file and is included in
            the output from opscript and hou.Node.asCode.

            The following example illustrates how to set, access, and delete
            user-defined data:

          > >>> n = hou.node(\"/obj\").createNode(\"geo\")
          > >>> n.setUserData(\"my data\", \"my data value\")
          > >>> n.userData(\"my data\")
          > 'my data value'
          > >>> n.userDataDict()
          > {'my data': 'my data value'}
          > >>> n.destroyUserData(\"my data\")
          > >>> n.userDataDict()
          > {}
          > >>> print n.userData(\"my data\")
          > None

            See per-node user-defined data for more information and examples.


            TIP
                If you prefix a user data key with nodeinfo_, the key (without
                the prefix) and the value will be shown as a custom field in the
                node info popup window.


        """
        return _hou.Node_setUserData(self, name, value)

    def destroyUserData(
        self, name: "char const *", must_exist: "bool" = True
    ) -> "void":
        r"""

        destroyUserData(self, name, must_exist=True)

            Remove the user-defined data with this name.

            See hou.Node.setUserData for more information.

            Raises hou.OperationFailed if no user data with this name exists and
            must_exist is True.


        """
        return _hou.Node_destroyUserData(self, name, must_exist)

    def clearUserDataDict(self) -> "void":
        r"""

        clearUserDataDict(self)

            Remove all user-defined data.

            See hou.Node.setUserData for more information.


        """
        return _hou.Node_clearUserDataDict(self)

    def userDataDict(
        self,
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        userDataDict(self) -> dict of str to str

            Return a dictionary containing all the user-defined name/string
            pairs for this node.

            See hou.Node.setUserData for more information.


        """
        return _hou.Node_userDataDict(self)

    def selectNextVisibleWorkItem(self) -> "void":
        r"""

        selectNextVisibleWorkItem(self)

            If a work item is selected, selects the next visible work item


        """
        return _hou.Node_selectNextVisibleWorkItem(self)

    def selectPreviousVisibleWorkItem(self) -> "void":
        r"""

        selectPreviousVisibleWorkItem(self)

            If a work item is selected, selects the previous work item


        """
        return _hou.Node_selectPreviousVisibleWorkItem(self)

    def deselectWorkItem(self) -> "void":
        r"""

        deselectWorkItem(self)

            Deselects the active work item if this node is inside or contains
            the TOP network with the currently selected work item.


        """
        return _hou.Node_deselectWorkItem(self)

    def setCurrentTOPPage(self, page: "int") -> "void":
        r"""

        setCurrentTOPPage(page_index)

            If a TOP node can't display all work items, sets which work item
            subset (page) will be displayed


        """
        return _hou.Node_setCurrentTOPPage(self, page)

    def userData(self, name: "char const *") -> "InterpreterObject":
        r"""

        userData(self, name) -> str or None

            Return the user-defined data with this name, or None if no data with
            this name exists.

            See hou.Node.setUserData for more information.

            This method can be implemented as follows:

          > def userData(self, name):
          >     return self.userDataDict().get(name)

        """
        return _hou.Node_userData(self, name)

    def destroyCachedUserData(
        self, name: "char const *", must_exist: "bool" = True
    ) -> "void":
        r"""

        destroyCachedUserData(self, name, must_exist=True)

            Remove the user-defined cached data with this name.

            See hou.Node.setCachedUserData for more information.

            Raises hou.OperationFailed if no user data with this name exists and
            must_exist is True.


        """
        return _hou.Node_destroyCachedUserData(self, name, must_exist)

    def clearCachedUserDataDict(self) -> "void":
        r"""

        clearCachedUserDataDict(self)

            Remove all user-defined cached data.

            See hou.Node.setCachedUserData for more information.


        """
        return _hou.Node_clearCachedUserDataDict(self)

    def cachedUserDataDict(
        self,
    ) -> "std::map< std::string,PY_OpaqueObject,std::less< std::string >,std::allocator< std::pair< std::string const,PY_OpaqueObject > > >":
        r"""

        cachedUserDataDict(self) -> dict of str to any python object`

            Return a dictionary containing all the user-defined name/string
            pairs for this node.

            See hou.Node.setCachedUserData for more information.


        """
        return _hou.Node_cachedUserDataDict(self)

    def setCachedUserData(
        self, name: "char const *", value: "InterpreterObject"
    ) -> "void":
        r"""

        setCachedUserData(self, name, value)

            Add/set a named value on this node instance. Unlike setUserData,
            values set using this method are not saved with the hip file.

            name: A unique name (key) for the user-defined data. By using
            different names, you can attach multiple pieces of user-defined data
            to a node. value: The value to store. Unlike setUserData, this value
            may be any Python object.

            This name/value pair is not stored with the hip file. It is useful
            for nodes implemented in Python that want to save temporary values
            between cooks, to avoid recomputing them on subsequent cooks.

            The following example illustrates how to set, access, and delete
            cached user-defined data:

          > >>> n = hou.node(\"/obj\").createNode(\"geo\")
          > >>> n.setCachedUserData(\"my data\", [1, 2, {\"a\": \"b\", \"c\": \"d\"}])
          > >>> n.cachedUserData(\"my data\")
          > [1, 2, {'a': 'b', 'c': 'd'}]
          > >>> n.cachedUserDataDict()
          > {'my data': [1, 2, {'a': 'b', 'c': 'd'}]}
          > >>> n.destroyCachedUserData(\"my data\")
          > >>> n.cachedUserDataDict()
          > {}
          > >>> print n.cachedUserData(\"my data\")
          > None

            See per-node user-defined data for more information and examples.


        """
        return _hou.Node_setCachedUserData(self, name, value)

    def cachedUserData(self, name: "char const *") -> "InterpreterObject":
        r"""

        cachedUserData(self, name) -> any python obect or None

            Return the user-defined cached data with this name, or None if no
            data with this name exists.

            See hou.Node.setCachedUserData for more information.

            This method can be implemented as follows:

          > def cachedUserData(self, name):
          >     return self.cachedUserDataDict().get(name)

            Note that None is a valid value for a key, so the most reliable way
            to check if a key is valid is to check if it is in the result of
            cachedUserDataDict:

          > >>> n = hou.node(\"/obj\").createNode(\"geo\")
          > >>> n.cachedUserDataDict()
          > {}
          > >>> print n.cachedUserData(\"foo\")
          > None
          > >>> \"foo\" in n.cachedUserDataDict()
          > False
          > >>> n.setCachedUserData(\"foo\", None)
          > >>> n.cachedUserDataDict()
          > {'foo': None}
          > >>> print n.cachedUserData(\"foo\")
          > None
          > >>> \"foo\" in n.cachedUserDataDict()
          > True

        """
        return _hou.Node_cachedUserData(self, name)

    def dataBlockKeys(
        self, blocktype: "char const *" = None
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        dataBlockKeys(self, blocktype) -> tuple of str

            Return the names of all data blocks stored on this node that are of
            the data type specified by the blocktype parameter.

            Data blocks are similar to user data in that they can contain any
            extra data that may be useful to attach to a specific node. They
            differ from user data in that data blocks are designed to more
            efficiently handle large blocks of data. Data blocks can also
            contain binary data, and have a data type associated with each
            block.


        """
        return _hou.Node_dataBlockKeys(self, blocktype)

    def dataBlockType(self, key: "char const *") -> "std::string":
        r"""

        dataBlockType(self, key) -> str

            Return the data type of the block specified by the key parameter.

            Raises hou.ValueError if the provided key is not associated with any
            data block on this node.


        """
        return _hou.Node_dataBlockType(self, key)

    def dataBlock(self, key: "char const *") -> "HOM_BinaryString":
        r"""

        dataBlock(self, key) -> str for Python 2, bytes for Python 3

            Returns the data block as a binary string stored under the given
            key. This method will only work if the specified data block is has a
            type that can be represented by a python object. Otherwise None is
            returned.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            Raises hou.ValueError if the provided key is not associated with any
            data block on this node.


        """
        return _hou.Node_dataBlock(self, key)

    def setDataBlock(
        self, key: "char const *", data: "HOM_BinaryString", blocktype: "char const *"
    ) -> "void":
        r"""

        setDataBlock(self, key, block, blocktype)

            Stores the provided data block on the node under the provided key
            name, marking it with the provided data type.

            Passing an empty string as the block value will remove any data
            block with the specified key. Data blocks can also be removed with
            the removeDataBlock() method.

            The blocktype string argument requires a C++/HDK plugin to interpret
            data blocks and turn them into C++ objects. If you're using Python
            to get and set data blocks, leave the blocktype empty.


        """
        return _hou.Node_setDataBlock(self, key, data, blocktype)

    def removeDataBlock(self, key: "char const *") -> "void":
        r"""

        removeDataBlock(self, key)

            Removes any existing data block on the node with the specified key.
            If there is no data block with this key, this method does nothing.


        """
        return _hou.Node_removeDataBlock(self, key)

    def asCode(
        self,
        brief: "bool" = False,
        recurse: "bool" = False,
        save_channels_only: "bool" = False,
        save_creation_commands: "bool" = True,
        save_keys_in_frames: "bool" = False,
        save_outgoing_wires: "bool" = False,
        save_parm_values_only: "bool" = False,
        save_spare_parms: "bool" = True,
        save_box_membership: "bool" = True,
        function_name: "char const *" = None,
    ) -> "std::string":
        r"""

        asCode(self, brief=False, recurse=False, save_channels_only=False,
        save_creation_commands=True, save_keys_in_frames=False,
        save_outgoing_wires=False, save_parm_values_only=False,
        save_spare_parms=True, save_box_membership=True, function_name=None) ->
        str

            Prints the Python code necessary to recreate a node.


            brief
                Do not set values if they are the parameter's default. Applies
                to the contents of the node if either recurse or
                save_box_contents is True.

            recurse
                Recursively apply to the entire operator hierarchy.

            save_box_contents
                Script the contents of the node.

            save_channels_only
                Only output channels. Applies to the contents of the node if
                either recurse or save_box_contents is True.

            save_creation_commands
                Generate a creation script for the node. If set to False, the
                generated script assumes that the network box already exists.
                When set to True, the script will begin by creating the network
                box.

            save_keys_in_frames
                Output channel and key times in samples (frames) instead of
                seconds. Applies to the contents of the node if either recurse
                or save_box_contents is True.

            save_parm_values_only
                Evaluate parameters, saving their values instead of the
                expressions. Applies to the contents of the node if either
                recurse or save_box_contents is True.

            save_spare_parms
                Save spare parameters as well. When save_creation_commands is
                True, commands for creating spare parameters will also be
                output. Applies to the contents of the node if either recurse or
                save_box_contents is True.

            save_box_membership
                Output code to add the root item to its parent network box, if
                any.

            function_name
                If a function_name is specified, the output will be wrapped in a
                Python function.


        """
        return _hou.Node_asCode(
            self,
            brief,
            recurse,
            save_channels_only,
            save_creation_commands,
            save_keys_in_frames,
            save_outgoing_wires,
            save_parm_values_only,
            save_spare_parms,
            save_box_membership,
            function_name,
        )

    def canGenerateCookCode(
        self, check_parent: "bool" = False, check_auto_shader: "bool" = True
    ) -> "bool":
        r"""

        canGenerateCookCode(self, check_parent=False, check_auto_shader=True) ->
        bool

            Return True if the node can generate compiled cook code and False
            otherwise.

            If check_parent is true, the parents in the ancestor hierarchy are
            tested if any of them can generate code.

            If the node cannot generate cook code explicitly, it might still be
            able to provide such code implicitly, if it can be wrapped in auto-
            shader. E.g., a building-block VOPs such as Anti-Aliased Noise don't
            generate a complete cook code; they provide code fragment that
            contributes to the full cook function. But sometimes they can be
            automatically wrapped in such a function, which which will act as
            cook code. If check_auto_shader is true, the node will be tested if
            it provides implicit cook code.


        """
        return _hou.Node_canGenerateCookCode(self, check_parent, check_auto_shader)

    def cookCodeGeneratorNode(self) -> "HOM_Node *":
        r"""

        cookCodeGeneratorNode(self, check_parent=False) -> hou.Node

            Return the node itself or a network node that contains this node and
            can generate compiled cook code. For example, the generator node for
            a VOP node could be the SHOP node or SOP node that contains it for
            example.

            Return None if this node cannot generate code and is not contained
            in a code generating node either either.


        """
        return _hou.Node_cookCodeGeneratorNode(self)

    def cookCodeLanguage(self) -> "std::string":
        r"""

        cookCodeLanguage(self) -> str

            Return the language of the generated cook code (i.e. VEX, RSL).

            Raises hou.OperationFailed if this node cannot generate compiled
            code.


        """
        return _hou.Node_cookCodeLanguage(self)

    def supportsMultiCookCodeContexts(self) -> "bool":
        r"""

        supportsMultiCookCodeContexts(self) -> bool

            Return True if this node can generate compiled cook code for
            multiple contexts (i.e. surface context, displacement context, etc.)
            and False otherwise.

            Raises hou.OperationFailed if this node cannot generate compiled
            code.


        """
        return _hou.Node_supportsMultiCookCodeContexts(self)

    def saveCookCodeToFile(
        self,
        file_name: "char const *",
        skip_header: "bool" = False,
        context_name: "char const *" = None,
    ) -> "void":
        r"""

        saveCookCodeToFile(self, file_name, skip_header=False,
        context_name=None)

            Saves VEX/RSL source code to a disk file (on nodes that support
            this).


            file_name
                The file path in which to save the generated code.

            skip_header
                If True, the method does not write a header comment at the
                beginning of the file containing the file name and node path
                from which the code was generated and a time stamp.

            context_name
                A string containing name of the shader context for the code.
                This option applies to nodes such as the Material Shader Builder
                which can generate code for multiple context types.

                For example, a Material network might contain both surface and
                displacement shaders, so you must specify which type of shader
                code to generate:

              > node(\"/shop/vopmaterial1\").saveCookCodeToFile(\"myfile.vfl\", context_name=\"surface\")

                On single-context nodes this argument is ignored.

                For VEX materials, possible values are surface, displacement,
                light, shadow, fog, image3d, photon, or cvex.

                For RSL materials, possible values are surface, displacement,
                light, volume, or imager.


        """
        return _hou.Node_saveCookCodeToFile(self, file_name, skip_header, context_name)

    def saveCodeToFile(
        self,
        file_name: "char const *",
        skip_header: "bool" = False,
        context_name: "char const *" = None,
    ) -> "void":
        return _hou.Node_saveCodeToFile(self, file_name, skip_header, context_name)

    def saveCompiledCookCodeToFile(
        self, file_name: "char const *", context_name: "char const *" = None
    ) -> "void":
        r"""

        saveCompiledCookCodeToFile(self, file_name, context_name=None)

            Saves compiled VEX code to a disk file (for nodes that support
            this). See hou.Node.saveCookCodeToFile for a description of the
            arguments.


        """
        return _hou.Node_saveCompiledCookCodeToFile(self, file_name, context_name)

    def saveToCompiledVexFile(
        self, file_name: "char const *", context_name: "char const *" = None
    ) -> "void":
        return _hou.Node_saveToCompiledVexFile(self, file_name, context_name)

    def cook(self, *args, **kwargs) -> "void":
        r"""

        cook(self, force=False, frame_range=())

            Asks or forces the node to re-cook.


            frame_range
                The frames at which to cook the object. This should be a tuple
                of 2 or 3 ints giving the start frame, end frame, and optionally
                a frame increment, in that order. If you supply a two-tuple
                (start, end), the increment is 1.


        """
        return _hou.Node_cook(self, *args, **kwargs)

    def _cookNoInterruptInternal(self, *args) -> "void":
        return _hou.Node__cookNoInterruptInternal(self, *args)

    def needsToCook(self, *args) -> "bool":
        r"""

        needsToCook(self, time=hou.time()) -> bool

            Asks if the node needs to re-cook.


        """
        return _hou.Node_needsToCook(self, *args)

    def cookCount(self) -> "int":
        r"""

        cookCount(self) -> int

            Returns the number of times this node has cooked in the current
            session.


        """
        return _hou.Node_cookCount(self)

    def updateParmStates(self) -> "void":
        r"""

        updateParmStates(self)

            Update the UI states, such as hidden and disabled, for each
            parameter in the node.

            UI states can be expressed as conditionals (i.e. Disable When) which
            require evaluation. Typically in graphical Houdini the Parameter
            Pane performs the evaluation when the node is selected in order to
            determine how the node parameters should look in the pane. However
            in non-graphical Houdini or if the Parameter Pane has not yet loaded
            the node, then the evaluation does not occur and the UI states
            remain at their defaults causing methods such as hou.Parm.isDisabled
            and hou.Parm.isHidden to return incorrect values. In these cases, it
            is recommended that hou.Node.updateParmStates is called.


        """
        return _hou.Node_updateParmStates(self)

    def deleteScript(self) -> "std::string":
        r"""

        deleteScript(self) -> str

            Return the script that will run when this node is deleted.


        """
        return _hou.Node_deleteScript(self)

    def setDeleteScript(self, *args) -> "void":
        r"""

        setDeleteScript(self, script_text, language=hou.scriptLanguage.Python)

            Sets the script that will run when this node is deleted.


        """
        return _hou.Node_setDeleteScript(self, *args)

    def createStickyNote(self, name: "char const *" = None) -> "HOM_StickyNote *":
        r"""

        createStickyNote(self, name=None) -> hou.StickyNote

            Creates a sticky note inside this network. Raises
            hou.OperationFailed if this node is not a network.

            If you don't specify a name, Houdini gives the note a default name.


        """
        return _hou.Node_createStickyNote(self, name)

    def stickyNotes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_StickyNote >,std::allocator< HOM_ElemPtr< HOM_StickyNote > > >":
        r"""

        iterStickyNotes(self) -> generator of hou.StickyNote

            Return a generator that iterates through all the sticky notes inside
            this node.


        """
        return _hou.Node_stickyNotes(self)

    def iterStickyNotes(self) -> "HOM_IterableList< HOM_StickyNote > *":
        return _hou.Node_iterStickyNotes(self)

    def copyStickyNote(
        self, sticky_note_to_copy: "StickyNote", new_name: "char const *" = None
    ) -> "HOM_StickyNote *":
        r"""

        copyStickyNote(self, network_box_to_copy, new_name=None) ->
        hou.StickyNote

            Copies a sticky note and returns the copy.

            If new_name is given, the sticky note will be copied to a new sticky
            note named new_name (a different name will be generated if there is
            already a sticky note with that name).

            Raises hou.OperationFailed if this node is not a network or if the
            node child type does not match the sticky note's node type.


        """
        return _hou.Node_copyStickyNote(self, sticky_note_to_copy, new_name)

    def findStickyNote(self, name: "char const *") -> "HOM_StickyNote *":
        r"""

        findStickyNote(self, name) -> hou.StickyNote

            Return a sticky note with the given name inside this node, or None
            if no sticky note with the given name exists.


        """
        return _hou.Node_findStickyNote(self, name)

    def findStickyNotes(
        self, pattern: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_StickyNote >,std::allocator< HOM_ElemPtr< HOM_StickyNote > > >":
        r"""

        findStickyNotes(self, pattern) -> tuple of hou.StickyNote

            Return a list of sticky notes inside this node whose names match a
            pattern.


        """
        return _hou.Node_findStickyNotes(self, pattern)

    def addNodeGroup(self, name: "char const *" = None) -> "HOM_NodeGroup *":
        r"""

        addNodeGroup(self, name=None) -> hou.NodeGroup

            Add a node group to the node and return the new group.

            If a group of the given name already exists then this function
            simply returns the existing group without adding a new one. If the
            name of the group is None or an empty string, then a unique default
            name is automatically chosen.

            This function can only be called on nodes that are networks. If it
            is called on a node that is not a network, then it raises
            hou.OperationFailed.

            To remove a node group, use hou.NodeGroup.destroy.


        """
        return _hou.Node_addNodeGroup(self, name)

    def nodeGroups(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NodeGroup >,std::allocator< HOM_ElemPtr< HOM_NodeGroup > > >":
        r"""

        nodeGroups(self) -> tuple of hou.NodeGroup

            Return the list of node groups in this node.


        """
        return _hou.Node_nodeGroups(self)

    def nodeGroup(self, name: "char const *") -> "HOM_NodeGroup *":
        r"""

        nodeGroup(self, name) -> hou.NodeGroup

            Return a node group contained by the node with the given name, or
            None if the group does not exist.


        """
        return _hou.Node_nodeGroup(self, name)

    def errors(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        errors(self) -> tuple of str

            Return the text of any errors from the last cook of this node, or an
            empty tuple if there were no errors.


        """
        return _hou.Node_errors(self)

    def warnings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        warnings(self) -> tuple of str

            Return the text of any warnings from the last cook of this node, or
            an empty tuple if there were no warnings.


        """
        return _hou.Node_warnings(self)

    def messages(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        messages(self) -> tuple of str

            Return the text of any messages from the last cook of this node, or
            an empty tuple if there were no messages.


        """
        return _hou.Node_messages(self)

    def motionEffectsNetworkPath(self) -> "std::string":
        r"""

        motionEffectsNetworkPath(self) -> str

            Return a node path representing the location for storing clips. This
            location may or may not exist. To find or create such a network, use
            hou.Node.findOrCreateMotionEffectsNetwork.


        """
        return _hou.Node_motionEffectsNetworkPath(self)

    def findOrCreateMotionEffectsNetwork(self, create: "bool" = True) -> "HOM_Node *":
        r"""

        findOrCreateMotionEffectsNetwork(self, create=True) ->
        hou.chopNetNodeTypeCategory

            Return a CHOP network node suitable for storing Motion Effects. By
            default, if the node doesn't exist, it will be created.

            See also hou.Parm.storeAsClip and hou.Node.motionEffectsNetworkPath.


        """
        return _hou.Node_findOrCreateMotionEffectsNetwork(self, create)

    def saveItemsToFile(
        self,
        items: "_NetworkMovableItemTuple",
        file_name: "char const *",
        save_hda_fallbacks: "bool" = False,
    ) -> "void":
        r"""

        saveItemsToFile(self, items, file_name, save_hda_fallbacks = False)

            Given a sequence of child items (nodes, network boxes, sticky notes,
            etc), save a file containing those items. You can load this file
            using hou.Node.loadItemsFromFile.


            items
                A sequence of hou.NetworkMovableItems that are children of this
                node.

            file_name
                The name of the file to write the contents to. You can use any
                extension for this file name.

            save_hda_fallbacks
                Set to True to save simplified definitions for HDAs into the
                file along with the child nodes. Doing this allows the generated
                file to be safely loaded into any houdini session, even if the
                assets used in the file are not already loaded into the houdini
                session. Depending on the use of the generated file, this
                information is often not required and makes the files
                unnecessarily large.

            Raises hou.OperationFailed if any of the nodes or network boxes are
            node children of this node, or if the file could not be written to.
            Raises hou.PermissionError if you do not have permission to read the
            contents of this node.


        """
        return _hou.Node_saveItemsToFile(self, items, file_name, save_hda_fallbacks)

    def loadItemsFromFile(
        self, file_name: "char const *", ignore_load_warnings: "bool" = False
    ) -> "void":
        r"""

        loadItemsFromFile(self, file_name, ignore_load_warnings=False)

            Load the contents of a file (saved with hou.Node.saveItemsToFile)
            into the contents of this node.

            Raises hou.OperationFailed if the file does not exist or it is not
            the correct type of file. Raises hou.PermissionError if this node is
            a locked instance of a digital asset. Raises hou.LoadWarning if the
            load succeeds but with warnings and ignore_load_warnings is False.


        """
        return _hou.Node_loadItemsFromFile(self, file_name, ignore_load_warnings)

    def removeAllEventCallbacks(self) -> "void":
        r"""

        removeAllEventCallbacks(self)

            Remove all event callbacks for all event types from this node.

            See hou.Node.addEventCallback for more information.


            WARNING
                removeAllEventCallbacks should be used carefully, especially
                with viewer states as it may cause functionality to silently
                stop working when entering a state.


        """
        return _hou.Node_removeAllEventCallbacks(self)

    def stampValue(self, *args) -> "std::string":
        r"""

        stampValue(self, parm_name, default_value)

            Return a copy stamping floating point or string value. This node
            must be a downstream stamping operator, such as a Copy SOP, Cache
            SOP, LSystem SOP, or Copy CHOP.


            parm_name
                The name of the stamping variable.

            default_value
                The value that this function returns if Houdini is not currently
                performing stamping, or if parm_name is not a valid variable
                name. This value may be a float or a string.

            You might put the following expression in a Python parameter:

          > node(\"../copy1\").stampValue(\"sides\", 5)

        """
        return _hou.Node_stampValue(self, *args)

    def _asVoidPointer(self) -> "void *":
        return _hou.Node__asVoidPointer(self)

    def simulation(self) -> "HOM_DopSimulation *":
        return _hou.Node_simulation(self)

    def findNodesThatProcessedObject(
        self, dop_object: "DopObject"
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        return _hou.Node_findNodesThatProcessedObject(self, dop_object)

    def _parmClipData(
        self,
        start: "double",
        end: "double",
        binary: "bool" = True,
        use_blosc_compression: "bool" = True,
        sample_rate: "double" = 0,
        scoped_only: "bool" = False,
    ) -> "HOM_BinaryString":
        return _hou.Node__parmClipData(
            self, start, end, binary, use_blosc_compression, sample_rate, scoped_only
        )

    def _setParmClipData(self, *args, **kwargs) -> "void":
        return _hou.Node__setParmClipData(self, *args, **kwargs)

    def _saveParmClip(
        self,
        file_name: "std::string",
        start: "double",
        end: "double",
        sample_rate: "double" = 0,
        scoped_only: "bool" = False,
    ) -> "void":
        return _hou.Node__saveParmClip(
            self, file_name, start, end, sample_rate, scoped_only
        )

    def _loadParmClip(self, *args, **kwargs) -> "void":
        return _hou.Node__loadParmClip(self, *args, **kwargs)

    def __creationTime(self) -> "int":
        return _hou.Node___creationTime(self)

    def __modificationTime(self) -> "int":
        return _hou.Node___modificationTime(self)

    def evalParm(self, parm_path: "char const *") -> "InterpreterObject":
        r"""

        evalParm(self, parm_path) -> int, float, or str

            Evaluates the specified parameter and returns the result.


        """
        return _hou.Node_evalParm(self, parm_path)

    def evalParmTuple(self, parm_path: "char const *") -> "InterpreterObject":
        r"""

        evalParmTuple(self, parm_path) -> tuple of int, float, or str

            Evaluates the specified parameter tuple and returns the result.


        """
        return _hou.Node_evalParmTuple(self, parm_path)

    def addEventCallback(
        self, event_types: "_EnumTuple", callback: "InterpreterObject"
    ) -> "void":
        r"""

        addEventCallback(self, event_types, callback)

            Registers a Python callback that Houdini will call whenever a
            particular action, or event, occurs on this particular node
            instance.

            Callbacks only persist for the current session. For example, they
            are not saved to the .hip file. If you want persistent callbacks in
            every session, you can add them in code in 456.py (runs when the
            user opens a .hip file). See where to add Python scripting for more
            information.


            event_types
                A sequence of hou.nodeEventType enumeration values describing
                the event types that will cause Houdini to call the callback
                function.

            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

                Houdini calls the function with an event_type keyword argument
                containing the hou.nodeEventType value corresponding to the
                event that triggered the callback.

                Houdini will pass additional keyword arguments depending on the
                event type. For example, in a callback for the ParmTupleChanged
                event, Houdini will pass a parm_tuple keyword argument
                containing a hou.ParmTuple reference to the parameter that
                changed. See hou.nodeEventType for the extra arguments (if any)
                passed for each event type.

                You can add **kwargs to the argument list to accept all keyword
                arguments, to allow the same callback to be used for different
                events, or to be safe from future changes:

              > def event_callback(event_type, **kwargs):
              >     ...

            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to an event. However, it may be useful to add the same
                function if you want to register it with different event_types.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            The following example shows to set up a function that's called
            whenever a certain node's name changes:

          >
          > def name_changed(node, event_type, **kwargs):
          >     print(\"The geometry object is now named\", node.name())
          >
          > hou.node(\"/obj/geo1\").addEventCallback((hou.nodeEventType.NameChanged, ), name_changed)

            See also hou.Node.removeEventCallback and
            hou.Node.removeAllEventCallbacks.


        """
        return _hou.Node_addEventCallback(self, event_types, callback)

    def addParmCallback(
        self, callback: "InterpreterObject", names: "_StringTuple"
    ) -> "void":
        r"""

        addParmCallback(self, callback, parm_names)

            Registers a Python callback that Houdini will call whenever a
            parameter in parm_names changes on this particular node instance.
            This is can be faster than filtering the parameter names in a
            callback installed with hou.Node.addEventCallback if you only care
            about some parameters or if the node has many parameters.


            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

            parm_names
                All list of parameter names.

            See hou.Node.addEventCallback for more information.


        """
        return _hou.Node_addParmCallback(self, callback, names)

    def removeEventCallback(
        self, event_types: "_EnumTuple", callback: "InterpreterObject"
    ) -> "void":
        r"""

        removeEventCallback(self, event_types, callback)

            Given a callback that was previously added on this node and a
            sequence of hou.nodeEventType enumerated values, remove those event
            types from the set of event types for the callback. If the remaining
            set of event types is empty, the callback will be removed entirely
            from this node.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.Node.addEventCallback for more information.


        """
        return _hou.Node_removeEventCallback(self, event_types, callback)

    def eventCallbacks(
        self,
    ) -> "std::vector< std::pair< std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >,InterpreterObject >,std::allocator< std::pair< std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >,InterpreterObject > > >":
        return _hou.Node_eventCallbacks(self)


# Register Node in _hou:
_hou.Node_swigregister(Node)


class NodeGroup(object):
    r"""

    hou.NodeGroup

    Represents a node group.

    In Houdini, a node group contains a set of nodes from the same network.
    Each group is named, and you can edit a group's contents from the
    network view pane by selecting Tools > Show Groups from its right-mouse
    menu.

    A node bundle, on the other hand, may contain nodes from multiple
    networks, and corresponds to a hou.NodeBundle object. You can edit a
    node bundle from the bundle list pane.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NodeGroup

    def __eq__(self, node_group: "HOM_PtrOrNull< HOM_NodeGroup >") -> "bool":
        return _hou.NodeGroup___eq__(self, node_group)

    def __ne__(self, node_group: "HOM_PtrOrNull< HOM_NodeGroup >") -> "bool":
        return _hou.NodeGroup___ne__(self, node_group)

    def __repr__(self) -> "std::string":
        return _hou.NodeGroup___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of this group.


        """
        return _hou.NodeGroup_name(self)

    def nodes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        nodes(self) -> tuple of hou.Node

            Return a tuple containing the nodes in this group.


        """
        return _hou.NodeGroup_nodes(self)

    def parent(self) -> "HOM_Node *":
        r"""

        parent(self) -> hou.Node

            Returns the network node containing this group.


        """
        return _hou.NodeGroup_parent(self)

    def addNode(self, node: "Node") -> "void":
        r"""

        addNode(self, node)

            Add a hou.Node to this group.

            If the node is already in the group, this method does nothing. If
            the node is not in the correct network for this group, raises
            hou.OperationFailed.


        """
        return _hou.NodeGroup_addNode(self, node)

    def removeNode(self, node: "Node") -> "void":
        r"""

        removeNode(self, node)

            Remove a hou.Node from this group.

            Raises hou.OperationFailed if the node is not in the group.


        """
        return _hou.NodeGroup_removeNode(self, node)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove all nodes from this group.


        """
        return _hou.NodeGroup_clear(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Delete this group. Does not delete the nodes that were contained in
            it.


        """
        return _hou.NodeGroup_destroy(self)

    def asCode(
        self,
        save_creation_commands: "bool" = True,
        save_node_memberships: "bool" = True,
        function_name: "char const *" = None,
    ) -> "std::string":
        r"""

        asCode(self, save_creation_commands=False, function_name=None) -> str

            Returns the Python code necessary to recreate this group.


            save_creation_commands
                Generate a creation script for the node group. If set to False
                (the default), the generated script assumes that the node group
                already exists. When set to True, the script will begin by
                creating the node group.

            function_name
                If a function_name is specified, the output will be wrapped in a
                Python function.


        """
        return _hou.NodeGroup_asCode(
            self, save_creation_commands, save_node_memberships, function_name
        )


# Register NodeGroup in _hou:
_hou.NodeGroup_swigregister(NodeGroup)


class ObjNode(Node):
    r"""

    hou.ObjNode

    An instance of an object node in the Houdini scene.

    Each object has a transformation (or transform) encapsulating its
    position (or translation), rotation, and scale. For a subnet object, the
    subnet's transform is applied to the objects inside the subnet. An
    object can have additional transforms from parent objects on top of the
    transform defined by its parameters, as well as a normally hidden
    pretransform that defines the object's rest or zero position (normally
    all zeros). An object's final position/rotation/scale in world space is
    defined by (object's transform) * (pretransform) * (parent transform).


    TIP
        You can set an object's position/rotation/scale to certain world
        space values regardless of parent/pre-transform values with the
        hou.ObjNode.setWorldTransform method.


    NOTE
        Houdini does not support shear parameters on objects. If you try to
        set an object's parameters to a transform containing shear, Houdini
        will automatically remove the shear.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ObjNode

    def __repr__(self) -> "std::string":
        return _hou.ObjNode___repr__(self)

    def origin(self) -> "HOM_Vector3 *":
        r"""

        origin(self) -> hou.Vector3

            Return the object's origin position, in world space.

            obj.origin() is equivalent to obj.Vector3(0, 0, 0) *
            obj.worldTransform().

          > # To compute the world space vector from obj1's origin to obj2's origin, you
          > # can write:
          > obj2.origin() - obj1.origin()
          >
          > # To compute the distance, in world space, between the origins of two
          > # objects, simply take the length of this vector:
          > (obj2.origin() - obj1.origin()).length()
          >
          > # If there are no rotations or scales, the vtorigin() hscript expression
          > # function will return the same result as obj2.origin() - obj1.origin().
          > # If there are rotations or scales, though, it won't.  A Python equivalent
          > # of vtorigin() is defined by:
          > def vtorigin(obj1, obj2):
          >     return (obj2.worldTransform() * obj1.worldTransform().inverted()).extractTranslates()

            See also the hou.ObjNode.worldTransform and
            hou.ObjNode.getTransformToNode methods.


        """
        return _hou.ObjNode_origin(self)

    def localTransform(self) -> "HOM_Matrix4 *":
        r"""

        localTransform(self) -> hou.Matrix4

            Return the matrix that transforms this object's geometry into space
            of its input.

            The local transform matrix contains the cumulative transforms of:

          * The node's pre-transform

          * The transform defined by the node's transform parameters

          * The transform adjustment by the node's lookat and path parameters

            The local transform matrix, independent of the node's pre-transform,
            can be obtained as follows:

          > def localTransformIgnorePreTransform(self):
          > return (self.localTransform() * self.preTransform().inverted())

            See also hou.ObjNode.localTransformAtTime and
            hou.ObjNode.worldTransform.


        """
        return _hou.ObjNode_localTransform(self)

    def localTransformAtTime(self, time: "double") -> "HOM_Matrix4 *":
        r"""

        localTransformAtTime(self, time) -> hou.Matrix4

            Return, for the specified time, the matrix that transforms this
            object's geometry into the space of its input.

            If the object's local transform is animated, this method provides a
            way to get the transformation at a specific time.

            See hou.ObjNode.localTransform for more information.


        """
        return _hou.ObjNode_localTransformAtTime(self, time)

    def worldTransform(self) -> "HOM_Matrix4 *":
        r"""

        worldTransform(self) -> hou.Matrix4

            Return the matrix that transforms this object's geometry into world
            space.

            The world transform matrix contains the cumulative transforms of:

          * The node's pre-transform

          * The transform defined by the node's parameters

          * The transforms of parent nodes or containing networks

            This method can approximately be implemented as follows:

          > def worldTransform(self):
          > return (self.localTransform() * self.parentAndSubnetTransform())

            See also hou.ObjNode.setWorldTransform and
            hou.ObjNode.worldTransformAtTime.


        """
        return _hou.ObjNode_worldTransform(self)

    def worldTransformAtTime(self, time: "double") -> "HOM_Matrix4 *":
        r"""

        worldTransformAtTime(self, time) -> hou.Matrix4

            Return, for the specified time, the matrix that transforms this
            object's geometry into world space.

            If the object's world transform is animated, this method provides a
            way to get the transformation at a specific time.

            See hou.ObjNode.worldTransform for more information.


        """
        return _hou.ObjNode_worldTransformAtTime(self, time)

    def setWorldTransform(
        self, matrix: "Matrix4", fail_on_locked_parms: "bool" = False
    ) -> "void":
        r"""

        setWorldTransform(self, matrix, fail_on_locked_parms=False)

            Adjust this object's parameters to achieve the desired world
            transformation.

            This method will adjust the translate, rotate, and scale values of
            this object to achieve the desired final world transform. It
            accounts for the transforms of containing networks, parent
            transforms, and pre-transforms.

            If fail_on_locked_parms is True, and any of the translate, rotate,
            or scale parameters of the object are locked, this method raises
            hou.OperationFailed. If it is False and any of those parameters are
            locked, this method will change their values but leave them locked.

            Suppose:

          * W is the desired new world transform,

          * W' is the existing world transform,

          * L is the desired transform defined by the node's parameters,

          * L' is the existing parm transform,

          * P is the object's pre-transform,

          * O is the parent transform combined with the containing subnet's,
            transform

            Then, since W = L * P * O we have P = W * O^ * R^. So, this method
            could be implemented as follows:

          > def setWorldTransform(self):
          > self.setParmTransform(
          >     matrix * self.parentAndSubnetTransform().inverted() * self.preTransform().inverted(),
          >     fail_on_locked_parms)

            Alternately, we can derive L from W' and L' as follows:

          * W' = L' * P * O

          * so P * O = L^' * W'

          * and (P * O)^ = W^' * L' and

          * W = L * P * O

          * so L = W * (P * O)^

          * giving L = W * W'^ * L'

            Thus, this method could also be implemented using the current world
            and parm transforms as follows:

          > def setWorldTransform(self):
          > self.setParmTransform(
          >     matrix * self.worldTransform().inverted() * self.parmTransform(),
          >     fail_on_locked_parms)

            Note that, because parm transforms cannot contain shears, it is
            possible that the resulting world transform will not match the
            desired transform. If r is a function that removes shears from a
            transform then the new world transform will actually be L * P * O =
            r(W * O^ * P^) * P * O.

            See also hou.ObjNode.worldTransform and
            hou.ObjNode.setParmTransform.


        """
        return _hou.ObjNode_setWorldTransform(self, matrix, fail_on_locked_parms)

    def setCookTransform(self, matrix: "Matrix4") -> "void":
        r"""

        setCookTransform(self, matrix)

            Set the parameter transform for the Python object that's cooking.
            Call this method from objects implemented in Python to set the
            result of the cook.

            Note that an object implemented in Python controls the parameter
            transform (i.e. the result of hou.ObjNode.parmTransform). The world
            transform (i.e. the result of hou.ObjNode.worldTransform) is still
            affected by parent node's transforms, pre-transforms, etc.

            This method raises hou.OperationFailed if you call it on an object
            that is not implemented in Python or if you call it from outside
            that object's Python cook code.

            See the Transforms from Disk example.


        """
        return _hou.ObjNode_setCookTransform(self, matrix)

    def parmTransform(self) -> "HOM_Matrix4 *":
        r"""

        parmTransform(self) -> hou.Matrix4

            Return the transform defined by the parameters on this node.

            This method can approximately be implemented as follows:

          > def parmTransform(self):
          > pivot_transform = hou.hmath.buildTransform({
          >     \"translate\":self.evalParmTuple(\"p\"),
          >     \"rotate\":self.evalParmTuple(\"pr\")},
          >     transform_order=\"srt\",
          >     rotate_order=\"xyz\")
          > return (
          >     pivot_transform.inverted() *
          >     hou.hmath.buildTransform({
          >         \"translate\": self.evalParmTuple(\"t\"),
          >         \"rotate\": self.evalParmTuple(\"r\"),
          >         \"scale\": [self.evalParm(\"scale\") * s
          >         for s in self.evalParmTuple(\"s\")],
          >         \"shear\": (0.0, 0.0, 0.0)},
          >     transform_order=self.parm(\"xOrd\").evalAsString(),
          >     rotate_order=self.parm(\"rOrd\").evalAsString()) *
          >     pivot_transform)

            See the class documentation for the relation between this transform
            and the world space transform. See also hou.ObjNode.worldTransform.

            NOTE: For Python Objects, the python code sets the parm transform as
            well and won't necessarily have any visible parameters. To get the
            local transform of an object (ie. the transform without any
            parenting), use hou.ObjNode.localTransform.


        """
        return _hou.ObjNode_parmTransform(self)

    def setParmTransform(
        self, matrix: "Matrix4", fail_on_locked_parms: "bool" = False
    ) -> "void":
        r"""

        setParmTransform(self, matrix, fail_on_locked_parms=False)

            Sets the transform controlled by this object's parameters.

            This method will adjust the translate, rotate, and scale values of
            this object to achieve the desired parameter, or local, transform.
            It will account for the existing pivot position, transformation
            order, and rotation order, and will leave them unchanged. It will
            also account for the existing orientation to set rotate values that
            produce a minimal rotation.

            Note that object nodes do not currently have shears parameters, so
            any shears in the matrix will be discarded.

            If fail_on_locked_parms is True, and any of the translate, rotate,
            or scale parameters of the object are locked, this method will raise
            hou.OperationFailed. If it is False and any of those parameters are
            locked, this method will change their values but leave them locked.

            See also hou.ObjNode.parmTransform and
            hou.ObjNode.setWorldTransform.

            This method can be approximately implemented as follows, ignoring
            locked parameters:

          > def setParmTransform(self, matrix):
          > parm_values = matrix.explode(
          >     transform_order=self.parm('xOrd').evalAsString(),
          >     rotate_order=self.parm('rOrd').evalAsString(),
          >     pivot=hou.Vector3(self.evalParmTuple('p')))
          >
          > for parm_name, key in ('t', 'translate'), ('r', 'rotate'), ('s', 'scale'):
          >     self.parmTuple(parm_name).set(parm_values[key])

            See also hou.Matrix4.explode.


        """
        return _hou.ObjNode_setParmTransform(self, matrix, fail_on_locked_parms)

    def parmPivotTransform(self) -> "HOM_Matrix4 *":
        r"""

        parmPivotTransform(self) -> hou.Matrix4

            Return the pivot transform defined by the parameters on this node.

            This method can approximately be implemented as follows:

          > def parmPivotTransform(self):
          > pivot_transform = hou.hmath.buildTranslate(self.evalParmTuple(\"p\"))
          > return (
          >     hou.hmath.buildTransform({
          >         \"translate\": self.evalParmTuple(\"p\"),
          >         \"rotate\": self.evalParmTuple(\"pr\")},
          >     transform_order=\"srt\",
          >     rotate_order=\"xyz\")

            See also hou.ObjNode.parmTransform.


        """
        return _hou.ObjNode_parmPivotTransform(self)

    def setParmPivotTransform(
        self, matrix: "Matrix4", fail_on_locked_parms: "bool" = False
    ) -> "void":
        r"""

        setParmPivotTransform(self, matrix, fail_on_locked_parms=False)

            Sets the pivot transform controlled by this object's parameters.

            This method will adjust the pivot translate and pivot rotate values
            of this object to achieve the desired transform. It will not
            compensate for any changes this causes to the world transform of
            this object.

            If fail_on_locked_parms is True, and any of the pivot translate or
            pivot rotate rotate parameters of the object are locked, this method
            will raise hou.OperationFailed. If it is False and any of those
            parameters are locked, this method will change their values but
            leave them locked.

            See also hou.ObjNode.parmPivotTransform and
            hou.ObjNode.setParmTransform.

            This method can be approximately implemented as follows, ignoring
            locked parameters:

          > def setParmPivotTransform(self, matrix):
          > parm_values = matrix.explode(
          >     transform_order=self.parm('xOrd').evalAsString(),
          >     rotate_order=self.parm('rOrd').evalAsString(),
          >     pivot=hou.Vector3())
          >
          > for parm_name, key in ('p', 'translate'), ('pr', 'rotate'):
          >     self.parmTuple(parm_name).set(parm_values[key])

            See also hou.Matrix4.explode.


        """
        return _hou.ObjNode_setParmPivotTransform(self, matrix, fail_on_locked_parms)

    def preTransform(self) -> "HOM_Matrix4 *":
        r"""

        preTransform(self) -> hou.Matrix4

            Return this object's pretransform.

            The pre-transform allows you to apply a transform after the
            parameter transform but before input and containing object
            transforms. See the class documentation for more details.

            Unlike the parameter transform, the pretransform is not stored using
            any parameters on the node. Instead, Houdini stores the pretransform
            as a matrix. Because it is directly as a matrix, the pretransform
            may contain shears.


        """
        return _hou.ObjNode_preTransform(self)

    def setPreTransform(self, matrix: "Matrix4") -> "void":
        r"""

        setPreTransform(self, matrix)

            Set this object's pretransform. See hou.ObjNode.preTransform for
            more information.


        """
        return _hou.ObjNode_setPreTransform(self, matrix)

    def movePreTransformIntoParmTransform(self) -> "void":
        r"""

        movePreTransformIntoParmTransform(self)

            Set this object's pre-transform to the identity and adjust the parm
            transform so that the world transform does not change.

            This method is implemented approximately as follows:

          > def movePreTransformIntoParmTransform(self):
          > self.setParmTransform(self.parmTransform() * self.preTransform())
          > self.setPreTransform(hou.hmath.identityTransform())

            See also hou.ObjNode.movePreTransformIntoParmTransform.


        """
        return _hou.ObjNode_movePreTransformIntoParmTransform(self)

    def moveParmTransformIntoPreTransform(self) -> "void":
        r"""

        moveParmTransformIntoPreTransform(self)

            Set this object's parm transform to the identity and adjust the pre-
            transform so that the world transform does not change.

            This method is implemented approximately as follows:

          > def moveParmTransformIntoPreTransform(self):
          > self.setPreTransform(self.parmTransform() * self.preTransform())
          > self.setParmTransform(hou.hmath.identityTransform())

            See also hou.ObjNode.moveParmRotateIntoPreTransform,
            hou.ObjNode.moveParmScaleIntoPreTransform, and
            hou.ObjNode.moveParmTranslateIntoPreTransform. Also see
            hou.ObjNode.movePreTransformIntoParmTransform.


        """
        return _hou.ObjNode_moveParmTransformIntoPreTransform(self)

    def moveParmTranslateIntoPreTransform(self) -> "void":
        r"""

        moveParmTranslateIntoPreTransform(self)

            Set this object's translate values to zero and adjust the pre-
            transform so that the world transform does not change.

            See hou.ObjNode.moveParmRotateIntoPreTransform for more information.


        """
        return _hou.ObjNode_moveParmTranslateIntoPreTransform(self)

    def moveParmRotateIntoPreTransform(self) -> "void":
        r"""

        moveParmRotateIntoPreTransform(self)

            Set this object's rotate values to zero and adjust the pre-transform
            so that the object's world transform does not change.

            Suppose:

          * W is the world transform,

          * L is the parameter transform without any rotate component,

          * L' is the existing parm transform,

          * P is the desired new pre-transform,

          * P' is the current pre-transform,

          * O is the parent transform combined with the containing subnet's,
            transform

            Then,

          * W = L * P * O and W = L' * P' * O

          * L * P = L' * P'

          * P = L^ * L' * P' So, this method is implemented approximately as
            follows:

          > def moveParmRotateIntoPreTransform(self):
          > old_parm_transform = self.parmTransform()
          > self.parmTuple(\"r\").set((0.0, 0.0, 0.0))
          > self.setPreTransform(
          >     self.parmTransform() * old_parm_transform * self.preTransform())
            See also hou.ObjNode.preTransform and the class documentation.


        """
        return _hou.ObjNode_moveParmRotateIntoPreTransform(self)

    def moveParmScaleIntoPreTransform(self) -> "void":
        r"""

        moveParmScaleIntoPreTransform(self)

            Set this object's scale values to one and adjust the pre-transform
            so that the world transform does not change.

            See hou.ObjNode.moveParmRotateIntoPreTransform for more information.


        """
        return _hou.ObjNode_moveParmScaleIntoPreTransform(self)

    def parentAndSubnetTransform(self) -> "HOM_Matrix4 *":
        r"""

        parentAndSubnetTransform(self) -> hou.Matrix4

            Return the input node's world space transform (if there is an input
            connected), combined with the world space transform of the
            containing subnet object (if there is one). See the class
            documentation for more information.

            This method can approximately be implemented as follows:

          > def parentAndSubnetTransform(self):
          > if len(self.inputConnectors()[0]) != 0:
          >     return self.inputs()[0].worldTransform()
          >
          > containing_subnet = self.parent()
          > if containing_subnet.type().category() == hou.objNodeTypeCategory():
          >     return containing_subnet.worldTransform()
          >
          > return hou.hmath.identityMatrix()

        """
        return _hou.ObjNode_parentAndSubnetTransform(self)

    def getTransformToNode(self, obj_node: "ObjNode") -> "HOM_Matrix4 *":
        r"""

        getTransformToNode(self, obj_node) -> hou.Matrix4

            Return a matrix that transforms this node to line up with the other
            node.

            The following invariant is true: node1.worldTransform() *
            node1.getTransformToNode(node2) == node2.worldTransform().

            This method can be implemented as follows:

          > def getTransformToNode(self, obj_node):
          > self.worldTransform().inverted() * obj_node.worldTransform()

            To align node1 (an ObjNode object) with node2 (another ObjNode
            object), you don't need to use getTransformToNode(). You can simply
            write: node1.setWorldTransform(node2.worldTransform()).

            See also hou.ObjNode.origin(), hou.ObjNode.worldTransform(), and
            hou.ObjNode.setWorldTransform().


        """
        return _hou.ObjNode_getTransformToNode(self, obj_node)

    def getTransformFromPointToPoint(
        self, pos3: "Vector3", other_node: "ObjNode", other_pos3: "Vector3"
    ) -> "HOM_Matrix4 *":
        r"""

        getTransformFromPointToPoint(self, pos3, other_node, other_pos3) ->
        hou.Matrix4

            Return the transform matrix that rotates the point pos3 (in this
            object node's transform space) to the point other_pos3 (in another
            object node's transform space).

          > obj1.getTransformFromPointToPoint(pos1, obj2, pos2)

            ...is equivalent to...

          > (obj1.worldTransform().inverted() *
          >     hou.hmath.buildTranslate(-pos1) *
          >     hou.hmath.buildTranslate(pos2) *
          >     obj2.worldTransform())

            See also the hou.ObjNode.getTransformToNode and
            hou.ObjNode.worldTransform methods, and the functions in the
            hou.hmath module.


        """
        return _hou.ObjNode_getTransformFromPointToPoint(
            self, pos3, other_node, other_pos3
        )

    def buildLookatRotation(
        self, to_node: "ObjNode", up_vector: "Vector3" = None
    ) -> "HOM_Matrix4 *":
        r"""

        buildLookatRotation(self, to_node, up_vector=None) -> hou.Matrix4

            Return a matrix that will rotate this object to look at the
            specified object.

            The returned hou.Matrix4 object transforms this object from its
            current position in world space so that its negative z axis points
            at the origin of the to_node object.

            up_vector can either be a hou.Vector3 object or None. If it is None,
            this method uses an up vector of hou.Vector3(0, 1, 0).

            You can extract the rotation values from the return value with
            hou.Matrix4.extractRotates. You can set an object's transform with
            hou.ObjNode.setWorldTransform.

          > # Set the cam1 object's transform so it points at geo1.
          > cam1 = hou.node(\"/obj/cam1\")
          > lookat_obj = hou.node(\"/obj/geo1\")
          > cam1.setWorldTransform(cam1.buildLookatRotation(lookat_obj))

            See also hou.ObjNode.setWorldTransform.


        """
        return _hou.ObjNode_buildLookatRotation(self, to_node, up_vector)

    def isObjectDisplayed(self) -> "bool":
        r"""

        isObjectDisplayed(self) -> bool

            Return whether or not this object is displayed. This method takes
            into account both the display flag and the display parameter. If the
            display parameter is enabled, because the tdisplay parameter is set,
            this parameter overrides the flag.

            See also hou.ObjNode.isDisplayFlagSet, which returns the current
            state of the flag.


        """
        return _hou.ObjNode_isObjectDisplayed(self)

    def isObjectDisplayedAtFrame(self, frame: "double") -> "bool":
        r"""

        isObjectDisplayedAtFrame(self, frame) -> bool

            Return whether or not this object is displayed at the given frame.
            This method takes into account both the display flag and the display
            parameter. If the display parameter is enabled, because the tdisplay
            parameter is set, this parameter overrides the flag.

            See also hou.ObjNode.isDisplayFlagSet, which returns the current
            state of the flag.


        """
        return _hou.ObjNode_isObjectDisplayedAtFrame(self, frame)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Return whether or not this object's display flag is turned on. Note
            that the display flag and the display parameter both determine
            whether the object is actually displayed.

            Use hou.ObjNode.isObjectDisplayed to determine if the object is
            actually displayed.


        """
        return _hou.ObjNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turn the object's display flag on or off. See also
            hou.ObjNode.isDisplayFlagSet.


        """
        return _hou.ObjNode_setDisplayFlag(self, on)

    def isSelectableInViewport(self) -> "bool":
        r"""

        isSelectableInViewport(self) -> bool

            Return whether or not the selectable flag is set. When it is not
            set, it is not possible to select this object or any of its geometry
            interactively in the viewport.


        """
        return _hou.ObjNode_isSelectableInViewport(self)

    def setSelectableInViewport(self, on: "bool") -> "void":
        r"""

        setSelectableInViewport(self, on)

            Set the object's selectable flag. See
            hou.ObjNode.isSelectableInViewport for more information.


        """
        return _hou.ObjNode_setSelectableInViewport(self, on)

    def isShowingOrigin(self) -> "bool":
        r"""

        isShowingOrigin(self) -> bool

            Return whether or not this object displays its local origin gnomon
            in the viewport.

            Note that you can change this setting by right-clicking on the node.


        """
        return _hou.ObjNode_isShowingOrigin(self)

    def showOrigin(self, on: "bool") -> "void":
        r"""

        showOrigin(self, on)

            Show or hide this object's local origin gnomon in the viewport. See
            also hou.ObjNode.isShowingOrigin.


        """
        return _hou.ObjNode_showOrigin(self, on)

    def isUsingXray(self) -> "bool":
        r"""

        isUsingXray(self) -> bool

            Return whether or not this object displays its geometry in xray
            mode. Houdini displays xrayed geometry in wireframe and makes it
            visible even when it is hidden behind another surface.

            Note that you can change this setting by right-clicking on the node.


        """
        return _hou.ObjNode_isUsingXray(self)

    def useXray(self, on: "bool") -> "void":
        r"""

        useXray(self, on)

            Turn this object's xray mode on or off. See also
            hou.ObjNode.isUsingXray.


        """
        return _hou.ObjNode_useXray(self, on)

    def displayNode(self) -> "HOM_Node *":
        r"""

        displayNode(self) -> hou.Node or None

            If this object contains SOPs or DOPs, return the one that has its
            display flag on. Otherwise, return None.


        """
        return _hou.ObjNode_displayNode(self)

    def renderNode(self) -> "HOM_Node *":
        r"""

        renderNode(self) -> hou.Node or None

            If this object contains SOPs or DOPs, return the one that has its
            render flag on. Otherwise, return None.


        """
        return _hou.ObjNode_renderNode(self)

    def combine(self, nodes: "_NodeTuple") -> "void":
        r"""

        combine(self, nodes)

            Combine the geometry from the given list of hou.ObjNode's into this
            object. After this operation, the old objects will be deleted.

            Raises hou.ObjectWasDeleted if any of the nodes no longer exist in
            Houdini. Raises TypeError if any of the nodes are not of type
            hou.ObjNode. These exceptions are raised prior to performing the
            combine operation to avoid partial results.


        """
        return _hou.ObjNode_combine(self, nodes)

    def material(self, *args, **kwargs) -> "void":
        r"""

        material(self, operation, parameter)

            Manages object-local overrides of material parameters. This is
            basically the scripting equivalent of the Material Override menu in
            the parameter editor for objects. It allows you to create parameters
            on an object that override the equivalent values on the object's
            material.

            The operation argument should be one of the following strings:


            \"override\"
                Create parameters on the object to override all material
                parameters.

            \"select\"
                Select and create object parameters to override material
                parameters.

            \"remove\"
                Removes all object parameter overrides.

            \"rmdefault\"
                Removes any unchanged object parameters (that is, that are
                currently set to their default value).

            \"sync\"
                Synchronize the object parameter overrides with the parameter
                definitions on the material.

            \"revert\"
                Revert any parameter overrides on the object to their values on
                the material.

            \"addlist\"
                (Followed by a second argument containing a list of parameter
                names strings.) Creates object parameters to override the named
                parameters on the material.

          >
          > myobject = hou.node(\"/obj/obj1\")
          >
          > # Add all material overrides
          > myobject.material(\"override\")
          >
          > # Remove all material overrides
          > myobject.material(\"remove\")
          >
          > # Add specific overrides for \"baseColor\" and \"roughness\" parameters
          > myobject.material(\"addlist\", [\"baseColor\", \"roughness\"])

        """
        return _hou.ObjNode_material(self, *args, **kwargs)

    def _parmClipData(
        self,
        start: "double",
        end: "double",
        binary: "bool" = True,
        use_blosc_compression: "bool" = True,
        sample_rate: "double" = 0,
        scoped_only: "bool" = False,
    ) -> "HOM_BinaryString":
        return _hou.ObjNode__parmClipData(
            self, start, end, binary, use_blosc_compression, sample_rate, scoped_only
        )

    def _saveParmClip(
        self,
        file_name: "std::string",
        start: "double",
        end: "double",
        sample_rate: "double" = 0,
        scoped_only: "bool" = False,
    ) -> "void":
        return _hou.ObjNode__saveParmClip(
            self, file_name, start, end, sample_rate, scoped_only
        )


# Register ObjNode in _hou:
_hou.ObjNode_swigregister(ObjNode)


class Prim(object):
    r"""

    hou.Prim

    Each Prim resides inside a Geometry object and stores some sort of 3D
    geometric primitive, like a polygon, a NURBS curve, or a volume. Each
    primitive usually contains a set of Vertex objects, each of which
    references a Point object.

    This class has a number of subclasses for the different primitive types,
    such as hou.Polygon and hou.Volume.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Prim

    def __eq__(self, prim: "HOM_PtrOrNull< HOM_Prim >") -> "bool":
        return _hou.Prim___eq__(self, prim)

    def __ne__(self, prim: "HOM_PtrOrNull< HOM_Prim >") -> "bool":
        return _hou.Prim___ne__(self, prim)

    def __hash__(self) -> "int":
        return _hou.Prim___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Prim___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Return the hou.Geometry object containing this primitive.


        """
        return _hou.Prim_geometry(self)

    def number(self) -> "int":
        r"""

        number(self) -> int

            Return the number of this primitive. Primitives are numbered
            sequentially starting from 0, and the primitives returned by
            hou.Geometry.prims are in order by their number.


        """
        return _hou.Prim_number(self)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.primType enum value

            Return a hou.primType value containing the type of this primitive
            (e.g. polygon, NURBS curve, metaball, etc).


        """
        return _hou.Prim_type(self)

    def attribType(self) -> "HOM_EnumValue &":
        r"""

        attribType(self) -> hou.attribType enum value

            Return the enumerated value hou.attribType.Prim. Points, primitives,
            vertices, and geometry support the same set of methods for querying
            their attributes, and this method is one of them.

            See also:

          * hou.Point.attribType

          * hou.Vertex.attribType

          * hou.Geometry.attribType

          * hou.attribType


        """
        return _hou.Prim_attribType(self)

    def vertices(self) -> "HOM_IterableList< HOM_Vertex > *":
        r"""

        vertices(self) -> generator of hou.Vertex

            Return a sequence of the vertices contained in this primitive.

            If the primitive is a face (e.g. a polygon or NURBS curve), the
            result corresponds to the order of the vertices in that face. If it
            is a surface (e.g. a NURBS mesh), however, the primitive has a 2D
            array of vertices, and this method returns all vertices in the 2D
            array, ordered by the rows.

            See hou.Surface.vertex for more information about the relationship
            between the 2D vertex array and the sequential vertex index, and for
            more ways to access the vertices in a surface.


        """
        return _hou.Prim_vertices(self)

    def numVertices(self) -> "int":
        r"""

        numVertices(self) -> int

            A shortcut for len(self.vertices()). You probably don't need to call
            this method.


        """
        return _hou.Prim_numVertices(self)

    def edges(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Edge >,std::allocator< HOM_ElemPtr< HOM_Edge > > >":
        return _hou.Prim_edges(self)

    def numEdges(self) -> "int":
        return _hou.Prim_numEdges(self)

    def floatAttribValue(self, *args) -> "double":
        r"""

        floatAttribValue(self, attrib) -> float

            Return the primitive attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not float of size 1.

            In most cases, you'll just use hou.Prim.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
        return _hou.Prim_floatAttribValue(self, *args)

    def floatListAttribValue(
        self, *args
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the primitive attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Prim.attribValue.


        """
        return _hou.Prim_floatListAttribValue(self, *args)

    def intAttribValue(self, *args) -> "int64":
        r"""

        intAttribValue(self, name_or_attrib) -> int

            Return the primitive attribute value for a particular integer
            attribute of size 1. The attribute may be specified by name or by
            hou.Attrib object. See hou.Point.floatAttribValue for more
            information.


        """
        return _hou.Prim_intAttribValue(self, *args)

    def intListAttribValue(
        self, *args
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the primitive attribute value for a particular integer
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of ints. See
            hou.Prim.floatListAttribValue for more information.


        """
        return _hou.Prim_intListAttribValue(self, *args)

    def stringAttribValue(self, *args) -> "std::string":
        r"""

        stringAttribValue(self, name_or_attrib) -> str

            Return the primitive attribute value for a particular string
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Prim.floatAttribValue for more information.


        """
        return _hou.Prim_stringAttribValue(self, *args)

    def stringListAttribValue(
        self, *args
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the primitive attribute value for a particular string
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of strings.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Prim.attribValue.


        """
        return _hou.Prim_stringListAttribValue(self, *args)

    def dictAttribValue(
        self, *args
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        dictAttribValue(self, name_or_attrib) -> dict

            Return the primitive attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Prim.floatAttribValue for more information.


        """
        return _hou.Prim_dictAttribValue(self, *args)

    def dictListAttribValue(
        self, *args
    ) -> "std::vector< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >,std::allocator< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > > >":
        r"""

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the primitive attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Prim.floatAttribValue for more information.


        """
        return _hou.Prim_dictListAttribValue(self, *args)

    def setAttribValue(self, *args) -> "void":
        r"""

        setAttribValue(self, name_or_attrib, attrib_value)

            Store an attribute value in this primitive. The attribute may be
            specified by name or by hou.Attrib object, and must be an existing
            primitive attribute in the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute's data type does not match the value passed in. If
            the attribute's size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute's size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # Create a float primitive attribute of size 3 named \"Cd\", and assign
          > # each primitive a unique color.  This code will work from inside a Python
          > # SOP, but not from the Python shell.
          > geo = hou.pwd().geometry()
          > color_attrib = geo.addAttrib(hou.attribType.Prim, \"Cd\", (1.0, 1.0, 1.0))
          > num_prims = len(geo.prims())
          > color = hou.Color()
          > for prim in geo.prims():
          >     fraction = float(prim.number()) / num_prims
          >     # Give each primitive a different hue, but full saturation and value.
          >     # Store the RGB value in the attribute.
          >     color.setHSV((fraction * 255, 1, 1))
          >     prim.setAttribValue(color_attrib, color.rgb())

        """
        return _hou.Prim_setAttribValue(self, *args)

    def intrinsicNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        intrinsicNames(self) -> tuple of str

            Returns a tuple of strings representing the intrinsic values
            available for this primitive. Different primitive types will have
            different intrinsic values available. You can then get or set the
            value using hou.Prim.intrinsicValue and/or
            hou.Prim.setIntrinsicValue.


        """
        return _hou.Prim_intrinsicNames(self)

    def intrinsicValue(self, intrinsic_name: "char const *") -> "hboost::any":
        r"""

        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple

            Gets the value of an intrinsic, often computed, value of the
            primitive, such as bounds, measuredarea, vertexcount, and so on.

            Most intrinsic values are computed, such as measuredarea, however a
            few are writeable with hou.Prim.setIntrinsicValue. For example,
            sphere primitives have a transform matrix as part of their
            definition.

            You can also view these values in the user interface using the
            geometry spreadsheet.

            Raises hou.OperationFailed if the given intrinsic name does not
            exist. You can get a list of the available intrinsic value names
            with hou.Prim.intrinsicNames. Different primitive types will have
            different intrinsic values available.

            Bounding box intrinsic values like bounds or packedbounds are
            returned in (xmin, xmax, ymin, ymax, zmin, zmax) order.


        """
        return _hou.Prim_intrinsicValue(self, intrinsic_name)

    def intrinsicSize(self, intrinsic_name: "char const *") -> "size_t":
        r"""

        intrinsicSize(self, intrinsic_name) -> int

            Returns the intrinsic value's tuple size.


        """
        return _hou.Prim_intrinsicSize(self, intrinsic_name)

    def intrinsicReadOnly(self, intrinsic_name: "char const *") -> "bool":
        r"""

        intrinsicReadOnly(self, intrinsic_name) -> bool

            Returns whether the intrinsic is read-only or can be modified with
            hou.Prim.setIntrinsicValue.


        """
        return _hou.Prim_intrinsicReadOnly(self, intrinsic_name)

    def setIntrinsicValue(self, *args) -> "void":
        r"""

        setIntrinsicValue(self, intrinsic_name, value)

            Some intrinsic values can be modified. For example, you change the
            internal size and rotation (transform) of a sphere primitive by
            passing a 9 float tuple representing the transform to
            hou.Prim.setIntrinsicValue. Raises hou.OperationFailed if the
            intrinsic is not writeable or does not accept the passed value, or
            if the given intrinsic name does not exist.


        """
        return _hou.Prim_setIntrinsicValue(self, *args)

    def attribValue(self, *args) -> "InterpreterObject":
        r"""

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return the value stored in this primitive for a particular
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Looking an attribute value using a hou.Attrib object is slightly
            faster than looking it up by name. When looking up attribute values
            inside a loop, look up the hou.Attrib object outside the loop, and
            pass it into this method.

            When looking up the attribute values of all primitives, it is faster
            to call hou.Geometry.primFloatAttribValues or
            hou.Geometry.primFloatAttribValuesAsString than to call this method
            for each primitive in the geometry.

            Raises hou.OperationFailed if no attribute exists with this name.


        """
        return _hou.Prim_attribValue(self, *args)

    def positionAtInterior(
        self, u: "double", v: "double", w: "double" = 0.0
    ) -> "HOM_Vector3 *":
        r"""

        positionAtInterior(self, u, v, w=0.0) -> hou.Vector3

            Given normalized (i.e. from 0 to 1) u, v, w values, return the
            interior position of the primitive at that parametric location.

            Use hou.Face.positionAt for querying positions along the perimeter.


        """
        return _hou.Prim_positionAtInterior(self, u, v, w)

    def _nearestPointOnPrimToPosition(
        self, uvw: "Vector3", position: "Vector3"
    ) -> "HOM_Point *":
        return _hou.Prim__nearestPointOnPrimToPosition(self, uvw, position)

    def attribValueAtInterior(self, *args) -> "InterpreterObject":
        r"""

        attribValueAtInterior(self, attrib_or_name, u, v, w=0.0) -> int, float,
        str or tuple

            Return an attribute value at the normalized u, v, w parametric
            position in the interior of the primitive.

            Raises hou.OperationFailed if the attribute is not a point or vertex
            attribute. If you want a primitive attribute value, it doesn't vary
            across the surface, so use hou.Prim.attribValue.

            Use hou.Face.attribValueAt for querying attributes along the
            perimeter.


        """
        return _hou.Prim_attribValueAtInterior(self, *args)

    def boundingBox(self) -> "HOM_BoundingBox":
        r"""

        boundingBox(self) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box that is sized and positioned
            to be large enough to hold this primitive.


        """
        return _hou.Prim_boundingBox(self)

    def nearestToPosition(
        self, position: "_DoubleTuple"
    ) -> "UT_Tuple< double,double,double >":
        r"""

        nearestToPosition(self, pos3)

            Given a sequence of three floats containing a position, find the
            location on this primitive that is closest to that position. Returns
            a tuple containing the u value on this primitive, the v value on
            this primitive, and the distance to this primitive.

            NOTE: The returned UVs are in real coordinates, use the
            primuvConvert to switch to unit coordinates to match VEX's xyzdist.


        """
        return _hou.Prim_nearestToPosition(self, position)

    def groups(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PrimGroup >,std::allocator< HOM_ElemPtr< HOM_PrimGroup > > >":
        r"""

        groups(self) -> tuple of hou.PrimGroup

            Return a tuple of the primitive groups that contain this primitive.


        """
        return _hou.Prim_groups(self)

    def primuvConvert(self, *args) -> "HOM_Vector2 *":
        r"""

        primuConvert(self, u, mode, tol)

            Given a 1D u coordinate, compute the location in a different
            coordinate system. The tol argument is optional. See the
            primuvconvert VEX function for the different valid modes.


        """
        return _hou.Prim_primuvConvert(self, *args)

    def primuConvert(self, *args) -> "double":
        return _hou.Prim_primuConvert(self, *args)

    def _attribInfo(
        self,
        name: "char const *",
        attr_data_type: "int &",
        attr_size: "int &",
        is_array_type: "bool &",
    ) -> "void":
        return _hou.Prim__attribInfo(
            self, name, attr_data_type, attr_size, is_array_type
        )


# Register Prim in _hou:
_hou.Prim_swigregister(Prim)


class Face(Prim):
    r"""

    hou.Face

    A Face is a kind of geometry primitive (Prim object) that contains a
    sequence of vertices (Vertex objects). How these vertices are used
    depends on the type of face; polygons, for example, use the vertices to
    define the edges of the polygon, while NURBS curves use them as control
    points.

    A hou.Surface, on the other hand, stores a two dimension grid of
    vertices, and might be a NURBS surface, Bezier surface, or quadrilateral
    mesh.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Face

    def __repr__(self) -> "std::string":
        return _hou.Face___repr__(self)

    def isClosed(self) -> "bool":
        r"""

        isClosed(self) -> bool

            Return whether the first and last vertex are connected.

            An open face forms a multi-segment line or curve, since the first
            and last vertices are not connected. A closed face forms a very thin
            surface.


        """
        return _hou.Face_isClosed(self)

    def closed(self) -> "bool":
        r"""

        closed(self) -> bool

            This method is deprecated in favor of hou.isClosed.


        """
        return _hou.Face_closed(self)

    def setIsClosed(self, on: "bool") -> "void":
        r"""

        setIsClosed(self, on)

            Set whether the face is open or closed. See hou.Face.isClosed for
            more information. You would typically call this method from the code
            of a Python-defined SOP.

            Note that this method will raise hou.OperationFailed on a Bezier
            curve. See hou.Geometry.createBezierCurve for more information.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Face_setIsClosed(self, on)

    def normal(self) -> "HOM_Vector3 *":
        r"""

        normal(self) -> hou.Vector3

            Return the vector that's perpendicular to the face.


        """
        return _hou.Face_normal(self)

    def positionAt(self, u: "double") -> "HOM_Vector3 *":
        r"""

        positionAt(self, u) -> hou.Vector3

            Given a normalized (i.e. from 0 to 1) u value, return the position
            of the curve at that parametric location.


        """
        return _hou.Face_positionAt(self, u)

    def attribValueAt(self, *args) -> "InterpreterObject":
        r"""

        attribValueAt(self, attrib_or_name, u, du=0) -> int, float, str or tuple

            Return an attribute value at a normalized u parametric position on
            the curve. If du is 0, returns the interpolated attribute value;
            otherwise, returns the derivative of the attribute value.

            Raises hou.OperationFailed if the attribute is not a point or vertex
            attribute. If you want a primitive attribute value, it doesn't vary
            across the surface, so use hou.Prim.attribValue.


        """
        return _hou.Face_attribValueAt(self, *args)

    def vertex(self, index: "int") -> "HOM_Vertex *":
        r"""

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
        return _hou.Face_vertex(self, index)

    def addVertex(self, point: "Point") -> "HOM_Vertex *":
        r"""

        addVertex(self, point) -> hou.Vertex

            Create a new vertex inside this face, adding it to the end of the
            vertex list. You would typically call this method from the code of a
            Python-defined SOP.

            point is a hou.Point object that the new vertex will refer to. See
            hou.Vertex for information on the relationship between points and
            vertices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # These arrays define point positions and a set of polygons composed
          > # of those points.  Note that the point positions could also be floating
          > # point values.
          > point_positions = ((0,0,0), (1,0,0), (1,1,0), (0,1,0))
          > poly_point_indices = ((0,1,2), (2,3,0))
          >
          > geo = hou.pwd().geometry()
          >
          > # Create all the points.
          > points = []
          > for position in point_positions:
          >     points.append(geo.createPoint())
          >     points[-1].setPosition(position)
          >
          > # Now create the polygons, adding vertices that refer to the points.
          > for point_indices in poly_point_indices:
          >     poly = geo.createPolygon()
          >     for point_index in point_indices:
          >         poly.addVertex(points[point_index])

            See also:

          * hou.Geometry.createPoint

          * hou.Geometry.createPolygon


        """
        return _hou.Face_addVertex(self, point)

    def arcLength(
        self, u_start: "double", u_stop: "double", divs: "int" = 10
    ) -> "double":
        r"""

        arcLength(self, u_start, u_stop, divs=10) ->float

            Given normalized (i.e. from 0 to 1) u_start and u_stop values,
            return the length of the arc of curve. divs represents the number of
            divisions per spans. Increasing it increases the precision of the
            computation.


        """
        return _hou.Face_arcLength(self, u_start, u_stop, divs)


# Register Face in _hou:
_hou.Face_swigregister(Face)


class PackedPrim(Prim):
    r"""

    hou.PackedPrim

    A packed primitive.

    See packed primitives for more information.

    To set contents of the packed primitive, use the
    hou.Prim.setIntrinsicValue method:

    > prim = myGeometry.createPacked(\"PackedDisk\")
    > prim.setIntrinsicValue(\"unexpandedfilename\", \"defgeo.bgeo\")

    To get the list of available intrinsic attributes you can set:

      * View a packed primitive of the type you want in the geometry
        spreadsheet and turn on display of intrinsic attributes.

        or

      * In a Houdini tools command line, type ginfo -IP to see a list of all
        intrinsic attributes on all packed primitive types.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PackedPrim

    def __repr__(self) -> "std::string":
        return _hou.PackedPrim___repr__(self)

    def transform(self) -> "HOM_Matrix3 *":
        r"""

        transform(self) -> hou.Matrix3

            Returns the local 3x3 transform associated with this primitive. The
            transform doesn't include the local point transform or any
            transforms inside the primitive (for example, transforms inside an
            Alembic file).


        """
        return _hou.PackedPrim_transform(self)

    def fullTransform(self) -> "HOM_Matrix4 *":
        r"""

        fullTransform(self) -> hou.Matrix4

            Returns the full 4x4 transform for this primitive's geometry. This
            includes translations due to points and any transforms inside the
            primitive (for example, transforms inside an Alembic file).


        """
        return _hou.PackedPrim_fullTransform(self)

    def setTransform(self, transform: "Matrix4") -> "void":
        r"""

        setTransform(self, m4)

            Sets this primitive's local transform. This sets the local 3x3
            transform and the translation of the point. This does not affect any
            transforms inside the primitive (for example, transforms inside an
            Alembic file).

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            m4
                A hou.Matrix4 object containing the full transform.


        """
        return _hou.PackedPrim_setTransform(self, transform)

    def vertex(self, index: "int") -> "HOM_Vertex *":
        r"""

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
        return _hou.PackedPrim_vertex(self, index)


# Register PackedPrim in _hou:
_hou.PackedPrim_swigregister(PackedPrim)


class BaseKeyframe(object):
    r"""

    hou.BaseKeyframe

    Abstract base class for all keyframe class.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_BaseKeyframe

    def __eq__(self, base_keyframe: "HOM_PtrOrNull< HOM_BaseKeyframe >") -> "bool":
        return _hou.BaseKeyframe___eq__(self, base_keyframe)

    def __ne__(self, base_keyframe: "HOM_PtrOrNull< HOM_BaseKeyframe >") -> "bool":
        return _hou.BaseKeyframe___ne__(self, base_keyframe)

    def __hash__(self) -> "int":
        return _hou.BaseKeyframe___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.BaseKeyframe___repr__(self)

    def evaluatedType(self) -> "HOM_EnumValue &":
        r"""

        evaluatedType(self) -> hou.parmData enum value

            Returns the type that the keyframe evaluates to.


        """
        return _hou.BaseKeyframe_evaluatedType(self)

    def setExpression(
        self, expression: "std::string const &", language: "EnumValue" = None
    ) -> "void":
        r"""

        setExpression(self, expression, language=None)

            Sets the keyframe's expression and language.

            This function raises TypeError if language is not a value from
            hou.exprLanguage.

            See expression(), expressionLanguage(), isExpressionSet(),
            isExpressionLanguageSet().


        """
        return _hou.BaseKeyframe_setExpression(self, expression, language)

    def expression(self) -> "std::string":
        r"""

        expression(self) -> str

            Returns the keyframe's expression. For example, in cases where the
            keyframe has had two values set the interpolating function is
            returned e.g. bezier(), spline() etc.

            This function raises hou.KeyframeValueNotSet if an expression has
            not been set.

            See setExpression() and isExpressionSet().


        """
        return _hou.BaseKeyframe_expression(self)

    def isExpressionSet(self) -> "bool":
        r"""

        isExpressionSet(self) -> bool

            Returns whether the keyframe's expression is set.

            See setExpression() and expression().


        """
        return _hou.BaseKeyframe_isExpressionSet(self)

    def expressionLanguage(self) -> "HOM_EnumValue &":
        r"""

        expressionLanguage(self) -> hou.exprLanguage enum value

            Returns the keyframe's expression's language.

            This function raises hou.KeyframeValueNotSet if an expression
            language has not ben set.

            See setExpression(), and isExpressionLanguageSet().


        """
        return _hou.BaseKeyframe_expressionLanguage(self)

    def isExpressionLanguageSet(self) -> "bool":
        r"""

        isExpressionLanguageSet(self) -> bool

            Returns whether the keyframe expression's language is set.

            See setExpression() and expressionLanguage().


        """
        return _hou.BaseKeyframe_isExpressionLanguageSet(self)

    def setTime(self, time: "double") -> "void":
        r"""

        setTime(self, time)

            Sets the keyframe's time in seconds. Using the number of frames per
            second (hou.fps), setting the time also sets the frame number. For
            example, with an fps of 24, then setting the time to 2 seconds will
            set the frame number to 49.

            See time().


        """
        return _hou.BaseKeyframe_setTime(self, time)

    def isTimeSet(self) -> "bool":
        r"""

        isTimeSet(self) -> bool

            Returns whether the keyframe's time is set.

            See setTime() and time().


        """
        return _hou.BaseKeyframe_isTimeSet(self)

    def time(self) -> "double":
        r"""

        time(self) -> double

            Returns the keyframe's time in seconds.

            This function raises hou.KeyframeValueNotSet if the time or frame
            has not been set.

            See setTime() and setFrame().


        """
        return _hou.BaseKeyframe_time(self)

    def setFrame(self, frame: "double") -> "void":
        r"""

        setFrame(self, frame)

            Sets the keyframe's frame number. Using the number of frames per
            second (hou.fps), setting the frame number also sets the time. For
            example, with an fps of 24, then setting the frame number to 49 will
            set the time to 2 seconds.

            See frame().


        """
        return _hou.BaseKeyframe_setFrame(self, frame)

    def frame(self) -> "double":
        r"""

        frame(self) -> double

            Returns the keyframe's frame number.

            This function raises hou.KeyframeValueNotSet if the frame or time
            has not been set.

            See setFrame() and setTime().


        """
        return _hou.BaseKeyframe_frame(self)

    def asCode(
        self,
        brief: "bool" = False,
        save_keys_in_frames: "bool" = False,
        function_name: "char const *" = None,
    ) -> "std::string":
        r"""

        asCode(self, brief=False, save_keys_in_frames=False, function_name=None)
        -> str

            Returns a script of Python statements that can be executed to create
            the keyframe. To run the script, use either Python's exec or
            execfile functions.


            brief
                When <brief> is True, the output script omits commands for
                setting unused values, slopes and accelerations. This parameter
                only applies to non-string keyframes. The value of <brief> must
                be either True or False.

            save_keys_in_frames
                When <save_keys_in_frames> is True, asCode outputs commands for
                setting channel and key times in samples (frames) instead of
                seconds. The value of <save_keys_in_frames> must be either True
                or False.

            function_name
                If <function_name> is specified, then the output script is
                wrapped in a Python function definition with the given name.
                <function_name> must be a non-zero length string consisting of
                only alphanumeric and underscore characters. Any invalid
                characters are internally converted to underscores.

                The function returns a reference to the newly created keyframe
                object.

            Here is an example of saving the output to a file and then loading
            it back into Houdini:

          > # Get a reference to the target keyframe.
          > tx_parm = hou.parm(\"/obj/geo1/tx\")
          > key = tx_parm.keyframes()[0]
          >
          > # Execute asCode and write the output script to file.
          > script = key.asCode()
          > f = open(\"create_key.py\", \"w\")
          > f.write(script)
          > f.close()
          >
          > # Execute the script.  The new keyframe will be stored
          > # in the 'hou_keyframe' variable.
          > execfile(\"create_key.py\")
          >
          > # Commit the keyframe back into the node parameter.
          > tx_parm.setKeyframe(hou_keyframe)

            Here is an example of saving the output into a function and then
            calling it in Houdini:

          > # Get a reference to the target keyframe.
          > tx_parm = hou.Node(\"/obj/geo1\").Parm(\"tx\")
          > key = tx_parm.keyframes()[0]
          >
          > # Execute asCode and write the function definition to file.
          > func = key.asCode(function_name=\"createKeyframe\")
          > f = open(\"keylib.py\", \"w\")
          > f.write(func)
          > f.close()
          >
          > # Call the function definition.
          > import keylib
          > hou_keyframe = keylib.createKeyframe()
          >
          > # Commit the keyframe back into the node parameter.
          > tx_parm.setKeyframe(hou_keyframe)

        """
        return _hou.BaseKeyframe_asCode(self, brief, save_keys_in_frames, function_name)


# Register BaseKeyframe in _hou:
_hou.BaseKeyframe_swigregister(BaseKeyframe)


class ChannelGraphSelection(object):
    r"""

    hou.ChannelGraphSelection

    A copy of an Animation Editor Graph Selection.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.ChannelGraphSelection

        A copy of an Animation Editor Graph Selection.


        """
        _hou.ChannelGraphSelection_swiginit(self, _hou.new_ChannelGraphSelection(*args))

    __swig_destroy__ = _hou.delete_ChannelGraphSelection

    def __repr__(self) -> "std::string":
        return _hou.ChannelGraphSelection___repr__(self)

    def __eq__(self, *args) -> "bool":
        return _hou.ChannelGraphSelection___eq__(self, *args)

    def __ne__(self, p: "HOM_PtrOrNull< HOM_ChannelGraphSelection >") -> "bool":
        return _hou.ChannelGraphSelection___ne__(self, p)

    def parm(self) -> "HOM_Parm *":
        r"""

        path(self) -> str

            Return the parameter path associated with the channel graph
            selection.


        """
        return _hou.ChannelGraphSelection_parm(self)

    def path(self) -> "std::string":
        return _hou.ChannelGraphSelection_path(self)

    def keyframes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >":
        r"""

        keyframes(self) -> tuple of hou.BaseKeyframe

            Return the keyframes on the parameter. The selection arrays match
            the order of the keyframes.


        """
        return _hou.ChannelGraphSelection_keyframes(self)

    def flags(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        setFlags(self) -> tuple of int

            Set the raw selection flags for all keyframes of the parameter.


        """
        return _hou.ChannelGraphSelection_flags(self)

    def setFlags(self, flags: "_IntTuple") -> "void":
        return _hou.ChannelGraphSelection_setFlags(self, flags)

    def values(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        values(self) -> tuple of int

            Return the value selection flags for all keyframes of the parameter.


        """
        return _hou.ChannelGraphSelection_values(self)

    def timeMarks(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        timeMarks(self) -> tuple of int

            Return the time mark selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_timeMarks(self)

    def slopes(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        slopes(self) -> tuple of int

            Return the slope selection flags for all keyframes of the parameter.


        """
        return _hou.ChannelGraphSelection_slopes(self)

    def accelerations(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        accelerations(self) -> tuple of int

            Return the acceleration selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_accelerations(self)

    def segments(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        segments(self) -> tuple of int

            Return the segment selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_segments(self)

    def inValues(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        inValues(self) -> tuple of int

            Return the incoming value selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_inValues(self)

    def inSlopes(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        inSlopes(self) -> tuple of int

            Return the incoming slope selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_inSlopes(self)

    def inAccelerations(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        inAccelerations(self) -> tuple of int

            Return the incoming acceleration selection flags for all keyframes
            of the parameter.


        """
        return _hou.ChannelGraphSelection_inAccelerations(self)

    def outValues(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        outValues(self) -> tuple of int

            Return the outgoing value selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_outValues(self)

    def outSlopes(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        outSlopes(self) -> tuple of int

            Return the outgoing slope selection flags for all keyframes of the
            parameter.


        """
        return _hou.ChannelGraphSelection_outSlopes(self)

    def outAccelerations(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        outAccelerations(self) -> tuple of int

            Return the outgoing acceleration selection flags for all keyframes
            of the parameter.


        """
        return _hou.ChannelGraphSelection_outAccelerations(self)

    def selectValues(
        self, sel: "_IntTuple", _in: "bool" = True, out: "bool" = True
    ) -> "void":
        r"""

        selectValues(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe value handles.


        """
        return _hou.ChannelGraphSelection_selectValues(self, sel, _in, out)

    def selectTimeMarks(self, sel: "_IntTuple") -> "void":
        r"""

        selectTimeMarks(self,selections)

            Select time mark handles.


        """
        return _hou.ChannelGraphSelection_selectTimeMarks(self, sel)

    def selectSlopes(
        self, sel: "_IntTuple", _in: "bool" = True, out: "bool" = True
    ) -> "void":
        r"""

        selectSlopes(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe slope handles.


        """
        return _hou.ChannelGraphSelection_selectSlopes(self, sel, _in, out)

    def selectAccelerations(
        self, sel: "_IntTuple", _in: "bool" = True, out: "bool" = True
    ) -> "void":
        r"""

        selectAccelerations(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe acceleration handles.


        """
        return _hou.ChannelGraphSelection_selectAccelerations(self, sel, _in, out)

    def selectSegments(self, sel: "_IntTuple") -> "void":
        r"""

        selectSegments(self,selections)

            Select segment handles.


        """
        return _hou.ChannelGraphSelection_selectSegments(self, sel)

    def deselectValues(
        self, sel: "_IntTuple", _in: "bool" = True, out: "bool" = True
    ) -> "void":
        r"""

        deselectValues(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe value handles.


        """
        return _hou.ChannelGraphSelection_deselectValues(self, sel, _in, out)

    def deselectTimeMarks(self, sel: "_IntTuple") -> "void":
        r"""

        deselectTimeMarks(self,selections)

            Select time mark handles.


        """
        return _hou.ChannelGraphSelection_deselectTimeMarks(self, sel)

    def deselectSlopes(
        self, sel: "_IntTuple", _in: "bool" = True, out: "bool" = True
    ) -> "void":
        r"""

        deselectSlopes(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe slope handles.


        """
        return _hou.ChannelGraphSelection_deselectSlopes(self, sel, _in, out)

    def deselectAccelerations(
        self, sel: "_IntTuple", _in: "bool" = True, out: "bool" = True
    ) -> "void":
        r"""

        deselectAccelerations(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe acceleration handles.


        """
        return _hou.ChannelGraphSelection_deselectAccelerations(self, sel, _in, out)

    def deselectSegments(self, sel: "_IntTuple") -> "void":
        r"""

        deselectSegments(self,selections)

            Select segment handles.


        """
        return _hou.ChannelGraphSelection_deselectSegments(self, sel)


# Register ChannelGraphSelection in _hou:
_hou.ChannelGraphSelection_swigregister(ChannelGraphSelection)


class NodeType(object):
    r"""

    hou.NodeType

    Information common to all instances of a type of node, such as the
    parameters.

    For example, the Geometry object and Subdivide SOP are node types.
    /obj/geo1 and /obj/geo2, on the other hand, are Node instances of the
    Geometry object node type.

    A digital asset defines a node type. The nodes contained inside the
    asset's definition implement the node type's algorithm, and you can
    customize the parameters in the node type using the Type Properties
    dialog,

    You can get a NodeType object from a Node object with hou.Node.type. For
    example, if /obj/geo1 is a geometry object, hou.node(\"/obj/geo1\").type()
    will return the NodeType corresponding to all geometry objects.

    All the node types in Houdini are organized into categories, and a node
    type is uniquely identified by its category and node type name. For
    example, objects, SOPs, POPs, etc. are node type categories. You can
    also access a NodeType object from a category with
    hou.NodeTypeCategory.nodeTypes. Similarly, you can call hou.nodeType_
    with the category and node type name.

    See also hou.Node and hou.NodeTypeCategory.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NodeType

    def __eq__(self, node_type: "HOM_PtrOrNull< HOM_NodeType >") -> "bool":
        return _hou.NodeType___eq__(self, node_type)

    def __ne__(self, node_type: "HOM_PtrOrNull< HOM_NodeType >") -> "bool":
        return _hou.NodeType___ne__(self, node_type)

    def __hash__(self) -> "int":
        return _hou.NodeType___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.NodeType___repr__(self)

    def category(self) -> "HOM_NodeTypeCategory &":
        r"""

        category(self) -> hou.NodeTypeCategory

            Return the node type category for this node type. For example, for
            the geometry object, the result is the object returned by
            hou.objNodeTypeCategory.


        """
        return _hou.NodeType_category(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this node type. For example, for the geometry
            object type, the name is geo. The name and the node type category
            together uniquely identify a node type.


        """
        return _hou.NodeType_name(self)

    def nameComponents(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        nameComponents(self) -> tuple of str

            Returns a tuple of node type name components that constitute the
            full node type name. The components in the tuple appear in the
            following order: scope network type, node type namespace, node type
            core name, and version.

          > # parse the full name into components
          > >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver::2.0')
          > >>> node_type.nameComponents()
          > ('', '', 'pyrosolver', '2.0')

        """
        return _hou.NodeType_nameComponents(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return the description of this node type that appears in the tab
            menu. For example, for the geometry object, the description is
            \"Geometry\". This description is also called the operator label in
            Houdini.


        """
        return _hou.NodeType_description(self)

    def nameWithCategory(self) -> "std::string":
        r"""

        nameWithCategory(self) -> str

            Return the name of the node type, prefixed with the name of the node
            type category. For example, for the geometry object, this function
            returns \"Object/geo\". The category name and type name together
            uniquely identify a node type.

          > >>> hou.nodeType(hou.objNodeTypeCategory(), \"geo\").nameWithCategory()
          > 'Object/geo'

        """
        return _hou.NodeType_nameWithCategory(self)

    def namespaceOrder(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        namespaceOrder(self) -> tuple of str

            Returns a node type name list sorted in the descending namespace
            precedence order. The node types in the list have the same base type
            as this node type. They have different namespace and/or version.

            Houdini uses this list when resolving an unqualified type name in
            hou.Node.createNode(); it will use the first entry in that list that
            matches the name specified in the function.

          > # parse the full name into components
          > >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver')
          > >>> node_type.namespaceOrder()
          > ('pyrosolver::2.0', 'pyrosolver')

        """
        return _hou.NodeType_namespaceOrder(self)

    def sectionData(self, name: "char const *") -> "std::string":
        r"""

        sectionData(self, section_name) -> str

            Return the data stored in the specified section of the HDA
            definition corresponding to this node type. If the HDA definition
            doesn't contain the specified section or this node type doesn't
            correspond to a digital asset, return an empty string.


        """
        return _hou.NodeType_sectionData(self, name)

    def binarySectionData(self, name: "char const *") -> "HOM_BinaryString":
        r"""

        binarySectionData(self, section_name) -> bytes

            Only available in Python 3.

            Return a bytes object containing the data stored in the specified
            section of the HDA definition corresponding to this node type. Ideal
            for sections containing binary data. If the HDA definition doesn't
            contain the specified section or this node type doesn't correspond
            to a digital asset, return an empty bytes object.


        """
        return _hou.NodeType_binarySectionData(self, name)

    def hasSectionData(self, name: "char const *") -> "bool":
        r"""

        hasSectionData(self, section_name) -> bool

            Return True if this node type corresponds to a digital asset whose
            definition contains the section. Otherwise, return False.


        """
        return _hou.NodeType_hasSectionData(self, name)

    def source(self) -> "HOM_EnumValue &":
        r"""

        source(self) -> hou.nodeTypeSource enum value

            Return a hou.nodeTypeSource enumerated value to indicate if this
            node type is implemented in VEX, RSL, or the HDK (in C++), or if it
            is a built-in node type that ships with Houdini.

          > >>> obj_cat = hou.objNodeTypeCategory()
          > >>> sop_cat = hou.sopNodeTypeCategory()
          > >>> hou.nodeType(obj_cat, \"biped_auto_rig\").source()
          > nodeTypeSource.Subnet
          > >>> hou.nodeType(sop_cat, \"mountain\").source()
          > nodeTypeSource.VexCode

        """
        return _hou.NodeType_source(self)

    def sourcePath(self) -> "std::string":
        r"""

        sourcePath(self) -> str

            Return the path to the source for this node type, or \"Internal\" if
            it is a built-in node type. If the node was created using the HDK,
            return the path to the shared object/dll for the node type.

          > >>> obj_cat = hou.objNodeTypeCategory()
          > >>> hou.nodeType(obj_cat, \"biped_auto_rig\").sourcePath()
          > 'oplib:/Object/biped_auto_rig?Object/biped_auto_rig'
          > >>> hou.nodeType(obj_cat, \"geo\").sourcePath()
          > 'Internal'

        """
        return _hou.NodeType_sourcePath(self)

    def sourceNetwork(self) -> "HOM_Node *":
        r"""

        sourceNetwork(self) -> hou.Node or None

            If this node type is a digital asset, return the Node instance whose
            contents define the digital asset. Otherwise, return None.


        """
        return _hou.NodeType_sourceNetwork(self)

    def definition(self) -> "HOM_HDADefinition *":
        r"""

        definition(self) -> hou.HDADefinition

            If this node type corresponds to a digital asset, return the
            hou.HDADefinition. Otherwise, return None.


        """
        return _hou.NodeType_definition(self)

    def allInstalledDefinitions(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_HDADefinition >,std::allocator< HOM_ElemPtr< HOM_HDADefinition > > >":
        r"""

        allInstalledDefinitions(self) -> tuple of hou.HDADefinition

            Search all installed operator type libraries and return a tuple of
            available hou.HDADefinition objects providing definitions for this
            node type.

            Houdini allows multiple otl files to be loaded at the same time that
            each contain definitions for the same node type. The definition in
            use is called the current definition. See also
            hou.HDADefinition.isCurrent.


        """
        return _hou.NodeType_allInstalledDefinitions(self)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> str

            Return the name or path of the icon for this node type. Note that
            node types that ship with Houdini use a name instead of a full path,
            and Houdini uses its search path to locate the icon with that name.


        """
        return _hou.NodeType_icon(self)

    def minNumInputs(self) -> "int":
        r"""

        minNumInputs(self) -> int

            Return the minimum number of inputs that nodes of this type can
            have. If these inputs are not connected, the node will generate an
            error.


        """
        return _hou.NodeType_minNumInputs(self)

    def maxNumInputs(self) -> "int":
        r"""

        maxNumInputs(self) -> int

            Return the maximum number of inputs that nodes of this type can
            have. Return 9999 if this node type can accept an unlimited number
            of inputs (e.g. the merge SOP).


        """
        return _hou.NodeType_maxNumInputs(self)

    def maxNumOutputs(self) -> "int":
        r"""

        maxNumOutputs(self) -> int

            Return the maximum number of outputs that nodes of this type can
            have. Most node types have only one output, but some, like the split
            dop, can have multiple.


        """
        return _hou.NodeType_maxNumOutputs(self)

    def isGenerator(self) -> "bool":
        r"""

        isGenerator(self) -> bool

            Return if this node type has been flagged as a generator. For
            example, a grid SOP generates new geometry, while a subdivide SOP
            does not, and instead processes the geometry passed into it. See
            also hou.NodeType.minNumInputs.


        """
        return _hou.NodeType_isGenerator(self)

    def generatorFlag(self) -> "bool":
        return _hou.NodeType_generatorFlag(self)

    def isManager(self, include_management_types: "bool" = True) -> "bool":
        r"""

        isManager(self, include_management_types=True) -> bool

            Return whether this NodeType is a manager. The manager node
            instances are /obj, /out, /part, /ch, /shop, /img, and /vex.

            If include_management_types is set to True then this method will
            additionally return True if this node type is a management node type
            such as a SHOP network, or VOP network, etc.


        """
        return _hou.NodeType_isManager(self, include_management_types)

    def managerFlag(self) -> "bool":
        return _hou.NodeType_managerFlag(self)

    def hasUnorderedInputs(self) -> "bool":
        r"""

        hasUnorderedInputs(self) -> bool

            Return whether it is impossible for this node type to have gaps in
            its connected inputs. For example, the cookie SOP has two inputs,
            and it's possible for only the second input to be connected, so this
            method would return False. However, the merge SOP cannot have any
            gaps in its inputs, so this method would return True.

            See also hou.Node.inputs, hou.Node.inputConnections, and
            hou.Node.inputConnectors.


        """
        return _hou.NodeType_hasUnorderedInputs(self)

    def unorderedInputsFlag(self) -> "bool":
        return _hou.NodeType_unorderedInputsFlag(self)

    def hasEditableInputData(self) -> "bool":
        r"""

        hasEditableInputData(self) -> bool

            Return True if nodes of this node type allow the user to associate
            data with each input to the node. The purpose of this data may vary
            from one node type to another. This data can be accessed with
            methods such as hou.Node.editableInputName and
            hou.Node.setEditableInputName.


        """
        return _hou.NodeType_hasEditableInputData(self)

    def aliases(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        aliases(self) -> tuple of str

            Return all current aliases for this node type. See
            hou.NodeType.addAlias for an example.


        """
        return _hou.NodeType_aliases(self)

    def addAlias(self, alias: "char const *") -> "void":
        r"""

        addAlias(self, alias)

            Add an alias for this node type. You can use this alias when
            creating new nodes.

          > >>> geo_type = hou.nodeType(hou.objNodeTypeCategory(), \"geo\")
          > >>> geo_type.addAlias(\"transformable\")
          > >>> geo_type.aliases()
          > ('transformable',)
          > >>> hou.node(\"/obj\").createNode(\"transformable\")
          > <hou.ObjNode of type geo at /obj/geo1>

        """
        return _hou.NodeType_addAlias(self, alias)

    def removeAlias(self, alias: "char const *") -> "void":
        r"""

        removeAlias(self, alias)

            Remove an alias for this node type.


        """
        return _hou.NodeType_removeAlias(self, alias)

    def hidden(self) -> "bool":
        r"""

        hidden(self) -> bool

            Return whether or not this node type appears in the tab menu. See
            also hou.NodeType.setHidden.


        """
        return _hou.NodeType_hidden(self)

    def setHidden(self, hidden: "bool") -> "void":
        r"""

        setHidden(self, hidden)

            Set whether or not this node type appears in the tab menu. See also
            hou.NodeType.hidden.


        """
        return _hou.NodeType_setHidden(self, hidden)

    def deprecated(self) -> "bool":
        r"""

        deprecated(self) -> bool

            Return whether or not this node type has been marked deprecated. See
            also hou.NodeType.deprecationInfo.


        """
        return _hou.NodeType_deprecated(self)

    def deprecationInfo(
        self,
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        deprecationInfo(self) -> dict of str to str or hou.NodeType

            If the node type has been marked deprecated, this call will return
            the deprecation information as a dictionary.

            The currently supported keys are:


            'version'
                The version of Houdini where this operator got deprecated. The
                form is either major.minor, or major.minor.build (e.g. 14.0 or
                14.5.122). This item is always present.

            'new_type'
                The new node type this node was replaced with. This can be used
                to create a system of automatic node replacement.

            'reason'
                This lists the reason given for the deprecation, in case there
                is no new node to replace with.


        """
        return _hou.NodeType_deprecationInfo(self)

    def instances(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        instances(self) -> tuple of hou.Node

            Return a tuple of all the nodes of this type in the current scene.


        """
        return _hou.NodeType_instances(self)

    def parmTemplates(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTemplate >,std::allocator< HOM_ElemPtr< HOM_ParmTemplate > > >":
        r"""

        parmTemplates(self) -> tuple of hou.ParmTemplate

            Return a tuple of parm templates for the parameters on this node
            type. Note that spare parameters on individual node instances are
            not included in this tuple, since they are independent from the node
            type.


        """
        return _hou.NodeType_parmTemplates(self)

    def parmTemplateGroup(self) -> "HOM_ParmTemplateGroup *":
        r"""

        parmTemplateGroup(self) -> hou.ParmTemplateGroup

            Return the group of parm templates corresponding to this node type's
            parameter interface.

            See hou.ParmTemplateGroup for more information on parm template
            groups. To change the parameter interface for a node type defined by
            a digital asset, see hou.HDADefinition.setParmTemplateGroup.


        """
        return _hou.NodeType_parmTemplateGroup(self)

    def uninstallFromPath(self, path: "char const *") -> "void":
        return _hou.NodeType_uninstallFromPath(self, path)

    def hdaModule(self) -> "HOM_HDAModule *":
        r"""

        hdaModule(self) -> hou.HDAModule

            Return the HDAModule object for this node type. If the type is not
            for a digital asset, the module is empty. Otherwise, the module
            contains the functions, constants, classes, etc. in the user-defined
            PythonModule section of the digital asset.

            You can use hou.Node.hdaModule as a shortcut to access the HDAModule
            from a node instance.

            See hou.HDAModule for more information.


        """
        return _hou.NodeType_hdaModule(self)

    def hdaViewerStateModule(self) -> "HOM_HDAViewerStateModule *":
        return _hou.NodeType_hdaViewerStateModule(self)

    def hdaViewerHandleModule(self) -> "HOM_HDAViewerHandleModule *":
        return _hou.NodeType_hdaViewerHandleModule(self)

    def hasPermanentUserDefaults(self) -> "bool":
        r"""

        hasPermanentUserDefaults(self) -> bool

            Returns whether a user has set permanent defaults for this node
            type.

            See also hou.Parm.hasTemporaryDefaults


        """
        return _hou.NodeType_hasPermanentUserDefaults(self)

    def isReadable(self) -> "bool":
        r"""

        isReadable(self) -> bool

            Return True if this node type is readable and False otherwise. A
            readable node type is one that you can create node instances from.


        """
        return _hou.NodeType_isReadable(self)

    def isWritable(self) -> "bool":
        r"""

        areContentsViewable(self) -> bool

            Return True if the node network contained in the node type is
            viewable and False otherwise.


        """
        return _hou.NodeType_isWritable(self)

    def areContentsViewable(self) -> "bool":
        return _hou.NodeType_areContentsViewable(self)

    def containedNodeTypes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        containedNodeTypes(self) -> tuple of str

            Return a tuple of all NodeType names of the contents of an HDA.


        """
        return _hou.NodeType_containedNodeTypes(self)

    def childTypeCategory(self) -> "HOM_NodeTypeCategory *":
        return _hou.NodeType_childTypeCategory(self)

    def helpUrl(self) -> "std::string":
        r"""

        helpUrl(self) -> str

            Return the URL where the node type stores the documentation, e.g., a
            file name or an HDA section path. May return an empty string if node
            type does not know where the documentation is.


        """
        return _hou.NodeType_helpUrl(self)

    def defaultHelpUrl(self) -> "std::string":
        r"""

        defaultHelpUrl(self) -> str

            Return a generic URL that the help system will try to resolve to the
            actual location that stores the node type documentation. The generic
            URL is in the form operator:table/optypename and may include
            additional information such as a namespace or a version.


        """
        return _hou.NodeType_defaultHelpUrl(self)

    def embeddedHelp(self) -> "std::string":
        r"""

        embeddedHelp(self) -> str

            Return the help text embedded in this node type. Return an empty
            string if no embedded help exists.

            The embedded help is searched for in two different places in the
            following order:

          * If an HDK node, the text given by its OP_Operator::getHDKHelp()
            override

          * If an HDA node, the corresponding result of
            hou.HDADefinition.embeddedHelp()


        """
        return _hou.NodeType_embeddedHelp(self)

    def defaultShape(self) -> "std::string":
        r"""

        defaultShape(self) -> str

            Return the name of the shape used to display a node of this type in
            the network view if no shape is explicitly assigned to the node.


        """
        return _hou.NodeType_defaultShape(self)

    def setDefaultShape(self, shape: "char const *") -> "void":
        r"""

        setDefaultShape(self, shape)

            Set the name of the shape used to display a node of this type in the
            network view if no shape is explicitly assigned to the node. Pass
            None as the shape parameter to remove the type-specific default.


        """
        return _hou.NodeType_setDefaultShape(self, shape)

    def defaultColor(self) -> "HOM_Color":
        r"""

        defaultColor(self) -> hou.Color

            Return the color used to display a node of this type in the network
            view if the node's hou.nodeFlag.ColorDefault flag is set.


        """
        return _hou.NodeType_defaultColor(self)

    def setDefaultColor(self, color: "Color") -> "void":
        r"""

        setDefaultColor(self, color)

            Set the color used to display a node of this type in the network
            view if the node's hou.nodeFlag.ColorDefault flag is set. Pass None
            as the color parameter to remove the type-specific default.


        """
        return _hou.NodeType_setDefaultColor(self, color)

    def _asVoidPointer(self) -> "void *":
        return _hou.NodeType__asVoidPointer(self)


# Register NodeType in _hou:
_hou.NodeType_swigregister(NodeType)


class ParmTemplate(object):
    r"""

    hou.ParmTemplate

    Describes a parameter tuple (its name, type, etc.). This is base class
    for all parameter templates.

    ParmTemplates are most often used when describing a parameter in a
    digital asset definition's parameter interface or when describing an
    individual node's parameter layout (including its spare parameters). A
    ParmTemplate describes a parameter and the type of data it holds, but it
    does not store the current value of a parameter; only hou.Parm objects
    inside hou.ParmTuple objects actually store parameter values. You can
    think of a hou.ParmTuple as an instance of a ParmTemplate. For example,
    the \"t\" parm tuple on geometry objects can be described by a
    hou.FloatParmTemplate -- it has a label of \"Transform\", a data type of
    hou.parmData.Float, 3 components, a naming scheme of
    hou.parmNamingScheme.XYZW, etc. Each geometry object node has a
    hou.ParmTuple named \"t\" that uses this ParmTemplate.

    Note that ParmTemplate objects are just data containers, and they have
    no live relationship with objects in Houdini. For example, a hou.Node
    object corresponds directly to a node in Houdini, and if the node is
    renamed in Houdini hou.Node.name will return the new name.
    ParmTemplates, on the other hand, do not have a live relationship.
    Creating a ParmTemplate based on a spare parameter or asset definition
    parameter will simply copy the information into the ParmTemplate object,
    and modifying the object will not affect the spare parameter/asset
    parameter.

    Note also that ParmTemplate objects are always instances of a subclass
    of this class, so you cannot construct an instance of this class
    directly.

    To manipulate the parameters of a digital asset, you can retrieve the
    asset's current set of ParmTemplates into a hou.ParmTemplateGroup using
    hou.HDADefinition.parmTemplateGroup. You can then modify the group,
    adding parameters to it and replacing parameters in it, and save the
    group back to the asset definition with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can change a
    node's parameter layout with hou.Node.parmTemplateGroup and
    hou.Node.setParmTemplateGroup.

    You can also ask a hou.ParmTuple for its ParmTemplate in order to find
    out information about the parameter, such as allowed ranges of values,
    the label displayed to the user in the parameter pane, the parameter's
    popup help, etc.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ParmTemplate

    def __eq__(self, parm_template: "HOM_PtrOrNull< HOM_ParmTemplate >") -> "bool":
        return _hou.ParmTemplate___eq__(self, parm_template)

    def __ne__(self, parm_template: "HOM_PtrOrNull< HOM_ParmTemplate >") -> "bool":
        return _hou.ParmTemplate___ne__(self, parm_template)

    def __hash__(self) -> "int":
        return _hou.ParmTemplate___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.ParmTemplate___repr__(self)

    def clone(self) -> "HOM_ParmTemplate *":
        r"""

        clone(self) -> hou.ParmTemplate

            Return a copy of this parm template.

            This method can be called on an instance of a ParmTemplate subclass
            and an instance of the subclass is properly returned.


        """
        return _hou.ParmTemplate_clone(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> string

            Return the internal name of the parm template. This is the name that
            hou.ParmTuple objects created from this parm template will have.

            Tha names of hou.ParmTemplate objects inside a multiparm block will
            have a # at the end of their name which will be replaced by the
            multiparm instance number when an the hou.ParmTuple object is
            instantiated.

            Note that the names of hou.Parm objects inside ParmTuples based off
            this ParmTemplate are determined by this name, the number of
            components in this parm template, and the naming scheme. See the
            namingScheme method for more information.


        """
        return _hou.ParmTemplate_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Change the internal name of this parm template. Remember that
            ParmTemplates just store data, so the name change will not have any
            effect unless this parm template is later used to modify a parameter
            layout in Houdini.

            Parameters inside a multiparm block must have a # at the end of
            their name which will be replaced by the multiparm's instance
            number.


        """
        return _hou.ParmTemplate_setName(self, name)

    def label(self) -> "std::string":
        r"""

        label(self) -> string

            Return the name of the parameter tuple that is displayed in the
            parameter pane.


        """
        return _hou.ParmTemplate_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self, label)

            Change the name of the label that is displayed in the parameter
            pane.


        """
        return _hou.ParmTemplate_setLabel(self, label)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.parmTemplateType enum value

            Return the enumerated value identifying the type of this parameter.

            Remember that ParmTemplate objects are always instances of a
            subclass of this class. The following table shows the mapping
            between hou.parmTemplateType enumeration values and ParmTemplate
            subclasses:


            Enumerated Value
                ParmTemplate Subclass

            hou.parmTemplateType.Int
                hou.IntParmTemplate

            hou.parmTemplateType.Float
                hou.FloatParmTemplate

            hou.parmTemplateType.String
                hou.StringParmTemplate

            hou.parmTemplateType.Toggle
                hou.ToggleParmTemplate

            hou.parmTemplateType.Menu
                hou.MenuParmTemplate

            hou.parmTemplateType.Button
                hou.ButtonParmTemplate

            hou.parmTemplateType.FolderSet
                hou.FolderSetParmTemplate

            hou.parmTemplateType.Folder
                hou.FolderParmTemplate

            hou.parmTemplateType.Separator
                hou.SeparatorParmTemplate

            hou.parmTemplateType.Label
                hou.LabelParmTemplate

            hou.parmTemplateType.Ramp
                hou.RampParmTemplate


        """
        return _hou.ParmTemplate_type(self)

    def dataType(self) -> "HOM_EnumValue &":
        r"""

        dataType(self) -> hou.parmData enum value

            Return the data type stored in hou.Parm instances inside
            hou.ParmTuple instances corresponding to this ParmTemplate.

            For example, suppose this parm tuple is a hou.FloatParmTemplate with
            3 components. The corresponding hou.ParmTuple will have 3 hou.Parm
            objects inside it, and each will store a floating point value. In
            this example, this method would return hou.parmData.Float.


        """
        return _hou.ParmTemplate_dataType(self)

    def look(self) -> "HOM_EnumValue &":
        r"""

        look(self) -> hou.parmLook enum value

            Return the look of this parameter in the parameter pane. For
            example, a tuple of 3 floats can be displayed as a 3D vector or as
            an RGB color.

            See hou.parmLook for more information.


        """
        return _hou.ParmTemplate_look(self)

    def setLook(self, look: "EnumValue") -> "void":
        r"""

        setLook(self, look)

            Set the look of this parameter to a hou.parmLook enum value.

            See the look method for more information.


        """
        return _hou.ParmTemplate_setLook(self, look)

    def namingScheme(self) -> "HOM_EnumValue &":
        r"""

        namingScheme(self) -> hou.parmNamingScheme enum value

            Return the naming scheme used to name parameters inside the parm
            tuple for this ParmTemplate.

            For example, if the naming scheme is hou.parmNamingScheme.XYZW and
            the parm template is named \"foo\" and has 3 components, the
            parameters will be named \"foox\", \"fooy\", and \"fooz\". On the other
            hand, if the naming scheme was hou.parmNamingScheme.Base1, the
            parameters would be named \"foo1\", \"foo2\", and \"foo3\".

            Note that when the parm template only has 1 component, the parm name
            is the same as the parm tuple name.

            See hou.parmNamingScheme for more information.


        """
        return _hou.ParmTemplate_namingScheme(self)

    def setNamingScheme(self, naming_scheme: "EnumValue") -> "void":
        r"""

        setNamingScheme(self, naming_scheme)

            Set the naming scheme used to name parameters inside the parm tuple
            for this ParmTemplate to a hou.parmNamingScheme enum value.

            See the namingScheme method for more information.


        """
        return _hou.ParmTemplate_setNamingScheme(self, naming_scheme)

    def numComponents(self) -> "int":
        r"""

        numComponents(self) -> int

            Return the number of values stored inside hou.ParmTuple instances of
            this ParmTemplate.

            For example, if this parm template has 3 components, there will be 3
            parameter fields displayed in the parameter pane and there will be 3
            hou.Parm objects inside a hou.ParmTuple based off this parm
            template.


        """
        return _hou.ParmTemplate_numComponents(self)

    def setNumComponents(self, num_components: "int") -> "void":
        r"""

        setNumComponents(self, num_components) -> int

            Set the number of values stored inside hou.ParmTuple instances of
            this ParmTemplate.

            Note that some ParmTemplate subclasses only support one component,
            so calling this method with a value other than 1 may raise a
            hou.OperationFailed exception. Also, changing the number of
            components may automatically change the size of the tuple of default
            values for some ParmTemplate subclasses.


        """
        return _hou.ParmTemplate_setNumComponents(self, num_components)

    def disableWhen(self) -> "std::string":
        r"""

        disableWhen(self) -> str

            This method is deprecated in favor of the conditionals method.


        """
        return _hou.ParmTemplate_disableWhen(self)

    def setDisableWhen(self, disable_when: "char const *") -> "void":
        r"""

        setDisableWhen(self, disable_when)

            This method is deprecated in favor of the setConditional method.


        """
        return _hou.ParmTemplate_setDisableWhen(self, disable_when)

    def conditionals(
        self,
    ) -> "std::map< HOM_EnumValue *,std::string,std::less< HOM_EnumValue * >,std::allocator< std::pair< HOM_EnumValue *const,std::string > > >":
        r"""

        conditionals(self) -> dict of hou.parmCondType enum value to str

            Returns the set of conditionals currently affecting this parameter.

            See the Conditionals section of the Operator Type Properties window
            help for more information on this string.


        """
        return _hou.ParmTemplate_conditionals(self)

    def setConditional(
        self, cond_type: "EnumValue", conditional: "char const *"
    ) -> "void":
        r"""

        setConditional(self, type, conditional)

            Set a conditional string of the given hou.parmCondType type for this
            parameter. This string consists of rules on how this parameter's
            display behaves when other parameters change.

            See the Conditionals section of the Operator Type Properties window
            help for more information on this string.


        """
        return _hou.ParmTemplate_setConditional(self, cond_type, conditional)

    def isHidden(self) -> "bool":
        r"""

        isHidden(self) -> bool

            Return whether this parameter is hidden in the parameter pane.


        """
        return _hou.ParmTemplate_isHidden(self)

    def hide(self, on: "bool") -> "void":
        r"""

        hide(self, on)

            Marks this parameter as visible or invisible in the parameter pane.

            Note that hidden parameters still exist, and can be evaluated,
            channel-referenced, etc. They simply will not be displayed in the
            parameter pane.


        """
        return _hou.ParmTemplate_hide(self, on)

    def isLabelHidden(self) -> "bool":
        r"""

        isLabelHidden(self) -> bool

            Return whether the label for this parameter is hidden in the
            parameter pane.


        """
        return _hou.ParmTemplate_isLabelHidden(self)

    def hideLabel(self, on: "bool") -> "void":
        r"""

        hideLabel(self, on)

            Hide or show the label for this parameter in the parameter pane.


        """
        return _hou.ParmTemplate_hideLabel(self, on)

    def joinsWithNext(self) -> "bool":
        r"""

        joinsWithNext(self) -> bool

            Return whether this parameter is displayed on the same line as the
            next parameter in the parameter pane.


        """
        return _hou.ParmTemplate_joinsWithNext(self)

    def setJoinWithNext(self, on: "bool") -> "void":
        r"""

        setJoinWithNext(self, on)

            Sets whether this parameter is displayed on the same line as the
            next parameter in the parameter pane.


        """
        return _hou.ParmTemplate_setJoinWithNext(self, on)

    def joinWithNext(self) -> "bool":
        r"""

        joinWithNext(self) -> bool

            This method is deprecated in favor of the joinsWithNext method.


        """
        return _hou.ParmTemplate_joinWithNext(self)

    def help(self) -> "std::string":
        r"""

        help(self) -> str

            Return the help that Houdini displays when you hover over the
            parameter label in the parameter pane.


        """
        return _hou.ParmTemplate_help(self)

    def setHelp(self, help: "char const *") -> "void":
        r"""

        setHelp(self, help)

            Set the help that Houdini displays when you hover over the parameter
            label in the parameter pane.


        """
        return _hou.ParmTemplate_setHelp(self, help)

    def scriptCallback(self) -> "std::string":
        r"""

        scriptCallback(self) -> str

            Return the contents of the script that Houdini runs when this
            parameter changes. This script is most commonly used in
            hou.ButtonParmTemplate objects to respond to the button being
            pressed.

            Note that Houdini uses the tags dictionary to store the script
            callback information.


        """
        return _hou.ParmTemplate_scriptCallback(self)

    def setScriptCallback(self, script_callback: "char const *") -> "void":
        r"""

        setScriptCallback(self, script_callback)

            Set the callback script to the given string. This script runs in
            response to a parameter change.

            See the scriptCallback method for more information.


        """
        return _hou.ParmTemplate_setScriptCallback(self, script_callback)

    def scriptCallbackLanguage(self) -> "HOM_EnumValue &":
        r"""

        scriptCallbackLanguage(self) -> hou.scriptLanguage enum value

            Return the language of the script that Houdini runs when this
            parameter changes.

            Note that Houdini uses the tags dictionary to store the script
            callback information.

            See also the scriptCallback method.


        """
        return _hou.ParmTemplate_scriptCallbackLanguage(self)

    def setScriptCallbackLanguage(
        self, script_callback_language: "EnumValue"
    ) -> "void":
        r"""

        setScriptCallbackLanguage(self, script_callback_language)

            Set the script callback language to a hou.scriptLanguage enum value.

            See the scriptCallbackLanguage method for more information.


        """
        return _hou.ParmTemplate_setScriptCallbackLanguage(
            self, script_callback_language
        )

    def tags(
        self,
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        tags(self) -> dict of string to string

            Return a dictionary of extra data stored in the parm template.

            Houdini uses this dictionary to attach arbitrary data to parm
            templates. The keys in this dictionary vary depending on the
            ParmTemplate type and its use.


        """
        return _hou.ParmTemplate_tags(self)

    def setTags(
        self,
        tags: "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const &",
    ) -> "void":
        r"""

        setTags(self, tags)

            Set the dictionary of extra data stored in this parm template.

            See the tags method for more information.


        """
        return _hou.ParmTemplate_setTags(self, tags)

    def asCode(
        self, function_name: "char const *" = None, variable_name: "char const *" = None
    ) -> "std::string":
        r"""

        asCode(self, function_name=None, variable_name=None) -> str

            Return a string containing Python statements that can be executed to
            recreate the parameter template. To run the string, use Python's
            compile, or execfile functions or the exec statement.


            function_name
                If <function_name> is specified, then the code returned creates
                a Python function with the given name. <function_name> must be a
                non-zero length string consisting of only alphanumeric and
                underscore characters. Any invalid characters are internally
                converted to underscores.

                The function returns a reference to the newly created parameter
                template object.

            variable_name
                The name of a Python variable that the result code will assign
                to. If None, Houdini uses the variable name \"hou_parm_template\".

            Here is an example of saving the output to a file and then loading
            it back into Houdini:

          > # Get a reference to the target parameter template.
          > node = hou.node(\"/obj/geo1\")
          > parm_template = node.parm(\"tx\").parmTemplate()
          >
          > # Execute asCode and write the output script to a file.
          > code = parm_template.asCode()
          > source_file = open(\"create_parm_template.py\", \"w\")
          > source_file.write(code)
          > source_file.close()
          >
          > # Execute the script.  The new parameter template will be stored
          > # in the 'hou_parm_template' variable.
          > execfile(\"create_parm_template.py\")
          >
          > # Add a spare parameter to the node using the saved parameter
          > # template.
          > node.addSpareParmTuple(hou_parm_template)

            Here is an example of saving the output into a function in a file
            and then calling it from Houdini:

          > # Get a reference to the target parameter template.
          > node = hou.node(\"/obj/geo1\")
          > parm_template = node.parm(\"tx\").parmTemplate()
          >
          > # Execute asCode and write the function definition to a file.
          > code = parm_template.asCode(function_name=\"createParmTemplate\")
          > source_file = open(\"parmtemplatelib.py\", \"w\")
          > source_file.write(code)
          > source_file.close()
          >
          > # Call the function definition.
          > import parmtemplatelib
          > hou_parm_template = parmtemplatelib.createParmTemplate()
          >
          > # Add a spare parameter to the node using the saved parameter
          > # template.
          > node.addSpareParmTuple(hou_parm_template)

        """
        return _hou.ParmTemplate_asCode(self, function_name, variable_name)


# Register ParmTemplate in _hou:
_hou.ParmTemplate_swigregister(ParmTemplate)


class ParmTemplateGroup(object):
    r"""

    hou.ParmTemplateGroup

    A group of parameter templates used to represent the parameter layout of
    a node or the parameters in a digital asset definition.

    This class stores a group of hou.ParmTemplate objects. You can create an
    empty group, create a group from a sequence of parm templates, or create
    a group from the parameter definitions of a digital asset or from a
    particular node's current parameter layout. Similarly, you can set an
    asset's parameters or a node's parameter interface to the contents of a
    parameter group.

    You can get an asset's parm templates with
    hou.HDADefinition.parmTemplateGroup and set them with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can get an
    individual node's parameter definition with hou.Node.parmTemplateGroup
    and set it with hou.Node.setParmTemplateGroup. When setting a node's
    parameter interface, any parms that are not in the node's type's set of
    parms will be added as spare parameters. Similarly, if parameters in the
    node's type are not present in the group, they will be automatically
    added at the end and made invisible. Also, if they exist but the types,
    labels, looks, naming schemes, etc are different, Houdini will discard
    all changes you attempt to make to these reserved parameters except for
    visibility settings.

    Note that ParmTemplateGroups store their own copy of the parm templates.
    Asking for the parm templates in a group will return a copy of the parm
    templates; modifying those copies will not change the contents of the
    group. For example, to change a parameter in a group you cannot simply
    call find and modify the hou.ParmTemplate it returned. Instead, you must
    call replace.

    It is important to understand the difference between folder parm
    templates and folder set parm templates when using ParmTemplateGroups.
    Folder sets correspond directly to hou.ParmTuple objects -- there is one
    parm tuple (that contains one parm) for each set of folders, and
    changing the value of that parm changes which folder is displayed.
    Individual Folders, on the other hand, do not directly correspond to
    hou.ParmTuple objects, but they are used in Houdini's <Type Properties>
    dialog and they make it easy to add individual folders and control which
    parameters are inside a folder. Unlike a hou.FolderSetParmTemplate, a
    hou.FolderParmTemplate stores the set of parm templates inside that
    folder. When a node or definition's parameters are set to the contents
    of a parm template group, the folder sets are determined and the parm
    tuple name for the set is the name of the first folder in that set. The
    names of the other folders in the set are not used.

    ParmTemplateGroups use folder parm templates instead of folder set parm
    templates. Attempting to add a FolderSetParmTemplate to a group will
    raise hou.OperationFailed. Asking a parm tuple for its parm template, on
    the other hand, may return a folder set but will never return a folder.
    Previously, folder parameter templates and parm template groups did not
    exist, so the only way to add folders were with special methods like
    hou.HDADefinition.addParmFolder and hou.Node.addSpareParmFolder. Now
    that that they exist, you may create folders by passing folder parm
    templates to hou.HDADefinition.addParmTuple and
    hou.Node.addSpareParmTuple. However, using parm template groups is
    preferred over calling these methods.

    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does. The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block. Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, parm_templates=())

            Create a new group from an optional sequence of parm templates. If
            none are passed in, the new group will be empty.

            Because groups and folder parm templates can both be constructed
            using a sequence of contained parm templates, it is possible to
            construct a parm template group with parameters inside folders using
            a single expression. The following example creates a group with two
            folders and with parameters inside each of those folders:

          > >>> group = hou.ParmTemplateGroup((
          > ... hou.FolderParmTemplate(\"folder\", \"Physical\", (
          > ...     hou.FloatParmTemplate(\"mass\", \"Mass\", 1),
          > ...     hou.FloatParmTemplate(\"density\", \"Density\", 1),
          > ... )),
          > ... hou.FolderParmTemplate(\"folder\", \"Divisions\", (
          > ...     hou.FloatParmTemplate(\"divisions\", \"Divisions\", 3),
          > ...     hou.ToggleParmTemplate(\"laser\", \"Laser Scan\", default_value=True),
          > ... )),
          > ... ))
          > >>> group.entries()
          > (<hou.FolderParmTemplate name='folder' label='Physical' folder_style=Tabs>,
          > <hou.FolderParmTemplate name= 'folder' label='Divisions' folder_style=Tabs>)
          > >>> group.entries()[0].parmTemplates()[0]
          > <hou.FloatParmTemplate name='mass' label='Mass' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>
          > >>> group.entriesWithoutFolders()
          > (<hou.FloatParmTemplate name='mass' label='Mass' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>,
          >  <hou.FloatParmTemplate name='density' label='Density' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>,
          >   <hou.FloatParmTemplate name='divisions' label='Divisions' length=3 naming_scheme=XYZW look=Regular default_value=(0,0,0)>,
          >    <hou.ToggleParmTemplate name='laser' label='Laser Scan' default_value=True>)

            Raises hou.OperationFailed if any of the parm templates in the
            sequence are hou.FolderSetParmTemplate objects.


        """
        _hou.ParmTemplateGroup_swiginit(self, _hou.new_ParmTemplateGroup(*args))

    def __repr__(self) -> "std::string":
        return _hou.ParmTemplateGroup___repr__(self)

    def __eq__(
        self, parm_template_group: "HOM_PtrOrNull< HOM_ParmTemplateGroup >"
    ) -> "bool":
        return _hou.ParmTemplateGroup___eq__(self, parm_template_group)

    def __ne__(
        self, parm_template_group: "HOM_PtrOrNull< HOM_ParmTemplateGroup >"
    ) -> "bool":
        return _hou.ParmTemplateGroup___ne__(self, parm_template_group)

    def find(self, name: "char const *") -> "HOM_ParmTemplate *":
        r"""

        find(self, name) -> hou.ParmTemplate or None

            Search in this group for a parm template whose name matches the
            specified one. Return a copy of the parm template or None if no
            match was found.

            Note that this function returns a copy of the parm template stored
            in this group. Modifying the copy will not affect the parameters in
            this group. The following example shows how to use the find and
            replace methods to modify the \"pos\" parm template in the group:

          > >>> parm_template = group.find(\"pos\")
          > >>> parm_template.setLabel(\"Position\")
          > >>> group.replace(\"pos\", parm_template)

            If you created the group from existing parameters, folder parm
            templates in the same folder set will share the same name, so
            searching for a folder using this method may return the first folder
            in the folder set. To instead search for a folder by its folder
            label, use findFolder.

            Note that, in general, the group does not prevent you from adding
            two parameters with the same name. In this case, searching for a
            parameter with this name will return the first one. Note, though,
            that when when setting this group to a node or asset definition's
            parms, either the duplicate parameters will be renamed on an
            exception will be raised. See the rename_conflicting_parms parameter
            to hou.HDADefinition.setParmTemplateGroup for more information.


        """
        return _hou.ParmTemplateGroup_find(self, name)

    def findIndices(self, *args) -> "std::vector< int,std::allocator< int > >":
        r"""

        findIndices(self, name_or_parm_template) -> tuple of int

            Search in this group for a parm template and return a tuple of
            integers corresponding to the indices of the parm in the group.
            Return an empty tuple if no match was found.


            name_or_parm_template
                Either the name of the parm template or another hou.ParmTemplate
                object to compare against when searching for a match.

            If the parm template was found and it is not inside any folders, the
            result tuple will contain a single integer with the index of the
            parm template. Otherwise, the first entry will be the index of a
            folder inside the group, the next will be an index of a folder
            inside that folder, and so on until the last index is an index of a
            parm template inside a folder.

            See also findIndicesForFolder.


        """
        return _hou.ParmTemplateGroup_findIndices(self, *args)

    def findFolder(self, *args) -> "HOM_ParmTemplate *":
        r"""

        findFolder(self, label_or_labels) -> hou.FolderParmTemplate or None

            Search in this group for a folder parm template with the given
            label. Return a copy of the hou.FolderParmTemplate or None if the
            folder wasn't found.


            label_or_labels
                Either a string containing the folder's label or a tuple of
                strings containing the labels of containing folders as well as
                the folder's label.

            Note that a folder parm template's label is what appears in the
            interface in the parameter dialog. The folder parm template's name
            is used to determine the name of the parm tuple for the folder set,
            if the folder is the first in the folder set. See the documentation
            for this class for more information.


        """
        return _hou.ParmTemplateGroup_findFolder(self, *args)

    def findIndicesForFolder(self, *args) -> "std::vector< int,std::allocator< int > >":
        r"""

        findIndicesForFolder(self, label_or_labels) -> tuple of int

            Search in this group for a folder parm template with the given
            label. Return an empty tuple if no match was found.

            See findFolder for a description of the parameter and findIndices
            for a description of the return value.

            Note that this method does not accept a parm template. However, if
            you have a folder parm template and want to find its indices, simply
            call findIndices on the folder parm template.


        """
        return _hou.ParmTemplateGroup_findIndicesForFolder(self, *args)

    def entryAtIndices(self, indices: "_IntTuple") -> "HOM_ParmTemplate *":
        r"""

        entryAtIndices(self, indices) -> hou.ParmTemplate

            Given a sequence of integer indices return a copy of the
            hou.ParmTemplate object at that location. The indices are of the
            format returned by findIndices.

            Like the hou.ParmTemplate.find and hou.ParmTemplate.entries methods,
            this method returns a copy of the parm template stored inside this
            group. Modifying the copied parm template will not affect the
            contents of this group. Use replace to change a parm template.

            Raises hou.OperationFailed if the indices are invalid, including
            when the indices sequence is empty.

            This method could be implemented as follows:

          > def entryAtIndices(self, indices):
          >     if len(indices) == 0:
          >         raise hou.OperationFailed(\"Invalid indices\")
          >     parm_template = self.entries()[indices[0]]
          >
          >     # If there are multiple indices then we should have just looked up
          >     # a folder parm template.
          >     for index in indices[1:]:
          >         parm_template = parm_template.parmTemplates()[index]
          >     return parm_template

        """
        return _hou.ParmTemplateGroup_entryAtIndices(self, indices)

    def containingFolderIndices(
        self, *args
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        containingFolderIndices(self, name_or_parm_template_or_indices) -> tuple
        of int

            Return the indices of the folder in this group containing a given
            parm template. Return an empty tuple if no match was found.

            See replace for a description of the parameter and findIndices for a
            description of the return value.

            Raises hou.OperationFailed if the parameter is not inside the group
            or is not inside a folder.


        """
        return _hou.ParmTemplateGroup_containingFolderIndices(self, *args)

    def containingFolder(self, *args) -> "HOM_ParmTemplate *":
        r"""

        containingFolder(self, name_or_parm_template) -> hou.FolderParmTemplate

            Return a copy of the hou.FolderParmTemplate in this group containing
            a parm template.


            name_or_parm_template
                Either the name of the parm template or another hou.ParmTemplate
                object to compare against when searching for a match.

            Raises hou.OperationFailed if the parameter is not inside the group
            or is not inside a folder.


        """
        return _hou.ParmTemplateGroup_containingFolder(self, *args)

    def entries(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTemplate >,std::allocator< HOM_ElemPtr< HOM_ParmTemplate > > >":
        r"""

        entries(self) -> tuple of hou.ParmTemplate

            Return a tuple containing copies of the parm templates inside this
            group.

            Note that folders are returned as hou.FolderParmTemplate objects,
            and each folder parm template contains the parm templates inside it.
            Use hou.FolderParmTemplate.parmTemplates to access the elements in a
            folder.

            The following example creates a function named allParmTemplates that
            returns a single sequence of parm templates, including folders, for
            all parm templates in the group:

          > def allParmTemplates(group_or_folder):
          >     for parm_template in group_or_folder.parmTemplates():
          >         yield parm_template
          >
          >     # Note that we don't want to return parm templates inside multiparm
          >     # blocks, so we verify that the folder parm template is actually
          >     # for a folder.
          >         if (parm_template.type() == hou.parmTemplateType.Folder and
          >         parm_template.isActualFolder()):
          >             for sub_parm_template in allParmTemplates(parm_template):
          >                 yield sub_parm_template

            See also the parmTemplates method.


        """
        return _hou.ParmTemplateGroup_entries(self)

    def parmTemplates(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTemplate >,std::allocator< HOM_ElemPtr< HOM_ParmTemplate > > >":
        r"""

        parmTemplates(self) -> tuple of hou.ParmTemplate

            This method is simply an alias for the entries method.

            It makes it easier to search down through a parm template group for
            items nested in folders, since the hou.FolderParmTemplate class also
            has a method named parmTemplates. The following example shows how to
            look up the labels for a folder parameter given its indices:

          > def folderLabels(parm_template_group, indices):
          >     container = parm_template_group
          >     result = []
          >     for index in indices:
          >         container = container.parmTemplates()[index]
          >         result.append(container.label())
          >     return result

        """
        return _hou.ParmTemplateGroup_parmTemplates(self)

    def entriesWithoutFolders(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTemplate >,std::allocator< HOM_ElemPtr< HOM_ParmTemplate > > >":
        r"""

        entriesWithoutFolders(self) -> tuple of hou.ParmTemplate

            Return a tuple containing all the non-folder parm templates inside
            this group. The output is the flattened set of parm templates in the
            group, and includes the non-folder parms inside folders.

            Like entries, this method returns a copy of the parm templates
            inside this group.

            Note that this function does not return parm templates for entries
            inside multiparm blocks.

            Also see the entries method for the example function
            allParmTemplates.


        """
        return _hou.ParmTemplateGroup_entriesWithoutFolders(self)

    def replace(self, *args) -> "void":
        r"""

        replace(self, name_or_parm_template_or_indices, parm_template)

            Replace a parm template inside this group with another parm
            template.


            name_or_parm_template_or_indices
                Either the name of the parm template being replaced, a copy of
                the parm template, or a tuple of integer indices that identify
                the parm template and any containing folders.

            This method changes the contents of this group. Note that it stores
            a copy of the parm template in the group, so future changes to the
            parm template passed in will not affect the group.

            See the find method for a simple example of how to use this method.

            Note that parm templates for reserved parameters (for example, the
            transform parameters in object-level digital assets) can be replaced
            in the parm template group, but all aspects of reserved parameters
            except for their visibility and join settings will be restored to
            their defaults when you save this group to a node or asset
            definition.

            Raises hou.OperationFailed if the parm template doesn't exist.


        """
        return _hou.ParmTemplateGroup_replace(self, *args)

    def insertBefore(self, *args) -> "void":
        r"""

        insertBefore(self, name_or_parm_template_or_indices, parm_template)

            Insert a parm template inside this group before an existing one. The
            new parm template will be in the same folder as the existing one.

            See replace for a description of the name/parm template/indices
            parameter.

            Use appendToFolder to add an entry to a empty folder. Use append to
            add an entry to an empty parm template group.


        """
        return _hou.ParmTemplateGroup_insertBefore(self, *args)

    def insertAfter(self, *args) -> "void":
        r"""

        insertAfter(self, name_or_parm_template_or_indices, parm_template)

            Insert a parm template inside this group after an existing one. The
            new parm template will be in the same folder as the existing one.

            See replace for a description of the name/ parm template/indices
            parameter.

            Use appendToFolder to add an entry to a empty folder. Use append to
            add an entry to an empty parm template group.


        """
        return _hou.ParmTemplateGroup_insertAfter(self, *args)

    def append(self, parm_template: "ParmTemplate") -> "void":
        r"""

        append(self, parm_template)

            Add a parm template after all existing parm templates, outside of
            any folder.

            See also appendToFolder.


        """
        return _hou.ParmTemplateGroup_append(self, parm_template)

    def appendToFolder(self, *args) -> "void":
        r"""

        appendToFolder(self, label_or_labels_or_parm_template_or_indices,
        parm_template)

            Add a parm template to the bottom of an existing folder.

            Note that you cannot add to a folder by simply looking up the folder
            parm template and calling hou.FolderParmTemplate.addParmTemplate on
            it, because asking for a folder will return a deep copy. The parm
            templates inside the copied folder will be separate from those
            inside this group, and modifying the folder will not affect the
            group. Consider the following example:

          > >>> folder = group.findFolder(\"Transform\")
          > # \"folder\" now has its own copy of the parms inside it.
          > >>> folder.addParmTemplate(new_parm_template)
          > # \"folder\"'s parm templates are updated, but the group's parm templates are
          > # unchanged.
          >
          > >>> group.appendToFolder(folder, new_parm_template)
          > # The group is modified.  \"folder\"'s contents are unchanged.

        """
        return _hou.ParmTemplateGroup_appendToFolder(self, *args)

    def addParmTemplate(self, parm_template: "ParmTemplate") -> "void":
        r"""

        addParmTemplate(self, parm_template)

            This method is simply an alias for the append method.

            It makes it easier to treat parm template groups and
            hou.FolderParmTemplate objects uniformly, since
            hou.FolderParmTemplate has an addParmTemplate method.


        """
        return _hou.ParmTemplateGroup_addParmTemplate(self, parm_template)

    def remove(self, *args) -> "void":
        r"""

        remove(self, name_or_parm_template_or_indices)

            Remove a parm template from the group. Note that if you remove a
            folder, all of the parm templates in the folder are also removed.

            See replace for a description of the name/parm template/indices
            parameter.

            Raises hou.OperationFailed if the parm template could not be found.


        """
        return _hou.ParmTemplateGroup_remove(self, *args)

    def hide(self, *args) -> "void":
        r"""

        hide(self, name_or_parm_template_or_indices, on)

            Hide a parameter by making it invisible. The parameter still exists
            in the group, but parameter dialogs will not display it.

            See replace for a description of the name/parm template/indices
            parameter.

            This method could be implemented as follows:

          > def hide(self, name_or_parm_template_or_indices, on):
          >     parm_template = self.find(name_or_parm_template_or_indices)
          >     parm_template.hide(on)
          >     self.replace(name_or_parm_template_or_indices, parm_template)

            See also hideFolder and hou.ParmTemplate.hide.


        """
        return _hou.ParmTemplateGroup_hide(self, *args)

    def hideFolder(self, *args) -> "void":
        r"""

        hideFolder(self, label_or_labels, on)

            Hide a folder and all the parameters in it.

            You may pass in either a string containing a single folder name or a
            sequence of strings to identify a nested folder. For example, the
            sequence (\"Render\", \"Dicing\") identifies the Dicing folder inside
            the Render folder. The folder is hidden if on is True and unhidden
            if it is False.

            The following example hides the Transform parameter in a geometry
            object:

          > >>> group = geo_node.parmTemplateGroup()
          > >>> group.hideFolder(\"Transform\", True)
          > >>> geo_node.setParmTemplateGroup(group)

            The following example hides the Dicing folder inside the Render
            folder on a geometry object:

          > >>> group = geo_node.parmTemplateGroup()
          > >>> group.hideFolder((\"Render\", \"Dicing\"), True)
          > >>> geo_node.setParmTemplateGroup(group)

            This method could be implemented as follows:

          > def hideFolder(self, label_or_labels, on):
          >     self.hide(self.findFolder(label_or_labels), on)

            See also hide.


        """
        return _hou.ParmTemplateGroup_hideFolder(self, *args)

    def isHidden(self, *args) -> "bool":
        r"""

        isHidden(self, name_or_parm_template_or_indices) -> bool

            Return whether the given parameter is itself hidden or lies inside a
            hidden folder.

            See replace for a description of the name/parm template/indices
            parameter.

            Note that if the parameter is inside a hidden folder but the
            parameter is not marked as hidden, calling hou.ParmTemplate.isHidden
            on the parm template will return False, while this method will
            return True.


        """
        return _hou.ParmTemplateGroup_isHidden(self, *args)

    def isFolderHidden(self, *args) -> "bool":
        r"""

        isFolderHidden(self, label_or_labels) -> bool

            Return whether a folder or one of its containing folders is hidden.

            Note that if a folder is inside a hidden folder but this folder is
            not marked as hidden, calling hou.ParmTemplate.isHidden on the
            folder parm template will return False, while this method will
            return True.

            You may pass in either a string containing a single folder name or a
            sequence of strings to identify a nested folder. For example, the
            sequence (\"Render\", \"Dicing\") identifies the Dicing folder inside
            the Render folder. The folder is hidden if on is True and unhidden
            if it is False.


        """
        return _hou.ParmTemplateGroup_isFolderHidden(self, *args)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove all parm templates from this group.


        """
        return _hou.ParmTemplateGroup_clear(self)

    def asDialogScript(self, *args, **kwargs) -> "std::string":
        r"""

        asDialogScript(rename_conflicting_parms=False, full_info=False,
        script_name=None, script_label=None, script_tags={}) -> str

            Return a string containing the dialog script file contents
            corresponding to this parm template group.

            Houdini saves parameter definitions in this format when saving
            digital asset definitions (in the DialogScript section of the
            digital asset) and when saving parameter layouts of nodes.

            The default behavior for reserved parameters is to output baseparm
            tokens for reserved parameters so that it is resistant to changes in
            their definition. To change this, use full_info=True.

            The script_name, script_label and script_tags parameters specify
            additional data that is saved to the dialog script header as the
            name, label, and parmtag options respectively. The script_tags
            dictionary should map strings to strings. Each entry is saved to the
            dialog script as a separate parmtag. The interpretation of these
            additional header elements depends on where this dialog script is
            being used. When used to provide the parameter definitions for an
            HDA, these elements are ignored. But when using the dialog script as
            a source of render properties, these additional elements will be
            used to filter and categorize the properties in the Edit Parameter
            Interface window.


        """
        return _hou.ParmTemplateGroup_asDialogScript(self, *args, **kwargs)

    def setToDialogScript(self, dialog_script: "char const *") -> "void":
        r"""

        setToDialogScript(dialog_script)

            Set the contents of this group to match the parameters defined by
            the given dialog script string.

            Raises hou.OperationFailed if there is an error in the dialog script
            contents.


        """
        return _hou.ParmTemplateGroup_setToDialogScript(self, dialog_script)

    def asCode(
        self, function_name: "char const *" = None, variable_name: "char const *" = None
    ) -> "std::string":
        r"""

        asCode(self, function_name=None, variable_name=None) -> str

            Return Python code that will recreate this group.


            function_name
                If not None, the returned code will create a Python function.

            variable_name
                The name of the variable that will be assigned the newly-created
                parm template group.


        """
        return _hou.ParmTemplateGroup_asCode(self, function_name, variable_name)

    def sourceNode(self) -> "HOM_Node *":
        r"""

        sourceNode(self) -> hou.Node or None

            Return the node that the parameter template group was generated
            from. If the group was not generated from a node, then return None.

            Raises hou.ObjectWasDeleted if the source node has been destroyed.


        """
        return _hou.ParmTemplateGroup_sourceNode(self)

    def sourceNodeType(self) -> "HOM_NodeType *":
        r"""

        sourceNodeType(self) -> hou.NodeType or None

            Return the node type that the parameter template group was generated
            from. If the group was not generated from a node type, then return
            None.

            Raises hou.ObjectWasDeleted if the source node type has been
            destroyed.


        """
        return _hou.ParmTemplateGroup_sourceNodeType(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the internal name recorded to this object, either through a
            call to setName, or loaded from a dialog script using the
            setToDialogScript method.


        """
        return _hou.ParmTemplateGroup_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Set the internal name for this parameter group. This information is
            written to the output of asDialogScript if the script_name parameter
            is left at the default value of None.


        """
        return _hou.ParmTemplateGroup_setName(self, name)

    def label(self) -> "std::string":
        r"""

        label(self) -> str

            Return the label recorded to this object, either through a call to
            setLabel, or loaded from a dialog script using the setToDialogScript
            method.


        """
        return _hou.ParmTemplateGroup_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self, label)

            Set the label for this parameter group. This information is written
            to the output of asDialogScript if the script_label parameter is
            left at the default value of None.


        """
        return _hou.ParmTemplateGroup_setLabel(self, label)

    __swig_destroy__ = _hou.delete_ParmTemplateGroup


# Register ParmTemplateGroup in _hou:
_hou.ParmTemplateGroup_swigregister(ParmTemplateGroup)


class Pane(object):
    r"""

    hou.Pane

    A rectangular area of the desktop that contains one or more pane tabs.

    Desktops (and floating panels) are composed of one or more panes.
    Initially a desktop contains one pane, and more panes are added to it by
    splitting existing panes in two, either horizontally or vertically.

    See hou.Desktop for more information about panes and pane tabs. See
    hou.FloatingPanel for more information about floating panels.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Pane

    def __repr__(self) -> "std::string":
        return _hou.Pane___repr__(self)

    def desktop(self) -> "HOM_Desktop *":
        r"""

        desktop(self) -> hou.Desktop or None

            Return the desktop in which this pane exists, or None if it is in a
            floating panel that's not attached to the desktop.


        """
        return _hou.Pane_desktop(self)

    def id(self) -> "int":
        return _hou.Pane_id(self)

    def isMaximized(self) -> "bool":
        r"""

        isMaximized(self) -> bool

            Return True if this pane is maximized.


        """
        return _hou.Pane_isMaximized(self)

    def floatingPanel(self) -> "HOM_FloatingPanel *":
        return _hou.Pane_floatingPanel(self)

    def setIsMaximized(self, on: "bool") -> "void":
        r"""

        setIsMaximized(self, on)

            Set the maximized state of this pane.


        """
        return _hou.Pane_setIsMaximized(self, on)

    def tabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        tabs(self) -> tuple of hou.PaneTab

            Return the pane tabs in this pane.


        """
        return _hou.Pane_tabs(self)

    def createTab(self, type: "EnumValue") -> "HOM_PaneTab *":
        r"""

        createTab(self, type) -> hou.PaneTab

            Create a new pane tab with the desired type and return it. The new
            pane tab will be current (i.e. it will be the pane tab that's open).


        """
        return _hou.Pane_createTab(self, type)

    def currentTab(self) -> "HOM_PaneTab *":
        r"""

        currentTab(self) -> hou.PaneTab

            Return the currently focused pane tab.

            See also hou.PaneTab.setIsCurrentTab.


        """
        return _hou.Pane_currentTab(self)

    def tabOfType(self, type: "EnumValue", index: "int" = 0) -> "HOM_PaneTab *":
        r"""

        tabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return a pane tab with the desired type, or None if no such
            tab exists in the pane.

            If there are multiple tabs in the pane with the desired type, then
            the first found tab is returned. Use index to return the other tabs.
            For example, use index=0 to return the first found tab, use index=1
            to return the second found tab, etc.

            See also hou.ui.paneTabOfType.


        """
        return _hou.Pane_tabOfType(self, type, index)

    def splitHorizontally(self) -> "HOM_Pane *":
        r"""

        splitHorizontally(self) -> hou.Pane

            Split the pane, adding a new pane to the right, and return the new
            pane. The new pane will have a single tab whose type is the same as
            the type of this pane's current tab.

            See also hou.Pane.splitVertically.


        """
        return _hou.Pane_splitHorizontally(self)

    def splitVertically(self) -> "HOM_Pane *":
        r"""

        splitVertically(self) -> hou.Pane

            Split the pane, adding a new pane to the bottom, and return the new
            pane. The new pane will have a single tab whose type is the same as
            the type of this pane's current tab.

            See also hou.Pane.splitHorizontally.


        """
        return _hou.Pane_splitVertically(self)

    def getSplitParent(self) -> "HOM_Pane *":
        r"""

        getSplitParent(self) -> hou.Pane or None

            Return the parent split pane if the Pane is nested under a split.


        """
        return _hou.Pane_getSplitParent(self)

    def getSplitChild(self, child: "int") -> "HOM_Pane *":
        r"""

        getSplitChild(self,index) -> hou.Pane or None

            Return the split child Pane at index if the Pane is a split.


        """
        return _hou.Pane_getSplitChild(self, child)

    def splitSwap(self) -> "void":
        r"""

        splitSwap(self)

            Swap the left and right panes of an horizontal split Pane. Swap the
            top and bottom panes of a vertical split Pane.


        """
        return _hou.Pane_splitSwap(self)

    def splitRotate(self) -> "void":
        r"""

        splitRotate(self)

            Turn an horizontal split Pane into a vertical split Pane.


        """
        return _hou.Pane_splitRotate(self)

    def isSplitMaximized(self) -> "bool":
        r"""

        isSplitMaximized(self) -> bool

            Return True if the Pane is maximized on the split. A split can't be
            minimized and maximized at the same time. In its default state, a
            split is not minimized and not maximized.


        """
        return _hou.Pane_isSplitMaximized(self)

    def isSplitMinimized(self) -> "bool":
        r"""

        isSplitMinimized(self) -> bool

            Return True if the Pane is minimized on the split. A split can't be
            minimized and maximized at the same time. In its default state, a
            split is not minimized and not maximized.


        """
        return _hou.Pane_isSplitMinimized(self)

    def setIsSplitMaximized(self, on: "bool") -> "void":
        r"""

        setIsSplitMaximized(self, on) -> bool

            Set the maximized state of a split.


        """
        return _hou.Pane_setIsSplitMaximized(self, on)

    def isSplit(self) -> "bool":
        r"""

        isSplit(self) -> bool

            Return True if the pane is a split.


        """
        return _hou.Pane_isSplit(self)

    def setSplitFraction(self, value: "double") -> "void":
        r"""

        setSplitFraction(self,fraction)

            Set the split fraction of the parent split.


        """
        return _hou.Pane_setSplitFraction(self, value)

    def getSplitFraction(self) -> "double":
        r"""

        getSplitFraction(self,fraction) -> double

            Return the split fraction of the parent split.


        """
        return _hou.Pane_getSplitFraction(self)

    def setSplitDirection(self, dir: "int") -> "void":
        r"""

        setSplitDirection(self,dir)

            Set the split direction of the parent split.


        """
        return _hou.Pane_setSplitDirection(self, dir)

    def getSplitDirection(self) -> "int":
        r"""

        getSplitDirection(self,dir) -> double

            Return the split direction of the parent split.


        """
        return _hou.Pane_getSplitDirection(self)

    def setShowPaneTabs(self, value: "bool") -> "void":
        r"""

        setShowPaneTabs(self,on)

            Show or Hide the pane tabs bar.

            This method is deprecated in favor of showPaneTabs.


        """
        return _hou.Pane_setShowPaneTabs(self, value)

    def showPaneTabs(self, value: "bool") -> "void":
        r"""

        showPaneTabs(self,on)

            Show or Hide the pane tabs bar.


        """
        return _hou.Pane_showPaneTabs(self, value)

    def isShowingPaneTabs(self) -> "bool":
        r"""

        isShowingPaneTabs(self) -> bool

            Return True if the Pane is showing pane tabs.


        """
        return _hou.Pane_isShowingPaneTabs(self)

    def showPaneTabsStow(self, value: "bool") -> "void":
        r"""

        showPaneTabsStow(self,on)

            Show or Hide the pane tabs stow bar button when pane tabs are
            hidden.


        """
        return _hou.Pane_showPaneTabsStow(self, value)

    def isShowingPaneTabsStow(self) -> "bool":
        r"""

        isShowingPaneTabsStow(self) -> bool

            Return True if the Pane is showing the pane tabs stow bar when pane
            tabs are hidden.


        """
        return _hou.Pane_isShowingPaneTabsStow(self)


# Register Pane in _hou:
_hou.Pane_swigregister(Pane)


class PaneTab(object):
    r"""

    hou.PaneTab

    One of the tabs inside a desktop pane.

    Each pane type is of a particular type (e.g. scene viewer, network view,
    parameters, etc.). A pane may contain multiple tabs and displays the
    contents of one tab at a time.

    See hou.Desktop for more information about panes and pane tabs.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PaneTab

    def __eq__(self, pane_tab: "HOM_PtrOrNull< HOM_PaneTab >") -> "bool":
        return _hou.PaneTab___eq__(self, pane_tab)

    def __ne__(self, pane_tab: "HOM_PtrOrNull< HOM_PaneTab >") -> "bool":
        return _hou.PaneTab___ne__(self, pane_tab)

    def __hash__(self) -> "int":
        return _hou.PaneTab___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.PaneTab___repr__(self)

    def pane(self) -> "HOM_Pane *":
        r"""

        pane(self) -> hou.Pane or None

            Return the pane in the desktop that contains this pane tab. Note
            that pane tabs in regular floating panels are always in a pane,
            since regular floating panels contain one or more panes.

            However, some floating panels have their content stripped down to
            only contain one particular pane tab type, and do not display the
            user interface to add more pane tabs, split the pane, etc. This
            method returns None for these stripped down floating panels.


        """
        return _hou.PaneTab_pane(self)

    def floatingPanel(self) -> "HOM_FloatingPanel *":
        r"""

        floatingPanel(self) -> hou.FloatingPanel or None

            Return the floating panel that contains this pane tab or None if the
            pane tab is not in a floating panel.


        """
        return _hou.PaneTab_floatingPanel(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this tab.


        """
        return _hou.PaneTab_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Set the name of this pane tab. A pane tab name may contain spaces.

            Note that this name is the internal name of the tab, and is
            different from the label displayed in the interface.


        """
        return _hou.PaneTab_setName(self, name)

    def isCurrentTab(self) -> "bool":
        r"""

        isCurrentTab(self) -> bool

            Return whether this tab is the selected tab in the containing pane.


        """
        return _hou.PaneTab_isCurrentTab(self)

    def setIsCurrentTab(self) -> "void":
        r"""

        setIsCurrentTab(self)

            Set this tab as the selected tab in the containing pane.


        """
        return _hou.PaneTab_setIsCurrentTab(self)

    def isFloating(self) -> "bool":
        r"""

        isFloating(self) -> bool

            Return whether this pane tab is in a floating panel.

            This method can be approximately implemented as follows:

          > def isFloating(self):
          >     return self.pane() is None or self.pane().floatingPanel() is not None

        """
        return _hou.PaneTab_isFloating(self)

    def clone(self) -> "HOM_PaneTab *":
        r"""

        clone(self) -> hou.PaneTab

            Create a floating copy of the pane tab and return the cloned pane
            tab. The new pane tab is in a new floating panel.


        """
        return _hou.PaneTab_clone(self)

    def close(self) -> "void":
        r"""

        close(self)

            Close the pane tab.


        """
        return _hou.PaneTab_close(self)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.paneTabType enum value

            Return the type of this tab (i.e. whether it is a scene viewer,
            parameter editor, network editor, etc.).


        """
        return _hou.PaneTab_type(self)

    def setType(self, type: "EnumValue") -> "HOM_PaneTab *":
        r"""

        setType(self, type) -> hou.PaneTab

            Create a new pane tab of the given type, replace this tab with it,
            and return the new pane tab. Use the returned pane tab afterward;
            references to this tab become invalid.


        """
        return _hou.PaneTab_setType(self, type)

    def linkGroup(self) -> "HOM_EnumValue &":
        r"""

        linkGroup(self) -> hou.paneLinkType enum value

            Return the link group that this pane tab belongs to.

            See also hou.PaneTab.isPin.


        """
        return _hou.PaneTab_linkGroup(self)

    def setLinkGroup(self, group: "EnumValue") -> "void":
        r"""

        setLinkGroup(self, group)

            Set the link group membership of this pane tab.


        """
        return _hou.PaneTab_setLinkGroup(self, group)

    def isPin(self) -> "bool":
        r"""

        isPin(self) -> bool

            Return whether this pane tab is pinned. This method is equivalent to
            (self.linkGroup() == hou.paneLinkType.Pinned)

            See also hou.PaneTab.linkGroup.


        """
        return _hou.PaneTab_isPin(self)

    def setPin(self, pin: "bool") -> "void":
        r"""

        setPin(self, pin)

            If pin is True, set the link group membership to
            hou.paneLinkType.Pinned. Otherwise, set it to
            hou.paneLinkType.FollowSelection. This method can be implemented
            using hou.PaneTab.setLinkGroup as follows:

          > def setPin(self, pin):
          >     if pin:
          >         self.setLinkGroup(hou.paneLinkType.Pinned)
          >     else:
          >         self.setLinkGroup(hou.paneLinkType.FollowSelection)

            See also hou.PaneTab.setLinkGroup.


        """
        return _hou.PaneTab_setPin(self, pin)

    def _getValueNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.PaneTab__getValueNames(self)

    def _getValue(self, name: "char const *") -> "std::string":
        return _hou.PaneTab__getValue(self, name)

    def _setValue(self, name: "char const *", value: "char const *") -> "bool":
        return _hou.PaneTab__setValue(self, name, value)

    def _pressButton(self, name: "char const *") -> "bool":
        return _hou.PaneTab__pressButton(self, name)

    def size(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        contentSize() -> tuple of int

            Return a 2-tuple containing the pane tab's content area width and
            height.

            The width and height do not include the network navigation control
            area (if any), pane tab borders or tab area.


        """
        return _hou.PaneTab_size(self)

    def contentSize(self) -> "std::vector< int,std::allocator< int > >":
        return _hou.PaneTab_contentSize(self)

    def hasNetworkControls(self) -> "bool":
        r"""

        hasNetworkControls(self) -> bool

            Return True if this pane tab type supports network controls.


        """
        return _hou.PaneTab_hasNetworkControls(self)

    def isShowingNetworkControls(self) -> "bool":
        r"""

        isShowingNetworkControls(self) -> bool

            Return whether this pane tab is showing its network control bar.
            Return False if the pane tab doesn't have network controls. See also
            hou.PaneTab.hasNetworkControls.


        """
        return _hou.PaneTab_isShowingNetworkControls(self)

    def setShowNetworkControls(self, value: "bool") -> "void":
        r"""

        setShowNetworkControls(self, pin)

            Show or Hide the network control bar. Has no effect if the pane tab
            doesn't have network controls. See also
            hou.PaneTab.hasNetworkControls.

            This method is deprecated in favor of showNetworkControls.


        """
        return _hou.PaneTab_setShowNetworkControls(self, value)

    def showNetworkControls(self, value: "bool") -> "void":
        r"""

        showNetworkControls(self, pin)

            Show or Hide the network control bar. Has no effect if the pane tab
            doesn't have network controls. See also
            hou.PaneTab.hasNetworkControls.


        """
        return _hou.PaneTab_showNetworkControls(self, value)

    def displayRadialMenu(self, *args) -> "void":
        r"""

        displayRadialMenu(self, menu)

            Launch the specified radial menu in the pane tab.


            menu
                The name of the registered radial menu. Alternatively, a
                temporary radial submenu (or script menu) can be passed. See
                also hou.ui.createRadialItem.


        """
        return _hou.PaneTab_displayRadialMenu(self, *args)


# Register PaneTab in _hou:
_hou.PaneTab_swigregister(PaneTab)


class PathBasedPaneTab(PaneTab):
    r"""

    hou.PathBasedPaneTab

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PathBasedPaneTab

    def __repr__(self) -> "std::string":
        return _hou.PathBasedPaneTab___repr__(self)

    def pwd(self) -> "HOM_Node *":
        r"""

        pwd(self) -> Node


        """
        return _hou.PathBasedPaneTab_pwd(self)

    def setPwd(self, node: "Node") -> "void":
        r"""

        setPwd(self, node)


        """
        return _hou.PathBasedPaneTab_setPwd(self, node)

    def cd(self, path: "char const *") -> "void":
        r"""

        cd(self, path)


        """
        return _hou.PathBasedPaneTab_cd(self, path)

    def currentNode(self) -> "HOM_Node *":
        r"""

        currentNode(self) -> Node


        """
        return _hou.PathBasedPaneTab_currentNode(self)

    def setCurrentNode(self, node: "Node", pick_node: "bool" = True) -> "void":
        r"""

        setCurrentNode(self, node, pick_node = True)


        """
        return _hou.PathBasedPaneTab_setCurrentNode(self, node, pick_node)


# Register PathBasedPaneTab in _hou:
_hou.PathBasedPaneTab_swigregister(PathBasedPaneTab)


class DopData(object):
    r"""

    hou.DopData

    A piece of data stored inside a DOP network's simulation.

    Each DOP network builds a tree of data, and then Houdini examines and
    updates this tree when it runs the simulation. DOP data elements can be
    DOP objects, geometry, volumes, forces, solvers, etc. The data is
    arranged in a tree structure, where child nodes are called subdata and
    are said to be attached to their parent nodes. Under the root of the
    tree are usually the DOP objects and data describing their
    relationships.

    Note that the same piece of data can appear in the tree in multiple
    locations, with different names. DopData objects thus do not store their
    name, and the name of a piece of data in the tree is instead stored with
    its parent data(s).

    By default, DopData objects store the path within the tree to the data.
    As a consequence, if the time changes and the solvers within the
    simulation change the contents of the tree of data, the Python DopData
    object will update to refer to the simulation's new state. If the data
    path no longer refers to valid data, Houdini raises hou.ObjectWasDeleted
    when you try to access the DopData object from Python.

    If you do not want the DopData to update with changes to the simulation,
    you can call hou.DopData.freeze. freeze returns another DopData object
    that refers the simulation's state at the current time, and will not
    change when the simulation time changes.

    Each piece of data can contain records, and each record stores a list of
    name and value pairs called fields. Each record has a name, but it's
    possible for multiple records with the same name to exist in the same
    piece of data. In this case, the record also has an index, and you can
    think of the records as rows of a spreadsheet.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_DopData

    def __eq__(self, data: "HOM_PtrOrNull< HOM_DopData >") -> "bool":
        return _hou.DopData___eq__(self, data)

    def __ne__(self, data: "HOM_PtrOrNull< HOM_DopData >") -> "bool":
        return _hou.DopData___ne__(self, data)

    def freeze(self) -> "HOM_DopData *":
        r"""

        freeze(self) -> hou.DopData

            Return a frozen version of this DopData. Frozen versions of the data
            will not update when the simulation updates. Instead, they will
            refer to the state of the simulation at the time they were frozen.

            It is ok to call this method on a DopData object that is already
            frozen.


        """
        return _hou.DopData_freeze(self)

    def isFrozen(self) -> "bool":
        r"""

        isFrozen(self) -> bool

            Return whether or not this data is frozen.

            See hou.DopData.freeze for more information.


        """
        return _hou.DopData_isFrozen(self)

    def path(self) -> "std::string":
        r"""

        path(self) -> str

            Return the path to this object within the tree of DOP data. This
            path includes the DOP object or relationship as the first part of
            the path.

            Note that the same piece of DOP data can exist in multiple places of
            the tree. The path returned is the path stored inside this Python
            DopData object, since the Python object uses the path to look up the
            underlying data each time you call a method on it.

            Note that the path is only available for unfrozen objects. If you
            call this method on a frozen DopData object it raises
            hou.OperationFailed.


        """
        return _hou.DopData_path(self)

    def selectionPath(self) -> "std::string":
        r"""

        selectionPath(self) -> str

            For DopData objects returned from a hou.SceneViewer.selectDynamics
            function call, this will return the a string that contains both the
            path to the DOP Network that created the data, and the path within
            the DOP data tree which uniquely identifies this DopData. This
            string is specifically intended to be passed in the
            prior_selection_paths argument of the hou.SceneViewer selection
            methods.


        """
        return _hou.DopData_selectionPath(self)

    def __hash__(self) -> "int":
        return _hou.DopData___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.DopData___repr__(self)

    def dopNetNode(self) -> "HOM_Node *":
        r"""

        dopNetNode(self) -> hou.Node

            Return the DOP network node containing this DOP data.


        """
        return _hou.DopData_dopNetNode(self)

    def simulation(self) -> "HOM_DopSimulation *":
        r"""

        simulation(self) -> hou.DopSimulation

            Return the DOP simulation containing this DOP data. This method is a
            shortcut for self.dopNetNode().simulation().


        """
        return _hou.DopData_simulation(self)

    def creator(self) -> "HOM_Node *":
        r"""

        creator(self) -> hou.DopNode

            Return the DOP node that created this DOP data inside the DOP
            network.


        """
        return _hou.DopData_creator(self)

    def id(self) -> "std::string":
        r"""

        id(self) -> str

            Return the globally unique identifier (GUID) for this DOP data. This
            method is a shortcut for self.record(\"Basic\").field(\"uniqueid\").

            If you want an object's index, hou.DopObject.objid.

          > >>> obj = hou.node(\"/obj/AutoDopNetwork\").simulation().objects()[0]
          > >>> obj.id()
          > '0xD011E41C-0x000034AE-0x494C12E4-0x000018B9'
          > >>> obj.objid()
          > 0

        """
        return _hou.DopData_id(self)

    def dataType(self) -> "std::string":
        r"""

        dataType(self) -> str

            Return a string describing the type of data this object contains.

          > >>> obj = hou.node(\"/obj/AutoDopNetwork\").simulation().objects()[0]
          > >>> obj.dataType()
          > 'SIM_Object'

            See also hou.DopData.dataTypeObject.


        """
        return _hou.DopData_dataType(self)

    def recordTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        recordTypes(self) -> tuple of str

            Return a tuple of strings containing the record types stored inside
            this DOP data. Each DOP data contains records named Basic and
            Options, and some types of DOP data contain additional records.


        """
        return _hou.DopData_recordTypes(self)

    def record(
        self, record_type: "char const *", record_index: "int" = 0
    ) -> "HOM_DopRecord *":
        r"""

        record(self, record_type, record_index=0) -> hou.DopRecord

            Given a record type name return that record, or None if no record
            exists with that name. If this DOP data contains multiple records
            with this record type name you can think of each record as a row in
            a spreadsheet, and record_index determines which one is returned.
            Use len(self.records(record_type)) to determine how many records of
            this type are in this DOP data.

            Use hou.DopData.recordTypes to get a tuple of record types in a DOP
            data. See also hou.DopData.records for an example, and see
            hou.DopData.options for a way to easily access the Options record.


        """
        return _hou.DopData_record(self, record_type, record_index)

    def records(
        self, record_type: "char const *"
    ) -> "HOM_IterableList< HOM_DopRecord > *":
        r"""

        records(self, record_type) -> tuple of hou.DopRecord

            Return a tuple of all the records of this record type. See also
            hou.DopData.record.

            This example lists the input affectors for a rigid body box that
            collides with a ground plane:

          > >>> obj = hou.node(\"/obj/AutoDopNetwork\").simulation().objects()[-1]
          > >>> obj.records(\"RelInAffectors\")
          > (<hou.DopRecord of type RelInAffectors index 0>, <hou.DopRecord of type RelInAffectors index 1>)
          > >>> [record.field(\"relname\") for record in obj.records(\"RelInAffectors\")]
          > ['merge1', 'staticsolver1_staticsolver1']
          > >>> obj.record(\"RelInAffectors\", 1).field(\"relname\")
          > 'staticsolver1_staticsolver1'

        """
        return _hou.DopData_records(self, record_type)

    def options(self) -> "HOM_DopRecord *":
        r"""

        options(self) -> hou.DopRecord

            Return the Options record. This method is a shortcut for
            self.record(\"Options\").


        """
        return _hou.DopData_options(self)

    def subData(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_DopData >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_DopData > > > >":
        r"""

        subData(self) -> dict of str to hou.DopData

            Return a dictionary mapping names to DOP data instances for the
            subdata attached to this data.

          > # The following code assumes you have created a box from the shelf and used
          > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          > >>> obj = hou.node(\"/obj/AutoDopNetwork\").simulation().objects()[0]
          > >>> obj
          > <hou.DopObject box_object1 id 0>
          > >>> obj.recordTypes()
          > ('Basic', 'Options', 'RelInGroup', 'RelInAffectors')
          > >>> record = obj.record(\"Options\")
          > >>> record.fieldNames()
          > ('name', 'groups', 'affectors', 'affectorids', 'objid')
          > >>> record.field(\"name\")
          > 'box_object1'
          >
          > >>> obj.subData().keys()
          > ['PhysicalParms', 'ODE_Body', 'Solver', 'Geometry', 'SolverParms', 'ODE_Geometry', 'Forces', 'Position', 'Colliders']
          > >>> obj.findSubData(\"Forces/Gravity_gravity1\")
          > <hou.DopData of type SIM_ForceGravity>
          > >>> obj.findSubData(\"Forces/Gravity_gravity1\").options().field(\"force\")
          > <hou.Vector3 [0, -9.80665, 0]>

        """
        return _hou.DopData_subData(self)

    def findSubData(self, data_spec: "char const *") -> "HOM_DopData *":
        r"""

        findSubData(self, data_spec) -> hou.DopData or None

            Return the DOP data with the given name that is attached to this DOP
            data, or None if no such data exists. Note that the name may also be
            a slash-separated path to nested subdata.

            See hou.DopData.subData for an example.

            This method can be approximately implemented as follows:

          > def findSubData(self, data_spec):
          >     data = self
          >     for name in data_spec.split(\"/\"):
          >         if name not in data.subData():
          >             return None
          >         data = data.subData()[name]
          >     return data

        """
        return _hou.DopData_findSubData(self, data_spec)

    def findAllSubData(
        self, data_spec: "char const *", recurse: "bool" = False
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_DopData >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_DopData > > > >":
        r"""

        findAllSubData(self, data_spec, recurse=False) -> dict of str to
        hou.DopData

            Given a pattern, return a dictionary mapping subdata paths to DOP
            data instances for all the subdatas whose name matches the pattern.
            If recurse is True, all grandchildren subdata will be added to the
            result.

          > # The following code assumes you have created a box from the shelf and used
          > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          > >>> obj = hou.node(\"/obj/AutoDopNetwork\").simulation().objects()[0]
          > >>> obj.findAllSubData(\"S*\").keys()
          > ['SolverParms', 'Solver']
          > >>> obj.findAllSubData(\"S*\", recurse=True).keys()
          > ['SolverParms', 'Solver/Random', 'SolverParms/ActiveValue', 'Solver']
          > >>> obj.findAllSubData(\"S*/*\", recurse=True).keys()
          > ['SolverParms/ActiveValue', 'Solver/Random']

        """
        return _hou.DopData_findAllSubData(self, data_spec, recurse)

    def createSubData(self, *args, **kwargs) -> "HOM_DopData *":
        r"""

        createSubData(self, data_name, data_type=\"SIM_EmptyData\",
        avoid_name_collisions=False) -> hou.DopData

            Create subdata under this data with the specified name and type. You
            would call this method from a script solver DOP.


            data_name
                The name of the new data. Note that this name may contain
                slashes to create subdata on existing data.

            data_type
                Either the name of the data type to create or a hou.DopDataType
                instance. If you simply want something containing an empty
                options record, use SIM_EmptyData.

            avoid_name_collisions
                If True and data with the specified name exists, Houdini will
                create a unique name that does not conflict with any existing
                data.

            Raises hou.OperationFailed if data with this name already exists. If
            you want to replace existing data it is up to you to first call
            hou.DopData.removeData.

            Raises hou.PermissionError if called from outside a script solver
            DOP.

            Use hou.DopData.attachSubData to create a reference to existing
            data. See hou.DopData.copyContentsFrom for an example of how to
            create a copy of existing data.


        """
        return _hou.DopData_createSubData(self, *args, **kwargs)

    def attachSubData(
        self,
        hom_new_subdata: "DopData",
        new_data_name: "char const *",
        avoid_name_collisions: "bool" = False,
    ) -> "void":
        r"""

        attachSubData(self, data, new_data_name, avoid_name_collisions=False)

            Make existing data become subdata of this data. Houdini does not
            create a duplicate of the data. Instead, the data's parent(s) and
            this data will both refer to the same instance of subdata. You would
            call this method from a script solver DOP.


            data
                The DopData that will become subdata of this data.

            new_data_name
                The name of the new subdata.

            avoid_name_collisions
                If True and data with the specified name exists, Houdini will
                create a unique name that does not conflict with any existing
                data.

            Raises hou.OperationFailed if data with this name already exists. If
            you want to replace existing data it is up to you to first call
            hou.DopData.removeData.

            Raises hou.PermissionError if called from outside a script solver
            DOP.

            See hou.DopData.copyContentsFrom for an example of how to create a
            copy of existing data.


        """
        return _hou.DopData_attachSubData(
            self, hom_new_subdata, new_data_name, avoid_name_collisions
        )

    def removeSubData(self, data_spec: "char const *") -> "void":
        r"""

        removeSubData(self, data_spec)

            Remove subdata with the given name. Raises hou.PermissionError if
            called from outside a script solver DOP.

            Raises hou.OperationFailed if data with that name already exists.


        """
        return _hou.DopData_removeSubData(self, data_spec)

    def copyContentsFrom(self, hom_data: "DopData") -> "void":
        r"""

        copyContentsFrom(self, data)

            Copy the contents of the given DopData into this one, adapting the
            data if it is of a different type. You would call this method from a
            script solver DOP.

            Raises hou.PermissionError if called from outside a script solver
            DOP.

            Use this method along with hou.DopData.createSubData to copy
            existing subdata:

          > def copySubData(new_parent_data, data_to_copy, new_data_name, avoid_name_collisions=False):
          >     '''Create a copy of data and attach it to other data.'''
          >     new_data = new_parent_data.createSubData(new_data_name, data_to_copy.dataType(), avoid_name_collisions)
          >     new_data.copyContentsFrom(data_to_copy)
          >     return new_data

        """
        return _hou.DopData_copyContentsFrom(self, hom_data)

    def _asVoidPointer(self) -> "void *":
        return _hou.DopData__asVoidPointer(self)

    def fieldGeometry(self, data_name: "char const *") -> "HOM_Geometry *":
        return _hou.DopData_fieldGeometry(self, data_name)

    def geometry(self, data_name: "char const *" = None) -> "HOM_Geometry *":
        return _hou.DopData_geometry(self, data_name)

    def editableGeometry(
        self, data_name: "char const *" = None
    ) -> "HOM_EditableDopGeometryGuard *":
        return _hou.DopData_editableGeometry(self, data_name)


# Register DopData in _hou:
_hou.DopData_swigregister(DopData)


class ShelfElement(object):
    r"""

    hou.ShelfElement

    Superclass of shelf tools, shelf tabs, and shelf sets.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ShelfElement

    def __repr__(self) -> "std::string":
        return _hou.ShelfElement___repr__(self)

    def __eq__(self, element: "HOM_PtrOrNull< HOM_ShelfElement >") -> "bool":
        return _hou.ShelfElement___eq__(self, element)

    def __ne__(self, element: "HOM_PtrOrNull< HOM_ShelfElement >") -> "bool":
        return _hou.ShelfElement___ne__(self, element)

    def filePath(self) -> "std::string":
        r"""

        filePath(self) -> str

            Returns the file that contains the definition of this object.


        """
        return _hou.ShelfElement_filePath(self)

    def setFilePath(self, file_path: "char const *") -> "void":
        r"""

        setFilePath(self, file_path)

            Sets the path string for where this object's definition is stored.


        """
        return _hou.ShelfElement_setFilePath(self, file_path)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the internal name of this object.

            Multiple objects may have the same name (for example, two different
            assets might both provide a hammer tool), but only one will be
            active at a time in a Houdini session.


        """
        return _hou.ShelfElement_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Sets this object's internal name. This is how you refer to the
            object in scripts.

            The name has similar rules to naming Houdini nodes: it must not
            start with a number, and can only contain letters, numbers, an
            underscores.

            For example, if a Tool objects name is foo, you can get a reference
            to it using:

          > footool = shelves.tool(\"foo\")

        """
        return _hou.ShelfElement_setName(self, name)

    def label(self) -> "std::string":
        r"""

        label(self) -> str

            Returns the object's human-readable label.


        """
        return _hou.ShelfElement_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self, label)

            Sets the object's human-readable label. This is what's displayed in
            the UI.


        """
        return _hou.ShelfElement_setLabel(self, label)

    def fileLocation(self) -> "std::string":
        r"""

        fileLocation(self) -> str

            Returns the file location description in a human readable format.
            For example, it is a file path for disk files, and information about
            an HDA if the element is stored in an HDA tool section.


        """
        return _hou.ShelfElement_fileLocation(self)

    def isReadOnly(self) -> "bool":
        r"""

        isReadOnly(self) -> bool

            Returns True if the element is read-only (can't be edited).


        """
        return _hou.ShelfElement_isReadOnly(self)

    def setReadOnly(self, on: "bool") -> "void":
        r"""

        setReadOnly(self, on)

          > # Get a reference to a tool
          > t = hou.shelves.tool(\"geometry_sphere\")
          > # Prevent the tool from being modified
          > t.setReadOnly(True)
          > # Allow the tool to be modified
          > t.setReadOnly(False)

        """
        return _hou.ShelfElement_setReadOnly(self, on)


# Register ShelfElement in _hou:
_hou.ShelfElement_swigregister(ShelfElement)


class _logging_Sink(object):
    r"""

    hou.logging.Sink

    Represents a logging destination.

    This is an abstract base class for all logging sink classes. It provides
    the common methods for connecting and disconnecting sources to the sink.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__logging_Sink

    def __repr__(self) -> "std::string":
        return _hou._logging_Sink___repr__(self)

    def connectedSources(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        connectedSources() -> tuple of str

            Returns the names of sources connected to this sink.


        """
        return _hou._logging_Sink_connectedSources(self)

    def connect(self, source_name: "char const *") -> "void":
        r"""

        connect(source_name)

            Connect a source to this sink object. The source_name should be one
            of the values return by a call to hou.logging.sources.


        """
        return _hou._logging_Sink_connect(self, source_name)

    def disconnect(self, source_name: "char const *") -> "void":
        r"""

        disconnect(source_name)

            Disconnect a source from this sink object. The source_name should be
            one of the values returned by the connectedSources method.


        """
        return _hou._logging_Sink_disconnect(self, source_name)

    def setFilterCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        setFilterCallback(callback)

            Associates a callable object with this log sink which is called
            every time a log entry is generated by a source connected to this
            sink. The callback should take one argument, which is a
            hou.logging.LogEntry object. If this callback returns False, the log
            entry will not be stored or otherwise processed by this sink object.


        """
        return _hou._logging_Sink_setFilterCallback(self, callback)


# Register _logging_Sink in _hou:
_hou._logging_Sink_swigregister(_logging_Sink)


class Agent(PackedPrim):
    r"""

    hou.Agent

    An agent primitive.

    See Crowd Agents for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Agent

    def __repr__(self) -> "std::string":
        return _hou.Agent___repr__(self)

    def definition(self) -> "HOM_AgentDefinition *":
        r"""

        definition(self) -> hou.AgentDefinition

            Returns the shared agent definition.


        """
        return _hou.Agent_definition(self)

    def setDefinition(self, definition: "AgentDefinition") -> "void":
        r"""

        setDefinition(definition)

            Changes the agent's definition. If the new definition's rig has a
            different number of transforms, the agent's current transforms will
            be reset. The agent's current clips will be reset if the new
            definition does not contain clips with the same names.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            definition
                A hou.AgentDefinition.


        """
        return _hou.Agent_setDefinition(self, definition)

    def currentLayer(self) -> "HOM_AgentLayer *":
        r"""

        currentLayer(self) -> hou.AgentLayer

            This method is deprecated in favor of hou.Agent.currentLayers.

            Returns the current display layer of the agent. If there are
            multiple current display layers, only the first layer will be
            returned.


        """
        return _hou.Agent_currentLayer(self)

    def setCurrentLayer(self, layer: "AgentLayer") -> "void":
        r"""

        setCurrentLayer(layer)

            This method is deprecated in favor of hou.Agent.setCurrentLayers.

            Sets the agent's current display layer.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layer
                A hou.AgentLayer.


        """
        return _hou.Agent_setCurrentLayer(self, layer)

    def collisionLayer(self) -> "HOM_AgentLayer *":
        r"""

        collisionLayer(self) -> hou.AgentLayer

            This method is deprecated in favor of hou.Agent.collisionLayers.

            Returns the current collision layer of the agent. If there are
            multiple current collision layers, only the first layer will be
            returned.


        """
        return _hou.Agent_collisionLayer(self)

    def setCollisionLayer(self, layer: "AgentLayer") -> "void":
        r"""

        setCollisionLayer(layer)

            This method is deprecated in favor of hou.Agent.setCollisionLayers.

            Sets the agent's current collision layer.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layer
                A hou.AgentLayer.


        """
        return _hou.Agent_setCollisionLayer(self, layer)

    def currentLayers(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentLayer >,std::allocator< HOM_ElemPtr< HOM_AgentLayer > > >":
        r"""

        currentLayers(self) -> tuple of hou.AgentLayer

            Returns the agent's current display layers.


        """
        return _hou.Agent_currentLayers(self)

    def setCurrentLayers(self, layers: "_AgentLayerTuple") -> "void":
        r"""

        setCurrentLayers(layers)

            Sets the agent's current display layers.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layers
                A hou.AgentLayer sequence.


        """
        return _hou.Agent_setCurrentLayers(self, layers)

    def collisionLayers(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentLayer >,std::allocator< HOM_ElemPtr< HOM_AgentLayer > > >":
        r"""

        collisionLayers(self) -> tuple of hou.AgentLayer

            Returns the agent's current collision layers.


        """
        return _hou.Agent_collisionLayers(self)

    def setCollisionLayers(self, layers: "_AgentLayerTuple") -> "void":
        r"""

        setCollisionLayers(layers)

            Sets the agent's current collision layers.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layers
                A hou.AgentLayer sequence.


        """
        return _hou.Agent_setCollisionLayers(self, layers)

    def clips(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentClip >,std::allocator< HOM_ElemPtr< HOM_AgentClip > > >":
        r"""

        clips(self) -> tuple of hou.AgentClip

            Returns the agent's current animation clips.


        """
        return _hou.Agent_clips(self)

    def setClips(self, clips: "_AgentClipTuple") -> "void":
        r"""

        setClips(clips)

            Sets the agent's current animation clips.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            clips
                A hou.AgentClip sequence.


        """
        return _hou.Agent_setClips(self, clips)

    def clipTimes(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        clipWeights(self) -> tuple of float

            Returns the blend weights for the agent's animation clips.


        """
        return _hou.Agent_clipTimes(self)

    def setClipTimes(self, times: "_DoubleTuple") -> "void":
        r"""

        setClipTimes(times)

            Sets the current times for the agent's animation clips.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            times
                A float sequence.


        """
        return _hou.Agent_setClipTimes(self, times)

    def clipWeights(self) -> "std::vector< double,std::allocator< double > >":
        return _hou.Agent_clipWeights(self)

    def setClipWeights(self, weights: "_DoubleTuple") -> "void":
        r"""

        setClipWeights(weights)

            Sets the blend weights for the agent's animation clips.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            weights
                A float sequence.


        """
        return _hou.Agent_setClipWeights(self, weights)

    def localTransform(self, i: "int") -> "HOM_Matrix4 *":
        r"""

        localTransform(self, transform) -> hou.Matrix4

            Returns the current local space transform of an agent primitive's
            bone.


            transform
                Index of a transform in the agent's rig.


        """
        return _hou.Agent_localTransform(self, i)

    def setLocalTransform(self, xform: "Matrix4", i: "int") -> "void":
        r"""

        setLocalTransform(xform, index)

            Sets the current local space transform of an agent primitive's bone.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            xform
                A hou.Matrix4.

            index
                Index of a transform in the agent's rig.


        """
        return _hou.Agent_setLocalTransform(self, xform, i)

    def worldTransform(self, i: "int") -> "HOM_Matrix4 *":
        r"""

        worldTransform(self, transform) -> hou.Matrix4

            Returns the current world space transform of an agent primitive's
            bone.


            transform
                Index of a transform in the agent's rig.


        """
        return _hou.Agent_worldTransform(self, i)

    def setWorldTransform(self, xform: "Matrix4", i: "int") -> "void":
        r"""

        setWorldTransform(xform, index)

            Sets the current world space transform of an agent primitive's bone.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            xform
                A hou.Matrix4.

            index
                Index of a transform in the agent's rig.


        """
        return _hou.Agent_setWorldTransform(self, xform, i)

    def channelValue(self, i: "int") -> "double":
        r"""

        channelValue(self, channel_index) -> float

            Returns the current value of an agent primitive's channel.


            channel_index
                Index of a channel in the agent's rig.


        """
        return _hou.Agent_channelValue(self, i)

    def setChannelValue(self, value: "double", i: "int") -> "void":
        r"""

        setChannelValue(self, value, channel_index)

            Set the current value of an agent primitive's channel.


            value
                A float value for the channel.

            channel_index
                Index of a channel in the agent's rig.


        """
        return _hou.Agent_setChannelValue(self, value, i)


# Register Agent in _hou:
_hou.Agent_swigregister(Agent)


class AgentClip(object):
    r"""

    hou.AgentClip

    An agent's animation clip.

    See Crowd Animation Clips for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(clip, rig, name = \"\")

            Creates a copy of an existing agent clip. The source clip may
            reference a different rig - in this case, identity transforms will
            be filled in for any new joints in the rig.


            clip
                A hou.AgentClip to copy the clip from.

            rig
                The hou.AgentRig that the clip will be associated with. The rig
                is used, for example, when converting transforms from local
                space to world space.

            name
                A name for the new clip, such as walk. If this parameter is not
                specified, the source clip's name will be used.


        """
        _hou.AgentClip_swiginit(self, _hou.new_AgentClip(*args))

    __swig_destroy__ = _hou.delete_AgentClip

    def __eq__(self, clip: "HOM_PtrOrNull< HOM_AgentClip >") -> "bool":
        return _hou.AgentClip___eq__(self, clip)

    def __ne__(self, clip: "HOM_PtrOrNull< HOM_AgentClip >") -> "bool":
        return _hou.AgentClip___ne__(self, clip)

    def __hash__(self) -> "int":
        return _hou.AgentClip___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentClip___repr__(self)

    def freeze(self) -> "HOM_AgentClip *":
        r"""

        freeze(self) -> hou.AgentClip

            Creates a modifiable copy of the clip. The copy will not be marked
            as an external reference.


        """
        return _hou.AgentClip_freeze(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of the clip.


        """
        return _hou.AgentClip_name(self)

    def fileName(self, expanded: "bool" = False) -> "std::string":
        r"""

        fileName(self, expanded = False) -> str

            If the clip is an external reference, returns the path to the file
            on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
        return _hou.AgentClip_fileName(self, expanded)

    def isLoaded(self) -> "bool":
        r"""

        isLoaded(self) -> bool

            If the clip is an external reference, returns whether the clip's
            data has been loaded from disk.


        """
        return _hou.AgentClip_isLoaded(self)

    def loadFromFile(self) -> "void":
        r"""

        loadFromFile(self)

            Explicitly loads the clip's data from disk if it is an external
            reference that is delay loaded. Raises hou.OperationFailed if the
            file does not exist or otherwise cannot be loaded.

            Calling any methods that require access to the clip's data will also
            cause the clip to be loaded, but this method can be used to report
            errors immediately.


        """
        return _hou.AgentClip_loadFromFile(self)

    def length(self) -> "double":
        r"""

        length(self) -> float

            Returns the length (in seconds) of the clip.


        """
        return _hou.AgentClip_length(self)

    def startTime(self) -> "double":
        r"""

        startTime(self) -> float

            Returns the start time of the clip (in seconds).


        """
        return _hou.AgentClip_startTime(self)

    def sampleCount(self) -> "int":
        r"""

        sampleCount(self) -> int

            Returns the number of samples in the clip.


        """
        return _hou.AgentClip_sampleCount(self)

    def sampleRate(self) -> "double":
        r"""

        sampleRate(self) -> float

            Returns the sample rate of the clip.


        """
        return _hou.AgentClip_sampleRate(self)

    def addChannel(self, name: "char const *", samples: "_FloatTuple") -> "void":
        r"""

        addChannel(self, name, samples)

            Creates an additional channel in the clip. If a channel already
            exists with the same name, the previous samples will be overwritten.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            name
                The name of the channel.

            `samples
                A float sequence containing the channel's data. Raises
                hou.InvalidSize if the length does not match
                hou.AgentClip.sampleCount.


        """
        return _hou.AgentClip_addChannel(self, name, samples)

    def sampleLocal(self, time: "double", transform: "int") -> "HOM_Matrix4 *":
        r"""

        sampleLocal(self, time, transform) -> hou.Matrix4


            time
                The time (in seconds) to evaluate the clip at.

            transform
                Index of a transform in the agent's rig.

            Evaluates the clip at the given time and returns the local
            transform.


        """
        return _hou.AgentClip_sampleLocal(self, time, transform)

    def sampleWorld(self, time: "double", transform: "int") -> "HOM_Matrix4 *":
        r"""

        sampleWorld(self, time, transform) -> hou.Matrix4


            time
                The time (in seconds) to evaluate the clip at.

            transform
                Index of a transform in the agent's rig.

            Evaluates the clip at the given time and returns the world
            transform.


        """
        return _hou.AgentClip_sampleWorld(self, time, transform)

    def localTransforms(
        self, sample: "int"
    ) -> "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > >":
        r"""

        localTransforms(self, sample) -> tuple of hou.Matrix4

            Returns the local space transforms for the specified sample. The
            number of entries matches hou.AgentRig.transformCount.


            sample
                Index of a sample in the clip.


        """
        return _hou.AgentClip_localTransforms(self, sample)

    def worldTransforms(
        self, sample: "int"
    ) -> "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > >":
        r"""

        worldTransforms(self, sample) -> tuple of hou.Matrix4

            Returns the world space transforms for the specified sample. The
            number of entries matches hou.AgentRig.transformCount.


            sample
                Index of a sample in the clip.


        """
        return _hou.AgentClip_worldTransforms(self, sample)

    def setLocalTransforms(
        self,
        sample: "int",
        xforms: "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > > const &",
    ) -> "void":
        r"""

        setLocalTransforms(self, sample, xforms)

            Edits the local transforms for a sample in the clip.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            sample
                Index of a sample in the clip.

            xforms
                A sequence of hou.Matrix4, with a local space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
        return _hou.AgentClip_setLocalTransforms(self, sample, xforms)

    def sample(self, time: "double", channel: "char const *") -> "double":
        r"""

        sample(self, time, channel_name) -> float


            time
                The time (in seconds) to evaluate the clip at.

            channel_name
                Name of a channel in the clip. See hou.AgentClip.channelNames.

            Evaluates the clip at the given time and returns the value of the
            specified channel. For sampling the clip's transforms, use
            hou.AgentClip.sampleLocal or hou.AgentClip.sampleWorld.


        """
        return _hou.AgentClip_sample(self, time, channel)

    def channelNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        channelNames(self) -> tuple of str

            Returns the names of the additional (non-transform) channels in the
            clip. These channels can be sampled with hou.AgentClip.sample.


        """
        return _hou.AgentClip_channelNames(self)

    def data(self, binary: "bool", worldspace: "bool" = False) -> "HOM_BinaryString":
        r"""

        data(self, binary, worldspace = False) -> str for Python 2, bytes for
        Python 3

            Returns the clip data in ASCII or binary.

            The returned clip data is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            binary
                Specifies whether the clip data should be saved in ASCII (.clip)
                or binary (.bclip) format.

            worldspace
                Specifies whether the transform channels should be saved in
                local or world space.


        """
        return _hou.AgentClip_data(self, binary, worldspace)

    def extractLocomotion(
        self,
        cog_transform: "int",
        cog_lookat_transform: "int" = -1,
        convert_inplace: "bool" = True,
        project_on_dominant_axis: "bool" = False,
    ) -> "void":
        r"""

        extractLocomotion(self, cog_transform, cog_lookat_transform=-1,
        convert_inplace=True, project_on_dominant_axis=False)

            Converts the animation to in-place and records the locomotion
            transform in the __locomotion__:[srt][xyz] channels.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            cog_transform
                Index of a transform in the agent's rig that controls the
                locomotion of the character (i.e. has the translation that moves
                it forward in space).

            cog_lookat_transform
                Optional index of a transform in the agent's rig, which is used
                to extract an overall rotation using the vector from the
                cog_transform to this transform.

            convert_inplace
                Specifies whether to convert the animation to an in-place clip
                in addition to recording the locomotion transform.

            project_on_dominant_axis
                Projects the locomotion translation along the dominant axis of
                motion in the XZ plane. If the clip will be used as an in-place
                clip in the crowd solver, this can help to maintain hip swaying
                in the motion.


        """
        return _hou.AgentClip_extractLocomotion(
            self,
            cog_transform,
            cog_lookat_transform,
            convert_inplace,
            project_on_dominant_axis,
        )


# Register AgentClip in _hou:
_hou.AgentClip_swigregister(AgentClip)


class AgentDefinition(object):
    r"""

    hou.AgentDefinition

    The shared data for an agent primitive.

    An agent definition includes a rig, shape library, layers, and clips,
    and can be shared between agent primitives. See Agent Primitives for
    more information.

    Since an agent definition is shared between copies of an agent primitive
    (such as agents in an upstream SOP's geometry), the definition returned
    by hou.Agent.definition is read-only. The hou.AgentDefinition.freeze
    method can be used to create a modifiable copy of an agent definition.

    RELATED

      * hou.crowds.findAgentDefinitions


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, rig: "AgentRig", shapelib: "AgentShapeLibrary"):
        r"""

        __init__(rig, shapelib)

            Creates a new (and modifiable) agent definition.


            rig
                The hou.AgentRig that the definition should reference.

            shapelib
                The hou.AgentShapeLibrary that the definition should reference.


        """
        _hou.AgentDefinition_swiginit(self, _hou.new_AgentDefinition(rig, shapelib))

    __swig_destroy__ = _hou.delete_AgentDefinition

    def __eq__(self, defn: "HOM_PtrOrNull< HOM_AgentDefinition >") -> "bool":
        return _hou.AgentDefinition___eq__(self, defn)

    def __ne__(self, defn: "HOM_PtrOrNull< HOM_AgentDefinition >") -> "bool":
        return _hou.AgentDefinition___ne__(self, defn)

    def __hash__(self) -> "int":
        return _hou.AgentDefinition___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentDefinition___repr__(self)

    def freeze(
        self, new_shapelib: "AgentShapeLibrary" = None, new_rig: "AgentRig" = None
    ) -> "HOM_AgentDefinition *":
        r"""

        freeze(self, new_shapelib = None, new_rig = None) -> hou.AgentDefinition

            Creates a modifiable copy of the agent definition. Use
            hou.Agent.setDefinition to change one or more agents to use the new
            agent definition.


            new_shapelib
                If specified, the copied agent definition and its layers will
                reference the new shape library.

            new_rig
                If specified, the copied agent definition (and its clips,
                layers, and transform groups) will reference the new rig.


        """
        return _hou.AgentDefinition_freeze(self, new_shapelib, new_rig)

    def rig(self) -> "HOM_AgentRig *":
        r"""

        rig(self) -> hou.AgentRig

            Returns the agent definition's rig.


        """
        return _hou.AgentDefinition_rig(self)

    def shapeLibrary(self) -> "HOM_AgentShapeLibrary *":
        r"""

        shapeLibrary(self) -> hou.AgentShapeLibrary

            Returns the agent definition's shape library.


        """
        return _hou.AgentDefinition_shapeLibrary(self)

    def layers(self) -> "HOM_IterableList< HOM_AgentLayer > *":
        r"""

        layers(self) -> tuple of hou.AgentLayer

            Returns a list of the layers in the agent definition.


        """
        return _hou.AgentDefinition_layers(self)

    def findLayer(self, name: "char const *") -> "HOM_AgentLayer *":
        r"""

        findLayer(self, name) -> hou.AgentLayer

            Finds the layer with the specified name, or None if no such layer
            exists.


        """
        return _hou.AgentDefinition_findLayer(self, name)

    def clips(self) -> "HOM_IterableList< HOM_AgentClip > *":
        r"""

        clips(self) -> tuple of hou.AgentClip

            Returns a list of the clips in the agent definition.


        """
        return _hou.AgentDefinition_clips(self)

    def findClip(self, name: "char const *") -> "HOM_AgentClip *":
        r"""

        findClip(self, name) -> hou.AgentClip

            Finds the clip with the specified name, or None if no such clip
            exists.


        """
        return _hou.AgentDefinition_findClip(self, name)

    def transformGroups(self) -> "HOM_IterableList< HOM_AgentTransformGroup > *":
        r"""

        transformGroups(self) -> tuple of hou.AgentTransformGroup

            Returns a list of the transform groups in the agent definition.


        """
        return _hou.AgentDefinition_transformGroups(self)

    def findTransformGroup(self, name: "char const *") -> "HOM_AgentTransformGroup *":
        r"""

        findTransformGroup(self, name) -> hou.AgentTransformGroup

            Finds the transform group with the specified name, or None if no
            such group exists.


        """
        return _hou.AgentDefinition_findTransformGroup(self, name)

    def addClip(self, clip: "AgentClip") -> "void":
        r"""

        addClip(self, clip)

            Adds a clip to the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.

            Raises hou.OperationFailed if the clip is associated with a
            different rig.


            clip
                A hou.AgentClip.


        """
        return _hou.AgentDefinition_addClip(self, clip)

    def removeClip(self, name: "char const *") -> "void":
        r"""

        removeClip(self, name)

            Removes a clip from the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.


            name
                The name of the clip to remove.


        """
        return _hou.AgentDefinition_removeClip(self, name)

    def addLayer(self, layer: "AgentLayer") -> "void":
        r"""

        addLayer(self, layer)

            Adds a layer to the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.

            Raises hou.OperationFailed if the layer is associated with a
            different rig or shape library.


            layer
                A hou.AgentLayer.


        """
        return _hou.AgentDefinition_addLayer(self, layer)

    def removeLayer(self, name: "char const *") -> "void":
        r"""

        removeLayer(self, name)

            Removes a layer from the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.


            name
                The name of the layer to remove.


        """
        return _hou.AgentDefinition_removeLayer(self, name)

    def addTransformGroup(self, group: "AgentTransformGroup") -> "void":
        r"""

        addTransformGroup(self, group)

            Adds a transform group to the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.

            Raises hou.OperationFailed if the group is associated with a
            different rig.


            group
                A hou.AgentTransformGroup.


        """
        return _hou.AgentDefinition_addTransformGroup(self, group)

    def removeTransformGroup(self, name: "char const *") -> "void":
        r"""

        removeTransformGroup(self, name)

            Removes a transform group from the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.


            name
                The name of the transform group to remove.


        """
        return _hou.AgentDefinition_removeTransformGroup(self, name)

    def metadata(self) -> "HOM_AgentMetadata *":
        r"""

        setMetadata(self, metadata)

            Replaces the agent definition's metadata. Raises
            hou.GeometryPermissionError if the agent definition is not
            modifiable.


            metadata
                A hou.AgentMetadata.


        """
        return _hou.AgentDefinition_metadata(self)

    def setMetadata(self, metadata: "AgentMetadata") -> "void":
        return _hou.AgentDefinition_setMetadata(self, metadata)


# Register AgentDefinition in _hou:
_hou.AgentDefinition_swigregister(AgentDefinition)


class AgentLayer(object):
    r"""

    hou.AgentLayer

    An agent's layer.

    See Agent Layers for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(name, rig, shapelib, shape_bindings, source_layer = None)

            Creates a new agent layer with the specified shape bindings.


            name
                The name of the new layer.

            rig
                The hou.AgentRig that the layer will be associated with.

            shapelib
                The hou.AgentShapeLibrary that the layer will be associated
                with.

            shape_bindings
                A list of shape bindings to add to the layer.

            source_layer
                Specifies an optional hou.AgentLayer to copy shape bindings
                from.


        """
        _hou.AgentLayer_swiginit(self, _hou.new_AgentLayer(*args))

    __swig_destroy__ = _hou.delete_AgentLayer

    def __eq__(self, layer: "HOM_PtrOrNull< HOM_AgentLayer >") -> "bool":
        return _hou.AgentLayer___eq__(self, layer)

    def __ne__(self, layer: "HOM_PtrOrNull< HOM_AgentLayer >") -> "bool":
        return _hou.AgentLayer___ne__(self, layer)

    def __hash__(self) -> "int":
        return _hou.AgentLayer___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentLayer___repr__(self)

    def asJSON(self) -> "std::string":
        r"""

        asJSON(self) -> str

            Returns a string containing the JSON that represents the layer.


        """
        return _hou.AgentLayer_asJSON(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of the layer.


        """
        return _hou.AgentLayer_name(self)

    def fileName(self, expanded: "bool" = False) -> "std::string":
        r"""

        fileName(self, expanded = False) -> str

            If the layer is an external reference, returns the path to the file
            on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
        return _hou.AgentLayer_fileName(self, expanded)

    def bindings(
        self, *args
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentShapeBinding >,std::allocator< HOM_ElemPtr< HOM_AgentShapeBinding > > >":
        r"""

        bindings(self, transform = None) -> tuple of hou.AgentShapeBinding

            Returns the list of shape bindings in the layer.


            transform
                Index of a transform in the agent's rig. If specified, only the
                shape bindings attached to the specified transform will be
                returned.


        """
        return _hou.AgentLayer_bindings(self, *args)

    def staticBindings(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentShapeBinding >,std::allocator< HOM_ElemPtr< HOM_AgentShapeBinding > > >":
        r"""

        staticBindings(self) -> tuple of hou.AgentShapeBinding

            Returns the shape bindings in the layer which reference static
            shapes.


        """
        return _hou.AgentLayer_staticBindings(self)

    def deformingBindings(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentShapeBinding >,std::allocator< HOM_ElemPtr< HOM_AgentShapeBinding > > >":
        r"""

        deformingBindings(self) -> tuple of hou.AgentShapeBinding

            Returns the shape bindings in the layer which reference deforming
            shapes.


        """
        return _hou.AgentLayer_deformingBindings(self)


# Register AgentLayer in _hou:
_hou.AgentLayer_swigregister(AgentLayer)


class AgentMetadata(object):
    r"""

    hou.AgentMetadata

    Stores metadata in an agent definition.

    The metadata contains a dictionary mapping strings to values, and can be
    used to store additional custom data in the agent definition.

    RELATED

      * hou.AgentDefinition


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(data)

            Creates new metadata from the provided dictionary.


            data
                A dict mapping strings to values.


        """
        _hou.AgentMetadata_swiginit(self, _hou.new_AgentMetadata(*args))

    __swig_destroy__ = _hou.delete_AgentMetadata

    def __eq__(self, metadata: "HOM_PtrOrNull< HOM_AgentMetadata >") -> "bool":
        return _hou.AgentMetadata___eq__(self, metadata)

    def __ne__(self, metadata: "HOM_PtrOrNull< HOM_AgentMetadata >") -> "bool":
        return _hou.AgentMetadata___ne__(self, metadata)

    def __hash__(self) -> "int":
        return _hou.AgentMetadata___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentMetadata___repr__(self)

    def freeze(self) -> "HOM_AgentMetadata *":
        r"""

        freeze(self) -> hou.AgentMetadata

            Creates a modifiable copy of the metadata. The copy will not be
            marked as an external reference.


        """
        return _hou.AgentMetadata_freeze(self)

    def isReadOnly(self) -> "bool":
        r"""

        isReadOnly(self) -> bool

            Return a bool indicating whether the metadata is read-only.


        """
        return _hou.AgentMetadata_isReadOnly(self)

    def asJSON(self) -> "std::string":
        r"""

        asJSON(self) -> str

            Returns a string containing the JSON representation of the metadata.


        """
        return _hou.AgentMetadata_asJSON(self)

    def fileName(self, expanded: "bool" = False) -> "std::string":
        r"""

        fileName(self, expanded = False) -> str

            If the metadata is an external reference, returns the path to the
            file on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
        return _hou.AgentMetadata_fileName(self, expanded)

    def data(
        self,
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        data(self) -> dict of str to value

            Returns the metadata dictionary.


        """
        return _hou.AgentMetadata_data(self)

    def setData(
        self,
        data: "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > const &",
    ) -> "void":
        r"""

        setData(self, data)

            Replaces the metadata dictionary. Raises hou.GeometryPermissionError
            if the metadata is not modifiable.


            data
                A dict mapping strings to values.


        """
        return _hou.AgentMetadata_setData(self, data)


# Register AgentMetadata in _hou:
_hou.AgentMetadata_swigregister(AgentMetadata)


class AgentRig(object):
    r"""

    hou.AgentRig

    The rig of an agent primitive.

    See Crowd Agents for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(name, transform_names, hierarchy)

            Creates a new agent rig from the given transform hierarchy.


            name
                The name of the new rig.

            transform_names
                A sequence of transform names.

            hierarchy
                A sequence of int sequences that specifies, for each transform
                in transform_names, the indices of its children in
                transform_names. See hou.AgentRig.transformHierarchy.

            The following example shows how to create a simple rig where
            transforms b and c are children of transform a.

          > transforms = [\"a\", \"b\", \"c\"]
          > hierarchy = [ [1, 2], [], [] ]
          > rig = hou.AgentRig(\"my_rig\", transforms, hierarchy)

        """
        _hou.AgentRig_swiginit(self, _hou.new_AgentRig(*args))

    __swig_destroy__ = _hou.delete_AgentRig

    def __eq__(self, rig: "HOM_PtrOrNull< HOM_AgentRig >") -> "bool":
        return _hou.AgentRig___eq__(self, rig)

    def __ne__(self, rig: "HOM_PtrOrNull< HOM_AgentRig >") -> "bool":
        return _hou.AgentRig___ne__(self, rig)

    def __hash__(self) -> "int":
        return _hou.AgentRig___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentRig___repr__(self)

    def freeze(self) -> "HOM_AgentRig *":
        r"""

        freeze(self) -> hou.AgentRig

            Creates a modifiable copy of the rig. The copy will not be marked as
            an external reference.


        """
        return _hou.AgentRig_freeze(self)

    def asJSON(self) -> "std::string":
        r"""

        asJSON(self) -> str

            Returns a string containing the JSON that represents the rig.


        """
        return _hou.AgentRig_asJSON(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name or filename of the rig.


        """
        return _hou.AgentRig_name(self)

    def fileName(self, expanded: "bool" = False) -> "std::string":
        r"""

        fileName(self, expanded = False) -> str

            If the rig is an external reference, returns the path to the file on
            disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
        return _hou.AgentRig_fileName(self, expanded)

    def transformCount(self) -> "int":
        r"""

        transformCount(self) -> int

            Returns the number of transforms in the rig.


        """
        return _hou.AgentRig_transformCount(self)

    def transformName(self, i: "int") -> "std::string":
        r"""

        transformName(self, transform) -> str

            Returns the name of the specified transform.


            transform
                Index of a transform in the rig.


        """
        return _hou.AgentRig_transformName(self, i)

    def findTransform(self, transform_name: "std::string const &") -> "int":
        r"""

        findTransform(self, transform_name) -> int

            Returns the index of the transform with the given name, or -1 if the
            transform name is invalid.


            transform_name
                Name of a transform in the rig.


        """
        return _hou.AgentRig_findTransform(self, transform_name)

    def parentIndex(self, transform: "int") -> "int":
        r"""

        parentIndex(self, transform) -> int

            Returns the parent of the specified transform, or -1 if the
            transform is a root of the transform hierarchy.


            transform
                Index of a transform in the rig.


        """
        return _hou.AgentRig_parentIndex(self, transform)

    def childIndices(
        self, transform: "int"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        childIndices(self, transform) -> tuple of int

            Returns the children of the specified transform.


            transform
                Index of a transform in the rig.


        """
        return _hou.AgentRig_childIndices(self, transform)

    def setRestLocalTransforms(
        self, xforms: "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > > const &"
    ) -> "void":
        r"""

        setRestLocalTransforms(self, xforms)

            Sets the local space rest transforms for the rig.

            Raises hou.GeometryPermissionError if the rig is not modifiable.


            xforms
                A sequence of hou.Matrix4, with a local space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
        return _hou.AgentRig_setRestLocalTransforms(self, xforms)

    def restLocalTransform(self, i: "int") -> "HOM_Matrix4 *":
        r"""

        restLocalTransform(self, transform) -> hou.Matrix4

            Returns the local space rest transform for the specified index in
            the hierarchy.


            transform
                Index of a transform in the rig.


        """
        return _hou.AgentRig_restLocalTransform(self, i)

    def restWorldTransform(self, i: "int") -> "HOM_Matrix4 *":
        r"""

        restWorldTransform(self, transform) -> hou.Matrix4

            Returns the world space rest transform for the specified index in
            the hierarchy.


            transform
                Index of a transform in the rig.


        """
        return _hou.AgentRig_restWorldTransform(self, i)

    def channelCount(self) -> "int":
        r"""

        channelCount(self) -> int

            Returns the number of channels in the rig.


        """
        return _hou.AgentRig_channelCount(self)

    def channelName(self, i: "int") -> "std::string":
        r"""

        channelName(self, channel_index) -> str

            Returns the name of the specified channel.


            channel_index
                Index of a channel in the rig.


        """
        return _hou.AgentRig_channelName(self, i)

    def channelDefaultValue(self, i: "int") -> "double":
        r"""

        channelDefaultValue(self, channel_index) -> float

            Returns the default value of the specified channel.


            channel_index
                Index of a channel in the rig.


        """
        return _hou.AgentRig_channelDefaultValue(self, i)

    def channelTransform(self, i: "int") -> "int":
        r"""

        channelTransform(self, channel_index) -> int

            Returns the transform index that the specified channel is associated
            with, or -1.


            channel_index
                Index of a channel in the rig.


        """
        return _hou.AgentRig_channelTransform(self, i)

    def findChannel(self, channel_name: "std::string const &") -> "int":
        r"""

        findChannel(self, channel_name) -> int

            Returns the index of the channel with the given name, or -1 if the
            channel name is invalid.


            channel_name
                Name of a channel in the rig.


        """
        return _hou.AgentRig_findChannel(self, channel_name)

    def addChannel(
        self,
        name: "std::string const &",
        default_value: "double" = 0.0,
        transform: "int" = -1,
    ) -> "void":
        r"""

        addChannel(self, name, default_value=0.0, transform=-1)

            Adds a new channel to the rig. If a channel already exists with the
            same name, properties such as the default value will be overwritten.

            Raises hou.GeometryPermissionError if the rig is not modifiable.


            name
                The name of the channel.

            `default_value
                A float containing the channel's default value.

            `transform
                Optional index of a transform that the channel is associated
                with.


        """
        return _hou.AgentRig_addChannel(self, name, default_value, transform)


# Register AgentRig in _hou:
_hou.AgentRig_swigregister(AgentRig)


class AgentShape(object):
    r"""

    hou.AgentShape

    An agent's shape.

    See Crowd Agents for more information.

    RELATED

      * hou.AgentShapeBinding

      * hou.AgentShapeLibrary

      * hou.crowds.addBlendshapeInputs

      * hou.crowds.addInBetweenShapes

      * hou.crowds.setBlendshapeDeformerParms


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_AgentShape

    def __eq__(self, lib: "HOM_PtrOrNull< HOM_AgentShape >") -> "bool":
        return _hou.AgentShape___eq__(self, lib)

    def __ne__(self, lib: "HOM_PtrOrNull< HOM_AgentShape >") -> "bool":
        return _hou.AgentShape___ne__(self, lib)

    def __hash__(self) -> "int":
        return _hou.AgentShape___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentShape___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the shape's name, which is unique within a shape library.


        """
        return _hou.AgentShape_name(self)

    def uniqueId(self) -> "int":
        r"""

        uniqueId(self) -> int

            Returns the shape's globally unique id.


        """
        return _hou.AgentShape_uniqueId(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Returns the shape's geometry.


        """
        return _hou.AgentShape_geometry(self)

    def freeze(self) -> "HOM_AgentShape *":
        r"""

        freeze(self) -> hou.AgentShape

            Creates a new modifiable copy of the shape. Raises
            hou.GeometryPermissionError if the shape library is not modifiable.


        """
        return _hou.AgentShape_freeze(self)

    def setGeometry(self, geometry: "Geometry") -> "void":
        r"""

        setGeometry(self, geometry)

            Replaces the shape's geometry. Raises hou.GeometryPermissionError if
            the shape is not modifiable.


            geometry
                A hou.Geometry containing the shape's new geometry.


        """
        return _hou.AgentShape_setGeometry(self, geometry)


# Register AgentShape in _hou:
_hou.AgentShape_swigregister(AgentShape)


class AgentShapeBinding(object):
    r"""

    hou.AgentShapeBinding

    A shape binding in an agent's layer.

    A shape binding attaches a shape from the agent's shape library to a
    transform in the agent's rig. See Agent Layers for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(shape, deformer, bounds_scale = 1.0)

            Creates a new shape binding, where the shape is not attached to a
            transform in the agent's rig. This can be useful for deforming
            shapes, which are deformed based on their capture attributes and the
            agent's current pose.


            shape
                A shape in the agent's shape library.

            deformer
                Specifies the hou.AgentShapeDeformer that should be used to
                deform the shape. A value of None will produce a static shape
                binding.

            bounds_scale
                Scale factor for the shape's bounding box. This can be a single
                float (for a uniform scale) or a hou.Vector3.


        """
        _hou.AgentShapeBinding_swiginit(self, _hou.new_AgentShapeBinding(*args))

    __swig_destroy__ = _hou.delete_AgentShapeBinding

    def __eq__(self, binding: "HOM_PtrOrNull< HOM_AgentShapeBinding >") -> "bool":
        return _hou.AgentShapeBinding___eq__(self, binding)

    def __ne__(self, binding: "HOM_PtrOrNull< HOM_AgentShapeBinding >") -> "bool":
        return _hou.AgentShapeBinding___ne__(self, binding)

    def __hash__(self) -> "int":
        return _hou.AgentShapeBinding___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentShapeBinding___repr__(self)

    def shapeName(self) -> "std::string":
        r"""

        shapeName(self) -> str

            Returns the name of the shape. This is equivalent to shape().name().


        """
        return _hou.AgentShapeBinding_shapeName(self)

    def shapeId(self) -> "int":
        r"""

        shapeId(self) -> int

            Returns the unique id of the shape. This is equivalent to
            shape().uniqueId().


        """
        return _hou.AgentShapeBinding_shapeId(self)

    def transformId(self) -> "int":
        r"""

        transformId(self) -> int

            Returns the index of the transform in the agent's rig that the shape
            is attached to.


        """
        return _hou.AgentShapeBinding_transformId(self)

    def isDeforming(self) -> "bool":
        r"""

        isDeforming(self) -> bool

            Returns whether the shape is static or deforming.


        """
        return _hou.AgentShapeBinding_isDeforming(self)

    def boundsScale(self) -> "HOM_Vector3 *":
        r"""

        boundsScale(self) -> hou.Vector3

            Returns the scale factor for the shape's bounding box.


        """
        return _hou.AgentShapeBinding_boundsScale(self)

    def shape(self) -> "HOM_AgentShape *":
        r"""

        shape(self) -> hou.AgentShape

            Returns the referenced shape.


        """
        return _hou.AgentShapeBinding_shape(self)

    def deformer(self) -> "HOM_AgentShapeDeformer *":
        r"""

        deformer(self) -> hou.AgentShapeDeformer

            Returns the deformer used for the shape, or None if the shape
            binding is static.


        """
        return _hou.AgentShapeBinding_deformer(self)


# Register AgentShapeBinding in _hou:
_hou.AgentShapeBinding_swigregister(AgentShapeBinding)


class AgentShapeDeformer(object):
    r"""

    hou.AgentShapeDeformer

    A deformer for agent shapes.

    Agent shape deformers are used to provide different deformation methods
    for shapes, such as linear skinning or dual quaternion skinning. Each
    shape binding can specify the deformer that should be used. The
    hou.crowds.shapeDeformers method provides a list of the available
    deformers.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(name)

            Creates a new deformer instance from the specified unique name.
            Raises hou.OperationFailed if there is not a registered deformer
            with this name.

            When using the built-in shape deformers, it is preferable to use the
            constructor that accepts a hou.agentShapeDeformerType. However, this
            constructor can be used with custom shape deformers that were
            registered via the HDK.

            hou.crowds.shapeDeformers provides a list of the registered
            deformers.


            name
                The unique name of the deformer (e.g. linearskinning).


        """
        _hou.AgentShapeDeformer_swiginit(self, _hou.new_AgentShapeDeformer(*args))

    __swig_destroy__ = _hou.delete_AgentShapeDeformer

    def __eq__(self, deformer: "HOM_PtrOrNull< HOM_AgentShapeDeformer >") -> "bool":
        return _hou.AgentShapeDeformer___eq__(self, deformer)

    def __ne__(self, deformer: "HOM_PtrOrNull< HOM_AgentShapeDeformer >") -> "bool":
        return _hou.AgentShapeDeformer___ne__(self, deformer)

    def __hash__(self) -> "int":
        return _hou.AgentShapeDeformer___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentShapeDeformer___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the unique name for the deformer.


        """
        return _hou.AgentShapeDeformer_name(self)


# Register AgentShapeDeformer in _hou:
_hou.AgentShapeDeformer_swigregister(AgentShapeDeformer)


class AgentShapeLibrary(object):
    r"""

    hou.AgentShapeLibrary

    The shape library of an agent primitive.

    See Crowd Agents for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(filename, keep_external_ref = True)

            Creates a new agent shape library by loading it from the specified
            geometry file.

            Raises hou.OperationFailed if the file does not exist or otherwise
            cannot be loaded.


            filename
                A path to a geometry file.

            keep_external_ref
                A bool indicating whether the external reference should be
                maintained when the agent is saved to a geometry file. If the
                reference is maintained, then the shape library file needs to be
                available when the saved geometry is used (only the path to the
                shape library is saved in the geometry file). Otherwise, a copy
                of the shape library will be inlined when saving out the
                geometry so that the original shape library file is no longer
                needed.


        """
        _hou.AgentShapeLibrary_swiginit(self, _hou.new_AgentShapeLibrary(*args))

    __swig_destroy__ = _hou.delete_AgentShapeLibrary

    def __eq__(self, lib: "HOM_PtrOrNull< HOM_AgentShapeLibrary >") -> "bool":
        return _hou.AgentShapeLibrary___eq__(self, lib)

    def __ne__(self, lib: "HOM_PtrOrNull< HOM_AgentShapeLibrary >") -> "bool":
        return _hou.AgentShapeLibrary___ne__(self, lib)

    def __hash__(self) -> "int":
        return _hou.AgentShapeLibrary___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentShapeLibrary___repr__(self)

    def freeze(self, keep_external_ref: "bool" = False) -> "HOM_AgentShapeLibrary *":
        r"""

        freeze(self, keep_external_ref = False) -> hou.AgentShapeLibrary

            Creates a modifiable copy of the shape library.


            keep_external_ref
                If the original shape library referenced a file on disk,
                specifies whether the new shape library should be marked as
                including the original library. In this situation, saving out
                the new shape library will only write out shapes that were not
                included from the original library, along with the path to the
                included shape library. Otherwise, saving out the new shape
                library will produce a standalone library containing all of the
                shapes.


        """
        return _hou.AgentShapeLibrary_freeze(self, keep_external_ref)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name or filename of the shape library.


        """
        return _hou.AgentShapeLibrary_name(self)

    def fileName(self, expanded: "bool" = False) -> "std::string":
        r"""

        fileName(self, expanded = False) -> str

            If the shape library is an external reference, returns the path to
            the file on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
        return _hou.AgentShapeLibrary_fileName(self, expanded)

    def findShape(self, name: "std::string const &") -> "HOM_AgentShape *":
        r"""

        findShape(self, shape_name) -> hou.AgentShape

            Finds the shape with the specified name, or None if no such shape
            exists.


        """
        return _hou.AgentShapeLibrary_findShape(self, name)

    def shapes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentShape >,std::allocator< HOM_ElemPtr< HOM_AgentShape > > >":
        r"""

        shapes(self) -> tuple of hou.AgentShape

            Returns a list of all shapes in the shape library.


        """
        return _hou.AgentShapeLibrary_shapes(self)

    def data(self) -> "HOM_Geometry *":
        r"""

        data(self) -> hou.Geometry

            Returns the geometry representation of the shape library, which can
            be saved to disk.


        """
        return _hou.AgentShapeLibrary_data(self)

    def addShape(
        self, name: "std::string const &", geometry: "Geometry"
    ) -> "HOM_AgentShape *":
        r"""

        addShape(self, name, geometry) -> hou.AgentShape

            Adds a new shape to the shape library.

            Raises hou.GeometryPermissionError if the shape library is not
            modifiable.


            name
                The name for the new shape.

            geometry
                A hou.Geometry containing the shape's geometry.


        """
        return _hou.AgentShapeLibrary_addShape(self, name, geometry)


# Register AgentShapeLibrary in _hou:
_hou.AgentShapeLibrary_swigregister(AgentShapeLibrary)


class AgentTransformGroup(object):
    r"""

    hou.AgentTransformGroup

    A group of transforms and channels in an agent's rig.

    See Crowd Agents for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(name, transforms, rig, weights, channels)

            Creates a new transform group containing the specified transforms
            and channels.


            name
                The name of the new transform group.

            transforms
                An int sequence containing the index of each transform in the
                group.

            rig
                The hou.AgentRig that the group will be associated with.

            weights
                A float sequence specifying the weight (between 0 and 1) of each
                transform in the group.

            channels
                An int sequence containing the index of each channel in the
                group.


        """
        _hou.AgentTransformGroup_swiginit(self, _hou.new_AgentTransformGroup(*args))

    __swig_destroy__ = _hou.delete_AgentTransformGroup

    def __eq__(self, group: "HOM_PtrOrNull< HOM_AgentTransformGroup >") -> "bool":
        return _hou.AgentTransformGroup___eq__(self, group)

    def __ne__(self, group: "HOM_PtrOrNull< HOM_AgentTransformGroup >") -> "bool":
        return _hou.AgentTransformGroup___ne__(self, group)

    def __hash__(self) -> "int":
        return _hou.AgentTransformGroup___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AgentTransformGroup___repr__(self)

    def asJSON(self) -> "std::string":
        r"""

        asJSON(self) -> str

            Returns a string containing the JSON representation of the group.


        """
        return _hou.AgentTransformGroup_asJSON(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of the transform group.


        """
        return _hou.AgentTransformGroup_name(self)

    def fileName(self, expanded: "bool" = False) -> "std::string":
        r"""

        fileName(self, expanded = False) -> str

            If the transform group is an external reference, returns the path to
            the file on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
        return _hou.AgentTransformGroup_fileName(self, expanded)

    def transformIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        transformIndices(self) -> tuple of int

            Returns a list containing the index of each transform in the group.


        """
        return _hou.AgentTransformGroup_transformIndices(self)

    def weights(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        weights(self) -> tuple of float

            Returns a list containing the weight of each transform in the group.


        """
        return _hou.AgentTransformGroup_weights(self)

    def channelIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        channelIndices(self) -> tuple of int

            Returns a list containing the index of each channel in the group.


        """
        return _hou.AgentTransformGroup_channelIndices(self)


# Register AgentTransformGroup in _hou:
_hou.AgentTransformGroup_swigregister(AgentTransformGroup)


class anonstats(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_anonstats

    def __repr__(self) -> "std::string":
        return _hou.anonstats___repr__(self)

    def recordOccurrence(self, key: "char const *") -> "void":
        return _hou.anonstats_recordOccurrence(self, key)

    def recordString(self, key: "char const *", value: "char const *") -> "void":
        return _hou.anonstats_recordString(self, key, value)

    def hasString(self, key: "char const *") -> "bool":
        return _hou.anonstats_hasString(self, key)

    def getString(self, key: "char const *") -> "std::string":
        return _hou.anonstats_getString(self, key)

    def incrementCount(self, key: "char const *", count: "int" = 1) -> "void":
        return _hou.anonstats_incrementCount(self, key, count)

    def logEvent(self, key: "char const *", message: "char const *") -> "void":
        return _hou.anonstats_logEvent(self, key, message)

    def addSum(
        self, key: "char const *", stat_value: "double const", count: "int" = 1
    ) -> "void":
        return _hou.anonstats_addSum(self, key, stat_value, count)


# Register anonstats in _hou:
_hou.anonstats_swigregister(anonstats)


class AssetBrowser(PathBasedPaneTab):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_AssetBrowser

    def __repr__(self) -> "std::string":
        return _hou.AssetBrowser___repr__(self)

    def reload(self) -> "void":
        return _hou.AssetBrowser_reload(self)

    def installRequiredDefinitionsForNodeTypeName(
        self, node_type_name: "char const *"
    ) -> "void":
        return _hou.AssetBrowser_installRequiredDefinitionsForNodeTypeName(
            self, node_type_name
        )

    def storeUpdateSessionKey(self, session_key: "char const *") -> "void":
        return _hou.AssetBrowser_storeUpdateSessionKey(self, session_key)

    def updateAssetDownloadFraction(
        self,
        node_type_name: "char const *",
        downloaded_bytes: "int",
        total_bytes: "int",
    ) -> "void":
        return _hou.AssetBrowser_updateAssetDownloadFraction(
            self, node_type_name, downloaded_bytes, total_bytes
        )

    def storeSyncSessionKey(self, session_key: "char const *") -> "void":
        return _hou.AssetBrowser_storeSyncSessionKey(self, session_key)


# Register AssetBrowser in _hou:
_hou.AssetBrowser_swigregister(AssetBrowser)


class AssetGalleryDataSource(object):
    r"""

    hou.AssetGalleryDataSource

    Provides an interface to any data source that can be used in association
    with an asset or snapshot gallery UI.

    Houdini's various asset gallery panels (the snapshot gallery attached to
    the LOP Scene Viewer, the Working Set gallery in the Layout LOP's brush
    panel, and the Asset Gallery pane) are all populated by pulling data
    from this class. This object is created by providing a source
    identifier, and an optional additional string argument. The source
    identifier is used to find or create a shared underlying data source
    implementation object (which may be a C++ or python object). These
    implementation objects are responsible for responding to the methods
    called on this object.

    Houdini shipds with three data source implementations. One uses an SQL
    database with read and write capabilities. This data source
    implementation type is used when the source identifier is a file path
    with a .db, .sqlite, or .sqlite3 extension. Another supports any file on
    disk with a USD file extension. This data source is read only, and
    accepts an additional argument specifying the primitive pattern
    indicating which primitives in the USD file should be presented as
    assets. Finally, if the source identifier beings with an op: prefix
    followed by a path to a LOP node, the stage for that LOP node is used as
    a read only data source, and again the additional argument specifies a
    primitive pattern to indicate which primitives on the source stage
    represent assets.

    To create a new data source implementation in C++, you must create a
    subclass of UT_GalleryDataSourceImpl (see UT_GalleryDataSource.h), and
    register it by calling
    UT_GalleryDataSource::registerDataSourceImplementation. To create a new
    data source implementation in python, create a subclass of the
    DataSource object defined in the husd.datasource module, and place it in
    the $HFS/houdini/husdplugins/datasources directory. See the usdfile.py
    module for an example.

    The methods on this class almost always simply forward the call to the
    underlying data source implementation object. So the decription of each
    method here also serves to document the action an that should be
    undertaken in each correspondingly named method on an implementation
    class.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, source_identifier: "char const *", args: "char const *" = None):
        r"""

        __init__(self, source_identifier, args=None) -> AssetGalleryDataSource

            Constructs or finds a matching existing data source implementation
            object based on the source_identifier and optional implementation-
            specific args parameter.


        """
        _hou.AssetGalleryDataSource_swiginit(
            self, _hou.new_AssetGalleryDataSource(source_identifier, args)
        )

    __swig_destroy__ = _hou.delete_AssetGalleryDataSource

    def __hash__(self) -> "int":
        return _hou.AssetGalleryDataSource___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.AssetGalleryDataSource___repr__(self)

    def isValid(self) -> "bool":
        r"""

        isValid(self) -> bool

            Return True if this data source has a valid implementation,
            otherwise return False. Returning False usually indicates that the
            source identifier does not represent an existing file or LOP node,
            or that the file type is not supported by any data source
            implementation classes.


        """
        return _hou.AssetGalleryDataSource_isValid(self)

    def isReadOnly(self) -> "bool":
        r"""

        isReadOnly(self) -> bool

            Return True if this data source only supports read operations,
            otherwise return False. A data source implementation that returns
            False for this method will never have any of its set methods called,
            and any attempts to call these methods on this object will
            immediately return False.


        """
        return _hou.AssetGalleryDataSource_isReadOnly(self)

    def sourceIdentifier(self) -> "std::string":
        r"""

        sourceIdentifier(self) -> str

            Return the source identifier string used to create this data source
            object.


        """
        return _hou.AssetGalleryDataSource_sourceIdentifier(self)

    def sourceArgs(self) -> "std::string":
        r"""

        sourceArgs(self) -> str

            Return the args string used to create this data source object.


        """
        return _hou.AssetGalleryDataSource_sourceArgs(self)

    def startTransaction(self) -> "void":
        r"""

        startTransaction(self)

            For writable data sources, this method can be used to group multiple
            calls to edit the data source. Once this method is called, requests
            to edit the data source do not actually need to edit the underlying
            data source until the endTransaction method is called.


        """
        return _hou.AssetGalleryDataSource_startTransaction(self)

    def endTransaction(self, commit: "bool" = True) -> "void":
        r"""

        endTransaction(self, commit=True)

            This method is always called after a call to startTransaction, and
            indicates that the group of data source edits has been completed.
            When this method returns, all edits since the call to
            startTransaction should be committed to the data source. If the
            commit parameter is False, all edits since the call to
            startTransaction should be discarded, and none of them should be
            recorded to the data source.


        """
        return _hou.AssetGalleryDataSource_endTransaction(self, commit)

    def getItemIds(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        getItemIds(self) -> tuple of str

            Return a unique identifier for each asset available in the data
            source. The ids returned by this method will be used to identify
            individual assets in every other method that gets or sets
            information associated with a specific asset.


        """
        return _hou.AssetGalleryDataSource_getItemIds(self)

    def sourceTypeName(self, item_id: "char const *" = None) -> "std::string":
        r"""

        sourceTypeName(self, item_id=None) -> str

            Return the data source type of the asset identied by the id.
            Generally all the assets from a data source will return the same
            sourceTypeName, which is why the item_id parameter here is optional.
            Only data sources that aggregate data from multiple other sources
            would return per-asset values from this method.


        """
        return _hou.AssetGalleryDataSource_sourceTypeName(self, item_id)

    def typeName(self, item_id: "char const *") -> "std::string":
        r"""

        typeName(self, item_id) -> str

            Return the type of asset identied by the id. This will either be
            snapshot (for a snapshot in a snapshot gallery) or asset (for an
            asset in an asset gallery).


        """
        return _hou.AssetGalleryDataSource_typeName(self, item_id)

    def label(self, item_id: "char const *") -> "std::string":
        r"""

        label(self, item_id) -> str

            Return the user-facing string that identifies and describes the
            item. This value need not be unique, and is normally displayed under
            the item's thumbnail image.


        """
        return _hou.AssetGalleryDataSource_label(self, item_id)

    def thumbnail(self, item_id: "char const *") -> "HOM_BinaryString":
        r"""

        thumbnail(self, item_id) -> bytes

            Return the raw data for a thumbnail image that represents the item.


        """
        return _hou.AssetGalleryDataSource_thumbnail(self, item_id)

    def creationDate(self, item_id: "char const *") -> "int64":
        r"""

        creationDate(self, item_id) -> int

            Return a long integer representing the unix timestamp at which the
            item was created.


        """
        return _hou.AssetGalleryDataSource_creationDate(self, item_id)

    def modificationDate(self, item_id: "char const *") -> "int64":
        r"""

        modificationDate(self, item_id) -> int

            Return a long integer representing the unix timestamp at which the
            item was last modified.


        """
        return _hou.AssetGalleryDataSource_modificationDate(self, item_id)

    def isStarred(self, item_id: "char const *") -> "bool":
        r"""

        isStarred(self, item_id) -> bool

            Return True if this item has been marked as a favorite by the user.


        """
        return _hou.AssetGalleryDataSource_isStarred(self, item_id)

    def colorTag(self, item_id: "char const *") -> "std::string":
        r"""

        colorTag(self, item_id) -> str

            Return a string indicating a special color tag value that has been
            assigned by the user. These color strings are displayed as colored
            bars in the gallery browser UI. Supported values are blue, green,
            purple, yellow, teal, and red.


        """
        return _hou.AssetGalleryDataSource_colorTag(self, item_id)

    def tags(
        self, item_id: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        tags(self, item_id) -> tuple of str

            Return a tuple of user defined tag strings that have been assigned
            to this item.


        """
        return _hou.AssetGalleryDataSource_tags(self, item_id)

    def filePath(self, item_id: "char const *") -> "std::string":
        r"""

        filePath(self, item_id) -> str

            Return a string that can be used to access the raw data assocaited
            with this item. In the case of a snapshot, this will be path to the
            snapshot image file on disk. In the case of an asset, this will be
            the path to a USD file on disk or a string representing a path to
            the LOP node which defines this asset.


        """
        return _hou.AssetGalleryDataSource_filePath(self, item_id)

    def ownsFile(self, item_id: "char const *") -> "bool":
        r"""

        ownsFile(self, item_id) -> bool

            Return True if the filePath for this item is a file on disk that
            should be deleted if the item is deleted. This is generally True for
            a snapshot image, but False for a USD asset file (though in a custom
            data source implementation, it may also be True for a USD asset).


        """
        return _hou.AssetGalleryDataSource_ownsFile(self, item_id)

    def blindData(self, item_id: "char const *") -> "HOM_BinaryString":
        r"""

        blindData(self, item_id) -> bytes

            Return a block of data source implementation specific binary data
            associated with the item. For a snapshot item, this will be the
            binary representation of the contents of the LOP Network when the
            snapshot was taken. For a USD asset, this may be a string
            representing information needed to pull a specific primitive out of
            a USD file (such as the root primitive path and variant selections).
            This blind data on an asset can be used by the data source specific
            code for instantiating an asset in a LOP network.


        """
        return _hou.AssetGalleryDataSource_blindData(self, item_id)

    def setLabel(self, item_id: "char const *", label: "char const *") -> "bool":
        r"""

        setLabel(self, item_id, label) -> bool

            Set the value of the label for this item. Return True if this call
            resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setLabel(self, item_id, label)

    def setThumbnail(
        self, item_id: "char const *", thumbnail: "HOM_BinaryString"
    ) -> "bool":
        r"""

        setThumbnail(self, item_id, thumbnail) -> bool

            Set the value of the thumbnail for this item. Return True if this
            call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setThumbnail(self, item_id, thumbnail)

    def setModificationDate(
        self, item_id: "char const *", timestamp: "int64"
    ) -> "bool":
        r"""

        setModificationDate(self, item_id, timestamp) -> bool

            Set the value of the modificationDate for this item. Return True if
            this call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setModificationDate(self, item_id, timestamp)

    def setIsStarred(self, item_id: "char const *", isstarred: "bool") -> "bool":
        r"""

        setIsStarred(self, item_id, isstarred) -> bool

            Set the value of the isStarred flag for this item. Return True if
            this call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setIsStarred(self, item_id, isstarred)

    def setColorTag(self, item_id: "char const *", color_tag: "char const *") -> "bool":
        r"""

        setColorTag(self, item_id, color_tag) -> bool

            Set the value of the colorTag for this item. Return True if this
            call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setColorTag(self, item_id, color_tag)

    def setMetadata(
        self,
        item_id: "char const *",
        metadata: "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > const &",
    ) -> "bool":
        r"""

        setMetadata(self, item_id, metadata) -> bool

            Set the value of the metadata dictionary for this item. Return True
            if this call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setMetadata(self, item_id, metadata)

    def setFilePath(self, item_id: "char const *", file_path: "char const *") -> "bool":
        r"""

        setFilePath(self, item_id, file_path) -> bool

            Set the value of the filePath for this item. Return True if this
            call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setFilePath(self, item_id, file_path)

    def setOwnsFile(self, item_id: "char const *", owns_file: "bool") -> "bool":
        r"""

        setOwnsFile(self, item_id, owns_file) -> bool

            Set the value of the ownsFile flag for this item. Return True if
            this call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setOwnsFile(self, item_id, owns_file)

    def setBlindData(self, item_id: "char const *", data: "HOM_BinaryString") -> "bool":
        r"""

        setBlindData(self, item_id, data) -> bool

            Set the value of the blindData for this item. Return True if this
            call resulted in a change to this value.


        """
        return _hou.AssetGalleryDataSource_setBlindData(self, item_id, data)

    def createTag(self, tag: "char const *") -> "bool":
        r"""

        createTag(self, tag) -> bool

            Create a tag in the data source, but do not assign it to any items.
            Return True if the tag did not already exist and was created.


        """
        return _hou.AssetGalleryDataSource_createTag(self, tag)

    def deleteTag(self, tag: "char const *", delete_if_assigned: "bool") -> "bool":
        r"""

        deleteTag(self, tag, delete_if_assigned) -> bool

            Delete a tag from the data source. Return True if the tag existed
            and was removed. If delete_if_assigned is False, and the tag is
            assigned to any item, this function will do nothing and return
            False. If delete_if_assigned is True and the tag is assigned to any
            items, the tag is first unassigned from those items, then the tag is
            deleted.


        """
        return _hou.AssetGalleryDataSource_deleteTag(self, tag, delete_if_assigned)

    def addTag(self, item_id: "char const *", tag: "char const *") -> "bool":
        r"""

        addTag(self, item_id, tag) -> bool

            Adds a tag to a specific item. Creates the tag if it does not
            already exist. Return True if the tag was added to the item. Return
            False if the tag was already assigned to the item.


        """
        return _hou.AssetGalleryDataSource_addTag(self, item_id, tag)

    def removeTag(self, item_id: "char const *", tag: "char const *") -> "bool":
        r"""

        removeTag(self, item_id, tag) -> bool

            Removes a tag from a specific item. Return True if the tag was
            removed from the item. Return False if the tag was not assigned to
            the item.


        """
        return _hou.AssetGalleryDataSource_removeTag(self, item_id, tag)

    def generateItemFilePath(
        self, item_id: "char const *", file_ext: "char const *"
    ) -> "std::string":
        r"""

        generateItemFilePath(self, item_id, file_ext) -> str

            Return a unique file path with an extension provided in file_ext.
            This helpful is useful for creating external files such as snapshot
            images on disk, as it automatically puts the image in the same
            location as the database file.


        """
        return _hou.AssetGalleryDataSource_generateItemFilePath(self, item_id, file_ext)

    def addItem(self, *args) -> "std::string":
        r"""

        addItem(self, label, file_path=None, thumbnail=b'', type_name='asset',
        blind_data=b'', creation_date=0) -> str

            Adds a new item to the data source. Sets the label, filePath,
            thumbnail, typeName, blindData, and creationDate values for the
            item. Return the item_id of the newly created item, or an empty
            string if the item could not be added.


        """
        return _hou.AssetGalleryDataSource_addItem(self, *args)

    def markItemsForDeletion(self, item_ids: "_StringTuple") -> "bool":
        r"""

        markItemsForDeletion(self, item_ids) -> bool

            Marks one or more items to be deleted. Ideally this deletion does
            not happen until the data source is destroyed, indicating that the
            user has switched data sources or shut down Houdini. By only marking
            the item for future deletion instead of deleting the items, it is
            possible to undo the deletion using the unmarkItemsForDeletion
            method. But while an item is marked for deletion, it should not be
            returned by the getItemIds method, or return any values when queried
            by other methods. Return True if the items were successfully marked
            for deletion. If a data source cannot support undoing the deletion
            of an item, this method should delete the item and return True.


        """
        return _hou.AssetGalleryDataSource_markItemsForDeletion(self, item_ids)

    def unmarkItemsForDeletion(self, item_ids: "_StringTuple") -> "bool":
        r"""

        unmarkItemsForDeletion(self, item_ids) -> bool

            Remove the indicator in the data source that the supplied items
            should be deleted. This is used to undo the requested deletion of an
            item. Return True if the specified items were successfully
            undeleted. If a data source doesn't support undoing the deletion of
            an item, return False.


        """
        return _hou.AssetGalleryDataSource_unmarkItemsForDeletion(self, item_ids)

    def saveAs(self, source_identifier: "char const *") -> "bool":
        r"""

        saveAs(self, source_identifier) -> bool

            Create a copy of the data source, if supported. This will also
            create copies of the item files, if the ownsFile flag is True.


        """
        return _hou.AssetGalleryDataSource_saveAs(self, source_identifier)

    def _asVoidPointer(self) -> "void *":
        return _hou.AssetGalleryDataSource__asVoidPointer(self)

    def metadata(self, item_id: "char const *") -> "InterpreterObject":
        r"""

        metadata(self, item_id) -> dict of str to str or float

            Return a dictionary of metadata that has been associated with this
            item. This metadata may be user created, or automatically (such as
            by a renderer used to create an image in the snapshot gallery).


        """
        return _hou.AssetGalleryDataSource_metadata(self, item_id)


# Register AssetGalleryDataSource in _hou:
_hou.AssetGalleryDataSource_swigregister(AssetGalleryDataSource)


class Attrib(object):
    r"""

    hou.Attrib

    This class stores information about a Geometry attribute.

    An attribute describes extra data you can attach to different elements
    of geometry. The attribute values are the individual instances of that
    data, and for each attribute there is exactly one attribute value per
    geometry element. For example, if you look at the points in Houdini's
    geometry spreadsheet, the point numbers are listed down the side, the
    point attributes are listed across the top, and the point attribute
    values are contained in the table.

    The attribute specifies which elements store the attribute values:
    points, primitives, or vertices. An attribute can also be global (also
    known as a detail attribute), in which case there is one instance of the
    attribute value in the geometry.

    The attribute also specifies the data type of the attribute values.

    To look up existing attributes, use hou.Geometry.findPointAttrib,
    hou.Geometry.findPrimAttrib, hou.Geometry.findVertexAttrib, and
    hou.Geometry.findGlobalAttrib. To add a new attribute, use
    hou.Geometry.addAttrib.


    NOTE
        Point positions are stored in a point attribute named P and point
        weights are stored in Pw. See hou.Point.position and
        hou.Point.weight for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Attrib

    def __eq__(self, attrib: "HOM_PtrOrNull< HOM_Attrib >") -> "bool":
        return _hou.Attrib___eq__(self, attrib)

    def __ne__(self, attrib: "HOM_PtrOrNull< HOM_Attrib >") -> "bool":
        return _hou.Attrib___ne__(self, attrib)

    def __hash__(self) -> "int":
        return _hou.Attrib___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Attrib___repr__(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this attribute from the geometry. You would typically call
            this method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if you try to destroy the P or Pw point
            attributes.


        """
        return _hou.Attrib_destroy(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Return the Geometry object containing this attribute.


        """
        return _hou.Attrib_geometry(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the attribute's name. Each attribute in the geometry has a
            unique name.


        """
        return _hou.Attrib_name(self)

    def dataType(self) -> "HOM_EnumValue &":
        r"""

        dataType(self) -> hou.attribData enum value

            Return the attribute's data type (int, float or string).

            The size of the attribute also determines the format of the
            attribute values. For example, if the data type is int and the size
            is 3, the attribute value will be a tuple of 3 ints. If the size was
            1, the attribute value would simply be an int.

            Note that a string attribute's size must be 1.


        """
        return _hou.Attrib_dataType(self)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.attribType enum value

            Return the type of attribute (point, primitive, vertex, or global).


        """
        return _hou.Attrib_type(self)

    def isArrayType(self) -> "bool":
        r"""

        isArrayType(self) -> bool

            Return True if the attribute is a type that contains array data
            (i.e. Float Array, Integer Array, String Array) and False otherwise.


        """
        return _hou.Attrib_isArrayType(self)

    def qualifier(self) -> "std::string":
        r"""

        qualifier(self) -> str

            Return the attribute's type qualifier. The qualifier is a
            description of the data contained in the attribute. An empty string
            is returned if the attribute has no numeric representation or if the
            attribute is the pseudo Pw point attribute.


        """
        return _hou.Attrib_qualifier(self)

    def size(self) -> "int":
        r"""

        size(self) -> int

            Return the number of data components in the attribute value. See
            hou.Attrib.dataType for more information.


        """
        return _hou.Attrib_size(self)

    def setSize(self, size: "int") -> "void":
        r"""

        setSize(self)

            Sets the number of data components in the attribute value. See
            hou.Attrib.dataType for more information.


        """
        return _hou.Attrib_setSize(self, size)

    def isTransformedAsVector(self) -> "bool":
        return _hou.Attrib_isTransformedAsVector(self)

    def isTransformedAsNormal(self) -> "bool":
        r"""

        isTransformedAsNormal(self) -> bool

            Return whether attribute values in the geometry are automatically
            transformed as a normal when Houdini transforms (e.g. rotates) the
            geometry.

            For more information, see the hou.Geometry.addAttrib, in the
            transform_as_normal parameter documentation.


        """
        return _hou.Attrib_isTransformedAsNormal(self)

    def boostAnyDefaultValue(self) -> "hboost::any":
        return _hou.Attrib_boostAnyDefaultValue(self)

    def strings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        strings(self) -> tuple of str

            Return the string table for this attribute. If the attribute is not
            a string, returns an empty tuple.

            A string attribute does not store each string value inside the
            attribute element (i.e. point, primitive, etc.). Instead, the unique
            string attribute values are stored in a table inside the attribute,
            and each attribute value stores an index to that string.

            For example, suppose this attribute stores strings on points. If all
            points have the attribute value \"foo\" then the string table will be
            just (\"foo\",) and each point will store the index 0. When you set
            some points' values to \"bar\", Houdini adds sets the string table to
            (\"foo\", \"bar\") and sets stores the index 1 in those points. When you
            set one of those points back to \"foo\", Houdini leaves the string
            table unchanged and stores the index 0 in that point.

            When using string attribute values, this implementation is hidden
            from you, and you get and set those attributes as strings. This
            method is provided only in case you need access to the string table.


        """
        return _hou.Attrib_strings(self)

    def replaceString(
        self, before: "std::string const &", after: "std::string const &"
    ) -> "bool":
        return _hou.Attrib_replaceString(self, before, after)

    def dicts(
        self,
    ) -> "std::vector< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >,std::allocator< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > > >":
        r"""

        dicts(self) -> tuple of dict

            Return the dictionary table for this attribute. If the attribute is
            not a dictionary, returns an empty tuple.

            A dictionary attribute does not store each dictionary value inside
            the attribute element (i.e. point, primitive, etc.). Instead, the
            unique dictionary attribute values are stored in a table inside the
            attribute, and each attribute value stores an index to that
            dictionary.

            For example, suppose this attribute stores dictionaries on points.
            If all points have the attribute value { \"foo\" : 1 } then the
            dictionary table will be just ({ \"foo\" : 1 },) and each point will
            store the index 0. When you set some points' values to { \"bar\" : 2},
            Houdini adds sets the dictionary table to ({\"foo\":1}, {\"bar\":2}) and
            sets stores the index 1 in those points. When you set one of those
            points back to {\"foo\":1}, Houdini leaves the dictionary table
            unchanged and stores the index 0 in that point.

            When using dictionary attribute values, this implementation is
            hidden from you, and you get and set those attributes as
            dictionaries. This method is provided only in case you need access
            to the dictionary table.


        """
        return _hou.Attrib_dicts(self)

    def indexPairPropertyTables(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_IndexPairPropertyTable >,std::allocator< HOM_ElemPtr< HOM_IndexPairPropertyTable > > >":
        r"""

        indexPairPropertyTables(self) -> tuple of hou.IndexPairPropertyTable

            Return the property tables for this attribute. If the attribute is
            not an index pair, returns an empty tuple.


        """
        return _hou.Attrib_indexPairPropertyTables(self)

    def optionType(self, option_name: "char const *") -> "HOM_EnumValue &":
        r"""

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
        return _hou.Attrib_optionType(self, option_name)

    def setOption(self, *args) -> "void":
        r"""

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See hou.Attrib.options
            for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
        return _hou.Attrib_setOption(self, *args)

    def removeOption(self, name: "char const *") -> "void":
        r"""

        removeOption(self, name)

            Remove an entry in the dictionary of options. See hou.Attrib.options
            for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
        return _hou.Attrib_removeOption(self, name)

    def dataId(self) -> "HOM_AttribDataId *":
        r"""

        dataId(self)

            Returns the data id that represents the contents of this attribute.


        """
        return _hou.Attrib_dataId(self)

    def incrementDataId(self) -> "void":
        r"""

        incrementDataId(self)

            Increment the data id to indicate that the contents of this
            attribute has changed.


        """
        return _hou.Attrib_incrementDataId(self)

    def defaultValue(self) -> "InterpreterObject":
        r"""

        defaultValue(self) -> int or float or str or tuple

            Return the attribute's default value. Returns a single
            int/float/string for attributes of size 1 and a tuple of values for
            attributes with more than one component.

            This method is useful when duplicating an attribute. See
            hou.Geometry.addAttrib for an example.


        """
        return _hou.Attrib_defaultValue(self)

    def options(self) -> "InterpreterObject":
        r"""

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.Attrib.options, hou.Attrib.setOption and
            hou.Attrib.removeOption.


        """
        return _hou.Attrib_options(self)

    def option(self, option_name: "char const *") -> "InterpreterObject":
        return _hou.Attrib_option(self, option_name)


# Register Attrib in _hou:
_hou.Attrib_swigregister(Attrib)


class AttribDataId(object):
    r"""

    hou.AttribDataId

    Used for detecting when contents of geometry have changed

    Every geometry attribute contains a data id that is incremented whenever
    it is modified (by at least 1). To perform optimizations that depend on
    whether an attribute has changed, these data ids can be cached and then
    compared again to see if they match at some future point in time. If
    they do not match, then one should assume that the contents of the
    attribute is no longer the same as before.

    If two attributes have matching data id values, then you can assume that
    their contents are the same. To preserve data id values across geometry
    copies, set the clone_data_ids parameter on such methods to True.

    This is typically used in a SOP to optimize operations in conjunction
    with setting hou.SopNode.setManagesAttribDataIds to True.


    Note
        The values of data ids are only valid within the same session. They
        cannot be compared across sessions or different running Houdini
        processes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__(self)

            Constructs an invalid data id. This can be used as a placeholder in
            a list of data id's for attributes that don't exist.


        """
        _hou.AttribDataId_swiginit(self, _hou.new_AttribDataId())

    __swig_destroy__ = _hou.delete_AttribDataId

    def __eq__(self, other: "HOM_PtrOrNull< HOM_AttribDataId >") -> "bool":
        return _hou.AttribDataId___eq__(self, other)

    def __ne__(self, other: "HOM_PtrOrNull< HOM_AttribDataId >") -> "bool":
        return _hou.AttribDataId___ne__(self, other)

    def __hash__(self) -> "int":
        return _hou.AttribDataId___hash__(self)

    def isValid(self) -> "bool":
        r"""

        isValid(self) -> bool

            Return True if this is a valid data id.


        """
        return _hou.AttribDataId_isValid(self)

    def vexAttribDataId(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        vexAttribDataId(self) -> tuple of int

            Return the same list of integers that the attribdataid() VEX
            function returns for this data id. This is provided for
            interoperability with VEX.


        """
        return _hou.AttribDataId_vexAttribDataId(self)

    def __repr__(self) -> "std::string":
        return _hou.AttribDataId___repr__(self)

    def _getstate(self) -> "std::pair< int64,int64 >":
        r"""

        __getstate__(self) -> tuple of int

            Return a tuple of int that can be used for the pickle module. Note
            that data id values are only valid within the same session.


        """
        return _hou.AttribDataId__getstate(self)

    def _setstate(self, state: "std::pair< int64,int64 >") -> "void":
        r"""

        __setstate__(self, state)

            Restore the state previously obtained by __getstate__.


        """
        return _hou.AttribDataId__setstate(self, state)

    def __getstate__(self):
        return self._getstate()

    def __setstate__(self, state):
        try:
            self.this
        except:
            self.__init__()
        self._setstate(state)


# Register AttribDataId in _hou:
_hou.AttribDataId_swigregister(AttribDataId)


class audio(object):
    r"""

    hou.audio

    Functions related to playing audio using Houdini's playbar.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_audio

    def __repr__(self) -> "std::string":
        return _hou.audio___repr__(self)

    def turnOffAudio(self) -> "void":
        r"""

        turnOffAudio()

            Turn off the audio playback.


        """
        return _hou.audio_turnOffAudio(self)

    def useTimeLineMode(self) -> "void":
        r"""

        useTimeLineMode()

            Put the Audio Panel into a scrub mode.

            When the Audio Panel is in the scrub (a.k.a. timeline) mode, Houdini
            will play the audio during the animation or when scrubbing the thumb
            in the playbar.


        """
        return _hou.audio_useTimeLineMode(self)

    def useTimeSliceMode(self) -> "void":
        r"""

        useTimeSliceMode()

            Put the Audio Panel into realtime (a.k.a. timeslice) mode.


        """
        return _hou.audio_useTimeSliceMode(self)

    def useTestMode(self) -> "void":
        r"""

        useTestMode()

            Put the Audio Panel into a mode that tests the audio playback.

            When the Audio Panel is in the test mode, it will play the entire
            audio soundtrack. The test can be stopped and resumed with stop()
            and play() functions.

            The sound will not play when scrubbing the thumb in the playbar or
            when playing the animation in the playbar. The audio must be in
            either scrub or realtime mode for playing the sound during animation
            or scrubbing.


        """
        return _hou.audio_useTestMode(self)

    def setMono(self, on: "bool") -> "void":
        r"""

        setMono(on)

            Set whether the audio will play in mono or stereo mode.


        """
        return _hou.audio_setMono(self, on)

    def setVolumeTied(self, on: "bool") -> "void":
        r"""

        setVolumeTied(self, on)

            Set whether changing the volume of one channel affects the volume of
            the other channel. If so, both channels will have the same volume
            set.


        """
        return _hou.audio_setVolumeTied(self, on)

    def setMeter(self, on: "bool") -> "void":
        r"""

        setMeter(on)

            Ses whether the meter will show the volume levels during the audio
            playback.


        """
        return _hou.audio_setMeter(self, on)

    def setLeftVolume(self, volume: "double") -> "void":
        r"""

        setLeftVolume(value)

            Set the volume for the left audio channel.


        """
        return _hou.audio_setLeftVolume(self, volume)

    def setRightVolume(self, volume: "double") -> "void":
        r"""

        setRightVolume(value)

            Set the volume for the right channel.


        """
        return _hou.audio_setRightVolume(self, volume)

    def useChops(self) -> "void":
        r"""

        useChops()

            Set the Audio Panel to use a CHOP node for the audio.


        """
        return _hou.audio_useChops(self)

    def useAudioFile(self) -> "void":
        r"""

        useAudioFile()

            Set the Audio Panel to use a disk file for the audio.


        """
        return _hou.audio_useAudioFile(self)

    def setChopPath(self, node_path: "char const *") -> "void":
        r"""

        setChopPath(path)

            Set the Audio Panel to play the sound inside a CHOP node. Houdini
            plays this sound during testing, animation or scrubbing. See also
            hou.audio.useChops.


            path
                A string containing the path to the CHOP node.


        """
        return _hou.audio_setChopPath(self, node_path)

    def setAudioFileName(self, file_name: "char const *") -> "void":
        r"""

        setAudioFileName(path)

            Set the Audio Panel to play the sound inside an audio file. Houdini
            plays this sound during testing, animation or scrubbing. See also
            hou.audio.useAudioFile.


        """
        return _hou.audio_setAudioFileName(self, file_name)

    def setAudioOffset(self, time_offset: "double") -> "void":
        r"""

        setAudioOffset(offset)

            Set the time offset of the sound to sync the audio. This offset,
            specified in seconds, will coincide with the audio frame. See also
            hou.audio.setAudioFrame.


        """
        return _hou.audio_setAudioOffset(self, time_offset)

    def setAudioFrame(self, frame: "double") -> "void":
        r"""

        setAudioFrame(frame)

            Set the frame to sync the audio. The audio offset (in seconds) will
            coincide with this frame. See also hou.audio.setAudioOffset.


        """
        return _hou.audio_setAudioFrame(self, frame)

    def setScrubRepeat(self, on: "bool") -> "void":
        r"""

        setScrubRepeat(on)

            Set whether the sound chunk is repeated during scrubbing. See also
            hou.audio.useTimeSliceMode.


        """
        return _hou.audio_setScrubRepeat(self, on)

    def setScrubSustain(self, sustain: "double") -> "void":
        r"""

        setScrubSustain(value)

            Set the length of time the that the sound chunk is repeatedly played
            when scrubbing comes to a standstill on a particular single frame.
            In practice, when the value is zero, no sound will be played when
            scrubbing keeps hovering over one frame. But, when the value is non-
            zero, a small sound chunk will keep playing repeatedly with a
            specified frequency. See also hou.audio.useTimeSliceMode.


        """
        return _hou.audio_setScrubSustain(self, sustain)

    def setScrubRate(self, scrub_rate: "double") -> "void":
        r"""

        setScrubRate(value)

            When the sustain period is non-zero, the small chunk of the sound
            will be repeated with this frequency when the scrubbing comes to a
            standstill at a single frame. See also hou.audio.useTimeSliceMode.


        """
        return _hou.audio_setScrubRate(self, scrub_rate)

    def reverse(self) -> "void":
        r"""

        reverse()

            When the Audio Panel is in the test mode, start playing the sound in
            reverse.


        """
        return _hou.audio_reverse(self)

    def stop(self) -> "void":
        r"""

        stop()

            When the Audio Panel is in the test mode, stop the test playback if
            any audio is currently playing.


        """
        return _hou.audio_stop(self)

    def play(self) -> "void":
        r"""

        play()

            When the Audio Panel is in the test mode, start playing the Audio
            Panel's specified audio file or CHOP. See also
            hou.audio.setAudioFileName and hou.audio.setChopPath.


        """
        return _hou.audio_play(self)

    def setLooping(self, on: "bool") -> "void":
        r"""

        setLooping(on)

            When the Audio Panel is in the test mode, set whether the test
            should start playing from the beginning once the end is reached. See
            also hou.audio.setRewind.


        """
        return _hou.audio_setLooping(self, on)

    def setRewind(self, on: "bool") -> "void":
        r"""

        setRewind(on)

            When the Audio Panel is in the test mode, set whether the sound
            should rewind to the beginning when the test is stopped. If not, on
            subsequent start, the sound will resume from the point at which it
            was previously stopped. See also hou.audio.setLooping.


        """
        return _hou.audio_setRewind(self, on)


# Register audio in _hou:
_hou.audio_swigregister(audio)


class BoundingBox(object):
    r"""

    hou.BoundingBox

    An axis-aligned 3D rectangular region.

    For example, a bounding box might describe a piece of geometry's minimum
    and maximum values on each of the coordinate axes. See
    hou.Geometry.boundingBox for an example of a function that returns a
    bounding box.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, xmin=0.0, ymin=0.0, zmin=0.0, xmax=0.0, ymax=0.0,
        zmax=0.0)

            Construct a new bounding box with the specified minimum and maximum
            bounds. Use hou.BoundingBox.setTo to change the position of an
            existing bounding box.


        """
        _hou.BoundingBox_swiginit(self, _hou.new_BoundingBox(*args))

    __swig_destroy__ = _hou.delete_BoundingBox

    def __eq__(self, bbox: "HOM_PtrOrNull< HOM_BoundingBox >") -> "bool":
        return _hou.BoundingBox___eq__(self, bbox)

    def __ne__(self, bbox: "HOM_PtrOrNull< HOM_BoundingBox >") -> "bool":
        return _hou.BoundingBox___ne__(self, bbox)

    def isAlmostEqual(
        self, bbox: "BoundingBox", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, bbox, tolerance=0.00001) -> bool

            Returns whether this bounding box is equal to another, subject to
            numerical tolerances.


        """
        return _hou.BoundingBox_isAlmostEqual(self, bbox, tolerance)

    def almostEqual(self, bbox: "BoundingBox", tolerance: "double" = 0.00001) -> "bool":
        return _hou.BoundingBox_almostEqual(self, bbox, tolerance)

    def __hash__(self) -> "int":
        return _hou.BoundingBox___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.BoundingBox___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.BoundingBox___repr__(self)

    def __mul__(self, matrix4: "Matrix4") -> "HOM_BoundingBox":
        r"""

        __mul__(self, matrix4) -> BoundingBox

            Take this bounding box, transform it by the given matrix, compute
            the axis-aligned bounding box around this transformed box, and
            return it.


        """
        return _hou.BoundingBox___mul__(self, matrix4)

    def isValid(self) -> "bool":
        r"""

        isValid(self) -> bool

            Returns whether this bounding box is valid.


        """
        return _hou.BoundingBox_isValid(self)

    def setTo(self, tuple: "_DoubleTuple") -> "void":
        r"""

        setTo(self, bounds_sequence)

            Given a sequence of (xmin, ymin, zmin, xmax, ymax, zmax) values, set
            the position of the bounding box.

            Raises hou.InvalidSize if the tuple does not contain six elements.


        """
        return _hou.BoundingBox_setTo(self, tuple)

    def minvec(self) -> "HOM_Vector3":
        r"""

        minvec(self) -> hou.Vector3

            Return a vector describing the corner of the box with the smallest
            x, y, and z values.


        """
        return _hou.BoundingBox_minvec(self)

    def maxvec(self) -> "HOM_Vector3":
        r"""

        maxvec(self) -> hou.Vector3

            Return a vector describing the corner of the box with the largest x,
            y, and z values.


        """
        return _hou.BoundingBox_maxvec(self)

    def sizevec(self) -> "HOM_Vector3":
        r"""

        sizevec(self) -> hou.Vector3

            Return a vector describing the size of the box in each of the x, y,
            and z axes.

            This method can be implemented as follows:

          > def sizevec(self):
          >     return self.maxvec() - self.minvec()

        """
        return _hou.BoundingBox_sizevec(self)

    def center(self) -> "HOM_Vector3":
        r"""

        center(self) -> hou.Vector3

            Return the position of the center of the bounding box.

            This method can be implemented as follows:

          > def sizevec(self):
          >     return (self.minvec() + self.maxvec()) * 0.5

        """
        return _hou.BoundingBox_center(self)

    def enlargeToContain(self, *args) -> "void":
        r"""

        enlargeToContain(self, point_or_bbox)

            Enlarge the bounding box to contain the given element. The element
            may be a sequence of 3 floats (such as a hou.Vector3) describing a
            position or another bounding box. If this box does not need to grow
            because it already completely contains the element, it won't be
            modified.


        """
        return _hou.BoundingBox_enlargeToContain(self, *args)

    def contains(self, point: "_DoubleTuple") -> "bool":
        r"""

        contains(self, point)

            Given a sequence of 3 floats (such as a hou.Vector3) describing a
            position, return whether the position is inside the box.


        """
        return _hou.BoundingBox_contains(self, point)

    def _asVoidPointer(self) -> "void *":
        return _hou.BoundingBox__asVoidPointer(self)


# Register BoundingBox in _hou:
_hou.BoundingBox_swigregister(BoundingBox)


class BoundingRect(object):
    r"""

    hou.BoundingRect

    An axis-aligned 2D rectangular region.

    A bounding rectangle can describe the size and location of a node in a
    network, or the visible area or a network editor pane.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, p1, p2)

            Construct a new bounding rectangle with the specified bounds
            expressed as two hou.Vector2s.


        """
        _hou.BoundingRect_swiginit(self, _hou.new_BoundingRect(*args))

    __swig_destroy__ = _hou.delete_BoundingRect

    def __eq__(self, rect: "HOM_PtrOrNull< HOM_BoundingRect >") -> "bool":
        return _hou.BoundingRect___eq__(self, rect)

    def __ne__(self, rect: "HOM_PtrOrNull< HOM_BoundingRect >") -> "bool":
        return _hou.BoundingRect___ne__(self, rect)

    def isAlmostEqual(
        self, rect: "BoundingRect", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, rect, tolerance=0.00001) -> bool

            Returns whether this bounding rectangle is equal to another, subject
            to numerical tolerances.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> subrect = hou.BoundingRect(0.001, 0.001, 0.999, 1.001)
          > >>> unitrect.isAlmostEqual(subrect)
          > False
          > >>> unitrect.isAlmostEqual(subrect, 0.01)
          > True

        """
        return _hou.BoundingRect_isAlmostEqual(self, rect, tolerance)

    def __hash__(self) -> "int":
        return _hou.BoundingRect___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.BoundingRect___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.BoundingRect___repr__(self)

    def isValid(self) -> "bool":
        r"""

        isValid(self) -> bool

            Returns whether this bounding rectangle is valid, indicating it has
            been initialized in any way.

          > >>> hou.BoundingRect().isValid()
          > False
          > >>> hou.BoundingRect(0, 0, 0, 0).isValid()
          > True
          > >>> hou.BoundingRect(0, 0, 0, 0).isValid()
          > True

        """
        return _hou.BoundingRect_isValid(self)

    def setTo(self, tuple: "_DoubleTuple") -> "void":
        r"""

        setTo(self, bounds_sequence)

            Given a sequence of (xmin, ymin, xmax, ymax) values, set the
            position of the bounding rectangle.

            Raises hou.InvalidSize if the tuple does not contain four elements.


        """
        return _hou.BoundingRect_setTo(self, tuple)

    def translate(self, tuple: "_DoubleTuple") -> "void":
        r"""

        translate(self, offset)

            Moves this rectangle by the amount specified in the two float tuple
            or hou.Vector2 passed as the offset parameter.

          > >>> rect = hou.BoundingRect(1, 1, 2, 2)
          > >>> rect.translate(hou.Vector2(1, -1))
          > >>> rect
          > <hou.BoundingRect [2, 0, 3, 1]>

        """
        return _hou.BoundingRect_translate(self, tuple)

    def scale(self, tuple: "_DoubleTuple") -> "void":
        r"""

        scale(self, scale)

            Scales this rectangle by the amount specified in the two float tuple
            or hou.Vector2 passed as the scale parameter. Note that scaling the
            rectangle by a negative value will result in an invlalid rectangle
            where the lower left corner is above or to the right of the upper
            right corner.

          > >>> rect = hou.BoundingRect(1, 1, 2, 2)
          > >>> rect.scale(hou.Vector2(2, 3))
          > >>> rect
          > <hou.BoundingRect [2, 3, 4, 6]>
          > >>> rect.scale((-1, -1))
          > >>> rect
          > <hou.BoundingRect [-2, -3, -4, -6]>
          > >>> rect.isValid()
          > False

        """
        return _hou.BoundingRect_scale(self, tuple)

    def expand(self, tuple: "_DoubleTuple") -> "void":
        r"""

        expand(self, offset)

            Moves the edges of the rectangle away from its center by the
            distances specified in the two float tuple or hou.Vector2 passed as
            the offset parameter. The offset is applied to both sides of the
            rectangle so actually changes the width and height of the rectangle
            by twice the passed in values.

            Negative values can be passed into the offset to shrink the
            rectangle, but shrinking the rectangle by more than its current size
            will result in an invliad rectangle.

          > >>> rect = hou.BoundingRect(1, 1, 2, 2)
          > >>> rect.expand((1, 1))
          > >>> rect
          > <hou.BoundingRect [0, 0, 3, 3]>
          > >>> rect.expand((0, -2))
          > >>> rect
          > <hou.BoundingRect [0, 2, 3, 1]>
          > >>> rect.isValid()
          > False

        """
        return _hou.BoundingRect_expand(self, tuple)

    def min(self) -> "HOM_Vector2":
        r"""

        min(self) -> hou.Vector2

            Return a vector describing the corner of the rectangle with the
            smallest x and y values.


        """
        return _hou.BoundingRect_min(self)

    def max(self) -> "HOM_Vector2":
        r"""

        max(self) -> hou.Vector2

            Return a vector describing the corner of the rectangle with the
            largest x and y values.


        """
        return _hou.BoundingRect_max(self)

    def size(self) -> "HOM_Vector2":
        r"""

        size(self) -> hou.Vector2

            Return a vector describing the size of the rectangle in each of the
            x and y axes.

            This method can be implemented as follows:

          > def size(self):
          >     return self.max() - self.min()

        """
        return _hou.BoundingRect_size(self)

    def center(self) -> "HOM_Vector2":
        r"""

        center(self) -> hou.Vector2

            Return the position of the center of the bounding rectangle.

            This method can be implemented as follows:

          > def center(self):
          >     return (self.min() + self.max()) * 0.5

        """
        return _hou.BoundingRect_center(self)

    def getOffsetToAvoid(
        self, bounds: "BoundingRect", direction: "Vector2" = None
    ) -> "HOM_Vector2":
        r"""

        getOffsetToAvoid(self, bounds, direction = None) -> hou.Vector2

            Return a vector describing the minimum distance this rectangle must
            be translated to avoid any overlap with the bounds rectangle. If
            direction is provided as a hou.Vector2, it indicates the specific
            direction the returned offset should be. If the rectangles do not
            overlap, the result will be hou.Vector2(0.0, 0.0).

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> subrect = hou.BoundingRect(0.2, 0.4, 0.8, 0.6)
          > >>> unitrect.getOffsetToAvoid(subrect)
          > <hou.Vector2 [0, 0.6]>
          > >>> unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 0.0))
          > <hou.Vector2 [0.8, 0]>
          > >>> unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 1.0))
          > <hou.Vector2 [0.6, 0.6]>

        """
        return _hou.BoundingRect_getOffsetToAvoid(self, bounds, direction)

    def enlargeToContain(self, *args) -> "void":
        r"""

        enlargeToContain(self, point_or_rect)

            Enlarge the bounding rectangle to contain the given element. The
            element may be a sequence of 2 floats (such as a hou.Vector2)
            describing a position or another bounding rectangle. If this
            rectangle does not need to grow because it already completely
            contains the element, it won't be modified.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.enlargeToContain((2, 0.5))
          > >>> unitrect
          > <hou.BoundingRect [0, 0, 2, 1]>
          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.enlargeToContain(hou.BoundingRect(0.5, 0.5, 2, 1.5))
          > >>> unitrect
          > <hou.BoundingRect [0, 0, 2, 1.5]>

        """
        return _hou.BoundingRect_enlargeToContain(self, *args)

    def intersect(self, rect: "BoundingRect") -> "void":
        r"""

        intersect(self, rect)

            Given a hou.BoundingRect object, updates the rectangle in this
            object to be the region where the two rectangles overlap.

          > >>> rect = hou.BoundingRect(0, 0, 1, 1)
          > >>> rect.intersect(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
          > >>> rect
          > <hou.BoundingRect [0.5, 0.5, 1, 1]>

        """
        return _hou.BoundingRect_intersect(self, rect)

    def intersects(self, *args) -> "bool":
        r"""

        intersects(self, rect) -> bool

            Given a hou.BoundingRect object, return whether that rectangle
            partially or fully overlaps the one described by this object.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
          > True
          > >>> unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
          > True
          > >>> unitrect.intersects(hou.BoundingRect(1.5, 1.5, 2.5, 2.5))
          > False

        """
        return _hou.BoundingRect_intersects(self, *args)

    def contains(self, *args) -> "bool":
        r"""

        contains(self, rect) -> bool

            Given a hou.BoundingRect object, return whether that rectangle is
            inside the one described by this object.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
          > True
          > >>> unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
          > False

        """
        return _hou.BoundingRect_contains(self, *args)

    def closestPoint(self, point: "_DoubleTuple") -> "HOM_Vector2":
        r"""

        closestPoint(self, point) -> hou.Vector2

            Given a sequence of 2 floats (such as a hou.Vector2) describing a
            position, return the position inside the rectangle that is closest
            to the provided point.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.closestPoint((0.5, 0.5))
          > <hou.Vector2 [0.5, 0.5]>
          > >>> unitrect.closestPoint((100, 0.5))
          > <hou.Vector2 [1.0, 0.5]>
          > >>> unitrect.closestPoint((-10, -5))
          > <hou.Vector2 [0, 0]>

        """
        return _hou.BoundingRect_closestPoint(self, point)

    def _asVoidPointer(self) -> "void *":
        return _hou.BoundingRect__asVoidPointer(self)


# Register BoundingRect in _hou:
_hou.BoundingRect_swigregister(BoundingRect)


class ButtonParmTemplate(ParmTemplate):
    r"""

    hou.ButtonParmTemplate

    Describes a parameter tuple containing a button.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={})

            Creates a new ButtonParmTemplate instance.

            Construct a new ButtonParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.


        """
        _hou.ButtonParmTemplate_swiginit(
            self, _hou.new_ButtonParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_ButtonParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.ButtonParmTemplate___repr__(self)


# Register ButtonParmTemplate in _hou:
_hou.ButtonParmTemplate_swigregister(ButtonParmTemplate)


class ChannelEditorPane(PaneTab):
    r"""

    hou.ChannelEditorPane

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ChannelEditorPane

    def __repr__(self) -> "std::string":
        return _hou.ChannelEditorPane___repr__(self)

    def graph(self) -> "HOM_ChannelGraph *":
        r"""

        graph(self) -> hou.ChannelGraph

            Return the channel graph for this pane.


        """
        return _hou.ChannelEditorPane_graph(self)

    def channelListSplitFraction(self) -> "double":
        r"""

        channelListSplitFraction(self) -> double

            Return the width of the embedded channel list as fraction (0-1
            value) of the pane's width.


        """
        return _hou.ChannelEditorPane_channelListSplitFraction(self)

    def setChannelListSplitFraction(self, split_fraction: "double") -> "void":
        r"""

        setChannelListSplitFraction(self, value)

            Set the width of the embedded channel list as fraction (0-1 value)
            of the pane's width.


        """
        return _hou.ChannelEditorPane_setChannelListSplitFraction(self, split_fraction)

    def displayFilter(self) -> "std::string":
        r"""

        displayFilter(self) -> string

            Return the filter pattern for which channels are displayed.


        """
        return _hou.ChannelEditorPane_displayFilter(self)

    def setDisplayFilter(self, filter: "std::string const &") -> "void":
        r"""

        setDisplayFilter(self, filter)

            Set the filter pattern for which channels are displayed. The channel
            name is used to match against the pattern.


        """
        return _hou.ChannelEditorPane_setDisplayFilter(self, filter)

    def editorMode(self) -> "HOM_EnumValue &":
        r"""

        editorMode(self) -> hou.channelEditorMode enum value

            Return the animation editor mode.


        """
        return _hou.ChannelEditorPane_editorMode(self)

    def setEditorMode(self, mode: "EnumValue") -> "void":
        r"""

        setEditorMode(self, mode)

            Set the animation editor mode.


        """
        return _hou.ChannelEditorPane_setEditorMode(self, mode)

    def templateFilter(self) -> "std::string":
        r"""

        templateFilter(self) -> string

            Return the filter pattern for which channels are templated.


        """
        return _hou.ChannelEditorPane_templateFilter(self)

    def setTemplateFilter(self, filter: "std::string const &") -> "void":
        r"""

        setTemplateFilter(self, filter)

            Set the filter pattern for which channels are templated. The channel
            name is used to match against the pattern.


        """
        return _hou.ChannelEditorPane_setTemplateFilter(self, filter)

    def colorsCallback(self) -> "std::string":
        r"""

        colorsCallback(self) -> string

            Return the active channel colors callback name.


        """
        return _hou.ChannelEditorPane_colorsCallback(self)

    def setColorsCallback(self, cb: "std::string const &") -> "bool":
        r"""

        setColorsCallback(self, callback_name) -> bool

            Set the active channel colors callback name. If the callback name is
            invalid, the active callback will be reset to default. Return True
            if the callback was successfully changed. Return False if the
            callback name was invalid.


        """
        return _hou.ChannelEditorPane_setColorsCallback(self, cb)

    def unregisterColorsCallback(self, cb_class: "std::string const &") -> "bool":
        r"""

        unregisterColorsCallback(self, callback_name) -> bool

            Unregister a callback by name. It also resets the active callback if
            the callback to remove was the active one. Return True if the
            callback was successfully removed. Return False if the callback name
            was invalid.


        """
        return _hou.ChannelEditorPane_unregisterColorsCallback(self, cb_class)

    def colorsCallbacks(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        colorsCallbacks(self) -> tuple of string

            Return the list of registered channel colors callback.


        """
        return _hou.ChannelEditorPane_colorsCallbacks(self)

    def registerColorsCallback(
        self, cb_class: "std::string const &", callback: "InterpreterObject"
    ) -> "bool":
        r"""

        registerColorsCallback(self, callback_name, callback_object ) -> bool

            Registers a callback to generate custom channel colors based on the
            node and parameter names.


            callback_name
                A name for the custom color scheme. You can use this to remove
                the callback with the unregisterColorsCallback method.

            callback_object
                A Python object with a getChannelColor method. For example:

              >
              > class MyChannelColors(object):
              >     def getChannelColor(self, node_path, channel_name):
              >         return 0, 0, 0

                The node argument is the path to the node (for example,
                /obj/table). The parm argument is the internal name of the
                channel (for example, tx). The method must return a 3-tuple
                representing normalized (0-1, not 0-255) red, green, and blue
                values. If the method returns (0, 0, 0) Houdini uses the default
                channel color.

            You should register the callback in a session-independent startup
            script. When you register the callback, Houdini will call it once
            with empty string arguments to make sure it returns a triple. Your
            getChannelColor() method needs to handle this case.

            The following example object uses the custom color tint of a node to
            color its channels:

          >
          > import hou
          >
          > class NodeColors:
          >     '''
          >     Use hue variants of a node's color for parameter names
          >     ending in x, y or z.
          >     '''
          >
          >     def getChannelColor(self, node_path, channel_name):
          >         # Handle the empty string case
          >         if not node_path:
          >             return 0, 0, 0
          >
          >         # Get a Node object from the path
          >         n = hou.node(node_path)
          >         # Get the node's color as a hou.Color object
          >         color = n.color()
          >         # Get the color's HSV values as a triple
          >         hue, sat, val = n.color().hsv()
          >
          >         # If the color is gray, use the default
          >         if not sat:
          >             return 0, 0, 0
          >
          >         # Hue-shift the node color for X, Y, and Z channels:
          >         if channel_name.endswith(\"x\"):
          >             color.setHSV(hue - 50, sat * 2, val * 1.2)
          >         elif channel_name.endswith(\"y\"):
          >             color.setHSV(hue, sat * 2, val * 1.2)
          >         elif channel_name.endswith(\"z\"):
          >             color.setHSV(hue + 50, sat * 2, val * 1.2)
          >
          >         # Return the color as normalized (r, g, b)
          >         return color.rgb()

        """
        return _hou.ChannelEditorPane_registerColorsCallback(self, cb_class, callback)

    def channelList(self) -> "HOM_ChannelList *":
        return _hou.ChannelEditorPane_channelList(self)

    def setChannelList(self, l: "ChannelList") -> "void":
        return _hou.ChannelEditorPane_setChannelList(self, l)

    def channelListPinned(self) -> "bool":
        return _hou.ChannelEditorPane_channelListPinned(self)

    def setChannelListPinned(self, pinned: "bool") -> "void":
        return _hou.ChannelEditorPane_setChannelListPinned(self, pinned)


# Register ChannelEditorPane in _hou:
_hou.ChannelEditorPane_swigregister(ChannelEditorPane)


class ChannelGraph(object):
    r"""

    hou.ChannelGraph

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ChannelGraph

    def __eq__(self, graph: "HOM_PtrOrNull< HOM_ChannelGraph >") -> "bool":
        return _hou.ChannelGraph___eq__(self, graph)

    def __ne__(self, graph: "HOM_PtrOrNull< HOM_ChannelGraph >") -> "bool":
        return _hou.ChannelGraph___ne__(self, graph)

    def __hash__(self) -> "int":
        return _hou.ChannelGraph___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.ChannelGraph___repr__(self)

    def selectedKeyframes(
        self,
    ) -> "std::map< HOM_ElemPtr< HOM_Parm >,std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >,std::less< HOM_ElemPtr< HOM_Parm > >,std::allocator< std::pair< HOM_ElemPtr< HOM_Parm > const,std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > > > > >":
        r"""

        selectedKeyframes(self) -> dictionary of (, tuple of hou.BaseKeyframe)
        pairs

            Returns a dictionary of (hou.Parm, keyframes) which are currently
            selected in the playbar. TIP: Here is an example of how to scale the
            selected key values by 2:

          > keyframes = hou.playbar.selectedKeyframes()
          > for parm in keyframes.keys():
          >     for key in keyframes[parm]:
          >         key.setValue(2 * key.value())
          >         parm.setKeyframe(key)

        """
        return _hou.ChannelGraph_selectedKeyframes(self)

    def selection(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ChannelGraphSelection >,std::allocator< HOM_ElemPtr< HOM_ChannelGraphSelection > > >":
        r"""

        selection(self) -> tuple of hou.ChannelGraphSelection

            Return a copy of the current channel graph selection.


        """
        return _hou.ChannelGraph_selection(self)

    def setSelection(
        self,
        s: "std::vector< HOM_ChannelGraphSelection *,std::allocator< HOM_ChannelGraphSelection * > > const &",
    ) -> "void":
        r"""

        setSelection(self, chan_graph_selections)

            Set the current channel graph selection to the given sequence of
            hou.ChannelGraphSelection objects.


        """
        return _hou.ChannelGraph_setSelection(self, s)


# Register ChannelGraph in _hou:
_hou.ChannelGraph_swigregister(ChannelGraph)


class ChannelList(object):
    r"""

    hou.ChannelList

    A copy of a list of channels from Channel List or Animation Editor.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        hou.ChannelList

        A copy of a list of channels from Channel List or Animation Editor.


        """
        _hou.ChannelList_swiginit(self, _hou.new_ChannelList())

    __swig_destroy__ = _hou.delete_ChannelList

    def __repr__(self) -> "std::string":
        return _hou.ChannelList___repr__(self)

    def __eq__(self, *args) -> "bool":
        return _hou.ChannelList___eq__(self, *args)

    def __ne__(self, p: "HOM_PtrOrNull< HOM_ChannelList >") -> "bool":
        return _hou.ChannelList___ne__(self, p)

    def clear(self) -> "void":
        r"""

        clear(self)

            Clears the channel list.


        """
        return _hou.ChannelList_clear(self)

    def parms(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        parms(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels in the channel
            list.


        """
        return _hou.ChannelList_parms(self)

    def selected(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        selected(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels selected in the
            channel list.


        """
        return _hou.ChannelList_selected(self)

    def deselected(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        deselected(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels deselected in the
            channel list.


        """
        return _hou.ChannelList_deselected(self)

    def pinned(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        pinned(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels pinned in the
            channel list.


        """
        return _hou.ChannelList_pinned(self)

    def unpinned(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        unpinned(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels unpinned in the
            channel list.


        """
        return _hou.ChannelList_unpinned(self)

    def selectedValue(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        selectedValue(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels with their value
            column selected in the channel list.


        """
        return _hou.ChannelList_selectedValue(self)

    def deselectedValue(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        deselectedValue(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels with their value
            column deselected in the channel list.


        """
        return _hou.ChannelList_deselectedValue(self)

    def addParm(
        self,
        parm: "Parm",
        selected: "bool" = True,
        pinned: "bool" = False,
        valueselected: "bool" = False,
    ) -> "void":
        r"""

        addParms(self, parms, selected, pinned, valueselected)

            Adds a list of parameters to the channel list setting selected,
            pinned and value selected flags.


            parms
                A tuple of hou.Parm.

            selected
                Select the channel, True by default.

            pinned
                Pin the channel, False by default.

            valueselected
                Select the value column of the channel, False by default.


        """
        return _hou.ChannelList_addParm(self, parm, selected, pinned, valueselected)

    def addPath(
        self,
        path: "std::string const &",
        selected: "bool" = True,
        pinned: "bool" = False,
        valueselected: "bool" = False,
    ) -> "void":
        r"""

        addPath(self, path, selected, pinned, valueselected)

            Adds a parameter to the channel list setting selected, pinned and
            value selected flags.


            path
                A full path string to a parameter.

            selected
                Select the channel, True by default.

            pinned
                Pin the channel, False by default.

            valueselected
                Select the value column of the channel, False by default.


        """
        return _hou.ChannelList_addPath(self, path, selected, pinned, valueselected)

    def addParms(
        self,
        parms: "std::vector< HOM_Parm *,std::allocator< HOM_Parm * > > const &",
        selected: "bool" = True,
        pinned: "bool" = False,
        valueselected: "bool" = False,
    ) -> "void":
        return _hou.ChannelList_addParms(self, parms, selected, pinned, valueselected)

    def addPaths(
        self,
        paths: "_StringTuple",
        selected: "bool" = True,
        pinned: "bool" = False,
        valueselected: "bool" = False,
    ) -> "void":
        r"""

        addPaths(self, paths, selected, pinned, valueselected)

            Adds a list of parameters using full paths to the channel list
            setting selected, pinned and value selected flags.


            path
                A full path string to a parameter.

            selected
                Select the channel, True by default.

            pinned
                Pin the channel, False by default.

            valueselected
                Select the value column of the channel, False by default.


        """
        return _hou.ChannelList_addPaths(self, paths, selected, pinned, valueselected)

    def remove(self, *args) -> "void":
        r"""

        remove(self, parm)

            Remove a parameter or a list of parameters from the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_remove(self, *args)

    def select(self, *args) -> "void":
        r"""

        select(self, parm)

            Select a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_select(self, *args)

    def deselect(self, *args) -> "void":
        r"""

        deselect(self, parm)

            Deselect a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_deselect(self, *args)

    def pin(self, *args) -> "void":
        r"""

        pin(self, parm)

            Pin a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_pin(self, *args)

    def unpin(self, *args) -> "void":
        r"""

        unpin(self, parm)

            Unpin a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_unpin(self, *args)

    def selectValue(self, *args) -> "void":
        r"""

        selectValue(self, parm)

            Select the value column of a parameter or a list of parameters in
            the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_selectValue(self, *args)

    def deselectValue(self, *args) -> "void":
        r"""

        deselectValue(self, parm)

            Deselect the value column of a parameter or a list of parameters in
            the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
        return _hou.ChannelList_deselectValue(self, *args)

    def contains(self, parm: "Parm") -> "bool":
        r"""

        contains(self, parm) -> bool

            Returns True if the parameter is in the Channel List.


            parm
                A hou.Parm.


        """
        return _hou.ChannelList_contains(self, parm)

    def isSelected(self, parm: "Parm") -> "bool":
        r"""

        isSelected(self, parm) -> bool

            Returns True if the parameter is selected in the Channel List.


            parm
                A hou.Parm.


        """
        return _hou.ChannelList_isSelected(self, parm)

    def isPinned(self, parm: "Parm") -> "bool":
        r"""

        isPinned(self, parm) -> bool

            Returns True if the parameter is pinned in the Channel List.


            parm
                A hou.Parm.


        """
        return _hou.ChannelList_isPinned(self, parm)

    def isValueSelected(self, parm: "Parm") -> "bool":
        r"""

        isValueSelected(self, parm) -> bool

            Returns True if the parameter has its value column selected in the
            Channel List.


            parm
                A hou.Parm.


        """
        return _hou.ChannelList_isValueSelected(self, parm)

    def filter(self) -> "std::string":
        r"""

        filter(self) -> str

            Returns the channel list filter string.


        """
        return _hou.ChannelList_filter(self)

    def keepSelection(self) -> "bool":
        r"""

        keepSelection(self) -> bool

            Returns the channel list Keep Selection flag.


        """
        return _hou.ChannelList_keepSelection(self)

    def enableFilter(self) -> "bool":
        r"""

        enableFilter(self) -> bool

            Returns True if the channel list filtering is active.


        """
        return _hou.ChannelList_enableFilter(self)

    def filterTranslates(self) -> "bool":
        r"""

        filterTranslates(self) -> bool

            Returns True if the channel list translations filtering is active.


        """
        return _hou.ChannelList_filterTranslates(self)

    def filterRotates(self) -> "bool":
        r"""

        filterRotates(self) -> bool

            Returns True if the channel list rotations filtering is active.


        """
        return _hou.ChannelList_filterRotates(self)

    def filterScales(self) -> "bool":
        r"""

        filterScales(self) -> bool

            Returns True if the channel list scales filtering is active.


        """
        return _hou.ChannelList_filterScales(self)

    def setFilter(self, pattern: "std::string const") -> "void":
        r"""

        setFilter(self,pattern)`

            Set the channel list filter string.


            pattern
                A pattern string.


        """
        return _hou.ChannelList_setFilter(self, pattern)

    def setKeepSelection(self, value: "bool") -> "void":
        r"""

        setKeepSelection(self,on)

            Set the channel list Keep Selection flag.


        """
        return _hou.ChannelList_setKeepSelection(self, value)

    def setEnableFilter(self, value: "bool") -> "void":
        r"""

        setEnableFilter(self,on)

            Enable/Disable the channel list filtering.


        """
        return _hou.ChannelList_setEnableFilter(self, value)

    def setFilterTranslates(self, value: "bool") -> "void":
        r"""

        setFilterTranslates(self,on)

            Enable/Disable channel list translations filtering.


        """
        return _hou.ChannelList_setFilterTranslates(self, value)

    def setFilterRotates(self, value: "bool") -> "void":
        r"""

        setFilterRotates(self,on)

            Enable/Disable channel list rotations filtering.


        """
        return _hou.ChannelList_setFilterRotates(self, value)

    def setFilterScales(self, value: "bool") -> "void":
        r"""

        setFilterScales(self,on)

            Enable/Disable channel list scales filtering.


        """
        return _hou.ChannelList_setFilterScales(self, value)

    def asCode(self, *args, **kwargs) -> "std::string":
        r"""

        asCode(self,var_name) -> str

            Returns a python code string that be run to recreate a ChannelList
            with the same content as the current object.


            var_name
                The variable name used in the generated code for the channel
                list. It defaults to chanlist.


        """
        return _hou.ChannelList_asCode(self, *args, **kwargs)


# Register ChannelList in _hou:
_hou.ChannelList_swigregister(ChannelList)


class ChopNode(Node):
    r"""

    hou.ChopNode

    Class representing a CHOP node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ChopNode

    def __repr__(self) -> "std::string":
        return _hou.ChopNode___repr__(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns whether the node's bypass flag is on.


        """
        return _hou.ChopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turn the node's bypass flag on or off, making this node have no
            effect.


        """
        return _hou.ChopNode_bypass(self, on)

    def isLocked(self) -> "bool":
        r"""

        isLocked(self) -> bool

            Returns whether this node's lock flag is on.


        """
        return _hou.ChopNode_isLocked(self)

    def setLocked(self, on: "bool") -> "void":
        r"""

        setLocked(self, on)

            Turn this node's lock flag on or off. Locking a node saves its
            current cooked channel data into the node. If you unlock a locked
            node, it will discard its locked channel data and recook, computing
            its channel data from its inputs and parameters.


        """
        return _hou.ChopNode_setLocked(self, on)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Returns whether the node's display flag is on.


        """
        return _hou.ChopNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turns the node's display flag to on or off.


        """
        return _hou.ChopNode_setDisplayFlag(self, on)

    def isAudioFlagSet(self) -> "bool":
        r"""

        isAudioFlagSet(self) -> bool

            Returns whether the node's audio flag is on.


        """
        return _hou.ChopNode_isAudioFlagSet(self)

    def setAudioFlag(self, on: "bool") -> "void":
        r"""

        setAudioFlag(self, on)

            Turns the node's audio flag on or off.


        """
        return _hou.ChopNode_setAudioFlag(self, on)

    def isExportFlagSet(self) -> "bool":
        r"""

        isExportFlagSet(self) -> bool

            Returns whether the node's export flag is on.


        """
        return _hou.ChopNode_isExportFlagSet(self)

    def setExportFlag(self, on: "bool") -> "void":
        r"""

        setExportFlag(self, on)

            Turns the node's export flag to on or off.


        """
        return _hou.ChopNode_setExportFlag(self, on)

    def isUnloadFlagSet(self) -> "bool":
        r"""

        isUnloadFlagSet(self) -> bool

            Returns whether the node's unload flag is on.


        """
        return _hou.ChopNode_isUnloadFlagSet(self)

    def setUnloadFlag(self, on: "bool") -> "void":
        r"""

        setUnloadFlag(self, on)

            Turns the node's unload flag to on or off.


        """
        return _hou.ChopNode_setUnloadFlag(self, on)

    def isCurrentFlagSet(self) -> "bool":
        r"""

        isCurrentFlagSet(self) -> bool

            Returns whether the node's current flag is on.


        """
        return _hou.ChopNode_isCurrentFlagSet(self)

    def setCurrentFlag(self, on: "bool") -> "void":
        r"""

        setCurrentFlag(self, on)

            Turns the node's audio flag on or off.


        """
        return _hou.ChopNode_setCurrentFlag(self, on)

    def tracks(
        self, output_index: "int" = 0, cook: "bool" = True
    ) -> "std::vector< HOM_ElemPtr< HOM_Track >,std::allocator< HOM_ElemPtr< HOM_Track > > >":
        r"""

        tracks(self) -> tuple of Tracks

            Returns a tuple of all the tracks in this node.


        """
        return _hou.ChopNode_tracks(self, output_index, cook)

    def track(
        self, track_name: "char const *", output_index: "int" = 0, cook: "bool" = True
    ) -> "HOM_Track *":
        r"""

        track(self, track_name) -> hou.Track or None

            Return the track of the given name, or None if it doesn't exist.


        """
        return _hou.ChopNode_track(self, track_name, output_index, cook)

    def clip(self, output_index: "int" = 0) -> "HOM_Clip *":
        r"""

        clip(self, output_index=0) -> hou.Clip

            Returns the CHOP node's clip.


            output_index
                If the CHOP has multiple outputs, this specifies which output's
                clip is returned.


        """
        return _hou.ChopNode_clip(self, output_index)

    def sampleRate(self) -> "double":
        r"""

        sampleRate(self) -> double

            Returns the sample rate used by this node in number of samples per
            second.


        """
        return _hou.ChopNode_sampleRate(self)

    def sampleRange(self) -> "std::pair< double,double >":
        r"""

        sampleRange(self) -> (start, end)

            Return a 2-tuple containing the start and end values of the sample
            range. The number of samples for each track in this node is start-
            end+1. Note that samples start from 0, not 1.


        """
        return _hou.ChopNode_sampleRange(self)

    def frameToSamples(self, frame: "double") -> "double":
        r"""

        frameToSamples(self, frame) -> double

            Converts a value expressed as frames to a value expressed in
            samples.


        """
        return _hou.ChopNode_frameToSamples(self, frame)

    def samplesToFrame(self, samples: "double") -> "double":
        r"""

        samplesToFrame(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            frames.


        """
        return _hou.ChopNode_samplesToFrame(self, samples)

    def timeToSamples(self, time: "double") -> "double":
        r"""

        timeToSamples(self, time) -> double

            Converts a value expressed in seconds to a value expressed in
            samples.


        """
        return _hou.ChopNode_timeToSamples(self, time)

    def samplesToTime(self, samples: "double") -> "double":
        r"""

        samplesToTime(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            seconds.


        """
        return _hou.ChopNode_samplesToTime(self, samples)

    def clipData(self, *args) -> "HOM_BinaryString":
        r"""

        clipData(self, binary) -> str for Python 2, bytes for Python 3

            Returns the clip data for the CHOP node in ASCII or binary,
            depending on the value of the binary parameter.

            The returned clip data is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


        """
        return _hou.ChopNode_clipData(self, *args)

    def setClipData(
        self,
        source: "HOM_BinaryString",
        binary: "bool",
        offset: "double" = 0,
        rename: "char const *" = None,
    ) -> "void":
        r"""

        setClipData(self, data, binary)

            Sets the clip data for the CHOP node. Should only be called on
            locked nodes.


        """
        return _hou.ChopNode_setClipData(self, source, binary, offset, rename)

    def saveClip(self, *args) -> "bool":
        r"""

        saveClip(self, file_name)

            Saves the node's output clip to a file. The filename extension
            determines the file format to use.


        """
        return _hou.ChopNode_saveClip(self, *args)


# Register ChopNode in _hou:
_hou.ChopNode_swigregister(ChopNode)


class Clip(object):
    r"""

    hou.Clip

    Class representing an animation clip.

    RELATED

      * hou.ChopNode

      * hou.Track

      * hou.AgentClip


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__()

            Creates an empty clip.


        """
        _hou.Clip_swiginit(self, _hou.new_Clip())

    __swig_destroy__ = _hou.delete_Clip

    def __eq__(self, clip: "HOM_PtrOrNull< HOM_Clip >") -> "bool":
        return _hou.Clip___eq__(self, clip)

    def __ne__(self, clip: "HOM_PtrOrNull< HOM_Clip >") -> "bool":
        return _hou.Clip___ne__(self, clip)

    def __repr__(self) -> "std::string":
        return _hou.Clip___repr__(self)

    def chopNode(self) -> "HOM_ChopNode *":
        r"""

        chopNode(self) -> hou.ChopNode

            Returns the hou.ChopNode owner of this clip. This returns None if
            the clip is not owned by a CHOP.


        """
        return _hou.Clip_chopNode(self)

    def chopNodeOutputIndex(self) -> "int":
        r"""

        chopNodeOutputIndex(self) -> int

            Returns the index of the CHOP node output that this clip corresponds
            to. This returns -1 if the clip is not owned by a CHOP.


        """
        return _hou.Clip_chopNodeOutputIndex(self)

    def tracks(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Track >,std::allocator< HOM_ElemPtr< HOM_Track > > >":
        r"""

        tracks(self) -> tuple of hou.Track

            Returns a tuple of all the tracks in this clip.


        """
        return _hou.Clip_tracks(self)

    def track(self, track_name: "char const *") -> "HOM_Track *":
        r"""

        track(self, track_name) -> hou.Track or None

            Return the track of the given name, or None if it doesn't exist.


        """
        return _hou.Clip_track(self, track_name)

    def sampleRate(self) -> "double":
        r"""

        sampleRate(self) -> double

            Returns the sample rate used by this clip in number of samples per
            second.


        """
        return _hou.Clip_sampleRate(self)

    def sampleRange(self) -> "std::pair< double,double >":
        r"""

        sampleRange(self) -> (start, end)

            Return a 2-tuple containing the start and end values of the sample
            range. The number of samples for each track in this node is start-
            end+1. Note that samples start from 0, not 1.


        """
        return _hou.Clip_sampleRange(self)

    def numSamples(self) -> "int":
        r"""

        numSamples(self) -> int

            Return the number of samples in this clip.


        """
        return _hou.Clip_numSamples(self)

    def frameToSamples(self, frame: "double") -> "double":
        r"""

        frameToSamples(self, frame) -> double

            Converts a value expressed as frames to a value expressed in
            samples.


        """
        return _hou.Clip_frameToSamples(self, frame)

    def samplesToFrame(self, samples: "double") -> "double":
        r"""

        samplesToFrame(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            frames.


        """
        return _hou.Clip_samplesToFrame(self, samples)

    def timeToSamples(self, time: "double") -> "double":
        r"""

        timeToSamples(self, time) -> double

            Converts a value expressed in seconds to a value expressed in
            samples.


        """
        return _hou.Clip_timeToSamples(self, time)

    def samplesToTime(self, samples: "double") -> "double":
        r"""

        samplesToTime(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            seconds.


        """
        return _hou.Clip_samplesToTime(self, samples)

    def loadFromFile(self, filename: "char const *") -> "void":
        r"""

        loadFromFile(self, file_name)

            Loads the clip from a file, such as a .bclip.


        """
        return _hou.Clip_loadFromFile(self, filename)

    def saveToFile(self, filename: "char const *") -> "void":
        r"""

        saveToFile(self, file_name)

            Saves the clip to a file. The filename extension determines the file
            format to use.


        """
        return _hou.Clip_saveToFile(self, filename)


# Register Clip in _hou:
_hou.Clip_swigregister(Clip)


class Color(object):
    r"""

    hou.Color

    Represents a color value.

    You can get and set the internal values using different color
    representations such as RGB and L*a*b*.

    Note that the constructor takes a single tuple of RGB values, not three
    arguments. So, for example, to create red you would say:

    > red = hou.Color((1.0, 0, 0))

    You can set the color in one color space and get the color in a
    different color space to convert between spaces.

    See HSL and HSV, Lab color space, CIE 1931 color space, and Color
    temperature for an introduction to the concepts the methods are based
    on.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, rgb_tuple=(0.0, 0.0, 0.0)) -> Color

            Creates a color object, optionally from RGB values.

            To construct a color using a different representation, first create
            the object and then use a set method:

          > c = hou.Color()
          > c.setHSV(180, 0.5, 1.0)

        """
        _hou.Color_swiginit(self, _hou.new_Color(*args))

    __swig_destroy__ = _hou.delete_Color

    def __eq__(self, color: "HOM_PtrOrNull< HOM_Color >") -> "bool":
        return _hou.Color___eq__(self, color)

    def __ne__(self, color: "HOM_PtrOrNull< HOM_Color >") -> "bool":
        return _hou.Color___ne__(self, color)

    def __hash__(self) -> "int":
        return _hou.Color___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Color___repr__(self)

    def rgb(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        rgb(self) -> (float, float, float)

            Returns the color as a tuple of (red, green, blue) floating point
            values, where each value is in the range 0.0 to 1.0.


        """
        return _hou.Color_rgb(self)

    def hsv(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        hsv(self) -> (float, float, float)

            Returns the color as a tuple of (hue, saturation, value), where hue
            is 0 - 360, and saturation and value are 0.0 - 1.0.


        """
        return _hou.Color_hsv(self)

    def hsl(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        hsl(self) -> (float, float, float)

            Returns the color as a tuple of (hue, saturation, lightness), where
            hue is 0 - 360, and saturation and lightness are 0.0 - 1.0.


        """
        return _hou.Color_hsl(self)

    def xyz(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        xyz(self) -> (float, float, float)

            Returns the color as a tuple of (x, y, z) tristimulus values, where
            each component is 0.0 to 1.0 (but may go out of bounds from
            conversion).


        """
        return _hou.Color_xyz(self)

    def lab(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        lab(self) -> (float, float, float)

            Returns the color as a tuple of (L, a, b) as defined in the L*a*b*
            model, where L is 0 - 100, and a and b are unbound. (Note that a and
            b are restricted to -128 - 127 in TIFF files).


        """
        return _hou.Color_lab(self)

    def tmi(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        tmi(self) -> (float, float, float)

            Returns the color as a tuple of (temperature, magenta, intensity),
            where each component is -1.0 to 1.0.


        """
        return _hou.Color_tmi(self)

    def setRGB(self, tuple: "_FloatTuple") -> "void":
        r"""

        setRGB(self, tuple)

            Sets the color using a tuple of (red, green, blue) floating point
            values. See the rgb() method.


        """
        return _hou.Color_setRGB(self, tuple)

    def setHSV(self, tuple: "_FloatTuple") -> "void":
        r"""

        setHSV(self, tuple)

            Sets the color as a tuple of (hue, saturation, value). See the hsv()
            method.


        """
        return _hou.Color_setHSV(self, tuple)

    def setHSL(self, tuple: "_FloatTuple") -> "void":
        r"""

        setHSL(self, tuple)

            Sets the color as a tuple of (hue, saturation, lightness). See the
            hsl() method.


        """
        return _hou.Color_setHSL(self, tuple)

    def setXYZ(self, tuple: "_FloatTuple") -> "void":
        r"""

        setXYZ(self, tuple)

            Sets the color as a tuple of (x, y, z) tristimulus values. See the
            xyz() method.


        """
        return _hou.Color_setXYZ(self, tuple)

    def setLAB(self, tuple: "_FloatTuple") -> "void":
        r"""

        setLAB(self, tuple)

            Sets the color as a tuple of (L, a, b) as defined in the L*a*b*
            model. See the lab() method.


        """
        return _hou.Color_setLAB(self, tuple)

    def setTMI(self, tuple: "_FloatTuple") -> "void":
        r"""

        setTMI(self, tuple)

            Sets the color as a tuple of (temperature, magenta, intensity). See
            the tmi() method.


        """
        return _hou.Color_setTMI(self, tuple)

    @staticmethod
    def ocio_configPath() -> "std::string":
        r"""

        ocio_configPath() -> str

            Query the full path to the current OpenColorIO 'config.ocio' file.


        """
        return _hou.Color_ocio_configPath()

    @staticmethod
    def ocio_spaces() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        ocio_spaces()

            Returns a list of the color spaces defined in the Open Color IO
            configuration in Houdini.


        """
        return _hou.Color_ocio_spaces()

    @staticmethod
    def ocio_activeDisplays() -> (
        "std::vector< std::string,std::allocator< std::string > >"
    ):
        r"""

        ocio_activeDisplays() -> tuple of str

            Return the list of active Displays, specified in the config file or
            the OpenColorIO OCIO_ACTIVE_DISPLAYS environment variable.


        """
        return _hou.Color_ocio_activeDisplays()

    @staticmethod
    def ocio_activeViews() -> (
        "std::vector< std::string,std::allocator< std::string > >"
    ):
        r"""

        ocio_activeViews() -> tuple of str

            Return the list of active Views, specified in the config file or the
            OpenColorIO OCIO_ACTIVE_VIEWS environment variable.


        """
        return _hou.Color_ocio_activeViews()

    @staticmethod
    def ocio_looks() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        ocio_looks() -> tuple of str

            Return the list of Looks in the current OpenColorIO config.


        """
        return _hou.Color_ocio_looks()

    @staticmethod
    def ocio_roles() -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        ocio_roles() -> tuple of str

            Return the list of Roles in the current OpenColorIO config.


        """
        return _hou.Color_ocio_roles()

    @staticmethod
    def ocio_views(
        display: "char const *",
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        ocio_views(display) -> tuple of str

            Return the list of Views available for 'display'.


        """
        return _hou.Color_ocio_views(display)

    @staticmethod
    def ocio_defaultDisplay() -> "std::string":
        r"""

        ocio_defaultDisplay() -> str

            Returns the default Display, specified in the config file or the
            OpenColorIO OCIO_ACTIVE_DISPLAYS environment variable (as the first
            Display in the list).


        """
        return _hou.Color_ocio_defaultDisplay()

    @staticmethod
    def ocio_defaultView() -> "std::string":
        r"""

        ocio_defaultView() -> str

            Returns the default View, specified in the config file or the
            OpenColorIO OCIO_ACTIVE_VIEWS environment variable (as the first
            View in the list).


        """
        return _hou.Color_ocio_defaultView()

    def ocio_transform(
        self,
        src_colorspace: "std::string",
        dest_colorspace: "std::string",
        looks: "std::string",
    ) -> "HOM_Color *":
        r"""

        ocio_transform(src_colorspace, dest_colorspace, looks) -> hou.Color`

            Do a color transform from this color (in src_colorspace) to a
            different colorspace (dest_colorspace) with optional transforms
            specified in looks. Each colorspace must be a valid colorspace in
            the current OCIO config file, and each look must be a valid look
            name in the config file. Return the transformed color.


        """
        return _hou.Color_ocio_transform(self, src_colorspace, dest_colorspace, looks)

    def ocio_viewTransform(
        self, src_colorspace: "std::string", display: "std::string", view: "std::string"
    ) -> "HOM_Color *":
        r"""

        ocio_viewTransform(src_colorspace, display_name, view_name) ->
        hou.Color`

            Do a color transform from this color (in src_colorspace) to the view
            specified by 'display_name' and 'view_name', and return the
            transformed result. The colorspace, display, and view must all be
            valid names in the current OCIO config file.


        """
        return _hou.Color_ocio_viewTransform(self, src_colorspace, display, view)

    @staticmethod
    def reloadOCIO() -> "void":
        r"""

        reloadOCIO()

            Reloads the OpenColorIO configuration file. This is generally paired
            with setting the OCIO environment variable to a new config file
            beforehand.


        """
        return _hou.Color_reloadOCIO()

    def _asVoidPointer(self) -> "void *":
        return _hou.Color__asVoidPointer(self)


# Register Color in _hou:
_hou.Color_swigregister(Color)


def Color_ocio_configPath() -> "std::string":
    r"""

    ocio_configPath() -> str

        Query the full path to the current OpenColorIO 'config.ocio' file.


    """
    return _hou.Color_ocio_configPath()


def Color_ocio_spaces() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    ocio_spaces()

        Returns a list of the color spaces defined in the Open Color IO
        configuration in Houdini.


    """
    return _hou.Color_ocio_spaces()


def Color_ocio_activeDisplays() -> (
    "std::vector< std::string,std::allocator< std::string > >"
):
    r"""

    ocio_activeDisplays() -> tuple of str

        Return the list of active Displays, specified in the config file or
        the OpenColorIO OCIO_ACTIVE_DISPLAYS environment variable.


    """
    return _hou.Color_ocio_activeDisplays()


def Color_ocio_activeViews() -> (
    "std::vector< std::string,std::allocator< std::string > >"
):
    r"""

    ocio_activeViews() -> tuple of str

        Return the list of active Views, specified in the config file or the
        OpenColorIO OCIO_ACTIVE_VIEWS environment variable.


    """
    return _hou.Color_ocio_activeViews()


def Color_ocio_looks() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    ocio_looks() -> tuple of str

        Return the list of Looks in the current OpenColorIO config.


    """
    return _hou.Color_ocio_looks()


def Color_ocio_roles() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    ocio_roles() -> tuple of str

        Return the list of Roles in the current OpenColorIO config.


    """
    return _hou.Color_ocio_roles()


def Color_ocio_views(
    display: "char const *",
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    ocio_views(display) -> tuple of str

        Return the list of Views available for 'display'.


    """
    return _hou.Color_ocio_views(display)


def Color_ocio_defaultDisplay() -> "std::string":
    r"""

    ocio_defaultDisplay() -> str

        Returns the default Display, specified in the config file or the
        OpenColorIO OCIO_ACTIVE_DISPLAYS environment variable (as the first
        Display in the list).


    """
    return _hou.Color_ocio_defaultDisplay()


def Color_ocio_defaultView() -> "std::string":
    r"""

    ocio_defaultView() -> str

        Returns the default View, specified in the config file or the
        OpenColorIO OCIO_ACTIVE_VIEWS environment variable (as the first
        View in the list).


    """
    return _hou.Color_ocio_defaultView()


def Color_reloadOCIO() -> "void":
    r"""

    reloadOCIO()

        Reloads the OpenColorIO configuration file. This is generally paired
        with setting the OCIO environment variable to a new config file
        beforehand.


    """
    return _hou.Color_reloadOCIO()


class CompositorViewer(PathBasedPaneTab):
    r"""

    hou.CompositorViewer

    Minimal class representing a compositing view pane.

    This class is currently very simple, implementing a minimal number of
    methods necessary to support compositing shelf tools. It does not
    currently allow programmatic control of most functions available in the
    UI.

    You should probably avoid using this object. If you are writing custom
    tools for the compositing view, the higher-level functions in the
    cop2toolutils module are more useful.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_CompositorViewer

    def __repr__(self) -> "std::string":
        return _hou.CompositorViewer___repr__(self)

    def currentState(self) -> "std::string":
        r"""

        currentState(self) -> str

            Returns the name of the tool currently in use in the view. This is
            an internal, undocumented designation but usually corresponds to the
            name of a node. You can change to a different tool using
            setCurrentState.


        """
        return _hou.CompositorViewer_currentState(self)

    def enterViewState(self, wait_for_exit: "bool" = False) -> "void":
        r"""

        enterViewState(self, wait_for_exit=False)

            Switch to the view tool.


        """
        return _hou.CompositorViewer_enterViewState(self, wait_for_exit)

    def setCurrentState(
        self, state: "char const *", wait_for_exit: "bool" = False
    ) -> "void":
        r"""

        setCurrentState(self, state, wait_for_exit=False)

            Sets the currently active tool in the view. state is a string
            containing an internal, undocumented designation. See
            currentState().


        """
        return _hou.CompositorViewer_setCurrentState(self, state, wait_for_exit)

    def usingOCIO(self) -> "bool":
        r"""

        usingOCIO(self) -> bool

            Query if OpenColorIO is being used for color correction in the
            viewer.


        """
        return _hou.CompositorViewer_usingOCIO(self)

    def setUsingOCIO(self, enable: "bool") -> "void":
        r"""

        setUsingOCIO(self, enable)

            Enable or disable OpenColorIO for color correction in the viewer.


        """
        return _hou.CompositorViewer_setUsingOCIO(self, enable)

    def setOCIODisplayView(
        self, display: "char const *" = None, view: "char const *" = None
    ) -> "void":
        r"""

        setOCIODisplayView(self, display=\"\", view=\"\")

            Set the OpenColorIO display name, view name, or both. The display
            and view together define the output colorspace for the viewer, and
            any number of color transforms (Looks) to be performed on the linear
            viewport image.


        """
        return _hou.CompositorViewer_setOCIODisplayView(self, display, view)

    def getOCIODisplay(self) -> "std::string":
        r"""

        getOCIODisplay(self) -> str

            Return the current OpenColorIO display used for color correction.


        """
        return _hou.CompositorViewer_getOCIODisplay(self)

    def getOCIOView(self) -> "std::string":
        r"""

        getOCIOView(self) -> str

            Return the current OpenColorIO view used for color correction.


        """
        return _hou.CompositorViewer_getOCIOView(self)


# Register CompositorViewer in _hou:
_hou.CompositorViewer_swigregister(CompositorViewer)


class ConstructionPlane(object):
    r"""

    hou.ConstructionPlane

    The grid (a.k.a. construction plane) in the scene viewer pane tab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ConstructionPlane

    def __repr__(self) -> "std::string":
        return _hou.ConstructionPlane___repr__(self)

    def sceneViewer(self) -> "HOM_SceneViewer *":
        r"""

        sceneViewer(self) -> hou.SceneViewer

            Return the scene viewer containing this plane.


        """
        return _hou.ConstructionPlane_sceneViewer(self)

    def isVisible(self) -> "bool":
        r"""

        isVisible(self) -> bool

            Return whether the grid is visible in the viewer.


        """
        return _hou.ConstructionPlane_isVisible(self)

    def setIsVisible(self, on: "bool") -> "void":
        r"""

        setIsVisible(self, on)

            Make this grid visible or invisible in the viewer.


        """
        return _hou.ConstructionPlane_setIsVisible(self, on)

    def transform(self) -> "HOM_Matrix4 *":
        r"""

        transform(self) -> hou.Matrix4

            Return the transformation matrix for this plane.

            When the transformation matrix is the identity matrix, the plane's
            bottom-left corner is at the origin and it sits in the XY plane. In
            this orientation, increasing the number of cells in x or the size of
            a cell in x grows the plane outward from the origin along the
            x-axis. Similarly, increasing the number of cells or size of a cell
            in y grows the plane along the y-axis.

            Note that the transformation matrix does not contain any scale
            information. Use the cellSize and numberOfCells methods to get the
            size of the plane.

            The following function will return the position of the center of the
            plane:

          > def origin(construction_plane):
          >     return hou.Vector3(0, 0, 0) * construction_plane.transform()

            The following function will return the normal of the plane:

          > def normal(construction_plane):
          >     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()

        """
        return _hou.ConstructionPlane_transform(self)

    def setTransform(self, matrix: "Matrix4") -> "void":
        r"""

        setTransform(self, matrix)

            Set the transformation matrix for this plane to a hou.Matrix4.

            This matrix is used to translate and rotate the plane. See the
            transform method for more information.

            Note that scale information inside the transformation matrix is
            ignored. Use the setCellSize and setNumberOfCells methods to adjust
            the size of the plane.

            The following function will change the position of the center of the
            plane:

          > def set_origin(construction_plane, new_origin):
          >     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(construction_plane))
          >     construction_plane.setTransform(construction_plane.transform() * translation)
          >
          > def origin(construction_plane):
          >     return hou.Vector3(0, 0, 0) * construction_plane.transform()

            The following function will change the normal of the plane:

          > def set_normal(construction_plane, normal_vector):
          >     existing_rotation = hou.Matrix4(construction_plane.transform().extractRotationMatrix3())
          >     rotation = existing_rotation * normal(construction_plane).matrixToRotateTo(normal_vector)
          >     translation = hou.hmath.buildTranslate(origin(construction_plane))
          >     construction_plane.setTransform(rotation * translation)
          >
          > def normal(construction_plane):
          >     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()
          >
          > def origin(construction_plane):
          >     return hou.Vector3(0, 0, 0) * construction_plane.transform()

        """
        return _hou.ConstructionPlane_setTransform(self, matrix)

    def cellSize(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        cellSize(self) -> tuple of float

            Return the x and y sizes (width and height) of one cell in the grid
            of cells. The return value is a tuple of two floats.


        """
        return _hou.ConstructionPlane_cellSize(self)

    def setCellSize(self, size: "_DoubleTuple") -> "void":
        r"""

        setCellSize(self, size)

            Change the x and y sizes (width and height) of each cell in the grid
            of cells. size is a sequence of two floats.

            Changing the size of each cell will change the total size of the
            grid.


        """
        return _hou.ConstructionPlane_setCellSize(self, size)

    def numberOfCells(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        numberOfCells(self) -> tuple of int

            Return the number of cells in the x and y directions of the grid. In
            other words, return the number of columns and rows.


        """
        return _hou.ConstructionPlane_numberOfCells(self)

    def setNumberOfCells(self, number: "_IntTuple") -> "void":
        return _hou.ConstructionPlane_setNumberOfCells(self, number)

    def numberOfCellsPerRulerLine(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        numberOfCellsPerRulerLine(self) -> tuple of int

            Return the number of cells in the x and y directions between ruler
            lines. Ruler lines are darker than the normal lines drawn between
            grid cells.


        """
        return _hou.ConstructionPlane_numberOfCellsPerRulerLine(self)

    def setNumberOfCellsPerRulerLine(self, number: "_IntTuple") -> "void":
        return _hou.ConstructionPlane_setNumberOfCellsPerRulerLine(self, number)


# Register ConstructionPlane in _hou:
_hou.ConstructionPlane_swigregister(ConstructionPlane)


class ContextViewer(PathBasedPaneTab):
    r"""

    hou.ContextViewer

    A class representing a context viewer pane tab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ContextViewer

    def __repr__(self) -> "std::string":
        return _hou.ContextViewer___repr__(self)

    def sceneViewer(self) -> "HOM_SceneViewer *":
        r"""

        sceneViewer(self) -> hou.SceneViewer

            Returns a SceneViewer if the ContextViewer is displaying a scene
            viewer. If not, returns None.


        """
        return _hou.ContextViewer_sceneViewer(self)

    def compositorViewer(self) -> "HOM_CompositorViewer *":
        r"""

        compositorViewer(self) -> hou.CompositorViewer

            Returns a CompositorViewer if the ContextViewer is displaying a
            compositor viewer. If not, returns None.


        """
        return _hou.ContextViewer_compositorViewer(self)

    def findViewport(self, name: "char const *") -> "HOM_GeometryViewport *":
        r"""

        findViewport(self, viewport_name) -> hou.GeometryViewport

            Returns a GeometryViewport with the given viewport_name if the
            ContextViewer is displaying a scene viewer. If not, returns None.


        """
        return _hou.ContextViewer_findViewport(self, name)


# Register ContextViewer in _hou:
_hou.ContextViewer_swigregister(ContextViewer)


class CopNode(Node):
    r"""

    hou.CopNode

    Represents a compositing node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_CopNode

    def __repr__(self) -> "std::string":
        return _hou.CopNode___repr__(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns True if the node's bypass flag is turned on. Returns False
            otherwise.


        """
        return _hou.CopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turns the node's bypass flag on or off. When the bypass flag is on,
            the node will have no effect on the scene. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.CopNode_bypass(self, on)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Returns True if the node's display flag is turned on. Returns False
            otherwise.


        """
        return _hou.CopNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turns the node's display flag on or off. When the display flag is
            on, the node's image will appear in the image viewport. The value of
            the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.CopNode_setDisplayFlag(self, on)

    def isRenderFlagSet(self) -> "bool":
        r"""

        isRenderFlagSet(self) -> bool

            Returns True if the node's render flag is turned on. Returns False
            otherwise.


        """
        return _hou.CopNode_isRenderFlagSet(self)

    def setRenderFlag(self, on: "bool") -> "void":
        r"""

        setRenderFlag(self, on)

            Turns the node's render flag on or off. The render flag controls
            which node in a compositing network will be rendered to or to disk.
            The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.CopNode_setRenderFlag(self, on)

    def isTemplateFlagSet(self) -> "bool":
        r"""

        isTemplateFlagSet(self) -> bool

            Returns True if the node's template flag is turned on. Returns False
            otherwise.


        """
        return _hou.CopNode_isTemplateFlagSet(self)

    def setTemplateFlag(self, on: "bool") -> "void":
        r"""

        setTemplateFlag(self, on)

            Turns the node's template flag on or off. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.CopNode_setTemplateFlag(self, on)

    def isCompressFlagSet(self) -> "bool":
        r"""

        isCompressFlagSet(self) -> bool

            Returns True if the node's compress flag is turned on. Returns False
            otherwise. The compress flag controls whether or not a preview image
            is shown for this node in the Network View.


        """
        return _hou.CopNode_isCompressFlagSet(self)

    def setCompressFlag(self, on: "bool") -> "void":
        r"""

        setCompressFlag(self, on)

            Turns the node's compress flag on or off. If the compress flag is
            True, this node will not show a preview image in the Network View.
            If the compress flag is False, a preview image will be shown in the
            Network View. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.CopNode_setCompressFlag(self, on)

    def planes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        planes(self) -> tuple of strings

            Returns a tuple of plane names in the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_planes(self)

    def components(
        self, plane: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        components(self, plane) -> tuple of str

            Returns a tuple of component names for the specified plane in the
            node's image sequence. The value of the plane argument must be a
            plane name.

            Raises ValueError if plane is None or empty. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the given plane does not
            exist.


        """
        return _hou.CopNode_components(self, plane)

    def depth(self, plane: "char const *") -> "HOM_EnumValue &":
        r"""

        depth(self, plane) -> hou.imageDepth enum value

            Return the data format used to represent one component of one pixel
            in the given image plane.

            For example, if the depth of the \"C\" (color) plane is
            hou.imageDepth.Int8, each of the red, green, and blue components is
            stored as an (unsigned) 8-bit integer, occupying one byte. If, for
            example, it is instead hou.imageDepth.Float32, each of the red,
            green, and blue components is a 32-bit float and occupies 4 bytes
            (12 bytes total for all 3 components combined).


        """
        return _hou.CopNode_depth(self, plane)

    def maskInputIndex(self) -> "int":
        r"""

        maskInputIndex(self) -> int

            Return the input index of the mask input for this node. Return -1 if
            this node type does not provide a mask input.


        """
        return _hou.CopNode_maskInputIndex(self)

    def getPixelByUV(
        self,
        plane: "char const *",
        u: "double",
        v: "double",
        component: "char const *" = None,
        interpolate: "bool" = True,
    ) -> "std::vector< float,std::allocator< float > >":
        r"""

        getPixelByUV(self, plane, u, v, component=None, interpolate=True) ->
        tuple of float

            Returns plane values for a single pixel in the node's image. The
            plane is defined by the plane argument which must be set to the
            plane's name. The pixel is defined by (u, v) coordinates where u and
            v are values between 0.0 and 1.0. If the optional component argument
            is specified, then the value for that particular component is
            returned. Otherwise, all of the plane's component values are
            returned. The value of component should be the component's name
            (i.e. r, g, b, etc.).

            If the (u, v) coordinates do not fall exactly on a pixel, then the
            return values are calculated by linear blending of the values for
            the surrounding pixels. This can be disabled by setting the
            interpolate argument to False, in which case the values of the pixel
            located immediately to the bottom-left of (u, v) are returned.

            Note that the returned values are for the node's image at the
            current frame.

            Raises ValueError if either u or v is outside of the 0.0-1.0 range.
            Raises ValueError if plane is None or empty. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the given plane does not
            exist. Raises hou.OperationFailed if the given component does not
            exist in the plane.


        """
        return _hou.CopNode_getPixelByUV(self, plane, u, v, component, interpolate)

    def getPixelHSVByUV(
        self, u: "double", v: "double", interpolate: "bool" = True
    ) -> "std::vector< float,std::allocator< float > >":
        r"""

        getPixelHSVByUV(self, u, v, interpolate=True) -> tuple of float

            Returns a 3-tuple containing the hue, saturation and value for a
            single pixel in the node's image. The pixel is defined by (u, v)
            coordinates where u and v are values between 0.0 and 1.0.

            If the (u, v) coordinates do not fall exactly on a pixel, then the
            return values are calculated by linear blending of the values for
            the surrounding pixels. This can be disabled by setting the
            interpolate argument to False, in which case the values of the pixel
            located immediately to the bottom-left of (u, v) are returned.

            Note that the returned hue, saturation and value are for the node's
            image at the current frame.

            Raises ValueError if either u or v is outside of the 0.0-1.0 range.
            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_getPixelHSVByUV(self, u, v, interpolate)

    def getPixelLuminanceByUV(
        self, u: "double", v: "double", interpolate: "bool" = True
    ) -> "float":
        r"""

        getPixelLuminanceByUV(self, u, v, interpolate=True) -> float

            Returns the luminance value for a single pixel in the node's image.
            The pixel is defined by (u, v) coordinates where u and v are values
            between 0.0 and 1.0.

            If the (u, v) coordinates do not fall exactly on a pixel, then the
            luminance is calculated by linear blending of the luminance values
            for the surrounding pixels. This can be disabled by setting the
            interpolate argument to False, in which case the luminance of the
            pixel located immediately to the bottom-left of (u, v) is returned.

            Note that the returned luminance value is for the node's image at
            the current frame.

            Raises ValueError if either u or v is outside of the 0.0-1.0 range.
            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_getPixelLuminanceByUV(self, u, v, interpolate)

    def allPixels(
        self, *args, **kwargs
    ) -> "std::vector< float,std::allocator< float > >":
        r"""

        allPixels(self, plane=\"C\", component=None, interleaved=True, time=-1.0)
        -> tuple of float

            Return a tuple of floats containing all pixel values for a
            particular image plane. The pixels in the bottom scanline of the
            image are first in the result, followed by the second-last scanline,
            etc. Floating point values in the color plane (C), for example, are
            typically in the range 0.0 to 1.0.


            plane
                The name of the image plane to return. All images have C (color)
                and A (alpha) planes. Deep raster images may contain other
                planes, such as Pz (depth), N (normal), etc.

            component
                A particular subcomponent of the plane. For example, for the C
                plane you could specify one of the r, g, or b subcomponents.
                Specify None to indicate all components.

            interleaved
                Whether the different components of the plane are interleaved in
                the result. For example, if the plane is C, the interleaved
                result would be organized as rgbrgbrgb... while the
                uninterleaved result would be rrr...ggg...bbb.... This parameter
                has no effect when a particular component is specified.

            time
                The time at which to cook the COP node. If this value is
                negative, Houdini uses the current time.

                Note that this argument does not apply if allPixels is called
                from a Python COP that is cooking. In that case allPixels
                evaluates at the current cooking time.

            This method does not accept a depth parameter like allPixelsAsString
            does. The values are converted to floating point data, regardless of
            the actual depth of the image plane.

            Raises hou.OperationFailed if the time argument is set to a value
            greater than or equal to 0.0 and allPixels is called from a cooking
            Python COP.


        """
        return _hou.CopNode_allPixels(self, *args, **kwargs)

    def allPixelsAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        allPixelsAsString(self, plane=\"C\", component=None, interleaved=True,
        time=-1.0, depth=None) -> str for Python 2, bytes for Python 3

            Return a binary string representation of the floats containing all
            the values of all voxels. This method is faster than
            hou.CopNode.allPixels, and you can use the array module to convert
            the string into a Python sequence. Note that this method returns
            binary float data, so there are 4 bytes per R, G, and B component,
            not 1 byte.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            If depth is hou.imageDepth.Float32, this method provides a faster
            implementation of the following:

          > import array
          > def allPixelsAsString(self):
          >     return array.array(\"f\", self.allPixels()).tostring()

            If depth is None and this method is called from the code
            implementing a Python COP to get an input plane, the depth will be
            the same as the plane's native depth. If depth is None and this
            method is called from outside a Python COP, the depth will be
            hou.imageDepth.Float32. Otherwise, if depth is a hou.imageDepth
            enumerated value the result will be converted to the specified
            depth.

            See hou.CopNode.allPixels for more information. See also
            hou.Volume.setVoxelSliceFromString.

            Raises hou.OperationFailed if the time argument is set to a value
            greater than or equal to 0.0 and allPixelsAsString is called from a
            cooking Python COP.


        """
        return _hou.CopNode_allPixelsAsString(self, *args, **kwargs)

    def setPixelsOfCookingPlane(
        self,
        values: "_FloatTuple",
        component: "char const *" = None,
        interleaved: "bool" = True,
        flip_vertically: "bool" = False,
    ) -> "void":
        r"""

        setPixelsOfCookingPlane(self, values, component=None, interleaved=True,
        flip_vertically=False)

            Set the pixels of the plane being cooked by the currently-running
            Python COP.


            values
                A sequence of floats, organized with the contents of the bottom
                scanline first.

                If component is None, the length of the sequence of floats must
                be the number of pixels in the image times the number of
                components. Otherwise, it must be the number of pixels in the
                image.

            component
                Either the name of one component in the plane being cooked, or
                None. If a component name is given, values will contain only the
                values for that component. Otherwise, it will contain the values
                for all components of all pixels in the plane.

            interleaved
                If component is None and interleaved is True, values is contains
                the first component of the first pixel, followed by the second
                component of the first pixel, until the last component of the
                first pixel, then the first component of the second pixel, etc.
                If it is False, values contains all the values of the first
                component for all pixels, followed by all the values of the
                second component, etc.

                For example, if the plane is C and interleaved is True, the
                values will be organized as rgbrgbrgb.... If it is not
                interleaved, it will be organized as rrr...ggg...bbb....

                If component is not None, this parameter is ignored.

            flip_vertically
                The default value for this parameter is False, so the first
                scanline in the values array is assumed to be the bottom
                scanline. If flip_vertically is True, the input values are
                assumed to oriented starting at the top scanline.

            If you call this method from outside the cook function in a Python
            COP, raises hou.OperationFailed.

            See also hou.CopNode.allPixels and
            hou.CopNode.setPixelsOfCookingPlaneFromString. Also see the HOM
            cookbook and the Python COP documentation for examples.


        """
        return _hou.CopNode_setPixelsOfCookingPlane(
            self, values, component, interleaved, flip_vertically
        )

    def imageBounds(
        self, *args, **kwargs
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        imageBounds(self, plane=\"C\") -> tuple of int

            Returns the x and y boundaries of the given plane in the form of
            (xmin, ymin, xmax, ymax). The value of the plane argument is the
            plane name. By default, the image bounds of the color plane is
            returned.

            Note that the image bounds is not the same as the image resolution.
            For example, the image bounds for a Font COP is the bounding
            rectangle around the displayed letters while the resolution is the
            size of the node's image.

            Note that the returned image bounds is for the current frame.

            Raises ValueError if plane is None or empty. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the given plane does not
            exist.


        """
        return _hou.CopNode_imageBounds(self, *args, **kwargs)

    def xRes(self) -> "int":
        r"""

        xRes(self)

            Returns the x-resolution of the node's image for the current frame.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_xRes(self)

    def yRes(self) -> "int":
        r"""

        yRes(self)

            Returns the y-resolution of the node's image for the current frame.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_yRes(self)

    def sequenceStartFrame(self) -> "double":
        r"""

        sequenceStartFrame(self) -> float

            Returns the start frame in the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_sequenceStartFrame(self)

    def sequenceEndFrame(self) -> "double":
        r"""

        sequenceEndFrame(self) -> float

            Returns the last frame in the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_sequenceEndFrame(self)

    def sequenceFrameLength(self) -> "double":
        r"""

        sequenceFrameLength(self) -> float

            Returns the frame length of the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
        return _hou.CopNode_sequenceFrameLength(self)

    def isSingleImage(self) -> "bool":
        r"""

        isSingleImage(self) -> bool

            Returns True if the node has a single image. Returns False if the
            node has an image sequence.


        """
        return _hou.CopNode_isSingleImage(self)

    def saveImage(self, *args) -> "void":
        r"""

        saveImage(self, file_name, frame_range=())

            Saves the node's cooked image sequence to disk. For multiple images,
            make sure that the file_name argument contains $F so that the
            sequence is written to multiple files.

            The optional frame_range argument can be specified to write only a
            subset of frames in the image sequence. frame_range must be a
            2-tuple or a 3-tuple, where the first element is the start frame,
            the second element is the end frame and the third element is the
            frame increment. If frame_range is not given, then every frame in
            the image sequence is saved to disk.

            Raises ValueError if the frame increment in frame_range is 0. Raises
            hou.InvalidSize if the size of frame_range is not 0, 2 or 3. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the image could not be
            saved to disk.


        """
        return _hou.CopNode_saveImage(self, *args)

    def hasMetaData(self, metadata_name: "char const *") -> "bool":
        r"""

        hasMetaData(self, metadata_name) -> bool

            Returns True if the metadata with name metadata_name exists, False
            otherwise.


        """
        return _hou.CopNode_hasMetaData(self, metadata_name)

    def getMetaDataInt(self, metadata_name: "char const *", index: "int" = 0) -> "int":
        r"""

        getMetaDataInt(self, metadata_name, index=0) -> int

            Returns numeric metadata as a single integer. In the case of
            vectors, matrices and arrays, index indicates the component to
            fetch. Floating point metadata will be truncated.


        """
        return _hou.CopNode_getMetaDataInt(self, metadata_name, index)

    def getMetaDataFloat(
        self, metadata_name: "char const *", index: "int" = 0
    ) -> "double":
        r"""

        getMetaDataFloat(self, metadata_name, index=0) -> double

            Returns numeric metadata as a single double precision value. In the
            case of vectors, matrices and arrays, index indicates the component
            to fetch.


        """
        return _hou.CopNode_getMetaDataFloat(self, metadata_name, index)

    def getMetaDataString(self, metadata_name: "char const *") -> "std::string":
        r"""

        getMetaDataString(self, metadata_name) -> str

            Returns string metadata from metadata_name.


        """
        return _hou.CopNode_getMetaDataString(self, metadata_name)

    def getMetaDataIntArray(
        self, metadata_name: "char const *"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        getMetaDataIntArray(self, metadata_name) -> tuple of int

            Returns numeric metadata as an array of integers. Floating point
            metadata values will be truncated.


        """
        return _hou.CopNode_getMetaDataIntArray(self, metadata_name)

    def getMetaDataFloatArray(
        self, metadata_name: "char const *"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        getMetaDataFloatArray(self, metadata_name) -> tuple of double

            Returns numeric metadata as an array of double-precision values.


        """
        return _hou.CopNode_getMetaDataFloatArray(self, metadata_name)

    def setPixelsOfCookingPlaneFromString(
        self,
        values: "InterpreterObject",
        component: "char const *" = None,
        interleaved: "bool" = True,
        depth: "EnumValue" = None,
        flip_vertically: "bool" = False,
    ) -> "void":
        r"""

        setPixelsOfCookingPlaneFromString(self, values, component=None,
        interleaved=True, depth=None, flip_vertically=False)

            Set the pixels of the plane being cooked by the currently-running
            Python COP. This method is like hou.CopNode.setPixelsOfCookingPlane
            except values contains a binary string representation of the data
            instead of a sequence of floats. Consequently, this method is
            faster.

            The values binary string must be a bytes object in Python 3 and a
            str object in Python 2. See HOM binary data for more information.

            The depth parameter specifies how to interpret the values in the
            binary string, and is a hou.imageDepth enumerated value. If depth is
            None, the depth is assumed to be in the depth of the plane being
            cooked. Note that, by specifying depth explicitly, you can provide
            data in any depth, regardless of the actual depth stored by the COP.

            Note that this method can accept more types that just a string: it
            can receive any Python object that supports the buffer interface. In
            particular, arrays from the array and numpy Python modules are
            supported, so there is no need to first construct strings from those
            arrays.

            See hou.CopNode.setPixelsOfCookingPlane and
            hou.CopNode.allPixelsAsString for more information.


        """
        return _hou.CopNode_setPixelsOfCookingPlaneFromString(
            self, values, component, interleaved, depth, flip_vertically
        )


# Register CopNode in _hou:
_hou.CopNode_swigregister(CopNode)


class crowds(object):
    r"""

    hou.crowds

    Crowd-related functions.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_crowds

    def __repr__(self) -> "std::string":
        return _hou.crowds___repr__(self)

    def addBlendshapeInputs(
        self,
        base_shape_geo: "Geometry",
        shapes: "_AgentShapeTuple",
        channel_names: "_StringTuple",
    ) -> "void":
        r"""

        addBlendshapeInputs(self, base_shape_geo, shapes, channel_names)

            Adds blendshape inputs to a shape's geometry. This sets up the
            required detail attributes (blendshape_shapenames and
            blendshape_channels) on the base shape's geometry. For an existing
            agent shape, blendshape inputs can also be added using
            hou.AgentShape.addBlendshapeInputs.


            base_shape_geo
                A modifiable hou.Geometry for the base shape.

            shapes
                A hou.AgentShape sequence to add as blendshape inputs.
                hou.AgentShapeLibrary.addShape should be called separately to
                add these shapes to the shape library.

            channel_names
                A str sequence specifying the channel name to use for each
                shape. Raises hou.InvalidSize if the length does not match the
                shapes list.


        """
        return _hou.crowds_addBlendshapeInputs(
            self, base_shape_geo, shapes, channel_names
        )

    def addInBetweenShapes(
        self,
        primary_shape_geo: "Geometry",
        shapes: "_AgentShapeTuple",
        weights: "_DoubleTuple",
    ) -> "void":
        r"""

        addInBetweenShapes(self, primary_shape_geo, shapes, weights)

            Adds in-between shapes to a blendshape input. This sets up the
            required detail attributes (blendshape_shapenames and
            blendshape_inbetweenweights) on the primary shape's geometry. For an
            existing agent shape, in-between shapes can also be added using
            hou.AgentShape.addInBetweenShapes.


            primary_shape_geo
                A modifiable hou.Geometry for the primary shape.

            shapes
                A hou.AgentShape sequence to add as in-between shapes.
                hou.AgentShapeLibrary.addShape should be called separately to
                add these shapes to the shape library.

            weights
                A float sequence specifying the weight that each in-between
                shape is applied at. Raises hou.InvalidSize if the length does
                not match the shapes list.


        """
        return _hou.crowds_addInBetweenShapes(self, primary_shape_geo, shapes, weights)

    def setBlendshapeDeformerParms(self, *args, **kwargs) -> "void":
        r"""

        setBlendshapeDeformerParms(self, base_shape_geo, attribs=\"P N\",
        point_id_attrib=\"id\", prim_id_attrib=\"id\")

            Adds attributes to the geometry to specify parameters for the
            blendshapes deformer. This creates the following detail attributes:
            blendshape_attribs, blendshape_ptidattr, and blendshape_primidattr.
            For an existing agent shape, the deformer parameters can be set
            using hou.AgentShape.setBlendshapeDeformerParms.


            attribs
                Specifies a list or pattern of attributes to be blended by the
                deformer.

            point_id_attrib
                Specifies the name of a point attribute used to match up points
                between the different blendshape inputs.

            prim_id_attrib
                Specifies the name of a primitive attribute used to match up
                points between the different blendshape inputs.


        """
        return _hou.crowds_setBlendshapeDeformerParms(self, *args, **kwargs)

    def findAgentDefinitions(
        self, geo: "Geometry", group_str: "char const *" = None
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentDefinition >,std::allocator< HOM_ElemPtr< HOM_AgentDefinition > > >":
        r"""

        findAgentDefinitions(geometry, group = \"\") -> tuple of
        hou.AgentDefinition

            Returns a list of the unique agent definitions in the geometry.

            This is equivalent to the following code, but is significantly
            faster.

          > definitions = set()
          > for prim in geometry.globPrims(group):
          >     if prim.type() == hou.primType.Agent:
          >         definitions.add(prim.definition())
          >
          > return definitions

            geometry
                A hou.Geometry.

            group
                An optional group string to filter which primitives are
                inspected. The pattern format is the same as the format used for
                group parameters on SOP nodes.


        """
        return _hou.crowds_findAgentDefinitions(self, geo, group_str)

    def replaceAgentDefinitions(
        self,
        geo: "Geometry",
        defn_map: "_AgentDefnMap",
        group_str: "char const *" = None,
    ) -> "void":
        r"""

        replaceAgentDefinitions(geometry, new_definition_map, group = \"\")

            Replaces agent definitions in the geometry with new versions. This
            is a useful convenience function when modifying each agent
            definition in the geometry, particularly when also using
            hou.crowds.findAgentDefinitions.

            For example:

          > defns = hou.crowds.findAgentDefinitions(geo, group)
          > new_defn_map = {}
          > for defn in defns:
          >     new_defn = defn.freeze()
          >     new_defn_map[defn] = new_defn
          >
          >     # Add a clip to the new agent definition.
          >     new_defn.addClip(...)
          >
          > # Switch all agents in the group to their respective new agent definition.
          > hou.crowds.replaceAgentDefinitions(geo, new_defn_map, group)

            geometry
                A modifiable hou.Geometry.

            new_definition_map
                A dictionary mapping each hou.AgentDefinition to a
                hou.AgentDefinition that it should be replaced by.

            group
                An optional group string to filter which primitives are
                modified. The pattern format is the same as the format used for
                group parameters on SOP nodes.


        """
        return _hou.crowds_replaceAgentDefinitions(self, geo, defn_map, group_str)

    def computeLocalTransforms(
        self,
        rig: "AgentRig",
        world_xforms: "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > > const &",
    ) -> "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > >":
        r"""

        computeLocalTransforms(self, rig, xforms) -> tuple of hou.Matrix4

            Converts transforms from world space to local space using the
            provided rig.


            rig
                A hou.AgentRig, which specifies the transform hierarchy.

            xforms
                A sequence of hou.Matrix4, with a world space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
        return _hou.crowds_computeLocalTransforms(self, rig, world_xforms)

    def computeWorldTransforms(
        self,
        rig: "AgentRig",
        local_xforms: "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > > const &",
    ) -> "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > >":
        r"""

        computeWorldTransforms(self, rig, xforms) -> tuple of hou.Matrix4

            Converts transforms from local space to world space using the
            provided rig.


            rig
                A hou.AgentRig, which specifies the transform hierarchy.

            xforms
                A sequence of hou.Matrix4, with a local space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
        return _hou.crowds_computeWorldTransforms(self, rig, local_xforms)

    def computeRotationLimits(
        self,
        rig: "AgentRig",
        clips: "_AgentClipTuple",
        xform_idx: "int",
        parent_xform_idx: "int",
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        computeRotationLimits(rig, clips, transform, parent_transform) -> dict
        of str to values

            Computes rotation limits for the specified joint based on the range
            of motion in the provided clips.

            The return value is a dictionary with the following keys:

          * anchor_pos: A hou.Vector3 containing the cone's anchor position.

          * rotation: A hou.Vector3 containing the cone's orientation.

          * child_rotation: A hou.Vector3 containing the child's orientation.

          * twist_limits: A hou.Vector2 containing the rotation limits for the
            twist axis.

          * up_limits: A hou.Vector2 containing the rotation limits for the up
            axis.

          * out_limits: A hou.Vector2 containing the rotation limits for the out
            axis.


            rig
                A hou.AgentRig.

            clips
                A list of hou.AgentClip.

            transform
                Index of a transform in the agent's rig.

            parent_transform
                Index of the parent transform in the agent's rig.


        """
        return _hou.crowds_computeRotationLimits(
            self, rig, clips, xform_idx, parent_xform_idx
        )

    def shapeDeformers(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_AgentShapeDeformer >,std::allocator< HOM_ElemPtr< HOM_AgentShapeDeformer > > >":
        r"""

        shapeDeformers() -> tuple of hou.AgentShapeDeformer

            Returns a list of the available shape deformers.


        """
        return _hou.crowds_shapeDeformers(self)

    def findShapeDeformer(self, name: "char const *") -> "HOM_AgentShapeDeformer *":
        r"""

        findShapeDeformer(name) -> hou.AgentShapeDeformer

            Finds the shape deformer with the specified name, or None if no such
            deformer exists.


        """
        return _hou.crowds_findShapeDeformer(self, name)


# Register crowds in _hou:
_hou.crowds_swigregister(crowds)


class DataParmTemplate(ParmTemplate):
    r"""

    hou.DataParmTemplate

    Describes a parameter tuple containing data values.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, num_components, look=hou.parmLook.Regular,
        naming_scheme=hou.parmNamingScheme.XYZW, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new DataParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
        _hou.DataParmTemplate_swiginit(self, _hou.new_DataParmTemplate(*args, **kwargs))

    __swig_destroy__ = _hou.delete_DataParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.DataParmTemplate___repr__(self)

    def dataParmType(self) -> "HOM_EnumValue &":
        r"""

        dataParmType(self) -> hou.dataParmType enum value

            Return the type of this data parameter. This type determines whether
            the parameter stores geometry data or a JSON map structure.

            See hou.dataParmType for more information.


        """
        return _hou.DataParmTemplate_dataParmType(self)

    def setDataParmType(self, data_type: "EnumValue") -> "void":
        return _hou.DataParmTemplate_setDataParmType(self, data_type)

    def defaultExpression(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.

            For example, suppose this parm template is named t, the naming
            scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
            3.0), the default expression is ($F, hou.frame(), ) and the default
            expression language is (hou.scriptLanguage.Hscript,
            hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
            corresponding parm tuple instance on a node would be named t and
            would contain parameters tx, ty, tz. When the node is created, tx
            would have a default Hscript expression of $F, ty would have a
            default Python expression of hou.frame(), and tz would have a
            default value of 3.0.


        """
        return _hou.DataParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "_StringTuple") -> "void":
        r"""

        setDefaultExpression(self, default_expression)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.DataParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
        return _hou.DataParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
        return _hou.DataParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "_EnumTuple"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """
        return _hou.DataParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )


# Register DataParmTemplate in _hou:
_hou.DataParmTemplate_swigregister(DataParmTemplate)


class DataTree(PaneTab):
    r"""

    hou.DataTree

    Represents a Data Tree panetab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_DataTree

    def __repr__(self) -> "std::string":
        return _hou.DataTree___repr__(self)

    def treeTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        treeTypes(self) -> tuple of str

            Returns a tuple of strings that represent the different tree types
            that can be shown in the Data Tree pane.


        """
        return _hou.DataTree_treeTypes(self)

    def treeType(self) -> "std::string":
        r"""

        treeType(self) -> str

            Returns the current tree type being shown in the Data Tree. This
            function may return an empty string if no tree type has been chosen
            yet.


        """
        return _hou.DataTree_treeType(self)

    def setTreeType(self, tree_type: "std::string const &") -> "bool":
        r"""

        setTreeType(self, tree_type) -> bool

            Changes the tree type being displayed in the Data Tree. Valid values
            are any strings returned by the treeTypes function. Returns True if
            the tree type was successfully changed, otherwise False.


        """
        return _hou.DataTree_setTreeType(self, tree_type)

    def currentPath(self) -> "std::string":
        r"""

        currentPath(self) -> str

            Returns the path to the current node in the tree.


        """
        return _hou.DataTree_currentPath(self)

    def clearCurrentPath(self) -> "void":
        r"""

        clearCurrentPath(self) -> str

            Clears the node(s) currently selected in the tree.


        """
        return _hou.DataTree_clearCurrentPath(self)

    def setCurrentPath(
        self,
        path: "std::string const &",
        multi_select: "bool" = False,
        index: "int" = -1,
    ) -> "void":
        r"""

        setCurrentPath(self, path, multi=False, index=-1)

            Sets the currently selected node in the tree. If the provided path
            does not match a node in the tree, the tree will still attempt to
            set the current node to the best possible match of the provided
            path.

            If multi is set to True, the previous selection will not be cleared
            before selecting the new the node. This allows multiple nodes to be
            selected in the tree.


        """
        return _hou.DataTree_setCurrentPath(self, path, multi_select, index)

    def setCurrentPaths(self, paths: "_StringTuple", expanded: "bool") -> "void":
        r"""

        setCurrentPaths(self, paths, expand)

            Selects mutliple nodes in the data tree based on the array of paths
            passed in. If the expand flag is set to True the tree nodes will be
            expanded after selection.


        """
        return _hou.DataTree_setCurrentPaths(self, paths, expanded)

    def setTreeExpanded(self, expanded: "bool") -> "void":
        r"""

        setTreeExpanded(self, expanded)

            Recursively sets the expanded state of the entire data tree.


        """
        return _hou.DataTree_setTreeExpanded(self, expanded)

    def setCurrentNodeExpanded(self, expanded: "bool") -> "void":
        r"""

        setCurrentNodeExpanded(self, expanded)

            Sets the expanded state of the currently selected node in the tree.
            If there is no selected node the method has no effect on the tree.


        """
        return _hou.DataTree_setCurrentNodeExpanded(self, expanded)


# Register DataTree in _hou:
_hou.DataTree_swigregister(DataTree)


class Desktop(object):
    r"""

    hou.Desktop

    Class representing a Houdini desktop (a pane layout).

    A desktop contains one or more panes. Each pane contains one or more
    pane tabs of various types (scene viewer, parameters, network editor,
    etc.) The main desktop window can be split horizontally or vertically
    into two panes, and each pane can itself be split horizontally or
    vertically.

    Note that a floating panel also contains one or more panes and a
    floating panel may optionally be attached to a desktop.

    The methods in this class that return pane tabs, panes, and floating
    panels only return those objects that are attached to (i.e. saved with)
    the desktop. To access all the visible pane tabs, panes, and floating
    panels, including those not attached to any desktop, use the functions
    in hou.ui.

    See also hou.ui.curDesktop, hou.ui.desktops, hou.Pane, hou.PaneTab, and
    hou.FloatingPanel.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Desktop

    def __repr__(self) -> "std::string":
        return _hou.Desktop___repr__(self)

    def panes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Pane >,std::allocator< HOM_ElemPtr< HOM_Pane > > >":
        r"""

        panes(self) -> tuple of hou.Pane

            Return the panes inside this desktop. Note that the result includes
            panes in floating panels as long as they are attached to the
            desktop.

            The following function will return all visible panes, regardless of
            whether or not they are attached to a desktop:

          > def allPanes():
          >     '''Return a tuple of all visible panes, regardless of whether or not
          >        they are attached to a desktop.'''
          >     # Loop through all the pane tabs and add each tab's pane to the result
          >     # if it's not already there.  Note that the only way to uniquely
          >     # identify a pane is using its id.
          >     ids_to_panes = {}
          >     for pane_tab in hou.ui.paneTabs():
          >         pane = pane_tab.pane()
          >         if pane.id() not in ids_to_panes:
          >             ids_to_panes[pane.id()] = pane
          >     return ids_to_panes.values()

        """
        return _hou.Desktop_panes(self)

    def paneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        paneTabs(self) -> tuple of hou.PaneTab

            Return the pane tabs that are contained in this desktop or are in
            floating panels attached to this desktop.

            This method does not return floating pane tabs that are not attached
            to this desktop. Use hou.ui.paneTabs to get all the visible pane
            tabs, regardless of whether they are attached to this desktop.


        """
        return _hou.Desktop_paneTabs(self)

    def currentPaneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        currentPaneTabs(self) -> tuple of hou.PaneTab

            Return the pane tabs that are contained in this desktop or are in
            floating panels attached to this desktop and are currently selected
            in their containing panes.

            This method does not return floating pane tabs that are not attached
            to this desktop. Use hou.ui.currentPaneTabs to get all the selected
            pane tabs, regardless of whether they are attached to this desktop.


        """
        return _hou.Desktop_currentPaneTabs(self)

    def floatingPaneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        floatingPaneTabs(self) -> tuple of hou.PaneTab

            Return all the pane tabs in floating panels that are attached to
            this desktop.


        """
        return _hou.Desktop_floatingPaneTabs(self)

    def paneTabOfType(self, type: "EnumValue", index: "int" = 0) -> "HOM_PaneTab *":
        r"""

        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return the pane tab with the desired type. If no such tab
            exists, return None. Like hou.Desktop.paneTabs, this method searches
            pane tabs in the desktop or in floating panels attached to the
            desktop.

            Use hou.ui.paneTabOfType to search all the visible pane tabs,
            regardless of whether they are attached to this desktop.


            type
                A hou.paneTabType enumerated variable.

            index
                If there are multiple tabs with the desired type, this parameter
                determines which one is returned. Use index=0 to return the
                first found tab, index=1 to return the second found tab, etc. By
                default, index is 0.

            This method can be approximately implemented as follows:

          > def paneTabOfType(self, tab_type, index=0):
          >     pane_tabs = [t for t in self.paneTabs() if t.type() == tab_type]
          >
          >     if max(index, 0) > len(pane_tabs):
          >         return None
          >     return pane_tabs[max(index, 0)]

        """
        return _hou.Desktop_paneTabOfType(self, type, index)

    def findPane(self, pane_id: "int") -> "HOM_Pane *":
        r"""

        findPane(self, pane_id) -> hou.Pane or None

            Return the pane with the given unique id, or None if no such pane
            exists. Like hou.Desktop.panes, this method searches panes in the
            desktop or in floating panels attached to the desktop.

            Use hou.ui.findPane to search all the visible panes, regardless of
            whether they are attached to this desktop.


        """
        return _hou.Desktop_findPane(self, pane_id)

    def findPaneTab(self, name: "char const *") -> "HOM_PaneTab *":
        r"""

        findPaneTab(self, name) -> hou.PaneTab or None

            Return the pane tab with the given name, or None if no such tab
            exists. Like hou.Desktop.paneTabs, this method searches pane tabs in
            the desktop or in floating panels attached to the desktop.

            The name may optionally be prefixed by the desktop name and a
            period.

            Use hou.ui.findPaneTab to search all the visible pane tabs,
            regardless of whether they are attached to this desktop.


        """
        return _hou.Desktop_findPaneTab(self, name)

    def createFloatingPaneTab(self, *args, **kwargs) -> "HOM_PaneTab *":
        r"""

        createFloatingPaneTab(self, pane_tab_type, position=(), size=(),
        python_panel_interface=None, immediate=False) -> hou.PaneTab

            Create and return a new floating window containing a single pane
            tab. Note that this method creates a floating panel with a single
            pane tab, and the graphical interface to add more tabs or split the
            pane inside the panel is not exposed.


            pane_tab_type
                A hou.paneTabType enumerated variable.

            position
                A tuple of two floats specifying the X and Y positions of the
                new window, respectively. The window will open near this
                position, not necessarily exactly at this position. If this
                value is an empty tuple, Houdini will choose a default location.

            size
                A tuple of two floats specifying the width and height of the new
                window, respectively. If this value is an empty tuple, Houdini
                will choose a default size.

            python_panel_interface
                The name of the Python Panel interface to be displayed in the
                floating pane tab. Specifying the interface name additionally
                hides the Python Panel toolbar. If python_panel_interface is
                None or points to an interface that does not exist then the
                default Python Panel pane tab is displayed along with the
                toolbar.

                This argument is ignored if pane_tab_type is not set to
                hou.paneTabType.PythonPanel.

            immediate
                Open the window immediately to help setting the window position
                correctly.

            Also note that the floating panel containing the new pane tab does
            not contain any panes: calling hou.PaneTab.pane on the pane tab
            returns None, and calling hou.FloatingPanel.panes on its floating
            panel returns an empty tuple. See hou.FloatingPanel for more
            information on these stripped down floating panels.

            See also hou.Desktop.createFloatingPanel.

            The following example function takes a hou.Node and opens a floating
            parameter pane pinned to that node.

          > def openParmPane(node):
          >     '''Open a floating parameter pane for a particular node.'''
          >     pane_tab = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.Parm)
          >     pane_tab.setCurrentNode(node)
          >     pane_tab.setPin(True)
          >     return pane_tab

        """
        return _hou.Desktop_createFloatingPaneTab(self, *args, **kwargs)

    def createFloatingPane(self, *args) -> "HOM_PaneTab *":
        return _hou.Desktop_createFloatingPane(self, *args)

    def floatingPanels(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_FloatingPanel >,std::allocator< HOM_ElemPtr< HOM_FloatingPanel > > >":
        r"""

        floatingPanels(self) -> tuple of hou.FloatingPanel

            Return all the floating panels attached to this desktop.

            Use hou.ui.floatingPanels to get all the visible floating panels,
            including those not attached to this desktop.

            See also hou.Desktop.floatingPaneTabs.


        """
        return _hou.Desktop_floatingPanels(self)

    def createFloatingPanel(self, *args, **kwargs) -> "HOM_FloatingPanel *":
        r"""

        createFloatingPanel(self, pane_tab_type, position=(), size=(),
        python_panel_interface=None, immediate=False) -> hou.FloatingPanel

            Create a floating panel and return it. The returned floating panel
            contains one pane which contains one pane tab of the desired type.

            See hou.Desktop.createFloatingPaneTab for a description of the
            parameters. This method differs from createFloatingPaneTab in two
            ways: First, it returns the floating panel instead of the pane tab.
            Second, the floating panel that is created from this method is not
            locked down, and the user can add more pane tabs and split the
            panes.

            The following example creates a floating panel with a parameters
            pane tab and a channel viewer (motion viewer) pane tab:

          > panel = hou.ui.curDesktop().createFloatingPanel(hou.paneTabType.Parm)
          > pane1 = panel.panes()[0]
          > pane2 = pane1.splitVertically()
          > pane2.tabs()[0].setType(hou.paneTabType.ChannelViewer)

        """
        return _hou.Desktop_createFloatingPanel(self, *args, **kwargs)

    def paneUnderCursor(self) -> "HOM_Pane *":
        r"""

        paneUnderCursor(self)

            Return the hou.Pane object located under the mouse cursor. Return
            None if no pane is located under the mouse cursor.

            This method does not search floating panes that are not attached to
            this desktop. Use hou.ui.paneUnderCursor to search all the visible
            panes, regardless of whether they are attached to this desktop.


        """
        return _hou.Desktop_paneUnderCursor(self)

    def paneTabUnderCursor(self) -> "HOM_PaneTab *":
        r"""

        paneTabUnderCursor(self)

            Similar to hou.Desktop.paneUnderCursor but return the hou.PaneTab
            object instead located under the mouse cursor. Return None if no
            pane tab is located under the mouse cursor.

            This method does not search floating pane tabs that are not attached
            to this desktop. Use hou.ui.paneTabUnderCursor to search all the
            visible pane tabs, regardless of whether they are attached to this
            desktop.


        """
        return _hou.Desktop_paneTabUnderCursor(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the desktop's name.

            Each desktop has a unique name. The desktop's name cannot be changed
            through either the scripting interface or through Houdini.


        """
        return _hou.Desktop_name(self)

    def shelfDock(self) -> "HOM_ShelfDock *":
        r"""

        shelfDock(self) -> hou.ShelfDock

            Return the shelf dock for the current desktop.


        """
        return _hou.Desktop_shelfDock(self)

    def displaySideHelp(self, show: "bool" = True) -> "HOM_PaneTab *":
        r"""

        displaySideHelp(self, show=True) -> hou.PaneTab

            Show or hide the side help pane.

            If show is set to True (default) this method displays the help pane
            and returns a help browser pane tab. If set to False then this
            method hides the help browser pane at the side of the desktop and
            returns None.


        """
        return _hou.Desktop_displaySideHelp(self, show)

    def displayHelp(self, node_type: "NodeType") -> "void":
        r"""

        displayHelp(self, node_type)

            Loads the help for the specified node type in the last opened help
            browser pane tab. Creates a help browser pane tab if no such pane
            tab already exists.


        """
        return _hou.Desktop_displayHelp(self, node_type)

    def displayHelpPath(self, help_path: "char const *") -> "void":
        r"""

        displayHelpPath(self, help_path)

            Loads the help for the specified help path in the last opened help
            browser pane tab. Creates a help browser pane tab if no such pane
            tab already exists. The path can either be a Houdini help URL (i.e.
            op:Sop/copy, tool:curve) or a raw help path (i.e. /nodes/sop/copy,
            shelf/curve).


        """
        return _hou.Desktop_displayHelpPath(self, help_path)

    def displayHelpPyPanel(self, interface_name: "char const *") -> "void":
        r"""

        displayHelpPyPanel(self, interface_name)

            Loads the help for the python panel with the specified name in the
            last opened help browser pane tab. Creates a help browser pane tab
            if no such pane tab already exists.

            Raises HOM_Error if the interface name is invalid.


        """
        return _hou.Desktop_displayHelpPyPanel(self, interface_name)

    def setAsCurrent(self) -> "void":
        r"""

        setAsCurrent(self)

            Make this desktop the currently selected one. See also
            hou.ui.desktops.

            This example changes to the animate desktop:

          > desktops_dict = dict((d.name(), d) for d in hou.ui.desktops())
          > desktops_dict['Animate'].setAsCurrent()

        """
        return _hou.Desktop_setAsCurrent(self)


# Register Desktop in _hou:
_hou.Desktop_swigregister(Desktop)


class Dialog(object):
    r"""

    hou.Dialog

    Class representing a Houdini dialog.

    This class represents only dialogs created by hou..ui.createDialog.

    Custom dialogs can be created with Houdini's User Interface Script
    Language. An overview of the language can be found in the Houdini
    Development Kit (HDK) documentation, specifically in the Houdini User
    Interface -> The .ui Script Language section.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Dialog

    def __repr__(self) -> "std::string":
        return _hou.Dialog___repr__(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Delete this dialog.

            If you call methods on a Dialog instance after it has been
            destroyed, Houdini will raise hou.ObjectWasDeleted.


        """
        return _hou.Dialog_destroy(self)

    def setValue(self, *args) -> "void":
        r"""

        setValue(self, name, value)

            Set the value of the specified UI variable.

            Raises TypeError if either name or value is None. Raises
            hou.OperationFailed if no UI variable with the specified name
            exists.


        """
        return _hou.Dialog_setValue(self, *args)

    def enableValue(self, name: "char const *", onoff: "bool") -> "void":
        r"""

        enableValue(self, name, onoff)

            Enable or disable the specified UI variable.

            Set onoff to True to enable the variable. Set onoff to False to
            disable the variable.

            Raises TypeError if either name is None. Raises hou.OperationFailed
            if no UI variable with the specified name exists.


        """
        return _hou.Dialog_enableValue(self, name, onoff)

    def waitForValueToChangeTo(self, *args) -> "void":
        r"""

        waitForValueToChangeTo(self, name, new_value)

            Wait for the specified UI variable to change its value to new_value.

            This is a blocking call. The method will return execution when the
            variable has changed to the desired value. Note that Houdini will
            remain responsive even when this method is blocked waiting.

            If the variable's current value is already set to new_value then
            this method will return immediately.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
        return _hou.Dialog_waitForValueToChangeTo(self, *args)

    def menuItems(
        self, name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuItems(self, name) -> tuple of str

            Return the menu entries for the specified UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists. Raises
            hou.OperationFailed if the UI variable does not point to a menu.


        """
        return _hou.Dialog_menuItems(self, name)

    def setMenuItems(self, name: "char const *", items: "_StringTuple") -> "void":
        r"""

        setMenuItems(self, name, items)

            Set the menu entries in the specified UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists. Raises
            hou.OperationFailed if the UI variable does not point to a menu.


        """
        return _hou.Dialog_setMenuItems(self, name, items)

    def value(self, name: "char const *") -> "InterpreterObject":
        r"""

        value(self, name)

            Return the value of the given UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
        return _hou.Dialog_value(self, name)

    def addCallback(
        self, name: "char const *", callback: "InterpreterObject"
    ) -> "void":
        r"""

        addCallback(self, name, callback)

            Register a callback function for the specified UI variable.

            The function is invoked when the value of the UI variable changes
            and receives no arguments.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
        return _hou.Dialog_addCallback(self, name, callback)

    def removeCallback(
        self, name: "char const *", callback: "InterpreterObject"
    ) -> "void":
        r"""

        removeCallback(self, name, callback)

            Remove the specified callback function from the UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists. Raises
            hou.OperationFailed if the specified callback is not registered with
            the UI variable.


        """
        return _hou.Dialog_removeCallback(self, name, callback)

    def callbacks(
        self, name: "char const *"
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        callbacks(self, name) -> tuple of callbacks

            Return all callback functions registered with the given UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
        return _hou.Dialog_callbacks(self, name)


# Register Dialog in _hou:
_hou.Dialog_swigregister(Dialog)


class dop(object):
    r"""

    hou.dop

    DOP related functions.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_dop

    def __repr__(self) -> "std::string":
        return _hou.dop___repr__(self)

    def isScriptSolverRunning(self) -> "bool":
        r"""

        isScriptSolverRunning() -> bool

            Return whether or not a Python script solver DOP is currently
            running.

            This function is called from the Python code that is automatically
            generated when you create a new Python solver DOP type.


        """
        return _hou.dop_isScriptSolverRunning(self)

    def scriptSolverData(self) -> "HOM_DopData *":
        r"""

        scriptSolverData() -> hou.DopData

            Return the solver solver data corresponding to the currently running
            Python script solver DOP.

            A Python script solver DOP runs in two passes. During the first
            pass, it evaluates its node parameters and stores them in the solver
            data. During this pass, hou.dop.isScriptSolverRunning returns False
            and you can access a writable version of the script solver data with
            hou.DopNode.pythonSolverData. During the second pass the solver is
            invoked to actually solve the objects. During this pass,
            hou.dop.isScriptSolverRunning returns True and you use this function
            to access a read-only version of the script solver data. You can
            access the objects being solved in this pass with
            hou.dop.scriptSolverNewObjects and hou.dop.scriptSolverObjects.

            DOP nodes attach data named Solver to each of the DOP objects being
            solved. If the only solver in use is the script solver, this data
            will be of type SIM_SolverScript. Otherwise, this data will be of
            type SIM_SolverMulti, and the SIM_SolverScript will be subdata of
            the multisolver data. This function provides an easy way of
            retrieving this data, regardless of where it exists.

            Typically, the solver data is shared between all the objects being
            solved. For this reason, the data returned by this function is read-
            only. Otherwise, if you modified this data, the DOP engine would
            copy it and the objects being solved would not share this data.


        """
        return _hou.dop_scriptSolverData(self)

    def scriptSolverNetwork(self) -> "HOM_Node *":
        r"""

        scriptSolverNetwork() -> hou.Node or None

            Return the DOP network node that contains the script solver DOP that
            is currently running, or None if not script solver is running. You
            would call this function from a script solver DOP.


        """
        return _hou.dop_scriptSolverNetwork(self)

    def scriptSolverSimulation(self) -> "HOM_DopSimulation *":
        return _hou.dop_scriptSolverSimulation(self)

    def scriptSolverObjects(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        scriptSolverObjects() -> tuple of hou.DopObject

            Return a tuple of DOP objects being solved by the current script
            solver DOP. If no script solver is running, returns an empty tuple.


        """
        return _hou.dop_scriptSolverObjects(self)

    def scriptSolverNewObjects(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        scriptSolverNewObjects() -> tuple of hou.DopObject

            Return a tuple of newly-created DOP objects to later be solved by
            the current script solver DOP. If no script solver is running,
            returns an empty tuple.


        """
        return _hou.dop_scriptSolverNewObjects(self)

    def scriptSolverTimestepSize(self) -> "double":
        r"""

        scriptSolverTimestepSize() -> float

            Return the timestep size for the script solver that is currently
            running, or 0.0 if no script solver is running.


        """
        return _hou.dop_scriptSolverTimestepSize(self)

    def scriptSolverTime(self) -> "double":
        return _hou.dop_scriptSolverTime(self)


# Register dop in _hou:
_hou.dop_swigregister(dop)


class DopNode(Node):
    r"""

    hou.DopNode

    Represents a dynamics node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_DopNode

    def __repr__(self) -> "std::string":
        return _hou.DopNode___repr__(self)

    def dopNetNode(self) -> "HOM_Node *":
        r"""

        dopNetNode(self) -> hou.Node

            Return the DOP network node that contains this DOP node.


        """
        return _hou.DopNode_dopNetNode(self)

    def simulation(self) -> "HOM_DopSimulation *":
        r"""

        simulation(self) -> hou.DopSimulation

            Return the simulation that this node contributes to. This method is
            a shortcut for self.dopNetNode().simulation().


        """
        return _hou.DopNode_simulation(self)

    def processedObjects(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        processedObjects(self) -> tuple of hou.DopObject

            Return a tuple of DOP objects that this DOP node processes.


        """
        return _hou.DopNode_processedObjects(self)

    def createdObjects(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        createdObjects(self) -> tuple of hou.DopObject

            Return a tuple of DOP objects that this DOP node creates.


        """
        return _hou.DopNode_createdObjects(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns whether the node's bypass flag is on.


        """
        return _hou.DopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turn the node's bypass flag on or off, making this node have no
            effect.


        """
        return _hou.DopNode_bypass(self, on)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Return whether this node's display flag is on. This is the orange
            Output flag in the interface.


        """
        return _hou.DopNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turn the node's display flag on or off. This the orange Output flag
            in the interface.


        """
        return _hou.DopNode_setDisplayFlag(self, on)

    def isTemplateFlagSet(self) -> "bool":
        r"""

        isTemplateFlagSet(self) -> bool

            Returns whether this node's template flag is on. This is the brown
            Hidden flag in the interface.


        """
        return _hou.DopNode_isTemplateFlagSet(self)

    def setTemplateFlag(self, on: "bool") -> "void":
        r"""

        setTemplateFlag(self, on)

            Turns this node's template flag on or off. This is the brown Hidden
            flag in the interface.


        """
        return _hou.DopNode_setTemplateFlag(self, on)

    def displayNode(self) -> "HOM_Node *":
        r"""

        displayNode(self) -> hou.Node or None

            If this node is a subnet (i.e. it contains child nodes), return the
            child that has its display flag set, or None if there are no
            children. Otherwise, return None.


        """
        return _hou.DopNode_displayNode(self)

    def renderNode(self) -> "HOM_Node *":
        return _hou.DopNode_renderNode(self)

    def objectsToProcess(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        objectsToProcess(self) -> tuple of hou.DopObject

            Return a tuple of DOP objects that this node should process. Raises
            hou.PermissionError if called from outside a DOP implemented in
            Python.


        """
        return _hou.DopNode_objectsToProcess(self)

    def pythonSolverData(self) -> "HOM_DopData *":
        r"""

        pythonSolverData(self) -> hou.DopData

            If this node is a Python DOP solver, return the solver data added to
            the DOP network by this node. Otherwise, raises hou.PermissionError.

            This method is called from Python DOP solvers when the solver is not
            running, to copy data from the DOP parameters into the solver data.

            See also hou.dop.scriptSolverData.


        """
        return _hou.DopNode_pythonSolverData(self)


# Register DopNode in _hou:
_hou.DopNode_swigregister(DopNode)


class DopObject(DopData):
    r"""

    hou.DopObject

    A type of DOP data that contains an object in the simulation.

    This object might be a rigid body, a fluid, cloth, etc. The type and
    properties of the DOP object are determined by the subdata attached to
    the object.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_DopObject

    def __repr__(self) -> "std::string":
        return _hou.DopObject___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this DOP object.


        """
        return _hou.DopObject_name(self)

    def objid(self) -> "int":
        r"""

        objid(self) -> int

            Return the index of this object in the output from
            hou.DopSimulation.objects. This method is a shortcut for
            self.options().field(\"objid\").

            See hou.DopData.id for an example.

            Some fields in DOP records store an objid to refer to other objects.
            The following function looks up an object by objid:

          > def findObjectByObjid(dopnet_node, objid):
          >     return dopnet_node.simulation().objects()[objid]

        """
        return _hou.DopObject_objid(self)

    def matches(self, pattern: "char const *") -> "bool":
        r"""

        matches(self, pattern) -> bool

            Return whether or not this object's name matches a pattern. * will
            match any number of characters and ? will match any single
            character. The pattern string contains only one pattern, so spaces
            in the pattern will be compared against the object name.

          > >>> obj = hou.node(\"/obj/AutoDopNetwork\").simulation().objects()[0]
          > >>> obj.name()
          > 'box_object1'
          > >>> obj.matches(\"box*\")
          > True
          > >>> obj.matches(\"c*\")
          > False
          > >>> obj.matches(\"box* b*\")
          > False
          > >>> obj.matches(\"b?x_object1\")
          > True

        """
        return _hou.DopObject_matches(self, pattern)

    def transform(self, include_geometry_transform: "bool" = True) -> "HOM_Matrix4 *":
        r"""

        transform(self, include_geometry_transform=True) -> hou.Matrix4

            Return the transformation matrix for this object. If
            include_geometry_transform is False, the result is determined only
            by the object's Position data. Otherwise, it is the transform in the
            object's Geometry data, followed by the position transform.

            For simple DopData types, this method can be approximately
            implemented as follows:

          > def transform(self, include_geometry_transform=True):
          >     result = hou.hmath.identityTransform()
          >
          >     geometry = self.findSubData(\"Geometry\")
          >     if include_geometry_transform and geometry is not None:
          >         result *= geometry.record(\"Transform\").field(\"transform\")
          >
          >     # Retrieve the position.  If there is Geometry data, use its
          >     # positionpath field to get the SIM_Position subdata.  If not, look
          >     # for data named Position.
          >     position = None
          >     if geometry is not None:
          >         position = geometry.findSubData(
          >             geometry.options().field(\"positionpath\"))
          >     if position is None:
          >         position = self.findSubData(\"Position\")
          >
          >     # If we found position data, build a transformation from the pivot,
          >     # rotation quaternion, and translate.
          >     if position is not None:
          >         options = position.options()
          >         rotation = hou.Matrix4(options.field(\"orient\").extractRotationMatrix3())
          >         result *= (hou.hmath.buildTranslate(-options.field(\"p\")) *
          >             rotation *
          >             hou.hmath.buildTranslate(options.field(\"p\")) *
          >             hou.hmath.buildTranslate(options.field(\"t\")))
          >
          >     return result

        """
        return _hou.DopObject_transform(self, include_geometry_transform)


# Register DopObject in _hou:
_hou.DopObject_swigregister(DopObject)


class DopRecord(object):
    r"""

    hou.DopRecord

    A table of values stored inside a DopData.

    See hou.DopData for a description of DOP data, records, and fields.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_DopRecord

    def __eq__(self, record: "HOM_PtrOrNull< HOM_DopRecord >") -> "bool":
        return _hou.DopRecord___eq__(self, record)

    def __ne__(self, record: "HOM_PtrOrNull< HOM_DopRecord >") -> "bool":
        return _hou.DopRecord___ne__(self, record)

    def __hash__(self) -> "int":
        return _hou.DopRecord___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.DopRecord___repr__(self)

    def recordType(self) -> "std::string":
        r"""

        recordType(self) -> str

            Return the name of this record. See hou.DopData.recordTypes for more
            information.


        """
        return _hou.DopRecord_recordType(self)

    def recordIndex(self) -> "int":
        r"""

        recordIndex(self) -> int

            Return the index of this record. See hou.DopData.record and
            hou.DopData.records for more information.


        """
        return _hou.DopRecord_recordIndex(self)

    def fieldNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        fieldNames(self) -> tuple of str

            Return the names of all the fields inside this record. See
            hou.DopRecord.field for an example.


        """
        return _hou.DopRecord_fieldNames(self)

    def fieldType(self, field_name: "char const *") -> "HOM_EnumValue &":
        r"""

        fieldType(self, field_name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in a field. Returns hou.fieldType.NoSuchField if no
            field exists with that name.

            See hou.DopRecord.field for an example.


        """
        return _hou.DopRecord_fieldType(self, field_name)

    def field(self, field_name: "char const *") -> "InterpreterObject":
        r"""

        field(self) -> int, bool, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, or hou.Matrix4

            Return the value of a field inside this record, or None if no such
            field exists.

            Note that you can add the suffixes x, y, and z to a vector field's
            name to access the individual float values.

          > # The following code assumes you have created a box from the shelf and used
          > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          > >>> record = hou.node(\"/obj/AutoDopNetwork\").simulation().findData(\"box_object1/Forces/Gravity_gravity1\").options()
          > >>> record.fieldNames()
          > ('force', 'handlepos')
          > >>> record.field(\"force\")
          > <hou.Vector3 [0, -9.80665, 0]>
          > >>> record.field(\"forcey\")
          > -9.8066501617431641
          > >>> record.fieldType(\"force\")
          > fieldType.Vector3
          > >>> record.fieldType(\"forcey\")
          > fieldType.Float

            This example function creates a dict out of a record:

          > def recordAsDict(record):
          >     return dict((field_name, record.field(field_name))
          >         for field_name in record.fieldNames())

            The following function returns the geometry transform of an object:

          > def dopGeometryTransform(dopnet_node, object_name):
          >     subdata = dopnet_node.simulation().findObject(object_name).findSubData(\"Geometry\")
          >     return subdata.record(\"Transform\").field(\"transform\")

        """
        return _hou.DopRecord_field(self, field_name)

    def setFieldBool(self, field_name: "char const *", value: "bool") -> "void":
        r"""

        setFieldBool(self, field_name, value)

            Set a field to the specified boolean value. You would call this
            method from a script solver DOP.

            To set a field to a different type, use hou.DopRecord.setField.

            Raises hou.PermissionError if called from outside a script solver
            DOP.


        """
        return _hou.DopRecord_setFieldBool(self, field_name, value)

    def setField(self, *args) -> "void":
        r"""

        setField(self, field_name, value)

            Set a field to the specified value. You would call this method from
            a script solver DOP. value may be an int, float, str, hou.Vector2,
            hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, or
            hou.Matrix4.

            Unfortunately, this method cannot be used to set a field to a
            boolean (True or False) value. If you pass a boolean to this method,
            it will set the field to the integer 1 or 0. To properly set it to a
            boolean value, use hou.DopRecord.setFieldBool.

            Raises hou.PermissionError if called from outside a script solver
            DOP.


        """
        return _hou.DopRecord_setField(self, *args)


# Register DopRecord in _hou:
_hou.DopRecord_swigregister(DopRecord)


class DopRelationship(DopData):
    r"""

    hou.DopRelationship

    A type of DOP data that stores which DOP objects affect one another.

    In addition to the Basic and Options records, a DopRelationship contains
    ObjInAffectors and ObjInGroup records. The former contains the objects
    doing the affecting and the latter contains the objects being affected.

    See hou.DopSimulation.relationships for an example.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_DopRelationship

    def __repr__(self) -> "std::string":
        return _hou.DopRelationship___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this DOP relationship.


        """
        return _hou.DopRelationship_name(self)

    def matches(self, pattern: "char const *") -> "bool":
        r"""

        matches(self, pattern) -> bool

            Return whether or not this relationship's name matches a pattern.
            See hou.DopObject.matches for more information.


        """
        return _hou.DopRelationship_matches(self, pattern)

    def setGroup(self, objects: "_DopObjectTuple") -> "void":
        r"""

        setGroup(self, objects)

            Sets the list of objects that are being affected. This corresponds
            to the ObjInGroup record.

            objects: A list of DOP objects.

            Raises hou.PermissionError if called from outside a Python DOP.


        """
        return _hou.DopRelationship_setGroup(self, objects)

    def setAffectorGroup(self, objects: "_DopObjectTuple") -> "void":
        r"""

        setAffectorGroup(self, objects)

            Sets the list of objects that are doing the affecting. This
            corresponds to the ObjInAffectors record.

            objects: A list of DOP objects.

            Raises hou.PermissionError if called from outside a Python DOP.


        """
        return _hou.DopRelationship_setAffectorGroup(self, objects)


# Register DopRelationship in _hou:
_hou.DopRelationship_swigregister(DopRelationship)


class DopSimulation(object):
    r"""

    hou.DopSimulation

    A dynamics simulation contained inside a DOP network node.

    See hou.DopData for more information about the contents of a DOP
    simulation. Note that methods of this class implicitly use the
    simulation data from the current frame.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__()

            Creates a new simulation, which is not associated with a node. Use
            hou.DopNode.simulation to access a DOP network's simulation.


        """
        _hou.DopSimulation_swiginit(self, _hou.new_DopSimulation())

    __swig_destroy__ = _hou.delete_DopSimulation

    def __eq__(self, sim: "HOM_PtrOrNull< HOM_DopSimulation >") -> "bool":
        return _hou.DopSimulation___eq__(self, sim)

    def __ne__(self, sim: "HOM_PtrOrNull< HOM_DopSimulation >") -> "bool":
        return _hou.DopSimulation___ne__(self, sim)

    def __repr__(self) -> "std::string":
        return _hou.DopSimulation___repr__(self)

    def createObject(
        self, name: "char const *", solve_on_creation_frame: "bool"
    ) -> "HOM_DopData *":
        r"""

        createObject(self, name, solve_on_creation_frame) -> hou.DopObject

            Create and return a new DOP object, or return None if the object was
            not created successfully.


            name
                The name of the new object.

            solve_on_creation_frame
                If True, the object will be solved on its first frame of
                existance.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).

            Use hou.DopData.copyContentsFrom to clone data from an existing
            object.


        """
        return _hou.DopSimulation_createObject(self, name, solve_on_creation_frame)

    def removeObject(self, obj: "DopObject") -> "void":
        r"""

        removeObject(self, object)

            Remove the given DOP object from the simulation.


            object
                The hou.DopObject to remove.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).


        """
        return _hou.DopSimulation_removeObject(self, obj)

    def createRelationship(self, name: "char const *") -> "HOM_DopData *":
        r"""

        createRelationship(self, name) -> hou.DopRelationship

            Create and return a new DOP relationship, or return None if the
            relationship was not created successfully.


            name
                The name of the new relationship.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).

            Use hou.DopData.copyContentsFrom to clone data from an existing
            relationship, and use hou.DopRelationship.setGroup and
            hou.DopRelationship.setAffectorGroup to update the ObjInGroup and
            ObjInAffectors records.


        """
        return _hou.DopSimulation_createRelationship(self, name)

    def removeRelationship(self, rel: "DopRelationship") -> "void":
        r"""

        removeRelationship(self, rel)

            Remove the given DOP relationship from the simulation.


            rel
                The hou.DopRelationship to remove.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).


        """
        return _hou.DopSimulation_removeRelationship(self, rel)

    def dopNetNode(self) -> "HOM_Node *":
        r"""

        dopNetNode(self) -> hou.Node

            Return the DOP network node containing this simulation.


        """
        return _hou.DopSimulation_dopNetNode(self)

    def objects(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        objects(self) -> tuple of hou.DopData

            Return a tuple of all the DOP objects in the simulation.

            You cannot index into this list using the object ID (see
            hou.DopObject.objid). To create a dictionary mapping object IDs to
            hou.DopObjects, do this:

          > id_dict = dict((obj.objid(), obj) for obj in simulation.objects())

        """
        return _hou.DopSimulation_objects(self)

    def relationships(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        relationships(self) -> tuple of hou.DopRelationship

            Return a tuple of hou.DopRelationship objects for all the DOP
            relationships in the simulation.

          > # The following example assumes you have created two box objects and made
          > # them rigid bodies.
          > >>> simulation = hou.node(\"/obj/AutoDopNetwork\").simulation()
          > >>> relationship = simulation.relationships()[1]
          > >>> affecting_objects = [
          > ...     simulation.objects()[record.field(\"objid\")]
          > ...     for record in relationship.records(\"ObjInAffectors\")]
          > >>> [obj.name() for obj in affecting_objects]
          > ['box_object1']
          > >>> affected_objects = [
          > ...     simulation.objects()[record.field(\"objid\")]
          > ...     for record in relationship.records(\"ObjInGroup\")]
          > >>> [obj.name() for obj in affected_objects]
          > ['box_object2']

        """
        return _hou.DopSimulation_relationships(self)

    def findObject(self, obj_spec: "char const *") -> "HOM_DopData *":
        r"""

        findObject(self, obj_spec) -> hou.DopObject or None

            Return the DOP object with the given name, or None if no object
            exists with that name. See also hou.DopSimulation.findData and
            hou.DopSimulation.objects.


        """
        return _hou.DopSimulation_findObject(self, obj_spec)

    def findRelationship(self, rel_spec: "char const *") -> "HOM_DopData *":
        r"""

        findRelationship(self, rel_spec) -> hou.DopRelationship

            Find a DOP relationship by name. Return None if no such relationship
            with that name exists. See also hou.DopSimulation.relationships.


        """
        return _hou.DopSimulation_findRelationship(self, rel_spec)

    def findData(self, data_spec: "char const *") -> "HOM_DopData *":
        r"""

        findData(self, data_spec) -> hou.DopData or None

            Return the DOP data with the given name. Note that the name may also
            be a slash-separated path to nested subdata.

            If the data path refers to a DOP object, this method returns a
            hou.DopObject instance. If it refers to a DOP relationship, it
            returns a hou.DopRelationship instance. Otherwise, it returns a
            hou.DopData instance.

            Note this method implicitly uses the simulation data from the
            current frame.

            See also hou.DopData.findSubData.


        """
        return _hou.DopSimulation_findData(self, data_spec)

    def findAllObjects(
        self, obj_spec: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        findAllObjects(self, obj_spec) -> tuple of hou.DopObject

            Given a pattern, return a tuple of DOP objects whose names match the
            pattern.

          > >>> simulation = hou.node(\"/obj/AutoDopNetwork\").simulation()
          > >>> [obj.name() for obj in simulation.findAllObjects(\"box_object?\")]
          > ['box_object1', 'box_object2']
          > >>> [obj.name() for obj in simulation.findAllObjects(\"o* b*\")]
          > ['obj1', 'obj2', 'box_object1', 'box_object2']

        """
        return _hou.DopSimulation_findAllObjects(self, obj_spec)

    def findAllRelationships(
        self, rel_spec: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        findAllRelationships(self, rel_spec) -> tuple of hou.DopRelationship

            Return a tuple of hou.DopRelationship objects whose names match a
            pattern. See also hou.DopSimulation.relationships and
            hou.DopSimulation.findRelationship.


        """
        return _hou.DopSimulation_findAllRelationships(self, rel_spec)

    def findAllData(
        self, data_spec: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        findAllData(self, data_spec) -> tuple of hou.DopData

            Given a pattern, return a tuple of DOP data whose names match the
            pattern. See also hou.DopSimulation.findData.


        """
        return _hou.DopSimulation_findAllData(self, data_spec)

    def time(self) -> "double":
        r"""

        time(self)

            Return the simulation's current time. This value is often the same
            as hou.time, unless it is called from a Python solver DOP or the
            Time Scale or Offset Time parameters of the DOP network have been
            changed from their default values.


        """
        return _hou.DopSimulation_time(self)

    def setTime(
        self,
        t: "double",
        resim_last_timestep: "bool" = False,
        force_reset_sim: "bool" = False,
        allow_simulation: "bool" = True,
    ) -> "void":
        r"""

        setTime(self, t, resim_last_timestep=False, force_reset_sim=False,
        allow_simulation=True)

            Sets the simulation's current time.


            resim_last_timestep
                Deletes the most recent simulation cache entry before setting
                the current time.

            force_reset_sim
                Resets the simulation before moving to the specified time.

            allow_simulation
                Specifies whether simulation is enabled when moving to the
                specified time.

            Raises hou.PermissionError if the simulation cannot be modified. If
            the simulation is owned by a DOP network, the simulation time should
            be changed through the playbar.


        """
        return _hou.DopSimulation_setTime(
            self, t, resim_last_timestep, force_reset_sim, allow_simulation
        )

    def timestep(self) -> "double":
        r"""

        timestep(self)

            Returns the length of a simulation timestep.


        """
        return _hou.DopSimulation_timestep(self)

    def setTimestep(self, t: "double") -> "void":
        r"""

        setTimestep(self, t)

            Sets the length of a simulation timestep.

            Raises hou.PermissionError if the simulation cannot be modified. If
            the simulation is owned by a DOP network, the timestep should be set
            through the node's parameters.


        """
        return _hou.DopSimulation_setTimestep(self, t)

    def memoryUsage(self) -> "size_t":
        r"""

        memoryUsage(self)

            Return the simulation's total memory usage.


        """
        return _hou.DopSimulation_memoryUsage(self)


# Register DopSimulation in _hou:
_hou.DopSimulation_swigregister(DopSimulation)


class Drawable(object):
    r"""

    hou.Drawable

    The base class for drawables.

    This class provides a common interface to all drawable classes.

    TIPS AND NOTES

      * Houdini supports various drawables such as hou.SimpleDrawable,
        hou.GeometryDrawable and hou.TextDrawable.

      * hou.SimpleDrawable and hou.GeometryDrawable represent extra geometry
        to draw in the viewer alongside user content (for example, as guide
        geometry).

      * hou.SimpleDrawable is the most basic Houdini drawable class, it is
        easy to use as you just need to attach a geometry, enable it and
        Houdini will take care of drawing the geometry.

      * hou.GeometryDrawable, hou.GadgetDrawable and
        hou.GeometryDrawableGroup also draw guide geometries but provide an
        API with advanced drawing capabilities.

      * hou.GadgetDrawable is similar to hou.GeometryDrawable but also
        allows you to identify located and picked geometries.

      * hou.TextDrawable draws text in the viewport.

      * Drawables are mostly used with custom python states, you will
        generally store a reference to drawable objects on the state
        implementation object.

      * When you create a drawable object, it is hidden. You need to call
        show(True) for the attached element to appear. hou.SimpleDrawable
        requires an extra call to hou.SimpleDrawable.enable for the geometry
        to appear.

      * The drawable element will appear in the viewer until the drawable
        object is hidden or deleted. If there are no references to the
        object, Python will automatically delete it during garbage
        collection, and the attached element will disappear. So, you need to
        make sure to keep a live reference to the object as long as you want
        it to appear.

    RELATED

      * hou.AdvancedDrawable

      * hou.GadgetDrawable

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable

      * hou.TextDrawable


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_Drawable

    def name(self) -> "std::string":
        r"""

        name(self)

            The name of this drawable.


        """
        return _hou.Drawable_name(self)

    def label(self) -> "std::string":
        r"""

        label(self)

            The label of this drawable.


        """
        return _hou.Drawable_label(self)

    def show(self, value: "bool") -> "void":
        r"""

        show(self, value)

            Displays or hides the element attached to this drawable in the
            viewport. The element will appear the next time the viewer redraws.


            value
                True to show the element or False to hide it.


        """
        return _hou.Drawable_show(self, value)

    def visible(self) -> "bool":
        r"""

        visible(self) -> bool

            Returns True if the drawable is visible or not.


        """
        return _hou.Drawable_visible(self)

    def transform(self) -> "HOM_Matrix4":
        r"""

        transform(self): -> hou.Matrix4

            Returns the transform matrix of the element attached to the
            drawable.


        """
        return _hou.Drawable_transform(self)

    def setTransform(self, xform: "Matrix4") -> "void":
        r"""

        setTransform(self, xform)

            Sets the transform matrix of the element attached to this drawable.
            The changes will appear the next time the viewer redraws.


            xform
                A hou.Matrix4 transformation matrix to set the element's
                translation, rotation, and scale.


        """
        return _hou.Drawable_setTransform(self, xform)

    def setLabel(self, label: "std::string const &") -> "void":
        r"""

        setLabel(self, label)

            Set the label for this drawable.


        """
        return _hou.Drawable_setLabel(self, label)


# Register Drawable in _hou:
_hou.Drawable_swigregister(Drawable)


class AdvancedDrawable(Drawable):
    r"""

    hou.AdvancedDrawable

    The base class for advanced drawables.

    This base class provides a common interface for drawables such as
    hou.GeometryDrawable and hou.TextDrawable. These are advanced drawables
    used by custom python states for drawing text and guide geometries in
    the viewport and, to convey visual information from the state to the
    user.

    RELATED

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable

      * hou.TextDrawable


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_AdvancedDrawable

    def setParams(self, params: "HOM_AdvancedDrawable::Params const &") -> "void":
        r"""

        setParams(self, params)

            Sets the parameters of the drawable. The settings will take effect
            in the viewport the next time hou.AdvancedDrawable.draw is called.


            params
                A dictionary of parameters for setting the drawable options.
                Each drawable type uses a specific set of parameters, detailed
                information can be found in the drawable derived class params
                documentation such as GeometryDrawable and TextDrawable.

                The following are parameters common to all hou.AdvancedDrawable
                types:

                color1
                hou.Vector4

                Vector representing an rgba value used as the main color of a
                drawable. This color is multiplied by the overlay stencil colors
                at the time of compositing. The default value is hou.Vector4(1,
                1, 1, 1).

                For hou.TextDrawable, color1 is the default foreground color for
                drawing the text.

                color2
                hou.Vector4

                Vector representing an rgba value for setting the glow color
                around the drawable generated matte. Defaults to hou.Vector4(0,
                0, 0, 0.25).

                For instance, color2 can be used for drawing a glow around the
                generated matte for a face or point drawable.

                fade_factor
                double

                Value used as the occlusion factor of the overlay in areas
                occluded by the existing geometry as determined by the depth
                buffer. A fade factor of 1.0 means no distinction must be made
                and a value of 0.0 completely hides occluded parts. Defaults to
                0.

                glow_width
                int

                Sets the glow width value. For instance, this changes the glow
                width of line segments or text. Defaults to 0.

                highlight_mode
                hou.drawableHighlightMode

                Sets the mode for highlighting the generated matte of the
                drawable. Defaults to hou.drawableHighlightMode.Matte.

                translate
                hou.Vector3 or sequence of 3 doubles

                Position of the geometry in 3D space.

                For hou.TextDrawable, it's the position of the text to display
                in viewport coordinates.

                Defaults to hou.Vector3(0, 0, 0).

                rotation
                hou.Vector3 or sequence of 3 doubles

                Rotation vector in degrees. Defaults to hou.Vector3(0, 0, 0).

                scale
                hou.Vector3 or sequence of 3 doubles

                Scaling vector. Defaults to hou.Vector3(1, 1, 1).

                screen_space
                Sequence of doubles or ints

                Assigns a 2D window to the viewport, in viewport coordinates,
                for drawing a geometry. The sequence defines the location and
                size of the window, and must contain the following values:

              * X position (defaults to 0)

              * Y position (defaults to 0)

              * Width (defaults to 0)

              * Height (defaults to 0)

              * X margin (defaults to 0)

              * Y margin (defaults to 0)

                use_cd
                Bool

                Specifies if the drawable should use the Cd attribute of the
                attached geometry (if any). If an Alpha attribute exists, the
                drawable will use it as well. Defaults to True.

                use_uv
                Bool

                Specifies if the drawable should use the Uv attribute of the
                attached geometry (if any). Defaults to True.


        """
        return _hou.AdvancedDrawable_setParams(self, params)

    def draw(self, *args, **kwargs) -> "void":
        r"""

        draw(self, handle, params=None)

            Method implemented by leaf classes to support the drawing of
            elements in a viewport. This method should normally be called from
            the python state onDraw or onDrawInterrupt event to render the
            drawable in the current viewport.


            handle
                This is an opaque value created by Houdini to render the
                drawable. This handle value is passed to the python state onDraw
                callback by Houdini and should be passed directly to the
                drawable object's draw method.

            params
                An optional dictionary of parameters for setting the drawable
                parameters. These are the same parameters
                hou.AdvancedDrawable.setParams is using.


        """
        return _hou.AdvancedDrawable_draw(self, *args, **kwargs)


# Register AdvancedDrawable in _hou:
_hou.AdvancedDrawable_swigregister(AdvancedDrawable)


class SimpleDrawable(Drawable):
    r"""

    hou.SimpleDrawable

    Represents extra geometry to draw in the viewer alongside user content
    (for example, as guide geometry).

    OVERVIEW

        You can attach geometry to a viewer in a Drawable object, causing
        the geometry to appear in the viewer even though the geometry is not
        actually part of the scene. This is useful to show guide geometry in
        a custom Python state.

        hou.SimpleDrawable basic support is ideal for simple guide
        geometries. For an advanced API for creating and drawing guide
        geometries, see hou.GeometryDrawable and hou.GeometryDrawableGroup.

      > import hou
      > # Create an empty geometry object
      > geo = hou.Geometry()
      > # Get the verb from the Box node
      > box_verb = hou.sopNodeTypeCategory().nodeVerb(\"box\")
      > # Set the verb's parameters
      > box_verb.setParms({
      >     \"t\": hou.Vector3(0.5, 0.5, -0.5),
      >     \"scale\": 0.5,
      > })
      > # Execute the verb and put its output in the Geometry object
      > box_verb.execute(geo, [])
      >
      > # Grab a reference to the viewer
      > scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
      > # Create a Drawable object
      > drawable = hou.SimpleDrawable(scene_viewer, geo, \"my_guide\")
      > # Set the Drawable display mode as wireframe (this is the default)
      > drawable.setDisplayMode(hou.drawableDisplayMode.WireframeMode)
      > # Enable and show the drawable geometry
      > drawable.enable(True)
      > drawable.show(True)
      > # Tumble the view to see the geometry
      > import hou
      > # Create a geometry from the Sphere node
      > sphere_verb = hou.sopNodeTypeCategory().nodeVerb(\"sphere\")
      > geo = hou.Geometry()
      > sphere_verb.execute(geo, [])
      >
      > # Add color and alpha attributes to the sphere
      > color_attrib = geo.addAttrib(hou.attribType.Prim, \"Cd\", (1.0, 1.0, 1.0))
      > alpha_attrib = geo.addAttrib(hou.attribType.Prim, \"Alpha\", 1.0)
      >
      > color = hou.Color(1.0, 0.0, 0.0)
      > for prim in geo.prims():
      >     prim.setAttribValue(color_attrib, color.rgb())
      >     prim.setAttribValue(alpha_attrib, 0.7)
      >
      > # Create a Drawable object
      > scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
      > drawable = hou.SimpleDrawable(scene_viewer, geo, \"my_sphere\")
      > # Set the Drawable display mode with the current viewport shading mode
      > drawable.setDisplayMode(hou.drawableDisplayMode.CurrentViewportMode)
      > # Set the size of the sphere
      > drawable.setTransform(hou.hmath.buildScale(0.5, 0.5, 0.5))
      > drawable.enable(True)
      > drawable.show(True)

    TIPS AND NOTES

      * The SimpleDrawable object keeps a reference to the Geometry object
        you pass. You can change the Geometry object's contents and the next
        time the viewer redraws it will draw the new contents.

      * When you create the SimpleDrawable object, it is disabled and
        hidden. You need to call enable(True) and then show(True) for the
        geometry to appear.

      * Even after they are activated and shown, SimpleDrawable geometry
        does not appear in the viewer until the next redraw (for example,
        when the user changes the view).

            You can force an individual viewport to redraw using
            hou.GeometryViewport.draw.

          > scene_viewer.curViewport().draw()

      * You can generate the contents of a Geometry object from scratch
        using verbs, or grab a copy of the output of a SOP node using
        hou.SopNode.geometry.

      * You can also use hou.drawablePrimitive to specify a built-in shape
        to generate the content of a SimpleDrawable object.

      * enabling/disabling a drawable may cause performances issues if
        performed too often, especially with large geometries. It's good
        practice to use show instead of enable for hiding and showing a
        drawable.

      * It's also good practice to disable drawables when they are not
        actively used in a viewer.

      * Add a Vertex or Point uv attribute to the hou.SimpleDrawable
        geometry to draw in the UV view:

          > sops = hou.sopNodeTypeCategory()
          > verb = sops.nodeVerb(\"sphere\")
          > verb.setParms(parms)
          > geo = hou.Geometry()
          > verb.execute(geo, [])
          >
          > # add uv vertex attribute to the drawable.
          > geo.addAttrib(hou.attribType.Vertex, \"uv\", (0,0))
          >
          > # add color and alpha attributes
          > color_attrib = geo.addAttrib(hou.attribType.Prim, \"Cd\", (1.0, 1.0, 1.0))
          > for prim in geo.prims():
          >     prim.setAttribValue(color_attrib, StrokeCursor.COLOR.rgb())
          >
          > # create a wireframe brush
          > brush = hou.SimpleDrawable(self.scene_viewer, geo, '%s_%s' % (self.state_name, \"sphere\"))
          > brush.setDisplayMode(hou.drawableDisplayMode.WireframeMode)

    RELATED

      * hou.TextDrawable

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, scene_viewer, geometry, name)

            Creates a drawable object for drawing a geometry in a viewport. The
            new drawable is hidden and disabled by default.


            scene_viewer
                A hou.SceneViewer reference to the viewer the guide geometry
                will appear in.

            geometry
                Either a hou.Geometry object containing the geometry to draw, or
                a hou.drawablePrimitive value specifying a shape to draw.

            name
                A string to identify this drawable object. This should be unique
                across all drawables in the current session.

            In a custom state, you can base the SimpleDrawable's name on the
            state name to try to ensure uniqueness. For example:

          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >
          >         geo = hou.Geometry()
          >         verb = hou.sopNodeTypeCategory().nodeVerb(\"box\")
          >         verb.execute(geo, [])
          >         self._box = hou.SimpleDrawable(
          >             self.scene_viewer, geo,
          >             # Use the state name as the basis for the drawable's name
          >             self.state_name + \"_box\"
          >         )

        """
        _hou.SimpleDrawable_swiginit(self, _hou.new_SimpleDrawable(*args))

    __swig_destroy__ = _hou.delete_SimpleDrawable

    def __repr__(self) -> "std::string":
        return _hou.SimpleDrawable___repr__(self)

    def enable(self, value: "bool") -> "void":
        r"""

        enable(self,value)

            Enables or disables the drawing of the geometry. This method is
            typically called first for the show method to take effect.


            value
                True to enable or False to disable the drawing.


        """
        return _hou.SimpleDrawable_enable(self, value)

    def enabled(self) -> "bool":
        r"""

        enabled(self,value) -> bool

            Returns True if the drawable is enabled or not.


        """
        return _hou.SimpleDrawable_enabled(self)

    def setDisplayMode(self, value: "EnumValue") -> "void":
        r"""

        displayMode(self): -> hou.drawableDisplayMode

            Returns the display mode of the geometry.


        """
        return _hou.SimpleDrawable_setDisplayMode(self, value)

    def displayMode(self) -> "HOM_EnumValue &":
        return _hou.SimpleDrawable_displayMode(self)

    def setWireframeColor(self, color: "Color") -> "void":
        r"""

        setWireframeColor(self, color)

            Updates the color of the geometry when the drawable display mode is
            set to hou.drawableDisplayMode.WireframeMode. The change will appear
            the next time the viewer redraws.


            color
                A hou.Color value to specify the primitive color.


        """
        return _hou.SimpleDrawable_setWireframeColor(self, color)

    def setXray(self, value: "bool") -> "void":
        r"""

        setXray(self, value)

            Sets the xray rendering flag on the drawable.


            value
                True to enable or False to disable xray rendering.


        """
        return _hou.SimpleDrawable_setXray(self, value)

    def isXray(self) -> "bool":
        r"""

        isXray(self): -> bool

            Returns True if the drawable will render with xray rendering.


        """
        return _hou.SimpleDrawable_isXray(self)

    def setShowMaterials(self, value: "bool") -> "void":
        r"""

        setShowMaterials(self, value)

            Enables or disables materials for the drawable. The drawable
            geometry must have a valid shop_materialpath attribute.


            value
                True to enable or False to disable materials.


        """
        return _hou.SimpleDrawable_setShowMaterials(self, value)

    def isShowMaterials(self) -> "bool":
        r"""

        isShowMaterials(self): -> bool

            Returns True if the drawable is drawn with materials.


        """
        return _hou.SimpleDrawable_isShowMaterials(self)

    def setCastShadows(self, value: "bool") -> "void":
        r"""

        setCastShadows(self, value)

            Enables or disables the shadow casting flag for the drawable.


            value
                True to enable or False to disable shadow casting.


        """
        return _hou.SimpleDrawable_setCastShadows(self, value)

    def isCastShadows(self) -> "bool":
        r"""

        isCastShadows(self): -> bool

            Returns True if the drawable is set to cast shadows.


        """
        return _hou.SimpleDrawable_isCastShadows(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self): -> hou.Geometry

            Returns the drawable's geometry object. The returned geometry is
            read-only.


        """
        return _hou.SimpleDrawable_geometry(self)

    def setGeometry(self, geometry: "Geometry") -> "void":
        r"""

        setGeometry(self, geometry)

            Sets the drawable with a new geometry. The changes will appear the
            next time the viewer redraws.


            geometry
                A hou.Geometry object.


        """
        return _hou.SimpleDrawable_setGeometry(self, geometry)

    def setVisibleInViewport(self, viewport: "GeometryViewport") -> "void":
        r"""

        setVisibleInViewport(self, viewport)

            Restricts the drawable to be only visible in viewport. The drawable
            can be made visible in more than one viewport by calling this once
            per viewport.


        """
        return _hou.SimpleDrawable_setVisibleInViewport(self, viewport)

    def setVisibleInAllViewports(self) -> "void":
        r"""

        setVisibleInAllViewports(self)

            Remove all per-viewport visibility restrictions, so that the
            drawable is shown in all viewports.


        """
        return _hou.SimpleDrawable_setVisibleInAllViewports(self)

    def isVisibleInViewport(self, viewport: "GeometryViewport") -> "bool":
        r"""

        isVisibleInViewport(self, viewport) -> bool

            Query to see if this drawable is visible in viewport.


        """
        return _hou.SimpleDrawable_isVisibleInViewport(self, viewport)


# Register SimpleDrawable in _hou:
_hou.SimpleDrawable_swigregister(SimpleDrawable)


class Edge(object):
    r"""

    hou.Edge

    Each Edge object resides inside a Geometry object and stores an edge.
    Edges are reprsented as pairs of points.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Edge

    def __eq__(self, edge: "HOM_PtrOrNull< HOM_Edge >") -> "bool":
        return _hou.Edge___eq__(self, edge)

    def __ne__(self, edge: "HOM_PtrOrNull< HOM_Edge >") -> "bool":
        return _hou.Edge___ne__(self, edge)

    def __hash__(self) -> "int":
        return _hou.Edge___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Edge___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        return _hou.Edge_geometry(self)

    def points(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        points(self) -> tuple of hou.Point

            Return a tuple of the points that make up this edge.


        """
        return _hou.Edge_points(self)

    def edgeId(self) -> "std::string":
        r"""

        edgeId(self) -> str

            Return a string such as p8-9 that identifies the edge


        """
        return _hou.Edge_edgeId(self)

    def length(self) -> "float":
        r"""

        length(self) -> float

            Returns the length of this edge


        """
        return _hou.Edge_length(self)

    def prims(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        prims(self) -> tuple of hou.Prim

            Return a tuple of the prims that has this edge


        """
        return _hou.Edge_prims(self)


# Register Edge in _hou:
_hou.Edge_swigregister(Edge)


class EdgeGroup(object):
    r"""

    hou.EdgeGroup

    A named group of edges inside a Geometry object.

    Edge groups reside inside the geometry, and each edge group has a unique
    name.

    See hou.Edge for more information about edges. See also hou.PrimGroup,
    hou.PointGroup, and hou.VertexGroup.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_EdgeGroup

    def __eq__(self, edge_group: "HOM_PtrOrNull< HOM_EdgeGroup >") -> "bool":
        return _hou.EdgeGroup___eq__(self, edge_group)

    def __ne__(self, edge_group: "HOM_PtrOrNull< HOM_EdgeGroup >") -> "bool":
        return _hou.EdgeGroup___ne__(self, edge_group)

    def __hash__(self) -> "int":
        return _hou.EdgeGroup___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.EdgeGroup___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
        return _hou.EdgeGroup_geometry(self)

    def name(self) -> "std::string":
        r"""

        name(self)

            Return the name of the group. Each edge group has a unique name.


        """
        return _hou.EdgeGroup_name(self)

    def iterEdges(self) -> "HOM_IterableList< HOM_Edge > *":
        r"""

        iterEdges(self) -> generator of hou.Edge

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.EdgeGroup.edges allocates and returns a tuple of all the
            edges in the group, this method returns a generator object that will
            yield hou.Edge objects on demand.


        """
        return _hou.EdgeGroup_iterEdges(self)

    def edges(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Edge >,std::allocator< HOM_ElemPtr< HOM_Edge > > >":
        r"""

        edges(self) -> tuple of hou.Edge

            Return the contents of this group.

            See also hou.EdgeGroup.iterEdges.


        """
        return _hou.EdgeGroup_edges(self)

    def contains(self, edge: "Edge") -> "bool":
        r"""

        contains(self, edge) -> bool

            Return whether or not an edge is in this group.

            Raises hou.OperationFailed if the edge belongs to a different
            geometry object than this group.


        """
        return _hou.EdgeGroup_contains(self, edge)

    def add(self, *args) -> "void":
        r"""

        add(self, edge_or_list_or_edge_group)

            If given a hou.Edge or a list of hou.Edge's, add the edge(s) to the
            group. If given a hou.EdgeGroup, merge the contents of the other
            edge group with this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is ok to add edges to the group that were already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the edge or edge group belong to a
            different geometry object than this group.


        """
        return _hou.EdgeGroup_add(self, *args)

    def remove(self, *args) -> "void":
        r"""

        remove(self, edge_or_list_or_edge_group)

            If given a hou.Edge or a list of hou.Edge's, remove the edge(s) from
            the group. If given a hou.EdgeGroup, remove all edges in the other
            group from this group (the other group is unaffected). You would
            typically call this method from the code of a Python-defined SOP.

            It is not an error to try to remove an edge from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the edge belongs to a different
            geometry object than this group.


        """
        return _hou.EdgeGroup_remove(self, *args)

    def clear(self) -> "void":
        return _hou.EdgeGroup_clear(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.EdgeGroup_destroy(self)

    def edgeCount(self) -> "int64":
        r"""

        edgeCount(self) -> int

            Returns the number of edges in this group.


        """
        return _hou.EdgeGroup_edgeCount(self)

    def dataId(self) -> "HOM_AttribDataId *":
        r"""

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
        return _hou.EdgeGroup_dataId(self)

    def incrementDataId(self) -> "void":
        r"""

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
        return _hou.EdgeGroup_incrementDataId(self)


# Register EdgeGroup in _hou:
_hou.EdgeGroup_swigregister(EdgeGroup)


class EditableDopGeometryGuard(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_EditableDopGeometryGuard

    def __repr__(self) -> "std::string":
        return _hou.EditableDopGeometryGuard___repr__(self)

    def __enter__(self) -> "HOM_Geometry *":
        return _hou.EditableDopGeometryGuard___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.EditableDopGeometryGuard___exit__(self, type, value, traceback)


# Register EditableDopGeometryGuard in _hou:
_hou.EditableDopGeometryGuard_swigregister(EditableDopGeometryGuard)


class FlipbookSettings(object):
    r"""

    hou.FlipbookSettings

    A collection of options for the viewport flipbook dialog.

    The viewport flipbook has a set of options beyond the Display Options
    provided by the viewport itself. This object contains all these
    settings.

      * Use hou.SceneViewer.flipbookSettings to get this object representing
        the current flipbook settings for the viewer. Changing the options
        on this object changes the settings for future interactive flipbooks
        generated from the viewer.

      * You can also pass the settings object directly to
        hou.SceneViewer.flipbook to generate a flipbook using the current
        settings.

      * To generate a flipbook using custom settings, first use
        hou.SceneViewer.flipbookSettings to get the current settings, and
        call hou.FlipbookSettings.stash to create a copy (so changing the
        options won't affect the viewer's interactive options). Then modify
        the settings and pass the object to hou.SceneViewer.flipbook.

      > # Copy the viewer's current flipbook settings
      > flipbook_options = scene.flipbookSettings().stash()
      >
      > # Change the settings however you need
      > # (for example, set the frame range and output filename)
      > flipbook_options.frameRange( (frame, frame) )
      > flipbook_options.output(filename)
      >
      > # Generate the flipbook using the modified settings
      > scene.flipbook(scene.curViewport(), flip_options)

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_FlipbookSettings

    def __repr__(self) -> "std::string":
        return _hou.FlipbookSettings___repr__(self)

    def stash(self) -> "HOM_FlipbookSettings *":
        r"""

        stash(self) -> hou.FlipbookSettings

            Return a new copy of this FlipbookSettings object. Changes to this
            new object will not update the flipbook dialog, but can be passed to
            hou.SceneViewer.flipbook() as the settings to use.


        """
        return _hou.FlipbookSettings_stash(self)

    def copy(self, from_settings: "FlipbookSettings") -> "void":
        r"""

        copy(self, from_settings)

            Copy all settings in from_settings into this object.


        """
        return _hou.FlipbookSettings_copy(self, from_settings)

    def outputToMPlay(self, *args) -> "bool":
        r"""

        outputToMPlay(self) -> bool

            Query if images are being sent to an interactive MPlay sesion.


        """
        return _hou.FlipbookSettings_outputToMPlay(self, *args)

    def leaveFrameAtEnd(self, *args) -> "bool":
        r"""

        leaveFrameAtEnd(self) -> bool

            Query if the playbar frame is being left at the last frame (True) or
            restored to the previous frame (False).


        """
        return _hou.FlipbookSettings_leaveFrameAtEnd(self, *args)

    def output(self, *args) -> "std::string":
        r"""

        output(self) -> str

            The current output destination for flipbooking.


        """
        return _hou.FlipbookSettings_output(self, *args)

    def sessionLabel(self, *args) -> "std::string":
        r"""

        sessionLabel(self) -> str

            The current flipbook session label.


        """
        return _hou.FlipbookSettings_sessionLabel(self, *args)

    def visibleObjects(self, *args) -> "std::string":
        r"""

        visibleObjects(self) -> str

            The current visibility list for objects to be rendered.


        """
        return _hou.FlipbookSettings_visibleObjects(self, *args)

    def visibleTypes(self, *args) -> "HOM_EnumValue &":
        r"""

        visibleTypes(self) -> hou.flipbookObjectType

            The current visible object types.


        """
        return _hou.FlipbookSettings_visibleTypes(self, *args)

    def frameRange(self, *args) -> "std::vector< double,std::allocator< double > >":
        r"""

        frameRange(self) -> tuple of double

            The current frame range of the flipbook, as a tuple of 2 ints
            (start, end).


        """
        return _hou.FlipbookSettings_frameRange(self, *args)

    def frameIncrement(self, *args) -> "int":
        r"""

        frameIncrement(self) -> int

            The current frame increment of the flipbook.


        """
        return _hou.FlipbookSettings_frameIncrement(self, *args)

    def beautyPassOnly(self, *args) -> "bool":
        r"""

        beautyPassOnly(self) -> bool

            The current state of the beauty pass render flag.


        """
        return _hou.FlipbookSettings_beautyPassOnly(self, *args)

    def renderAllViewports(self, *args) -> "bool":
        r"""

        renderAllViewports(self) -> bool

            Render all visible viewports (True), or only the currently selected
            one.


        """
        return _hou.FlipbookSettings_renderAllViewports(self, *args)

    def appendFramesToCurrent(self, *args) -> "bool":
        r"""

        appendFramesToCurrent(self) -> bool

            The current state of the flipbook append mode, either Append (True)
            or Overwrite (False).


        """
        return _hou.FlipbookSettings_appendFramesToCurrent(self, *args)

    def scopeChannelKeyframesOnly(self, *args) -> "bool":
        r"""

        scopeChannelKeyframesOnly(self) -> bool

            The current state of scoped keyframe mode.


        """
        return _hou.FlipbookSettings_scopeChannelKeyframesOnly(self, *args)

    def blockEditing(self, *args) -> "bool":
        r"""

        blockEditing(self) -> bool

            The current state of block editing mode.


        """
        return _hou.FlipbookSettings_blockEditing(self, *args)

    def initializeSimulations(self, *args) -> "bool":
        r"""

        initializeSimulations(self) -> bool

            The current state of simulation initialization. True indicates that
            simulations will be reset, and False indicates that any cached
            results will be used.


        """
        return _hou.FlipbookSettings_initializeSimulations(self, *args)

    def audioFilename(self, *args) -> "void":
        r"""

        audioFilename(self, audio_file)

            The current audio file used by the flipbook.


        """
        return _hou.FlipbookSettings_audioFilename(self, *args)

    def audioFrameStart(self, *args) -> "double":
        r"""

        audioFrameStart(self) -> double

            The frame where the audio will be playing audioTimeOffset seconds.


        """
        return _hou.FlipbookSettings_audioFrameStart(self, *args)

    def audioTimeOffset(self, *args) -> "double":
        r"""

        audioTimeOffset(self) -> double

            The audio time that will be playing at audioFrameStart frames.


        """
        return _hou.FlipbookSettings_audioTimeOffset(self, *args)

    def backgroundImage(self, *args) -> "std::string":
        r"""

        backgroundImage(self) -> str

            The pathname of the background image or images.


        """
        return _hou.FlipbookSettings_backgroundImage(self, *args)

    def overrideGamma(self, *args) -> "bool":
        r"""

        overrideGamma(self) -> bool

            The current state of the gamma override.


        """
        return _hou.FlipbookSettings_overrideGamma(self, *args)

    def gamma(self, *args) -> "double":
        r"""

        gamma(self) -> double

            The current gamma value.


        """
        return _hou.FlipbookSettings_gamma(self, *args)

    def overrideLUT(self, *args) -> "bool":
        r"""

        overrideLUT(self) -> bool

            The current state of the LUT override.


        """
        return _hou.FlipbookSettings_overrideLUT(self, *args)

    def LUT(self, *args) -> "std::string":
        r"""

        LUT(self) -> str

            The current LUT used for flipbooking.


        """
        return _hou.FlipbookSettings_LUT(self, *args)

    def setUseFrameTimeLimit(self, limit: "bool") -> "void":
        r"""

        setUseFrameTimeLimit(self, limit)

            Enable the frame time limit for progressive renderers in LOPs.


        """
        return _hou.FlipbookSettings_setUseFrameTimeLimit(self, limit)

    def useFrameTimeLimit(self) -> "bool":
        r"""

        useFrameTimeLimit(self) -> bool

            The frame time limit for progressive renderers in LOPs.


        """
        return _hou.FlipbookSettings_useFrameTimeLimit(self)

    def setFrameTimeLimit(self, t: "double") -> "void":
        r"""

        setFrameTimeLimit(self, t)

            Set the frame time limit for progressive renderers in LOPs, in
            seconds. Once this is exceeeded the flipbook will advance to the
            next frame.


        """
        return _hou.FlipbookSettings_setFrameTimeLimit(self, t)

    def frameTimeLimit(self) -> "double":
        r"""

        frameTimeLimit(self) -> double

            The frame time limit for progressive renderers in LOPs, in seconds.
            Once this is exceeeded the flipbook will advance to the next frame.


        """
        return _hou.FlipbookSettings_frameTimeLimit(self)

    def setUseFrameProgressLimit(self, limit: "bool") -> "void":
        r"""

        setUseFrameProgressLimit(self, limit)

            Enable the frame progress limit for progressive renderers in LOPs.


        """
        return _hou.FlipbookSettings_setUseFrameProgressLimit(self, limit)

    def useFrameProgressLimit(self) -> "bool":
        r"""

        useFrameProgressLimit(self) -> bool

            The frame progress limit for progressive renderers in LOPs.


        """
        return _hou.FlipbookSettings_useFrameProgressLimit(self)

    def setFrameProgessLimit(self, t: "double") -> "void":
        r"""

        setFrameProgessLimit(self, t)

            Specify the frame progress limit for progressive renderers in LOPs,
            in percent. Once this is exceeeded the flipbook will advance to the
            next frame.


        """
        return _hou.FlipbookSettings_setFrameProgessLimit(self, t)

    def frameProgressLimit(self) -> "double":
        r"""

        frameProgressLimit(self) -> double

            The frame progress limit for progressive renderers in LOPs, in
            percent. Once this is exceeeded the flipbook will advance to the
            next frame.


        """
        return _hou.FlipbookSettings_frameProgressLimit(self)

    def antialias(self, *args) -> "HOM_EnumValue &":
        r"""

        antialias(self) -> hou.flipbookAntialias

            Query the current flipbook antialiasing setting:

          * hou.flipbookAntialias.UseViewportSetting: Use the current viewport
            setting.

          * hou.flipbookAntialias.Off: No antialiasing.

          * hou.flipbookAntialias.Fast: Minimal 2-sample antialiasing.

          * hou.flipbookAntialias.Good: 4-sample antialiasing.

          * hou.flipbookAntialias.HighQuality: 8-sample antialiasing.


        """
        return _hou.FlipbookSettings_antialias(self, *args)

    def useMotionBlur(self, *args) -> "bool":
        r"""

        useMotionBlur(self) -> bool

            Query if motion blur is enabled.


        """
        return _hou.FlipbookSettings_useMotionBlur(self, *args)

    def motionBlurSegments(self, *args) -> "int":
        r"""

        motionBlurSegments(self) -> int

            Query the number of subframes currently used for motion blur.


        """
        return _hou.FlipbookSettings_motionBlurSegments(self, *args)

    def motionBlurFrameRange(self, *args) -> "HOM_EnumValue &":
        r"""

        motionBlurFrameRange(self) -> hou.flipbookMotionBlurBias

            Query the subframe range for motion blur:

          * hou.flipbookMotionBlurBias.Centered: Subframe range is centered
            around the currently rendering frame.

          * hou.flipbookMotionBlurBias.Forward: Subframe range starts at the
            currently rendering frame.

          * hou.flipbookMotionBlurBias.Previous: Subframe range ends at the
            currently rendering frame.


        """
        return _hou.FlipbookSettings_motionBlurFrameRange(self, *args)

    def shutterFromCamera(self, *args) -> "bool":
        r"""

        shutterFromCamera(self) -> bool

            Query if the shutter is sourced from the camera or the flipbook
            dialog.


        """
        return _hou.FlipbookSettings_shutterFromCamera(self, *args)

    def shutter(self, *args) -> "double":
        r"""

        shutter(self) -> double

            Query the current camera shutter for motion blur.


        """
        return _hou.FlipbookSettings_shutter(self, *args)

    def useDepthOfField(self, *args) -> "bool":
        r"""

        useDepthOfField(self) -> bool

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
        return _hou.FlipbookSettings_useDepthOfField(self, *args)

    def depthOfFieldFromCamera(self, *args) -> "bool":
        r"""

        depthOfFieldFromCamera(self) -> bool

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
        return _hou.FlipbookSettings_depthOfFieldFromCamera(self, *args)

    def depthOfFieldQuality(self, *args) -> "double":
        r"""

        depthOfFieldQuality(self) -> double

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
        return _hou.FlipbookSettings_depthOfFieldQuality(self, *args)

    def focusDistance(self, *args) -> "double":
        r"""

        focusDistance(self) -> double

            Obsolete. Uses the setting on the camera.


        """
        return _hou.FlipbookSettings_focusDistance(self, *args)

    def aperture(self, *args) -> "double":
        r"""

        aperture(self) -> double

            Obsolete. Uses the setting on the camera.


        """
        return _hou.FlipbookSettings_aperture(self, *args)

    def fStop(self, *args) -> "double":
        r"""

        fStop(self) -> double

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
        return _hou.FlipbookSettings_fStop(self, *args)

    def outputZoom(self, *args) -> "int":
        r"""

        outputZoom(self) -> int

            Query the output zoom level. Valid settings are 100, 75, 50, and 25.


        """
        return _hou.FlipbookSettings_outputZoom(self, *args)

    def useResolution(self, *args) -> "bool":
        r"""

        useResolution(self) -> bool

            Query if the resolution is defined by the flipbook dialog (True) or
            by the current size of the viewport (False).


        """
        return _hou.FlipbookSettings_useResolution(self, *args)

    def resolution(self, *args) -> "std::vector< int,std::allocator< int > >":
        r"""

        resolution(self) -> tuple of int

            Returns a 2-tuple of ints representing the width and height of the
            flipbook dialog image output resolution. This is not used unless
            useResolution is enabled.


        """
        return _hou.FlipbookSettings_resolution(self, *args)

    def useSheetSize(self, *args) -> "bool":
        r"""

        useSheetSize(self) -> bool

            Query if the viewport captures will be arranged into a sheet (True)
            or each frame will produce a different flipbook image (False).


        """
        return _hou.FlipbookSettings_useSheetSize(self, *args)

    def sheetSize(self, *args) -> "std::vector< int,std::allocator< int > >":
        r"""

        sheetSize() -> tuple of int

            Returns a 2-tuple of ints representing the number of columns and
            rows of frames in each output image. This is not used unless
            useSheetSize is enabled.


        """
        return _hou.FlipbookSettings_sheetSize(self, *args)

    def cropOutMaskOverlay(self, *args) -> "bool":
        r"""

        cropOutMaskOverlay(self) -> bool

            Query if the resulting image will be cropped to the camera area.


        """
        return _hou.FlipbookSettings_cropOutMaskOverlay(self, *args)

    def fromAudioPanel(self, *args) -> "void":
        r"""

        fromAudioPanel(self) -> bool

            When enabled, the flipbook gets it's audio settings from the Audio
            Panel.


        """
        return _hou.FlipbookSettings_fromAudioPanel(self, *args)


# Register FlipbookSettings in _hou:
_hou.FlipbookSettings_swigregister(FlipbookSettings)


class FloatingPanel(object):
    r"""

    hou.FloatingPanel

    A floating window that contains one or more panes.

    Much like a desktop, a floating panel contains panes. A floating panel
    may be attached to a desktop, in which case it is saved with the
    desktop, hidden when the desktop is closed, and shown when the desktop
    is opened. You can use floating panels to create desktops that span
    multiple monitors.

    When you create a new floating panel, for example, it contains a single
    pane, which in turn contains a single pane tab showing the network
    editor.

    Note that a floating panel may be locked to one particular pane tab.
    These stripped down panels do not display the interface for adding new
    pane tabs or splitting panes. In fact, these stripped down floating
    panels do not contain any panes at all, and hou.FloatingPanel.panes will
    return an empty tuple. You can create such a stripped down floating
    panel with hou.Desktop.createFloatingPaneTab.

    See hou.Desktop for more information about panes and pane tabs.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_FloatingPanel

    def __repr__(self) -> "std::string":
        return _hou.FloatingPanel___repr__(self)

    def panes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Pane >,std::allocator< HOM_ElemPtr< HOM_Pane > > >":
        r"""

        panes(self) -> tuple of hou.Pane

            Return all the panes inside the panel. As mentioned in the
            documentation for this class, a floating panel may be stripped down
            and locked to one particular pane tab, and these stripped down
            floating panels do not contain any panes.


        """
        return _hou.FloatingPanel_panes(self)

    def paneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        paneTabs(self) -> tuple of hou.PaneTab

            Return all the pane tabs that are in this floating panel, regardless
            of which pane they are in.


        """
        return _hou.FloatingPanel_paneTabs(self)

    def paneTabOfType(self, type: "EnumValue", index: "int" = 0) -> "HOM_PaneTab *":
        r"""

        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return the pane tab with the desired type or None if no
            such pane tab exists.


            type
                A hou.paneTabType enumerated variable.

            index
                If there are multiple tabs with the desired type, this parameter
                determines which one is returned. Use index=0 to return the
                first found tab, index=1 to return the second found tab, etc. By
                default, index is 0.


        """
        return _hou.FloatingPanel_paneTabOfType(self, type, index)

    def findPaneTab(self, name: "char const *") -> "HOM_PaneTab *":
        r"""

        findPaneTab(self, name) -> hou.PaneTab or None

            Return the pane tab with the given name, or None if no such tab
            exists.


        """
        return _hou.FloatingPanel_findPaneTab(self, name)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of the floating panel. The panel's name is displayed
            in its window's title.


        """
        return _hou.FloatingPanel_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Set this panel's name. Any characters in the name that are not
            letters, numbers, or underscores are replaced with underscores.

            Raises hou.OperationFailed if the name is an empty string.


        """
        return _hou.FloatingPanel_setName(self, name)

    def containsPlaybar(self) -> "bool":
        r"""

        containsPlaybar(self) -> bool

            Return whether or not this panel contains Houdini's playbar.

            See also hou.FloatingPanel.setContainsPlaybar.


        """
        return _hou.FloatingPanel_containsPlaybar(self)

    def setContainsPlaybar(self, on: "bool") -> "void":
        r"""

        setContainsPlaybar(self, on)

            If on is True, move Houdini's playbar to this panel. Otherwise, move
            it back to the main desktop window.

            See also hou.FloatingPanel.containsPlaybar.


        """
        return _hou.FloatingPanel_setContainsPlaybar(self, on)

    def containsShelf(self) -> "bool":
        r"""

        containsShelf(self) -> bool

            Return whether or not this panel contains Houdini's shelf.

            See also hou.FloatingPanel.setContainsShelf.


        """
        return _hou.FloatingPanel_containsShelf(self)

    def setContainsShelf(self, on: "bool") -> "void":
        r"""

        setContainsShelf(self, on)

            If on is True, move Houdini's shelf to this panel. Otherwise, move
            it back to the main desktop window.

            See also hou.FloatingPanel.containsShelf.


        """
        return _hou.FloatingPanel_setContainsShelf(self, on)

    def containsStatusBar(self) -> "bool":
        r"""

        containsStatusBar(self) -> bool

            Return whether or not this panel contains Houdini's status bar (the
            bar at the bottom of the desktop for status messages).

            See also hou.FloatingPanel.setContainsStatusBar.


        """
        return _hou.FloatingPanel_containsStatusBar(self)

    def setContainsStatusBar(self, on: "bool") -> "void":
        r"""

        setContainsStatusBar(self, on)

            If on is True, move Houdini's status bar to this panel. Otherwise,
            move it back to the main desktop window.

            See also hou.FloatingPanel.containsStatusBar.


        """
        return _hou.FloatingPanel_setContainsStatusBar(self, on)

    def containsMenuBar(self) -> "bool":
        r"""

        containsMenuBar(self) -> bool

            Return whether or not this panel contains Houdini's main menu bar.

            See also hou.FloatingPanel.setContainsMenuBar.


        """
        return _hou.FloatingPanel_containsMenuBar(self)

    def setContainsMenuBar(self, on: "bool") -> "void":
        r"""

        setContainsMenuBar(self, on)

            If on is True, move Houdini's main menu bar to this panel.
            Otherwise, move it back to the main desktop window.

            See also hou.FloatingPanel.containsMenuBar.


        """
        return _hou.FloatingPanel_setContainsMenuBar(self, on)

    def isAttachedToDesktop(self) -> "bool":
        r"""

        isAttachedToDesktop(self) -> bool

            Return whether or not this panel is attached to the desktop. Panels
            attached to the desktop are saved with the desktop and are opened
            when the desktop is opened and closed when the desktop is closed.

            See also hou.FloatingPanel.attachToDesktop.


        """
        return _hou.FloatingPanel_isAttachedToDesktop(self)

    def attachToDesktop(self, on: "bool") -> "void":
        r"""

        attachToDesktop(self, on)

            Attach this panel to the desktop. See
            hou.FloatingPanel.isAttachedToDesktop for more information.


        """
        return _hou.FloatingPanel_attachToDesktop(self, on)

    def isFullscreen(self) -> "bool":
        r"""

        isFullscreen(self) -> bool

            Return whether or not this panel is in full screen mode.

            See also hou.FloatingPanel.setIsFullscreen.


        """
        return _hou.FloatingPanel_isFullscreen(self)

    def setIsFullscreen(self, on: "bool") -> "void":
        r"""

        setIsFullscreen(self, on)

            Set whether or not this panel is in full screen mode.

            See also hou.FloatingPanel.isFullscreen.


        """
        return _hou.FloatingPanel_setIsFullscreen(self, on)

    def position(self) -> "HOM_Vector2 *":
        r"""

        position(self) -> hou.Vector2

            Return the desktop position (in pixels) of the floating panel
            window.


        """
        return _hou.FloatingPanel_position(self)

    def setPosition(self, position: "_IntTuple") -> "void":
        r"""

        setPosition(self, position)

            Move the floating panel window to the specified desktop position (in
            pixels).

            Raise TypeError if position does not contain exactly two values.


        """
        return _hou.FloatingPanel_setPosition(self, position)

    def size(self) -> "HOM_Vector2 *":
        r"""

        size(self) -> hou.Vector2

            Return the floating panel window's size (in pixels).


        """
        return _hou.FloatingPanel_size(self)

    def setSize(self, size: "_IntTuple") -> "void":
        r"""

        setSize(self, size)

            Resize the floating panel window (in pixels).

            Raise TypeError if size does not contain exactly two values. Raise
            TypeError if size contains a value that is less than or equal to
            zero.


        """
        return _hou.FloatingPanel_setSize(self, size)

    def close(self) -> "void":
        r"""

        close(self)

            Close the floating panel's window, closing all the pane tabs inside
            it.


        """
        return _hou.FloatingPanel_close(self)


# Register FloatingPanel in _hou:
_hou.FloatingPanel_swigregister(FloatingPanel)


class FloatParmTemplate(ParmTemplate):
    r"""

    hou.FloatParmTemplate

    Describes a parameter tuple containing floating point values.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, num_components, default_value=(), min=0.0,
        max=10.0, min_is_strict=False, max_is_strict=False,
        look=hou.parmLook.Regular, naming_scheme=hou.parmNamingScheme.XYZW,
        disable_when=None, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new FloatParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            default_value
                See the defaultValue method for more information.

            min
                See the minValue method for more information.

            max
                See the maxValue method for more information.

            min_is_strict
                See the minIsStrict method for more information.

            max_is_strict
                See the maxIsStrict method for more information.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
        _hou.FloatParmTemplate_swiginit(
            self, _hou.new_FloatParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_FloatParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.FloatParmTemplate___repr__(self)

    def minValue(self) -> "double":
        r"""

        minValue(self) -> float

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
        return _hou.FloatParmTemplate_minValue(self)

    def setMinValue(self, min_value: "double") -> "void":
        r"""

        setMinValue(self, min_value)

            Set the minimum value of the parameter.

            See the minValue method for more information.


        """
        return _hou.FloatParmTemplate_setMinValue(self, min_value)

    def maxValue(self) -> "double":
        r"""

        maxValue(self) -> float

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
        return _hou.FloatParmTemplate_maxValue(self)

    def setMaxValue(self, max_value: "double") -> "void":
        r"""

        setMaxValue(self, max_value)

            Set the maximum value of the parameter.

            See the maxValue method for more information.


        """
        return _hou.FloatParmTemplate_setMaxValue(self, max_value)

    def minIsStrict(self) -> "bool":
        r"""

        minIsStrict(self) -> bool

            Return whether the minimum value is strictly enforced.

            If a minimum value is not strictly enforced, the slider will not let
            you change the value below the minimum, but you can set the value to
            be lower than the minimum by typing it in, changing it via
            hou.Parm.setValue, or using the ladder handle.

            If it is strictly enforced and you try to change it below the
            minimum value using any mechanism, Houdini will set it to the
            minimum value.

            See also the minValue method.


        """
        return _hou.FloatParmTemplate_minIsStrict(self)

    def setMinIsStrict(self, on: "bool") -> "void":
        r"""

        setMinIsStrict(self, on)

            Set whether the minimum value is strictly enforced.

            See the minIsStrict method for more information.


        """
        return _hou.FloatParmTemplate_setMinIsStrict(self, on)

    def maxIsStrict(self) -> "bool":
        r"""

        maxIsStrict(self) -> bool

            Return whether the maximum value is strictly enforced.

            See the minIsStrict method for more information.


        """
        return _hou.FloatParmTemplate_maxIsStrict(self)

    def setMaxIsStrict(self, on: "bool") -> "void":
        r"""

        setMaxIsStrict(self, on)

            Set whether the maximum value is strictly enforced.

            See the maxIsStrict method for more information.


        """
        return _hou.FloatParmTemplate_setMaxIsStrict(self, on)

    def defaultValue(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        defaultValue(self) -> tuple of float

            Return the default value for new parameter instances.

            For example, suppose this parm template is named t, the naming
            scheme is XYZW, it has 3 components, and the default value is (1.0,
            2.0, 3.0). The corresponding parm tuple instance on a node would be
            named t and would contain parameters tx, ty, and tz. When the node
            is created, tx would be 1.0, ty would be 2.0, and tz would be 3.0.


        """
        return _hou.FloatParmTemplate_defaultValue(self)

    def setDefaultValue(self, default_value: "_DoubleTuple") -> "void":
        r"""

        setDefaultValue(self, tuple_of_default_values)

            Set the default value for new parameter instances to a sequence of
            floats.

            See the defaultValue method for more information. Note that if the
            number of floats in the sequence is different from the number of
            components in the parm template, any extra values will be discarded
            and any missing values will become zeros.


        """
        return _hou.FloatParmTemplate_setDefaultValue(self, default_value)

    def defaultExpression(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.

            For example, suppose this parm template is named t, the naming
            scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
            3.0), the default expression is ($F, hou.frame(), ) and the default
            expression language is (hou.scriptLanguage.Hscript,
            hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
            corresponding parm tuple instance on a node would be named t and
            would contain parameters tx, ty, tz. When the node is created, tx
            would have a default Hscript expression of $F, ty would have a
            default Python expression of hou.frame(), and tz would have a
            default value of 3.0.


        """
        return _hou.FloatParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "_StringTuple") -> "void":
        r"""

        setDefaultExpression(self, tuple_of_default_expressions)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.FloatParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
        return _hou.FloatParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
        return _hou.FloatParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "_EnumTuple"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """
        return _hou.FloatParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )


# Register FloatParmTemplate in _hou:
_hou.FloatParmTemplate_swigregister(FloatParmTemplate)


class FolderParmTemplate(ParmTemplate):
    r"""

    hou.FolderParmTemplate

    Describes a folder in a parameter dialog.

    Unlike all other hou.ParmTemplate subclasses, a folder does not
    correspond to an individual hou.ParmTuple. Instead, the set of adjacent
    folders form a folder set, and there is one parameter for this set that
    controls which folder is currently visible. These folder sets correspond
    to hou.FolderSetParmTemplate objects.

    Folder parm template objects are useful when manipulating the parameter
    interface of a node or a digital asset definition. Unlike folder set
    parm templates, they contain the parm templates inside the folder. They
    also let you add, remove, or hide an individual folder or move it from
    set one to another using hou.ParmTemplateGroup objects. Doing these
    individual folder-level operations is not possible with folder set parm
    templates.

    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does. The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block. Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(name, label, parm_templates=(),
        folder_type=hou.folderType.Tabs, is_hidden=False, ends_tab_group=False,
        tags={}, conditionals={}, tab_conditionals={})

            Create a new folder parm template.


            name
                The internal name of the parm template. Normally, parm template
                names correspond directly to parm tuples on nodes. However,
                because folder sets, not folders, correspond directly to parm
                tuples, the name used for the folder set parm tuple is the name
                of the first folder parm template in the set of adjacent folder
                parm templates.

            label
                The name of the folder that is displayed in the parameter
                dialog.

            parm_templates
                A sequence of hou.ParmTemplate subclass objects for the
                parameters inside the folder. Folders may be nested in other
                folders by putting FolderParmTemplates in this sequence.

            folder_type
                A hou.folderType enumerated value controlling whether the
                parameter is a folder or a multiparm block. This value controls
                the look of the folder/multiparm instance.

            is_hidden
                Whether or not this folder is hidden.

            ends_tab_group
                If True, this folder will be the last in the folder set, even if
                the next parameter is also a folder. In that case, the next
                parameter will begin a new folder set.

            tags
                A dictionary of extra information attached to the parm template.

            conditionals
                A dictionary that specifies conditionals (i.e. disable when,
                hide when) on the parameter template. For folder tab parameters
                these conditionals affect the entire folder set.

                The dictionary maps hou.parmCondType types to conditional
                strings.

                See the Conditionals section of the <Operator Type Properties
                window> help for more information on conditional strings.

            tab_conditionals
                A dictionary that specifies conditionals (i.e. disable when,
                hide when) on the parameter template. These conditionals affect
                only the folder tab generated by this parameter template and not
                the entire folder set.

                The dictionary maps hou.parmCondType types to conditional
                strings.

                See the Conditionals section of the <Operator Type Properties
                window> help for more information on conditional strings.

                hou.OperationFailed is raised if tab conditionals are specified
                for multi-parameter templates or import blocks.


        """
        _hou.FolderParmTemplate_swiginit(
            self, _hou.new_FolderParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_FolderParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.FolderParmTemplate___repr__(self)

    def folderStyle(self) -> "HOM_EnumValue &":
        return _hou.FolderParmTemplate_folderStyle(self)

    def folderType(self) -> "HOM_EnumValue &":
        r"""

        folderType(self) -> hou.folderType enum value

            Return the type of folder. Note that the folder may actually be a
            multiparm block.


        """
        return _hou.FolderParmTemplate_folderType(self)

    def setFolderType(self, folder_type: "EnumValue") -> "void":
        r"""

        setFolderType(self, folder_type)

            Set the type of folder to a hou.folderType enum value.


        """
        return _hou.FolderParmTemplate_setFolderType(self, folder_type)

    def isActualFolder(self) -> "bool":
        r"""

        isActualFolder(self) -> bool

            Return whether or not this parm template corresponds to an actual
            folder, as opposed to a multiparm or import block.

            This method can be implemented as follows:

          > def isActualFolder(self):
          >     return self.folderType() in (
          >         hou.folderType.Tabs, hou.folderType.RadioButtons)

        """
        return _hou.FolderParmTemplate_isActualFolder(self)

    def defaultValue(self) -> "int":
        r"""

        defaultValue(self) -> int

            Return the integer default value.

            The default value is only used for folders that are multiparm
            blocks, and controls the default number of multiparm instances in
            newly created nodes.


        """
        return _hou.FolderParmTemplate_defaultValue(self)

    def setDefaultValue(self, default_value: "int") -> "void":
        r"""

        setDefaultValue(self, tuple_of_default_values)

            Set the default value to an integer.

            The default value is only used for folders that are multiparm
            blocks. See the defaultValue method for more information.


        """
        return _hou.FolderParmTemplate_setDefaultValue(self, default_value)

    def tabConditionals(
        self,
    ) -> "std::map< HOM_EnumValue *,std::string,std::less< HOM_EnumValue * >,std::allocator< std::pair< HOM_EnumValue *const,std::string > > >":
        r"""

        tabConditionals(self) -> dict of [Hom:hou.parmCondType] enum value to
        string

            Returns the set of conditionals that affect the folder tab generated
            by this parameter template. The conditionals correspond to the Tab
            disable when and Tab hide when properties that appear Edit Parameter
            Interface window for folder parameters.

            See the Conditionals section of the <Operator Type Properties
            window> help for more information on conditional strings.

            This method returns an empty dictionary if this parameter template
            is for a multi-parameter or import block.


        """
        return _hou.FolderParmTemplate_tabConditionals(self)

    def setTabConditional(
        self, cond_type: "EnumValue", conditional: "char const *"
    ) -> "void":
        r"""

        setTabConditional(self, type, conditional)

            Set a conditional string of the given hou.parmCondType type that
            affects the folder tab generated by this parameter template. The
            string consists of rules on how this parameter's folder tab's
            display behaves when other parameters change.

            See the Conditionals section of the <Operator Type Properties
            window> help for more information on conditional strings.

            Raises hou.OperationFailed if this parameter template is for a
            multi-parameter or import block.


        """
        return _hou.FolderParmTemplate_setTabConditional(self, cond_type, conditional)

    def endsTabGroup(self) -> "bool":
        r"""

        endsTabGroup(self) -> bool

            Return whether this folder will be the last in the folder set, even
            if the next parameter is also a folder. In that case, the next
            parameter will begin a new folder set.

            This parameter only has meaning if the parm template is for an
            actual folder and not for a multiparm block.


        """
        return _hou.FolderParmTemplate_endsTabGroup(self)

    def setEndsTabGroup(self, on: "bool") -> "void":
        r"""

        setEndsTabGroup(self, on)

            Set the flag to indicate whether or not the folder tab is the last
            one in the folder set. If the flag is set to True and the next
            parameter is also a folder, then that next folder will begin a new
            folder set.

            This parameter only has meaning if the parm template is for an
            actual folder and not for a multiparm block.


        """
        return _hou.FolderParmTemplate_setEndsTabGroup(self, on)

    def parmTemplates(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTemplate >,std::allocator< HOM_ElemPtr< HOM_ParmTemplate > > >":
        r"""

        parmTemplates(self) -> tuple of hou.ParmTemplate

            Return a tuple of copies of the parm templates stored inside this
            folder.

            Because copies are returned, you cannot change the contents of the
            parm templates inside this folder by modifying the parm templates
            returned. Instead, use methods in hou.ParmTemplateGroup to modify
            parm templates in this folder.


        """
        return _hou.FolderParmTemplate_parmTemplates(self)

    def setParmTemplates(self, parm_templates: "_ParmTemplateTuple") -> "void":
        r"""

        setParmTemplates(self, parm_templates)

            Replace the parm templates inside this folder with a new sequence of
            parm templates.


        """
        return _hou.FolderParmTemplate_setParmTemplates(self, parm_templates)

    def addParmTemplate(self, parm_template: "ParmTemplate") -> "void":
        r"""

        addParmTemplate(self, parm_template)

            Append a parm template to the end of the list of parm templates
            inside the folder.

            Note that hou.ParmTemplateGroup provides a number of methods to
            insert parm templates inside folders, including
            hou.ParmTemplateGroup.appendToFolder.


        """
        return _hou.FolderParmTemplate_addParmTemplate(self, parm_template)


# Register FolderParmTemplate in _hou:
_hou.FolderParmTemplate_swigregister(FolderParmTemplate)


class FolderSetParmTemplate(ParmTemplate):
    r"""

    hou.FolderSetParmTemplate

    Describes a set of folders.

    A folder set is a group of adjacent folders, and only one of those
    folders can be displayed at a time. A folder set corresponds to one
    parameter, and the value of that parameter determines which folder is
    displayed.

    Note that there is also a hou.FolderParmTemplate class. Folder sets are
    used when there is a mapping to a parameter; for example, asking a
    hou.ParmTuple for its parm template may return a folder set, but it will
    never return a folder. Folder parm templates are used by
    hou.ParmTemplateGroup because they easily let you add, remove, and move
    individual folders, and they let you easily place parameters inside
    folders. Attempting to place folder set parm templates in
    hou.ParmTemplateGroup objects will raise hou.OperationFailed.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        hou.FolderSetParmTemplate

        Describes a set of folders.

        A folder set is a group of adjacent folders, and only one of those
        folders can be displayed at a time. A folder set corresponds to one
        parameter, and the value of that parameter determines which folder is
        displayed.

        Note that there is also a hou.FolderParmTemplate class. Folder sets are
        used when there is a mapping to a parameter; for example, asking a
        hou.ParmTuple for its parm template may return a folder set, but it will
        never return a folder. Folder parm templates are used by
        hou.ParmTemplateGroup because they easily let you add, remove, and move
        individual folders, and they let you easily place parameters inside
        folders. Attempting to place folder set parm templates in
        hou.ParmTemplateGroup objects will raise hou.OperationFailed.


        """
        _hou.FolderSetParmTemplate_swiginit(
            self, _hou.new_FolderSetParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_FolderSetParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.FolderSetParmTemplate___repr__(self)

    def folderNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        setFolderNames(self, folder_names)

            Set the names of the folders in this set to the given sequence of
            strings.

            See the folderNames method for more information.

            Raises hou.OperationFailed if folder_names is an empty sequence.


        """
        return _hou.FolderSetParmTemplate_folderNames(self)

    def setFolderNames(self, folder_names: "_StringTuple") -> "void":
        return _hou.FolderSetParmTemplate_setFolderNames(self, folder_names)

    def folderType(self) -> "HOM_EnumValue &":
        r"""

        folderType(self) -> hou.folderType enum value

            Return the type of folder.


        """
        return _hou.FolderSetParmTemplate_folderType(self)

    def setFolderType(self, folder_type: "EnumValue") -> "void":
        r"""

        setFolderType(self, folder_type)

            Set the type of folder to a hou.folderType enum value.

            Raises TypeError if the folder type is for a multiparm or import
            block.


        """
        return _hou.FolderSetParmTemplate_setFolderType(self, folder_type)

    def folderStyle(self) -> "HOM_EnumValue &":
        r"""

        folderStyle(self) -> hou.folderType enum value

            This method is deprecated. It is an alias for the folderType method.


        """
        return _hou.FolderSetParmTemplate_folderStyle(self)


# Register FolderSetParmTemplate in _hou:
_hou.FolderSetParmTemplate_swigregister(FolderSetParmTemplate)


class GadgetContext(object):
    r"""

    hou.GadgetContext

    The base class for a viewer resource gadget context.

    OVERVIEW

        hou.GadgetContext provides a common interface to viewer resources
        such as Python viewer handles and Python viewer states. It holds
        relevant information about the gadget drawables bound to the viewer
        resource currently running in the viewport.

    RELATED

        hou.ViewerStateContext hou.ViewerHandleContext


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_GadgetContext

    def gadget(self) -> "std::string":
        r"""

        gadget(self) -> string

            Returns the name of the active gadget drawable. A gadget is active
            when it is picked or when the mouse moves over the gadget geometry
            (located).


        """
        return _hou.GadgetContext_gadget(self)

    def gadgetLabel(self) -> "std::string":
        r"""

        gadgetLabel(self) -> string

            The active gadget label name.


        """
        return _hou.GadgetContext_gadgetLabel(self)

    def component1(self) -> "int":
        r"""

        component1(self) -> int

            A component id of the active gadget geometry. The id refers to
            either a polygon, a polygon vertex or the start point of a line
            geometry. Returns -1 if no gadget is active.


        """
        return _hou.GadgetContext_component1(self)

    def component2(self) -> "int":
        r"""

        component2(self) -> int

            A component id of the active gadget geometry. The returned id
            typically identifies the end point of a line geometry. Returns -1 if
            no line geometry is picked or located or no gadget is active.


        """
        return _hou.GadgetContext_component2(self)

    def isLocating(self) -> "bool":
        r"""

        isLocating(self) -> bool

            Returns True if any gadget is being located.


        """
        return _hou.GadgetContext_isLocating(self)

    def isPicking(self) -> "bool":
        r"""

        isPicking(self) -> bool

            Returns True if any gadget is being picked.


        """
        return _hou.GadgetContext_isPicking(self)

    def isDrawing(self) -> "bool":
        r"""

        isDrawing(self) -> bool

            Returns True if the handle is in a drawing state which means no
            gadget is being picked or located.


        """
        return _hou.GadgetContext_isDrawing(self)

    def isLocated(self, gadget_name: "std::string const &") -> "bool":
        r"""

        isLocated(gadget_name) -> bool

            Returns True if a given gadget is located.


            gadget_name
                Name of the gadget to test.


        """
        return _hou.GadgetContext_isLocated(self, gadget_name)

    def isPicked(self, gadget_name: "std::string const &") -> "bool":
        r"""

        isPicked(gadget_name) -> bool

            Returns True if a given gadget is picked.


            gadget_name
                Name of the gadget to test.


        """
        return _hou.GadgetContext_isPicked(self, gadget_name)


# Register GadgetContext in _hou:
_hou.GadgetContext_swigregister(GadgetContext)


class galleries(object):
    r"""

    hou.galleries

    A module for managing galleries and their entries.

    This module provides a few basic functions for accessing and managing
    hou.Gallery and hou.GalleryEntry.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_galleries

    def __repr__(self) -> "std::string":
        return _hou.galleries___repr__(self)

    def galleries(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Gallery >,std::allocator< HOM_ElemPtr< HOM_Gallery > > >":
        r"""

        galleries() -> tuple of hou.Gallery

            Return a tuple containing all the galleries currently installed in
            the Houdini session.


        """
        return _hou.galleries_galleries(self)

    def galleryEntries(
        self,
        name_pattern: "char const *" = None,
        label_pattern: "char const *" = None,
        keyword_pattern: "char const *" = None,
        category: "char const *" = None,
        node_type: "NodeType" = None,
    ) -> "std::vector< HOM_ElemPtr< HOM_GalleryEntry >,std::allocator< HOM_ElemPtr< HOM_GalleryEntry > > >":
        r"""

        galleryEntries(name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry

            Return a tuple of hou.GalleryEntry objects matching the search
            criteria. The result is the intersection of the matches against all
            the parameters. If you call this function with no parameters, it
            returns all the gallery entries. See also
            hou.Gallery.galleryEntries.

            Unless a parameter is None, the results are filtered by the
            following:


            name_pattern
                gallery entry names matching this pattern

            label_pattern
                gallery entry label names matching this pattern

            keyword_pattern
                gallery entries that have a keyword matching this pattern

            category
                gallery entries in a category matching this pattern

            node_type
                gallery entries that can be applied to this node type

            This example prints all the gallery entries starting with a b that
            have the Material keyword.

          > >>> hou.galleries.galleryEntries(\"b*\", keyword_pattern=\"Material\")
          > (<hou.GalleryEntry \"basic_surface\">, <hou.GalleryEntry \"bumpy_glass\">, ...)

            This example prints the name and description of all the entries in
            the Metals category:

          > >>> for entry in hou.galleries.galleryEntries(category=\"Metals\"):
          > ...     print \"%s: %s\" % (entry.name(), entry.description())
          > chrome: Very bright metal with mirror reflections
          > aged_metal: Aged metal material with ray traced or environment mapped reflections
          > ...

            This example prints the gallery entry names for the Lsystem SOP.

          > >>> node_type = hou.nodeType(hou.sopNodeTypeCategory(), \"lsystem\")
          > >>> for entry in hou.galleries.galleryEntries(node_type=node_type):
          > ...     print entry.name()
          > planta
          > plantb
          > plantc
          > ...
          > sympodial_tree
          > ternary_tree
          > wheel

        """
        return _hou.galleries_galleryEntries(
            self, name_pattern, label_pattern, keyword_pattern, category, node_type
        )

    def installGallery(self, gallery_path: "char const *") -> "HOM_Gallery *":
        r"""

        installGallery(gallery_path) -> hou.Gallery or None

            Load a gallery into the current Houdini session.


            gallery_path
                The file path of the gallery to be installed.


        """
        return _hou.galleries_installGallery(self, gallery_path)

    def removeGallery(self, gallery_path: "char const *") -> "bool":
        r"""

        removeGallery(gallery_path) -> bool

            Remove a gallery from the current Houdini session. Returns False if
            the specified gallery file was not installed.


            gallery_path
                The file path of the gallery to be removed.


        """
        return _hou.galleries_removeGallery(self, gallery_path)

    def createGalleryEntry(
        self,
        gallery_path: "char const *",
        entry_name: "char const *",
        node: "Node" = None,
    ) -> "HOM_GalleryEntry *":
        r"""

        createGalleryEntry(gallery_path, entry_name, node) -> hou.GalleryEntry
        or None

            Create and return a new gallery entry.


            gallery_path
                The path of the gallery file in which the new element should be
                stored.

            entry_name
                The name of the new gallery entry.

            node
                The operator node from which the new gallery entry should copy
                the settings. The settings include parameter values, channels,
                spare parameters etc, and also the children nodes if the node is
                a subnetwork.


        """
        return _hou.galleries_createGalleryEntry(self, gallery_path, entry_name, node)


# Register galleries in _hou:
_hou.galleries_swigregister(galleries)


class Gallery(object):
    r"""

    hou.Gallery

    A collection of gallery entries that can be applied to operator nodes to
    set their parameters to predefined values.

    In Houdini, a gallery is a collection of node templates and their
    parameter presets, which are represented by a hou.GalleryEntry. A
    gallery corresponds to a file where such templates are saved. Galleries
    can be managed with a hou.galleries module.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Gallery

    def __repr__(self) -> "std::string":
        return _hou.Gallery___repr__(self)

    def galleryEntries(
        self,
        name_pattern: "char const *" = None,
        label_pattern: "char const *" = None,
        keyword_pattern: "char const *" = None,
        category: "char const *" = None,
        node_type: "NodeType" = None,
    ) -> "std::vector< HOM_ElemPtr< HOM_GalleryEntry >,std::allocator< HOM_ElemPtr< HOM_GalleryEntry > > >":
        r"""

        galleryEntries(self, name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry

            Return a tuple of entries that are stored in the gallery. See also
            hou.galleries.galleryEntries.


            name_pattern
                A pattern that the gallery entry name must match to be included
                in the returned tuple. The pattern can contain '?' to match a
                single character, '*' to match any number of characters, and ''
                to match any character in the set. If None, all gallery entries
                are considered to match it.

            label_pattern
                A pattern that the gallery entry label must match to be included
                in the returned tuple. See the name_pattern above for special
                characters in the pattern. If None, all gallery entries are
                considered to match it.

            keyword_pattern
                A pattern that any of the gallery entry keywords needs to match
                for the entry to be included in the returned tuple. See the
                name_pattern above for special characters in the pattern. If
                None, all gallery entries are considered to match it.

            category
                If not None, only gallery entries in the specified category will
                be included in the returned tuple.

            node_type
                If not None, only gallery entries for a given node type will be
                included in the returned tuple.


        """
        return _hou.Gallery_galleryEntries(
            self, name_pattern, label_pattern, keyword_pattern, category, node_type
        )

    def createEntry(
        self, entry_name: "char const *", node: "Node" = None
    ) -> "HOM_GalleryEntry *":
        return _hou.Gallery_createEntry(self, entry_name, node)

    def deleteEntry(self, entry_name: "char const *") -> "void":
        return _hou.Gallery_deleteEntry(self, entry_name)


# Register Gallery in _hou:
_hou.Gallery_swigregister(Gallery)


class GalleryEntry(object):
    r"""

    hou.GalleryEntry

    A gallery entry that can be applied to operator nodes to set their
    parameters to predefined values.

    A gallery entry is an entity containing data about an operator node
    setup. It has information about the node's parameter values, any
    additional spare parameters, channels, and for subnet nodes the
    information about the children, etc. Thus, a gallery entry is like a
    node template or a parameter preset. Such templates can be created from
    and applied to existing nodes.

    A gallery entry is identified by a unique, and has a non-unique label,
    and is usually associated with a specific hou.NodeType (or several node
    types) of the nodes to which it applies. In addition to the node
    information, gallery entries can have own categories that organize them
    into manageable sets and also can have keywords that identify their
    purpose. For more information about gallery entries, please see a
    gallery entry editor.

    In order for your gallery entries to appear in the Material Palette
    pane, they must satisfy two conditions. First, the node category must be
    set to indicate the gallery entry creates a SHOP node. Use code like:

    > hou.galleries.galleryEntries(\"entry_name\")[0].setNodeTypeCategory(hou.shopNodeTypeCategory())

    The second condition is that the entry must contain one or more keywords
    that indicate what renderer the SHOP works with. This affects whether
    the gallery entry appears when a specific renderer is chosen in the
    Material Palette renderer menu. Even if All is chosen in that menu, the
    gallery entry must contain a keyword that matches one of the renderers
    that appears in that menu. To associate a gallery entry with the Mantra
    renderer, do the following:

    > hou.galleries.galleryEntries(\"entry_name\")[0].setKeywords(('Mantra',))

    In HOM the gallery entries can be managed using hou.Gallery.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GalleryEntry

    def __repr__(self) -> "std::string":
        return _hou.GalleryEntry___repr__(self)

    def canApplyToNode(self, node: "Node") -> "bool":
        r"""

        canApplyToNode(self, node) -> bool

            Return True if this gallery entry can be safely applied to the given
            node. See hou.GalleryEntry.applyToNode for more info.


            node
                A node to test whether the gallery entry can be applied to.


        """
        return _hou.GalleryEntry_canApplyToNode(self, node)

    def applyToNode(self, node: "Node") -> "void":
        r"""

        applyToNode(self, node)

            Apply the gallery entry to a given node. This method sets the node's
            parameter values to match the ones stored by the entry. It may also
            add spare parameters and channels to the node and for the subnets,
            it may create new child nodes.


            node
                A node to which to apply the gallery entry.


        """
        return _hou.GalleryEntry_applyToNode(self, node)

    def canCreateChildNode(self, parent: "Node") -> "bool":
        r"""

        canCreateChildNode(self, parent) -> bool

            Return True if hou.GalleryEntry.createChildNode can succeed.


        """
        return _hou.GalleryEntry_canCreateChildNode(self, parent)

    def createChildNode(self, parent: "Node") -> "HOM_Node *":
        r"""

        createChildNode(self, parent) -> Node

            Create a new node in the parent network and then apply this gallery
            entry to that newly created node.


            parent
                A subnetwork within which the new node should be created. If
                None, an implicit natural parent is chosen using a node type
                this gallery entry is associated with.


        """
        return _hou.GalleryEntry_createChildNode(self, parent)

    def setEqual(self, entry: "GalleryEntry") -> "void":
        r"""

        setEqual(self, entry)

            Set this gallery entry to be exactly the same as the given entry,
            except for the name, which is left unchanged.


            entry
                The gallery entry to copy the information from.


        """
        return _hou.GalleryEntry_setEqual(self, entry)

    def name(self) -> "std::string":
        r"""

        name(self) -> string

            Return the gallery entry name.


        """
        return _hou.GalleryEntry_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Set the gallery entry name.


            name
                The name string.


        """
        return _hou.GalleryEntry_setName(self, name)

    def label(self) -> "std::string":
        r"""

        label(self) -> str

            Return the gallery entry label.


        """
        return _hou.GalleryEntry_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self, label)

            Set the gallery entry label.


            label
                The label string.


        """
        return _hou.GalleryEntry_setLabel(self, label)

    def description(self) -> "std::string":
        r"""

        description(self) -> string

            Return a description of the gallery entry. A description is a short
            string that states the gallery entry purpose. It is used for tool-
            tip pop-ups.


        """
        return _hou.GalleryEntry_description(self)

    def setDescription(self, description: "char const *") -> "void":
        r"""

        setDescription(self, description)

            Set the description of the gallery entry.


            description
                The text briefly describing the gallery entry purpose.


        """
        return _hou.GalleryEntry_setDescription(self, description)

    def helpURL(self) -> "std::string":
        r"""

        helpURL(self) -> string

            Return the URL of the help document for this gallery entry.


        """
        return _hou.GalleryEntry_helpURL(self)

    def setHelpURL(self, helpurl: "char const *") -> "void":
        r"""

        setHelpURL(self, helpurl)

            Set the URL of the help document for this gallery entry.


        """
        return _hou.GalleryEntry_setHelpURL(self, helpurl)

    def requiredHDAFile(self) -> "std::string":
        r"""

        requiredHDAFile(self) -> string

            Return a file path to an HDA library that should be loaded before
            trying to apply this gallery entry. It is often used for gallery
            entries associated with a non-native operator type.


        """
        return _hou.GalleryEntry_requiredHDAFile(self)

    def setRequiredHDAFile(self, hda_file: "char const *") -> "void":
        r"""

        setRequiredHDAFile(self, hda_file)

            Set a file path to an HDA library on which this gallery entry
            depends.


            hda_file
                A path of the HDA library file (OTL).


        """
        return _hou.GalleryEntry_setRequiredHDAFile(self, hda_file)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> string

            Return the icon name or a icon file path that should be used for
            this gallery entry.


        """
        return _hou.GalleryEntry_icon(self)

    def setIcon(self, icon: "char const *") -> "void":
        r"""

        setIcon(self, icon)

            Set the icon name or an icon file path that should be used for this
            gallery entry.


        """
        return _hou.GalleryEntry_setIcon(self, icon)

    def allowIconRegeneration(self) -> "bool":
        r"""

        allowIconRegeneration(self) -> bool

            Return True if this gallery entry wants to let Houdini regenerate
            the icon for it automatically using an appropriate renderer. Only
            applies to material gallery entries.


        """
        return _hou.GalleryEntry_allowIconRegeneration(self)

    def setAllowIconRegeneration(self, on: "bool") -> "void":
        r"""

        setAllowIconRegeneration(self, allow)

            Sets the allow icon regeneration flag on this gallery entry.


        """
        return _hou.GalleryEntry_setAllowIconRegeneration(self, on)

    def isHidden(self) -> "bool":
        r"""

        isHidden(self) -> bool

            Return True if this gallery entry is hidden from the tools gallery
            menu.


        """
        return _hou.GalleryEntry_isHidden(self)

    def setHidden(self, hide: "bool") -> "void":
        r"""

        setHidden(self, hide)

            Set the hidden flag which controls whether a gallery entry is shown
            in the tools gallery menu.


        """
        return _hou.GalleryEntry_setHidden(self, hide)

    def bestNodeType(self) -> "HOM_NodeType *":
        r"""

        bestNodeType(self) -> NodeType or None

            Return a best node type which this gallery entry is associated with
            and whose nodes it can be applied to.


        """
        return _hou.GalleryEntry_bestNodeType(self)

    def nodeTypeNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        nodeTypeNames(self) -> tuple of strings

            Return the names of the node type this gallery is associated with.
            The gallery can be safely applied to the nodes of these types.


        """
        return _hou.GalleryEntry_nodeTypeNames(self)

    def setNodeTypeNames(self, nodetypes: "_StringTuple") -> "void":
        r"""

        setNodeTypeNames(self, nodetypes)

            Set the names of the node types this gallery should be associated
            with.


            nodetypes
                A string containing white-space separated list of node type
                names.


        """
        return _hou.GalleryEntry_setNodeTypeNames(self, nodetypes)

    def categories(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        categories(self) -> tuple of strings

            Return the categories this gallery entry subscribes to.


        """
        return _hou.GalleryEntry_categories(self)

    def setCategories(self, categories: "_StringTuple") -> "void":
        r"""

        setCategories(self, categories)

            Set the categories this gallery entry subscribes to.


            categories
                A sequence of strings containing the categories to set the
                gallery entry to.


        """
        return _hou.GalleryEntry_setCategories(self, categories)

    def keywords(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        keywords(self) -> tuple of strings

            Return the keywords that describe this gallery entry.


        """
        return _hou.GalleryEntry_keywords(self)

    def setKeywords(self, keywords: "_StringTuple") -> "void":
        r"""

        setKeywords(self, keywords)

            Set the keywords that describe this gallery entry.


            keywords
                A string containing a white-space separated list of keywords.


        """
        return _hou.GalleryEntry_setKeywords(self, keywords)

    def nodeTypeCategory(self) -> "HOM_NodeTypeCategory &":
        r"""

        nodeTypeCategory(self) -> NodeTypeCategory

            Return the category of the node types this gallery entry is
            associated with.


        """
        return _hou.GalleryEntry_nodeTypeCategory(self)

    def setNodeTypeCategory(self, category: "NodeTypeCategory") -> "void":
        r"""

        setNodeTypeCategory(self, category)

            Set the category of the node types this gallery entry should be
            associated with.


            category
                A hou.NodeTypeCategory to associate this gallery entry with.


        """
        return _hou.GalleryEntry_setNodeTypeCategory(self, category)

    def script(self) -> "std::string":
        r"""

        script(self) -> string

            Return a script that modifies the node parameters to match the
            information stored in the gallery entry.


        """
        return _hou.GalleryEntry_script(self)

    def setScript(self, script: "char const *") -> "void":
        r"""

        setScript(self, script)

            Set a script that modifies the parameters when the gallery entry is
            applied to a node.


            script
                A string that contains the commands setting the node's
                parameters.


        """
        return _hou.GalleryEntry_setScript(self, script)

    def setScriptFromNode(self, node: "Node") -> "void":
        r"""

        setScriptFromNode(self, node)

            Set a script that modifies node parameters. Later on, when applying
            this gallery entry to a node, the script will reconstruct that
            node's parameters to match exactly the parameters of a node passed
            to this method.


            node
                A node object from which to build the script.


        """
        return _hou.GalleryEntry_setScriptFromNode(self, node)

    def setContentsFromNode(self, node: "Node") -> "void":
        r"""

        setContentsFromNode(self, node)

            Save the information about the node contents (i.e., child nodes).
            When applying the node entry later on, these nodes will be
            reconstructed in a new parent to match the contents of the current
            parent.


            node
                The parent of the nodes whose data should be saved.


        """
        return _hou.GalleryEntry_setContentsFromNode(self, node)


# Register GalleryEntry in _hou:
_hou.GalleryEntry_swigregister(GalleryEntry)


class Geometry(object):
    r"""

    hou.Geometry

    A Geometry object contains the points and primitives that define a 3D
    geometric shape. For example, each SOP node in Houdini generates a
    single Geometry object.

    If you ask a SOP for its geometry via hou.SopNode.geometry, you'll get a
    read-only reference to it. If the SOP recooks, the corresponding
    Geometry object will update to the SOP's new geometry. If the SOP is
    deleted, accessing the Geometry object will raise a hou.ObjectWasDeleted
    exception. If you call methods that try to modify the geometry, they
    will raise a hou.GeometryPermissionError exception.


    NOTE
        Whenever you call a method on a hou.Geometry object, Houdini will
        first attempt to acquire a handle to the underlying geometry. When
        working with read-only references to geometry on a SOP node, if the
        SOP in question fails to cook after the read-only reference has been
        assigned to a variable then any calls to methods on that variable
        will throw a hou.InvalidGeometry exception. If you receive this
        exception, your read-only reference is still 'live' and so methods
        on it will be accessible when the node errors are resolved, until
        then your code should handle this exception to avoid getting further
        errors. See hou.Geometry.isValid

    If you do not want the geometry to update when the SOP recooks, you can
    call hou.Geometry.freeze. freeze returns another Geometry object that
    will not change when the SOP recooks. Accessing frozen Geometry is
    slightly faster, since Houdini does not need to look up the SOP node for
    each access, so you may want to use frozen geometry for speed-crucial
    operations.

    If you're writing a SOP using Python, you will have read-write access to
    the geometry, and it will be frozen. To create a Python-defined SOP,
    select File > New Operator Type... and place the Python code in the Code
    tab.

    Finally, you can allocate a new frozen geometry with read-write access
    by creating an instance of hou.Geometry.

    GEOMETRY MODIFICATION

        Since Houdini 18, modifying geometry outside of cooking that is then
        passed into other HOM methods requires a corresponding increment of
        the appropriate data ids as well as incrementing the modification
        counter. This is especially important if you pass this geometry to
        be processed such as hou.SopVerb.execute since it uses data id
        optimizations. The simplest way to do this is to call
        hou.Geometry.incrementAllDataIds. However, a fine-grained list of
        methods can used to obtain the best performance:
        hou.Geometry.incrementDataIdsForAddOrRemove,
        hou.Geometry.incrementPrimitiveIntrinsicsDataId,
        hou.Geometry.incrementTopologyDataId, hou.Attrib.incrementDataId,
        hou.PointGroup.incrementDataId, hou.PrimGroup.incrementDataId,
        hou.EdgeGroup.incrementDataId, hou.VertexGroup.incrementDataId,
        hou.Geometry.incrementModificationCounter.

        When modifying geometry while inside a SOP, all data ids are
        automatically incremented, as well as the geometry change counter.
        To opt out of automatic data ids incrementing, call
        hou.SopNode.setManagesAttribDataIds with True. Note that you cannot
        opt out of incrementing the geometry change counter, it must be
        always done whenever a SOP node cooks. When unsure, it is better to
        leave hou.SopNode.managesAttribDataIds to the default False or else
        there is a risk that users of the output geometry (eg. the viewport)
        will fail to update when the geometry has changed.

    RELATED

      * hou.AttribDataId


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, geo: "Geometry" = None, clone_data_ids: "bool" = False):
        r"""

        isValid(self)

            Check that the hou.Geometry object references a non-null geometry.

            Will only be False when the hou.Geometry is a read-only reference to
            a SOP node's geometry that has failed to cook since the reference
            was assigned.

            Will always be True for a 'frozen' geometry, see also
            hou.Geometry.freeze.


        """
        _hou.Geometry_swiginit(self, _hou.new_Geometry(geo, clone_data_ids))

    __swig_destroy__ = _hou.delete_Geometry

    def __repr__(self) -> "std::string":
        return _hou.Geometry___repr__(self)

    def sopNode(self) -> "HOM_SopNode *":
        r"""

        sopNode(self) -> hou.SopNode

            If the Geometry is not frozen, return the hou.SopNode object
            corresponding to this Geometry. Otherwise, return None.

            See hou.Geometry.freeze for more information on frozen geometry.


        """
        return _hou.Geometry_sopNode(self)

    def sopNodeOutputIndex(self) -> "int":
        r"""

        sopNodeOutputIndex(self) -> int

            If the Geometry is not frozen, return the index of the SOP node
            output that this geometry corresponds to. Otherwise, return -1.

            For most cases this method will return 0 to indicate that the
            geometry corresponds to the first output. This method will only
            return a value other than 0 for SOP nodes that have multiple
            outputs.

            See hou.Geometry.freeze for more information on frozen geometry.


        """
        return _hou.Geometry_sopNodeOutputIndex(self)

    def isValid(self) -> "bool":
        return _hou.Geometry_isValid(self)

    def freeze(
        self, read_only: "bool" = False, clone_data_ids: "bool" = False
    ) -> "HOM_Geometry *":
        r"""

        freeze(self, read_only=False, clone_data_ids=False) -> hou.Geometry

            Return another Geometry object that is not linked to a particular
            SOP.

            Normally, when you call hou.SopNode.geometry, the resultant Geometry
            object retains a reference to that SOP, and is said to be unfrozen.
            Each time you access points, primitives, attributes, etc. in an
            unfrozen Geometry object, Houdini uses the SOP's latest cooked
            geometry. So, if you change parameters or change the time for an
            animated SOP, the Geometry object will update to the SOP's new
            geometry.

            Unless Python SOPs are involved, a frozen Geometry object does not
            have a similar live association with a particular SOP. If you ask a
            SOP for its geometry and then store a frozen copy of that geometry,
            when the SOP recooks the frozen Geometry object will not update.
            Instead, the frozen geometry saves its own copy of the point and
            primitive data, and is unaffected by subsequent changes to the SOP.
            When a frozen Geometry object is destroyed, any geometry copy it
            created is also destroyed.

            Note that accessing a Geometry object's points, primitives,
            attributes, etc. may be faster when dealing with frozen objects. You
            may want to work with frozen Geometry in speed-sensitive operations.

            Calling this method on an unfrozen Geometry object returns a frozen
            one. Calling it on a frozen object has no effect, and it returns a
            frozen object.

            When a Python-defined SOP cooks and runs Python code that asks for
            the SOP's geometry, the returned Geometry object is writable.
            Modifying this Geometry object affects the output of this SOP. For
            efficiency, this geometry object is already frozen, so calling
            freeze on it has no effect.


            read_only
                If True, the resulting frozen geometry will be read-only. Use
                read-only frozen geometry to share embedded geometry among
                multiple packed primitives.

            clone_data_ids
                If the conditions of this method causes a copy of the geometry
                to be made, then this specifies whether the new copy will have
                the same data ids. This is useful to enable optimizations that
                cache data by only looking at the attribute data id regardless
                of whether it is from the same geometry object or not.
                Otherwise, the new copy will have data ids that are unique.


        """
        return _hou.Geometry_freeze(self, read_only, clone_data_ids)

    def iterPoints(self) -> "HOM_IterableList< HOM_Point > *":
        r"""

        iterPoints(self) -> generator of hou.Point

            Return a generator that iterates through all the points in the
            geometry.

            Whereas hou.Geometry.points allocates and returns a tuple of all the
            points in the geometry, this method returns a generator object that
            will allocate hou.Point objects on demand. This object is very fast
            at random access into the sequence.

            If you're accessing a specific point by index and the geometry
            contains many points, it is faster to use iterPoints() than
            points(). If, however, you are iterating over all the points in the
            geometry, it is generally faster to use points() than iterPoints().

          > # This is preferred:
          > geo.iterPoints()[23]
          >
          > # over this:
          > geo.points()[23]
          >
          > # But this is preferred:
          > for point in geo.points():
          >     ...process point...
          >
          > # over this:
          > for point in geo.iterPoints():
          >     ...process point...

        """
        return _hou.Geometry_iterPoints(self)

    def points(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        points(self) -> tuple of hou.Point

            Return a tuple of all the points in the geometry.

            See also the hou.Geometry.iterPoints method.


        """
        return _hou.Geometry_points(self)

    def point(self, index: "int") -> "HOM_Point *":
        r"""

        point(self, index) -> hou.Point

            Return the point at the specified index.

            This is a convenience method for accessing a particular point
            without the overhead of obtaining all points via
            hou.Geometry.points.

            Return None if no such point at the specified index exists.


        """
        return _hou.Geometry_point(self, index)

    def iterPrims(self) -> "HOM_IterableList< HOM_Prim > *":
        r"""

        iterPrims(self) -> generator of hou.Prim

            Return a generator that iterates through all the primitives in the
            geometry.

            Whereas hou.Geometry.prims allocates and returns a tuple of all the
            primitives in the geometry, this method returns a generator object
            that will yield hou.Prim objects on demand. This object is very fast
            at random access into the sequence.

            If you're accessing a specific primitive by index and the geometry
            contains many primitives, it is faster to use iterPrims() than
            prims(). If, however, you are iterating over all the primitives in
            the geometry, it is generally faster to use prims() than
            iterPrims().

          > # This is preferred:
          > geo.iterPrims()[23]
          >
          > # over this:
          > geo.prims()[23]
          >
          > # But this is preferred:
          > for prim in geo.prims():
          >     ...process prim...
          >
          > # over this:
          > for prim in geo.iterPrims():
          >     ...process prim...

            See also the hou.Geometry.prims method.


        """
        return _hou.Geometry_iterPrims(self)

    def prims(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        prims(self) -> tuple of hou.Prim

            Return a tuple of all the primitives in the geometry. The primitives
            returned will be subclasses of hou.Prim (e.g.polygons, volumes,
            etc.).

            See also:

          * hou.Geometry.iterPrims

          * hou.Face

          * hou.Polygon

          * hou.Surface

          * hou.Volume


        """
        return _hou.Geometry_prims(self)

    def prim(self, index: "int") -> "HOM_Prim *":
        r"""

        prim(self, index) -> hou.Prim

            Return the primitive at the specified index.

            This is a convenience method for accessing a particular primitive
            without the overhead of obtaining all primitives via
            hou.Geometry.prims.

            Return None if no such primitive at the specified index exists.


        """
        return _hou.Geometry_prim(self, index)

    def containsPrimType(self, *args) -> "bool":
        r"""

        containsPrimType(self, type_or_name) -> bool

            Returns whether the geometry contains at least one primitive of the
            specified type.


            type_or_name
                A hou.primType, or a string containing the name of a primitive
                type.

                Typical examples of string values are \"Poly\" (polygon) or
                \"PackedAgent\" (agent packed primitive). To see a complete list
                of possible typename values, run ginfo -P on a Houdini tools
                command line.


        """
        return _hou.Geometry_containsPrimType(self, *args)

    def countPrimType(self, *args) -> "int64":
        r"""

        countPrimType(self, type_or_name) -> long

            Returns the number of primitives of the specified type in the
            geometry.


            type_or_name
                A hou.primType, or a string containing the name of a primitive
                type.

                Typical examples of string values are \"Poly\" (polygon) or
                \"PackedAgent\" (agent packed primitive). To see a complete list
                of possible typename values, run ginfo -P on a Houdini tools
                command line.


        """
        return _hou.Geometry_countPrimType(self, *args)

    def preferredPrecision(self) -> "int64":
        r"""

        preferredPrecision(self) -> int

            Returns the preferred computation precision of the geometry. This
            can be used to determine what sort of attributes to create and what
            precision to run intermediate computations in. Can be either 32 or
            64.


        """
        return _hou.Geometry_preferredPrecision(self)

    def setPreferredPrecision(self, prec: "int64") -> "void":
        r"""

        setPreferredPrecision(self, int)

            Adjusts the preferred precision of the geometry. The value should be
            either 32 or 64. Nodes may use this precision as a hint to set
            default attribute creation and computation to a certain precision.


        """
        return _hou.Geometry_setPreferredPrecision(self, prec)

    def averageMinDistance(
        self,
        local_transform: "Matrix4",
        geometry: "Geometry",
        geometry_transform: "Matrix4",
    ) -> "double":
        r"""

        averageMinDistance(self, local_transform, geometry, geometry_transform)
        -> float

            Return the average over all points in <geometry> of the minimum
            distance to the point set of <self>


            local_transform
                A transform to be applied to all points in this geometry.

            geometry
                The geometry to find distances from.

            geometry_transform
                A transform to be applied to all points in <geometry>.

            Raises hou.OperationFailed if <geometry> has no vertices.

          > query_geometry = query_node.geometry()
          > queried_geometry = queried_node.geometry()
          >
          > # Return the average over all points in <queried_geometry> of the minimum
          > # distance to the point set of <query_geometry>
          > query_geometry.averageMinDistance(
          >     query_node.worldTransform(),
          >     queried_geometry,
          >     queried_node.worldTransform())

        """
        return _hou.Geometry_averageMinDistance(
            self, local_transform, geometry, geometry_transform
        )

    def averageEdgeLength(self) -> "double":
        r"""

        averageEdgeLength(self) -> float

            Return the average edge length of the mesh.

            Raises hou.OperationFailed if mesh does not contain any edges.

          > # Return the average edge length.
          > geo.averageEdgeLength()

        """
        return _hou.Geometry_averageEdgeLength(self)

    def globPoints(
        self, pattern: "char const *", ordered: "bool" = False
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        globPoints(self, pattern, ordered=False) -> tuple of hou.Point

            Return a tuple of points corresponding to a pattern of point
            numbers.

            The pattern format is the same one used by the group fields on SOP
            nodes that take point selections. Elements in the pattern are
            separated by spaces, and elements can be point numbers, point number
            ranges, or group names.

            Optionally, the points can be returned in the order they were added
            to the group.

            This method can be useful when writing a Python SOP that works on
            only a selected set of points.

            Raises hou.OperationFailed if the pattern is not valid or if it
            refers to a group that does not exist. Note that an empty pattern is
            considered to be invalid. Numbers that do not refer to valid points
            are not errors, and simply do not match points.

          > # Return a tuple containing points 5 and 7.
          > geo.globPoints(\"5 7\")
          >
          > # Return a tuple containing points 5 to 10.
          > geo.globPoints(\"5-10\")
          >
          > # Return a tuple containing all the points in the pointgroup called group1.
          > geo.globPoints(\"group1\")
          >
          > # Return all the points except those from 0 to 98.
          > geo.globPoints(\"!0-98\")
          >
          > # Return points 5, 10 to 20, and those in group1.
          > geo.globPoints(\"5 group1 10-20\")

            The following Python SOP example is behaves similarly to the Point
            sop.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.  It assumes the Python sop has the following parm tuples:
          > #     group: A string containing which points to affect
          > #     t:     A set of 3 floats that behaves like the point sop's position
          > #            parameter.  Set these parameters to the expressions ($TX, $TY, $TZ).
          > geo = hou.pwd().geometry()
          >
          > # Use the group field to determine which points to affect.  If it's blank,
          > # operate on all points.
          > pattern = hou.ch(\"group\")
          > if pattern == \"\":
          >     points = geo.points()
          > else:
          >     points = geo.globPoints(pattern)
          >
          > # Loop through the points, setting the SOP's current point as we go.
          > # Then evaluate the t parm tuple, so it can use the current point (e.g.
          > # with hscript's $TX or Python's pwd().curPoint()).
          > for point in points:
          >     hou.pwd().setCurPoint(point)
          >     new_position = hou.pwd().evalParmTuple(\"t\")
          >     point.setPosition(new_position)

        """
        return _hou.Geometry_globPoints(self, pattern, ordered)

    def globPrims(
        self, pattern: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        globVertices(self, pattern) -> tuple of hou.Vertex

            Return a tuple of vertices corresponding to a pattern of vertex
            numbers.

            The pattern format is the same one used by the group fields on SOP
            nodes that take vertex selections. See hou.Geometry.globPoints for
            more information.


        """
        return _hou.Geometry_globPrims(self, pattern)

    def globVertices(
        self, pattern: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_Vertex >,std::allocator< HOM_ElemPtr< HOM_Vertex > > >":
        return _hou.Geometry_globVertices(self, pattern)

    def globEdges(
        self, pattern: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_Edge >,std::allocator< HOM_ElemPtr< HOM_Edge > > >":
        return _hou.Geometry_globEdges(self, pattern)

    def pointAttribs(
        self, include_private: "bool" = False
    ) -> "std::vector< HOM_ElemPtr< HOM_Attrib >,std::allocator< HOM_ElemPtr< HOM_Attrib > > >":
        r"""

        pointAttribs(self, include_private=False) -> tuple of hou.Attrib

            Return a tuple of all the point attributes.


            include_private
                Also include private attributes.

            Note that the point position attribute is named P and is 3 floats in
            size. Also, the point weight attribute is named Pw and is 1 float in
            size. P always exists, but Pw may not.


        """
        return _hou.Geometry_pointAttribs(self, include_private)

    def primAttribs(
        self, include_private: "bool" = False
    ) -> "std::vector< HOM_ElemPtr< HOM_Attrib >,std::allocator< HOM_ElemPtr< HOM_Attrib > > >":
        r"""

        primAttribs(self, include_private=False) -> tuple of hou.Attrib

            Return a tuple of all the primitive attributes.


            include_private
                Also include private attributes.


        """
        return _hou.Geometry_primAttribs(self, include_private)

    def vertexAttribs(
        self, include_private: "bool" = False
    ) -> "std::vector< HOM_ElemPtr< HOM_Attrib >,std::allocator< HOM_ElemPtr< HOM_Attrib > > >":
        r"""

        vertexAttribs(self, include_private=False) -> tuple of hou.Attrib

            Return a tuple of all the vertex attributes.


            include_private
                Also include private attributes.


        """
        return _hou.Geometry_vertexAttribs(self, include_private)

    def globalAttribs(
        self, include_private: "bool" = False
    ) -> "std::vector< HOM_ElemPtr< HOM_Attrib >,std::allocator< HOM_ElemPtr< HOM_Attrib > > >":
        r"""

        globalAttribs(self, include_private=False) -> tuple of hou.Attrib

            Return a tuple of all the global (a.k.a. detail) attributes.


            include_private
                Also include private attributes.


        """
        return _hou.Geometry_globalAttribs(self, include_private)

    def findPointAttrib(self, name: "char const *") -> "HOM_Attrib *":
        r"""

        findPointAttrib(self, name) -> hou.Attrib or None

            Look up a point attribute by name. Returns the corresponding
            hou.Attrib object, or None if no attribute exists with that name.

            Note that the point position attribute is named P and is 3 floats in
            size. Also, the point weight attribute is named Pw and is 1 float in
            size. P always exists, but Pw may not.

            See hou.Point.attribValue for an example.


        """
        return _hou.Geometry_findPointAttrib(self, name)

    def findPrimAttrib(self, name: "char const *") -> "HOM_Attrib *":
        r"""

        findPrimAttrib(self, name) -> hou.Attrib or None

            Look up a primitive attribute by name. Returns the corresponding
            hou.Attrib object, or None if no attribute exists with that name.


        """
        return _hou.Geometry_findPrimAttrib(self, name)

    def findVertexAttrib(self, name: "char const *") -> "HOM_Attrib *":
        r"""

        findVertexAttrib(self, name) -> hou.Attrib or None

            Look up a vertex attribute by name. Returns the corresponding
            hou.Attrib object, or None if no attribute exists with that name.


        """
        return _hou.Geometry_findVertexAttrib(self, name)

    def findGlobalAttrib(self, name: "char const *") -> "HOM_Attrib *":
        r"""

        findGlobalAttrib(self, name) -> hou.Attrib or None

            Look up a global (a.k.a. detail) attribute by name. Returns the
            corresponding hou.Attrib object, or None if no attribute exists with
            that name.


        """
        return _hou.Geometry_findGlobalAttrib(self, name)

    def attribType(self) -> "HOM_EnumValue &":
        r"""

        attribType(self) -> hou.attribType enum value

            Return the enumerated value hou.attribType.Global. Points,
            primitives, vertices, and geometry support the same set of methods
            for querying their attributes, and this method is one of them.

            See also:

          * hou.Prim.attribType

          * hou.Point.attribType

          * hou.Vertex.attribType


        """
        return _hou.Geometry_attribType(self)

    def floatAttribValue(self, *args) -> "double":
        r"""

        floatAttribValue(self, name_or_attrib) -> float

            Return the global (a.k.a. detail) attribute value for a particular
            floating point attribute. The attribute may be specified by name or
            by hou.Attrib object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not a float of size 1.

            In most cases, you'll just use hou.Geometry.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
        return _hou.Geometry_floatAttribValue(self, *args)

    def floatListAttribValue(
        self, *args
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the global (a.k.a. detail) attribute value for a particular
            floating point attribute. The attribute may be specified by name or
            by hou.Attrib object. The return value is a list of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a list with one element is returned.

            See also:

          * hou.Geometry.attribValue


        """
        return _hou.Geometry_floatListAttribValue(self, *args)

    def intAttribValue(self, *args) -> "int64":
        r"""

        intAttribValue(self, name_or_attrib) -> int

            Return the global (a.k.a. detail) attribute value for a particular
            integer attribute of size 1. The attribute may be specified by name
            or by hou.Attrib object. See hou.Geometry.floatAttribValue for more
            information.


        """
        return _hou.Geometry_intAttribValue(self, *args)

    def intListAttribValue(
        self, *args
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the global (a.k.a. detail) attribute value for a particular
            integer attribute. The attribute may be specified by name or by
            hou.Attrib object. The return value is a list of ints. See
            hou.Geometry.floatListAttribValue for more information.


        """
        return _hou.Geometry_intListAttribValue(self, *args)

    def stringAttribValue(self, *args) -> "std::string":
        r"""

        stringAttribValue(self, name_or_attrib) -> str

            Return the global (a.k.a. detail) attribute value for a particular
            string attribute. The attribute may be specified by name or by
            hou.Attrib object. See hou.Geometry.floatAttribValue for more
            information.


        """
        return _hou.Geometry_stringAttribValue(self, *args)

    def stringListAttribValue(
        self, *args
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the global (a.k.a. detail) attribute value for a particular
            string attribute. The attribute may be specified by name or by
            hou.Attrib object. The return value is a list of strings. See
            hou.Geometry.floatListAttribValue for more information.


        """
        return _hou.Geometry_stringListAttribValue(self, *args)

    def dictAttribValue(
        self, *args
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        dictAttribValue(self, name_or_attrib) -> dict

            Return the global (a.k.a detail) attribute value for a particular
            dictionary attribute. The attribute may be specified by name or by
            hou.Attrib object. See hou.Geometry.floatAttribValue for more
            information.


        """
        return _hou.Geometry_dictAttribValue(self, *args)

    def dictListAttribValue(
        self, *args
    ) -> "std::vector< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >,std::allocator< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > > >":
        r"""

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the global (a.k.a detail) attribute value for a particular
            dictionary attribute. The attribute may be specified by name or by
            hou.Attrib object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Geometry.floatAttribValue for more information.


        """
        return _hou.Geometry_dictListAttribValue(self, *args)

    def pointFloatAttribValues(
        self, name: "char const *"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        pointFloatAttribValues(self, name) -> tuple of float

            Return a tuple of floats containing one attribute's values for all
            the points.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each point will correspond to
            multiple values in the result. For example, if Cd is a float
            attribute of size 3 and there are 3 points with values (0.1, 0.2,
            0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
            (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

            Calling this method is faster than looping over all the points and
            calling hou.Point.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_pointFloatAttribValues(self, name)

    def pointFloatAttribValuesAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        pointFloatAttribValuesAsString(self, name,
        float_type=hou.numericData.Float32) -> str for Python 2, bytes for
        Python 3

            Return a binary string representation of the floats of one
            attribute's value for all the points. This method is faster than
            hou.Geometry.pointFloatAttribValues, and you can use the array
            module to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            float_type
                A hou.numericData value to specify the float data type (either
                Float16, Float32 or Float64).

            This method provides a faster implementation of the following:

          > import array
          > def pointFloatAttribValuesAsString(self, name):
          >     return array.array(\"f\", self.pointFloatAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def pointFloatAttribValuesAsArray(geometry, name):
          >     a = array.array(\"f\")
          >     a.fromstring(geometry.pointFloatAttribValuesAsString(name))
          >     return a

            See hou.Geometry.pointFloatAttribValues for more information.


        """
        return _hou.Geometry_pointFloatAttribValuesAsString(self, *args, **kwargs)

    def primFloatAttribValues(
        self, name: "char const *"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        primFloatAttribValues(self, name) -> tuple of float

            Return a tuple of floats containing one attribute's values for all
            the primitives.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each primitive will correspond to
            multiple values in the result. For example, if Cd is a float
            attribute of size 3 and there are 3 primitives with values (0.1,
            0.2, 0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will
            be (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

            Calling this method is faster than looping over all the primitives
            and calling hou.Prim.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_primFloatAttribValues(self, name)

    def primFloatAttribValuesAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        primFloatAttribValuesAsString(self, name) -> str for Python 2, bytes for
        Python 3

            Return a binary string representation of the floats of one
            attribute's value for all the primitives. This method is faster than
            hou.Geometry.primFloatAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            This method provides a faster implementation of the following:

          > import array
          > def primFloatAttribValuesAsString(self, name):
          >     return array.array(\"f\", self.primFloatAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def primFloatAttribValuesAsArray(geometry, name):
          >     a = array.array(\"f\")
          >     a.fromstring(geometry.primFloatAttribValuesAsString(name))
          >     return a

            See hou.Geometry.primFloatAttribValues for more information.


        """
        return _hou.Geometry_primFloatAttribValuesAsString(self, *args, **kwargs)

    def vertexFloatAttribValues(
        self, name: "char const *"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        vertexFloatAttribValues(self, name) -> tuple of float

            Return a tuple of floats containing one attribute's values for all
            the vertices.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each vertex will correspond to
            multiple values in the result. For example, if attrib is a float
            attribute of size 3 and there are 3 vertices with values (0.1, 0.2,
            0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
            (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

            Calling this method is faster than looping over all the vertices and
            calling hou.Vertex.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_vertexFloatAttribValues(self, name)

    def vertexFloatAttribValuesAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        vertexFloatAttribValuesAsString(self, name,
        float_type=hou.numericData.Float32) -> str for Python 2, bytes for
        Python 3

            Return a binary string representation of the floats of one
            attribute's value for all the vertices. This method is faster than
            hou.Geometry.vertexFloatAttribValues, and you can use the array
            module to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            float_type
                A hou.numericData value to specify the float data type (either
                Float16, Float32 or Float64).

            This method provides a faster implementation of the following:

          > import array
          > def vertexFloatAttribValuesAsString(self, name):
          >     return array.array(\"f\", self.vertexFloatAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def vertexFloatAttribValuesAsArray(geometry, name):
          >     a = array.array(\"f\")
          >     a.fromstring(geometry.vertexFloatAttribValuesAsString(name))
          >     return a

            See hou.Geometry.vertexFloatAttribValues for more information.


        """
        return _hou.Geometry_vertexFloatAttribValuesAsString(self, *args, **kwargs)

    def pointIntAttribValues(
        self, name: "char const *"
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        pointIntAttribValues(self, name) -> tuple of int

            Return a tuple of integers containing one attribute's values for all
            the points.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each point will correspond to
            multiple values in the result. For example, if idmap is an integer
            attribute of size 2 and there are 3 points with values (1, 2), (2,
            3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).

            Calling this method is faster than looping over all the points and
            calling hou.Point.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_pointIntAttribValues(self, name)

    def pointIntAttribValuesAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        pointIntAttribValuesAsString(self, name, int_type=hou.numericData.Int32)
        -> str for Python 2, bytes for Python 3

            Return a binary string representation of the integers of one
            attribute's value for all the points. This method is faster than
            hou.Geometry.pointIntAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            int_type
                A hou.numericData value to specify the integer data type (either
                Int8, Int16, Int32 or Int64).

            This method provides a faster implementation of the following:

          > import array
          > def pointIntAttribValuesAsString(self, name):
          >     return array.array(\"i\", self.pointIntAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def pointIntAttribValuesAsArray(geometry, name):
          >     a = array.array(\"i\")
          >     a.fromstring(geometry.pointIntAttribValuesAsString(name))
          >     return a

            See hou.Geometry.pointIntAttribValues for more information.


        """
        return _hou.Geometry_pointIntAttribValuesAsString(self, *args, **kwargs)

    def primIntAttribValues(
        self, name: "char const *"
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        primIntAttribValues(self, name) -> tuple of int

            Return a tuple of integers containing one attribute's values for all
            the primitives.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each primitive will correspond to
            multiple values in the result. For example, if idmap is an integer
            attribute of size 2 and there are 3 primitives with values (1, 2),
            (2, 3), and (3,4) then the result will be (1, 2, 2, 3, 3, 4).

            Calling this method is faster than looping over all the primitives
            and calling hou.Prim.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_primIntAttribValues(self, name)

    def primIntAttribValuesAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        primIntAttribValuesAsString(self, name, int_type=hou.numericData.Int32)
        -> str for Python 2, bytes for Python 3

            Return a binary string representation of the integers of one
            attribute's value for all the primitives. This method is faster than
            hou.Geometry.primFloatAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            int_type
                A hou.numericData value to specify the integer data type (either
                Int8, Int16, Int32 or Int64).

            This method provides a faster implementation of the following:

          > import array
          > def primIntAttribValuesAsString(self, name):
          >     return array.array(\"i\", self.primIntAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def primIntAttribValuesAsArray(geometry, name):
          >     a = array.array(\"i\")
          >     a.fromstring(geometry.primIntAttribValuesAsString(name))
          >     return a

            See hou.Geometry.primIntAttribValues for more information.


        """
        return _hou.Geometry_primIntAttribValuesAsString(self, *args, **kwargs)

    def vertexIntAttribValues(
        self, name: "char const *"
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        vertexIntAttribValues(self, name) -> tuple of int

            Return a tuple of integers containing one attribute's values for all
            the vertices.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each vertex will correspond to
            multiple values in the result. For example, if idmap is an integer
            attribute of size 2 and there are 3 vertices with values (1, 2), (2,
            3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).

            Calling this method is faster than looping over all the vertices and
            calling hou.Vertex.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_vertexIntAttribValues(self, name)

    def vertexIntAttribValuesAsString(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        vertexIntAttribValuesAsString(self, name,
        int_type=hou.numericData.Int32) -> str for Python 2, bytes for Python 3

            Return a binary string representation of the integers of one
            attribute's value for all the vertices. This method is faster than
            hou.Geometry.vertexIntAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            int_type
                A hou.numericData value to specify the integer data type (either
                Int8, Int16, Int32 or Int64).

            This method provides a faster implementation of the following:

          > import array
          > def vertexIntAttribValuesAsString(self, name):
          >     return array.array(\"i\", self.vertexIntAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def vertexIntAttribValuesAsArray(geometry, name):
          >     a = array.array(\"i\")
          >     a.fromstring(geometry.vertexIntAttribValuesAsString(name))
          >     return a

            See hou.Geometry.vertexIntAttribValues for more information.


        """
        return _hou.Geometry_vertexIntAttribValuesAsString(self, *args, **kwargs)

    def pointStringAttribValues(
        self, name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        pointStringAttribValues(self, name) -> tuple of str

            Return a tuple of strings containing one attribute's values for all
            the points.

            This method only works on string attributes. If the attribute
            contains more than one element, each point will correspond to
            multiple values in the result. For example, if strmap is a string
            attribute of size 2 and there are 3 points with values (apple,
            orange), (red, blue), and (one, two) then the result will be (apple,
            orange, red, blue, one, two).

            Calling this method is faster than looping over all the points and
            calling hou.Point.attribValue.

            If the attribute name is invalid or the attribute is not a string
            attribute then this method raises hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_pointStringAttribValues(self, name)

    def primStringAttribValues(
        self, name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        primStringAttribValues(self, name) -> tuple of str

            Return a tuple of strings containing one attribute's values for all
            the primitives.

            This method only works on string attributes. If the attribute
            contains more than one element, each primitive will correspond to
            multiple values in the result. For example, if strmap is a string
            attribute of size 2 and there are 3 primitives with values (apple,
            orange), (red, blue), and (one, two) then the result will be (apple,
            orange, red, blue, one, two).

            Calling this method is faster than looping over all the primitives
            and calling hou.Prim.attribValue.

            If the attribute name is invalid or the attribute is not a string
            attribute) then this method raises hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_primStringAttribValues(self, name)

    def vertexStringAttribValues(
        self, name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        vertexStringAttribValues(self, name) -> tuple of str

            Return a tuple of strings containing one attribute's values for all
            the vertices.

            This method only works on string attributes. If the attribute
            contains more than one element, each vertex will correspond to
            multiple values in the result. For example, if strmap is a string
            attribute of size 2 and there are 3 vertices with values (apple,
            orange), (red, blue), and (one, two) then the result will be (apple,
            orange, red, blue, one, two).

            Calling this method is faster than looping over all the vertices and
            calling hou.Vertex.attribValue.

            If the attribute name is invalid or the attribute is not a string
            attribute then this method raises hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
        return _hou.Geometry_vertexStringAttribValues(self, name)

    def setPointFloatAttribValues(
        self, name: "char const *", values: "_DoubleTuple"
    ) -> "void":
        r"""

        setPointFloatAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all points.
            You would typically call this method from the code of a Python-
            defined SOP.


            name
                The name of the point attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.pointFloatAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.pointFloatAttribValues.


        """
        return _hou.Geometry_setPointFloatAttribValues(self, name, values)

    def setPrimFloatAttribValues(
        self, name: "char const *", values: "_DoubleTuple"
    ) -> "void":
        r"""

        setPrimFloatAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            primitives. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the primitive attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.primFloatAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.primFloatAttribValues.


        """
        return _hou.Geometry_setPrimFloatAttribValues(self, name, values)

    def setVertexFloatAttribValues(
        self, name: "char const *", values: "_DoubleTuple"
    ) -> "void":
        r"""

        setVertexFloatAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            vertices. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the vertex attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.vertexFloatAttribValues. See that
                method for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.vertexFloatAttribValues.


        """
        return _hou.Geometry_setVertexFloatAttribValues(self, name, values)

    def setPointFloatAttribValuesFromString(self, *args, **kwargs) -> "void":
        return _hou.Geometry_setPointFloatAttribValuesFromString(self, *args, **kwargs)

    def setPrimFloatAttribValuesFromString(self, *args, **kwargs) -> "void":
        return _hou.Geometry_setPrimFloatAttribValuesFromString(self, *args, **kwargs)

    def setVertexFloatAttribValuesFromString(self, *args, **kwargs) -> "void":
        return _hou.Geometry_setVertexFloatAttribValuesFromString(self, *args, **kwargs)

    def setPointIntAttribValues(
        self, name: "char const *", values: "_Int64Tuple"
    ) -> "void":
        r"""

        setPointIntAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all points.
            You would typically call this method from the code of a Python-
            defined SOP.


            name
                The name of the point attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.pointIntAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.pointIntAttribValues.


        """
        return _hou.Geometry_setPointIntAttribValues(self, name, values)

    def setPrimIntAttribValues(
        self, name: "char const *", values: "_Int64Tuple"
    ) -> "void":
        r"""

        setPrimIntAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            primitives. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the primitive attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.primFloatAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.primIntAttribValues.


        """
        return _hou.Geometry_setPrimIntAttribValues(self, name, values)

    def setVertexIntAttribValues(
        self, name: "char const *", values: "_Int64Tuple"
    ) -> "void":
        r"""

        setVertexIntAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            vertices. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the vertex attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.vertexIntAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.vertexIntAttribValues.


        """
        return _hou.Geometry_setVertexIntAttribValues(self, name, values)

    def setPointIntAttribValuesFromString(self, *args, **kwargs) -> "void":
        return _hou.Geometry_setPointIntAttribValuesFromString(self, *args, **kwargs)

    def setPrimIntAttribValuesFromString(self, *args, **kwargs) -> "void":
        return _hou.Geometry_setPrimIntAttribValuesFromString(self, *args, **kwargs)

    def setVertexIntAttribValuesFromString(self, *args, **kwargs) -> "void":
        return _hou.Geometry_setVertexIntAttribValuesFromString(self, *args, **kwargs)

    def setPointStringAttribValues(
        self, name: "char const *", values: "_StringTuple"
    ) -> "void":
        r"""

        setPointStringAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all points.
            You would typically call this method from the code of a Python-
            defined SOP.


            name
                The name of the point attribute.

            values
                A sequence of string values in the same format as that returned
                by hou.Geometry.pointStringAttribValues. See that method for
                more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not a string, or the array of values is not the correct
            size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.pointStringAttribValues.


        """
        return _hou.Geometry_setPointStringAttribValues(self, name, values)

    def setPrimStringAttribValues(
        self, name: "char const *", values: "_StringTuple"
    ) -> "void":
        r"""

        setPrimStringAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            primitives. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the primitive attribute.

            values
                A sequence of string values in the same format as that returned
                by hou.Geometry.primStringAttribValues. See that method for more
                information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not a string, or the array of values is not the correct
            size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.primStringAttribValues.


        """
        return _hou.Geometry_setPrimStringAttribValues(self, name, values)

    def setVertexStringAttribValues(
        self, name: "char const *", values: "_StringTuple"
    ) -> "void":
        r"""

        setVertexStringAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            vertices. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the vertex attribute.

            values
                A sequence of string values in the same format as that returned
                by hou.Geometry.vertexStringAttribValues. See that method for
                more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not a string, or the array of values is not the correct
            size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.vertexStringAttribValues.


        """
        return _hou.Geometry_setVertexStringAttribValues(self, name, values)

    def renamePointAttrib(
        self, old_name: "char const *", new_name: "char const *"
    ) -> "void":
        r"""

        renamePointAttrib(self, old_name, new_name)

            Rename the point attribute with the specified old name to the new
            name. This method is typically called from within a Python-defined
            SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such point attribute with the old name exists.
            Raises OperationFailed if a point attribute with the new name
            already exists.


        """
        return _hou.Geometry_renamePointAttrib(self, old_name, new_name)

    def renamePrimAttrib(
        self, old_name: "char const *", new_name: "char const *"
    ) -> "void":
        r"""

        renamePrimAttrib(self, old_name, new_name)

            Rename the primitive attribute with the specified old name to the
            new name. This method is typically called from within a Python-
            defined SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such primitive attribute with the old name
            exists. Raises OperationFailed if a primitive attribute with the new
            name already exists.


        """
        return _hou.Geometry_renamePrimAttrib(self, old_name, new_name)

    def renameVertexAttrib(
        self, old_name: "char const *", new_name: "char const *"
    ) -> "void":
        r"""

        renameVertexAttrib(self, old_name, new_name)

            Rename the vertex attribute with the specified old name to the new
            name. This method is typically called from within a Python-defined
            SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such vertex attribute with the old name
            exists. Raises OperationFailed if a vertex attribute with the new
            name already exists.


        """
        return _hou.Geometry_renameVertexAttrib(self, old_name, new_name)

    def renameGlobalAttrib(
        self, old_name: "char const *", new_name: "char const *"
    ) -> "void":
        r"""

        renameGlobalAttrib(self, old_name, new_name)

            Rename the global attribute with the specified old name to the new
            name. This method is typically called from within a Python-defined
            SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such global attribute with the old name
            exists. Raises OperationFailed if a global attribute with the new
            name already exists.


        """
        return _hou.Geometry_renameGlobalAttrib(self, old_name, new_name)

    def createPoint(self) -> "HOM_Point *":
        r"""

        createPoint(self) -> hou.Point

            Create a new point located at (0, 0, 0) and return the corresponding
            hou.Point object. You would typically call this method from the code
            of a Python-defined SOP.

            If the geometry contains point attributes, the new point receives
            the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See hou.Geometry.addAttrib, hou.Geometry.createPolygon, and
            hou.Face.addVertex for examples.


        """
        return _hou.Geometry_createPoint(self)

    def createPoints(
        self, *args
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        createPoints(self, point_positions) -> tuple of hou.Point

            Create a set of points located at the specified positions and return
            a tuple of the new hou.Point objects. You would typically call this
            method from the code of a Python-defined SOP.

            point_positions can be either a tuple of hou.Vector3 objects or a
            tuple of 3-tuple floating point numbers. For example, if
            point_positions is ((0, 1, 2), (1, 2, 3)) then this method will
            create 2 points with one positioned at (0, 1, 2) and the other at
            (1, 2, 3).

            If the geometry contains point attributes, the new points receive
            the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable. Raises hou.InvalidSize if one of the specified point
            positions does not contain 3 values (for x, y, z).

            See hou.Geometry.addAttrib, hou.Geometry.createPolygons, and
            hou.Face.addVertex for examples.


        """
        return _hou.Geometry_createPoints(self, *args)

    def createPolygon(self, is_closed: "bool" = True) -> "HOM_Polygon *":
        r"""

        createPolygon(self, is_closed=True) -> hou.Polygon

            Create a new polygon and return the corresponding hou.Polygon
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created polygon has no vertices. Use hou.Face.addVertex to
            add them. The polygon is also closed (see hou.Face.isClosed for more
            information) by default unless specified otherwise for a polygon
            curve.

            If the geometry contains primitive attributes, the new polygon
            receives the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > geo = hou.pwd().geometry()
          > poly = geo.createPolygon()
          > for position in (0,0,0), (1,0,0), (0,1,0):
          >     point = geo.createPoint()
          >     point.setPosition(position)
          >     poly.addVertex(point)

            See hou.Face.addVertex for a slightly more complicated example.


        """
        return _hou.Geometry_createPolygon(self, is_closed)

    def createPolygons(
        self, *args
    ) -> "std::vector< HOM_ElemPtr< HOM_Polygon >,std::allocator< HOM_ElemPtr< HOM_Polygon > > >":
        r"""

        createPolygons(self, points, is_closed=True) -> tuple of hou.Polygon

            Create a set of polygons with the specified points as vertices and
            return a tuple of the new hou.Polygon objects. You would typically
            call this method from the code of a Python-defined SOP.

            points can be either a tuple of tuples of hou.Point objects or a
            tuple of tuples of integers representing the point numbers. For
            example, if points is ((0, 1, 2), (3, 4, 5, 6)) then this method
            will create 2 polygons with one having points 0, 1 and 2 as its
            vertices and the other one having points 3, 4, 5 and 6 as its
            vertices.

            The created polygons are closed (see hou.Face.isClosed for more
            information) by default unless specified otherwise for polygon
            curves.

            If the geometry contains primitive attributes, then the new polygons
            receive the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable. Raises hou.InvalidSize if one of the specified point
            tuples does not contain at least 3 elements. Raises hou.InvalidInput
            if one of the point numbers or hou.Point objects do not exist in the
            geometry.

            Example:

          > # Create 6 points in the geometry.
          > geo = hou.pwd().geometry()
          > point_positions = (
          >     (1, 0, 0), (0, 1, 0), (0, 0, 1),
          >     (1, 1, 0), (1, 0, 1), (0, 1, 1),
          > )
          > points = geo.createPoints(point_positions)
          >
          > # Create 2 polygons.
          > # The first polygon uses the first 3 points in the geometry as its vertices.
          > # The second polygon uses the last 3 points in the geometry as its vertices.
          > polygons = geo.createPolygons(
          >     ((points[0], points[1], points[2]), (points[3], points[4], points[5])))

        """
        return _hou.Geometry_createPolygons(self, *args)

    def createPacked(
        self, packed_type: "char const *", point: "Point" = None
    ) -> "HOM_PackedPrim *":
        r"""

        createPacked(self, typename, point=None) -> hou.PackedPrim


            typename
                A string containing the name of a type of packed primitive.
                Typical examples are \"PackedDisk\" (on-disk geometry file) or
                \"AlembicRef\" (Alembic file).

                To see a complete list of possible typename values, run ginfo -P
                on a Houdini tools command line.

            point

            See hou.PackedPrim for more information.


        """
        return _hou.Geometry_createPacked(self, packed_type, point)

    def createTetrahedron(self) -> "HOM_Prim *":
        r"""

        createTetrahedron(self) -> hou.Prim

            Create a new tetrahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created tetrahedron has four vertices and new points have
            been allocated for them. To build a tetrahedron out of existing
            points, use hou.Geometry.createTetrahedronInPlace

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_createTetrahedron(self)

    def createTetrahedronInPlace(
        self, p0: "Point", p1: "Point", p2: "Point", p3: "Point"
    ) -> "HOM_Prim *":
        r"""

        createTetrahedronInPlace(self, p0, p1, p2, p3) -> hou.Prim

            Create a new tetrahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created tetrahedron has four vertices and uses the points
            that have been passed into it.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_createTetrahedronInPlace(self, p0, p1, p2, p3)

    def createHexahedron(self) -> "HOM_Prim *":
        r"""

        createHexahedron(self) -> hou.Prim

            Create a new hexahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created hexahedron has eight vertices and new points have
            been allocated for them. To build a hexahedron out of existing
            points, use hou.Geometry.createHexahedronInPlace

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_createHexahedron(self)

    def createHexahedronInPlace(
        self,
        p0: "Point",
        p1: "Point",
        p2: "Point",
        p3: "Point",
        p4: "Point",
        p5: "Point",
        p6: "Point",
        p7: "Point",
    ) -> "HOM_Prim *":
        r"""

        createHexahedronInPlace(self, p0, p1, p2, p3, p4, p5, p6, p7) ->
        hou.Prim

            Create a new hexahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created hexahedron has eight vertices and uses the points
            that have been passed into it.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_createHexahedronInPlace(
            self, p0, p1, p2, p3, p4, p5, p6, p7
        )

    def createNURBSCurve(
        self, num_points: "int" = 4, is_closed: "bool" = False, order: "int" = 4
    ) -> "HOM_Face *":
        r"""

        createNURBSCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face

            Create a new NURBS with the specified number of vertices and return
            it. You would typically call this method from the code of a Python-
            defined SOP.


            num_vertices
                The number of verticies in the curve. A new point is added to
                the geometry for each vertex, and this point is located at the
                origin until you change its position. You can also add more
                vertices with hou.Face.addVertex.

                The minimum number of vertices for a NURBS curve is identical to
                its order. So for the default order of 4, the curve must have a
                minimum of 4 vertices. If you specify too few vertices, this
                method raises hou.OperationFailed.

            is_closed
                Controls if the curve is open or closed; see hou.Face.isClosed
                for more information. If not specified, the resulting curve is
                open. This behavior is different from
                hou.Geometry.createPolygon, where the new polygon is closed. You
                can also open or close it with hou.Face.setIsClosed.

            order
                Specifies the curve's order. The default order is 4,
                corresponding to a cubic NURBS curve. An order of 2, the lowest
                order, will give a curve with linear segments.

            If the geometry contains primitive attributes, the new curve
            receives the default values for those attributes.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > curve = geo.createNURBSCurve(10)
          > i = 0
          > for vertex in curve.vertices():
          >     vertex.point().setPosition((i, i % 3, 0))
          >     i = i + 1

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also:

          * hou.Prim.vertices

          * hou.Point.setPosition


        """
        return _hou.Geometry_createNURBSCurve(self, num_points, is_closed, order)

    def createBezierCurve(
        self, num_points: "int" = 4, is_closed: "bool" = False, order: "int" = 4
    ) -> "HOM_Face *":
        r"""

        createBezierCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face

            Create a new Bezier curve with the specified number of vertices and
            return it. You would typically call this method from the code of a
            Python-defined SOP.


            num_vertices
                The number of verticies in the curve. A new point is added to
                the geometry for each vertex, and this point is located at the
                origin until you change its position. You can also add more
                vertices with hou.Face.addVertex.

            is_closed
                Controls if the curve is open or closed; see hou.Face.isClosed
                for more information. If not specified, the resulting curve is
                open. This behavior is different from
                hou.Geometry.createPolygon, where the new polygon is closed.

            order
                Specifies the curve's order. The default order is 4,
                corresponding to a cubic Bezier curve. An order of 2, the lowest
                order, will give a curve with linear segments.

            An open Bezier curve must have (order - 1) * n + 1 vertices for some
            integer n>=1 (so valid values for order 4 curves are 4, 7, 10,
            etc.). A closed Bezier curve must have (order - 1) * n vertices
            (e.g. 3, 6, 9, etc. for order 4 curve). This restriction does not
            apply to curves of order 2, however.

            As a consequence, you cannot use hou.Face.setIsClosed on non-linear
            Bezier curves, since the number of vertices would need to change.

            See hou.Geometry.createNURBSCurve for more information.


        """
        return _hou.Geometry_createBezierCurve(self, num_points, is_closed, order)

    def createNURBSSurface(
        self,
        rows: "int",
        cols: "int",
        is_closed_in_u: "bool" = False,
        is_closed_in_v: "bool" = False,
        order_u: "int" = 4,
        order_v: "int" = 4,
    ) -> "HOM_Surface *":
        r"""

        createNURBSSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

            Create a NURBS surface in the XY plane centered at the origin with
            size (1, 1) and return it. You would typically call this method from
            the code of a Python-defined SOP.


            rows, cols
                Determines the size of the 2D array of vertices defining the
                control points of the surface. The number of cols and rows in
                each direction, must be equal to or larger than the U and V
                orders, respectively.

            is_closed_in_u, is_closed_in_v
                Controls if the surface is open or closed in each of the U and V
                directions; see hou.Surface.isClosedInU for more information. If
                not specified, the default behavior is to build an open surface.

            order_u, order_v
                Specifies the surface's order in each of the U and V directions.
                The default order for both is 4, corresponding to a cubic NURBS
                surface. An order of 2, the lowest order, will give a surface
                with linear segments, essentially a mesh.

            If the geometry contains primitive attributes, the new surface
            receives the default values for those attributes.

            You can move or resize the surface using
            hou.Geometry.transformPrims.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the number of rows and/or columns is
            invalid.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          >
          > # Create a surface with a 10x10 grid of vertices.
          > surf = geo.createNURBSSurface(10, 10)
          >
          > # Initially, the center is at (0, 0, 0), size is (1, 1, 1), on the XY
          > # plane.  Scale to (20, 10) and rotate into the XZ plane.
          > geo.transformPrims((surf,),
          >     hou.hmath.buildScale((20, 10, 1)) *
          >     hou.hmath.buildRotateAboutAxis((1, 0, 0), 90))

            See also:

          * hou.Geometry.transformPrims

          * hou.Matrix4

          * hou.hmath


        """
        return _hou.Geometry_createNURBSSurface(
            self, rows, cols, is_closed_in_u, is_closed_in_v, order_u, order_v
        )

    def createBezierSurface(
        self,
        rows: "int",
        cols: "int",
        is_closed_in_u: "bool" = False,
        is_closed_in_v: "bool" = False,
        order_u: "int" = 4,
        order_v: "int" = 4,
    ) -> "HOM_Surface *":
        r"""

        createBezierSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

            Create a Bezier surface in the XY plane centered at the origin with
            size (1, 1) and return it. You would typically call this method from
            the code of a Python-defined SOP.


            rows, cols
                Determines the size of the 2D array of vertices defining the
                control points of the surface.

                Note that the number of rows corresponds to v and the number or
                columns corresponds to u, which can be slightly confusing. For
                example, geo.createBezierSurface(9, 7, is_closed_in_u=False,
                is_closed_in_v=True) is valid, but geo.createBezierSurface(9, 7,
                is_closed_in_u=True, is_closed_in_v=False) raises
                hou.OperationFailed.

            is_closed_in_u, is_closed_in_v
                Determines if it is open or closed in each of the u and v
                directions; see hou.Surface.isClosedInU for more information.

            order_u, order_v
                Specifies the surface's order in of the U and V directions. The
                default order for both is 4, corresponding to a cubic NURBS
                surface. An order of 2, the lowest order, will give a surface
                with linear segments, essentially a mesh.

            As with Bezier curves, a Bezier surface has some restrictions on the
            point count in each of the U and V directions. For a given
            direction; if it's open the number of points in the direction must
            be (order - 1) * n + 1 for some integer n >= 1 (e.g. 4, 7, 10, ...).
            If it's open, the number of points must be (order - 1) * n where n
            >= 1 in that direction (e.g. 2, 4, 6, .. for order 3).

            You can move or resize the surface using
            hou.Geometry.transformPrims.

            If the geometry contains primitive attributes, the new surface
            receives the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > import math
          >
          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          >
          > # Build a tube-like object about the y axis.
          > num_rows, num_cols = (10, 9)
          > surf = geo.createBezierSurface(num_rows, num_cols, is_closed_in_u=True)
          > for v_index in range(num_rows):
          >     for u_index in range(num_cols):
          >         angle = u_index * (2.0 * math.pi) / num_cols
          >         surf.vertex(u_index, v_index).point().setPosition(
          >             (math.cos(angle), v_index / float(num_cols-1), math.sin(angle)))

        """
        return _hou.Geometry_createBezierSurface(
            self, rows, cols, is_closed_in_u, is_closed_in_v, order_u, order_v
        )

    def createMeshSurface(
        self,
        rows: "int",
        cols: "int",
        is_closed_in_u: "bool" = False,
        is_closed_in_v: "bool" = False,
    ) -> "HOM_Surface *":
        r"""

        createMeshSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

            Create a quadrilateral mesh surface in the XY plane centered at the
            origin with size (1, 1) and return it. You would typically call this
            method from the code of a Python-defined SOP.

            Note that a mesh object is not the same as a set of polygons
            defining the same shape. A mesh object is a single primitive.

            See hou.Geometry.createNURBSSurface for more information.


        """
        return _hou.Geometry_createMeshSurface(
            self, rows, cols, is_closed_in_u, is_closed_in_v
        )

    def createVolume(
        self, xres: "int", yres: "int", zres: "int", bounding_box: "BoundingBox" = None
    ) -> "HOM_Volume *":
        r"""

        createVolume(self, xres, yres, zres, bounding_box=None) -> hou.Volume

            Given the x, y, and z resolution (or size) of a voxel array, add a
            new volume primitive to the geometry and return it. The values in
            the new volume's voxels are all zero.


            xres, yres, zres
                Integers greater than zero that specify the size of the voxel
                array in one dimension. Raises hou.OperationFailed if any of
                these values are not positive.

            bounding_box
                A hou.BoundingBox that specifies the volume's 3D size. Note that
                this size is independent of the volume's voxel resolution. If
                this parameter is None, Houdini uses a bounding box going from
                (-1,-1,-1) to (1,1,1).


        """
        return _hou.Geometry_createVolume(self, xres, yres, zres, bounding_box)

    def transform(self, matrix: "Matrix4") -> "void":
        r"""

        transform(self, matrix)

            Transforms (e.g. rotates, scales, translates, etc.) the geometry by
            a transformation matrix. You would typically call this method from
            the code of a Python-defined SOP.

            See hou.hmath for functions that build transformation matrices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_transform(self, matrix)

    def transformPrims(self, prims: "_PrimTuple", matrix: "Matrix4") -> "void":
        r"""

        transformPrims(self, prims, matrix)

            Transforms a set of primitives (e.g. rotates, scales, translates,
            etc.) by a transformation matrix. You would typically call this
            method from the code of a Python-defined SOP.

          > import math
          >
          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          >
          > def createCircle(geo, num_vertices=10):
          >     # Create a closed curve with the specified number of vertices.
          >     curve = geo.createNURBSCurve(num_vertices)
          >     curve.setIsClosed(True)
          >
          >     # Arrange the points into a unit circle on the XZ plane,
          >     # centered about the origin.
          >     for i, vertex in enumerate(curve.vertices()):
          >         angle = i * (2.0 * math.pi) / num_vertices
          >         position = (math.cos(angle), 0, math.sin(angle))
          >         vertex.point().setPosition(position)
          >     return curve
          >
          > # Create a bunch of circles on the XZ plane, tilt them slightly
          > # about X, translate them away from the origin, and rotate each
          > # one about the y axis by a different amount.
          > geo = hou.pwd().geometry()
          > num_copies = 20
          > for i in range(num_copies):
          >     curve = createCircle(geo)
          >     geo.transformPrims([curve],
          >         hou.hmath.buildRotateAboutAxis((1, 0, 0), 30) *
          >         hou.hmath.buildTranslate((2, 0, 0)) *
          >         hou.hmath.buildRotateAboutAxis((0, 1, 0), i * 360.0 / num_copies))

            See hou.hmath functions that build transformation matrices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_transformPrims(self, prims, matrix)

    def deletePrims(self, prims: "_PrimTuple", keep_points: "bool" = False) -> "void":
        r"""

        deletePrims(self, prims, keep_points=False)

            Delete a sequence of primitives. You would typically call this
            method from the code of a Python-defined SOP.


            keep_points
                if True, the primitive will be deleted but its points will
                remain.

            To delete a single primitive, pass in a sequence with one primitive.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # Delete every other primitive:
          > prims = [p for p in geo.prims() if p.number() % 2 == 0]
          > geo.deletePrims(prims)
          >
          > # Delete the first primitive:
          > geo.deletePrims([geo.iterPrims()[0]])

        """
        return _hou.Geometry_deletePrims(self, prims, keep_points)

    def deletePrimsOutsideBoundingBox(self, bbox: "BoundingBox") -> "void":
        r"""

        deletePrimsOutsideBoundingBox(self, bbox)

            Delete primitives who's bounding boxes are entirely outside of the
            specified bounding box.

            Also deletes points associated with the deleted primitives.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_deletePrimsOutsideBoundingBox(self, bbox)

    def deletePoints(self, points: "_PointTuple") -> "void":
        r"""

        deletePoints(self, points)

            Delete a sequence of points. You would typically call this method
            from the code of a Python-defined SOP.

            Note that Houdini will delete any vertices that reference the point.
            For example, suppose you have a box with 6 polygons, each with 4
            vertices. Also suppose that each point on the box is shared by 3
            vertices on 3 separate polygons. If you delete one of those points,
            Houdini will remove each of those vertices from their corresponding
            polygons, leaving 3 polygons with 4 vertices and 3 polygons with 3
            vertices.

            To delete a single primitive, pass in a sequence with one point.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_deletePoints(self, points)

    def addAttrib(self, *args) -> "HOM_Attrib *":
        r"""

        addAttrib(self, type, name, default_value, transform_as_normal=False,
        create_local_variable=True) -> hou.Attrib

            Create a new point, primitive, vertex, or global (a.k.a. detail)
            attribute. Returns a hou.Attrib object describing the newly created
            attribute. You would typically call this method from the code of a
            Python-defined SOP.


            type
                A hou.attribType value to specify if the new attribute should be
                a point, primitive, vertex, or global attribute.

            name
                The new attribute's name. Each attribute in the geometry must
                have a unique name.

            default_value
                The default value for this attribute. When an attribute is
                created, all existing elements (e.g. primitives or points) will
                store this value. As well, elements that you add later will also
                use this value.

                This value also determines the attribute's data type.

                You can use one of the following Python types:

              * int

              * float

              * str

              * sequence (generator, iterator, list, or tuple) of int

              * sequence of float

              * sequence of str

              * dict

              * sequence of dict

                If the default value is a sequence of integers or floats, the
                sequence size will determine the attribute's size. Otherwise,
                the attribute's size is 1.

                String attributes do not support a default value and use this
                value solely for type determination.

            transform_as_normal
                This parameter may only be set to True when the default value is
                a sequence of 3 floats. For such attributes, Houdini will not
                modify the attribute values when it transforms (translates,
                rotates, etc.) the geometry. If you want to the attribute to be
                transformed as a vector (such as a normal vector) when Houdini
                transforms the geometry, set this parameter to True.

            create_local_variable
                If True, Houdini will create a local variable for this attribute
                that may be used in parameter expressions. The name of the local
                variable is the attribute's name, all in upper case. The mapping
                from attribute names to local variables is stored in a special
                global attribute named \"varmap\".

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if an attribute with this name already
            exists. If you are familiar with the C++ Houdini Development Kit
            (HDK), you know that Houdini can support attributes with the same
            name but with different types. However, many SOPs do not let you
            distinguish between attributes that have the same name, and multiple
            attributes with the same name are discouraged. For this reason, you
            cannot create them with this method.

            Raises hou.OperationFailed if transform_as_normal is True and the
            default value is not a sequence of 3 floats.

          > # Create an integer point attribute of size 1 named \"population\", and
          > # create 5 points with attribute values 0, 5, 10, 15, and 20.  This code
          > # will work from inside a Python SOP, but not from the Python shell.
          > geo = hou.pwd().geometry()
          > population_attrib = geo.addAttrib(hou.attribType.Point, \"population\", 0)
          > for i in range(5):
          >     point = geo.createPoint()
          >     point.setPosition((i, 0, 0))
          >     point.setAttribValue(population_attrib, i * 5)

            The following example shows how to copy an existing attribute:

          > def copyAttrib(attrib, new_name):
          >     return attrib.geometry().addAttrib(
          >         attrib.type(), new_name, attrib.defaultValue(), attrib.isTransformedAsNormal())

            If create_local_variable is True, this function performs the
            equivalent of the following code:

          > def addLocalVariable(geo, attrib_name):
          >     '''Create a geometry attribute and add a local variable for it.'''
          >     # The variable mappings are stored in the varmap attribute's string
          >     # table.  This table is different than varmap's current value, which
          >     # simply refers to an entry in that table.  So, to ensure an entry
          >     # exists in the table, we simply set varmap's value.
          >     map_value = \"%s -> %s\" % (attrib_name, attrib_name.upper())
          >     if geo.findGlobalAttrib(\"varmap\") is None:
          >         geo.addAttrib(hou.attribType.Global, \"varmap\", \"\")
          >     geo.setGlobalAttribValue(\"varmap\", map_value)

            See also:

          * hou.Prim.setAttribValue

          * hou.Point.setAttribValue

          * hou.Prim.setAttribValue

          * hou.Geometry.setGlobalAttribValue


        """
        return _hou.Geometry_addAttrib(self, *args)

    def addArrayAttrib(
        self,
        type: "EnumValue",
        name: "char const *",
        data_type: "EnumValue",
        tuple_size: "int64" = 1,
    ) -> "HOM_Attrib *":
        r"""

        addArrayAttrib(self, type, name, data_type, tuple_size=1) -> hou.Attrib

            Create a new point, primitive, vertex, or global (a.k.a. detail)
            array attribute. Returns a hou.Attrib object describing the newly
            created attribute. You would typically call this method from the
            code of a Python-defined SOP.


            type
                A hou.attribType value to specify if the new attribute should be
                a point, primitive, vertex, or global attribute.

            name
                The new attribute's name. Each attribute in the geometry must
                have a unique name.

            data_type
                A hou.attribData value to specify if the new attribute should be
                an int, float, or string attribute.

            tuple_size
                The new attribute's tuple size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if an attribute with this name already
            exists. If you are familiar with the C++ Houdini Development Kit
            (HDK), you know that Houdini can support attributes with the same
            name but with different types. However, many SOPs do not let you
            distinguish between attributes that have the same name, and multiple
            attributes with the same name are discouraged. For this reason, you
            cannot create them with this method.


        """
        return _hou.Geometry_addArrayAttrib(self, type, name, data_type, tuple_size)

    def setGlobalAttribValue(self, *args) -> "void":
        r"""

        setGlobalAttribValue(self, name_or_attrib, attrib_value)

            Set a global (a.k.a. detail) attribute value. The attribute may be
            specified by name or by hou.Attrib object. You would typically call
            this method from the code of a Python-defined SOP.

            If the attribute is an array attribute, then a sequence of values
            with length divisble by the attribute's tuple size must be passed in
            for attrib_value. Any values at the end of the sequence that do not
            complete a tuple with the desired size are discarded.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute's data type does not match the value passed in. If
            the attribute's size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute's size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > geo.addAttrib(hou.attribType.Global, \"author\", \"\")
          > geo.addAttrib(hou.attribType.Global, \"version\", (0, 0, 0))
          > geo.setGlobalAttribValue(\"author\", \"Joe\")
          > geo.setGlobalAttribValue(\"version\", (1, 0, 7))

            Here is an example for setting values in a global array attribute:

          > geo = hou.pwd().geometry()
          > geo.addArrayAttrib(
          >     hou.attribType.Global, \"data\", hou.attribData.Float, tuple_size=3)
          >
          > # This will set the global attribute's value to
          > # [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)].
          > geo.setGlobalAttribValue(\"data\", [1.0, 2.0, 3.0, 4.0, 5.0, 6.0])

            See also:

          * hou.Geometry.attribValue

          * hou.Point.setAttribValue

          * hou.Prim.setAttribValue

          * hou.Vertex.setAttribValue


        """
        return _hou.Geometry_setGlobalAttribValue(self, *args)

    def copyAttrib(self, attrib: "Attrib") -> "void":
        r"""

        copyAttribs(self, attribs)

            Copy a list of attributes hou.Attrib from another geometry.
            Attributes with the same name and right context must exist on the
            current geometry. Raises OperationFailed on failure describing the
            error condition in detail.


        """
        return _hou.Geometry_copyAttrib(self, attrib)

    def copyAttribs(
        self,
        attribs: "std::vector< HOM_Attrib *,std::allocator< HOM_Attrib * > > const &",
    ) -> "void":
        return _hou.Geometry_copyAttribs(self, attribs)

    def copy(self, geometry: "Geometry", clone_data_ids: "bool" = False) -> "void":
        r"""

        copy(self, geometry, clone_data_ids=False)

            Copy the points and primitives from another hou.Geometry object into
            this one. This is faster than doing a clear() and a merge() as it
            avoid reallocating attributes and primitives. You would typically
            call this method from the code of a Python-defined SOP.

            When merging into an empty Geometry object, clone_data_ids specifies
            whether the resulting attributes will have the same data ids. This
            is useful to enable optimizations that cache data by only looking at
            the attribute data id regardless of whether it is from the same
            geometry object or not. Otherwise, the copied attributes will have
            data ids that are unique.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.loadFromFile.


        """
        return _hou.Geometry_copy(self, geometry, clone_data_ids)

    def _getPointChildren(
        self, pt: "Point"
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        return _hou.Geometry__getPointChildren(self, pt)

    def attribValue(self, *args) -> "InterpreterObject":
        r"""

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return the global (a.k.a. detail) attribute value for a particular
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name.


        """
        return _hou.Geometry_attribValue(self, *args)

    def attributeCaptureRegions(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        attributeCaptureRegions(self) -> tuple of str

            Returns a tuple of strings representing the capture region paths for
            this geometry. The capture regions are identified from the
            geometry's capture attributes.

            See also:

          * hou.Geometry.attributeCaptureObjectPaths


        """
        return _hou.Geometry_attributeCaptureRegions(self)

    def attributeCaptureObjectPaths(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        attributeCaptureObjectPaths(self) -> tuple of str

            Returns a tuple of strings representing the capture object paths for
            this geometry. The capture objects are those used to capture this
            geometry and are identified from the geometry's capture attributes.
            The skeleton root path is prepended to the capture object paths and
            the object nodes are given by:

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > nodes = [hou.node(x) for x in geo.attributeCaptureObjectPaths()]

            See also:

          * hou.Geometry.attributeCaptureRegions


        """
        return _hou.Geometry_attributeCaptureObjectPaths(self)

    def intrinsicNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        intrinsicNames(self) -> tuple of str

            Returns a tuple of strings representing the intrinsic values
            available for this geometry. Different geometry types will have
            different intrinsic values available. You can then get or set the
            value using intrinsicValue and/or setIntrinsicValue.

            See the intrinsicValue method for more information.


        """
        return _hou.Geometry_intrinsicNames(self)

    def intrinsicValue(self, intrinsic_name: "char const *") -> "hboost::any":
        r"""

        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple

            Gets the value of an intrinsic, often computed, value of the
            geometry, such as memoryusage, pointcount, pointattributes, and so
            on. Raises OperationFailed if the given intrinsic name does not
            exist.

            You can also view these values in the user interface using the
            geometry spreadsheet.

            In Houdini, some primitives have intrinsic values which can't be
            accessed directly through the attribute interface. Most intrinsic
            values are computed, such as measuredarea, however a few are
            writeable with the setIntrinsicValue method. For example, sphere
            primitives have a transform matrix as part of their definition.

            You can get a list of the available intrinsic value names with the
            intrinsicNames method. Different geometry types will have different
            intrinsic values available.

            Bounding box intrinsic values like bounds are returned in (xmin,
            xmax, ymin, ymax, zmin, zmax) order.


        """
        return _hou.Geometry_intrinsicValue(self, intrinsic_name)

    def intrinsicSize(self, intrinsic_name: "char const *") -> "size_t":
        return _hou.Geometry_intrinsicSize(self, intrinsic_name)

    def intrinsicReadOnly(self, intrinsic_name: "char const *") -> "bool":
        return _hou.Geometry_intrinsicReadOnly(self, intrinsic_name)

    def setIntrinsicValue(self, *args) -> "void":
        r"""

        setIntrinsicValue(self, intrinsic_name, value)

            Some intrinsic values can be modified. For example, you change the
            internal size and rotation (transform) of a sphere primitive by
            passing a 16 float tuple representing the transform to
            setIntrinsicValue. Raises Error if the intrinsic is not writeable or
            does not accept the passed value, or if the given intrinsic name
            does not exist.


            NOTE
                Modifying the geometry directly will lock the geometry's parent
                node.

            See the intrinsicValue method for more information.


        """
        return _hou.Geometry_setIntrinsicValue(self, *args)

    def data(self) -> "HOM_BinaryString":
        r"""

        data(self) -> bytes

            Return the geometry data in bgeo format.

            For example:

          > geometry = hou.node(\"/obj/geo1/torus1\").geometry()
          > bgeo_data = geometry.data()
          > open(\"/tmp/torus.bgeo\", \"wb\").write(bgeo_data)

        """
        return _hou.Geometry_data(self)

    def load(self, data: "HOM_BinaryString") -> "void":
        r"""

        load(self, data)

            Loads a bgeo bytes into this object.

            For example:

          > torus = hou.node(\"/obj/geo1/torus1\").geometry()
          > bgeo_data = torus.data()
          >
          > geometry = hou.Geometry()
          > geometry.load(bgeo_data)

        """
        return _hou.Geometry_load(self, data)

    def saveToFile(self, file_name: "char const *") -> "void":
        r"""

        saveToFile(self, file_name)

            Save the contents of the geometry object to a file. The file
            extension determines what file format to use.

            All file formats supported by Houdini (e.g. geo, bgeo, obj, etc.),
            including extensions listed in GEOio, are supported. If the file
            extension is not recognized, the bgeo format is used.

            Raises hou.OperationFailed if the path to the file is invalid or
            there were permission or other I/O errors.


        """
        return _hou.Geometry_saveToFile(self, file_name)

    def loadFromFile(self, file_name: "char const *") -> "void":
        r"""

        loadFromFile(self, file_name)

            Replace the contents of this geometry object with the data stored in
            a file. You would typically call this method from the code of a
            Python-defined SOP.

            You may specify any type of file supported by Houdini's File SOP.
            See hou.Geometry.saveToFile for more information.

            Raises hou.OperationFailed if the file does not exist or otherwise
            cannot be loaded.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.merge.


        """
        return _hou.Geometry_loadFromFile(self, file_name)

    def merge(self, geometry: "Geometry", clone_data_ids: "bool" = False) -> "void":
        r"""

        merge(self, geometry, clone_data_ids=False)

            Merge the points and primitives from another hou.Geometry object
            into this one. The new points and primitives are appended to this
            geometry's points and primitives. You would typically call this
            method from the code of a Python-defined SOP.

            When merging into an empty Geometry object, clone_data_ids specifies
            whether the resulting attributes will have the same data ids. This
            is useful to enable optimizations that cache data by only looking at
            the attribute data id regardless of whether it is from the same
            geometry object or not. Otherwise, the copied attributes will have
            data ids that are unique.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.loadFromFile.


        """
        return _hou.Geometry_merge(self, geometry, clone_data_ids)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove everything from this geometry object. The geometry will have
            no points or primitives after calling this method.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Geometry_clear(self)

    def intersect(
        self,
        rayorig: "Vector3",
        dir: "Vector3",
        p: "Vector3",
        n: "Vector3",
        uvw: "Vector3",
        pattern: "char const *" = None,
        min_hit: "float" = 1e-2,
        max_hit: "float" = 1e18,
        tolerance: "float" = 1e-2,
    ) -> "int":
        r"""

        intersect(self, ray_origin, ray_direction, position_out, normal_out,
        uvw_out, pattern=None, min_hit=0.01, max_hit=1E18, tolerance=0.01) ->
        int

            Determines the intersection point of a ray with the geometry in this
            object.


            NOTE
                This method is unusual in that instead of returning multiple
                pieces of information about the intersection, it requires that
                you pass it objects which it modifies in-place with the
                information.

          > # Get some geometry from a SOP node
          > geometry = hou.node(\"/obj/geo1/sphere1\").geometry()
          > # Shoot a ray from high up in the \"sky\" straight down at the origin
          > origin = hou.Vector3(0, 100, 0)
          > direction = hou.Vector3(0, -1, 0)
          > # Make objects for the intersect() method to modify
          > position = hou.Vector3()
          > normal = hou.Vector3()
          > uvw = hou.Vector3()
          > # Find the first intersection (if it exists)
          > did_intersect = geometry.intersect(origin, direction, position, normal, uvw)

            Returns the ID number of the hit primitive if the ray intersected
            the geometry, or -1 if the ray did not hit.


            ray_origin
                A hou.Vector3 object representing the starting point of the ray
                in world space.

            ray_direction
                A hou.Vector3 object representing the direction vector of the
                ray.

            position_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the intersection
                position in world space.

            normal_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the normal direction
                from the surface to the ray.

            uvw_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the UVW position within
                the intersecting primitive where the ray hit.

            pattern
                If you pass a string containing primitive group syntax, the ray
                can only intersect primitives that match the pattern.

            min_hit
                Ignore intersections closer than this distance. You can use the
                min_hit argument to iterate through all possible hits along the
                ray, by setting the min_hit a tiny bit farther than the previous
                hit.

              > hit_positions = []
              > prev_dist = 0.01
              > while geometry.intersect(origin, direction, position, normal, uvw,
              >                          min_hit=prev_dist):
              >     # Make sure to store a *copy* of the position, not the object
              >     # that is being modified in each iteration of the loop
              >     hit_positions.append(hou.Vector3(position))
              >     prev_dist = origin.distanceTo(position) + 0.01

            max_hit
                Ignore intersections farther than this distance.

            tolerance
                Use this parameter to adjust the accuracy of intersections. If
                the ray approaches the geometry within the tolerance value, an
                intersection hit is assumed. A 0.01 tolerance (default) gives
                strict intersections while larger values produces less accurate
                intersections.


        """
        return _hou.Geometry_intersect(
            self, rayorig, dir, p, n, uvw, pattern, min_hit, max_hit, tolerance
        )

    def _orderedPoints(
        self,
        groupname: "char const *",
        corner_groupname: "char const *",
        dimensions: "Vector2",
    ) -> "std::vector< int,std::allocator< int > >":
        return _hou.Geometry__orderedPoints(
            self, groupname, corner_groupname, dimensions
        )

    def pointGroups(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PointGroup >,std::allocator< HOM_ElemPtr< HOM_PointGroup > > >":
        r"""

        pointGroups(self) -> tuple of hou.PointGroup

            Return a tuple of all the point groups in the geometry.

            The following function returns the names of all the groups in the
            geometry:

          > def pointGroupNames(geometry):
          >     return [group.name() for group in geometry.pointGroups()]

        """
        return _hou.Geometry_pointGroups(self)

    def findPointGroup(self, name: "char const *") -> "HOM_PointGroup *":
        r"""

        findPointGroup(self, name) -> hou.PointGroup or None

            Return the point group with the given name, or None if no such group
            exists.


        """
        return _hou.Geometry_findPointGroup(self, name)

    def createPointGroup(
        self, name: "char const *", is_ordered: "bool" = False
    ) -> "HOM_PointGroup *":
        r"""

        createPointGroup(self, name, is_ordered=False) -> hou.PointGroup

            Create a new point group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            is_ordered
                Whether or not the new group should be ordered. See
                hou.PointGroup for more information about ordered groups.

            Use hou.PointGroup.destroy to remove a point group from the
            geometry.


        """
        return _hou.Geometry_createPointGroup(self, name, is_ordered)

    def primGroups(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PrimGroup >,std::allocator< HOM_ElemPtr< HOM_PrimGroup > > >":
        r"""

        primGroups(self) -> tuple of hou.PrimGroup

            Return a tuple of all the primitive groups in the geometry.


        """
        return _hou.Geometry_primGroups(self)

    def findPrimGroup(self, name: "char const *") -> "HOM_PrimGroup *":
        r"""

        findPrimGroup(self, name) -> hou.PrimGroup or None

            Return the primitive group with the given name, or None if no such
            group exists.


        """
        return _hou.Geometry_findPrimGroup(self, name)

    def createPrimGroup(
        self, name: "char const *", is_ordered: "bool" = False
    ) -> "HOM_PrimGroup *":
        r"""

        createPrimGroup(self, name, is_ordered=False) -> hou.PrimGroup

            Create a new primitive group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            is_ordered
                Whether or not the new group should be ordered. See
                hou.PrimGroup for more information about ordered groups.

            Use hou.PrimGroup.destroy to remove a primitive group from the
            geometry.


        """
        return _hou.Geometry_createPrimGroup(self, name, is_ordered)

    def edgeGroups(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_EdgeGroup >,std::allocator< HOM_ElemPtr< HOM_EdgeGroup > > >":
        r"""

        edgeGroups(self) -> tuple of hou.EdgeGroup

            Return a tuple of all the edge groups in the geometry.


        """
        return _hou.Geometry_edgeGroups(self)

    def findEdgeGroup(self, name: "char const *") -> "HOM_EdgeGroup *":
        r"""

        findEdgeGroup(self, name) -> hou.EdgeGroup or None


            name
                The name of the edge group.

            Return the edge group with the given name, or None if no such group
            exists.


        """
        return _hou.Geometry_findEdgeGroup(self, name)

    def createEdgeGroup(self, name: "char const *") -> "HOM_EdgeGroup *":
        r"""

        createEdgeGroup(self, name) -> hou.EdgeGroup

            Create a new edge group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            Use hou.EdgeGroup.destroy to remove an edge group from the geometry.


        """
        return _hou.Geometry_createEdgeGroup(self, name)

    def vertexGroups(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_VertexGroup >,std::allocator< HOM_ElemPtr< HOM_VertexGroup > > >":
        r"""

        vertexGroups(self) -> tuple of hou.VertexGroup

            Return a tuple of all the vertex groups in the geometry.

            The following function returns the names of all the groups in the
            geometry:

          > def vertexGroupNames(geometry):
          >     return [group.name() for group in geometry.vertexGroups()]

        """
        return _hou.Geometry_vertexGroups(self)

    def findVertexGroup(self, name: "char const *") -> "HOM_VertexGroup *":
        r"""

        findVertexGroup(self, name) -> hou.VertexGroup or None

            Return the vertex group with the given name, or None if no such
            group exists.


        """
        return _hou.Geometry_findVertexGroup(self, name)

    def createVertexGroup(
        self, name: "char const *", is_ordered: "bool" = False
    ) -> "HOM_VertexGroup *":
        r"""

        createVertexGroup(self, name, is_ordered=False) -> hou.VertexGroup

            Create a new vertex group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            is_ordered
                Whether or not the new group should be ordered. See
                hou.VertexGroup for more information about ordered groups.

            Use hou.VertexGroup.destroy to remove a vertex group from the
            geometry.


        """
        return _hou.Geometry_createVertexGroup(self, name, is_ordered)

    def findEdge(self, p0: "Point", p1: "Point") -> "HOM_Edge *":
        r"""

        findEdge(self, p0, p1) -> hou.Edge


            p0
                The first point that makes up the edge. See hou.Point for more
                information.

            p1
                The second point that makes up the edge. See hou.Point for more
                information.

            finds an edge given two points, or None if no such edge exists


        """
        return _hou.Geometry_findEdge(self, p0, p1)

    def boundingBox(self, transform: "Matrix4" = None) -> "HOM_BoundingBox":
        r"""

        boundingBox(self, transform=None) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box (of optionally transformed
            instantiation) that is sized and positioned to be large enough to
            hold this geometry.


            transform
                A hou.Matrix4 that transforms the geometry instance. Does not
                change the original geometry.


        """
        return _hou.Geometry_boundingBox(self, transform)

    def pointBoundingBox(self, ptgroup: "char const *") -> "HOM_BoundingBox":
        r"""

        pointBoundingBox(self, pointpattern) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box that is sized and positioned
            to include the points specified by the point pattern. If the pattern
            is blank, all points will be included.

            Some primitives, such as spheres, extend beyond their points. This
            extension will not be included.


        """
        return _hou.Geometry_pointBoundingBox(self, ptgroup)

    def primBoundingBox(self, primgroup: "char const *") -> "HOM_BoundingBox":
        r"""

        primBoundingBox(self, primpattern) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box that is sized and positioned
            to include the primitives specified by the primitive pattern. If the
            pattern is blank, all primitives will be included.

            Some primitives, such as spheres, extend beyond their points. This
            extension will be included.


        """
        return _hou.Geometry_primBoundingBox(self, primgroup)

    def orientedBoundingBox(self) -> "HOM_OrientedBoundingBox":
        r"""

        orientedBoundingBox(self) -> hou.orientedBoundingBox

            Return an oriented 3D bounding box that is sized and positioned to
            be large enough to hold this geometry.


        """
        return _hou.Geometry_orientedBoundingBox(self)

    def orientedPointBoundingBox(
        self, ptgroup: "char const *"
    ) -> "HOM_OrientedBoundingBox":
        r"""

        orientedPointBoundingBox(self, pointpattern) -> hou.OrientedBoundingBox

            Return an oriented 3D bounding box that is sized and positioned to
            include the points specified by the point pattern. If the pattern is
            blank, all points will be included.

            Some primitives, such as spheres, extend beyond their points. This
            extension will not be included.


        """
        return _hou.Geometry_orientedPointBoundingBox(self, ptgroup)

    def orientedPrimBoundingBox(
        self, primgroup: "char const *"
    ) -> "HOM_OrientedBoundingBox":
        r"""

        orientedPrimBoundingBox(self, primpattern) -> hou.OrientedBoundingBox

            Return an oriented 3D bounding box that is sized and positioned to
            include the primitives specified by the primitive pattern. If the
            pattern is blank, all primitives will be included.

            Some primitives, such as spheres, extend beyond their points. This
            extension will be included.


        """
        return _hou.Geometry_orientedPrimBoundingBox(self, primgroup)

    def nearestPrim(
        self, position: "_DoubleTuple"
    ) -> "UT_Tuple< HOM_ElemPtr< HOM_Prim >,double,double,double >":
        r"""

        nearestPrim(self, position) -> (hou.Prim or None, float, float, float)

            Given a sequence of three floats containing a position, find the
            location on the primitive closest to that position and return a
            tuple containing that primitive, the u value on the primitive, the v
            value on the primitive, and the distance to the primitive.

            Note that the first value in the return tuple can be None if there
            are no primitives in the geometry.

            NOTE: The returned UVs are in real coordinates, use the
            hou.Prim.primuvConvert to switch to unit coordinates to match VEX's
            xyzdist.


        """
        return _hou.Geometry_nearestPrim(self, position)

    def nearestPoint(
        self,
        position: "_DoubleTuple",
        ptgroup: "char const *" = None,
        max_radius: "double" = 1e18,
    ) -> "HOM_Point *":
        r"""

        nearestPoint(self, position, ptgroup=None, max_radius=1E18) -> hou.Point
        or None

            Given a sequence of three floats containing a query position, find
            the closest point in the geometry to that position within
            max_radius.

            If ptgroup is a string group pattern, then the search will be
            restricted to the points specified.

            Note that None is returned when there are no points in the geometry.

            See also: hou.nearestPoints


        """
        return _hou.Geometry_nearestPoint(self, position, ptgroup, max_radius)

    def nearestPoints(
        self,
        position: "_DoubleTuple",
        max_points: "int64",
        ptgroup: "char const *" = None,
        max_radius: "double" = 1e18,
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        nearestPoints(self, position, max_points, ptgroup=None, max_radius=1E18)
        -> tuple of hou.Point

            Given a sequence of three floats containing a query position, find
            the closest max_points in the geometry to that position within
            max_radius.

            If ptgroup is a string group pattern, then the search will be
            restricted to the points specified.

            Note that None is returned when there are no points in the geometry.

            See also: hou.nearestPoint


        """
        return _hou.Geometry_nearestPoints(
            self, position, max_points, ptgroup, max_radius
        )

    def primLoop(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        primLoop(self, prims, loop_type) -> tuple of hou.Prim

            Returns a tuple of hou.Prim objects that make a path connecting the
            primitives provided in the prims parameter. If multiple paths are
            being returned, they will be separated in the single returned tuple
            by a value of None. The paths are generated using the same algorithm
            used when performing loop selections in the viewport.

            prims: A list of hou.Prim objects that define the path or paths of
            connected primitives this function should return. Must contain at
            least two primitives.

            loop_type: Controls the type of path returned. Can be any of the
            hou.componentLoopType values. If using either the
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, the inputs prims cannot contain any None entries.
            Furthermore, each pair of primitives is used to define a separate
            full loop, so the number of primitives must be even. If these
            conditions are not met, a hou.OperationFailed exception will be
            thrown.

            Raises a hou.OperationFailed if it was unable to construct a loop
            from the desired components.


        """
        return _hou.Geometry_primLoop(self, *args, **kwargs)

    def pointLoop(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        pointLoop(self, points, full_loop) -> tuple of hou.Point

            Returns a tuple of hou.Point objects that make a path connecting the
            points provided in the points parameter. If multiple paths are being
            returned, they will be separated in the single returned tuple by a
            value of None. The paths are generated using the same algorithm used
            when performing loop selections in the viewport.

            points: A list of hou.Point objects that define the path or paths of
            connected points this function should return. Must contain at least
            two points.

            loop_type: Controls the type of path returned. Can be any of the
            hou.componentLoopType values. If using either the
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, the inputs points cannot contain any None entries.
            Furthermore, each pair of points is used to define a separate full
            loop, so the number of points must be even. If these conditions are
            not met, a hou.OperationFailed exception will be thrown.

            Raises a hou.OperationFailed if it was unable to construct a loop
            from the desired components.


        """
        return _hou.Geometry_pointLoop(self, *args, **kwargs)

    def edgeLoop(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Edge >,std::allocator< HOM_ElemPtr< HOM_Edge > > >":
        r"""

        edgeLoop(self, edges, loop_type, full_loop_per_edge, force_ring,
        allow_ring) -> tuple of hou.Edge

            Returns a tuple of hou.Edge objects that make a path connecting the
            edges provided in the edges parameter. If multiple paths are being
            returned, they will be separated in the single returned tuple by a
            value of None. The paths are generated using the same algorithm used
            when performing loop selections in the viewport.

            edges: A list of hou.Edge objects that define the path or paths of
            connected edges this function should return. Must contain at least
            one or two edges depending on the loop options.

            loop_type: Controls the type of path returned. Can be any of the
            hou.componentLoopType values. If using either the
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, the inputs edges cannot contain any None entries. If these
            conditions are not met, a hou.OperationFailed exception will be
            thrown.

            full_loop_per_edge: If set to True, with the loop_type set to
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, each inputs edge is used to create its own full loop or ring.
            If False, the edges are taken in pairs, and so the number of edges
            must be even.

            force_ring: If set to True, this function will return edge rings
            instead of edge loops.

            allow_ring: If set to True, this function may return an edge ring if
            the edges provided produce a ring more naturally than they produce a
            loop (for example if two perpendicular edges are provided from the
            same row on a polygonal grid). If set to False, only edge loops will
            be returned.

            Raises a hou.OperationFailed if it was unable to construct a loop
            from the desired components.


        """
        return _hou.Geometry_edgeLoop(self, *args, **kwargs)

    def pointNormals(
        self, points: "_PointTuple"
    ) -> "std::vector< HOM_Vector3,std::allocator< HOM_Vector3 > >":
        r"""

        pointNormals(self, points) -> tuple of hou.Vector3

            Returns a tuple of hou.Vector3 objects representing the point
            normals for the supplied points.

            points: A list of hou.Point objects for which to compute point
            normals.


        """
        return _hou.Geometry_pointNormals(self, points)

    def importLop(self, *args, **kwargs) -> "HOM_LopLockedStage *":
        r"""

        importLop(self, lopnode, selectionrule, purpose=None, traversal=None,
        path_attrib_name=None, name_attrib_name=None, strip_layers=False,
        frame=None) -> hou.LopLockedStage

            Imports primitives from the stage of the specified LOP as packed
            primitives.

            Returns a hou.LopLockedStage object which should be kept in scope
            for as long as this geometry object contains packed primitives
            created by this method. Allowing this hou.LopLockedStage object to
            be destroyed will prevent the USD packed primitives from being
            displayed or unpacked.

            Primitives are selected according to the hou.LopSelectionRule.

            When a purpose is specified, only primitives with that purpose are
            imported.

            When a traversal method is specified, the children of primitives
            specified by the hou.LopSelectionRule will be traversed using the
            specified traversal. Possible values are, for example std:component,
            std:boundables, std:groups.

            When a path_attrib_name is given, the path of each LOP primitive is
            stored in an attribute of that name.

            When a name_attrib_name is given, the name of each LOP primitive is
            stored in an attribute of that name.

            If strip_layers is True, any layers preceding a Layer Break node
            connected directly or indirectly to the requested LOP node will be
            stripped from the USD stage before importing the stage. This can be
            useful if a Layer Break is being used to keep data that may be
            modified (added after the Layer Break node) separate from primitives
            that should not be modified (added to the stage before the Layer
            Break node).

            If frame is given, the LOP will be evaluated at that specific
            sample. If left at None, the current evaluation time sample will be
            used instead.


        """
        return _hou.Geometry_importLop(self, *args, **kwargs)

    def importUsdStage(self, *args, **kwargs) -> "void":
        r"""

        importUsdStage(self, stage, selectionrule, purpose=None, traversal=None,
        path_attrib_name=None, name_attrib_name=None, frame=None)

            Imports primitives from a USD Stage as packed primitives.

            The USD Stage should be kept in scope for as long as this geometry
            object contains packed primitives created by this method. Allowing
            the Stage object to be destroyed may prevent the USD packed
            primitives from being displayed or unpacked.

            Primitives are selected according to the hou.LopSelectionRule.

            When a purpose is specified, only primitives with that purpose are
            imported.

            When a traversal method is specified, the children of primitives
            specified by the hou.LopSelectionRule will be traversed using the
            specified traversal. Possible values are, for example std:component,
            std:boundables, std:groups.

            When a path_attrib_name is given, the path of each LOP primitive is
            stored in an attribute of that name.

            When a name_attrib_name is given, the name of each LOP primitive is
            stored in an attribute of that name.

            If frame is given, time samples from the stage will be extracted for
            the requested sample. If left at None, Houdini's current evaluation
            time sample will be used instead.


        """
        return _hou.Geometry_importUsdStage(self, *args, **kwargs)

    def selection(self) -> "HOM_Selection *":
        r"""

        selection(self) -> hou.Selection

            Returns the current cook component selection associated with this
            geometry. This is the default selection set by the SOP that created
            the geometry.


        """
        return _hou.Geometry_selection(self)

    def _guDetailHandle(self) -> "HOM_GUDetailHandle *":
        return _hou.Geometry__guDetailHandle(self)

    def _geometryHandle(self) -> "HOMF_GeometryHandle &":
        return _hou.Geometry__geometryHandle(self)

    def vexAttribDataId(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        vexAttribDataId(self) -> tuple of int

            Return the same list of integers that the attribdataid() VEX
            function returns when calling attribdataid(geo, \"meta\", \"detail\").
            It is an identifier that can be used as a conservative check whether
            there are any modifications to this object. The value of
            hou.Geometry.modificationCounter is included in the return value.


        """
        return _hou.Geometry_vexAttribDataId(self)

    def modificationCounter(self) -> "int64":
        r"""

        modificationCounter(self) -> int or long

            Return a counter that can be used as a conservative check to
            determine if changes have been made to this object. Note that this
            counter is not unique across different hou.Geometry objects. To
            compare these values across different geometries, use
            hou.Geometry.vexAttribDataId instead.


        """
        return _hou.Geometry_modificationCounter(self)

    def incrementModificationCounter(self) -> "void":
        r"""

        incrementModificationCounter(self)

            Increment the modification counter to mark this object as having its
            contents modified.


        """
        return _hou.Geometry_incrementModificationCounter(self)

    def incrementAllDataIds(self) -> "void":
        r"""

        incrementAllDataIds(self)

            Increment all data ids on attributes in this geometry. Use this as
            an easy way to mark that everything in this geometry has changed.
            Internally, this also calls
            hou.Geometry.incrementModificationCounter.


        """
        return _hou.Geometry_incrementAllDataIds(self)

    def incrementDataIdsForAddOrRemove(
        self, for_points: "bool" = True, for_prims: "bool" = True
    ) -> "void":
        r"""

        incrementDataIdsForAddOrRemove(self, for_points=True, for_prims=True)

            Increment data ids which indicate that points and/or primitives have
            been added or removed.


        """
        return _hou.Geometry_incrementDataIdsForAddOrRemove(self, for_points, for_prims)

    def primitiveIntrinsicsDataId(self) -> "HOM_AttribDataId *":
        r"""

        primitiveIntrinsicsDataId(self)

            Returns the data id that represents the contents of primitives,
            excluding primitive attributes. Note that this data id is also
            incremented whenever the number of primitives changes as well.


        """
        return _hou.Geometry_primitiveIntrinsicsDataId(self)

    def incrementPrimitiveIntrinsicsDataId(self) -> "void":
        r"""

        incrementPrimitiveIntrinsicsDataId(self)

            Increment the primitive intrinsics data id to indicate that the
            contents of primitives have changed, excluding primitive attributes.


        """
        return _hou.Geometry_incrementPrimitiveIntrinsicsDataId(self)

    def topologyDataId(self) -> "HOM_AttribDataId *":
        r"""

        topologyDataId(self)

            Returns the data id that represents the topology of this geometry
            such as when points are wired to primitives.


        """
        return _hou.Geometry_topologyDataId(self)

    def incrementTopologyDataId(self) -> "void":
        r"""

        incrementTopologyDataId(self)

            Increment data ids to indicate that topology in this geometry has
            changed in some way.


        """
        return _hou.Geometry_incrementTopologyDataId(self)

    def generateAttribMenu(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        generateAttribMenu(self, attrib_type=None, data_type=None, min_size=1,
        max_size=-1, array_type=True, scalar_type=True, case_sensitive=True,
        pattern=\"*\", decode_tokens=False) -> tuple of str

            Generates the tokens and labels for a parameter menu listing the
            geometry's attributes.


            attrib_type
                A hou.attribType value specifying whether to list point,
                primitive, vertex, or global attributes. Providing a value of
                None will list attributes of all types.

            data_type
                Filters the attribute list to include only attributes with the
                specified hou.attribData data type. Providing a value of None
                will list attributes of all data types.

            min_size
                Includes only attributes whose size is at least this value.

            max_size
                If greater than min_size, includes only attributes whose size is
                at most this value.

            array_type
                Specifies whether array attributes should be included.

            scalar_type
                Specifies whether attributes that do not contain array data
                should be included.

            case_sensitive
                Specifies whether the menu labels are produced in a case-
                sensitive order. This also controls whether the pattern is
                treated as case-sensitive.

            pattern
                Specifies a pattern of attribute names that should be included.

            decode_tokens
                If enabled, the menu tokens will contain the decoded attribute
                names rather than the actual attribute names. This can be useful
                for parameters that support matching against decoded attribute
                names.


        """
        return _hou.Geometry_generateAttribMenu(self, *args, **kwargs)

    def _generateGroupMenu(
        self,
        group_types: "_EnumTuple",
        include_selection: "bool",
        include_name_attrib: "bool",
        case_sensitive: "bool",
        pattern: "char const *",
        decode_tokens: "bool",
        parm: "Parm",
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.Geometry__generateGroupMenu(
            self,
            group_types,
            include_selection,
            include_name_attrib,
            case_sensitive,
            pattern,
            decode_tokens,
            parm,
        )

    def isReadOnly(self) -> "bool":
        r"""

        isReadOnly(self) -> bool

            Return true if the geometry is read-only.


        """
        return _hou.Geometry_isReadOnly(self)

    def _attribInfo(
        self,
        name: "char const *",
        attr_data_type: "int &",
        attr_size: "int &",
        is_array_type: "bool &",
    ) -> "void":
        return _hou.Geometry__attribInfo(
            self, name, attr_data_type, attr_size, is_array_type
        )


# Register Geometry in _hou:
_hou.Geometry_swigregister(Geometry)


class GeometryDelta(object):
    r"""

    hou.GeometryDelta

    Geometry delta provides access to the geometry differences (deltas)
    stored by some Geometry nodes such as the edit SOP.

    If you ask a SOP for its geometry delta via hou.SopNode.geometryDelta,
    you'll get a reference to it. If the SOP recooks, the corresponding
    geometry delta objects will update to the SOP's new geometry delta
    object. If the SOP is deleted, accessing the geometry delta object will
    raise a hou.ObjectWasDeleted exception.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometryDelta

    def __repr__(self) -> "std::string":
        return _hou.GeometryDelta___repr__(self)

    def setPointPositionsFromString(self, *args) -> "void":
        r"""

        setPointPositionsFromString(self, positions)

            Stores the differences between the provided positions and this SOP
            node's input geometry into this node's geometry delta object. This
            can be used, for example, to preload an edit SOP's delta so its
            output geometry matches a desired shape without changing the input
            geometry.

            The positions parameter should be a binary representation of the
            positions. For example, the result of calling
            hou.Geometry.pointFloatAttribValuesAsString.


        """
        return _hou.GeometryDelta_setPointPositionsFromString(self, *args)


# Register GeometryDelta in _hou:
_hou.GeometryDelta_swigregister(GeometryDelta)


class GeometryDrawable(AdvancedDrawable):
    r"""

    hou.GeometryDrawable

    Advanced drawable for drawing guide geometries.

    OVERVIEW

        hou.GeometryDrawable lets you draw guide geometries like
        hou.SimpleDrawable, but offers more drawing options with various
        kind of visualization effects. For instance, you can use a
        hou.GeometryDrawable object for drawing the faces of the attached
        geometry, drawing points in different shapes, drawing lines or
        vectors. You may also use a glow matte effect to highlight faces,
        lines, point radius, etc...

        Like hou.SimpleDrawable, hou.GeometryDrawable uses mostly the same
        services for managing geometries in the viewer without being part of
        the actual scene. Like hou.TextDrawable, hou.GeometryDrawable is
        designed for python states and requires the onDraw handler for
        drawing its attached geometry.


        NOTE
            hou.GeometryDrawable can only be used with polygon mesh
            geometries.

    RELATED

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable

      * hou.TextDrawable


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, scene_viewer, geo_type, name, label=None, geometry=None,
        params=None)

            Creates a new drawable object of a given highlight type. The new
            drawable is hidden by default.


            scene_viewer
                A hou.SceneViewer reference to the viewer the guide geometry
                will appear in.

            geo_type
                A hou.drawableGeometryType value for specifying the kind of
                drawable to create.

            name
                A string to identify this drawable object.

            label
                An optional string for the drawable label. Defaults to empty.

            geometry
                An optional hou.Geometry object containing the geometry to draw.

            params
                An optional parameter dictionary for setting the drawable
                parameters. The parameters contained in params must match the
                geo_type drawable being created or they will be ignored. These
                are the same parameters you can use with
                hou.AdvancedDrawable.setParams and hou.AdvancedDrawable.draw.

                Other common parameters are listed in
                hou.AdvancedDrawable.setParams.

                clip_plane
                hou.Vector4 or sequence of 4 doubles

                Vector representing a clip plane in world coordinates. (a, b, c,
                d) represents a plane ax + by + cz + d = 0, and geometry behind
                the plane is clipped. The default value is hou.Vector4(0, 0, 0,
                0). Setting this param also enables the use of clip plane on
                this drawable. This can be enabled/disabled with useClipPlane.

                Line parameter
                Type
                Description
                line_width
                double

                Sets the line width value. Defaults to 1.0.

                style
                hou.drawableGeometryLineStyle or sequence of 2 doubles

                Sets the line style to draw: solid, dashed, or dotted. When
                passing in 2 doubles, the first value is the length of the dash
                in pixels and the second is the length of the gap between dashes
                in pixels. Defaults to hou.drawableGeometryLineStyle.Plain.

                Face parameter
                Type
                Description
                backface_culling
                Bool

                Enable or disable backface culling. Defaults to the current
                viewport Remove Backfaces display option.

                color_ramp_parm
                hou.Parm

                Sets the drawable with a color ramp object. If the ramp is
                enabled (i.e. use_ramp_color=True), the drawable hilites the
                geometry polygons with the ramp value settings along with a pre-
                existing Cd attribute on the geometry. Defaults to an RGB ramp
                object type.

                The ramp works as a transformation on values from the Cd. It's
                done per component, so, if your Cd doesn't have the same value
                in all the three components, you won't get the colors from the
                ramp.

                The way it works is that the ramp ends up being a 1-dimensional
                OpenGL texture (512 pixels long). The drawable takes each
                component (R, G, B) of each fragment color and maps it linearly
                (using the ramp_range min and max values) into an index in
                (0...511) and reads off the corresponding color component from
                the texture and substitutes the Cd value with that value for
                that component.

                If the value ends up out of min-max range, then depending on the
                ramp_clamp setting it either gets clamped to one of the two ends
                of the range, or is taken modulo the range interval (repeating
                cyclically), or is just blacked out.

                glyphe_scale
                double

                A scale value for the face patterns. Default to 1.0.

                indices
                sequence of int

                A list of indices representing the geometry faces to draw. All
                geometry faces are drawn by default.

                period
                double

                A value for displaying faces in patterns based on the style
                option selected. Defaults to 0.

                style
                hou.drawableGeometryFaceStyle

                Sets the face style to draw. Defaults to
                hou.drawableGeometryFaceStyle.Plain.

                ramp_clamp
                hou.drawableRampClamp

                Sets the ramp clamp type for color_ramp_parm. Defaults to
                hou.drawableRampClamp.Edge.

                ramp_range
                hou.Vector2

                Sets the minimum and maximum ramp value for color_ramp_parm.
                Defaults to hou.Vector2(-1,-1).

                reverse_winding
                Bool

                Pick which side of a face to remove when backface culling is
                active. Defaults to False;

                use_color_ramp
                Bool

                Enable the use of the color ramp if one is set on the drawable.
                Defaults to False.

                Point parameter
                Type
                Description
                falloff_range
                hou.Vector2

                Sets the falloff range value. Defaults to hou.Vector2(0, 0).

                indices
                sequence of int

                A list of polygon point indices, only the points of the
                corresponding indices are drawn. If no indices are provided, all
                geometry points are drawn by default.

                num_rings
                int

                Sets the number of rings around the point. Works with
                hou.drawableGeometryPointStyle.RingsCircle or
                hou.drawableGeometryPointStyle.RingsSquare. Defaults to 0.

                radius
                double

                Sets the point radius value. Defaults to 0.05.

                style
                hou.drawableGeometryPointStyle

                Sets the point style to draw. Ring styles work better when the
                max falloff_range value is > 0. Defaults to
                hou.drawableGeometryPointStyle.LinearCircle.

                Vector parameter
                Type
                Description
                indices
                sequence of int

                A list of polygon point indices, only the vectors for the points
                of the corresponding indices are drawn. If no indices are
                provided, all vectors are drawn by default.

                bidirect
                Bool

                Draws the vector segment with an arrow on both end. Defaults to
                False.

                length_scale
                double

                Sets the length of the vector segment. Defaults to 1.0.

                vector_width
                int

                Sets the width of the vector segment in pixel units. Defaults to
                0.

                use_arrow
                Bool

                Draws the vector segment with an arrow on one end. Defaults to
                False.

                base_fade_factor
                double

                Fades the entire vector by this factor if the base point of the
                vector is occluded. Can be used in conjunction with fade_factor
                to achieve different levels of fading if the vector is occluded
                and the base of the vector is occluded, in which case the
                product of the two fade factors is used. Defaults to 0.25.


        """
        _hou.GeometryDrawable_swiginit(self, _hou.new_GeometryDrawable(*args, **kwargs))

    __swig_destroy__ = _hou.delete_GeometryDrawable

    def __repr__(self) -> "std::string":
        return _hou.GeometryDrawable___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Returns the drawable's geometry object. The returned geometry is
            read-only.


        """
        return _hou.GeometryDrawable_geometry(self)

    def setGeometry(self, geometry: "Geometry") -> "void":
        r"""

        setGeometry(self, geometry)

            Sets the drawable with a new geometry. The changes will appear the
            next time the viewer redraws.


            geometry
                A hou.Geometry object.


        """
        return _hou.GeometryDrawable_setGeometry(self, geometry)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.drawableGeometryType

            Returns the type of drawable as specified at creation time.


        """
        return _hou.GeometryDrawable_type(self)

    def useClipPlane(self, value: "bool") -> "void":
        r"""

        useClipPlane(self, value)

            Enable or disable the clip plane while rendering this drawable. It
            is disabled by default.


            value
                True to enable the clip plane and False to disable it.


        """
        return _hou.GeometryDrawable_useClipPlane(self, value)


# Register GeometryDrawable in _hou:
_hou.GeometryDrawable_swigregister(GeometryDrawable)


class GeometryDrawableGroup(AdvancedDrawable):
    r"""

    hou.GeometryDrawableGroup

    A container of hou.GeometryDrawable objects.

    OVERVIEW

        hou.GeometryDrawableGroup acts as a regular hou.GeometryDrawable
        object which can contain several hou.GeometryDrawable children.
        hou.GeometryDrawableGroup performs operations on its children in the
        order they were added. You can also query specific children from
        hou.GeometryDrawableGroup for setting their parameters individually.

        Here's an example that creates a group composed of two
        hou.GeometryDrawable objects.

      > import hou
      > import viewerstate.utils as su
      >
      > class State(object):
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      >
      >         # create the geometry
      >         sops = hou.sopNodeTypeCategory()
      >         verb = sops.nodeVerb('tube')
      >         verb.setParms({
      >             \"rad\": (0.2, 0.4),
      >             \"rows\": 3,
      >             \"cols\": 6,
      >             'height': 1.0,
      >             \"cap\":True
      >         })
      >
      >         geo = hou.Geometry()
      >         verb.execute(geo, [])
      >
      >         # creates the drawable group
      >         self.cursor = hou.GeometryDrawableGroup(\"cursor\")
      >
      >         # adds the drawables
      >         self.cursor.addDrawable( hou.GeometryDrawable( self.scene_viewer,
      >             hou.drawableGeometryType.Face, \"face\", params = {'color1' : (0.0,1.0,0.0,1.0)} ))
      >         self.cursor.addDrawable( hou.GeometryDrawable(self.scene_viewer,
      >             hou.drawableGeometryType.Line, \"line\", params = {'color1' : (0,0,0,1.0)} ))
      >
      >         # set the geometry on all children
      >         self.cursor.setGeometry(geo)
      >         self.cursor.show(False)
      >
      >         self.cursor_pos = hou.Vector3()
      >
      >     def onMouseEvent(self, kwargs):
      >         ui_event = kwargs[\"ui_event\"]
      >         (origin, dir) = ui_event.ray()
      >
      >         gi = su.GeometryIntersector(kwargs[\"node\"].geometry())
      >         gi.intersect(origin, dir)
      >
      >         if gi.intersected:
      >             self.cursor_pos = gi.position
      >             self.cursor.show(True)
      >         else:
      >             self.cursor.show(False)
      >
      >     def onDraw(self, kwargs):
      >         handle = kwargs['draw_handle']
      >
      >         params = {
      >             'translate' : (self.cursor_pos[0], self.cursor_pos[1], self.cursor_pos[2]),
      >             'line_width' : 0.25
      >         }
      >
      >         self.cursor.draw( handle, params )

    RELATED

      * hou.GeometryDrawable


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label=None)

            Creates a new geometry drawable group object. The new object is
            empty and must be filled with hou.GeometryDrawable objects to be
            useful.


            name
                Name of the drawable group.

            label
                An optional string for the drawable label. Defaults to empty.


        """
        _hou.GeometryDrawableGroup_swiginit(
            self, _hou.new_GeometryDrawableGroup(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_GeometryDrawableGroup

    def __repr__(self) -> "std::string":
        return _hou.GeometryDrawableGroup___repr__(self)

    def addDrawable(self, drawable: "GeometryDrawable") -> "void":
        r"""

        addDrawable(geometry_drawable)

            Adds a hou.GeometryDrawable object at the end of the children.


            geometry_drawable
                The hou.GeometryDrawable to add.


        """
        return _hou.GeometryDrawableGroup_addDrawable(self, drawable)

    def drawable(
        self, drawable_name: "std::string const &"
    ) -> "HOM_GeometryDrawable *":
        r"""

        drawable(name): -> hou.GeometryDrawable

            Returns a drawable by name.


        """
        return _hou.GeometryDrawableGroup_drawable(self, drawable_name)

    def drawables(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_GeometryDrawable >,std::allocator< HOM_ElemPtr< HOM_GeometryDrawable > > >":
        r"""

        drawables(): -> list` of hou.GeometryDrawable

            Returns a list of all children.


        """
        return _hou.GeometryDrawableGroup_drawables(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self): -> hou.Geometry

            Returns the drawable's geometry object. The returned geometry is
            read-only.


        """
        return _hou.GeometryDrawableGroup_geometry(self)

    def setGeometry(self, geometry: "Geometry") -> "void":
        r"""

        setGeometry(self, geometry)

            Sets all drawable children with a new geometry. The changes will
            appear the next time the viewer redraws.


            geometry
                A hou.Geometry object.


        """
        return _hou.GeometryDrawableGroup_setGeometry(self, geometry)

    def useClipPlane(self, value: "bool") -> "void":
        r"""

        useClipPlane(self, value)

            Enable or disable the clip plane on all drawables in this group. By
            default the clip plane for all drawables are disabled.


            value
                True to enable the clip plane on all drawables and False to
                disable it.


        """
        return _hou.GeometryDrawableGroup_useClipPlane(self, value)


# Register GeometryDrawableGroup in _hou:
_hou.GeometryDrawableGroup_swigregister(GeometryDrawableGroup)


class GadgetDrawable(GeometryDrawable):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, widget: "int64", gadget_context: "int64"):
        _hou.GadgetDrawable_swiginit(
            self, _hou.new_GadgetDrawable(widget, gadget_context)
        )

    __swig_destroy__ = _hou.delete_GadgetDrawable

    def __repr__(self) -> "std::string":
        return _hou.GadgetDrawable___repr__(self)


# Register GadgetDrawable in _hou:
_hou.GadgetDrawable_swigregister(GadgetDrawable)


class GeometryRayCache(object):
    r"""

    hou.GeometryRayCache

    Geometry Ray Cache allows caching of ray-intersection structures.

    When you use hou.Geometry.intersect(), the hou.Geometry will store an
    acceleration structure. This is reset if the geometry changes at all,
    however. A ray cache allows you to maintain an acceleration structure
    and re-use it if only the point positions change.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__(self)

            Return a new GeometryRayCache. The same ray cache can be used across
            multiple geometries and, where possible, it will cache the
            acceleration structures for faster ray intersection.


        """
        _hou.GeometryRayCache_swiginit(self, _hou.new_GeometryRayCache())

    __swig_destroy__ = _hou.delete_GeometryRayCache

    def __repr__(self) -> "std::string":
        return _hou.GeometryRayCache___repr__(self)

    def intersect(
        self,
        geo: "Geometry",
        rayorig: "Vector3",
        dir: "Vector3",
        p: "Vector3",
        n: "Vector3",
        uvw: "Vector3",
        min_hit: "float" = 1e-2,
        max_hit: "float" = 1e18,
        tolerance: "float" = 1e-2,
    ) -> "int":
        r"""

        intersect(self, ray_origin, ray_direction, position_out, normal_out,
        uvw_out, min_hit=0.01, max_hit=1E18, tolerance=0.01) -> int

            Determines the intersection point of a ray with the geometry in this
            object.


            NOTE
                This method is unusual in that instead of returning multiple
                pieces of information about the intersection, it requires that
                you pass it objects which it modifies in-place with the
                information.

            Returns the ID number of the hit primitive if the ray intersected
            the geometry, or -1 if the ray did not hit.


            ray_origin
                A hou.Vector3 object representing the starting point of the ray
                in world space.

            ray_direction
                A hou.Vector3 object representing the direction vector of the
                ray.

            position_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the intersection
                position in world space.

            normal_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the normal direction
                from the surface to the ray.

            uvw_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the UVW position within
                the intersecting primitive where the ray hit.

            min_hit
                Ignore intersections closer than this distance. You can use the
                min_hit argument to iterate through all possible hits along the
                ray, by setting the min_hit a tiny bit farther than the previous
                hit.

              > hit_positions = []
              > prev_dist = 0.01
              > while geometry.intersect(origin, direction, position, normal, uvw,
              >                          min_hit=prev_dist):
              >     # Make sure to store a *copy* of the position, not the object
              >     # that is being modified in each iteration of the loop
              >     hit_positions.append(hou.Vector3(position))
              >     prev_dist = origin.distanceTo(position) + 0.01

            max_hit
                Ignore intersections farther than this distance.

            tolerance
                Use this parameter to adjust the accuracy of intersections. If
                the ray approaches the geometry within the tolerance value, an
                intersection hit is assumed. A 0.01 tolerance (default) gives
                strict intersections while larger values produces less accurate
                intersections.


        """
        return _hou.GeometryRayCache_intersect(
            self, geo, rayorig, dir, p, n, uvw, min_hit, max_hit, tolerance
        )

    def findAllInTube(
        self,
        geo: "Geometry",
        rayorig: "Vector3",
        dir: "Vector3",
        radius: "float",
        min_hit: "float" = 0.0,
        max_hit: "float" = 1e18,
        tolerance: "float" = 5e-3,
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        findAllInTube(self, line_origin, line_direction, radius, min_hit=0,
        max_hit=1E18, tolerance=5E-3) -> tuple of hou.Point

            Return a tuple of all the points in the geometry inside the tube
            given by the line and radius.


            ray_origin
                A hou.Vector3 object representing the starting point of the line
                in world space.

            ray_direction
                A hou.Vector3 object representing the direction vector of the
                line.

            radius
                Find points within this distance of the line.

            min_hit
                Ignore intersections closer than this distance. You can use the
                min_hit argument to iterate through all possible hits along the
                ray, by setting the min_hit a tiny bit farther than the previous
                hit.

            max_hit
                Ignore intersections farther than this distance.

            tolerance
                Use this parameter to adjust the accuracy of intersections. A
                5E-3 tolerance (default) gives strict intersections while larger
                values produces less accurate intersections.


        """
        return _hou.GeometryRayCache_findAllInTube(
            self, geo, rayorig, dir, radius, min_hit, max_hit, tolerance
        )


# Register GeometryRayCache in _hou:
_hou.GeometryRayCache_swigregister(GeometryRayCache)


class GeometrySelection(object):
    r"""

    hou.GeometrySelection

    Represents a component selection performed by the user in a viewport.

    Calling hou.SceneViewer.selectGeometry waits for the user to perform a
    selection in the viewport, and returns an object of this type
    representing the elected components. The returned selection can be
    manipulated by converting it to a specific component type, grown, or
    shrunk. Then the selection can be converted to a string that can be used
    in a SOP node group parameter.

    If the selection contains components from more than one SOP, you can use
    the hou.GeometrySelection.mergedNode function to create a Merge SOP
    and/or Object Merge SOPs that brings all the referenced geometry into a
    single node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.GeometrySelection

        Represents a component selection performed by the user in a viewport.

        Calling hou.SceneViewer.selectGeometry waits for the user to perform a
        selection in the viewport, and returns an object of this type
        representing the elected components. The returned selection can be
        manipulated by converting it to a specific component type, grown, or
        shrunk. Then the selection can be converted to a string that can be used
        in a SOP node group parameter.

        If the selection contains components from more than one SOP, you can use
        the hou.GeometrySelection.mergedNode function to create a Merge SOP
        and/or Object Merge SOPs that brings all the referenced geometry into a
        single node.


        """
        _hou.GeometrySelection_swiginit(self, _hou.new_GeometrySelection(*args))

    __swig_destroy__ = _hou.delete_GeometrySelection

    def __repr__(self) -> "std::string":
        return _hou.GeometrySelection___repr__(self)

    def __str__(self) -> "std::string":
        return _hou.GeometrySelection___str__(self)

    def ordered(self) -> "bool":
        r"""

        ordered(self) -> bool

            Returns true if this is an ordered selection. This means that the
            order in which the user selected the components is preserved. To
            have an ordered selection, the ordered parameter needs to have been
            set to True when calling hou.SceneViewer.geometrySelection.


        """
        return _hou.GeometrySelection_ordered(self)

    def geometryType(self) -> "HOM_EnumValue &":
        r"""

        geometryType(self) -> hou.geometryType enum value

            Returns the type of component that was selected.


        """
        return _hou.GeometrySelection_geometryType(self)

    def setGeometryType(self, type: "EnumValue") -> "void":
        r"""

        setGeometryType(self, type)

            Changes the type of component contained in the selection, converting
            the existing selection to the new component type.


        """
        return _hou.GeometrySelection_setGeometryType(self, type)

    def connectivity(self) -> "HOM_EnumValue &":
        r"""

        connectivity(self) -> hou.connectivityType enum value

            Returns the hou.connectivityType that has been set on this geometry
            selection. Unless you call hou.GeometrySelection.setConnectivity,
            this function will return the no connectivity value.


        """
        return _hou.GeometrySelection_connectivity(self)

    def setConnectivity(self, connectivity: "EnumValue") -> "void":
        r"""

        setConnectivity(self, connectivity)

            Sets the type of connectivity to enforce when modifying the
            selection. The current selection is also expanded so that all
            connected components (using the supplied style of connectivity)
            become part of the selection.


        """
        return _hou.GeometrySelection_setConnectivity(self, connectivity)

    def primitiveTypes(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        primitiveTypes(self) -> tuple of hou.primitiveType enum values

            Returns a tuple containing all primitive types that are contained in
            the selection.


        """
        return _hou.GeometrySelection_primitiveTypes(self)

    def setPrimitiveTypes(self, primitive_types: "_EnumTuple") -> "void":
        r"""

        setPrimitiveTypes(self, primitive_types)

            Sets the tuple of primitive types allowed in the selection. Any
            primitives that are not of an allowed type are removed from the
            selection. Only has an effect if this is a primitive selection.


        """
        return _hou.GeometrySelection_setPrimitiveTypes(self, primitive_types)

    def nodes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        nodes(self) -> tuple of Nodes

            Returns a tuple of all nodes referenced by the selection.


        """
        return _hou.GeometrySelection_nodes(self)

    def selectionStrings(
        self, empty_string_selects_all: "bool" = True, force_numeric: "bool" = False
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectionStrings(self, empty_string_selects_all=True, bool
        force_numeric=False) -> tuple of strings

            Returns a tuple of strings that can be used to refer to the selected
            components in each SOP node referenced by the selection.


        """
        return _hou.GeometrySelection_selectionStrings(
            self, empty_string_selects_all, force_numeric
        )

    def selections(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Selection >,std::allocator< HOM_ElemPtr< HOM_Selection > > >":
        r"""

        selections(self) -> tuple of [Hom:hou.Selection]

            Returns a tuple of component selection objects. These correspond to
            the nodes returned by the nodes function.


        """
        return _hou.GeometrySelection_selections(self)

    def needsMergedNode(self, parent: "Node") -> "bool":
        r"""

        needsMergedNode(self, parent) -> bool

            Returns true if a Merge SOP needs to be created in order to access
            all components in the selection.


        """
        return _hou.GeometrySelection_needsMergedNode(self, parent)

    def mergedNode(
        self,
        parent: "Node",
        creator_name: "char const *",
        force_keep_original_objects: "bool" = False,
        display_original_objects: "bool" = False,
    ) -> "HOM_Node *":
        r"""

        mergedNode(self, parent, creator_name,
        force_keep_original_objects=False, display_original_objects=False) ->
        Node

            Creates a Merge SOP that combines all the SOPs referenced by the
            selection. Most selections will only reference a single SOP in which
            case no Merge SOP is required, and the selected SOP will be
            returned.


        """
        return _hou.GeometrySelection_mergedNode(
            self,
            parent,
            creator_name,
            force_keep_original_objects,
            display_original_objects,
        )

    def mergedSelectionString(
        self, empty_string_selects_all: "bool" = True, force_numeric: "bool" = False
    ) -> "std::string":
        r"""

        mergedSelectionString(self, empty_string_selects_all=True,
        force_numeric=False) -> string

            Returns a single string that can be used in group parameters of the
            merged node returned by hou.GeometrySelection.mergedNode. If all
            components are selected from a single node this is equivalent to the
            first string in the tuple returned by
            hou.GeometrySelection.selectionStrings.


        """
        return _hou.GeometrySelection_mergedSelectionString(
            self, empty_string_selects_all, force_numeric
        )

    def shrinkSelection(self, check_uv: "bool" = True) -> "void":
        r"""

        shrinkSelection(checkuv = true)

            Removes components that are on the boundary of the selection.


        """
        return _hou.GeometrySelection_shrinkSelection(self, check_uv)

    def growSelection(self) -> "void":
        r"""

        growSelection()

            Expands the selection by adding all components that are connected to
            components currently in the selection.


        """
        return _hou.GeometrySelection_growSelection(self)

    def boundingBox(self) -> "HOM_BoundingBox":
        r"""

        boundingBox(self) -> BoundingBox

            Returns the bounding box of the selected region.


        """
        return _hou.GeometrySelection_boundingBox(self)

    def orientedBoundingBox(self) -> "HOM_OrientedBoundingBox":
        r"""

        orientedBoundingBox(self) -> OrientedBoundingBox

            Returns the oriented bounding box of the selected region.


        """
        return _hou.GeometrySelection_orientedBoundingBox(self)


# Register GeometrySelection in _hou:
_hou.GeometrySelection_swigregister(GeometrySelection)


class GeometrySpreadsheet(PathBasedPaneTab):
    r"""

    hou.GeometrySpreadsheet

    Represents a geometry spreadsheet pane tab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometrySpreadsheet

    def __repr__(self) -> "std::string":
        return _hou.GeometrySpreadsheet___repr__(self)

    def numRows(self) -> "int":
        r"""

        numRows(self) -> int

            Returns the number of rows in the geometry spreadsheet.


        """
        return _hou.GeometrySpreadsheet_numRows(self)

    def numColumns(self) -> "int":
        r"""

        numColumns(self) -> int

            Returns the number of columns in the geometry spreadsheet.


        """
        return _hou.GeometrySpreadsheet_numColumns(self)

    def cellText(self, row: "int", col: "int") -> "std::string":
        r"""

        cellText(self, row, col) -> str

            Returns the text for the specified cell.


        """
        return _hou.GeometrySpreadsheet_cellText(self, row, col)

    def groupFilter(self) -> "std::string":
        r"""

        groupFilter(self) -> str

            Returns the spreadsheet's group filter pattern.


        """
        return _hou.GeometrySpreadsheet_groupFilter(self)

    def setGroupFilter(self, group: "char const *") -> "void":
        r"""

        setGroupFilter(self, group)

            Sets the group pattern for the spreadsheet.


        """
        return _hou.GeometrySpreadsheet_setGroupFilter(self, group)

    def groupFilterEnabled(self) -> "bool":
        r"""

        groupFilterEnabled(self) -> bool

            Return whether the group filter is enabled in the spreadsheet.


        """
        return _hou.GeometrySpreadsheet_groupFilterEnabled(self)

    def setGroupFilterEnabled(self, enable: "bool") -> "void":
        r"""

        setGroupFilterEnabled(self, enable)

            Toggles whether the group filter is enabled in the spreadsheet.


        """
        return _hou.GeometrySpreadsheet_setGroupFilterEnabled(self, enable)

    def attribFilter(self) -> "std::string":
        r"""

        attribFilter(self) -> str

            Returns the spreadsheet's attribute filter pattern.


        """
        return _hou.GeometrySpreadsheet_attribFilter(self)

    def setAttribFilter(self, filter: "char const *") -> "void":
        r"""

        setAttribFilter(self, filter)

            Sets the attribute filter pattern for the spreadsheet.


        """
        return _hou.GeometrySpreadsheet_setAttribFilter(self, filter)

    def attribFilterEnabled(self) -> "bool":
        r"""

        attribFilterEnabled(self) -> bool

            Return whether the attribute filter is enabled in the spreadsheet.


        """
        return _hou.GeometrySpreadsheet_attribFilterEnabled(self)

    def setAttribFilterEnabled(self, enable: "bool") -> "void":
        r"""

        setAttribFilterEnabled(self, enable)

            Toggles whether the attribute filter is enabled in the spreadsheet.


        """
        return _hou.GeometrySpreadsheet_setAttribFilterEnabled(self, enable)

    def viewDecomposedMatrices(self) -> "bool":
        r"""

        viewDecomposedMatrices(self) -> bool

            Returns whether matrix values are decomposed into translation,
            rotation, scale, and shear components.


        """
        return _hou.GeometrySpreadsheet_viewDecomposedMatrices(self)

    def setViewDecomposedMatrices(self, enable: "bool") -> "void":
        r"""

        setViewDecomposedMatrices(self, enable)

            Toggles whether matrix values are decomposed into translation,
            rotation, scale, and shear components.


        """
        return _hou.GeometrySpreadsheet_setViewDecomposedMatrices(self, enable)


# Register GeometrySpreadsheet in _hou:
_hou.GeometrySpreadsheet_swigregister(GeometrySpreadsheet)


class GeometryViewport(object):
    r"""

    hou.GeometryViewport

    A viewport within a Scene Viewer pane, for viewing the scene at the
    Object or SOP level.

    OVERVIEW

        A viewer is a type of pane that shows the scene. The viewer's
        contents is conceptually divided into viewports. By default, the
        scene viewer shows a single viewport, the Perspective view. However,
        you can use the view layout controls to, for example, split the view
        into four viewports (Perspective, Top, Front, and Right views).
        Viewports are the parts of the interface that actually display the
        scene to the user.


            To access a viewport, you must first get a reference to a Scene
            Viewer pane tab. See the following methods:


            hou.ui.paneTabOfType
                Use hou.ui.paneTabOfType(hou.paneTabType.SceneViewer) to get
                a reference to a Scene Viewer pane tab in the current pane
                layout. If the current layout has no Scene Viewer pane tab,
                this returns None.

                To be more precise about which viewer you grab in a possible
                multi-viewer layout, see also hou.ui.curDesktop to get a
                hou.Desktop object representing the current pane layout, and
                hou.Desktop.sceneViewers to get a list of scene viewer pane
                tabs in the current layout.

            Once you have a reference to a hou.SceneViewer pane object, you
            can use it to access the viewer pane's viewport or viewports.
            See the following methods:


            hou.SceneViewer.viewports
                Returns a list of the viewports in the viewer pane.

            hou.SceneViewer.findViewport
                Gets a single viewport by name, for example \"Top\".

            hou.SceneViewer.selectedViewport
                Gets the currently selected viewport. The user can select a
                viewport by pressing [Space + N] in the viewport. The view
                menus in the upper right corner are drawn brighter in the
                selected viewport.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometryViewport

    def __repr__(self) -> "std::string":
        return _hou.GeometryViewport___repr__(self)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.geometryViewportType enum value

            Query the viewport type (UV, 3D, top, left, etc).


        """
        return _hou.GeometryViewport_type(self)

    def changeType(self, type: "EnumValue") -> "void":
        r"""

        changeType(self, [Hom:hou.geometryViewportType])

            Set the viewport type (hou.geometryViewportType). This method first
            attempts to restore a stashed view for the new viewport type, but
            failing that, will home the viewport.


        """
        return _hou.GeometryViewport_changeType(self, type)

    def settings(self) -> "HOM_GeometryViewportSettings *":
        r"""

        settings(self) -> hou.GeometryViewportSettings

            Returns the hou.GeometryViewportSettings object for this viewport.
            By calling methods on that object, you can read/edit the viewport's
            display options.


        """
        return _hou.GeometryViewport_settings(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Query of the name of the viewport (persp1, top1, etc).


        """
        return _hou.GeometryViewport_name(self)

    def changeName(self, name: "std::string &") -> "void":
        r"""

        changeName(self, str)

            Set the name of the viewport. Setting the name does not affect its
            type, so naming a perspective view front will be confusing. This is
            best used in conjunction with changeType().


        """
        return _hou.GeometryViewport_changeName(self, name)

    def home(self) -> "void":
        r"""

        home(self)

            Moves/tumbles the viewport to the default view.


        """
        return _hou.GeometryViewport_home(self)

    def homeAll(self) -> "void":
        r"""

        homeAll(self)

            Moves/tumbles the view to show all geometry/objects (including
            templated geometry). See also homeNonTemplated().


        """
        return _hou.GeometryViewport_homeAll(self)

    def homeSelected(self) -> "void":
        r"""

        homeSelected(self)

            Moves/tumbles the view to show the selected geometry/objects.


        """
        return _hou.GeometryViewport_homeSelected(self)

    def homeGrid(self) -> "void":
        r"""

        homeGrid(self)

            Homes the viewport on the grid.


        """
        return _hou.GeometryViewport_homeGrid(self)

    def homeNonTemplated(self) -> "void":
        r"""

        homeNonTemplated(self)

            Moves/tumbles the view to show all non-templated geometry.


        """
        return _hou.GeometryViewport_homeNonTemplated(self)

    def homeBoundingBox(
        self, bbox: "BoundingBox", center_to_origin: "bool" = False
    ) -> "void":
        r"""

        homeBoundingBox(self, bbox, center_to_origin=False)

            Moves/tumbles the viewport to show an arbitrary area in the scene.


            bbox
                A hou.BoundingBox representing the volume of space to focus on.

            center_to_origin


        """
        return _hou.GeometryViewport_homeBoundingBox(self, bbox, center_to_origin)

    def frameAll(self) -> "void":
        r"""

        frameAll(self)

            Moves the view to show all geometry/objects. See also
            frameNonTemplates().


        """
        return _hou.GeometryViewport_frameAll(self)

    def frameBoundingBox(self, bbox: "BoundingBox" = None) -> "void":
        r"""

        frameBoundingBox(self, bbox)

            Moves the view to show an arbitrary area in the scene.


            bbox
                A hou.BoundingBox representing the volume of space to focus on.


        """
        return _hou.GeometryViewport_frameBoundingBox(self, bbox)

    def frameSelected(self) -> "void":
        r"""

        frameSelected(self)

            Moves the view to show the selected geometry/objects.


        """
        return _hou.GeometryViewport_frameSelected(self)

    def frameGrid(self) -> "void":
        r"""

        frameGrid(self)

            Frames the view on the grid.


        """
        return _hou.GeometryViewport_frameGrid(self)

    def frameNonTemplated(self) -> "void":
        r"""

        frameNonTemplated(self)

            Moves the view to show all non-templated geometry.


        """
        return _hou.GeometryViewport_frameNonTemplated(self)

    def draw(self) -> "void":
        r"""

        draw(self)

            Request that the viewport redraw. Multiple draw() calls within the
            same script will be merged into a single call.


        """
        return _hou.GeometryViewport_draw(self)

    def viewTransform(self) -> "HOM_Matrix4 *":
        r"""

        viewTransform(self) -> hou.Matrix4

            Returns the transform matrix of the view. To set the viewpoint
            programmatically, use defaultCamera() to get a hou.ViewportCamera
            object and manipulate that.


        """
        return _hou.GeometryViewport_viewTransform(self)

    def modelToGeometryTransform(self) -> "HOM_Matrix4 *":
        r"""

        modelToGeometryTransform(self) -> hou.Matrix4

            Returns the transform from the modeling space to the space of the
            points in the geometry. When modeling at object level, this converts
            from the object space into the SOP's space. When modeling at the SOP
            level, this is identity as the model space was the SOP space.


        """
        return _hou.GeometryViewport_modelToGeometryTransform(self)

    def cameraToModelTransform(self) -> "HOM_Matrix4 *":
        r"""

        cameraToModelTransform(self) -> hou.Matrix4

            Equivalent to viewTransform, this is the transform matrix of the
            view. It converts from the camera's space into the space that
            modeling is currently being done at.


        """
        return _hou.GeometryViewport_cameraToModelTransform(self)

    def ndcToCameraTransform(self) -> "HOM_Matrix4 *":
        r"""

        ndcToCameraTransform(self) -> hou.Matrix4

            Returns the transform from normalized device coordinates to the
            viewport camera's space. This is often a projective transform, so if
            used the resulting points will have to be dehomogenized by dividing
            by w.


        """
        return _hou.GeometryViewport_ndcToCameraTransform(self)

    def viewportToNDCTransform(self) -> "HOM_Matrix4 *":
        r"""

        viewportToNDCTransform(self) -> hou.Matrix4

            Returns the matrix converting from the viewport pixel coordinates to
            the normalized device coordinates. This is a two dimensional scale
            and translate, so the z and w components are identity.


        """
        return _hou.GeometryViewport_viewportToNDCTransform(self)

    def windowToViewportTransform(self) -> "HOM_Matrix4 *":
        r"""

        windowToViewportTransform(self) -> hou.Matrix4

            Returns the matrix converting from the window pixel viewport
            coordinates to the viewport pixel coordinates. Window coordinates
            are present in hou.ViewerEvent and are unaware of quad-view
            viewports.

            This is a two dimensional translate, so z and w components are
            identity.


        """
        return _hou.GeometryViewport_windowToViewportTransform(self)

    def viewPivot(self) -> "HOM_Vector3 *":
        r"""

        viewPivot(self) -> hou.Vector3

            Returns a hou.Vector3 representing the view pivot as a point in
            world space.


        """
        return _hou.GeometryViewport_viewPivot(self)

    def resolutionInPixels(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        resolutionInPixels(self) -> 2-tuple of int

            Returns the resolution of the viewport in pixels, as (width,
            height).


        """
        return _hou.GeometryViewport_resolutionInPixels(self)

    def camera(self) -> "HOM_ObjNode *":
        return _hou.GeometryViewport_camera(self)

    def cameraPath(self) -> "std::string":
        r"""

        cameraPath(self) -> str

            Return the path to the camera that the viewport is looking through.
            If the viewport isn't looking through a camera, return an empty
            string. In objects, this is the path of the camera object node. In
            LOPs, this is the USD primitive path.


        """
        return _hou.GeometryViewport_cameraPath(self)

    def setCamera(self, *args) -> "void":
        r"""

        setCamera(self, camera_node)

            Copies the viewport transform from the transformation parameters of
            a camera or light onto the current view. This is the same as
            choosing a camera/light from the Look through submenu in the
            viewport's Camera menu.


            camera_node
                A hou.ObjNode object representing the node to save the view
                from.


        """
        return _hou.GeometryViewport_setCamera(self, *args)

    def saveViewToCamera(self, camera_node: "ObjNode") -> "void":
        r"""

        saveViewToCamera(self, camera_node)

            Copies the viewpoint transform of the current view onto the
            transformation parameters of a camera or light node.


            camera_node
                A hou.ObjNode object representing the node to save the view to.


        """
        return _hou.GeometryViewport_saveViewToCamera(self, camera_node)

    def defaultCamera(self) -> "HOM_GeometryViewportCamera *":
        r"""

        defaultCamera(self) -> hou.GeometryViewportCamera

            Returns an object representing the viewport's viewpoint. The
            returned object is live in that changing its settings will
            immediately change the view

            If a camera/light is locked to the view, changing the settings of
            the GeometryViewportCamera will change the camera/light node's
            parameters as well.

            Instead of a live object, you can get a disconnected version of the
            viewpoint using hou.GeometryViewportCamera.stash. This is a useful
            way to remember a certain viewpoint in code for later. You can
            restore a stashed camera using setDefaultCamera().

          > # Remember the current view
          > cam = viewport.defaultCamera()
          > saved = cam.stash()
          >
          > # Change the view somehow
          >
          > # Restore the original view
          > viewport.setDefaultCamera(saved)

        """
        return _hou.GeometryViewport_defaultCamera(self)

    def setDefaultCamera(self, cam_settings: "GeometryViewportCamera") -> "void":
        r"""

        setDefaultCamera(self, stashed_cam)

            Takes a hou.GeometryViewportCamera and copies its values into this
            viewport.

            Set the current camera settings of the viewport to the settings
            stored in cam_setting. If the viewport is looking through a camera
            and the view is not locked to the camera, it will be switched to No
            camera. If the view is locked to the camera, the camera object will
            be updated instead.


        """
        return _hou.GeometryViewport_setDefaultCamera(self, cam_settings)

    def useDefaultCamera(self) -> "void":
        r"""

        useDefaultCamera(self)

            Set the viewport camera to No camera and stop looking through a
            camera object (or light).


        """
        return _hou.GeometryViewport_useDefaultCamera(self)

    def isCameraLockedToView(self) -> "bool":
        r"""

        isCameraLockedToView(self) -> bool

            Query to see if the camera is locked to the view. This returns the
            state of the camera lock only; this can be enabled without viewing
            through a camera.


        """
        return _hou.GeometryViewport_isCameraLockedToView(self)

    def lockCameraToView(self, arg2: "bool") -> "void":
        r"""

        lockCameraToView(self)

            Set the viewport camera lock. When True, any changes to the view
            will affect the camera object being viewed though. When False, the
            camera will become disconnected from the viewport and revert to the
            default viewport camera when the user tumbles the view. It is
            possible to enable this without the viewport looking through a
            camera, though view changes will not affect any objects until the
            user sets the viewport to look through a camera or light.


        """
        return _hou.GeometryViewport_lockCameraToView(self, arg2)

    def isActive2D(self) -> "bool":
        r"""

        isActive2D(self) -> bool

            Query if the viewport is currently displaying 2d geometry, often
            implying it is displaying UV information.


        """
        return _hou.GeometryViewport_isActive2D(self)

    def isActive3D(self) -> "bool":
        r"""

        isActive3D(self) -> bool

            Query if the viewport is currently displaying 3d geometry. This is
            the case for perspective and ortho viewports.


        """
        return _hou.GeometryViewport_isActive3D(self)

    def usesConstructionPlane(self) -> "bool":
        r"""

        usesConstructionPlane(self) -> bool

            Returns whether this viewport uses the construction plane when it is
            on.


        """
        return _hou.GeometryViewport_usesConstructionPlane(self)

    def queryNodeAtPixel(
        self, x: "int", y: "int", pick_templates: "bool" = False
    ) -> "HOM_Node *":
        r"""

        queryNodeAtPixel(self, x, y, pick_templates=False) -> hou.ObjNode,
        hou.SopNode, or None

            Return the node draw at the specified pixel in the viewport, or None
            if there is nothing there. The type of node returned depends on the
            level of the viewer.

            If pick_templates is True then templated geometries will be included
            in the query.


        """
        return _hou.GeometryViewport_queryNodeAtPixel(self, x, y, pick_templates)

    def queryPrimAtPixel(self, node: "Node", x: "int", y: "int") -> "HOM_Prim *":
        r"""

        queryPrimAtPixel(self, node, x, y) -> hou.Prim or None

            Return the primitive drawn at the specified pixel in the viewport,
            or None if there is nothing there. The primitive returned will be a
            subclass of hou.Prim.

            The parameter node is used to restrict the query to geometry within
            a particular node. If node is None, then the query is unrestricted.


        """
        return _hou.GeometryViewport_queryPrimAtPixel(self, node, x, y)

    def _queryPrimOnDrawables(
        self, drawables: "_DrawableTuple", x: "int", y: "int", enable_occlusion: "bool"
    ) -> "std::pair< int,int >":
        return _hou.GeometryViewport__queryPrimOnDrawables(
            self, drawables, x, y, enable_occlusion
        )

    def _queryComponentsOnDrawables(
        self,
        drawables: "_DrawableTuple",
        start: "Vector2",
        end_inclusive: "Vector2" = None,
        enable_occlusion: "bool" = False,
        contained: "bool" = False,
    ) -> "std::vector< std::pair< int,HOM_ElemPtr< HOM_Selection > >,std::allocator< std::pair< int,HOM_ElemPtr< HOM_Selection > > > >":
        return _hou.GeometryViewport__queryComponentsOnDrawables(
            self, drawables, start, end_inclusive, enable_occlusion, contained
        )

    def queryInspectedGeometry(self) -> "HOM_Geometry *":
        r"""

        queryInspectedGeometry(self) -> hou.Geometry or None

            Return the geometry currently being inspected in the viewport, or
            None when nothing is being inspected or when called outside of an
            inspect script.


        """
        return _hou.GeometryViewport_queryInspectedGeometry(self)

    def queryInspectedPrim(self) -> "HOM_Prim *":
        r"""

        queryInspectedPrim(self) -> hou.Prim or None

            Return the primitive currently being inspected in the viewport, or
            None when nothing is being inspected or when called outside of an
            inspect script. The primitive returned will be a subclass of
            hou.Prim.


        """
        return _hou.GeometryViewport_queryInspectedPrim(self)

    def mapToWorld(
        self, x: "double", y: "double"
    ) -> "std::pair< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        mapToWorld(self, x, y) -> tuple of (hou.Vector3, hou.Vector3)

            Convert viewport coordinates to world coordinates. Returns a ray
            (direction vector and an origin point).


        """
        return _hou.GeometryViewport_mapToWorld(self, x, y)

    def mapToScreen(self, pos: "Vector3") -> "HOM_Vector2 *":
        r"""

        mapToScreen(self, position) -> hou.Vector2

            Convert world coordinates to viewport coordinates.


            position
                A hou.Vector3 containing a world space position.


        """
        return _hou.GeometryViewport_mapToScreen(self, pos)

    def mapFromMouseChop(self, x: "double", y: "double") -> "std::pair< int,int >":
        r"""

        mapFromMouseChop(self, x, y) -> tuple of (int, int)

            Convert from the Mouse CHOP's X and Y screen values (which range
            from -1 to 1) to viewport coordinates, where (0,0) is the bottom
            left corner of the viewport.


        """
        return _hou.GeometryViewport_mapFromMouseChop(self, x, y)

    def queryWorldPositionAndNormal(
        self, *args
    ) -> "UT_Tuple< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 >,bool >":
        r"""

        queryWorldPositionAndNormal(self, x,y,selectionRestriction) -> tuple of
        (hou.Vector3, hou.Vector3, bool)

            Look up the world position and normal of geometry at viewport
            coordinates (x,y) where (0,0) is the bottom left corner of the
            viewport. The returned tuple contains the position, normal, and a
            boolean flag that is True if there is geometry at that screen
            position. The selectionRestriction can optionally exclude selected
            or non-selected prims; it defaults to querying all prims.


        """
        return _hou.GeometryViewport_queryWorldPositionAndNormal(self, *args)

    def size(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        size(self) -> tuple of double

            Returns the size of this viewport. The tuple elements are returned
            in viewport coordinates.

             1. X position (lower left)

             2. Y position (lower left)

             3. Width dimension

             4. Height dimension


        """
        return _hou.GeometryViewport_size(self)

    def geometry(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        geometry(self) -> tuple of int

            Returns the position and size of this viewport in the UI space. The
            tuple elements are returned in viewport coordinates, relative to the
            lower-left corner position of the scene viewer.

             1. X position (lower left)

             2. Y position (lower left)

             3. Width dimension

             4. Height dimension


        """
        return _hou.GeometryViewport_geometry(self)

    def addEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addEventCallback(self, callback)

            Register a Python callback to be called whenever a viewport event
            occurs.


            callback
                Any callable Python object that expects keyworded arguments
                specific to an event type. This

            callback can be used for any geometry viewport event type.

            The kwargs contains the following:

          * event_type: A viewport event.

          * desktop: The desktop object holding the scene viewer.

          * viewer: The scene viewer object pointing to the viewport.

          * viewport: The viewport object that triggered the event.

          > import hou
          >
          > def onViewportCB(**kwargs):
          >         event_type=kwargs['event_type']
          >         desktop=kwargs['desktop']
          >         viewer=kwargs['viewer']
          >         viewport=kwargs['viewport']
          >
          >         print( \"event type=\",event_type )
          >         print( \"desktop=\",desktop )
          >         print( \"viewer=\",viewer )
          >         print( \"viewport=\",viewport )
          >
          >         cam = viewport.camera()
          > if cam:
          >             print( \"camera=%s

        \"%(cam.name()) )
          >
          > curSceneViewer = [item for item in hou.ui.curDesktop().currentPaneTabs() if item.type() == hou.paneTabType.SceneViewer][0]
          > curSceneViewer.curViewport().addEventCallback(onViewportCB)

        """
        return _hou.GeometryViewport_addEventCallback(self, callback)

    def removeEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeEventCallback(self,callback)

            Remove a specific Python callback that have been registered with
            hou.GeometryViewport.addEventCallback.


        """
        return _hou.GeometryViewport_removeEventCallback(self, callback)

    def clearEventCallbacks(self) -> "void":
        r"""

        clearEventCallbacks(self)

            Remove all Python callbacks that have been registered with
            hou.GeometryViewport.addEventCallback.


        """
        return _hou.GeometryViewport_clearEventCallbacks(self)

    def eventCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        eventCallbacks(self) -> tuple of callbacks

            Return a tuple of all the Python callbacks that have been registered
            with hou.GeometryViewport.addEventCallback.


        """
        return _hou.GeometryViewport_eventCallbacks(self)


# Register GeometryViewport in _hou:
_hou.GeometryViewport_swigregister(GeometryViewport)


class GeometryViewportCamera(object):
    r"""

    hou.GeometryViewportCamera

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometryViewportCamera

    def __repr__(self) -> "std::string":
        return _hou.GeometryViewportCamera___repr__(self)

    def stash(self) -> "HOM_GeometryViewportCamera *":
        r"""

        stash(self) -> hou.GeometryViewportCamera

            Create a copy of the camera settings which can be used to store the
            view, usually so it can be restored later. Stashed camera settings
            are not connected to a viewport, so modifying them will have no
            effect on the viewport until it is passed to the viewport via
            hou.GeometryViewport.setDefaultCamera().


        """
        return _hou.GeometryViewportCamera_stash(self)

    def setPerspective(self, perspective: "bool") -> "void":
        r"""

        setPerspective(self, perspective)

            Set the camera view to perspective (True) or orthographic (False).
            Fixed orthographics views cannot be changed to perspective (Top,
            Bottom, Left, Right, Front, and Back).


        """
        return _hou.GeometryViewportCamera_setPerspective(self, perspective)

    def isPerspective(self) -> "bool":
        r"""

        isPerspective(self) -> bool

            Query if the camara view uses a perspective projection.


        """
        return _hou.GeometryViewportCamera_isPerspective(self)

    def isOrthographic(self) -> "bool":
        r"""

        isOrthographic(self) -> bool

            Query if the camara view uses an orthographic projection.


        """
        return _hou.GeometryViewportCamera_isOrthographic(self)

    def setAperture(self, ap: "double") -> "void":
        r"""

        setAperture(self, ap)

            Set the aperture of the viewport camera. Throws an error if the
            viewport is looking though camera object and the view is not locked
            to that camera.


        """
        return _hou.GeometryViewportCamera_setAperture(self, ap)

    def aperture(self) -> "double":
        r"""

        aperture(self) -> float

            Query the aperture of the viewport camera (or current camera).


        """
        return _hou.GeometryViewportCamera_aperture(self)

    def setFocalLength(self, fl: "double") -> "void":
        r"""

        setFocalLength(self, fl)

            Set the focal length of the viewport camera. Throws an error if the
            viewport is looking though camera object and the view is not locked
            to that camera.


        """
        return _hou.GeometryViewportCamera_setFocalLength(self, fl)

    def focalLength(self) -> "double":
        r"""

        focalLength(self) -> float

            Query the focal length of the viewport camera (or current camera).


        """
        return _hou.GeometryViewportCamera_focalLength(self)

    def focalUnitScale(self) -> "double":
        r"""

        focalUnitScale(self) -> float

            Query the scale which needs to be applied to aperture and focal
            length due to the Focal Units parameter on the Camera object.


        """
        return _hou.GeometryViewportCamera_focalUnitScale(self)

    def setAspectRatio(self, ar: "double") -> "void":
        r"""

        setAspectRatio(self, ar)

            Set the view aspect ratio of the viewport camera (16:9 would be
            1.777). Throws an error if the viewport is looking though camera
            object and the view is not locked to that camera.


        """
        return _hou.GeometryViewportCamera_setAspectRatio(self, ar)

    def aspectRatio(self) -> "double":
        r"""

        aspectRatio(self) -> float


        """
        return _hou.GeometryViewportCamera_aspectRatio(self)

    def setOrthoWidth(self, ow: "double") -> "void":
        r"""

        setOrthoWidth(self, ow)

            Set the orthographic width of the viewport camera. Throws an error
            if the viewport is looking though camera object and the view is not
            locked to that camera. This has no effect on perspective cameras.


        """
        return _hou.GeometryViewportCamera_setOrthoWidth(self, ow)

    def orthoWidth(self) -> "double":
        r"""

        orthoWidth(self) -> float


        """
        return _hou.GeometryViewportCamera_orthoWidth(self)

    def setRotation(self, mat: "Matrix3") -> "void":
        return _hou.GeometryViewportCamera_setRotation(self, mat)

    def rotation(self) -> "HOM_Matrix3":
        return _hou.GeometryViewportCamera_rotation(self)

    def setTranslation(self, xyz: "_DoubleTuple") -> "void":
        r"""

        setTranslation(self, xyz)


        """
        return _hou.GeometryViewportCamera_setTranslation(self, xyz)

    def translation(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        translation(self) -> 3-tuple of float

            Query the translation (position) of the viewport camera.


        """
        return _hou.GeometryViewportCamera_translation(self)

    def setPivot(self, xyz: "_DoubleTuple") -> "void":
        r"""

        setPivot(self, xyz)


        """
        return _hou.GeometryViewportCamera_setPivot(self, xyz)

    def pivot(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        pivot(self) -> 3-tuple of float

            Query the pivot of the viewport camera.


        """
        return _hou.GeometryViewportCamera_pivot(self)

    def setClipPlanes(self, near_far: "_DoubleTuple") -> "void":
        r"""

        setClipPlanes(self, near_far)


        """
        return _hou.GeometryViewportCamera_setClipPlanes(self, near_far)

    def clipPlanes(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        clipPlanes(self) -> 2-tuple of float

            Query the clip planes of the viewport camera as (near,far).


        """
        return _hou.GeometryViewportCamera_clipPlanes(self)

    def setWindowOffset(self, xy: "_DoubleTuple") -> "void":
        r"""

        setWindowOffset(self, xy)


        """
        return _hou.GeometryViewportCamera_setWindowOffset(self, xy)

    def windowOffset(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        windowOffset(self) -> 2-tuple of float

            Query the window offset of the viewport, in (0,1) space.


        """
        return _hou.GeometryViewportCamera_windowOffset(self)

    def setWindowSize(self, size: "_DoubleTuple") -> "void":
        r"""

        setWindowSize(self, size)


        """
        return _hou.GeometryViewportCamera_setWindowSize(self, size)

    def windowSize(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        windowSize(self) -> 2-tuple of float

            Query the window size of the viewport, in (0,1) space.


        """
        return _hou.GeometryViewportCamera_windowSize(self)


# Register GeometryViewportCamera in _hou:
_hou.GeometryViewportCamera_swigregister(GeometryViewportCamera)


class GeometryViewportDisplaySet(object):
    r"""

    hou.GeometryViewportDisplaySet

    A Display Set represents a group of 3D viewport display options that
    apply to a particular context of geometry.

    OVERVIEW

        In Houdini's 3D viewer display options window, you can apply
        different display options to certain subsets of objects/geometry,
        for example selected objects, or the displayed SOP. This object
        represents a set of options that apply to one of these subsets. For
        example, you can set templated SOPs to display as wireframe:

      > # Get a reference to the geometry viewer
      > pane = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.SceneViewer)
      >
      > # Get the display settings
      > settings = pane.curViewport().settings()
      >
      > # Get the GeometryViewportDisplaySet for objects
      > tmplset = settings.displaySet(hou.displaySetType.TemplateModel)
      >
      > # Tell Houdini to show set the shading mode for this subset to wireframe
      > tmplset.setShadedMode(hou.glShadingType.Wire)

        There are several subsets available:

        Objects

        hou.displaySetType.SceneObject
            Object nodes which are not selected or ghosted.

        hou.displaySetType.SelectedObject
            Object nodes which are selected.

        hou.displaySetType.GhostObject
            Object nodes which ghosted, which occurs when they are visible
            when at the SOP level and Ghost Other Objects is the current
            object mode, but are not the current object.

        Geometry

        hou.displaySetType.DisplayModel
            SOP with the display flag. This takes precedence over
            TemplateModel and CurrentModel, if the SOP has either the
            template flag set or is selected.

        hou.displaySetType.CurrentModel
            SOP that is currently selected. This takes precedence over
            TemplateModel, if that SOP also has the template flag set.

        hou.displaySetType.TemplateModel
            SOP that has a template flag set.

        You can set the options in each display set independently of the
        other sets. You can also link a subset to another, so this subset
        uses the linked set's options.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometryViewportDisplaySet

    def __repr__(self) -> "std::string":
        return _hou.GeometryViewportDisplaySet___repr__(self)

    def displaySetType(self) -> "HOM_EnumValue &":
        r"""

        displaySetType() -> hou.displaySetType

            Returns the geometry context this display set represents:

          * hou.displaySetType.SceneObject - object nodes which are not selected
            or ghosted.

          * hou.displaySetType.SelectedObject - object nodes which are selected.

          * hou.displaySetType.GhostObject - object nodes which ghosted, which
            occurs when they are visible when at the SOP level and \"Ghost Other
            Objects\" is the current object mode, but are not the current object.

          * hou.displaySetType.DisplayModel - SOP with the display flag. This
            takes precedence over TemplateModel and CurrentModel, if the SOP has
            either the template flag set or is selected.

          * hou.displaySetType.CurrentModel - SOP that is currently selected.
            This takes precedence over TemplateModel, if that SOP also has the
            template flag set.

          * hou.displaySetType.TemplateModel - SOP that has a template flag set.


        """
        return _hou.GeometryViewportDisplaySet_displaySetType(self)

    def showPointMarkers(self, b: "bool") -> "void":
        r"""

        showPointMarkers(self, on)

            Show or hide point markers.


        """
        return _hou.GeometryViewportDisplaySet_showPointMarkers(self, b)

    def isShowingPointMarkers(self) -> "bool":
        r"""

        isShowingPointMarkers(self) -> bool

            Query if point markers are shown (blue dots at points).


        """
        return _hou.GeometryViewportDisplaySet_isShowingPointMarkers(self)

    def showPointNumbers(self, b: "bool") -> "void":
        r"""

        showPointNumbers(self, on)

            Show or hide point numbers.


        """
        return _hou.GeometryViewportDisplaySet_showPointNumbers(self, b)

    def isShowingPointNumbers(self) -> "bool":
        r"""

        isShowingPointNumbers(self) -> bool

            Query if point numbers are shown as text (blue point numbers, one
            per point).


        """
        return _hou.GeometryViewportDisplaySet_isShowingPointNumbers(self)

    def showPointNormals(self, b: "bool") -> "void":
        r"""

        showPointNormals(self, on)

            Show or hide point normals.


        """
        return _hou.GeometryViewportDisplaySet_showPointNormals(self, b)

    def isShowingPointNormals(self) -> "bool":
        r"""

        isShowingPointNormals(self) -> bool

            Query if point normals are shown.

            If the point normals are blue, the geometry has point normals. If
            they are dimmed, the model does not have normals and the normals
            shown have been automatically generated for display. If no normals
            are shown, the geometry has vertex normals. This query does not
            check for those conditions, but just the current setting of the
            display option.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPointNormals(self)

    def showPointPositions(self, b: "bool") -> "void":
        r"""

        showPointPositions(self, on)

            Show or hide point position text display, drawn by each point.


        """
        return _hou.GeometryViewportDisplaySet_showPointPositions(self, b)

    def isShowingPointPositions(self) -> "bool":
        r"""

        isShowingPointPositions(self) -> bool

            Query if 3D point positions are being shown, as text: (x,y,z).


        """
        return _hou.GeometryViewportDisplaySet_isShowingPointPositions(self)

    def showPointUVs(self, b: "bool") -> "void":
        r"""

        showPointUVs(self, on)

            Show or hide point UVs. If the geometry does not have point UVs,
            nothing will be displayed (ie. no UVs or vertex UVs).


        """
        return _hou.GeometryViewportDisplaySet_showPointUVs(self, b)

    def isShowingPointUVs(self) -> "bool":
        r"""

        isShowingPointUVs(self) -> bool

            Query if point texture coordinates are being shown, as text: (u,v).


        """
        return _hou.GeometryViewportDisplaySet_isShowingPointUVs(self)

    def showPointTrails(self, b: "bool") -> "void":
        r"""

        showPointTrails(self, on)

            Show or hide point trails on all points. Geometry must have a
            velocity attribute v.


        """
        return _hou.GeometryViewportDisplaySet_showPointTrails(self, b)

    def isShowingPointTrails(self) -> "bool":
        r"""

        isShowingPointTrails(self) -> bool

            Query if point trails are shown (based on the velocity v attribute).


        """
        return _hou.GeometryViewportDisplaySet_isShowingPointTrails(self)

    def showCoincidentPoints(self, b: "bool") -> "void":
        r"""

        showCoincidentPoints(self, on)

            Enable or disable coincident point detection. Orange points markers
            and a duplicate count are placed where coincident points are
            detected.

            Coincident point detection has affects viewport performance more
            significantly than other markers. It is best used when zoomed in on
            an area of the geometry for dense meshes, to avoid false positives.


            NOTE
                Coincident point detection has affects viewport performance more
                significantly than other markers. It is best used when zoomed in
                on an area of the geometry for dense meshes, to avoid false
                positives.


        """
        return _hou.GeometryViewportDisplaySet_showCoincidentPoints(self, b)

    def isShowingCoincidentPoints(self) -> "bool":
        r"""

        isShowingCoincidentPoints(self) -> bool

            Query if coincident point detection is enabled (yellow points and a
            duplicate count where coincident points are detected).


        """
        return _hou.GeometryViewportDisplaySet_isShowingCoincidentPoints(self)

    def showPrimHulls(self, b: "bool") -> "void":
        r"""

        showPrimHulls(self, on)

            Enable or disable primitive hulls. Only certain primitive types have
            hulls, such as NURBS, volumes, agents, and bezier curves.


        """
        return _hou.GeometryViewportDisplaySet_showPrimHulls(self, b)

    def isShowingPrimHulls(self) -> "bool":
        r"""

        isShowingPrimHulls(self) -> bool

            Query if primitive hulls are shown. Only some primitives have hulls,
            such as volumes, NURBS, crowd agents, and bezier curves.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimHulls(self)

    def showPrimNumbers(self, b: "bool") -> "void":
        r"""

        showPrimNumbers(self, on)

            Enable or disable the display of primitive numbers, which are shown
            in the middle of the primitive.


        """
        return _hou.GeometryViewportDisplaySet_showPrimNumbers(self, b)

    def isShowingPrimNumbers(self) -> "bool":
        r"""

        isShowingPrimNumbers(self) -> bool

            Query if primitive numbers are shown. The primitive numbers can be
            used to specify primitives in primitive groups. The number is shown
            at the center of the primitive.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimNumbers(self)

    def showPrimNormals(self, b: "bool") -> "void":
        r"""

        showPrimNormals(self, on)

            Enable or disable primitive face normals. This shows the face
            normals of polygons, not the value of a primitive N attribute.


        """
        return _hou.GeometryViewportDisplaySet_showPrimNormals(self, b)

    def isShowingPrimNormals(self) -> "bool":
        r"""

        isShowingPrimNormals(self) -> bool

            Query if the primitive face normals are shown. Only polygon-based
            primitives have face normals.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimNormals(self)

    def showPrimProfiles(self, b: "bool") -> "void":
        r"""

        showPrimProfiles(self, on)

            Enable or disable profile curve display on NURBS surfaces.


        """
        return _hou.GeometryViewportDisplaySet_showPrimProfiles(self, b)

    def isShowingPrimProfiles(self) -> "bool":
        r"""

        isShowingPrimProfiles(self) -> bool

            Query if profile curves are shown, on NURBS surfaces only.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimProfiles(self)

    def showPrimBreakpoints(self, b: "bool") -> "void":
        r"""

        showPrimBreakpoints(self, on)

            Enable or disable breakpoints display. Breakpoints are only
            available on NURBS and bezier surfaces and curves, and appear as
            hollow circles along the isoparms.


        """
        return _hou.GeometryViewportDisplaySet_showPrimBreakpoints(self, b)

    def isShowingPrimBreakpoints(self) -> "bool":
        r"""

        isShowingPrimBreakpoints(self) -> bool

            Query if breakpoints are displayed. Breakpoints are only available
            on NURBS and bezier surfaces and curves.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimBreakpoints(self)

    def showPrimProfileNumbers(self, b: "bool") -> "void":
        r"""

        showPrimProfileNumbers(self, on)

            Enable or disable profile curve number display on NURBS surfaces.
            Each profile on a NURBS surface has an index from 0 to #profiles-1.


        """
        return _hou.GeometryViewportDisplaySet_showPrimProfileNumbers(self, b)

    def isShowingPrimProfileNumbers(self) -> "bool":
        r"""

        isShowingPrimProfileNumbers(self) -> bool

            Query if profile curve numbers are shown, on NURBS surfaces only.
            Each profile curve has an index from 0 to #profiles-1.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimProfileNumbers(self)

    def showPrimBackfaces(self, b: "bool") -> "void":
        r"""

        showPrimBackfaces(self, on)

            Enable to tint backfacing polygons to distinguish them from front
            facing polygons.


        """
        return _hou.GeometryViewportDisplaySet_showPrimBackfaces(self, b)

    def isShowingPrimBackfaces(self) -> "bool":
        r"""

        isShowingPrimBackfaces(self) -> bool

            Query if backfacing polygons are tinted to distinguish them from
            front facing polygons.


        """
        return _hou.GeometryViewportDisplaySet_isShowingPrimBackfaces(self)

    def showVertexMarkers(self, b: "bool") -> "void":
        r"""

        showVertexMarkers(self, on)

            Enable or disable vertex markers. Vertex markers are drawn as small
            squares inset into its parent polygon slightly.


        """
        return _hou.GeometryViewportDisplaySet_showVertexMarkers(self, b)

    def isShowingVertexMarkers(self) -> "bool":
        r"""

        isShowingVertexMarkers(self) -> bool

            Query if vertex markers are shown. Vertex markers are inset into
            their polygon slightly, for ease of selection and selection display.
            The markers are small hollow squares. Not all primitive types have
            vertex markers.


        """
        return _hou.GeometryViewportDisplaySet_isShowingVertexMarkers(self)

    def showVertexNumbers(self, b: "bool") -> "void":
        r"""

        showVertexNumbers(self, on)

            Enable or disable vertex numbers. Vertex numbers are drawn as
            numbers inset into its parent polygon slightly, ranging 0 to
            #edges-1.


        """
        return _hou.GeometryViewportDisplaySet_showVertexNumbers(self, b)

    def isShowingVertexNumbers(self) -> "bool":
        r"""

        isShowingVertexNumbers(self) -> bool

            Query if vertex numbers are shown. Each vertex on a polygon or mesh
            is numbered 0 to #edges-1.


        """
        return _hou.GeometryViewportDisplaySet_isShowingVertexNumbers(self)

    def showVertexNormals(self, b: "bool") -> "void":
        r"""

        showVertexNormals(self, on)

            Enable or disable vertex normal display. Vertex normals are drawn
            inset into its parent polygon slightly. The geometry must have
            vertex normals to be shown (vertex N).


        """
        return _hou.GeometryViewportDisplaySet_showVertexNormals(self, b)

    def isShowingVertexNormals(self) -> "bool":
        r"""

        isShowingVertexNormals(self) -> bool

            Query if vertex normals are shown. If the geometry does not have
            vertex normals, they will not be shown. The base of the vertex
            normal is inset slightly into its polygon to make it easier to see
            which polygon the normal is influencing.


        """
        return _hou.GeometryViewportDisplaySet_isShowingVertexNormals(self)

    def showVertexUVs(self, b: "bool") -> "void":
        r"""

        showVertexUVs(self, on)

            Enable or disable vertex UV texture display. Vertex UVs are drawn
            inset into its parent polygon. The geometry must have vertex texture
            coordinates to be shown (vertex uv).


        """
        return _hou.GeometryViewportDisplaySet_showVertexUVs(self, b)

    def isShowingVertexUVs(self) -> "bool":
        return _hou.GeometryViewportDisplaySet_isShowingVertexUVs(self)

    def showUVBackfaces(self, b: "bool") -> "void":
        r"""

        showUVBackfaces(self, on)

            Enable or disable UV backface highlighting in the UV viewport.
            Backfacing polygons would have the texture displayed on them
            backwards, from the point of view of the background image in the UV
            viewport.


        """
        return _hou.GeometryViewportDisplaySet_showUVBackfaces(self, b)

    def isShowingUVBackfaces(self) -> "bool":
        r"""

        isShowingUVBackfaces(self) -> bool

            Query if UV Backface highlighting is enabled in the UV view.
            Highlight polygons that are facing away, as the texture will appear
            backwards on these polygons.


        """
        return _hou.GeometryViewportDisplaySet_isShowingUVBackfaces(self)

    def showUVOverlap(self, b: "bool") -> "void":
        r"""

        showUVOverlap(self, on)

            Enable or disable highlighting of UV overlap. Areas of the texture
            that would be share the same UVs are highlighted.


        """
        return _hou.GeometryViewportDisplaySet_showUVOverlap(self, b)

    def isShowingUVOverlap(self) -> "bool":
        r"""

        isShowingUVOverlap(self) -> bool

            Query if the UV overlap is shown in the UV texture viewport. UV
            areas that reuse the same UV coordinates will be highlighted.


        """
        return _hou.GeometryViewportDisplaySet_isShowingUVOverlap(self)

    def setPointMarkerVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPointMarkerVisibility(self, visibility)

            Controls how point markers are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only markers for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Markers close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Markers under the mouse cursor
            are shown.


        """
        return _hou.GeometryViewportDisplaySet_setPointMarkerVisibility(self, v)

    def pointMarkerVisibility(self) -> "HOM_EnumValue &":
        r"""

        pointMarkerVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point markers.


        """
        return _hou.GeometryViewportDisplaySet_pointMarkerVisibility(self)

    def setPointNumberVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPointNumberVisibility(self, visibility)

            Controls how point numbers are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only numbers for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Numbers close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
            are shown.


        """
        return _hou.GeometryViewportDisplaySet_setPointNumberVisibility(self, v)

    def pointNumberVisibility(self) -> "HOM_EnumValue &":
        r"""

        pointNumberVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point numbers.


        """
        return _hou.GeometryViewportDisplaySet_pointNumberVisibility(self)

    def setPointNormalVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPointNormalVisibility(self, visibility)

            Controls how point normals are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only normals for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Normals close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Normals under the mouse cursor
            are shown.


        """
        return _hou.GeometryViewportDisplaySet_setPointNormalVisibility(self, v)

    def pointNormalVisibility(self) -> "HOM_EnumValue &":
        r"""

        pointNormalVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point normals.


        """
        return _hou.GeometryViewportDisplaySet_pointNormalVisibility(self)

    def setPointPositionVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPointPositionVisibility(self, visibility)

            Controls how point positions are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only positions for selected points
            are shown.

          * hou.markerVisibility.AroundPointer: Positions close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Positions under the mouse cursor
            are shown.


        """
        return _hou.GeometryViewportDisplaySet_setPointPositionVisibility(self, v)

    def pointPositionVisibility(self) -> "HOM_EnumValue &":
        r"""

        pointPositionVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point UVs.


        """
        return _hou.GeometryViewportDisplaySet_pointPositionVisibility(self)

    def setPointUVVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPointUVVisibility(self, visibility)

            Controls how point UVs are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only UVs for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: UVs close to the 3D point the
            mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: UVs under the mouse cursor are
            shown.


        """
        return _hou.GeometryViewportDisplaySet_setPointUVVisibility(self, v)

    def pointUVVisibility(self) -> "HOM_EnumValue &":
        r"""

        pointUVVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point UVs.


        """
        return _hou.GeometryViewportDisplaySet_pointUVVisibility(self)

    def setPointTrailVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPointTrailVisibility(self, visibility)

            Controls how point trails are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only trails for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Trails close to the 3D point the
            mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Trails under the mouse cursor are
            shown.


        """
        return _hou.GeometryViewportDisplaySet_setPointTrailVisibility(self, v)

    def pointTrailVisibility(self) -> "HOM_EnumValue &":
        r"""

        pointTrailVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point trails.


        """
        return _hou.GeometryViewportDisplaySet_pointTrailVisibility(self)

    def setPrimNumberVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPrimNumberVisibility(self, visibility)

            Controls how primitive numbers are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only numbers for selected primitives
            are shown.

          * hou.markerVisibility.AroundPointer: Numbers close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
            are shown.


        """
        return _hou.GeometryViewportDisplaySet_setPrimNumberVisibility(self, v)

    def primNumberVisibility(self) -> "HOM_EnumValue &":
        r"""

        primNumberVisibility(self) -> hou.markerVisibility

            Query the visibility setting of primitive numbers.


        """
        return _hou.GeometryViewportDisplaySet_primNumberVisibility(self)

    def setPrimNormalVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPrimNormalVisibility(self, visibility)

            Controls how primitive face normals are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only normals for selected primitives
            are shown.

          * hou.markerVisibility.AroundPointer: Normals close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Normals under the mouse cursor
            are shown.


        """
        return _hou.GeometryViewportDisplaySet_setPrimNormalVisibility(self, v)

    def primNormalVisibility(self) -> "HOM_EnumValue &":
        r"""

        primNormalVisibility(self) -> hou.markerVisibility

            Query the visibility setting of primitive normals.


        """
        return _hou.GeometryViewportDisplaySet_primNormalVisibility(self)

    def setPrimBreakpointVisibility(self, v: "EnumValue") -> "void":
        r"""

        setPrimBreakpointVisibility(self, visibility)

            Controls how primitive breakpoints are shown when displayed.


        """
        return _hou.GeometryViewportDisplaySet_setPrimBreakpointVisibility(self, v)

    def primBreakpointVisibility(self) -> "HOM_EnumValue &":
        r"""

        primBreakpointVisibility(self) -> hou.markerVisibility

            Query the visibility setting of primitive breakpoints.


        """
        return _hou.GeometryViewportDisplaySet_primBreakpointVisibility(self)

    def setVertexMarkerVisibility(self, v: "EnumValue") -> "void":
        r"""

        setVertexMarkerVisibility(self, visibility)

            Controls how vertex markers are shown when displayed.


        """
        return _hou.GeometryViewportDisplaySet_setVertexMarkerVisibility(self, v)

    def vertexMarkerVisibility(self) -> "HOM_EnumValue &":
        r"""

        vertexMarkerVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex markers.


        """
        return _hou.GeometryViewportDisplaySet_vertexMarkerVisibility(self)

    def setVertexNormalVisibility(self, v: "EnumValue") -> "void":
        r"""

        setVertexNormalVisibility(self, visibility)

            Controls how vertex normals are shown when displayed.


        """
        return _hou.GeometryViewportDisplaySet_setVertexNormalVisibility(self, v)

    def vertexNormalVisibility(self) -> "HOM_EnumValue &":
        r"""

        vertexNormalVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex normals.


        """
        return _hou.GeometryViewportDisplaySet_vertexNormalVisibility(self)

    def setVertexNumberVisibility(self, v: "EnumValue") -> "void":
        r"""

        setVertexNumberVisibility(self, visibility)

            Controls how vertex numbers are shown when displayed.


        """
        return _hou.GeometryViewportDisplaySet_setVertexNumberVisibility(self, v)

    def vertexNumberVisibility(self) -> "HOM_EnumValue &":
        r"""

        vertexNumberVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex numbers.


        """
        return _hou.GeometryViewportDisplaySet_vertexNumberVisibility(self)

    def setVertexUVVisibility(self, v: "EnumValue") -> "void":
        r"""

        setVertexUVVisibility(self, visibility)

            Controls how vertex normals are shown when displayed.


        """
        return _hou.GeometryViewportDisplaySet_setVertexUVVisibility(self, v)

    def vertexUVVisibility(self) -> "HOM_EnumValue &":
        r"""

        vertexUVVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex UVs.


        """
        return _hou.GeometryViewportDisplaySet_vertexUVVisibility(self)

    def useGhostedLook(self, b: "bool") -> "void":
        r"""

        useGhostedLook(self, on)

            Make all geometry in the display set appear ghosted - slightly
            translucent. This allows geometry behind the ghosted to seen and de-
            emphasizes the ghosted geometry in the viewport. This is normal used
            to direct focus to other geometry (displayed SOP within an object,
            for example).


        """
        return _hou.GeometryViewportDisplaySet_useGhostedLook(self, b)

    def isUsingGhostedLook(self) -> "bool":
        r"""

        isUsingGhostedLook(self) -> bool

            Query if the display set is ghosted. Ghosted geometry appears
            translucent so that geometry behind it can be easily seen.


        """
        return _hou.GeometryViewportDisplaySet_isUsingGhostedLook(self)

    def useFadedLook(self, b: "bool") -> "void":
        r"""

        useFadedLook(self, on)

            Suppress geometry color (Cd attribute, point, primitive, or vertex)
            on the geometry in the display set.


        """
        return _hou.GeometryViewportDisplaySet_useFadedLook(self, b)

    def isUsingFadedLook(self) -> "bool":
        r"""

        isUsingFadedLook(self) -> bool

            Query if the display set is faded. Faded geometry suppresses the
            display of geometry color.


        """
        return _hou.GeometryViewportDisplaySet_isUsingFadedLook(self)

    def useXRay(self, b: "bool") -> "void":
        r"""

        useXRay(self, on)

            Draw the geometry in the display set as XRay, which draws the
            geometry normally if not occluded, and as a dimmed wireframe where
            occluded by other geometry.


        """
        return _hou.GeometryViewportDisplaySet_useXRay(self, b)

    def isUsingXRay(self) -> "bool":
        r"""

        isUsingXRay(self) -> bool

            Query if the display set is drawn with XRay. XRay geometry will
            appear as a faded wireframe behind other geometry that occludes it.


        """
        return _hou.GeometryViewportDisplaySet_isUsingXRay(self)

    def useLighting(self, b: "bool") -> "void":
        r"""

        useLighting(self, on)

            Enable lighting for the geometry in the display set. This works in
            conjunction with the global lighting mode in the viewport. Both this
            option and the global lighting mode must be set to a lighting mode
            in order to see lighting (ie, enabling Lighting on this display set
            will not cause it to be lit if the global viewport mode is No
            Lighting).


        """
        return _hou.GeometryViewportDisplaySet_useLighting(self, b)

    def isUsingLighting(self) -> "bool":
        r"""

        isUsingLighting(self) -> bool

            Query if lighting is used for this display set. When off, the
            geometry is displayed without any lighting (often much brighter).


        """
        return _hou.GeometryViewportDisplaySet_isUsingLighting(self)

    def useUVMap(self, b: "bool") -> "void":
        r"""

        useUVMap(self, on)

            Use a UV map texture for visualizing UVs when a model has UVs but no
            material assignment.


        """
        return _hou.GeometryViewportDisplaySet_useUVMap(self, b)

    def isUsingUVMap(self) -> "bool":
        r"""

        isUsingUVMap(self) -> bool

            Query if a UV map texture is used for visualizing UVs when a model
            has UVs but no material assignment.


        """
        return _hou.GeometryViewportDisplaySet_isUsingUVMap(self)

    def setShadingModeLocked(self, b: "bool") -> "void":
        r"""

        setShadingModeLocked(self, on)

            Locks the shading mode so that it cannot be changed by the user
            using the Shading Mode menu in the viewport or the wireframe toggle
            hotkey. Passing False unlocks the display set so that it follows the
            viewport's shading mode.


        """
        return _hou.GeometryViewportDisplaySet_setShadingModeLocked(self, b)

    def isShadingModeLocked(self) -> "bool":
        r"""

        isShadingModeLocked(self) -> bool

            Query if the shading mode is locked. When locked, changing the
            shading mode in the viewport will not affect the look of geometry in
            this display set.


        """
        return _hou.GeometryViewportDisplaySet_isShadingModeLocked(self)

    def setToolbarLinked(self, b: "bool") -> "void":
        r"""

        setToolbarLinked(self, on)

            Link the display set's options to the option toggles in the right
            viewport toolbar. When linked, clicking a display option button on
            this toolbar will affect the corresponding option in this display
            set.


        """
        return _hou.GeometryViewportDisplaySet_setToolbarLinked(self, b)

    def isToolbarLinked(self) -> "bool":
        r"""

        isToolbarLinked(self) -> bool

            Query if the display set is linked to the right viewport toolbar.
            When linked, clicking a display option button on this toolbar will
            affect the corresponding option in this display set.


        """
        return _hou.GeometryViewportDisplaySet_isToolbarLinked(self)

    def setUniqueDisplaySet(self, b: "bool") -> "void":
        r"""

        setUniqueDisplaySet(self, on)

            When True, remove any link from this display set to another display
            set. Its own settings will be used. Passing False has no effect; use
            setLinkToDisplaySet to link this set to another display set.


        """
        return _hou.GeometryViewportDisplaySet_setUniqueDisplaySet(self, b)

    def isUniqueDisplaySet(self) -> "bool":
        r"""

        isUniqueDisplaySet(self) -> bool

            A display set can be linked to another display set, so that all of
            its options are taken from that linked set rather than its own. This
            method returns True if the display set is unique, in that it is not
            linked to another display set, and False if the set refers to
            another display set.


        """
        return _hou.GeometryViewportDisplaySet_isUniqueDisplaySet(self)

    def setShadedMode(self, arg2: "EnumValue") -> "void":
        r"""

        setShadedMode(self, shaded_mode)

            Sets the shading mode for this display set:

          * hou.glShadingType.WireBoundingBox: no geometry, only bounding box
            outline

          * hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box

          * hou.glShadingType.Wire: wireframe

          * hou.glShadingType.WireGhost: wireframe with muted hidden lines

          * hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines

          * hou.glShadingType.HiddenLineGhost: wireframe with solid constant
            faces

          * hou.glShadingType.Flat: shaded with primitive face normals

          * hou.glShadingType.FlatWire: shaded with primitive face normals,
            outlined polygons

          * hou.glShadingType.Smooth: shaded with point or vertex normals

          * hou.glShadingType.SmoothWire: shaded with point or vertex normals,
            outlined polygons


        """
        return _hou.GeometryViewportDisplaySet_setShadedMode(self, arg2)

    def shadedMode(self) -> "HOM_EnumValue &":
        r"""

        shadedMode(self) -> hou.glShadingType

            Query the shading mode of the display set (hou.glShadingType):

          * hou.glShadingType.WireBoundingBox: no geometry, only bounding box
            outline

          * hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box

          * hou.glShadingType.Wire: wireframe

          * hou.glShadingType.WireGhost: wireframe with muted hidden lines

          * hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines

          * hou.glShadingType.HiddenLineGhost: wireframe with solid constant
            faces

          * hou.glShadingType.MatCap: shaded with a MatCap texture, ignores
            other lighting and shading.

          * hou.glShadingType.MatCapWire: shaded MatCap texture, outlined
            polygons

          * hou.glShadingType.Flat: shaded with primitive face normals

          * hou.glShadingType.FlatWire: shaded with primitive face normals,
            outlined polygons

          * hou.glShadingType.Smooth: shaded with point or vertex normals

          * hou.glShadingType.SmoothWire: shaded with point or vertex normals,
            outlined polygons


        """
        return _hou.GeometryViewportDisplaySet_shadedMode(self)

    def setBoundaryMode(self, arg2: "EnumValue") -> "void":
        r"""

        setBoundaryMode(self, hou.boundaryDisplay)

            Set the viewport types that highlight 3D boundaries for the geometry
            in the display set.

          * hou.boundaryDisplay.Off:

                No 3D boundaries are displayed.

          * hou.boundaryDisplay.On:

                3D boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                3D boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                3D boundaries are shown in UV viewports only.


        """
        return _hou.GeometryViewportDisplaySet_setBoundaryMode(self, arg2)

    def boundaryMode(self) -> "HOM_EnumValue &":
        r"""

        boundaryMode(self) -> hou.boundaryDisplay

            Query which viewport types display 3D boundaries
            (hou.boundaryDisplay).

          * hou.boundaryDisplay.Off:

                No 3D boundaries are displayed.

          * hou.boundaryDisplay.On:

                3D boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                3D boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                3D boundaries are shown in UV viewports only.


        """
        return _hou.GeometryViewportDisplaySet_boundaryMode(self)

    def setUVBoundaryMode(self, arg2: "EnumValue") -> "void":
        r"""

        setUVBoundaryMode(self, hou.boundaryDisplay)

            Set viewport types that highlight UV boundaries for the geometry in
            the display set.

          * hou.boundaryDisplay.Off:

                No UV boundaries are displayed.

          * hou.boundaryDisplay.On:

                UV boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                UV boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                UV boundaries are shown in UV viewports only.


        """
        return _hou.GeometryViewportDisplaySet_setUVBoundaryMode(self, arg2)

    def uvBoundaryMode(self) -> "HOM_EnumValue &":
        r"""

        uvBoundaryMode(self) -> hou.boundaryDisplay

            Query which viewport types display UV boundaries
            (hou.boundaryDisplay).

          * hou.boundaryDisplay.Off:

                No UV boundaries are displayed.

          * hou.boundaryDisplay.On:

                UV boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                UV boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                UV boundaries are shown in UV viewports only.


        """
        return _hou.GeometryViewportDisplaySet_uvBoundaryMode(self)

    def setLinkToDisplaySet(self, arg2: "EnumValue") -> "void":
        r"""

        setLinkToDisplaySet(self, view_display_set)

            Link this display set to the settings of another display set. This
            display set's option settings are then ignored, and the other sets
            are used in their place. Linking a set to itself restores its own
            settings.

          * hou.displaySetType.SceneObject

          * hou.displaySetType.SelectedObject

          * hou.displaySetType.GhostObject

          * hou.displaySetType.DisplayModel

          * hou.displaySetType.CurrentModel

          * hou.displaySetType.TemplateModel


        """
        return _hou.GeometryViewportDisplaySet_setLinkToDisplaySet(self, arg2)

    def linkedToDisplaySet(self) -> "HOM_EnumValue &":
        r"""

        linkedToDisplaySet(self) -> hou.displaySetType

            A display set can be linked to another display set, so that all of
            its options are taken from that linked set rather than its own. This
            method returns the display set this set is linked to. If it is not
            linked to another set, it will return the its own set.


        """
        return _hou.GeometryViewportDisplaySet_linkedToDisplaySet(self)


# Register GeometryViewportDisplaySet in _hou:
_hou.GeometryViewportDisplaySet_swigregister(GeometryViewportDisplaySet)


class GeometryViewportSettings(object):
    r"""

    hou.GeometryViewportSettings

    A collection of settings controlling a viewport's view of the scene
    (such as the view angle and whether different guides are displayed).
    Many of this object's methods correspond to settings in the Display
    Options dialog.

    OVERVIEW


            To access a viewport, you must first get a reference to a Scene
            Viewer pane tab. See the following methods:


            hou.ui.paneTabOfType
                Use hou.ui.paneTabOfType(hou.paneTabType.SceneViewer) to get
                a reference to a Scene Viewer pane tab in the current pane
                layout. If the current layout has no Scene Viewer pane tab,
                this returns None.

                To be more precise about which viewer you grab in a possible
                multi-viewer layout, see also hou.ui.curDesktop to get a
                hou.Desktop object representing the current pane layout, and
                hou.Desktop.sceneViewers to get a list of scene viewer pane
                tabs in the current layout.

            Once you have a reference to a hou.SceneViewer pane object, you
            can use it to access the viewer pane's viewport or viewports.
            See the following methods:


            hou.SceneViewer.viewports
                Returns a list of the viewports in the viewer pane.

            hou.SceneViewer.findViewport
                Gets a single viewport by name, for example \"Top\".

            hou.SceneViewer.selectedViewport
                Gets the currently selected viewport. The user can select a
                viewport by pressing [Space + N] in the viewport. The view
                menus in the upper right corner are drawn brighter in the
                selected viewport.

        You can then get a GeometryViewportSettings object for the viewport
        by calling hou.GeometryViewport.settings.


        TIP
            Some of the more commonly-used methods, such as setting the view
            to look through a camera, are duplicated on the
            hou.GeometryViewport object for convenience.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometryViewportSettings

    def __repr__(self) -> "std::string":
        return _hou.GeometryViewportSettings___repr__(self)

    def viewportType(self) -> "HOM_EnumValue &":
        r"""

        viewportType(self) -> hou.geometryViewportType enum value

            Query the viewport type (UV, 3D, top, left, etc).


        """
        return _hou.GeometryViewportSettings_viewportType(self)

    def displaySet(self, settype: "EnumValue") -> "HOM_GeometryViewportDisplaySet *":
        r"""

        displaySet(self, display_set) -> hou.GeometryViewportDisplaySet

            Returns the hou.GeometryViewportDisplaySet object associated with
            display_set, which must be a type of hou.displaySetType. A display
            set describes a certain category of displayed geometry (for example,
            templated geometry, or current (selected) geometry). The associated
            GeometryViewportDisplaySet object lets you customize how that
            category of geometry is drawn in the viewport, for example
            wireframe/shaded, showing point numbers, and so on.


        """
        return _hou.GeometryViewportSettings_displaySet(self, settype)

    def viewAspectRatio(self, masked: "bool" = True) -> "float":
        r"""

        viewAspectRatio(self, masked) -> float

            Query the actual viewport aspect ratio. If masked is True, return
            the aspect ratio of the area inside the camera mask, otherwise
            return the full viewport aspect ratio.


        """
        return _hou.GeometryViewportSettings_viewAspectRatio(self, masked)

    def normalScale(self) -> "double":
        return _hou.GeometryViewportSettings_normalScale(self)

    def setNormalScale(self, normal_scale: "double") -> "void":
        r"""

        setNormalScale(self, normal_scale)

            Set a scale factor for the display of normals to increase or
            decrease their length.


        """
        return _hou.GeometryViewportSettings_setNormalScale(self, normal_scale)

    def vectorScale(self) -> "double":
        r"""

        vectorScale(self) -> float

            Query the scale applied to the length of vector decorations.


        """
        return _hou.GeometryViewportSettings_vectorScale(self)

    def setVectorScale(self, vec_scale: "double") -> "void":
        r"""

        setVectorScale(self, scale)

            Set the scale applied to vector decorations, to make them longer or
            shorter.


        """
        return _hou.GeometryViewportSettings_setVectorScale(self, vec_scale)

    def pointMarkerSize(self) -> "double":
        r"""

        pointMarkerSize(self) -> float

            Queries the size of point marker decorations, in pixels.


        """
        return _hou.GeometryViewportSettings_pointMarkerSize(self)

    def setPointMarkerSize(self, psize: "double") -> "void":
        r"""

        setPointMarkerSize(self, point_size)

            Set the size of point marker decorations, in pixels.


        """
        return _hou.GeometryViewportSettings_setPointMarkerSize(self, psize)

    def originGnomonSize(self) -> "double":
        r"""

        originGnomonSize(self) -> float

            Queries the world size of the gnomon axes that appear at the world
            origin.


        """
        return _hou.GeometryViewportSettings_originGnomonSize(self)

    def setOriginGnomonSize(self, size: "double") -> "void":
        r"""

        setOriginGnomonSize(self, size)

            Sets the world size of the gnomon axes that appear at the world
            origin.


        """
        return _hou.GeometryViewportSettings_setOriginGnomonSize(self, size)

    def camera(self) -> "HOM_ObjNode *":
        r"""

        camera(self) -> ObjNode or None

            Return the camera or light node that the viewport is looking
            through. Return None if the viewport is not looking through a camera
            or light node.


        """
        return _hou.GeometryViewportSettings_camera(self)

    def setCamera(self, *args) -> "void":
        r"""

        setCamera(self, camera_node)

            Makes the viewport look through the given camera node.


        """
        return _hou.GeometryViewportSettings_setCamera(self, *args)

    def saveViewToCamera(self, camera_node: "ObjNode") -> "void":
        r"""

        saveViewToCamera(self, camera_node)

            Saves the viewport's current view into the given camera node. It
            does this by setting the camera's transform parameters to match the
            viewport's view transform matrix.


        """
        return _hou.GeometryViewportSettings_saveViewToCamera(self, camera_node)

    def geometryInfo(self, *args) -> "HOM_EnumValue &":
        r"""

        geometryInfo(self, hou.viewportGeometryInfo)

            Queries the current geometry information display setting:

          * hou.viewportGeometryInfo.Off: No information displayed.

          * hou.viewportGeometryInfo.SelectedOnly: only display information if
            something is selected.

          * hou.viewportGeometryInfo.Always: Always display information.


        """
        return _hou.GeometryViewportSettings_geometryInfo(self, *args)

    def handleHighlight(self, *args) -> "HOM_EnumValue &":
        r"""

        handleHighlight(self, hou.viewportHandleHighlight)

            Sets the size of the handle highlight when the mouse is over a
            handle part:

          * hou.viewportHandleHighlight.Off: Handles do not show highlights.

          * hou.viewportHandleHighlight.Small: Handles have a subtle highlight.

          * hou.viewportHandleHighlight.Normal: Handles use their default
            highlight, which is twice the width of the small highlight.


        """
        return _hou.GeometryViewportSettings_handleHighlight(self, *args)

    def closureSelection(self, *args) -> "HOM_EnumValue &":
        r"""

        closureSelection(self, hou.viewportClosureSelection)

            Change the closure selection display setting. A Closure selection is
            shown on a primitive when any part of that primitive is selected.

          * hou.viewportClosureSelection.Hide: Do not show closure selections.

          * hou.viewportClosureSelection.HullPrimitives: Only show closure
            selections on primitives that have hulls which are disconnected from
            the tessellated surface or curve (such as a NURBS surface).

          * hou.viewportClosureSelection.Show: Show closure selections on all
            primitive types.


        """
        return _hou.GeometryViewportSettings_closureSelection(self, *args)

    def guideFontSize(self, *args) -> "HOM_EnumValue &":
        return _hou.GeometryViewportSettings_guideFontSize(self, *args)

    def setOffsetVertexMarkers(self, enable: "bool") -> "void":
        r"""

        setOffsetVertexMarkers(self, enable)

            When enabled, vertex markers and normals are inset into the polygon
            so they can be selected independently when part of a seamless mesh.
            When disabled, the markers and normals are placed at the actual
            vertex, potentially overlapping.


        """
        return _hou.GeometryViewportSettings_setOffsetVertexMarkers(self, enable)

    def offsetVertexMarkers(self) -> "bool":
        r"""

        offsetVertexMarkers(self) -> bool

            When enabled, vertex markers and normals are inset into the polygon
            so they can be selected independently when part of a seamless mesh.
            When disabled, the markers and normals are placed at the actual
            vertex, potentially overlapping.


        """
        return _hou.GeometryViewportSettings_offsetVertexMarkers(self)

    def enableGuide(self, guide: "EnumValue", enabled: "bool") -> "void":
        r"""

        enableGuide(self, guide, on)

            Show or hide a guide. The guide argument must be a type of
            hou.viewportGuide.


        """
        return _hou.GeometryViewportSettings_enableGuide(self, guide, enabled)

    def guideEnabled(self, guide: "EnumValue") -> "bool":
        r"""

        guideEnabled(self, guide) -> bool

            Test if a guide is visible. The guide argument must be a type of
            hou.viewportGuide.


        """
        return _hou.GeometryViewportSettings_guideEnabled(self, guide)

    def levelOfDetail(self, *args) -> "double":
        r"""

        levelOfDetail(self) -> double

            Query the current level of detail used for tessellating geometry.


        """
        return _hou.GeometryViewportSettings_levelOfDetail(self, *args)

    def volumeQuality(self, *args) -> "HOM_EnumValue &":
        r"""

        volumeQuality(self) -> hou.viewportVolumeQuality

            Query the volume display quality.

          * hou.viewportVolumeQuality.VeryLow: Very fast, low quality preview

          * hou.viewportVolumeQuality.Low: Fewer slices than Normal for speed

          * hou.viewportVolumeQuality.Normal: Good quality vs. speed setting.

          * hou.viewportVolumeQuality.High: Large number of slices with
            jittering


        """
        return _hou.GeometryViewportSettings_volumeQuality(self, *args)

    def volumeAmbientShadows(self, *args) -> "double":
        r"""

        volumeAmbientShadows(self) -> double

            Query the default intensity of self-shadowing for fog volumes from
            ambient light sources.


        """
        return _hou.GeometryViewportSettings_volumeAmbientShadows(self, *args)

    def volumeBSplines(self, *args) -> "HOM_EnumValue &":
        r"""

        volumeBSplines(self) -> hou.viewportVolumeBSplines

            Query if higher order interpolation is used by the viewport to draw
            fog volumes.

          * hou.viewportVolumeBSplines.Off: the viewport will never use higher-
            order volume interpolation. This is the fastest to draw, but low
            resolution volumes may appear blocky in the viewport.

          * hou.viewportVolumeBSplines.NonInteractive: the viewport will use the
            higher-order interpolation when not interacting with the viewport.
            This mode falls back to linear interpolation while interacting with
            the viewport to speed up draws.

          * hou.viewportVolumeBSplines.On: the viewport will always use higher-
            order volume interpolation. This is the slowest, highest quality
            option.


            NOTE
                The equivalent setting in the viewport display options can be
                found in the Geometry tab and is labelled Volume Filtering.


        """
        return _hou.GeometryViewportSettings_volumeBSplines(self, *args)

    def volumeWireAsPoints(self, *args) -> "bool":
        r"""

        volumeWireAsPoints(self) -> bool

            Query if volumes are currently drawn as a point field in wireframe.


        """
        return _hou.GeometryViewportSettings_volumeWireAsPoints(self, *args)

    def polygonConvexQuality(self, *args) -> "bool":
        r"""

        polygonConvexQuality(self) -> bool

            Query the polygon convexing quality, true for high quality and false
            for fast convexing.


        """
        return _hou.GeometryViewportSettings_polygonConvexQuality(self, *args)

    def subdivsionLimit(self, *args) -> "int":
        r"""

        subdivsionLimit(self) -> int

            Returns the current subdivision polygon limit, in millions of
            polygons.


        """
        return _hou.GeometryViewportSettings_subdivsionLimit(self, *args)

    def wireWidth(self, *args) -> "double":
        r"""

        wireWidth(self) -> double

            Query the width of lines drawn for wireframe and wire-over-shaded
            modes.


        """
        return _hou.GeometryViewportSettings_wireWidth(self, *args)

    def wireBlend(self, *args) -> "double":
        r"""

        wireBlend(self) -> double

            Query the blend factor between wires and the surface in wire-over-
            shaded modes. Values close to 0 produce very faint lines, values
            closer to 1 produce solid lines.


        """
        return _hou.GeometryViewportSettings_wireBlend(self, *args)

    def interiorWireAlpha(self, *args) -> "double":
        r"""

        interiorWireAlpha(self) -> double

            Query the dimness of the interior wires in a tet mesh. Outer wires
            are drawn normally, inner wires are dimmed. This only affects tet
            meshes in wireframe mode.


        """
        return _hou.GeometryViewportSettings_interiorWireAlpha(self, *args)

    def shadeOpenCurves(self, *args) -> "bool":
        r"""

        shadeOpenCurves(self) -> bool

            Query if shaded open curves are enabled or not.


        """
        return _hou.GeometryViewportSettings_shadeOpenCurves(self, *args)

    def selectWireframeAsSolid(self, *args) -> "bool":
        r"""

        selectWireframeAsSolid(self) -> bool

            Query if selection of wireframe polygons is done by face (true) or
            edge (false).


        """
        return _hou.GeometryViewportSettings_selectWireframeAsSolid(self, *args)

    def setWireOverPackedGeo(self, wire_over_packed: "bool") -> "void":
        r"""

        setWireOverPackedGeo(self, wire_over_packed)

            Show polygon outlines on meshes in packed geometry when drawing a
            wire-over-shaded mode. Disabling this hides the outlines on packed
            geometry, making meshes appear as a single shape, which packed
            geometry technically is.


        """
        return _hou.GeometryViewportSettings_setWireOverPackedGeo(
            self, wire_over_packed
        )

    def wireOverPackedGeo(self) -> "bool":
        r"""

        wireOverPackedGeo(self) -> bool

            Query if polygon outlines are visible on packed geometry when a
            wire-over-shaded mode is active.


        """
        return _hou.GeometryViewportSettings_wireOverPackedGeo(self)

    def particleDisplayType(self, *args) -> "HOM_EnumValue &":
        r"""

        particleDisplayType(self) -> hou.viewportParticleDisplay

            Query the default particle display.

          * hou.viewportParticleDisplay.Points: Constant sized point marker,
            with the diameter specified by particlePointSize. This marker is
            unaffected by pscale.

          * hou.viewportParticleDisplay.Pixels: Single pixel drawn for a
            particle.

          * hou.viewportParticleDisplay.Lines: Streak trail plus marker.

          * hou.viewportParticleDisplay.Discs: World-space circle, affected by
            pscale or discSize.


        """
        return _hou.GeometryViewportSettings_particleDisplayType(self, *args)

    def allowParticleSprites(self, *args) -> "bool":
        r"""

        allowParticleSprites(self) -> bool

            Query if particles are drawn as sprites when sprite attributes are
            detected on the particle (sprite* or shop_materialpath).


        """
        return _hou.GeometryViewportSettings_allowParticleSprites(self, *args)

    def particlePointSize(self, *args) -> "double":
        r"""

        particlePointSize(self) -> double

            Query the point diameter for particles drawn as Points or Lines.


        """
        return _hou.GeometryViewportSettings_particlePointSize(self, *args)

    def particleDiscSize(self, *args) -> "double":
        r"""

        particleDiscSize(self) -> double

            Query the disc diameter for particles drawn as Discs or Sprites if
            the pscale attribute does not exist. This is specified in world-
            space units.


        """
        return _hou.GeometryViewportSettings_particleDiscSize(self, *args)

    def orientDiscToNormal(self, *args) -> "bool":
        r"""

        orientDiscToNormal(self) -> bool

            Queries if discs and sprites are oriented to the normal (true) or
            not. The normal will be orthogonal to the disc (they will face in
            that direction).


        """
        return _hou.GeometryViewportSettings_orientDiscToNormal(self, *args)

    def spriteTextureLimit(self, *args) -> "std::vector< int,std::allocator< int > >":
        r"""

        spriteTextureLimit(self) -> tuple of int

            Query the maximum texture resolution for sprites. This is primarily
            a performance vs. quality trade-off option. Larger sprites look
            better but may cause slowdowns for large particle systems.


        """
        return _hou.GeometryViewportSettings_spriteTextureLimit(self, *args)

    def pointInstancing(self, *args) -> "bool":
        r"""

        pointInstancing(self) -> bool

            Query if point instancing is globally enabled.


        """
        return _hou.GeometryViewportSettings_pointInstancing(self, *args)

    def pointInstancingPercent(self, *args) -> "double":
        r"""

        pointInstancingPercent(self) -> double

            Query the percentage of instances shown in the viewport for point
            instancing.


        """
        return _hou.GeometryViewportSettings_pointInstancingPercent(self, *args)

    def pointInstancingLimit(self, *args) -> "int":
        r"""

        pointInstancingLimit(self) -> int

            Query the current polygon limit for instancing.


        """
        return _hou.GeometryViewportSettings_pointInstancingLimit(self, *args)

    def instanceStandInGeometry(self, *args) -> "HOM_EnumValue &":
        r"""

        instanceStandInGeometry(self) -> hou.viewportStandInGeometry

            Query the current stand-in geometry for culled instances.

          * hou.viewportStandInGeometry.DisplayOff: Show nothing for culled
            instances.

          * hou.viewportStandInGeometry.LocationMarker: Show a location marker
            at the local space origin of each instanced.

          * hou.viewportStandInGeometry.BoundingBox: Show the culled instances'
            bounding boxes.


        """
        return _hou.GeometryViewportSettings_instanceStandInGeometry(self, *args)

    def autoGenerateVertexNormals(self, *args) -> "bool":
        r"""

        autoGenerateVertexNormals(self) -> bool

            Query if vertex normals are produced when geometry is missing
            normals. If false, point numbers are produced.


        """
        return _hou.GeometryViewportSettings_autoGenerateVertexNormals(self, *args)

    def vertexNormalCuspAngle(self, *args) -> "double":
        r"""

        vertexNormalCuspAngle(self) -> double

            Query the cusp angle for vertex normal generation. Any shared edge
            between polygons will be considered a hard edge if the polygon faces
            differ by more than this angle, otherwise the normals will be smooth
            over the edge.


        """
        return _hou.GeometryViewportSettings_vertexNormalCuspAngle(self, *args)

    def vertexNormalLimit(self, *args) -> "int":
        r"""

        vertexNormalLimit(self) -> int

            Query the polygon limit for generating vertex normals, in millions
            of polygons.


        """
        return _hou.GeometryViewportSettings_vertexNormalLimit(self, *args)

    def setSceneAntialias(self, aa: "int") -> "void":
        r"""

        setSceneAntialias(self, aalevel)

            Sets the viewports full-scene antialiasing level to one of 1, 2, 4,
            8, 16, 32, 64, or 128. This represents the number of samples
            rendered to produce a higher quality image. Higher numbers produce
            better antialiasing, but this can affect the viewport's rendering
            performance. Some graphics hardware only support a subset of these
            modes (eg. up to 8 or 32).


        """
        return _hou.GeometryViewportSettings_setSceneAntialias(self, aa)

    def sceneAntialias(self) -> "int":
        r"""

        sceneAntialias(self)

            Returns the number of samples used to antialias the viewport.
            Possible values are 1 (no antialiasing), 2, 4 (default for most
            hardware), 8, 16, 32, 64, or 128.


        """
        return _hou.GeometryViewportSettings_sceneAntialias(self)

    def setHdrRendering(self, hdr: "bool") -> "void":
        r"""

        hdrRendering(self) -> bool

            Queries if High Dynamic Range (HDR) rendering is enabled.


        """
        return _hou.GeometryViewportSettings_setHdrRendering(self, hdr)

    def hdrRendering(self) -> "bool":
        return _hou.GeometryViewportSettings_hdrRendering(self)

    def setXrayDrawing(self, global_enable: "bool") -> "void":
        r"""

        setXrayDrawing(self, global_enable)

            Globally enable or disable X-ray drawing. Object must have their
            X-ray flag set in order to render as X-ray. X-ray causes the object
            to be visible when occluded.


        """
        return _hou.GeometryViewportSettings_setXrayDrawing(self, global_enable)

    def xrayDrawing(self) -> "bool":
        r"""

        xrayDrawing(self) -> bool

            Query if X-ray drawing is enabled globally.


        """
        return _hou.GeometryViewportSettings_xrayDrawing(self)

    def setXrayQuality(self, quality: "bool") -> "void":
        r"""

        setXrayQuality(self, quality)

            Enable high-quality X-ray rendering, which draws X-rayed objects as
            dimmed shaded surfaces when occluded, with up to 8 levels of overlap
            between X-rayed objects. This looks better but takes longer to
            render. Regular X-ray rendering displays X-ray objects as wireframe
            when occluded.


        """
        return _hou.GeometryViewportSettings_setXrayQuality(self, quality)

    def xrayQuality(self) -> "bool":
        r"""

        xrayQuality(self) -> bool

            Queries if high quality X-ray rendering is active.


        """
        return _hou.GeometryViewportSettings_xrayQuality(self)

    def setXrayStrength(self, strength: "double") -> "void":
        r"""

        setXrayStrength(self, strength)

            Sets the strength of the occluded x-ray objects. Lower values make
            occluded X-ray objects dimmer.


        """
        return _hou.GeometryViewportSettings_setXrayStrength(self, strength)

    def xrayStrength(self) -> "double":
        r"""

        xrayStrength(self) -> double

            Query the strength of occluded x-ray objects.


        """
        return _hou.GeometryViewportSettings_xrayStrength(self)

    def setObjectOrigins(self, globel_enable: "bool") -> "void":
        r"""

        setObjectOrigins(self, globel_enable)

            Globally allow object origins to be displayed. Object origins are
            enabled by setting the Origin flag on objects.


        """
        return _hou.GeometryViewportSettings_setObjectOrigins(self, globel_enable)

    def objectOrigins(self) -> "bool":
        r"""

        objectOrigins(self) -> bool

            Query if object origin display is globally enabled.


        """
        return _hou.GeometryViewportSettings_objectOrigins(self)

    def setOnionSkinning(self, global_enable: "bool") -> "void":
        r"""

        setOnionSkinning(self, global_enable)

            Globally allow onion skinning to be displayed. Onion skinning is
            enabled on a per-object basis in the Misc tab of objects. This shows
            animation as a series of ghosted poses at other frames around the
            current frame.


        """
        return _hou.GeometryViewportSettings_setOnionSkinning(self, global_enable)

    def onionSkinning(self) -> "bool":
        r"""

        onionSkinning(self) -> bool

            Query if onion skinning is globally enabled.


        """
        return _hou.GeometryViewportSettings_onionSkinning(self)

    def setOnionSkinFramesBeforeCount(self, num_frames: "int") -> "void":
        r"""

        setOnionSkinFramesBeforeCount(self, num_frames)

            Set the number of onion skins before the current frame. Their
            spacing depends on the onion skin frame increment.


        """
        return _hou.GeometryViewportSettings_setOnionSkinFramesBeforeCount(
            self, num_frames
        )

    def onionSkinFramesBeforeCount(self) -> "int":
        r"""

        onionSkinFramesBeforeCount(self) -> int

            Queries the number of onion skins before the current frame.


        """
        return _hou.GeometryViewportSettings_onionSkinFramesBeforeCount(self)

    def setOnionSkinFramesBeforeTint(self, tint: "Color") -> "void":
        r"""

        setOnionSkinFramesBeforeTint(self, tint)

            Tint all onion skins that appear before the current frame with this
            color.


        """
        return _hou.GeometryViewportSettings_setOnionSkinFramesBeforeTint(self, tint)

    def onionSkinFramesBeforeTint(self) -> "HOM_Color":
        r"""

        onionSkinFramesBeforeTint(self) -> tuple of double

            Query the tint color of skins that appear before the current frame.


        """
        return _hou.GeometryViewportSettings_onionSkinFramesBeforeTint(self)

    def setOnionSkinFramesAfterCount(self, num_frames: "int") -> "void":
        r"""

        setOnionSkinFramesAfterCount(self, num_frames)

            Set the number of onion skins after the current frame. Their spacing
            depends on the onion skin frame increment.


        """
        return _hou.GeometryViewportSettings_setOnionSkinFramesAfterCount(
            self, num_frames
        )

    def onionSkinFramesAfterCount(self) -> "int":
        r"""

        onionSkinFramesAfterCount(self) -> int

            Queries the number of onion skins after the current frame.


        """
        return _hou.GeometryViewportSettings_onionSkinFramesAfterCount(self)

    def setOnionSkinFramesAfterTint(self, tint: "Color") -> "void":
        r"""

        setOnionSkinFramesAfterTint(self, tint)

            Tint all onion skins that appear after the current frame with this
            color.


        """
        return _hou.GeometryViewportSettings_setOnionSkinFramesAfterTint(self, tint)

    def onionSkinFramesAfterTint(self) -> "HOM_Color":
        r"""

        onionSkinFramesAfterTint(self) -> tuple of double

            Query the tint color of skins that appear after the current frame.


        """
        return _hou.GeometryViewportSettings_onionSkinFramesAfterTint(self)

    def setOnionSkinFrameIncrement(self, frame_increment: "int") -> "void":
        r"""

        setOnionSkinFrameIncrement(self, frame_increment)

            Set the frame increment between onion skins. Using 1 will draw every
            frame around the current frame ($F-2 $F-1 $F $F+1 $F+2, while 5
            would step by 5 ($F-10 $F-5 $F $F+5 $F+10).


        """
        return _hou.GeometryViewportSettings_setOnionSkinFrameIncrement(
            self, frame_increment
        )

    def onionSkinFrameIncrement(self) -> "int":
        r"""

        onionSkinFrameIncrement(self) -> int

            Query the frame increment between onion skins.


        """
        return _hou.GeometryViewportSettings_onionSkinFrameIncrement(self)

    def setOnionSkinOpacity(self, opacity: "double") -> "void":
        r"""

        setOnionSkinOpacity(self, opacity)

            Set the opacity of the onion skins to make them more or less
            prominent.


        """
        return _hou.GeometryViewportSettings_setOnionSkinOpacity(self, opacity)

    def onionSkinOpacity(self) -> "double":
        r"""

        onionSkinOpacity(self) -> double

            Query the current onion skin opacity.


        """
        return _hou.GeometryViewportSettings_onionSkinOpacity(self)

    def setSceneGamma(self, gamma: "double") -> "void":
        r"""

        setSceneGamma(self, gamma)

            Set the gamma correction for the scene. This value should match the
            calibrated gamma of the display device.


        """
        return _hou.GeometryViewportSettings_setSceneGamma(self, gamma)

    def sceneGamma(self) -> "double":
        r"""

        sceneGamma(self) -> double

            Query the scene gamma correction.


        """
        return _hou.GeometryViewportSettings_sceneGamma(self)

    def setUseSceneLUT(self, enable: "bool") -> "void":
        r"""

        setUseSceneLUT(self, enable)

            Enable Lookup Table (LUT) color correction. A valid LUT file must
            also be present.


        """
        return _hou.GeometryViewportSettings_setUseSceneLUT(self, enable)

    def useSceneLUT(self) -> "bool":
        r"""

        useSceneLUT(self) -> bool

            Query if Lookup Table color correction is enabled. This will return
            True even no LUT file exists.


        """
        return _hou.GeometryViewportSettings_useSceneLUT(self)

    def setSceneLUT(self, lut_file: "std::string") -> "void":
        r"""

        setSceneLUT(self, lut_file)

            Specify a Lookup Table (LUT) file to use for color correction.


        """
        return _hou.GeometryViewportSettings_setSceneLUT(self, lut_file)

    def sceneLUT(self) -> "std::string":
        r"""

        sceneLUT(self) -> str

            Query the current Lookup Table (LUT) file.


        """
        return _hou.GeometryViewportSettings_sceneLUT(self)

    def setBackgroundImageGammaLUT(self, apply_to_bg: "bool") -> "void":
        r"""

        setBackgroundImageGammaLUT(self, apply_to_bg)

            Apply gamma and Lookup Table (LUT) color correction to the
            background image.


        """
        return _hou.GeometryViewportSettings_setBackgroundImageGammaLUT(
            self, apply_to_bg
        )

    def backgroundImageGammaLUT(self) -> "bool":
        r"""

        backgroundImageGammaLUT(self) -> bool

            Query if color correction is applied to the background image.


        """
        return _hou.GeometryViewportSettings_backgroundImageGammaLUT(self)

    def setDepthOfField(self, enable: "bool") -> "void":
        r"""

        setDepthOfField(self, enable)

            Enable depth of field effect (also requires the viewport look
            through a camera with a non-zero fstop).


        """
        return _hou.GeometryViewportSettings_setDepthOfField(self, enable)

    def getDepthOfField(self) -> "bool":
        r"""

        getDepthOfField(self) -> bool

            Query if the Depth of Field setting is enabled.


        """
        return _hou.GeometryViewportSettings_getDepthOfField(self)

    def setDepthOfFieldBokeh(self, viewportDOFBokeh: "EnumValue") -> "void":
        r"""

        setDepthOfFieldBokeh(self, viewportDOFBokeh)

            Set the bokeh effect.

          * hou.viewportDOFBokeh.NoBokeh:

                No additional bokeh effect.

          * hou.viewportDOFBokeh.Circular:

                Circular bokeh (can also be oval if the aspect is adjusted).

          * hou.viewportDOFBokeh.Texture:

                Use a texture, either from a image file or COP (using the op:
                syntax).


        """
        return _hou.GeometryViewportSettings_setDepthOfFieldBokeh(
            self, viewportDOFBokeh
        )

    def getDepthOfFieldBokeh(self) -> "HOM_EnumValue &":
        r"""

        getDepthOfFieldBokeh(self) -> hou.EnumValue

            Query the current bokeh effect state.


        """
        return _hou.GeometryViewportSettings_getDepthOfFieldBokeh(self)

    def setDepthOfFieldBokehTexture(self, file_or_node: "std::string") -> "void":
        r"""

        setDepthOfFieldBokehTexture(self, file_or_node)

            Set the path to an image file or COP node to use as the bokeh shape.
            COP references use the op: syntax.


        """
        return _hou.GeometryViewportSettings_setDepthOfFieldBokehTexture(
            self, file_or_node
        )

    def getDepthOfFieldBokehTexture(self) -> "std::string":
        r"""

        getDepthOfFieldBokehTexture(self) -> str

            Return the file or COP path of the bokeh shape.


        """
        return _hou.GeometryViewportSettings_getDepthOfFieldBokehTexture(self)

    def setDepthOfFieldBokehBoost(self, boost: "double") -> "void":
        r"""

        setDepthOfFieldBokehBoost(self, boost)

            Boost the brightness of the image to produce more more and brighter
            bokeh shapes.


        """
        return _hou.GeometryViewportSettings_setDepthOfFieldBokehBoost(self, boost)

    def getDepthOfFieldBokehBoost(self) -> "double":
        r"""

        getDepthOfFieldBokehBoost(self) -> float

            Query the current bokeh boost.


        """
        return _hou.GeometryViewportSettings_getDepthOfFieldBokehBoost(self)

    def setDepthOfFieldBokehAspect(self, aspect: "double") -> "void":
        r"""

        setDepthOfFieldBokehAspect(self, aspect)

            Set the aspect ratio (width/height) of the bokeh shape.


        """
        return _hou.GeometryViewportSettings_setDepthOfFieldBokehAspect(self, aspect)

    def getDepthOfFieldBokehAspect(self) -> "double":
        r"""

        getDepthOfFieldBokehAspect(self) -> float

            Query the current bokeh aspect ratio.


        """
        return _hou.GeometryViewportSettings_getDepthOfFieldBokehAspect(self)

    def showsName(self, show: "bool") -> "void":
        r"""

        showsName(self, show)

            Display the viewport name and menu in the upper right corner.


        """
        return _hou.GeometryViewportSettings_showsName(self, show)

    def showName(self) -> "bool":
        r"""

        showName(self) -> bool

            Query if the viewport name menu is displayed.


        """
        return _hou.GeometryViewportSettings_showName(self)

    def showsCameraName(self, show: "bool") -> "void":
        r"""

        showsCameraName(self, show)

            Display the camera name and menu in the upper right corner.


        """
        return _hou.GeometryViewportSettings_showsCameraName(self, show)

    def showCameraName(self) -> "bool":
        r"""

        showCameraName(self) -> bool

            Query if the camera name menu is displayed.


        """
        return _hou.GeometryViewportSettings_showCameraName(self)

    def showsStateStatus(self, show: "bool") -> "void":
        r"""

        showsStateStatus(self, show)

            Display any status messages of the current tool.


        """
        return _hou.GeometryViewportSettings_showsStateStatus(self, show)

    def showStateStatus(self) -> "bool":
        r"""

        showStateStatus(self) -> bool

            Query if the tool status messages are displayed.


        """
        return _hou.GeometryViewportSettings_showStateStatus(self)

    def showsBadges(self, show: "bool") -> "void":
        r"""

        showsBadges(self, show)

            Display viewport status badges as icons beside the camera menu,
            which presents additional state information.


        """
        return _hou.GeometryViewportSettings_showsBadges(self, show)

    def showBadges(self) -> "bool":
        r"""

        showBadges(self) -> bool

            Query if viewport status badges are displayed. Badges are icons
            which present additional state information.


        """
        return _hou.GeometryViewportSettings_showBadges(self)

    def useAspectRatio(self, enable: "bool") -> "void":
        r"""

        useAspectRatio(self, enable)

            Enforce a specific aspect ratio for the viewport, which will add
            bars if the viewport aspect ratio does not match.


        """
        return _hou.GeometryViewportSettings_useAspectRatio(self, enable)

    def usingAspectRatio(self) -> "bool":
        r"""

        usingAspectRatio(self) -> bool

            Query if a specific aspect ratio is being enforced.


        """
        return _hou.GeometryViewportSettings_usingAspectRatio(self)

    def setAspectRatio(self, aspect: "double") -> "void":
        r"""

        setAspectRatio(self, aspect)

            Set the viewport aspect ratio (width/height).


        """
        return _hou.GeometryViewportSettings_setAspectRatio(self, aspect)

    def aspectRatio(self) -> "double":
        r"""

        aspectRatio(self) -> float

            Query the viewport aspect ratio display option. Use
            viewAspectRatio() to query the current viewport aspect ratio.


        """
        return _hou.GeometryViewportSettings_aspectRatio(self)

    def setViewMaskOpacity(self, opacity: "double") -> "void":
        r"""

        setViewMaskOpacity(self, opacity)

            Set the opacity of the bars used to mask areas out the viewport
            outside the aspect ratio.


        """
        return _hou.GeometryViewportSettings_setViewMaskOpacity(self, opacity)

    def viewMaskOpacity(self) -> "double":
        r"""

        viewMaskOpacity(self) -> float

            Query the opacity of the bars used to mask areas out the viewport
            outside the aspect ratio.


        """
        return _hou.GeometryViewportSettings_viewMaskOpacity(self)

    def setStereoMode(self, viewportStereoMode: "EnumValue") -> "void":
        r"""

        setStereoMode(self, viewportStereoMode)

            Set the stereo display mode when viewing through a stereo camera.

          * hou.viewportStereoMode.Anaglyph:

                Anaglyph display of left/right as red/cyan.

          * hou.viewportStereoMode.HorizontalInterlace:

                Interlace left and right on alternating scanlines. Only useful
                for 3D monitors which support this.

          * hou.viewportStereoMode.HorizontalInterlaceReverse:

                Interlace left and right on alternating scanlines, swapping
                which scanlines are used for left and right.

          * hou.viewportStereoMode.QuadBufferGL:

                Use OpenGL quad buffer stereo, generally only available on
                professional cards.


        """
        return _hou.GeometryViewportSettings_setStereoMode(self, viewportStereoMode)

    def stereoMode(self) -> "HOM_EnumValue &":
        r"""

        stereoMode(self) -> hou.viewportStereoMode

            Query the current stereo display mode.


        """
        return _hou.GeometryViewportSettings_stereoMode(self)

    def setHomeAutoAdjustsClip(self, viewportHomeClipMode: "EnumValue") -> "void":
        r"""

        setHomeAutoAdjustsClip(self, viewportHomeClipMode)

            Set which camera clip planes are adjusted when performing a homing
            operation.

          * hou.viewportHomeClipMode.Neither:

                Neither clip plane is adjusted.

          * hou.viewportHomeClipMode.FarOnly:

                Only the far clip plane is adjusted.

          * hou.viewportHomeClipMode.NearOnly:

                Only the near clip plane is adjusted.

          * hou.viewportHomeClipMode.NearAndFar:

                Both clip planes are adjusted.


        """
        return _hou.GeometryViewportSettings_setHomeAutoAdjustsClip(
            self, viewportHomeClipMode
        )

    def homeAutoAdjustClip(self) -> "HOM_EnumValue &":
        r"""

        homeAutoAdjustClip(self) -> hou.viewportHomeClipMode

            Queries which camera clip planes are adjusted when performing a
            homing operation.


        """
        return _hou.GeometryViewportSettings_homeAutoAdjustClip(self)

    def setClipPlanes(self, clip: "_DoubleTuple") -> "void":
        r"""

        setClipPlanes(self, clip)

            Set the near and far camera clip planes from a 2-tuple.


        """
        return _hou.GeometryViewportSettings_setClipPlanes(self, clip)

    def clipPlanes(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        clipPlanes(self) -> tuple of float

            Query the near and far camera clip planes, returning them in a
            2-tuple.


        """
        return _hou.GeometryViewportSettings_clipPlanes(self)

    def setMinHomeSize(self, min_size: "double") -> "void":
        r"""

        setMinHomeSize(self, min_size)

            Set the smallest area that viewport can home to, in world units.


        """
        return _hou.GeometryViewportSettings_setMinHomeSize(self, min_size)

    def minHomeSize(self) -> "double":
        r"""

        minHomeSize(self) -> float

            Query the smallest area that viewport can home to, in world units.


        """
        return _hou.GeometryViewportSettings_minHomeSize(self)

    def setUVDisplayAttribute(self, uv: "std::string const &") -> "void":
        return _hou.GeometryViewportSettings_setUVDisplayAttribute(self, uv)

    def uvDisplayAttribute(self) -> "std::string":
        r"""

        uvDisplayAttribute(self) -> str

            Return the attribute currently displayed in the UV viewport.


        """
        return _hou.GeometryViewportSettings_uvDisplayAttribute(self)

    def setUVAutoAttribute(self, detect: "bool") -> "void":
        return _hou.GeometryViewportSettings_setUVAutoAttribute(self, detect)

    def uvAutoAttribute(self) -> "bool":
        r"""

        uvAutoAttribute(self) -> bool

            Return True if the UV viewport is auto-detecting the class of the
            displayed UV attribute.


        """
        return _hou.GeometryViewportSettings_uvAutoAttribute(self)

    def setUVVertexType(self, is_vertex_uv: "bool") -> "void":
        return _hou.GeometryViewportSettings_setUVVertexType(self, is_vertex_uv)

    def uvVertexType(self) -> "bool":
        r"""

        uvVertexType(self) -> bool

            Return the class of the UV attribute, Point or Vertex. This returns
            the viewport setting, and not the detected class of the current UV
            attribute. If uvAutoAttribute is enabled, the class will be the same
            as the currently displayed attribute, but if it is disabled it may
            be different.


        """
        return _hou.GeometryViewportSettings_uvVertexType(self)

    def setUVMapTexture(self, uv_file: "std::string const &") -> "void":
        r"""

        setUVMapTexture(self, uv)

            Set the file path of the texture map used to visualize UVs when
            geometry has a UV attribute but no material assigned.


        """
        return _hou.GeometryViewportSettings_setUVMapTexture(self, uv_file)

    def uvMapTexture(self) -> "std::string":
        r"""

        uvMapTexture(self) -> str

            Return the file path of the texture map used to visualize UVs when
            geometry has a UV attribute but no material assigned.


        """
        return _hou.GeometryViewportSettings_uvMapTexture(self)

    def setUVMapScale(self, uv_scale: "double") -> "void":
        r"""

        setUVMapScale(self, scale)

            Set the UV scaling factor for the UV Map when visualizing UVs. It
            defaults to 1.


        """
        return _hou.GeometryViewportSettings_setUVMapScale(self, uv_scale)

    def uvMapScale(self) -> "double":
        r"""

        uvMapScale(self) -> float

            Returns the UV scaling factor for the UV Map when visualizing UVs.


        """
        return _hou.GeometryViewportSettings_uvMapScale(self)

    def setLighting(self, viewportLighting: "EnumValue") -> "void":
        r"""

        setLighting(self, viewportLighting)

            Set the global lighting mode for all viewports.

          * hou.viewportLighting.Off:

                No lighting, constant shaded.

          * hou.viewportLighting.Headlight:

                Basic lighting from a single directional light defined in the
                display options.

          * hou.viewportLighting.Normal:

                Good quality lighting from up to 10 basic lights (area lights
                modeled as point lights, limited environment lights).

          * hou.viewportLighting.HighQuality:

                High quality lighting from an unlimited number of lights
                including area, geometry, environment and ambient occlusion.

          * hou.viewportLighting.HighQualityWithShadows:

                High quality lighting with shadows.


        """
        return _hou.GeometryViewportSettings_setLighting(self, viewportLighting)

    def lighting(self) -> "HOM_EnumValue &":
        r"""

        lighting(self) -> hou.viewportLighting

            Query the current global lighting mode.


        """
        return _hou.GeometryViewportSettings_lighting(self)

    def showDiffuse(self, enable: "bool") -> "void":
        r"""

        showDiffuse(self, enable)

            Enable diffuse contribution of lighting. When disabled, diffuse will
            not contribute to the final lit color. This can be used to debug
            lighting.


        """
        return _hou.GeometryViewportSettings_showDiffuse(self, enable)

    def showingDiffuse(self) -> "bool":
        r"""

        showingDiffuse(self) -> bool

            Query if diffuse lighting is enabled.


        """
        return _hou.GeometryViewportSettings_showingDiffuse(self)

    def showSpecular(self, enable: "bool") -> "void":
        r"""

        showSpecular(self, enable)

            Enable specular highlights. When disabled, specular will not
            contribute to the final lit color. This will also disable most
            reflections. This can be used to debug lighting.


        """
        return _hou.GeometryViewportSettings_showSpecular(self, enable)

    def showingSpecular(self) -> "bool":
        r"""

        showingSpecular(self) -> bool

            Query if specular lighting is enabled.


        """
        return _hou.GeometryViewportSettings_showingSpecular(self)

    def showAmbient(self, enable: "bool") -> "void":
        r"""

        showAmbient(self, enable)

            Enable ambient lighting. When disabled, all ambient lights will not
            contribute to the final lit color. This can be used to debug
            lighting.


        """
        return _hou.GeometryViewportSettings_showAmbient(self, enable)

    def showingAmbient(self) -> "bool":
        r"""

        showingAmbient(self) -> bool

            Query if ambient lighting is enabled.


        """
        return _hou.GeometryViewportSettings_showingAmbient(self)

    def showEmission(self, enable: "bool") -> "void":
        r"""

        showEmission(self, enable)

            Enable emissive lighting. Emission lighting comes from materials on
            geometry, not lights, so modifying the lights in the scene has no
            effect on it. This can be used to debug lighting.


        """
        return _hou.GeometryViewportSettings_showEmission(self, enable)

    def showingEmission(self) -> "bool":
        r"""

        showingEmission(self) -> bool

            Query if emission lighting is enabled.


        """
        return _hou.GeometryViewportSettings_showingEmission(self)

    def setLightSampling(self, num_samples: "int") -> "void":
        r"""

        setLightSampling(self, num_samples)

            Set the number of lighting samples to perform when doing high
            quality lighting for area and environment lights.


        """
        return _hou.GeometryViewportSettings_setLightSampling(self, num_samples)

    def lightSampling(self) -> "int":
        r"""

        lightSampling(self) -> int

            Query the number of lighting samples.


        """
        return _hou.GeometryViewportSettings_lightSampling(self)

    def setMaxLightSamples(self, samples: "int") -> "void":
        r"""

        setMaxLightSamples(self, samples)

            Set the maximum number of light samples to use, across all lights.
            If there are more lights than samples, at least 1 sample will be
            used for each light. Setting this to zero removes the limit and each
            light will use up to the number of samples defined by the Light
            Sampling display option. Not all lights use multiple samples.


        """
        return _hou.GeometryViewportSettings_setMaxLightSamples(self, samples)

    def maxLightSamples(self) -> "int":
        r"""

        maxLightSamples(self) -> int

            Return the maximum light samples, or zero if there is no limit.


        """
        return _hou.GeometryViewportSettings_maxLightSamples(self)

    def setLightLimit(self, limit: "int") -> "void":
        r"""

        setLightLimit(self, limit)

            Set the maximum number of lights to contribute to lighting in HQ
            Lighting. The brightest lights are taken first. Setting this to zero
            disables the limit.


        """
        return _hou.GeometryViewportSettings_setLightLimit(self, limit)

    def getLightLimit(self) -> "int":
        r"""

        getLightLimit(self) -> int

            Return the maximum number of lights to use in HQ Lighting, or zero
            if there is no light limit.


        """
        return _hou.GeometryViewportSettings_getLightLimit(self)

    def setHeadlightIntensity(self, intensity: "double") -> "void":
        r"""

        setHeadlightIntensity(self, intensity)

            Set the intensity of the headlight used in Headlight lighting mode.


        """
        return _hou.GeometryViewportSettings_setHeadlightIntensity(self, intensity)

    def headlightIntensity(self) -> "double":
        r"""

        headlightIntensity(self) -> double

            Query the intensity of the headlight.


        """
        return _hou.GeometryViewportSettings_headlightIntensity(self)

    def setHeadlightDirection(self, dir: "_DoubleTuple") -> "void":
        r"""

        setHeadlightDirection(self, dir)

            Set the direction of the headlight used in Headlight lighting mode.
            This is expressed as a direction vector in camera space (the camera
            looks down -Z).


        """
        return _hou.GeometryViewportSettings_setHeadlightDirection(self, dir)

    def headlightDirection(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        headlightDirection(self) -> tuple of double

            Query the vector direction of the headlight.


        """
        return _hou.GeometryViewportSettings_headlightDirection(self)

    def setHeadlightSpecular(self, enable: "bool") -> "void":
        r"""

        setHeadlightSpecular(self, enable)

            Enable specular reflections when in Headlight lighting mode. Turning
            this off results in purely diffuse lighting.


        """
        return _hou.GeometryViewportSettings_setHeadlightSpecular(self, enable)

    def headlightSpecular(self) -> "bool":
        r"""

        headlightSpecular(self) -> bool

            Query if specular reflections are generated by the headlight.


        """
        return _hou.GeometryViewportSettings_headlightSpecular(self)

    def setHeadlightOcclusion(self, enable: "bool") -> "void":
        r"""

        setHeadlightOcclusion(self, enable)

            Enables ambient occlusion when in headlight mode. This has no effect
            if a lighting mode other than headlight is active.


        """
        return _hou.GeometryViewportSettings_setHeadlightOcclusion(self, enable)

    def headlightOcclusion(self) -> "bool":
        r"""

        headlightOcclusion(self) -> bool

            Query if ambient occlusion is active for headlight mode.


        """
        return _hou.GeometryViewportSettings_headlightOcclusion(self)

    def setAmbientOcclusion(self, enable: "bool") -> "void":
        r"""

        setAmbientOcclusion(self, enable)

            Enable an ambient occlusion pass in high quality lighting modes.
            This generates local occlusion shadows.


        """
        return _hou.GeometryViewportSettings_setAmbientOcclusion(self, enable)

    def ambientOcclusion(self) -> "bool":
        r"""

        ambientOcclusion(self) -> bool

            Query if ambient occlusion is enabled. This can return true even if
            not in a high quality mode as this queries the raw display option
            value, not a reflection of whether the pass is active. If querying
            it the pass is active, the lighting mode should also be checked.


        """
        return _hou.GeometryViewportSettings_ambientOcclusion(self)

    def setAmbientOcclusionLevel(self, level: "int") -> "void":
        r"""

        setAmbientOcclusionLevel(self, level)

            Set the level of occlusion to generate, from 1-4. Higher levels
            produce a larger area of effect, while lower values produce fine
            detail.


        """
        return _hou.GeometryViewportSettings_setAmbientOcclusionLevel(self, level)

    def ambientOcclusionLevel(self) -> "int":
        r"""

        ambientOcclusionLevel(self) -> int

            Return the current occlusion level for ambient occlusion.


        """
        return _hou.GeometryViewportSettings_ambientOcclusionLevel(self)

    def setShadowQuality(self, viewportShadowQuality: "EnumValue") -> "void":
        r"""

        setShadowQuality(self, viewportShadowQuality)

            Set the quality of shadow sampling in High Quality Lighting with
            Shadows lighting mode.

          * hou.viewportShadowQuality.Point:

                Area lights are treated as point lights when generating and
                sampling shadow maps. This is the fastest option.

          * hou.viewportShadowQuality.PointAA:

                Do some antialiasing of shadow edges. Treat area lights as point
                lights when generating and sampling shadow maps.

          * hou.viewportShadowQuality.Area:

                Area lights generate multiple shadow maps which are sampled to
                generate an approximation of a blurred shadow from an area
                source.

          * hou.viewportShadowQuality.AreaAA:

                Area lights generate multiple maps and antialias the shadow
                lookups.


        """
        return _hou.GeometryViewportSettings_setShadowQuality(
            self, viewportShadowQuality
        )

    def shadowQuality(self) -> "HOM_EnumValue &":
        r"""

        shadowQuality(self) -> hou.viewportShadowQuality

            Query the current shadow quality.


        """
        return _hou.GeometryViewportSettings_shadowQuality(self)

    def setShadowSensitivity(self, offset: "_IntTuple") -> "void":
        r"""

        setShadowSensitivity(self, offset)

            Set the shadow bias to avoid self-shadowing. A 2-tuple is expected,
            with the first value setting the variable offset (depending on how
            parallel the surface is to the view direction) and the second a
            constant offset. Generally these don't need to be changed from their
            default, but larger values reduce self shadowing but increase the
            risk of missing shadows for very close geometry.


        """
        return _hou.GeometryViewportSettings_setShadowSensitivity(self, offset)

    def shadowSensitivity(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        shadowSensitivity(self) -> tuple of int

            Query the variable and constant shadow offsets, returned in a
            2-tuple.


        """
        return _hou.GeometryViewportSettings_shadowSensitivity(self)

    def setShadowMapSize(self, size: "int") -> "void":
        r"""

        setShadowMapSize(self, size)

            Set the maximum shadow map size, in pixels. Larger maps will produce
            sharper shadows but increase memory usage. Shadow maps are always
            square.


        """
        return _hou.GeometryViewportSettings_setShadowMapSize(self, size)

    def shadowMapSize(self) -> "int":
        r"""

        shadowMapSize(self) -> int

            Query the maximum size of the shadow maps used by High Quality
            Lighting with Shadows lighting mode.


        """
        return _hou.GeometryViewportSettings_shadowMapSize(self)

    def setShadowMapSizeFromLight(self, enable: "bool") -> "void":
        r"""

        setShadowMapSizeFromLight(self, enable)

            Set whether to use the shadow map size specified by the Shadow Map
            size parameter in the light object (clamped to the maximum size
            specified in the display options) or always use the maximum size.


        """
        return _hou.GeometryViewportSettings_setShadowMapSizeFromLight(self, enable)

    def shadowMapSizeFromLight(self) -> "bool":
        r"""

        shadowMapSizeFromLight(self) -> bool

            Query if the shadow map size is defined by the light object.


        """
        return _hou.GeometryViewportSettings_shadowMapSizeFromLight(self)

    def setShadowMapMem(self, mem_in_mb: "int") -> "void":
        r"""

        setShadowMapMem(self, mem_in_mb)

            Set the amount of VRAM to use for all shadowmaps, in MiB.


        """
        return _hou.GeometryViewportSettings_setShadowMapMem(self, mem_in_mb)

    def getShadowMapMem(self) -> "int":
        r"""

        getShadowMapMem(self) -> int

            Query the amount of VRAM used for shadowmaps, in MiB.


        """
        return _hou.GeometryViewportSettings_getShadowMapMem(self)

    def setShadowMapTime(self, time_in_sec: "double") -> "void":
        r"""

        setShadowMapTime(self, time_in_sec)

            Set the time limit for generating shadowmaps in one redraw (in
            seconds). If more shadowmaps are left to generate, cause another
            redraw (and so on until all are complete).


        """
        return _hou.GeometryViewportSettings_setShadowMapTime(self, time_in_sec)

    def getShadowMapTime(self) -> "double":
        r"""

        getShadowMapTime(self) -> int

            Return the time limit for generating shadowmaps within one redraw,
            in seconds.


        """
        return _hou.GeometryViewportSettings_getShadowMapTime(self)

    def useReflections(self, enable: "bool") -> "void":
        r"""

        useReflections(self, enable)

            Enable reflection mapping. Objects with reflective materials
            generate reflection maps of the scene around them, which can be
            quite expensive.


        """
        return _hou.GeometryViewportSettings_useReflections(self, enable)

    def usingReflections(self) -> "bool":
        r"""

        usingReflections(self) -> bool

            Query if reflection mapping is enabled.


        """
        return _hou.GeometryViewportSettings_usingReflections(self)

    def setHdrReflections(self, hdr_reflect: "bool") -> "void":
        r"""

        setHdrReflections(self, hdr_reflect)

            Enable High Dynamic Range (HDR) color buffers for the generated
            scene cubemap, which allows for higher contrast and bright spots in
            reflections.


        """
        return _hou.GeometryViewportSettings_setHdrReflections(self, hdr_reflect)

    def hdrReflections(self) -> "bool":
        r"""

        hdrReflections(self) -> bool

            Query if High Dynamic Range (HDR) color buffers are use for the
            scene cubemap.


        """
        return _hou.GeometryViewportSettings_hdrReflections(self)

    def setReflectMapSize(self, size: "int") -> "void":
        r"""

        setReflectMapSize(self, size)

            Set the size of the cubemap used to store the surrounding scene as
            an environment map. Larger cubemaps produce sharper reflections but
            increase memory use.


        """
        return _hou.GeometryViewportSettings_setReflectMapSize(self, size)

    def reflectMapSize(self) -> "int":
        r"""

        reflectMapSize(self) -> int

            Query the size of reflection cubemaps.


        """
        return _hou.GeometryViewportSettings_reflectMapSize(self)

    def setMinReflectAmount(self, min_reflect: "double") -> "void":
        r"""

        setMinReflectAmount(self, min_reflect)

            Set the minimum level of reflection required for a reflection
            cubemap to be generated for an object. This is based on the largest
            reflective value from all the materials assigned to the object. The
            larger this value, the more reflective an object must be to generate
            a reflection maps. A value of zero is not recommended, as all
            objects will generate a reflection map.


        """
        return _hou.GeometryViewportSettings_setMinReflectAmount(self, min_reflect)

    def minReflectAmount(self) -> "double":
        r"""

        minReflectAmount(self) -> double

            Query the minimum reflection level required for a cubemap to be
            generated for an object.


        """
        return _hou.GeometryViewportSettings_minReflectAmount(self)

    def setFastInteractiveSampling(self, fast: "bool") -> "void":
        r"""

        setFastInteractiveSampling(self, fast)

            When enabled, drops the number of samples used in HQ Lighting to
            improve performance when interacting with the viewer, which includes
            tumbling, moving handles, or playing the timeline. This may result
            in slightly different lighting while interacting with the viewer.


        """
        return _hou.GeometryViewportSettings_setFastInteractiveSampling(self, fast)

    def fastInteractiveSampling(self) -> "bool":
        r"""

        fastInteractiveSampling(self) -> bool

            Query if Fast Interactive Sampling is enabled on the viewer. This
            drops the number of samples used in HQ Lighting to improve
            performance when interacting with the viewer.


        """
        return _hou.GeometryViewportSettings_fastInteractiveSampling(self)

    def showMaterials(self, enable: "bool") -> "void":
        r"""

        showMaterials(self, enable)

            Enable materials on geometry from SHOPs or VOPs. When disabled,
            these material assignments are ignored and only the attributes on
            the geometry will affect shading.


        """
        return _hou.GeometryViewportSettings_showMaterials(self, enable)

    def showingMaterials(self) -> "bool":
        r"""

        showingMaterials(self) -> bool

            Query if materials are shown.


        """
        return _hou.GeometryViewportSettings_showingMaterials(self)

    def showGeometryColor(self, enable: "bool") -> "void":
        r"""

        showGeometryColor(self, enable)

            Enable contribution of the geometry Cd attribute to the material.
            When disabled, this is ignored. Cd multiplies both the material
            diffuse and ambient colors.


        """
        return _hou.GeometryViewportSettings_showGeometryColor(self, enable)

    def showingGeometryColor(self) -> "bool":
        r"""

        showingGeometryColor(self) -> bool

            Query if geometry Cd contributes to the material.


        """
        return _hou.GeometryViewportSettings_showingGeometryColor(self)

    def useTransparency(self, enable: "bool") -> "void":
        r"""

        useTransparency(self, enable)

            Enable transparency rendering. When transparency is enabled, another
            pass handles areas of the geometry that have Alpha less than one
            (either due to an Alpha attribute or material opacity). When
            disabled, alpha is ignored and rendered as opaque.


        """
        return _hou.GeometryViewportSettings_useTransparency(self, enable)

    def usingTransparency(self) -> "bool":
        r"""

        usingTransparency(self) -> bool

            Query if transparency rendering is enabled.


        """
        return _hou.GeometryViewportSettings_usingTransparency(self)

    def setTransparencyQuality(self, viewportTransparency: "EnumValue") -> "void":
        r"""

        setTransparencyQuality(self, viewportTransparency)

            Set the quality of the transparency pass performed by the viewport.

          * hou.viewportTransparency.Cutout:

                Fast test to render the transparent pixel as opaque (>0) or to
                discard it (0). This can be used for texture cards such as
                leaves. This doesn't require an additional pass for
                transparency.

          * hou.viewportTransparency.Low:

                Render transparent pixels in a separate pass. Only the front-
                most transparent pixel is rendered.

          * hou.viewportTransparency.Medium:

                Render transparent pixels in an Order-Independent buffer of 8
                samples, which is then sorted and composited together to do
                multi-layer transparency for up to 8 layers of overlapping
                transparency.

          * hou.viewportTransparency.High:

                Render transparent pixels in an Order-Independent buffer of 16
                samples, which is then sorted and composited together to do
                multi-layer transparency for up to 16 layers of overlapping
                transparency.


        """
        return _hou.GeometryViewportSettings_setTransparencyQuality(
            self, viewportTransparency
        )

    def transparencyQuality(self) -> "HOM_EnumValue &":
        r"""

        transparencyQuality(self) -> hou.viewportTransparency

            Query the transparency quality.


        """
        return _hou.GeometryViewportSettings_transparencyQuality(self)

    def useDisplacement(self, enable: "bool") -> "void":
        r"""

        useDisplacement(self, enable)

            Enable displacement mapping for materials that have a displacement
            map. When disabled, the displacement map is ignored. This can have a
            significant hit for lower-end GPUs.


        """
        return _hou.GeometryViewportSettings_useDisplacement(self, enable)

    def usingDisplacement(self) -> "bool":
        r"""

        usingDisplacement(self) -> bool

            Query if displacement mapping is allowed.


        """
        return _hou.GeometryViewportSettings_usingDisplacement(self)

    def setDisplacementLevel(self, level: "double") -> "void":
        r"""

        setDisplacementLevel(self, level)

            Set the level of detail for displacement mapping. Displacement
            mapping adaptively subdivides the geometry to provide finer detail.
            Higher values result in denser subdivision, while lower values
            produce lighter meshes. The default is 1.0.


        """
        return _hou.GeometryViewportSettings_setDisplacementLevel(self, level)

    def displacementLevel(self) -> "double":
        r"""

        displacementLevel(self) -> double

            Query the level of detail used for displacement mapping.


        """
        return _hou.GeometryViewportSettings_displacementLevel(self)

    def setDefaultMaterialDiffuse(self, tint: "Color") -> "void":
        r"""

        setDefaultMaterialDiffuse(self, tint)

            Set the diffuse color of the default material (used when no material
            assignment is present or Show Materials is disabled).


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialDiffuse(self, tint)

    def defaultMaterialDiffuse(self) -> "HOM_Color":
        r"""

        defaultMaterialDiffuse(self) -> hou.Color

            Query the default material's diffuse color.


        """
        return _hou.GeometryViewportSettings_defaultMaterialDiffuse(self)

    def setDefaultMaterialSpecular(self, tint: "Color") -> "void":
        r"""

        setDefaultMaterialSpecular(self, tint)

            Set the specular color of the default material (used when no
            material assignment is present or Show Materials is disabled).


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialSpecular(self, tint)

    def defaultMaterialSpecular(self) -> "HOM_Color":
        r"""

        defaultMaterialSpecular(self) -> hou.Color

            Query the default material's specular color.


        """
        return _hou.GeometryViewportSettings_defaultMaterialSpecular(self)

    def setDefaultMaterialAmbient(self, tint: "Color") -> "void":
        r"""

        setDefaultMaterialAmbient(self) -> hou.Color

            Query the default material's ambient color.


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialAmbient(self, tint)

    def defaultMaterialAmbient(self) -> "HOM_Color":
        r"""

        defaultMaterialAmbient(self, tint)

            Set the ambient color of the default material (used when no material
            assignment is present or Show Materials is disabled).


        """
        return _hou.GeometryViewportSettings_defaultMaterialAmbient(self)

    def setDefaultMaterialEmission(self, tint: "Color") -> "void":
        r"""

        setDefaultMaterialEmission(self) -> hou.Color

            Query the default material's emission color.


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialEmission(self, tint)

    def defaultMaterialEmission(self) -> "HOM_Color":
        r"""

        defaultMaterialEmission(self, tint)

            Set the emission color of the default material (used when no
            material assignment is present or Show Materials is disabled).


        """
        return _hou.GeometryViewportSettings_defaultMaterialEmission(self)

    def setDefaultMaterialMatCapFile(self, filepath: "std::string const &") -> "void":
        r"""

        setDefaultMaterialMatCapFile(self, filepath)

            Set the file path to a Material Capture (MatCap) texture for the
            MatCap default material. A MatCap texture encodes lighting and
            shading information, much like a lat-long environment map.


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialMatCapFile(
            self, filepath
        )

    def getDefaultMaterialMatCapFile(self) -> "std::string":
        r"""

        getDefaultMaterialMatCapFile(self) -> str

            Return the file path of the current MatCap texture.


        """
        return _hou.GeometryViewportSettings_getDefaultMaterialMatCapFile(self)

    def setDefaultMaterialMatCapIntensity(self, i: "double") -> "void":
        r"""

        setDefaultMaterialMatCapIntensity(self, i)

            Set the intensity of the MatCap texture, which can be used to boost
            or dim the values in a MatCap texture file. This is a direct
            multiplier on the texture values.


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialMatCapIntensity(self, i)

    def getDefaultMaterialMatCapIntensity(self) -> "double":
        r"""

        getDefaultMaterialMatCapIntensity(self) -> float

            Return the MatCap texture intensity multiplier.


        """
        return _hou.GeometryViewportSettings_getDefaultMaterialMatCapIntensity(self)

    def setDefaultMaterialType(self, viewportDefaultMaterial: "EnumValue") -> "void":
        r"""

        setDefaultMaterialType(self, viewportDefaultMaterial)

            Set the default material type used when the geometry has to material
            assignment.

          * hou.viewportDefaultMaterial.Simple:

                An untextured material with variable roughness and color
                settings for diffuse, specular, emission, and ambient values.

          * hou.viewportDefaultMaterial.MatCap:

                A material that uses a MatCap texture (Material Capture) to
                define the lighting and shading of the surface rather than the
                lights in the scene.


        """
        return _hou.GeometryViewportSettings_setDefaultMaterialType(
            self, viewportDefaultMaterial
        )

    def getDefaultMaterialType(self) -> "HOM_EnumValue &":
        r"""

        getDefaultMaterialType(self) -> hou.EnumValue

            Return the default material type, either Simple or MatCap


        """
        return _hou.GeometryViewportSettings_getDefaultMaterialType(self)

    def setUniformFog(self, enable: "bool") -> "void":
        r"""

        setUniformFog(self, enable)

            Draw an simple atmospheric fog effect in the viewport, based on
            distance and not affected by lighting.


        """
        return _hou.GeometryViewportSettings_setUniformFog(self, enable)

    def getUniformFog(self) -> "bool":
        r"""

        getUniformFog(self) -> bool

            Query if uniform fog is active.


        """
        return _hou.GeometryViewportSettings_getUniformFog(self)

    def setUniformFogColor(self, color: "_DoubleTuple") -> "void":
        r"""

        setUniformFogColor(self, color)

            Tints the generated fog so it can be made to look more like smog,
            haze, or dust.


        """
        return _hou.GeometryViewportSettings_setUniformFogColor(self, color)

    def getUniformFogColor(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        getUniformFogColor(self) -> tuple of float

            Query the uniform fog color.


        """
        return _hou.GeometryViewportSettings_getUniformFogColor(self)

    def setUniformFogDensity(self, density: "double") -> "void":
        r"""

        setUniformFogDensity(self, density)

            Factor that controls how dense the fog is. Must be a positive value.


        """
        return _hou.GeometryViewportSettings_setUniformFogDensity(self, density)

    def getUniformFogDensity(self) -> "double":
        r"""

        getUniformFogDensity(self) -> float

            Query the uniform fog density.


        """
        return _hou.GeometryViewportSettings_getUniformFogDensity(self)

    def setUniformFogOpacity(self, opacity: "double") -> "void":
        r"""

        setUniformFogOpacity(self, opacity)

            An additional factor on the final fog result to make it heavier
            (>1.0) or lighter (<1.0). Must be zero or greater.


        """
        return _hou.GeometryViewportSettings_setUniformFogOpacity(self, opacity)

    def getUniformFogOpacity(self) -> "double":
        r"""

        getUniformFogOpacity(self) -> float

            Query the fog opacity.


        """
        return _hou.GeometryViewportSettings_getUniformFogOpacity(self)

    def setUniformFogDepthRange(self, range: "_DoubleTuple") -> "void":
        r"""

        setUniformFogDepthRange(self, range)

            For uniform fog, this is the depths where the fog begins and ends,
            in unit distance from the camera. All depths beyond the end are
            clamped to the end depth. Any depth before the fog start do not have
            fog applied. The fog start should be smaller than fog end, and both
            should be positive.


        """
        return _hou.GeometryViewportSettings_setUniformFogDepthRange(self, range)

    def getUniformFogDepthRange(
        self,
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        getUniformFogDepthRange(self) -> tuple of float

            Query the uniform depth range (near,far).


        """
        return _hou.GeometryViewportSettings_getUniformFogDepthRange(self)

    def setUniformFogHeightMode(self, viewportFogHeightMode: "EnumValue") -> "void":
        r"""

        setUniformFogHeightMode(self, viewportFogHeightMode)

          * hou.viewportFogHeightMode.Off:

                Height has no effect on the fog.

          * hou.viewportFogHeightMode.Above:

                Fog only appears above the fog height.

          * hou.viewportFogHeightMode.Below:

                Fog only appears below the fog height.


        """
        return _hou.GeometryViewportSettings_setUniformFogHeightMode(
            self, viewportFogHeightMode
        )

    def getUniformFogHeightMode(self) -> "HOM_EnumValue &":
        r"""

        getUniformFogHeightMode(self) -> hou.EnumValue

            Query the uniform fog height mode.


        """
        return _hou.GeometryViewportSettings_getUniformFogHeightMode(self)

    def setUniformFogHeight(self, h: "double") -> "void":
        r"""

        setUniformFogHeight(self, h)

            Set the height where fog starts, in world units.


        """
        return _hou.GeometryViewportSettings_setUniformFogHeight(self, h)

    def getUniformFogHeight(self) -> "double":
        r"""

        getUniformFogHeight(self) -> float

            Query the uniform fog height.


        """
        return _hou.GeometryViewportSettings_getUniformFogHeight(self)

    def setUniformFogHeightFalloff(self, h: "double") -> "void":
        r"""

        setUniformFogHeightFalloff(self, h)

            Set the height of the fog transition area between no and uniform
            full fog, in world units.


        """
        return _hou.GeometryViewportSettings_setUniformFogHeightFalloff(self, h)

    def getUniformFogHeightFalloff(self) -> "double":
        r"""

        getUniformFogHeightFalloff(self) -> float

            Query the uniform fog falloff.


        """
        return _hou.GeometryViewportSettings_getUniformFogHeightFalloff(self)

    def setUniformFogDepthClip(self, depth: "double") -> "void":
        r"""

        setUniformFogDepthClip(self, depth)

            Anything beyond the depth clip value not have uniform fog applied.
            This is useful for preventing fog on skyboxes or other image-based
            background elements.


        """
        return _hou.GeometryViewportSettings_setUniformFogDepthClip(self, depth)

    def getUniformFogDepthClip(self) -> "double":
        r"""

        getUniformFogDepthClip(self) -> float

            Query the depth clip value.


        """
        return _hou.GeometryViewportSettings_getUniformFogDepthClip(self)

    def setUniformFogUseSun(self, enable: "bool") -> "void":
        r"""

        setUniformFogUseSun(self, enable)

            Enable or disable simple lighting of uniform fog based on a distant
            light in the scene.


        """
        return _hou.GeometryViewportSettings_setUniformFogUseSun(self, enable)

    def getUniformFogUseSun(self) -> "bool":
        r"""

        getUniformFogUseSun(self) -> bool

            Query if the sun light is enabled for uniform fog.


        """
        return _hou.GeometryViewportSettings_getUniformFogUseSun(self)

    def setUniformFogSunBloom(self, bloom: "double") -> "void":
        r"""

        setUniformFogSunBloom(self, bloom)

            Set the size of the light bloom around the sun (scattering).


        """
        return _hou.GeometryViewportSettings_setUniformFogSunBloom(self, bloom)

    def getUniformFogSunBloom(self) -> "double":
        r"""

        getUniformFogSunBloom(self) -> float

            Query the sun bloom.


        """
        return _hou.GeometryViewportSettings_getUniformFogSunBloom(self)

    def setUniformFogSunIntensity(self, intensity: "double") -> "void":
        r"""

        setUniformFogSunIntensity(self, intensity)

            For uniform fog with the Sun enabled, this provides an additional
            intensity adjustment on the distant light's color.


        """
        return _hou.GeometryViewportSettings_setUniformFogSunIntensity(self, intensity)

    def getUniformFogSunIntensity(self) -> "double":
        r"""

        getUniformFogSunIntensity(self) -> float

            Query the sun light intensity modifier.


        """
        return _hou.GeometryViewportSettings_getUniformFogSunIntensity(self)

    def setVolumeFog(self, enable: "bool") -> "void":
        r"""

        setVolumeFog(self, enable)

            Draw an simple atmospheric fog effect in the viewport, based on
            distance and not affected by lighting.


        """
        return _hou.GeometryViewportSettings_setVolumeFog(self, enable)

    def getVolumeFog(self) -> "bool":
        r"""

        getVolumeFog(self) -> bool

            Query if volume fog is active.


        """
        return _hou.GeometryViewportSettings_getVolumeFog(self)

    def setVolumeFogColor(self, color: "_DoubleTuple") -> "void":
        r"""

        setVolumeFogColor(self, color)

            Tints the generated fog so it can be made to look more like smog,
            haze, or dust.


        """
        return _hou.GeometryViewportSettings_setVolumeFogColor(self, color)

    def getVolumeFogColor(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        getVolumeFogColor(self) -> tuple of float

            Query the volume fog color.


        """
        return _hou.GeometryViewportSettings_getVolumeFogColor(self)

    def setVolumeFogDensity(self, density: "double") -> "void":
        r"""

        setVolumeFogDensity(self, density)

            Factor that controls how dense the fog is. Must be a positive value.


        """
        return _hou.GeometryViewportSettings_setVolumeFogDensity(self, density)

    def getVolumeFogDensity(self) -> "double":
        r"""

        getVolumeFogDensity(self) -> float

            Query the volume fog density.


        """
        return _hou.GeometryViewportSettings_getVolumeFogDensity(self)

    def setVolumeFogOpacity(self, opacity: "double") -> "void":
        r"""

        setVolumeFogOpacity(self, opacity)

            An additional factor on the final fog result to make it heavier
            (>1.0) or lighter (<1.0). Must be zero or greater.


        """
        return _hou.GeometryViewportSettings_setVolumeFogOpacity(self, opacity)

    def getVolumeFogOpacity(self) -> "double":
        r"""

        getVolumeFogOpacity(self) -> float

            Query the fog opacity.


        """
        return _hou.GeometryViewportSettings_getVolumeFogOpacity(self)

    def setVolumeFogDepthRange(self, range: "_DoubleTuple") -> "void":
        r"""

        setVolumeFogDepthRange(self, range)

            For volume fog, this is the depths where the fog begins and ends, in
            unit distance from the camera. All depths beyond the end are clamped
            to the end depth. Any depth before the fog start do not have fog
            applied. The fog start should be smaller than fog end, and both
            should be positive.


        """
        return _hou.GeometryViewportSettings_setVolumeFogDepthRange(self, range)

    def getVolumeFogDepthRange(
        self,
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        getVolumeFogDepthRange(self) -> tuple of float

            Query the volume depth range (near,far).


        """
        return _hou.GeometryViewportSettings_getVolumeFogDepthRange(self)

    def setVolumeFogHeightMode(self, viewportFogHeightMode: "EnumValue") -> "void":
        r"""

        setVolumeFogHeightMode(self, viewportFogHeightMode)

          * hou.viewportFogHeightMode.Off:

                Height has no effect on the fog.

          * hou.viewportFogHeightMode.Above:

                Fog only appears above the fog height.

          * hou.viewportFogHeightMode.Below:

                Fog only appears below the fog height.


        """
        return _hou.GeometryViewportSettings_setVolumeFogHeightMode(
            self, viewportFogHeightMode
        )

    def getVolumeFogHeightMode(self) -> "HOM_EnumValue &":
        r"""

        getVolumeFogHeightMode(self) -> hou.EnumValue

            Query the volume fog height mode.


        """
        return _hou.GeometryViewportSettings_getVolumeFogHeightMode(self)

    def setVolumeFogHeight(self, h: "double") -> "void":
        r"""

        setVolumeFogHeight(self, h)

            Set the height where fog starts, in world units.


        """
        return _hou.GeometryViewportSettings_setVolumeFogHeight(self, h)

    def getVolumeFogHeight(self) -> "double":
        r"""

        getVolumeFogHeight(self) -> float

            Query the volume fog height.


        """
        return _hou.GeometryViewportSettings_getVolumeFogHeight(self)

    def setVolumeFogHeightFalloff(self, h: "double") -> "void":
        r"""

        setVolumeFogHeightFalloff(self, h)

            Set the height of the fog transition area between no and volume full
            fog, in world units.


        """
        return _hou.GeometryViewportSettings_setVolumeFogHeightFalloff(self, h)

    def getVolumeFogHeightFalloff(self) -> "double":
        r"""

        getVolumeFogHeightFalloff(self) -> float

            Query the volume fog falloff.


        """
        return _hou.GeometryViewportSettings_getVolumeFogHeightFalloff(self)

    def setVolumeFogQuality(self, viewportFogQuality: "EnumValue") -> "void":
        r"""

        setVolumeFogQuality(self, viewportFogQuality)

            The quality determines the size of the volume used for fog lighting.

          * hou.viewportFogQuality.Low:

                Small volume for fast drawing.

          * hou.viewportFogQuality.Medium:

                Larger volume balanced for quality and speed.

          * hou.viewportFogQuality.High:

                Very large volume for quality.


        """
        return _hou.GeometryViewportSettings_setVolumeFogQuality(
            self, viewportFogQuality
        )

    def getVolumeFogQuality(self) -> "HOM_EnumValue &":
        r"""

        getVolumeFogQuality(self) -> hou.EnumValue

            Query the volume fog quality.


        """
        return _hou.GeometryViewportSettings_getVolumeFogQuality(self)

    def setVolumeFogLightIntensity(self, h: "double") -> "void":
        r"""

        setVolumeFogLightIntensity(self, h)

            Set the default light intensity modifier for any lights without the
            gl_fogintensity property on them. Zero will cause only lights with
            that property to contribute to the lighting.


        """
        return _hou.GeometryViewportSettings_setVolumeFogLightIntensity(self, h)

    def getVolumeFogLightIntensity(self) -> "double":
        r"""

        getVolumeFogLightIntensity(self) -> float

            Query the volume light intensity modifier.


        """
        return _hou.GeometryViewportSettings_getVolumeFogLightIntensity(self)

    def setVolumeFogLightScattering(self, scatter: "_DoubleTuple") -> "void":
        r"""

        setVolumeFogLightScattering(self, scatter)


        """
        return _hou.GeometryViewportSettings_setVolumeFogLightScattering(self, scatter)

    def getVolumeFogLightScattering(
        self,
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        getVolumeFogLightScattering(self) -> tuple of float

            Query the volume light scattering (2-tuple).


        """
        return _hou.GeometryViewportSettings_getVolumeFogLightScattering(self)

    def setBloom(self, enable: "bool") -> "void":
        r"""

        setBloom(self, enable)

            Enable or disable the drawing of the bloom post-process effect which
            creates light bloom around very bright pixels.


        """
        return _hou.GeometryViewportSettings_setBloom(self, enable)

    def getBloom(self) -> "bool":
        r"""

        getBloom(self) -> bool

            Query if bloom is enabled.


        """
        return _hou.GeometryViewportSettings_getBloom(self)

    def setBloomScale(self, scale: "double") -> "void":
        r"""

        setBloomScale(self, scale)

            Scale the radius of blooms. The size is initially based on the
            brightness of the pixel, and this multiplies that value.


        """
        return _hou.GeometryViewportSettings_setBloomScale(self, scale)

    def getBloomScale(self) -> "double":
        r"""

        getBloomScale(self) -> float

            Query the bloom scale.


        """
        return _hou.GeometryViewportSettings_getBloomScale(self)

    def setBloomIntensity(self, i: "double") -> "void":
        r"""

        setBloomIntensity(self, i)

            Brighten or darken the blooms. The intensity is initially based on
            the brightness of the pixel, and this multiplies that value.


        """
        return _hou.GeometryViewportSettings_setBloomIntensity(self, i)

    def getBloomIntensity(self) -> "double":
        r"""

        getBloomIntensity(self) -> float

            Query the bloom intensity.


        """
        return _hou.GeometryViewportSettings_getBloomIntensity(self)

    def setBloomThreshold(self, i: "double") -> "void":
        r"""

        setBloomThreshold(self, i)

            Any pixels in the scene which are brighter than this threshold will
            have bloom applied to them (white being 1.0). Increasing this value
            reduces the amount of bloom generated.


        """
        return _hou.GeometryViewportSettings_setBloomThreshold(self, i)

    def getBloomThreshold(self) -> "double":
        r"""

        getBloomThreshold(self) -> float

            Query the bloom threshold.


        """
        return _hou.GeometryViewportSettings_getBloomThreshold(self)

    def setFogNode(self, node: "Node") -> "void":
        r"""

        setFogNode(self, node)

            Specify a node path which contains the fog parameters above. Any
            parameter that is found will override its corresponding display
            option. See Fog Properties. Passing None will clear the fog node and
            use the display option settings instead.


        """
        return _hou.GeometryViewportSettings_setFogNode(self, node)

    def getFogNode(self) -> "HOM_Node *":
        r"""

        getFogNode(self) -> hou.Node

            Query the fog node override.


        """
        return _hou.GeometryViewportSettings_getFogNode(self)

    def setDisplayOrthoGrid(self, enable: "bool") -> "void":
        r"""

        setDisplayOrthoGrid(self, enable)

            Display the grid in fixed orthographic views (Top, Left, Front,
            Bottom, Right, Back).


        """
        return _hou.GeometryViewportSettings_setDisplayOrthoGrid(self, enable)

    def displayOrthoGrid(self) -> "bool":
        r"""

        displayOrthoGrid(self) -> bool

            Query if the grid is displayed in fixed orthographic views.


        """
        return _hou.GeometryViewportSettings_displayOrthoGrid(self)

    def setOrthoGridOffset(self, offset: "_DoubleTuple") -> "void":
        r"""

        setOrthoGridOffset(self, offset)

            Set the offset of the grid in fixed orthographic views, as a 3-tuple
            in world space.


        """
        return _hou.GeometryViewportSettings_setOrthoGridOffset(self, offset)

    def orthoGridOffset(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        orthoGridOffset(self) -> tuple of float

            Query the offset of the grid in fixed orthographic views.


        """
        return _hou.GeometryViewportSettings_orthoGridOffset(self)

    def setOrthoGridSpacing(self, offset: "_DoubleTuple") -> "void":
        r"""

        setOrthoGridSpacing(self, offset)

            Set the spacing of the grid lines in fixed orthographic views as a
            2-tuple.


        """
        return _hou.GeometryViewportSettings_setOrthoGridSpacing(self, offset)

    def orthoGridSpacing(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        orthoGridSpacing(self) -> tuple of float

            Query the spacing of the grid lines in fixed orthographic views as a
            2-tuple.


        """
        return _hou.GeometryViewportSettings_orthoGridSpacing(self)

    def setOrthoGridRuler(self, offset: "_IntTuple") -> "void":
        r"""

        setOrthoGridRuler(self, offset)

            Set the spacing of the grid numbers in fixed orthographic views as a
            2-tuple.


        """
        return _hou.GeometryViewportSettings_setOrthoGridRuler(self, offset)

    def orthoGridRuler(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        orthoGridRuler(self) -> tuple of int

            Query the spacing of the grid numbers in fixed orthographic views as
            a 2-tuple.


        """
        return _hou.GeometryViewportSettings_orthoGridRuler(self)

    def setOrthoRuler(self, viewportGridRuler: "EnumValue") -> "void":
        r"""

        setOrthoRuler(self, viewportGridRuler)

            Where to display the grid numbers on the fixed orthographic view
            grid.

          * hou.viewportGridRuler.Hide:

                Do not display.

          * hou.viewportGridRuler.MainAxis:

                Display along the main axes at grid line intersections.

          * hou.viewportGridRuler.GridPoints:

                Display on grid line intersections.


        """
        return _hou.GeometryViewportSettings_setOrthoRuler(self, viewportGridRuler)

    def orthoRuler(self) -> "HOM_EnumValue &":
        r"""

        orthoRuler(self) -> hou.viewportGridRuler

            Query where the grid numbers are displayed on the fixed orthographic
            view grid.

          * hou.viewportGridRuler.Hide:

                Not displayed.

          * hou.viewportGridRuler.MainAxis:

                Displayed along the main axes at grid line intersections.

          * hou.viewportGridRuler.GridPoints:

                Displayed on grid line intersections.


        """
        return _hou.GeometryViewportSettings_orthoRuler(self)

    def setUVReferenceGrid(self, enable: "bool") -> "void":
        r"""

        setUVReferenceGrid(self, enable)

            Display the grid in UV viewports.


        """
        return _hou.GeometryViewportSettings_setUVReferenceGrid(self, enable)

    def uvReferenceGrid(self) -> "bool":
        r"""

        uvReferenceGridOverImage(self) -> bool

            Query if the dot grid is displayed.


        """
        return _hou.GeometryViewportSettings_uvReferenceGrid(self)

    def setUVDisplayGridOverImage(self, enable: "bool") -> "void":
        return _hou.GeometryViewportSettings_setUVDisplayGridOverImage(self, enable)

    def uvReferenceGridOverImage(self) -> "bool":
        return _hou.GeometryViewportSettings_uvReferenceGridOverImage(self)

    def setUVGridPixelSpacing(self, offset: "_IntTuple") -> "void":
        r"""

        setUVGridPixelSpacing(self, offset)

            Set the spacing of the UV dot grid displayed over the background
            image.


        """
        return _hou.GeometryViewportSettings_setUVGridPixelSpacing(self, offset)

    def uvGridPixelSpacing(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        uvGridPixelSpacing(self) -> tuple of float

            Query the spacing of the UV dot grid displayed over background
            images.


        """
        return _hou.GeometryViewportSettings_uvGridPixelSpacing(self)

    def setUVGridPixelOffset(self, offset: "_DoubleTuple") -> "void":
        r"""

        setUVGridPixelOffset(self, offset)

            Set the spacing, in pixels, of the dot grid.


        """
        return _hou.GeometryViewportSettings_setUVGridPixelOffset(self, offset)

    def uvGridPixelOffset(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        uvGridPixelOffset(self) -> tuple of float

            Query the spacing of the dot grid in pixels.


        """
        return _hou.GeometryViewportSettings_uvGridPixelOffset(self)

    def setClampUVGridToBackground(self, enable: "bool") -> "void":
        r"""

        setClampUVGridToBackground(self, enable)

            Restrict the grid to the background image's area.


        """
        return _hou.GeometryViewportSettings_setClampUVGridToBackground(self, enable)

    def clampUVGridToBackground(self) -> "bool":
        r"""

        clampUVGridToBackground(self) -> bool

            Query if the grid is restricted to the background image's area.


        """
        return _hou.GeometryViewportSettings_clampUVGridToBackground(self)

    def setDisplayUVTileBoundaries(self, enable: "bool") -> "void":
        r"""

        setDisplayUVTileBoundaries(self, enable)

            Display the boundaries of UV tiles at integral U and V numbers.


        """
        return _hou.GeometryViewportSettings_setDisplayUVTileBoundaries(self, enable)

    def displayUVTileBoundaries(self) -> "bool":
        r"""

        displayUVTileBoundaries(self) -> bool

            Query if the boundaries of UV tiles are displayed.


        """
        return _hou.GeometryViewportSettings_displayUVTileBoundaries(self)

    def setColorScheme(self, viewportColorScheme: "EnumValue") -> "void":
        r"""

        setColorScheme(self, viewportColorScheme)

            Set the color scheme for the viewport.

          * hou.viewportColorScheme.Dark:

                Black background.

          * hou.viewportColorScheme.Grey:

                Light grey background.

          * hou.viewportColorScheme.Light:

                Light blue gradient background.


        """
        return _hou.GeometryViewportSettings_setColorScheme(self, viewportColorScheme)

    def colorScheme(self) -> "HOM_EnumValue &":
        r"""

        colorScheme(self) -> hou.viewportColorScheme

            Query the current viewport color scheme.

          * hou.viewportColorScheme.Dark:

                Black background.

          * hou.viewportColorScheme.Grey:

                Light grey background.

          * hou.viewportColorScheme.Light:

                Light blue gradient background.


        """
        return _hou.GeometryViewportSettings_colorScheme(self)

    def colorFromName(self, name: "std::string const &") -> "HOM_Color":
        r"""

        colorFromName(self, colorName) -> hou.Color

            Query a specific color from the current viewport color scheme. The
            valid color names can be found in the color scheme configuration
            files in 3DSceneColors.


        """
        return _hou.GeometryViewportSettings_colorFromName(self, name)

    def alphaFromName(self, name: "std::string const &") -> "double":
        r"""

        alphaFromName(self, colorName) -> double

            Query a specific alpha from the current viewport color scheme. The
            valid alpha names can be found in the color scheme configuration
            files in 3DSceneColors.


        """
        return _hou.GeometryViewportSettings_alphaFromName(self, name)

    def backgroundImage(
        self, viewportBackgroundView: "EnumValue", layer: "int" = 1
    ) -> "HOM_GeometryViewportBackground *":
        r"""

        backgroundImage(self, viewportBGImageView, layer) ->
        hou.GeometryViewportBGImage

            Access the background image parameters for the target view type.
            layer is currently not used but reserved for future use.

          * hou.viewportBGImageView.Perspective:

                The 3D view not attached to a camera (No cam).

          * hou.viewportBGImageView.Camera:

                The 3D view looking through a camera.

          * hou.viewportBGImageView.Top:

                The orthographic top view.

          * hou.viewportBGImageView.Front:

                The orthographic front view.

          * hou.viewportBGImageView.Right:

                The orthographic right view.

          * hou.viewportBGImageView.Bottom:

                The orthographic bottom view.

          * hou.viewportBGImageView.Back:

                The orthographic back view.

          * hou.viewportBGImageView.Left:

                The orthographic left view.

          * hou.viewportBGImageView.UV:

                The UV texture viewport.


        """
        return _hou.GeometryViewportSettings_backgroundImage(
            self, viewportBackgroundView, layer
        )

    def setDisplayBackgroundImage(self, enable: "bool") -> "void":
        r"""

        setDisplayBackgroundImage(self, enable)

            Globally enable background image display.


        """
        return _hou.GeometryViewportSettings_setDisplayBackgroundImage(self, enable)

    def displayBackgroundImage(self) -> "bool":
        r"""

        displayBackgroundImage(self) -> bool

            Query if background image display is globally enabled.


        """
        return _hou.GeometryViewportSettings_displayBackgroundImage(self)

    def setDisplayEnvironmentBackgroundImage(self, enable: "bool") -> "void":
        r"""

        setDisplayEnvironmentBackgroundImage(self, enable)

            Allow environment lights to show their environment maps as 360
            degree background images.


        """
        return _hou.GeometryViewportSettings_setDisplayEnvironmentBackgroundImage(
            self, enable
        )

    def displayEnvironmentBackgroundImage(self) -> "bool":
        r"""

        displayEnvironmentBackgroundImage(self) -> bool

            Query if environment lights' environment maps are shown as 360
            degree background images.


        """
        return _hou.GeometryViewportSettings_displayEnvironmentBackgroundImage(self)

    def setFilterBackgroundImage(self, enable: "bool") -> "void":
        r"""

        setFilterBackgroundImage(self, enable)

            Enable texture filtering of background images. When off, individual
            pixels are shown as blocks at high zoom levels rather than blended.


        """
        return _hou.GeometryViewportSettings_setFilterBackgroundImage(self, enable)

    def filterBackgroundImage(self) -> "bool":
        r"""

        filterBackgroundImage(self) -> bool

            Query if texture filtering of background images is enabled.


        """
        return _hou.GeometryViewportSettings_filterBackgroundImage(self)

    def setApplyZoomToBackgroundImage(self, enable: "bool") -> "void":
        r"""

        setApplyZoomToBackgroundImage(self, enable)

            Allow the camera zoom to affect the background image.


        """
        return _hou.GeometryViewportSettings_setApplyZoomToBackgroundImage(self, enable)

    def applyZoomToBackgroundImage(self) -> "bool":
        r"""

        applyZoomToBackgroundImage(self) -> bool

            Query if the camera zoom is affecting the background image.


        """
        return _hou.GeometryViewportSettings_applyZoomToBackgroundImage(self)

    def setBackgroundImageQuality(self, quality: "int") -> "void":
        r"""

        setBackgroundImageQuality(self, quality)

            Set the quality of the background image, from 0-100. Values less
            than 100 will scale down the resolution of the background image.


        """
        return _hou.GeometryViewportSettings_setBackgroundImageQuality(self, quality)

    def backgroundImageQuality(self) -> "int":
        r"""

        backgroundImageQuality(self) -> int

            Query the quality of background image display, from 0-100.


        """
        return _hou.GeometryViewportSettings_backgroundImageQuality(self)

    def setDisplayTextures(self, enable: "bool") -> "void":
        r"""

        setDisplayTextures(self, enable)

            Enable material texturing.


        """
        return _hou.GeometryViewportSettings_setDisplayTextures(self, enable)

    def displayTextures(self) -> "bool":
        r"""

        displayTextures(self) -> bool

            Query if material texturing is enabled.


        """
        return _hou.GeometryViewportSettings_displayTextures(self)

    def setDisplayTextureLayers(self, enable: "bool") -> "void":
        r"""

        setDisplayTextureLayers(self, enable)

            Enable multiple texture layers when texturing. This causes an extra
            render of the geometry per texture layer.


        """
        return _hou.GeometryViewportSettings_setDisplayTextureLayers(self, enable)

    def displayTextureLayers(self) -> "bool":
        r"""

        displayTextureLayers(self) -> bool

            Query if multiple texture layers are rendered.


        """
        return _hou.GeometryViewportSettings_displayTextureLayers(self)

    def setDisplayProjectedTextures(self, enable: "bool") -> "void":
        r"""

        setDisplayProjectedTextures(self, enable)

            Enable projected textures from spotlights with a valid texture.


        """
        return _hou.GeometryViewportSettings_setDisplayProjectedTextures(self, enable)

    def displayProjectedTextures(self) -> "bool":
        r"""

        displayProjectedTextures(self) -> bool

            Query if projected textures from spotlights are rendered.


        """
        return _hou.GeometryViewportSettings_displayProjectedTextures(self)

    def setTextureMipmapping(self, enable: "bool") -> "void":
        r"""

        setTextureMipmapping(self, enable)

            Enable mipmapping for textures, improving display quality but
            increasing texture memory use by 50%.


        """
        return _hou.GeometryViewportSettings_setTextureMipmapping(self, enable)

    def textureMipmapping(self) -> "bool":
        r"""

        textureMipmapping(self) -> bool

            Query if texture mipmapping is enabled.


        """
        return _hou.GeometryViewportSettings_textureMipmapping(self)

    def setTextureAnisotropicFilter(self, num_samples: "int") -> "void":
        r"""

        setTextureAnisotropicFilter(self, num_samples)

            Set the number of samples for anisotropic texture filtering. More
            samples produces better results for textures on polygons on an angle
            to the view direction.


        """
        return _hou.GeometryViewportSettings_setTextureAnisotropicFilter(
            self, num_samples
        )

    def textureAnisotropicFilter(self) -> "int":
        r"""

        textureAnisotropicFilter(self) -> int

            Query the number of samples used for anisotropic texture filtering.


        """
        return _hou.GeometryViewportSettings_textureAnisotropicFilter(self)

    def setTextureCacheSize(self, size_in_mb: "int") -> "void":
        r"""

        setTextureCacheSize(self, size_in_mb)

            Set the size of the texture cache, in megabytes. The viewport will
            use as much texture memory as it needs, even if it exceeds this
            level, but textures will be culled once they are no longer used to
            remain within this limit.


        """
        return _hou.GeometryViewportSettings_setTextureCacheSize(self, size_in_mb)

    def textureCacheSize(self) -> "int":
        r"""

        textureCacheSize(self) -> int

            Query the texture cache size, in megabytes.


        """
        return _hou.GeometryViewportSettings_textureCacheSize(self)

    def setTextureMaxMemory(self, size_in_mb: "int") -> "void":
        r"""

        setTextureMaxMemory(self, size_in_mb)

            Set the maximum size of a single texture, in megabytes. This
            prevents extremely large textures from starving the graphics
            hardware's bandwidth (mostly by 3D textures).


        """
        return _hou.GeometryViewportSettings_setTextureMaxMemory(self, size_in_mb)

    def textureMaxMemory(self) -> "int":
        r"""

        textureMaxMemory(self) -> int

            Return the maximum size of a single texture, in megabytes.


        """
        return _hou.GeometryViewportSettings_textureMaxMemory(self)

    def setTextureAutoReduce(self, enable: "bool") -> "void":
        r"""

        setTextureAutoReduce(self, enable)

            Enable auto-reduction of viewport textures. This attempts to scale
            down textures to fit within the texture cache.


        """
        return _hou.GeometryViewportSettings_setTextureAutoReduce(self, enable)

    def textureAutoReduce(self) -> "bool":
        r"""

        textureAutoReduce(self) -> bool

            Query if auto-reduction of viewport textures is enabled.


        """
        return _hou.GeometryViewportSettings_textureAutoReduce(self)

    def setTextureAutoReduce2D(self, enable: "bool") -> "void":
        r"""

        setTextureAutoReduce2D(self, enable)

            Allow auto-reduction of regular 2D textures.


        """
        return _hou.GeometryViewportSettings_setTextureAutoReduce2D(self, enable)

    def textureAutoReduce2D(self) -> "bool":
        r"""

        textureAutoReduce2D(self) -> bool

            Query if auto-reduction of regular 2D textures is allowed.


        """
        return _hou.GeometryViewportSettings_textureAutoReduce2D(self)

    def setTextureAutoReduce3D(self, enable: "bool") -> "void":
        r"""

        setTextureAutoReduce3D(self, enable)

            Allow auto-reduction of 3D textures (volumes).


        """
        return _hou.GeometryViewportSettings_setTextureAutoReduce3D(self, enable)

    def textureAutoReduce3D(self) -> "bool":
        r"""

        textureAutoReduce3D(self) -> bool

            Query if auto-reduction of 3D textures is allowed.


        """
        return _hou.GeometryViewportSettings_textureAutoReduce3D(self)

    def setTextureResLimit2D(self, enable: "bool") -> "void":
        r"""

        setTextureResLimit2D(self, enable)

            Limit the resolution of all 2D textures, so that the width and
            height cannot exceed the limit. Even if disabled, OpenGL has its own
            texture limits which will be applied (usually 8k or 16k).


        """
        return _hou.GeometryViewportSettings_setTextureResLimit2D(self, enable)

    def textureResLimit2D(self) -> "bool":
        r"""

        textureResLimit2D(self) -> bool

            Query if 2D textures have their resolutions limited.


        """
        return _hou.GeometryViewportSettings_textureResLimit2D(self)

    def setTextureMaxRes2D(self, res: "_IntTuple") -> "void":
        r"""

        setTextureMaxRes2D(self, res)

            Set the maximum resolution of a 2D texture. res is an integer
            2-tuple of (width, height). OpenGL has its own limit, and setting
            this limit higher than that will have no effect. The image will be
            scaled to fit the limit if it exceeds it.


        """
        return _hou.GeometryViewportSettings_setTextureMaxRes2D(self, res)

    def textureMaxRes2D(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        textureMaxRes2D(self) -> 2-tuple of int

            Return the maximum resolution for a 2D texture.


        """
        return _hou.GeometryViewportSettings_textureMaxRes2D(self)

    def setTextureBitDepthLimit2D(self, viewportTextureDepth: "EnumValue") -> "void":
        r"""

        setTextureBitDepthLimit2D(self, viewportTextureDepth)

            Set the maximum bit depth for a 2D texture. Textures with a bit
            depth higher than this will be downconverted to this bit depth.
            Textures with an equal or lower bit depth will not be converted.

          * hou.viewportTextureDepth.Compressed8:

                Compressed, 8b SDR texture format. Smallest memory use.

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with care.


        """
        return _hou.GeometryViewportSettings_setTextureBitDepthLimit2D(
            self, viewportTextureDepth
        )

    def textureBitDepthLimit2D(self) -> "HOM_EnumValue &":
        r"""

        textureBitDepthLimit2D(self) -> hou.viewportTextureDepth

            Query the maximum bit depth for a 2D texture.

          * hou.viewportTextureDepth.Compressed8:

                Compressed, 8b SDR texture format. Smallest memory use.

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with care.


        """
        return _hou.GeometryViewportSettings_textureBitDepthLimit2D(self)

    def setTextureScale2D(self, scale: "double") -> "void":
        r"""

        setTextureScale2D(self, scale)

            Uniformly downscale all 2D textures by this fraction (default 1.0,
            no scale).


        """
        return _hou.GeometryViewportSettings_setTextureScale2D(self, scale)

    def textureScale2D(self) -> "double":
        r"""

        textureScale2D(self) -> float

            Query the uniform scale applied to 2D textures.


        """
        return _hou.GeometryViewportSettings_textureScale2D(self)

    def setTextureResLimit3D(self, enable: "bool") -> "void":
        r"""

        setTextureResLimit3D(self, enable)

            Limit the resolution of all 3D textures (volumes), so that the
            width, height, and depth cannot exceed the limit. Even if disabled,
            OpenGL has its own texture limits which will be applied (usually 2k
            or 8k).


        """
        return _hou.GeometryViewportSettings_setTextureResLimit3D(self, enable)

    def textureResLimit3D(self) -> "bool":
        r"""

        textureResLimit3D(self) -> bool

            Query if 3D textures have their resolutions limited.


        """
        return _hou.GeometryViewportSettings_textureResLimit3D(self)

    def setTexture2DSettingsFor3D(self, enable: "bool") -> "void":
        r"""

        setTexture2DSettingsFor3D(self, enable)

            When enabled, use all the 2D texture settings for 3D textures.


        """
        return _hou.GeometryViewportSettings_setTexture2DSettingsFor3D(self, enable)

    def texture2DSettingsFor3D(self) -> "bool":
        r"""

        texture2DSettingsFor3D(self) -> bool

            Query if the 2D settings are used for 3D textures.


        """
        return _hou.GeometryViewportSettings_texture2DSettingsFor3D(self)

    def setTextureMaxRes3D(self, res: "_IntTuple") -> "void":
        r"""

        setTextureMaxRes3D(self, res)

            Set the maximum resolution of a 3D texture (volume). res is an
            integer 3-tuple of (width, height, depth). OpenGL has its own limit,
            and setting this limit higher than that will have no effect. The
            image will be scaled to fit the limit if it exceeds it.


        """
        return _hou.GeometryViewportSettings_setTextureMaxRes3D(self, res)

    def textureMaxRes3D(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        textureMaxRes3D(self) -> 3-tuple of int

            Query the maximum resolution of a 3D texture (volume).


        """
        return _hou.GeometryViewportSettings_textureMaxRes3D(self)

    def setTextureBitDepthLimit3D(self, viewportTextureDepth: "EnumValue") -> "void":
        r"""

        setTextureBitDepthLimit3D(self, viewportTextureDepth)

            Set the maximum bit depth for a 3D texture (volume). Textures with a
            bit depth higher than this will be downconverted to this bit depth.
            Textures with an equal or lower bit depth will not be converted. 3D
            textures do not support compressed formats.

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with care.


        """
        return _hou.GeometryViewportSettings_setTextureBitDepthLimit3D(
            self, viewportTextureDepth
        )

    def textureBitDepthLimit3D(self) -> "HOM_EnumValue &":
        r"""

        textureBitDepthLimit3D(self) -> hou.viewportTextureDepth

            Query the maximum bit depth of a 3D texture (volume).

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with extreme
                care.


        """
        return _hou.GeometryViewportSettings_textureBitDepthLimit3D(self)

    def setTextureScale3D(self, scale: "double") -> "void":
        r"""

        setTextureScale3D(self, scale)

            Uniformly downscale all 3D textures (volumes) by this fraction
            (default 1.0, no scale).


        """
        return _hou.GeometryViewportSettings_setTextureScale3D(self, scale)

    def textureScale3D(self) -> "double":
        r"""

        textureScale3D(self) -> float

            Query the uniform scale applied to 3D textures (volumes).


        """
        return _hou.GeometryViewportSettings_textureScale3D(self)

    def useMaterialStylesheets(self, enable: "bool") -> "void":
        r"""

        useMaterialStylesheets(self, enable)

            Enable evaluation of material stylesheets for viewport material
            assignment.


        """
        return _hou.GeometryViewportSettings_useMaterialStylesheets(self, enable)

    def usingMaterialStylesheets(self) -> "bool":
        r"""

        usingMaterialStylesheets(self) -> bool

            Query if material stylesheet assignment is active.


        """
        return _hou.GeometryViewportSettings_usingMaterialStylesheets(self)

    def usePerPrimStylesheets(self, enable: "bool") -> "void":
        r"""

        usePerPrimStylesheets(self, enable)

            Enable evaluation of per-primitive stylesheets.


        """
        return _hou.GeometryViewportSettings_usePerPrimStylesheets(self, enable)

    def usingPerPrimStylesheets(self) -> "bool":
        r"""

        usingPerPrimStylesheets(self) -> bool

            Query if per-primitive stylesheets are evaluated.


        """
        return _hou.GeometryViewportSettings_usingPerPrimStylesheets(self)

    def usePackedStylesheets(self, enable: "bool") -> "void":
        r"""

        usePackedStylesheets(self, enable)

            Enable assignment of material stylesheets to geometry within packed
            primitives.


        """
        return _hou.GeometryViewportSettings_usePackedStylesheets(self, enable)

    def usingPackedStylesheets(self) -> "bool":
        r"""

        usingPackedStylesheets(self) -> bool

            Query if material stylesheet assignments are applied to geometry
            within packed primitives.


        """
        return _hou.GeometryViewportSettings_usingPackedStylesheets(self)

    def useMaterialOverrides(self, enable: "bool") -> "void":
        r"""

        useMaterialOverrides(self, enable)

            Allow material overrides from material stylesheets and the
            material_override attribute.


        """
        return _hou.GeometryViewportSettings_useMaterialOverrides(self, enable)

    def usingMaterialOverrides(self) -> "bool":
        r"""

        usingMaterialOverrides(self) -> bool

            Query if material overrides are being applied to material
            assignments.


        """
        return _hou.GeometryViewportSettings_usingMaterialOverrides(self)

    def setSingleObjectMaterialLimit(self, num_materials: "int") -> "void":
        r"""

        setSingleObjectMaterialLimit(self, num_materials)

            Set the maximum number of material variations for a single object.


        """
        return _hou.GeometryViewportSettings_setSingleObjectMaterialLimit(
            self, num_materials
        )

    def singleObjectMaterialLimit(self) -> "int":
        r"""

        singleObjectMaterialLimit(self) -> int

            Query the maximum number of material variations for a single object.


        """
        return _hou.GeometryViewportSettings_singleObjectMaterialLimit(self)

    def setMaterialUpdate(self, viewportMaterialUpdate: "EnumValue") -> "void":
        r"""

        setMaterialUpdate(self, viewportMaterialUpdate)

            Set the material assignment update frequency.

          * hou.viewportMaterialUpdate.Always:

                Update assignments whenever needed.

          * hou.viewportMaterialUpdate.OffForPlayback:

                Update assignments whenever needed, but not during playback.

          * hou.viewportMaterialUpdate.Manual:

                Only update assignments when Update Materials is pressed.


        """
        return _hou.GeometryViewportSettings_setMaterialUpdate(
            self, viewportMaterialUpdate
        )

    def materialUpdate(self) -> "HOM_EnumValue &":
        r"""

        materialUpdate(self) -> hou.viewportMaterialUpdate

            Query the material assignment update frequency.

          * hou.viewportMaterialUpdate.Always:

                Update assignments whenever needed.

          * hou.viewportMaterialUpdate.OffForPlayback:

                Update assignments whenever needed, but not during playback.

          * hou.viewportMaterialUpdate.Manual:

                Only update assignments when Update Materials is pressed.


        """
        return _hou.GeometryViewportSettings_materialUpdate(self)

    def setInteractiveMaterialUpdate(self, enable: "bool") -> "void":
        r"""

        setInteractiveMaterialUpdate(self, enable)

            Update materials when they are changed to reflect their new state.
            When disabled, Update Materials must be pressed manually for changes
            to be reflected in the viewport.


        """
        return _hou.GeometryViewportSettings_setInteractiveMaterialUpdate(self, enable)

    def interactiveMaterialUpdate(self) -> "bool":
        r"""

        interactiveMaterialUpdate(self) -> bool

            Query if materials are updated when they change.


        """
        return _hou.GeometryViewportSettings_interactiveMaterialUpdate(self)

    def updateMaterials(self) -> "void":
        r"""

        updateMaterials(self)

            Manually update all materials and material assignments.


        """
        return _hou.GeometryViewportSettings_updateMaterials(self)

    def setVisibleObjects(self, uv: "std::string const &") -> "void":
        r"""

        setVisibleObjects(self, uv)

            Set the mask for all visible objects in the viewport. Wildcards can
            be used.


        """
        return _hou.GeometryViewportSettings_setVisibleObjects(self, uv)

    def visibleObjects(self) -> "std::string":
        r"""

        visibleObjects(self) -> str

            Query the current visible object mask.


        """
        return _hou.GeometryViewportSettings_visibleObjects(self)

    def setRemoveBackfaces(self, enable: "bool") -> "void":
        r"""

        setRemoveBackfaces(self, enable)

            Cull polygons facing backwards instead of rasterizing them.


        """
        return _hou.GeometryViewportSettings_setRemoveBackfaces(self, enable)

    def removeBackfaces(self) -> "bool":
        r"""

        removeBackfaces(self) -> bool

            Query if backwards facing polygons are culled.


        """
        return _hou.GeometryViewportSettings_removeBackfaces(self)

    def setHullsOnly(self, enable: "bool") -> "void":
        r"""

        setHullsOnly(self, enable)

            Draw only hulls for complex curves and surfaces like NURBS and
            Beziers.


        """
        return _hou.GeometryViewportSettings_setHullsOnly(self, enable)

    def hullsOnly(self) -> "bool":
        r"""

        hullsOnly(self) -> bool

            Query if only hulls are drawn for complex curves and surfaces.


        """
        return _hou.GeometryViewportSettings_hullsOnly(self)

    def setDistanceBasedPackedCulling(self, enable: "bool") -> "void":
        r"""

        setDistanceBasedPackedCulling(self, enable)

            Enable culling of packed primitives when the polygon count of the
            visible objects in the frustum exceeds a certain amount, starting
            with the most distant.


        """
        return _hou.GeometryViewportSettings_setDistanceBasedPackedCulling(self, enable)

    def distanceBasedPackedCulling(self) -> "bool":
        r"""

        distanceBasedPackedCulling(self) -> bool

            Query if packed primitive culling is enabled.


        """
        return _hou.GeometryViewportSettings_distanceBasedPackedCulling(self)

    def setScenePolygonLimit(self, millions_of_polygons: "int") -> "void":
        r"""

        setScenePolygonLimit(self, millions_of_polygons)

            Set the maximum number of polygons in the view frustum, in millions,
            before the viewport begins culling packed primitives.


        """
        return _hou.GeometryViewportSettings_setScenePolygonLimit(
            self, millions_of_polygons
        )

    def scenePolygonLimit(self) -> "int":
        r"""

        scenePolygonLimit(self) -> int

            Query the maximum allowed number of polygons in the view frustum, in
            millions of polygons.


        """
        return _hou.GeometryViewportSettings_scenePolygonLimit(self)

    def setPackedBoundingBoxMode(self, viewportPackedBoxMode: "EnumValue") -> "void":
        r"""

        setPackedBoundingBoxMode(self, viewportPackedBoxMode)

            Define how culled packed primitives are displayed.

          * hou.viewportPackedBoxMode.NoDisplay:

                Culled packed primitives are not displayed at all.

          * hou.viewportPackedBoxMode.Wireframe:

                A wireframe bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.Shaded:

                A shaded bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.CurrentShadingMode:

                A bounding box replaces the packed primitive, drawn wireframe in
                wireframe shading modes and shaded otherwise.


        """
        return _hou.GeometryViewportSettings_setPackedBoundingBoxMode(
            self, viewportPackedBoxMode
        )

    def packedBoundingBoxMode(self) -> "HOM_EnumValue &":
        r"""

        packedBoundingBoxMode(self) -> hou.viewportPackedBoxMode

            Query how culled packed primitives are displayed.

          * hou.viewportPackedBoxMode.NoDisplay:

                Culled packed primitives are not displayed at all.

          * hou.viewportPackedBoxMode.Wireframe:

                A wireframe bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.Shaded:

                A shaded bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.CurrentShadingMode:

                A bounding box replaces the packed primitive, drawn wireframe in
                wireframe shading modes and shaded otherwise.


        """
        return _hou.GeometryViewportSettings_packedBoundingBoxMode(self)

    def setOptimizeGeometry(self, enable: "bool") -> "void":
        r"""

        setOptimizeGeometry(self, enable)

            Optimize packed geometry when loaded to make it faster for display
            (triangulating and splitting meshes).


        """
        return _hou.GeometryViewportSettings_setOptimizeGeometry(self, enable)

    def optimizeGeometry(self) -> "bool":
        r"""

        optimizeGeometry(self) -> bool

            Query if packed geometry is optimized.


        """
        return _hou.GeometryViewportSettings_optimizeGeometry(self)

    def setAgentLODReduction(self, enable: "bool") -> "void":
        r"""

        setAgentLODReduction(self, enable)

            Enable the use of multiple levels of detail for crowd agents, each
            LOD level being half the polygon count of the previous level.


        """
        return _hou.GeometryViewportSettings_setAgentLODReduction(self, enable)

    def agentLODReduction(self) -> "bool":
        r"""

        agentLODReduction(self) -> bool

            Query if multiple levels of detail (LOD) are generated for crowd
            agents.


        """
        return _hou.GeometryViewportSettings_agentLODReduction(self)

    def setAgentLODReductionBias(self, reduce_bias: "int") -> "void":
        r"""

        setAgentLODReductionBias(self, reduce_bias)

            Set the LOD balance from Performance (0) to Quality (10), which
            biases which LOD levels are chosen.


        """
        return _hou.GeometryViewportSettings_setAgentLODReductionBias(self, reduce_bias)

    def agentLODReductionBias(self) -> "int":
        r"""

        agentLODReductionBias(self) -> int

            Query the LOD bias for agents.


        """
        return _hou.GeometryViewportSettings_agentLODReductionBias(self)

    def setAgentShapePointCutoff(self, num_points: "int") -> "void":
        r"""

        setAgentShapePointCutoff(self, num_points)

            Set the minimum number of points in an agent LOD level. If an LOD
            level would go below this number, it is not generated.


        """
        return _hou.GeometryViewportSettings_setAgentShapePointCutoff(self, num_points)

    def agentShapePointCutoff(self) -> "int":
        r"""

        agentShapePointCutoff(self) -> int

            Query the minimum number of points in an agent LOD level.


        """
        return _hou.GeometryViewportSettings_agentShapePointCutoff(self)

    def setMaxLODLevels(self, num_levels: "int") -> "void":
        r"""

        setMaxLODLevels(self, num_levels)

            Set the maximum number of levels to generate for an agent. This will
            be the original model plus this number.


        """
        return _hou.GeometryViewportSettings_setMaxLODLevels(self, num_levels)

    def maxLODLevels(self) -> "int":
        r"""

        maxLODLevels(self) -> int

            Query the maximum number of levels generated for an agent.


        """
        return _hou.GeometryViewportSettings_maxLODLevels(self)

    def setBaseLODLevel(self, base_level: "int") -> "void":
        r"""

        setBaseLODLevel(self, base_level)

            Set the level to use as the full level of detail model, generally 0
            (the original agent model). For very heavy poly count agents, this
            can be set to higher values to reduce the polygon count of the
            highest level of detail model.


        """
        return _hou.GeometryViewportSettings_setBaseLODLevel(self, base_level)

    def baseLODLevel(self) -> "int":
        r"""

        baseLODLevel(self) -> int

            Query the base level of detail.


        """
        return _hou.GeometryViewportSettings_baseLODLevel(self)

    def setSingleBoneDeform(self, viewportAgentBoneDeform: "EnumValue") -> "void":
        r"""

        setSingleBoneDeform(self, viewportAgentBoneDeform)

            Set the complexity of bone-based deformation on agents.

          * hou.viewportAgentBoneDeform.Always:

                Only use 1 bone to deform on all agent instances (the one with
                the most influence).

          * hou.viewportAgentBoneDeform.ReducedLOD:

                Use up to 4 bones to deform the highest LOD agent instances, and
                1 bone on all the reduced LOD instances.

          * hou.viewportAgentBoneDeform.Disabled:

                Use up to 4 bones to deform on all agent instances.


        """
        return _hou.GeometryViewportSettings_setSingleBoneDeform(
            self, viewportAgentBoneDeform
        )

    def singleBoneDeform(self) -> "HOM_EnumValue &":
        r"""

        singleBoneDeform(self) -> hou.viewportAgentBoneDeform

            Query the complexity of bone-based deformation on agents.

          * hou.viewportAgentBoneDeform.Always:

                Only use 1 bone to deform on all agent instances (the one with
                the most influence).

          * hou.viewportAgentBoneDeform.ReducedLOD:

                Use up to 4 bones to deform the highest LOD agent instances, and
                1 bone on all the reduced LOD instances.

          * hou.viewportAgentBoneDeform.Disabled:

                Use up to 4 bones to deform on all agent instances.


        """
        return _hou.GeometryViewportSettings_singleBoneDeform(self)

    def setAgentWireframe(self, viewportAgentWireframe: "EnumValue") -> "void":
        r"""

        setAgentWireframe(self, viewportAgentWireframe)

            Set the appearance of agents in wireframe mode.

          * hou.viewportAgentWireframe.Bone:

                Agents are rendered as bone-based skeletons.

          * hou.viewportAgentWireframe.Line:

                Agents are rendered as line-based skeletons.


        """
        return _hou.GeometryViewportSettings_setAgentWireframe(
            self, viewportAgentWireframe
        )

    def agentWireframe(self) -> "HOM_EnumValue &":
        r"""

        agentWireframe(self) -> hou.viewportAgentWireframe

            Query the appearance of agents in wireframe mode.

          * hou.viewportAgentWireframe.Bone:

                Agents are rendered as bone-based skeletons.

          * hou.viewportAgentWireframe.Line:

                Agents are rendered as line-based skeletons.


        """
        return _hou.GeometryViewportSettings_agentWireframe(self)

    def setAgentBlendShapes(self, enable: "bool") -> "void":
        r"""

        setAgentBlendShapes(self, enable)

            Enable the display of blend shapes for crowd agents.


        """
        return _hou.GeometryViewportSettings_setAgentBlendShapes(self, enable)

    def agentBlendShapes(self) -> "bool":
        r"""

        agentBlendShapes(self) -> bool

            Query if blend shape display is enabled for crowd agents.


        """
        return _hou.GeometryViewportSettings_agentBlendShapes(self)


# Register GeometryViewportSettings in _hou:
_hou.GeometryViewportSettings_swigregister(GeometryViewportSettings)


class GeometryViewportBackground(object):
    r"""

    hou.GeometryViewportBackground

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_GeometryViewportBackground

    def __repr__(self) -> "std::string":
        return _hou.GeometryViewportBackground___repr__(self)

    def setImageFile(self, file_path: "std::string const &") -> "void":
        r"""

        setImageFile(self, file_path)

            Set the filename of the background image and set the background
            source to 'File'.


        """
        return _hou.GeometryViewportBackground_setImageFile(self, file_path)

    def imageFile(self) -> "std::string":
        r"""

        imageFile(self) -> str

            Query the filename of the background image.


        """
        return _hou.GeometryViewportBackground_imageFile(self)

    def setImageCOP(self, op_path: "std::string const &") -> "void":
        r"""

        setImageCOP(self, op_path)

            Set the path to the Composite operator defining the background image
            and set the background source to 'COP'.


        """
        return _hou.GeometryViewportBackground_setImageCOP(self, op_path)

    def imageCOP(self) -> "std::string":
        r"""

        imageCOP(self) -> str

            Query the operation path of the background image.


        """
        return _hou.GeometryViewportBackground_imageCOP(self)

    def sourceFromCOP(self, use_cop: "bool") -> "void":
        r"""

        sourceFromCOP(self, use_cop)

            Fetch the background image from a composite operator instead of a
            disk file. If False, a disk file is used.


        """
        return _hou.GeometryViewportBackground_sourceFromCOP(self, use_cop)

    def isCOPSource(self) -> "bool":
        r"""

        isCOPSource(self) -> bool

            Query if the background image is sourced from a composite operator.


        """
        return _hou.GeometryViewportBackground_isCOPSource(self)

    def isFileSource(self) -> "bool":
        r"""

        isFileSource(self) -> bool

            Query if the background image is sourced from a disk file.


        """
        return _hou.GeometryViewportBackground_isFileSource(self)

    def setImageSource(self, file_or_op_path: "std::string const &") -> "void":
        r"""

        setImageSource(self, file_or_op_path)

            Set the file or cop path, depending on the current background image
            source.


        """
        return _hou.GeometryViewportBackground_setImageSource(self, file_or_op_path)

    def imageSource(self) -> "std::string":
        r"""

        imageSource(self) -> str

            Query the file or cop path, depending on the current background
            image source.


        """
        return _hou.GeometryViewportBackground_imageSource(self)

    def setEnvironmentMap(self, enable: "bool") -> "void":
        r"""

        setEnvironmentMap(self, enable)

            Draw the background image as a 360 degree environment map, or a
            regular 2D image if set to False.


        """
        return _hou.GeometryViewportBackground_setEnvironmentMap(self, enable)

    def isEnvironmentMap(self) -> "bool":
        r"""

        isEnvironmentMap(self) -> bool

            Query if the background image is drawn as 360 degree environment
            map..


        """
        return _hou.GeometryViewportBackground_isEnvironmentMap(self)

    def setAutoPlace(self, enable: "bool") -> "void":
        r"""

        setAutoPlace(self, enable)

            Automatically fit the background image to the viewport. If False,
            use the manual offset and scale to position the image.


        """
        return _hou.GeometryViewportBackground_setAutoPlace(self, enable)

    def autoPlace(self) -> "bool":
        r"""

        autoPlace(self) -> bool

            Query if the background image is automatically fit to the viewport.


        """
        return _hou.GeometryViewportBackground_autoPlace(self)

    def setImageOffset(self, offset: "_DoubleTuple") -> "void":
        r"""

        setImageOffset(self, offset)

            Set the background image offset, which is a 2-tuple of float. The
            values should be in the 0-1 range, representing fractions of the
            viewport width and height.


        """
        return _hou.GeometryViewportBackground_setImageOffset(self, offset)

    def imageOffset(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        imageOffset(self) -> tuple of float

            Query the background image offset.


        """
        return _hou.GeometryViewportBackground_imageOffset(self)

    def setImageScale(self, scale: "_DoubleTuple") -> "void":
        r"""

        setImageScale(self, scale)

            Set the background image scale, which is a 2-tuple of float. The
            values should be in the 0-1 range, representing fractions of the
            viewport width and height.


        """
        return _hou.GeometryViewportBackground_setImageScale(self, scale)

    def imageScale(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        imageScale(self) -> tuple of float

            Query the background image scale.


        """
        return _hou.GeometryViewportBackground_imageScale(self)

    def setBrightness(self, intensity: "double") -> "void":
        r"""

        setBrightness(self, intensity)

            Set the intensity multiplier of the background image. A value of 1
            keeps it at its original intensity, and values less than that dim
            it.


        """
        return _hou.GeometryViewportBackground_setBrightness(self, intensity)

    def brightness(self) -> "double":
        r"""

        brightness(self) -> float

            Query the intensity multiplier of the background image.


        """
        return _hou.GeometryViewportBackground_brightness(self)


# Register GeometryViewportBackground in _hou:
_hou.GeometryViewportBackground_swigregister(GeometryViewportBackground)


class _GUDetailHandle(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__GUDetailHandle

    def __repr__(self) -> "std::string":
        return _hou._GUDetailHandle___repr__(self)

    def _asVoidPointer(self) -> "void *":
        return _hou._GUDetailHandle__asVoidPointer(self)

    def isFrozen(self) -> "bool":
        return _hou._GUDetailHandle_isFrozen(self)

    def isReadOnly(self) -> "bool":
        return _hou._GUDetailHandle_isReadOnly(self)

    def destroy(self) -> "void":
        return _hou._GUDetailHandle_destroy(self)


# Register _GUDetailHandle in _hou:
_hou._GUDetailHandle_swigregister(_GUDetailHandle)


class Handle(object):
    r"""

    hou.Handle

    Gives access to an handle bound to a viewer state.

    OVERVIEW

        The Handle class lets you manipulate handles bound to viewer states.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, scene_viewer: "SceneViewer", name: "std::string const &"):
        r"""

        __init__(self, scene_viewer, name)

            Creates an object for accessing a handle of a given name. hou.Handle
            is typically used with python viewer states.


            WARNING
                Handle objects are typically created from a python viewer state
                constructor. However, calling methods on Handle objects must be
                done once the state has been entered, exceptions will be raised
                otherwise.


            scene_viewer
                A hou.SceneViewer object referencing the scene viewer where the
                handle is going to be used. Exception is thrown if the scene
                viewer is not compatible.

            name
                A string to identify the handle object. The name corresponds to
                the handle's name used at binding time. See
                hou.ViewerStateTemplate.bindHandle or
                hou.ViewerStateTemplate.bindStaticHandle for details.

          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >         self.handle = hou.Handle(scene_viewer, \"Transform\")
          >
          > # Create a template to describe the state and its bindings
          > template = hou.ViewerStateTemplate(\"mystate\", \"My Custom State\", hou.sopNodeTypeCategory())
          > template.bindFactory(MyState)
          > template.bindHandle(\"xform\", \"Transform\")

        """
        _hou.Handle_swiginit(self, _hou.new_Handle(scene_viewer, name))

    __swig_destroy__ = _hou.delete_Handle

    def __repr__(self) -> "std::string":
        return _hou.Handle___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self): -> string

            The name of this handle.


        """
        return _hou.Handle_name(self)

    def type(self) -> "std::string":
        r"""

        type(self): -> string

            Returns the type name of the handle. The return value corresponds to
            the type used for binding the handle. See
            hou.ViewerStateTemplate.bindHandle or
            hou.ViewerStateTemplate.bindStaticHandle for details.


        """
        return _hou.Handle_type(self)

    def show(self, value: "bool") -> "void":
        r"""

        show(self, value)

            Shows or hides the handle.


            value
                Bool value, True to show the handle, False to hide it.


        """
        return _hou.Handle_show(self, value)

    def update(self, immediate: "bool" = False) -> "void":
        r"""

        update(self, immediate)

            This method forces the handle to update. Useful if a change made to
            a viewer state requires one of its handle to get updated. For
            dynamic handles, this will trigger a call to the onStateToHandle
            callback, allowing the viewer state to update the proper handle
            parameter(s).


            immediate
                Controls when the update is performed. If False, the update is
                delayed until Houdini is on idle. If True, the update is
                performed immediately. Defaults to False.


        """
        return _hou.Handle_update(self, immediate)

    def visible(self) -> "bool":
        r"""

        visible(self): -> bool

            Returns True if the handle is visible, False otherwise.


        """
        return _hou.Handle_visible(self)

    def enableParms(self, *args) -> "void":
        r"""

        enableParms(self, parm_names)

            Dynamically enables the parms of this handle specified with
            parm_names. If handle_parms is empty (default), all handle parms are
            enabled.

            Raises exception if the handle is not bound dynamically to a viewer
            state.


            NOTE
                Some handles like xform may not display its components right
                away when enabled. This can happen if the components were
                previously disabled. For instance, disabling the rotation
                (rx,ry,rz) and re-enabling it again will not restore the
                previous rotate mode to display the rotation knobs. Restoring
                the rotate mode must rather be achieved by cycling the Y key or
                by calling hou.Handle.applySetting.

            See also hou.Handle.disableParms.


            parm_names
                A list of names specifying the handle parms to enable.
                parm_names must contain the handle parm names as described here.
                Exception is raised if parm_names contains unknown parm names.


        """
        return _hou.Handle_enableParms(self, *args)

    def disableParms(self, *args) -> "void":
        r"""

        disableParms(self, parm_names)

            This method does the opposite of hou.Handle.enableParms and
            dynamically disables the handle parms specified in parm_names. If
            handle_parms is empty (default), all handle parms are disabled.

            Raises exception if the handle is not bound dynamically to a viewer
            state.


            parm_names
                A list of names specifying the handle parms to disable.
                parm_names must contain the handle parm names as described here.
                Exception is raised if parm_names contains unknown parm names.


        """
        return _hou.Handle_disableParms(self, *args)

    def applySettings(self, settings: "std::string const &") -> "void":
        r"""

        applySettings(self, settings)

            Apply one or more settings to this handle.


            settings
                A string containing the handle specific settings. Multiple
                settings must be space separated.


        """
        return _hou.Handle_applySettings(self, settings)


# Register Handle in _hou:
_hou.Handle_swigregister(Handle)


class hda(object):
    r"""

    hou.hda

    Module containing functions related to Houdini Digital Assets.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_hda

    def __repr__(self) -> "std::string":
        return _hou.hda___repr__(self)

    def installFile(
        self,
        file_path: "char const *",
        oplibraries_file: "char const *" = None,
        change_oplibraries_file: "bool" = True,
        force_use_assets: "bool" = False,
    ) -> "void":
        r"""

        installFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True, force_use_assets=False)

            Install all the node types defined in an hda file into the current
            Houdini session. This function is equivalent to File > Install
            Digital Asset Library... in Houdini.


            file_path
                The hda file to load.

            oplibraries_file
                The path to an OPlibraries file or None. OPlibraries files are
                text files containing lists of hda files to load on startup.
                When Houdini starts up it reads all the OPlibraries files it
                finds in the Houdini path and loads all the hda files listed in
                them. By creating OPlibraries files in $HOME/houdiniX.Y,
                $HSITE/houdiniX.Y, $JOB, etc. you can create libraries that are
                specific to a particular user, studio, job, etc.

                This parameter is only meaningful when change_oplibraries_file
                is True.

                Note that OPlibraries are only used when the Use OPlibraries
                files to find HDAS checkbox in the Configuration tab of the
                Operator Type Manager is checked.

                If None or Current HIP File, the hda file is loaded only into
                the current Houdini session. The file name will also be saved in
                the Hip file so that when the same Hip file is loaded, the hda
                file will also be loaded automatically.

                If Scanned Asset Library Directories, this is equivalent to the
                installation menu entry in the Install Digital Asset Library
                dialog.

            change_oplibraries_file
                When oplibraries_file is not None and this parameter is True,
                Houdini will modify the OPlibraries file, adding the hda file to
                it.

            force_use_assets
                When True, ensure that the definitions inside the hda file are
                current. If they would not otherwise provide the current
                definition, they are marked as preferred to ensure they are
                current. See hou.HDADefinition.isPreferred for more information.

            Note that, if you do not store the path to the hda file in an
            OPlibraries file, Houdini will store it in the current Houdini
            session. So, when you load a hip file, it will try to load the hda
            files that it references.


        """
        return _hou.hda_installFile(
            self, file_path, oplibraries_file, change_oplibraries_file, force_use_assets
        )

    def uninstallFile(
        self,
        file_path: "char const *",
        oplibraries_file: "char const *" = None,
        change_oplibraries_file: "bool" = True,
    ) -> "void":
        r"""

        uninstallFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True)

            Uninstall an hda file and all the node type definitions it provides
            from the current Houdini session. The hda file and its contents on
            disk are unchanged.

            You can set file_path to the special name \"Embedded\" to refer to the
            digital assets embedded in the current hip file. The following
            example removes any embedded digital asset definitions from the
            current Houdini session:

          > hou.hda.uninstallFile(\"Embedded\")

            If oplibraries_file is not None and change_oplibraries_file is True,
            Houdini will remove the path to the hda from the specified
            OPlibraries file. See hou.hda.installFile for more information about
            these parameters.

            If all the definitions of a node type are uninstalled, any instances
            of that node type will warn that they are using an incomplete asset
            definition. They will, however, retain their parameter values as
            spare parameters. Installing an hda file with the missing node type
            will restore those node instances and remove the warnings.

            See also hou.HDADefinition.destroy.


        """
        return _hou.hda_uninstallFile(
            self, file_path, oplibraries_file, change_oplibraries_file
        )

    def reloadFile(self, file_path: "char const *") -> "void":
        r"""

        reloadFile(file_path)

            Reload the contents of an hda file, loading any updated digital
            asset definitions inside it.

            You only need to call this function if an hda file was modified from
            outside the current Houdini session.


        """
        return _hou.hda_reloadFile(self, file_path)

    def reloadAllFiles(self, rescan: "bool" = True) -> "void":
        r"""

        reloadAllFiles(rescan=True)

            Reload the digital asset files and update asset definitions in the
            current session.

            If the rescan is true, Houdini will check the hda directories for
            any new hda files and load them too.

            See also hou.hda.reloadFile.


        """
        return _hou.hda_reloadAllFiles(self, rescan)

    def reloadNamespaceOrder(self) -> "void":
        r"""

        reloadNamespaceOrder()

            Check HOUDINI_OPNAMESPACE_HIERARCHY environment variable and rebuild
            the node type preference order that determines the node type to use
            when only unqualified root name is used in scripts, or, when Tab
            menu settings specify to show only a single preferred entry among
            several potential choices from different namespaces.


        """
        return _hou.hda_reloadNamespaceOrder(self)

    def expandToDirectory(
        self, file_path: "char const *", directory_path: "char const *"
    ) -> "void":
        r"""

        expandToDirectory(file_path, directory_path)

            Expand the contents of the hda file in file_path into the directory
            directory_path. If the directory does not already exist it is
            created.

            When expanding an hda file, Houdini puts each digital asset
            definition in the file into its own directory. As well, it puts each
            section inside a definition into its own file. Each directory inside
            the expanded file tree contains a Sections.List file that maps the
            actual file or directory names into the section names, since section
            names may contain characters that cannot occur in directory or file
            names. See hou.HDASection for more information about sections.

            This function provides an easy way to inspect and modify the
            contents of an hda file. See also hou.hda.collapseFromDirectory.


        """
        return _hou.hda_expandToDirectory(self, file_path, directory_path)

    def collapseFromDirectory(
        self, file_path: "char const *", directory_path: "char const *"
    ) -> "void":
        r"""

        collapseFromDirectory(file_path, directory_path)

            Given a directory that contains a previously expanded hda file,
            collapse it into the hda file specified by file_path.

            This function provides the inverse of hou.hda.expandToDirectory.


        """
        return _hou.hda_collapseFromDirectory(self, file_path, directory_path)

    def loadedFiles(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        loadedFiles() -> tuple of str

            Return a tuple of paths to the hda files that are loaded into the
            current Houdini session.

            This method is can be approximately implemented as follows:

          > def loadedFiles():
          >     '''Return a list of hda files loaded into this Houdini session.'''
          >     # Look through all the node types, and for those that have digital
          >     # asset definitions, remember the hda file containing the definition.
          >     result = []
          >     for category in hou.nodeTypeCategories().values():
          >         for node_type in category.nodeTypes().values():
          >             definition = node_type.definition()
          >             if definition is None:
          >                 continue
          >             if definition.libraryFilePath() not in result:
          >                 result.append(definition.libraryFilePath())
          >     return result

            See hou.HDADefinition.isCurrent for an example.


        """
        return _hou.hda_loadedFiles(self)

    def renameSource(
        self, oplibraries_file: "char const *", source_name: "char const *" = None
    ) -> "void":
        r"""

        renameSource(oplibraries_file, source_name=None)

            Give a name to an OPlibraries file. This name appears in the
            Operator Type Manager's list of OPlibraries file. If source_name is
            None, the name is removed from the OPlibraries file.

            If the oplibraries_file does not already exist, it is created.

            See hou.hda.installFile for more information about OPlibraries
            files.


        """
        return _hou.hda_renameSource(self, oplibraries_file, source_name)

    def definitionsInFile(
        self, file_path: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_HDADefinition >,std::allocator< HOM_ElemPtr< HOM_HDADefinition > > >":
        r"""

        definitionsInFile(file_path) -> tuple of hou.HDADefinition

            Return all the digital asset definitions inside an hda file. See
            hou.HDADefinition for more information.

            Raises hou.OperationFailed if file_path does not refer to a valid
            hda file.

          > # Print the node types defined by digital assets in $HOME/houdiniX.Y/hda/OPcustom.hda:
          > >>> import os
          > >>> my_hda_file = \"%s/hda/OPcustom.hda\" % hou.homeHoudiniDirectory()
          > >>> for definition in hou.hda.definitionsInFile(my_hda_file):
          > ...     print definition.nodeTypeCategory().name() + \"/\" + definition.nodeTypeName()
          > Sop/gcoggeo
          > Sop/gCogFlatGeo
          > Sop/gDivideAtCentroid
          > Object/gAxle
          > Object/gCog

        """
        return _hou.hda_definitionsInFile(self, file_path)

    def componentsFromFullNodeTypeName(
        self, node_type_name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        componentsFromFullNodeTypeName(node_type_name) -> tuple of str

            Returns a tuple of operator type name components that constitute the
            full node type name. The components in the tuple appear in the
            following order: scope network type, node type namespace, node type
            core name, and version.

          > >>> # Parse the full name into components
          > >>> hou.hda.componentsFromFullNodeTypeName('MyUserNamespace::MyHDA::2.5')
          > ('', 'MyUserNamespace', 'MyHDA', '2.5')
          > >>> hou.hda.componentsFromFullNodeTypeName('Sop/foreach::MyCounterHDA')
          > ('Sop/foreach', '', 'MyCounterHDA', '')

        """
        return _hou.hda_componentsFromFullNodeTypeName(self, node_type_name)

    def fullNodeTypeNameFromComponents(
        self,
        scope_node_type: "char const *",
        name_space: "char const *",
        name: "char const *",
        version: "char const *",
    ) -> "std::string":
        r"""

        fullNodeTypeNameFromComponents(scope_node_type, name_space, name,
        version) -> str

            Returns a full node type name build out of the given components. The
            arguments represent the following components: scope network type,
            node type namespace, node type core name, and version.

          > >>> # Compose the node type full name from components
          > >>> hou.hda.fullNodeTypeNameFromComponents('', 'userA', 'sphere', '')
          > 'userA::sphere'
          > >>> hou.hda.fullNodeTypeNameFromComponents('', 'userB', 'myHda', '2.6')
          > 'userB::myHda::2.6'
          > >>> hou.hda.fullNodeTypeNameFromComponents('Sop/foreach', '', 'MyCounterHDA', '')
          > 'Sop/foreach::MyCounterHDA'

        """
        return _hou.hda_fullNodeTypeNameFromComponents(
            self, scope_node_type, name_space, name, version
        )

    def changeCurrentStoreUser(self, new_user: "char const *") -> "void":
        return _hou.hda_changeCurrentStoreUser(self, new_user)

    def safeguardHDAs(self) -> "bool":
        r"""

        safeguardHDAs() -> bool

            Return True if the Safeguard Operator Definitions configuration
            option is turned on. When safeguarding is turned on then no digital
            asset definition can be modified in the Houdini session.


        """
        return _hou.hda_safeguardHDAs(self)

    def setSafeguardHDAs(self, on: "bool") -> "void":
        r"""

        setSafeguardHDAs(on)

            Set whether the Safeguard Operator Definitions configuration option
            should be turned on or off. The on argument must be either True of
            False.


        """
        return _hou.hda_setSafeguardHDAs(self, on)

    def removeAllEventCallbacks(self) -> "void":
        r"""

        removeAllEventCallbacks(self)

            Remove all event callbacks for all event types.

            See hou.hda.addEventCallback for more information.


        """
        return _hou.hda_removeAllEventCallbacks(self)

    def addEventCallback(
        self, event_types: "_EnumTuple", callback: "InterpreterObject"
    ) -> "void":
        r"""

        addEventCallback(self, event_types, callback)

            Register a Python callback that Houdini will call whenever a
            particular action, or event, occurs with digital asset libraries.

            Callbacks only persist for the current session. For example, they
            are not saved to the .hip file. If you want persistent callbacks in
            every session, you can add them in code in pythonrc.py (runs on
            startup) or 456.py (runs when the user opens a .hip file). See where
            to add Python scripting for more information.


            event_types
                A sequence of hou.hdaEventType enumeration values describing the
                event types that will cause Houdini to call the callback
                function.

            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

                Houdini calls the function with an event_type keyword argument
                containing the hou.hdaEventType value corresponding to the event
                that triggered the callback.

                Houdini will pass additional keyword arguments depending on the
                event type. For example, in a callback for the LibraryInstalled
                or LibraryUninstalled events, Houdini will pass a library_path
                keyword argument containing the path of the .hda file that was
                installed or uninstalled. See hou.hdaEventType for the
                additional arguments passed for each event type.

                You can add **kwargs to the argument list to accept all keyword
                arguments, to allow the same callback to be used for different
                events, or to be safe from future changes:

              > def event_callback(event_type, **kwargs):
              >     ...

            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to an event. However, it may be useful to add the same
                function if you want to register it with different event_types.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            The following example shows to set up a function that's called
            whenever a new asset is added to Houdini:

          >
          > def hda_event(event_type, asset_definition, **kwargs):
          >     label = asset_definition.description()
          >     library_path = asset_definition.libraryFilePath()
          >     print(\"New asset %s in %s\" % (label, library_path))
          >
          > hou.hda.addEventCallback((hou.hdaEventType.AssetCreated, ), hda_event)

            See also hou.hda.removeEventCallback and
            hou.hda.removeAllEventCallbacks.


        """
        return _hou.hda_addEventCallback(self, event_types, callback)

    def removeEventCallback(
        self, event_types: "_EnumTuple", callback: "InterpreterObject"
    ) -> "void":
        r"""

        removeEventCallback(self, event_types, callback)

            Given a callback that was previously added and a sequence of
            hou.hdaEventType enumerated values, remove those event types from
            the set of event types for the callback. If the remaining set of
            event types is empty, the callback will be removed entirely.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.hda.addEventCallback for more information.


        """
        return _hou.hda_removeEventCallback(self, event_types, callback)

    def eventCallbacks(
        self,
    ) -> "std::vector< std::pair< std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >,InterpreterObject >,std::allocator< std::pair< std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >,InterpreterObject > > >":
        return _hou.hda_eventCallbacks(self)


# Register hda in _hou:
_hou.hda_swigregister(hda)


class HDADefinition(object):
    r"""

    hou.HDADefinition

    Represents the definition of a houdini digital asset (HDA).

    A digital asset definition defines a node type and exists inside an hda
    file. The node type is implemented in terms of other nodes wired
    together inside a subnet. These nodes inside the subnet are called the
    definition's contents.

    An hda file contains one or more digital asset definitions, and
    installing an hda file installs all the definitions in the file. When a
    digital asset definition is installed, the node type it defines is added
    to Houdini. Note that you can access an HDADefinition without installing
    it.

    A digital asset's algorithm is determined by the nodes inside it. To
    edit those nodes you create an instance of the digital asset, unlock it,
    modify the contents, and save the definition. New digital asset
    instances are normally locked, meaning that they are read-only, and they
    automatically update when the asset's definition changes. An unlocked
    instance is editable, does not update when the definition changes, and
    you can save its contents to change the definition.

    To unlock a node, select Allow Editing of Contents or call
    hou.Node.allowEditingOfContents. To save the contents of an unlocked
    node to the definition, select Save Operator Type or call
    hou.HDADefinition.updateFromNode. To revert an unlocked instance back to
    the last saved definition and change it back into a locked instance,
    select Match Current Definition or call hou.Node.matchCurrentDefinition.

    See also hou.hda and hou.HDAOptions.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_HDADefinition

    def __eq__(self, hda_definition: "HOM_PtrOrNull< HOM_HDADefinition >") -> "bool":
        return _hou.HDADefinition___eq__(self, hda_definition)

    def __ne__(self, hda_definition: "HOM_PtrOrNull< HOM_HDADefinition >") -> "bool":
        return _hou.HDADefinition___ne__(self, hda_definition)

    def __hash__(self) -> "int":
        return _hou.HDADefinition___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.HDADefinition___repr__(self)

    def nodeType(self) -> "HOM_NodeType *":
        r"""

        nodeType(self) -> hou.NodeType

            Return the node type defined by this digital asset. Raises
            hou.OperationFailed if the digital asset is not installed.


        """
        return _hou.HDADefinition_nodeType(self)

    def nodeTypeCategory(self) -> "HOM_NodeTypeCategory &":
        r"""

        nodeTypeCategory(self) -> hou.NodeTypeCategory

            Return the node type category (e.g. Objects, SOPs, DOPs, etc.) for
            the node type defined by this digital asset. See
            hou.NodeTypeCategory for more information.

            It is safe to call this method if the digital asset is not
            installed. If the digital asset is installed, this method is
            equivalent to self.nodeType().category().


        """
        return _hou.HDADefinition_nodeTypeCategory(self)

    def nodeTypeName(self) -> "std::string":
        r"""

        nodeTypeName(self) -> str

            Return the name of the node type defined by this digital asset.
            Raises hou.OperationFailed if the digital asset is not installed.

            If the digital asset is installed, this method is a shortcut for
            self.nodeType().name().


        """
        return _hou.HDADefinition_nodeTypeName(self)

    def libraryFilePath(self) -> "std::string":
        r"""

        libraryFilePath(self) -> str

            Return the path to the hda file containing the digital asset's
            definition.

            Note that it is possible to save an asset with a hip file, without
            storing it in an hda file. In this case, this method returns
            \"Embedded\".


        """
        return _hou.HDADefinition_libraryFilePath(self)

    def embeddedHelp(self) -> "std::string":
        r"""

        embeddedHelp(self) -> str

            Return the help text embedded in the digital asset. Return an empty
            string if no embedded help exists.

            Embedded help typically comes from the Help tab of the operator type
            properties window, but it may also come from a dialog script.


        """
        return _hou.HDADefinition_embeddedHelp(self)

    def isInstalled(self) -> "bool":
        r"""

        isInstalled(self) -> bool

            Return whether this definition is installed in Houdini.

            It is possible to access HDADefinition objects in hda files that are
            not installed with hou.hda.definitionsInFile.

            See also hou.hda.installFile.


        """
        return _hou.HDADefinition_isInstalled(self)

    def installed(self) -> "bool":
        return _hou.HDADefinition_installed(self)

    def isCurrent(self) -> "bool":
        r"""

        isCurrent(self) -> bool

            Return whether this definition is the one currently in use by
            Houdini.

            This example shows how you can access other definitions for the same
            node type:

          > def otherDefinitions(definition):
          >     '''Given an HDADefinition object, return the other loaded definitions
          >        for the same node type.'''
          >     # Look through all the loaded hda files for definitions providing
          >     # the same node type.
          >     result = []
          >     for hda_file in hou.hda.loadedFiles():
          >         # Skip the hda file containing the definition that was passed in.
          >         if hda_file == definition.libraryFilePath():
          >             continue
          >
          >         for other_definition in hou.hda.definitionsInFile(hda_file):
          >             if other_definition.nodeType() == definition.nodeType():
          >                 result.append(other_definition)
          >     return result
          > # Print the paths to hda files providing other definitions for a digital asset instance.
          > >>> for other_definition in otherDefinitions(hou.node(\"/obj/my_hda1\").type().definition()):
          > ...     print other_definition.libraryFilePath()
          > /path/to/file1.hda
          > /path/to/file2.hda

        """
        return _hou.HDADefinition_isCurrent(self)

    def current(self) -> "bool":
        return _hou.HDADefinition_current(self)

    def isPreferred(self) -> "bool":
        r"""

        isPreferred(self) -> bool

            Return whether this definition is preferred.

            After loading hda files, Houdini uses a set of rules to resolve
            conflicts when it encounters multiple definitions for the same node
            type (e.g. preferring the most recent hda file, preferring
            definitions embedded in the hip file, etc.). When these rules do not
            use the definition you want, you can override them by explicitly
            marking a definition as preferred. Houdini saves this list of
            preferred definitions with the hip file. Marking a definition as not
            preferred will remove it from this list, and the normal rules will
            apply again.


        """
        return _hou.HDADefinition_isPreferred(self)

    def preferred(self) -> "bool":
        return _hou.HDADefinition_preferred(self)

    def setIsPreferred(self, preferred: "bool") -> "void":
        r"""

        setIsPreferred(self, preferred)

            Set whether this definition is preferred. See
            hou.HDADefinition.isPreferred for more information.


        """
        return _hou.HDADefinition_setIsPreferred(self, preferred)

    def setPreferred(self, preferred: "bool") -> "void":
        return _hou.HDADefinition_setPreferred(self, preferred)

    def enableCreateBackups(self, create_backups: "bool") -> "void":
        r"""

        enableCreateBackups(self, create_backups)

            Sets whether or not backup files should be created each time the HDA
            is modified, e.g. if a section is added or removed, if the icon is
            changed, etc.


        """
        return _hou.HDADefinition_enableCreateBackups(self, create_backups)

    def isCreateBackupsEnabled(self) -> "bool":
        r"""

        isCreateBackupsEnabled(self) -> bool

            Returns true if the HDA Definition creates backup files on disk when
            modified.


        """
        return _hou.HDADefinition_isCreateBackupsEnabled(self)

    def sections(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_HDASection >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_HDASection > > > >":
        r"""

        sections(self) -> dict of str to hou.HDASection

            Return a dictionary mapping section names to hou.HDASection objects.
            See hou.HDASection for more information on sections.


        """
        return _hou.HDADefinition_sections(self)

    def hasSection(self, name: "char const *") -> "bool":
        r"""

        hasSection(self, name) -> bool

            Return True if the HDA definition contains a section with the
            specified name and False otherwise.

            See hou.HDASection for more information on sections.


        """
        return _hou.HDADefinition_hasSection(self, name)

    def addSection(self, *args) -> "HOM_HDASection *":
        r"""

        addSection(self, name, contents=\"\",
        compression_type=hou.compressionType.NoCompression) -> hou.HDASection

            Create a new section with the specified contents. If a section
            already exists with this name, changes the existing contents to the
            new contents. Note that the contents may contain binary data. Also
            note that section names may contain '/'.

            You can optionally specify a compression type, hou.compressionType,
            to compress the contents. Note that you must specify the same
            compression type when reading the contents back to decompress them.

            For Python 3, the contents can be either a str object for plain text
            data or a bytes object for binary data.

            See hou.HDASection for more information on sections. To remove a
            section, use hou.HDASection.destroy.

            Sections can have associated properties stored in the
            hou.HDADefinition.extraFileOptions.

          > def addSectionFromFile(hda_definition, section_name, file_name):
          >     '''Add a section whose contents come from a file.  If the section
          >        already exists, replace its contents.'''
          >     section_file = open(file_name, \"r\")
          >     hda_definition.addSection(section_name, section_file.read())
          >     section_file.close()

        """
        return _hou.HDADefinition_addSection(self, *args)

    def removeSection(self, name: "char const *") -> "void":
        r"""

        removeSection(self, name)

            Remove an existing section. Only remove sections that you explicitly
            added. Do not remove the special sections that Houdini uses to store
            the contents of the digital asset definition, or Houdini will
            generate errors or strange side effects.

            See hou.HDASection for more information on sections. Note that
            hou.HDASection.destroy will also remove a section.

            Raises hou.OperationFailed if no such section exists in the
            definition.


        """
        return _hou.HDADefinition_removeSection(self, name)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return the description for this definition's node type. Houdini uses
            this description for user interface elements such as the TAB menu.
            This description is also called the operator label in Houdini.

            See also hou.NodeType.description.


        """
        return _hou.HDADefinition_description(self)

    def setDescription(self, label: "char const *") -> "void":
        r"""

        setDescription(self, description)

            Set the description for this definition's node type. Houdini uses
            this description for user interface elements such as the TAB menu.
            This description is also called the operator label in Houdini.

            See also hou.HDADefinition.description and hou.NodeType.description.


        """
        return _hou.HDADefinition_setDescription(self, label)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> str

            Return the name or path of the icon for this definition's node type.
            Note that Houdini uses its search path to locate icons, so you do
            not need to pass in a full path.

            See also hou.NodeType.icon.


        """
        return _hou.HDADefinition_icon(self)

    def setIcon(self, icon: "char const *") -> "void":
        r"""

        setIcon(self, icon)

            Set the icon for this definition's node type. See
            hou.HDADefinition.icon for more information.


        """
        return _hou.HDADefinition_setIcon(self, icon)

    def minNumInputs(self) -> "int":
        r"""

        minNumInputs(self) -> int

            Return the minimum number of connected inputs that node instances of
            this digital asset can have. If these inputs are not connected, the
            node will generate an error.

            See also hou.NodeType.minNumInputs.


        """
        return _hou.HDADefinition_minNumInputs(self)

    def setMinNumInputs(self, min_num_inputs: "int") -> "void":
        r"""

        setMinNumInputs(self, min_num_inputs)

            Set the minimum number of connected inputs that node instances of
            this digital asset must have. min_num_inputs must be between 0 and
            4, inclusive. If a node does not have the minimum number of inputs,
            it will generate an error.


        """
        return _hou.HDADefinition_setMinNumInputs(self, min_num_inputs)

    def maxNumInputs(self) -> "int":
        r"""

        maxNumInputs(self) -> int

            Return the maximum number of inputs that node instances of this
            digital asset can have. Return a number greater than 4 if this node
            type can accept an unlimited number of inputs.

            See also hou.NodeType.maxNumInputs.


        """
        return _hou.HDADefinition_maxNumInputs(self)

    def setMaxNumInputs(self, max_num_inputs: "int") -> "void":
        r"""

        setMaxNumInputs(self, max_num_inputs)

            Set the maximum number of inputs that node instances of this digital
            asset may have. This number must be greater than or equal to the
            minimum number of inputs. If it is 5 or greater, Houdini will use a
            merge SOP-style input connector that allows an unlimited number of
            inputs. Otherwise, the node will have between 0 and 4 input
            connectors, each of which may or may not be connected, that
            correspond to the subnet indirect inputs inside the digital asset.

            See hou.Node.inputConnectors and hou.SubnetIndirectInput for more
            information on input connectors and subnet indirect inputs.


        """
        return _hou.HDADefinition_setMaxNumInputs(self, max_num_inputs)

    def maxNumOutputs(self) -> "int":
        r"""

        maxNumOutputs(self) -> int

            Return the maximum number of outputs that node instances of this
            digital asset can have.

            See also hou.NodeType.maxNumOutputs.


        """
        return _hou.HDADefinition_maxNumOutputs(self)

    def setMaxNumOutputs(self, max_num_outputs: "int") -> "void":
        r"""

        setMaxNumOutputs(self, max_num_outputs)

            Set the maximum number of outputs that node instances of this
            digital asset may have.


        """
        return _hou.HDADefinition_setMaxNumOutputs(self, max_num_outputs)

    def extraInfo(self) -> "std::string":
        r"""

        extraInfo(self) -> str

            Return a string storing extra information about the asset definition
            that isn't stored elsewhere, like the representative node, guide
            geometry, whether default parameters are hidden, etc.

            See also hou.HDADefinition.representativeNodePath and
            hou.HDADefinition.hideDefaultParameters to more easily retrieve some
            portions of the extra info.


        """
        return _hou.HDADefinition_extraInfo(self)

    def setExtraInfo(self, extra_info: "char const *") -> "void":
        r"""

        setExtraInfo(self, extra_info)

            Set extra information about the asset definition that isn't stored
            elsewhere, like the representative node, guide geometry, etc. This
            string is encoded in a specific format, so it is recommended that
            you only call this method with values returned from
            hou.HDADefinition.extraInfo.


        """
        return _hou.HDADefinition_setExtraInfo(self, extra_info)

    def userInfo(self) -> "std::string":
        r"""

        userInfo(self) -> str

            Return a string containing user specified information about the
            asset definition.


        """
        return _hou.HDADefinition_userInfo(self)

    def setUserInfo(self, extra_info: "char const *") -> "void":
        r"""

        setUserInfo(self, extra_info)

            Set user information about the asset definition. This info isn't
            used by Houdini so it can contain any text.


        """
        return _hou.HDADefinition_setUserInfo(self, extra_info)

    def hideDefaultParameters(self) -> "bool":
        r"""

        hideDefaultParameters(self) -> bool

            Return whether the parameters that are common to nodes types in this
            node type category are hidden or not. For example, nearly all
            objects have common translation, rotation, scale, etc. parameters,
            and object level digital assets have these parameters by default. If
            hidden, though, these parameters are still there but are not
            displayed to the user.

            Note that this value is also stored in the string returned by
            hou.HDADefinition.extraInfo.


        """
        return _hou.HDADefinition_hideDefaultParameters(self)

    def representativeNodePath(self) -> "std::string":
        r"""

        representativeNodePath(self) -> str

            Return the contents of the Representative Node field on the Basic
            tab of the Type Properties dialog.

            For object-level digital assets that contain other object nodes, it
            is possible to make Houdini treat your digital asset like a camera
            or light by choosing a node inside the asset to represent it. For
            example, if you choose a camera inside the asset as the
            representative node, instances of the digital asset will appear in
            the viewport's list of camera objects.

            Note that this value is also stored in the string returned by
            hou.HDADefinition.extraInfo.


        """
        return _hou.HDADefinition_representativeNodePath(self)

    def comment(self) -> "std::string":
        return _hou.HDADefinition_comment(self)

    def setComment(self, comment: "char const *") -> "void":
        return _hou.HDADefinition_setComment(self, comment)

    def version(self) -> "std::string":
        return _hou.HDADefinition_version(self)

    def setVersion(self, version: "char const *") -> "void":
        return _hou.HDADefinition_setVersion(self, version)

    def modificationTime(self) -> "int":
        r"""

        modificationTime(self) -> int

            Return the time when the definition was last modified. This time is
            returned as a POSIX timestamp, such as is returned by time.time().

          > >>> import time
          > >>> time.ctime(hou.nodeType(hou.objNodeTypeCategory(), \"toon_character\").
          > ...     definition().modificationTime())
          > 'Thu Nov  6 18:22:38 2008'

        """
        return _hou.HDADefinition_modificationTime(self)

    def setModificationTime(self, time: "int" = -1) -> "void":
        r"""

        setModificationTime(self, time=-1)

            Set the modification time for the definition to the given POSIX
            timestamp. If the time parameter is negative, uses the current time.

            See also hou.HDADefinition.modificationTime.


        """
        return _hou.HDADefinition_setModificationTime(self, time)

    def options(self) -> "HOM_HDAOptions *":
        r"""

        options(self) -> hou.HDAOptions

            Return a hou.HDAOptions object for the options stored in this
            digital asset. See hou.HDAOptions for more information.


        """
        return _hou.HDADefinition_options(self)

    def setOptions(self, options: "HDAOptions") -> "void":
        r"""

        setOptions(self, options)

            Set this digital asset definition's options to the data in a
            hou.HDAOptions object. See hou.HDAOptions for more information.


        """
        return _hou.HDADefinition_setOptions(self, options)

    def updateFromNode(self, node: "Node") -> "void":
        r"""

        updateFromNode(self, node)

            Update and save the definition to match the contents of a given
            unlocked instance of the asset. Calling this method is the same as
            selecting Save Operator Type on the node's menu.

          > def saveUnlockedNodes():
          >     '''Look through all the nodes in the file for unlocked digital asset
          >        instances and save and lock them.'''
          >     for node in hou.node(\"/\").allSubChildren():
          >         if node.type().definition() is None or node.matchesCurrentDefinition():
          >             continue
          >
          >         node.type().definition().updateFromNode(node)
          >         node.matchCurrentDefinition()

        """
        return _hou.HDADefinition_updateFromNode(self, node)

    def save(
        self,
        file_name: "std::string const &",
        template_node: "Node" = None,
        options: "HDAOptions" = None,
        black_box: "bool" = False,
        create_backup: "bool" = True,
    ) -> "void":
        r"""

        save(self, file_name, template_node=None, options=None, black_box=False,
        create_backup=True)

            Save the definition into an hda file.


            file_name
                Where to save the definition. To save to the current hda file,
                use the return value from hou.HDADefinition.libraryFilePath.

            template_node
                Either None or a hou.Node object containing an unlocked instance
                of the digital asset that defines the definition's new contents.
                If None, this method does not update the definition's contents.

            options
                Either None or a hou.HDAOptions object that specifies extra
                behaviors of the definition. If template_node is not None, the
                compressContents, lockContents, saveSpareParms, and
                makeInitialParmsDefaults values of the hou.HDAOptions object are
                used. Otherwise, only the compressContents value is used.

            black_box
                If True, then the asset is saved as a black box asset that
                cannot be unlocked or edited. This parameter only applies if the
                template_node parameter is not None. The contents of the
                template node are compiled and saved into the black box asset.

            create_backup
                Create a backup before modifying existing hda files.

            See also hou.HDADefinition.updateFromNode for a way to save an
            unlocked node's definition to the current hda file. See also
            hou.HDADefinition.copyToHDAFile.


        """
        return _hou.HDADefinition_save(
            self, file_name, template_node, options, black_box, create_backup
        )

    def copyToHDAFile(
        self,
        file_name: "std::string const &",
        new_name: "char const *" = None,
        new_menu_name: "char const *" = None,
    ) -> "void":
        r"""

        copyToHDAFile(self, file_name, new_name=None, new_menu_name=None)

            Copy this definition into an hda file.


            file_name
                The hda file where the definition will be saved. If the file
                does not already exist, it will be created. If it already
                contains a definition for this node type, it will be
                overwritten.

            new_name
                The new name of the node type. If None, the definition will be
                saved as the existing node type name. See also
                hou.NodeType.name.

            new_menu_name
                The new description of the node type that appears in the tab
                menu. If None, Houdini will use the existing description. Note
                that the node type name must be unique within the hda file, so
                saving the definition with a new description to an hda file
                containing a definition with the old node name will still
                overwrite the existing definition. See also
                hou.NodeType.description.


        """
        return _hou.HDADefinition_copyToHDAFile(
            self, file_name, new_name, new_menu_name
        )

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Uninstall this definition and delete it from the hda file. Any node
            instances of this asset will warn that they are using an incomplete
            asset definition.

            See also hou.hda.uninstallFile.


        """
        return _hou.HDADefinition_destroy(self)

    def parmTemplateGroup(self) -> "HOM_ParmTemplateGroup *":
        r"""

        parmTemplateGroup(self) -> hou.ParmTemplateGroup

            Return the group of parm templates corresponding to the current
            parameter layout for this node.

            You can edit the parameter layout for this node (add or remove spare
            parameters, reorder or hide built-in parameters, etc.) by getting
            the current parameter group, modifying it, and calling
            hou.Node.setParmTemplateGroup with it.

            The following example creates a geometry object, adds a My Parms
            folder to it, and adds a My Parm float parameter to it in that
            folder. The parameters are added only to the geometry object
            created; other geometry objects are unaffected.

          > >>> node = hou.node(\"/obj\").createNode(\"geo\")
          > >>> group = node.parmTemplateGroup()
          > >>> folder = hou.FolderParmTemplate(\"folder\", \"My Parms\")
          > >>> folder.addParmTemplate(hou.FloatParmTemplate(\"myparm\", \"My Parm\", 1))
          > >>> group.append(folder)
          > >>> node.setParmTemplateGroup(group)

            See hou.ParmTemplateGroup and the setParmTemplateGroup method for
            more information and examples.


        """
        return _hou.HDADefinition_parmTemplateGroup(self)

    def setParmTemplateGroup(
        self,
        parm_template_group: "ParmTemplateGroup",
        rename_conflicting_parms: "bool" = False,
        create_backup: "bool" = True,
    ) -> "void":
        r"""

        setParmTemplateGroup(self, parm_template_group,
        rename_conflicting_parms=False)

            Change the spare parameters for this node.


            parm_template_group
                A hou.ParmTemplateGroup object containing the new parameter
                layout.

            rename_conflicting_parms
                If True, parameters in the group with the same parm tuple names
                will be automatically renamed. If False and there are parms with
                the same name, this method raises hou.OperationFailed.

            Note that each node type has a set of parameters which must exist
            and must be of certain types. If your parm template group does not
            contain the required parameters for the node type the will be added
            at the bottom and will be made invisible. Similarly, if your parm
            template group attempts to modify the type, range, label, or other
            property of a required parameter, all changes to that parameter
            other than visibility settings will be ignored.

            This method is preferred over the other parameter-related methods in
            this class (addSpareParmTuple, removeSpareParmTuple,
            replaceSpareParmTuple, addSpareParmFolder, removeSpareParmFolder)
            because it lets you more easily make manipulate parameters.

            See hou.HDADefinition.setParmTemplateGroup to change the parameter
            interface of a digital asset.


        """
        return _hou.HDADefinition_setParmTemplateGroup(
            self, parm_template_group, rename_conflicting_parms, create_backup
        )

    def setExtraFileOption(self, *args) -> "void":
        r"""

        setExtraFileOption(self, name, value, type_hint =
        hou.fieldType::NoSuchField)

            Set an entry in the dictionary of extra file options. See
            hou.HDADefinition.extraFileOptions for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.

            The following example function marks an section, such as OnCreated,
            as containing Python code:

          > def markSectionAsPython(definition, section_name):
          >     definition.setExtraFileOption(section_name + \"/IsPython\", True)

        """
        return _hou.HDADefinition_setExtraFileOption(self, *args)

    def removeExtraFileOption(self, name: "char const *") -> "void":
        r"""

        removeExtraFileOption(self, name)

            Remove an entry in the dictionary of extra file options. See
            hou.HDADefinition.extraFileOptions for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
        return _hou.HDADefinition_removeExtraFileOption(self, name)

    def compileCodeSection(
        self, source_section: "char const *", destination_section: "char const *"
    ) -> "void":
        r"""

        compileCodeSection(self, source_section, destination_section)

            This function is deprecated. Compiled VEX code should no longer be
            stored inside of an HDA.


        """
        return _hou.HDADefinition_compileCodeSection(
            self, source_section, destination_section
        )

    def extraFileOptions(self) -> "InterpreterObject":
        r"""

        extraFileOptions(self) -> dict of str to bool, int, float, str

            Return a dictionary containing the extra options attached to
            sections in the asset's definition. For example, event handler
            scripts such as OnCreated are stored as sections inside the asset,
            and extra metadata in this dictionary determines whether Houdini
            runs these scripts as Python as as Hscript.

            These is one dictionary for the entire asset, and keys in this
            dictionary are usually of the form section_name/option_name. For
            example, if the OnCreated section is marked as containing Python
            code, this dictionary will contain OnCreated/IsPython set to True.

            Note that the contents of this dictionary are saved in the
            ExtraFileOptions section and are encoded in a binary format.

            See also hou.HDADefinition.setExtraFileOption and
            hou.HDADefinition.removeExtraFileOption.


        """
        return _hou.HDADefinition_extraFileOptions(self)


# Register HDADefinition in _hou:
_hou.HDADefinition_swigregister(HDADefinition)


class HDAModule(object):
    r"""

    hou.HDAModule

    User-defined Python module containing functions, classes, and constants
    that are stored with and accessed from a digital asset.

    In Python, a module lets you organize functions, classes, and constants
    into a common namespace. For example, os is a module and os.getcwd is a
    function inside that module, and you access the contents of a module by
    looking up Python attributes on it.

    An HDAModule is a Python module that is associated with a particular
    digital asset type. It lets you store a library of Python code in one
    location in your asset, and you can invoke that code from parameters,
    event handlers, and callbacks inside that asset.

    The module's source code is stored in the Python Module section of the
    Scripts tab in the Type Properties dialog. For example, suppose the
    digit asset is an object named gear and the Python Module section
    contains the following:

    > def position():
    >     return (hou.frame() * 1.2, 0.0, 3.2)
    >
    > def onButtonPress():
    >     print \"you pressed the button\"
    >
    > def onLoaded():
    >     print \"onLoaded section running\"

    Unlike regular Python modules, which you access by name, you access a
    digital asset's Python module by calling hou.NodeType.hdaModule on its
    node type. For example, suppose you created an object-level digital
    asset named gear and put the above code in its Python Module section.
    You could then access the contents of the Python module as follows:

    > >>> node_type = hou.nodeType(hou.objNodeTypeCategory(), \"gear\")
    > >>> node_type.hdaModule().position()
    > (1.2, 0.0, 3.2)
    > >>> node_type.hdaModule().onButtonPress()
    > you pressed the button

    One use for the Python module is drive parameter expressions on nodes
    inside the digital asset. For example, suppose /obj/gear1 is an instance
    of the digital asset and /obj/gear1/geo1 is a node inside the asset. You
    could put the following inside geo1's tx parameter expression:

    > hou.node(\"..\").type().hdaModule().position()[0]

    For convenience, you can also access the module from a node instance of
    the digital asset using hou.Node.hdaModule. So, you could simplify the
    above expression to:

    > hou.node(\"..\").hdaModule().position()[0]

    And since you don't need to use the hou. prefix inside expressions, you
    could further simplify it to:

    > node(\"..\").hdaModule().position()[0]

    The following example shows how you might run code in the module from
    the Callback Script field of a button parameter:

    > hou.pwd().hdaModule().onButtonPress()

    In an event handler script, such as On Loaded, you can use the kwargs
    dict to access the node type:

    > kwargs[\"type\"].hdaModule().onLoaded()

    Note that Houdini creates a local kwargs dict that's accessible from the
    Python Module, too. It contains one entry with the key \"type\", to give
    you access to the hou.NodeType defined by the digital asset.

    If you find that a digital asset has too much Python code to store in
    one module, it's possible to create submodules. For example, if you want
    to create a submodule named bar, put its source code in a new digital
    asset section (say, \"bar_PythonModule\"). Then, from the Python Module
    section, you can write the following:

    > import toolutils
    > bar = toolutils.createModuleFromSection(\"bar\", kwargs[\"type\"], \"bar_PythonModule\")

    NOTE
        New to Houdini 18.0, the createModuleFromSection function expects
        the code in the HDA section to have Python 3 style print statements.

        In general this means that print statements in the HDA section must
        have the arguments enclosed in parentheses.


        For example
          > print(\"Hello world!\")
        instead of
          > print \"Hello world!\"
    bar now appears as a submodule of the main module. If, for example, the
    bar_PythonModule section contains:

    > def foo():
    >     return 3.2

    then you could write the following from a parameter on the digital asset
    node:

    > pwd().hdaModule().bar.foo()

    Note that the Python Module code is stored in a section of the digital
    asset named \"PythonModule\". For example, you can get a string containing
    that source code using
    node_type.definition().sections()[\"PythonModule\"].contents().


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_HDAModule

    def __repr__(self) -> "std::string":
        return _hou.HDAModule___repr__(self)

    def _reload(self) -> "void":
        return _hou.HDAModule__reload(self)

    def __getattr__(self, name: "char const *") -> "InterpreterObject":
        return _hou.HDAModule___getattr__(self, name)


# Register HDAModule in _hou:
_hou.HDAModule_swigregister(HDAModule)


class HDAOptions(object):
    r"""

    hou.HDAOptions

    Stores miscellaneous options about a houdini digital asset (HDA).

    The contents of this object correspond to some of the checkboxes on the
    Basic tab of the Type Properties dialog. These values are stored in the
    TypePropertiesOptions section of a digital asset definition.

    Call hou.HDADefinition.options to get an HDAOptions instance. Note that
    an instance of this class is simply a data structure, and is not
    associated with an particular digital asset instance. In other words,
    changing the values inside this object will not change the digital
    asset. To save these values to the digital asset definition, call
    hou.HDADefinition.setOptions.

    > >>> node = hou.node(\"/obj/my_digital_asset1\")
    > >>> definition = node.type().definition()
    > >>> print definition.sections()['TypePropertiesOptions'].contents()
    > ParmsFromVfl := 0;
    > PrefixDroppedParmName := 1;
    > UseDSParms := 1;
    > ForbidOutsideParms := 1;
    > LockContents := 1;
    > SaveSpareParms := 0; # <-- Currently 0
    > CheckExternal := 1;
    > GzipContents := 1;
    > MakeDefault := 1;
    > PrefixDroppedParmLabel := 1;
    > UnlockOnCreate := 0;
    >
    > >>> options = definition.options()
    > >>> options.saveSpareParms()
    > False
    > >>> options.setSaveSpareParms(True)
    > >>> definition.setOptions(options)
    > >>> print definition.sections()['TypePropertiesOptions'].contents()
    > ParmsFromVfl := 0;
    > PrefixDroppedParmName := 1;
    > UseDSParms := 1;
    > ForbidOutsideParms := 1;
    > LockContents := 1;
    > SaveSpareParms := 1; # <-- Now 1
    > CheckExternal := 1;
    > GzipContents := 1;
    > MakeDefault := 1;
    > PrefixDroppedParmLabel := 1;
    > UnlockOnCreate := 0;

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__(self)

            Create an HDAOptions object with default settings.

            See the class documentation for more information.


        """
        _hou.HDAOptions_swiginit(self, _hou.new_HDAOptions())

    def __eq__(self, options: "HOM_PtrOrNull< HOM_HDAOptions >") -> "bool":
        return _hou.HDAOptions___eq__(self, options)

    def __ne__(self, options: "HOM_PtrOrNull< HOM_HDAOptions >") -> "bool":
        return _hou.HDAOptions___ne__(self, options)

    def __hash__(self) -> "int":
        return _hou.HDAOptions___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.HDAOptions___repr__(self)

    def checkForExternalLinks(self) -> "bool":
        r"""

        checkForExternalLinks(self) -> bool

            Return whether the Check for External Node References option is set.

            If set, this option changes all absolute node references inside the
            digital asset into relative references.


        """
        return _hou.HDAOptions_checkForExternalLinks(self)

    def setCheckForExternalLinks(self, on: "bool") -> "void":
        r"""

        setCheckForExternalLinks(self, check_for_external_links)

            Sets the Check for External Node References option. See
            hou.HDAOptions.checkForExternalLinks for more information.


        """
        return _hou.HDAOptions_setCheckForExternalLinks(self, on)

    def compressContents(self) -> "bool":
        r"""

        compressContents(self) -> bool

            Return whether the Compress Contents option is on.

            When this option is set, Houdini compresses the contents of the
            asset definition to reduce the size of the .hda file. Note that this
            option only as effect when the result of hou.HDAOptions.lockContents
            is True.


        """
        return _hou.HDAOptions_compressContents(self)

    def setCompressContents(self, on: "bool") -> "void":
        r"""

        setCompressContents(self, compress_contents)

            Sets the Compress Contents option. See
            hou.HDAOptions.compressContents for more information.


        """
        return _hou.HDAOptions_setCompressContents(self, on)

    def compressionType(self) -> "int":
        return _hou.HDAOptions_compressionType(self)

    def setCompressionType(self, type: "int") -> "void":
        return _hou.HDAOptions_setCompressionType(self, type)

    def forbidOutsideParms(self) -> "bool":
        r"""

        forbidOutsideParms(self) -> bool

            Return whether the Forbid Linking Parameters from Outside this
            Subnet option is set.

            When set, this option does not allow you to drag parameters from
            nodes outside the contents of the digital asset.


        """
        return _hou.HDAOptions_forbidOutsideParms(self)

    def setForbidOutsideParms(self, on: "bool") -> "void":
        r"""

        setForbidOutsideParms(self, forbid_outside_parms)

            Sets the Forbid Linking Parameters from Outside this Subnet option.
            See hou.HDAOptions.forbidOutsideParms for more information.


        """
        return _hou.HDAOptions_setForbidOutsideParms(self, on)

    def lockContents(self) -> "bool":
        r"""

        lockContents(self) -> bool

            Return whether the Save Contents as Locked option is on.

            When this option is not set, Houdini will use a creation script to
            store the contents of the digital asset instead of storing the node
            data. A creation script cannot store extra data like locked SOPs,
            edit SOP information, paint SOP information, etc.

            If this option is not set, new instances of the digital asset will
            be locked, so the user can edit the contents. However, you probably
            do not ever want to turn this option off. Instead, if you want to
            lock new instances of the digital asset, see
            hou.HDAOptions.unlockNewInstances.


        """
        return _hou.HDAOptions_lockContents(self)

    def setLockContents(self, on: "bool") -> "void":
        r"""

        setLockContents(self, lock_contents)

            Sets the Save Contents as Locked option. See
            hou.HDAOptions.lockContents for more information.


        """
        return _hou.HDAOptions_setLockContents(self, on)

    def makeInitialParmsDefaults(self) -> "bool":
        r"""

        makeInitialParmsDefaults(self) -> bool

            Return whether the Save Defaults as Initial Parameters option is on.

            When set, this option uses the default values of the original
            parameters as the initial values for new nodes, instead of their
            current values.


        """
        return _hou.HDAOptions_makeInitialParmsDefaults(self)

    def setMakeInitialParmsDefaults(self, on: "bool") -> "void":
        r"""

        setMakeInitialParmsDefaults(self, make_initial_parms_defaults)

            Sets the Save Defaults as Initial Parameters option. See
            hou.HDAOptions.makeInitialParmsDefaults for more information.


        """
        return _hou.HDAOptions_setMakeInitialParmsDefaults(self, on)

    def parametersFromVexCode(self) -> "bool":
        r"""

        parametersFromVexCode(self) -> bool

            Return whether the Get Properties from VEX Code option is on.

            When this option is set, most properties and parameters of the
            operator come from pragma statements in the VEX source code.


        """
        return _hou.HDAOptions_parametersFromVexCode(self)

    def setParametersFromVexCode(self, on: "bool") -> "void":
        r"""

        setParametersFromVexCode(self, parameters_from_vex_code)

            Sets the Get Properties from VEX Code option. See
            hou.HDAOptions.parametersFromVexCode for more information.


        """
        return _hou.HDAOptions_setParametersFromVexCode(self, on)

    def prefixDroppedParmLabels(self) -> "bool":
        return _hou.HDAOptions_prefixDroppedParmLabels(self)

    def setPrefixDroppedParmLabels(self, on: "bool") -> "void":
        r"""

        setPrefixDroppedParmLabels(self, prefix_dropped_parm_labels)

            Sets the Prefix Dropped Parameter Labels option. See
            hou.HDAOptions.prefixDroppedParmLabels for more information.


        """
        return _hou.HDAOptions_setPrefixDroppedParmLabels(self, on)

    def prefixDroppedParmNames(self) -> "bool":
        r"""

        prefixDroppedParmNames(self) -> bool

            Return whether the Prefix Dropped Parameter Names option is on.

            When this option is set, Houdini will not include a prefix on
            parameter names when you drag and drop parameters into the Existing
            Parameters areas of the Parameters tab of the Type Properties
            dialog.

            See also hou.HDAOptions.prefixDroppedParmLabels.


        """
        return _hou.HDAOptions_prefixDroppedParmNames(self)

    def setPrefixDroppedParmNames(self, on: "bool") -> "void":
        r"""

        setPrefixDroppedParmNames(self, prefix_dropped_parm_names)

            Sets the Prefix Dropped Parameter Names option. See
            hou.HDAOptions.prefixDroppedParmNames for more information.


        """
        return _hou.HDAOptions_setPrefixDroppedParmNames(self, on)

    def saveInitialParmsAndContents(self) -> "bool":
        r"""

        saveInitialParmsAndContents(self) -> bool

            Return whether the Save Initial Contents and Parameters option is
            on.

            When this option is set, Houdini saves any parameter values and node
            contents referenced by the digital asset to be saved as part of the
            asset's definition.


        """
        return _hou.HDAOptions_saveInitialParmsAndContents(self)

    def setSaveInitialParmsAndContents(self, on: "bool") -> "void":
        r"""

        setSaveInitialParmsAndContents(self, save_initial_parms_and_contents)

            Set the Save Initial Contents and Parameters option. See
            hou.HDAOptions.saveInitialParmsAndContents for more information.


        """
        return _hou.HDAOptions_setSaveInitialParmsAndContents(self, on)

    def unlockNewInstances(self) -> "bool":
        r"""

        unlockNewInstances(self) -> bool

            Return whether the Unlock New Nodes on Creation option is set.

            When this option is set, Houdini will unlock new instances of the
            digital asset when they are created. Note that this option only has
            effect when the result of hou.HDAOptions.lockContents is True.


        """
        return _hou.HDAOptions_unlockNewInstances(self)

    def setUnlockNewInstances(self, on: "bool") -> "void":
        r"""

        setUnlockNewInstances(self, unlock_new_instances)

            Sets the Unlock New Nodes on Creation option. See
            hou.HDAOptions.unlockNewInstances for more information.


        """
        return _hou.HDAOptions_setUnlockNewInstances(self, on)

    def saveSpareParms(self) -> "bool":
        r"""

        saveSpareParms(self) -> bool

            Return the Save Spare Parameters option.

            When set, this option will add code into the asset creation script
            to recreate the node's current spare parameters. New node instances
            of the digital asset will contain the same spare parameters as those
            on the representative node.


        """
        return _hou.HDAOptions_saveSpareParms(self)

    def setSaveSpareParms(self, on: "bool") -> "void":
        r"""

        setSaveSpareParms(self, save_spare_parms)

            Set the Save Spare Parameters option. See
            hou.HDAOptions.saveSpareParms for more information.


        """
        return _hou.HDAOptions_setSaveSpareParms(self, on)

    def saveCachedCode(self) -> "bool":
        r"""

        saveCachedCode(self) -> bool

            Return the Save Cached Code option.

            When set, this option will save cached code for applicable
            definitions, such as digital assets defined by VOP networks that
            generate VEX code. With this option on, the compiled code will be
            saved to the HDA section(s) and will be used for shaders, etc,
            without the need to recompile the network. This can save significant
            amounts of time for complex shaders.


        """
        return _hou.HDAOptions_saveCachedCode(self)

    def setSaveCachedCode(self, on: "bool") -> "void":
        r"""

        setSaveCachedCode(self, save_cached_code)

            Set the Save Cached Code option. See hou.HDAOptions.saveCachedCode
            for more information.


        """
        return _hou.HDAOptions_setSaveCachedCode(self, on)

    __swig_destroy__ = _hou.delete_HDAOptions


# Register HDAOptions in _hou:
_hou.HDAOptions_swigregister(HDAOptions)


class HDASection(object):
    r"""

    hou.HDASection

    Represents a section of data stored along with a digital asset.

    A digital asset stores its contents in a number of different pieces of
    data called sections. Each section is named and contains an arbitrarily
    sized piece of data, often textual. Each section is like a file embedded
    inside the definition, and Houdini uses specially named sections to
    store the node contents, list of parameters, etc. You can embed your own
    data into a digital asset by putting it inside a section.

    Any parameter in Houdini that references a file can also reference a
    section inside a digital asset. For example, if car is an object-level
    digital asset and the section is named \"texture.jpg\", you can reference
    that texture with opdef:/Object/car?texture.jpg. Note that hou.readFile
    also supports this opdef: syntax.

    By moving files into digital asset sections, you can build self-
    contained digital assets that can be distributed via a single hda file.

    Note that section names may contain '/'.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_HDASection

    def __eq__(self, hda_section: "HOM_PtrOrNull< HOM_HDASection >") -> "bool":
        return _hou.HDASection___eq__(self, hda_section)

    def __ne__(self, hda_section: "HOM_PtrOrNull< HOM_HDASection >") -> "bool":
        return _hou.HDASection___ne__(self, hda_section)

    def __hash__(self) -> "int":
        return _hou.HDASection___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.HDASection___repr__(self)

    def definition(self) -> "HOM_HDADefinition *":
        r"""

        definition(self) -> hou.HDADefinition

            Return the digital asset definition containing this section.


        """
        return _hou.HDASection_definition(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this section.

            Note that is is not possible to rename a section, but the following
            function will emulate renaming:

          > def renameSection(section):
          >     '''Rename a section by removing it and creating a new one.  Return the new section.'''
          >     new_section = section.definition().addSection(new_name, section.contents())
          >     section.destroy()
          >     return new_section

        """
        return _hou.HDASection_name(self)

    def contents(self, *args, **kwargs) -> "std::string":
        r"""

        contents(self, compressionType=hou.compressionType.NoCompression) -> str

            Return a string containing the contents of this section.

            You can optionally specify a compression type, hou.compressionType,
            to decompress the contents.

            Raises hou.OperationFailed if a compression type is specified and
            the contents are not compressed by that type.

          > def saveSectionToFile(section, file_name):
          >     '''Given a section, save it to a file.'''
          >     section_file = file(file_name, \"w\")
          >     section_file.write(section.contents())
          >     section_file.close()

        """
        return _hou.HDASection_contents(self, *args, **kwargs)

    def binaryContents(self, *args, **kwargs) -> "HOM_BinaryString":
        r"""

        binaryContents(self, compressionType=hou.compressionType.NoCompression)
        -> bytes

            Only available in Python 3.

            Similar to hou.HDASection.contents but return a bytes object
            instead. Ideal for sections containing binary data.

          > def saveBinarySectionToFile(section, file_name):
          >     '''Given a section, save it to a file.'''
          >     section_file = file(file_name, \"wb\")
          >     section_file.write(section.binaryContents())
          >     section_file.close()

        """
        return _hou.HDASection_binaryContents(self, *args, **kwargs)

    def setContents(self, *args) -> "void":
        r"""

        setContents(self, contents,
        compressionType=hou.compressionType.NoCompression)

            Set the contents of this section to the given string. A section may
            contain binary information, like bgeo files, images, etc.

            You can optionally specify a compression type, hou.compressionType,
            to compress the contents. Note that you must specify the same
            compression type when reading the contents back to decompress them.

            For Python 3, the contents can be either a str object for plain text
            data or a bytes for binary data.

            See hou.HDADefinition.addSection for an example of how to create a
            section from a file on disk.


        """
        return _hou.HDASection_setContents(self, *args)

    def size(self) -> "int":
        r"""

        size(self) -> int

            Return the number of bytes in the contents. This method is a
            shortcut for len(self.contents()).


        """
        return _hou.HDASection_size(self)

    def modificationTime(self) -> "int64":
        r"""

        modificationTime(self) -> int

            Return the time when the section was last modified. This time is
            returned as a POSIX timestamp, such as is returned by time.time().

          > >>> hou.nodeType(hou.cop2NodeTypeCategory(), \"colorwheel\").definition()
          > <hou.HDADefinition of Cop2 colorwheel in /opt/hfs9.5/houdini/hda/OPlibCop2.hda>
          > >>> definition = hou.nodeType(hou.cop2NodeTypeCategory(), \"colorwheel\").definition()
          > >>> definition.sections().keys()
          > ['VflCode', 'DialogScript', 'VexCode']
          > >>> section = definition.sections()['VflCode']
          > >>> section.modificationTime()
          > 1177535169
          > >>> import datetime, time
          > >>> datetime.datetime.fromtimestamp(section.modificationTime())
          > datetime.datetime(2007, 4, 25, 17, 6, 9)
          > >>> time.ctime(section.modificationTime())
          > 'Wed Apr 25 17:06:09 2007'

        """
        return _hou.HDASection_modificationTime(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this section from the HDA definition. You can also remove a
            section with hou.HDADefinition.removeSection, and this method is
            equivalent to self.definition().removeSection(self.name()).

            Only remove sections that you explicitly added. Do not remove the
            special sections that Houdini uses to store the contents of the
            digital asset definition, or Houdini will generate errors or strange
            side effects.

            To add a section, use hou.HDADefinition.addSection.


        """
        return _hou.HDASection_destroy(self)


# Register HDASection in _hou:
_hou.HDASection_swigregister(HDASection)


class HDAViewerHandleModule(object):
    r"""

    hou.HDAViewerHandleModule

    User-defined Python module containing the implementation and
    registration code of a python viewer handle stored in a digital asset.

    HDAViewerHandleModule is similar to hou.HDAViewerStateModule but
    dedicated for python viewer handles. It is mainly used to access the
    python viewer handle module that is associated with a particular digital
    asset type. You don't normally need HDAViewerHandleModule for using
    python handles though, this object is typically used by Houdini for
    registering the python handles embedded in the digital asset.

    The python handle state module's source code is stored in the
    ViewerHandle Module section of the Interactive|Handle Script tab in the
    Type Properties dialog. The source code can be edited with the Handle
    script editor.

    See hou.Node.hdaViewerHandleModule and
    hou.NodeType.hdaViewerHandleModule for creating HDAViewerHandleModule
    instances.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_HDAViewerHandleModule

    def __repr__(self) -> "std::string":
        return _hou.HDAViewerHandleModule___repr__(self)

    def _reload(self) -> "void":
        return _hou.HDAViewerHandleModule__reload(self)

    def __getattr__(self, name: "char const *") -> "InterpreterObject":
        return _hou.HDAViewerHandleModule___getattr__(self, name)


# Register HDAViewerHandleModule in _hou:
_hou.HDAViewerHandleModule_swigregister(HDAViewerHandleModule)


class HDAViewerStateModule(object):
    r"""

    hou.HDAViewerStateModule

    User-defined Python module containing the implementation and
    registration code of a python viewer state stored in a digital asset.

    HDAViewerStateModule is similar to hou.HDAModule but dedicated for
    python viewer states. It is mainly used to access the python viewer
    state module that is associated with a particular digital asset type.
    You don't normally need HDAViewerStateModule for using python states
    though, this object is typically used by Houdini for registering the
    python states embedded in the digital asset.

    The python viewer state module's source code is stored in the
    ViewerState Module section of the Interactive|State Script tab in the
    Type Properties dialog. The source code can be edited with the State
    script editor.

    See hou.Node.hdaViewerStateModule and hou.NodeType.hdaViewerStateModule
    for creating HDAViewerStateModule instances.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_HDAViewerStateModule

    def __repr__(self) -> "std::string":
        return _hou.HDAViewerStateModule___repr__(self)

    def _reload(self) -> "void":
        return _hou.HDAViewerStateModule__reload(self)

    def __getattr__(self, name: "char const *") -> "InterpreterObject":
        return _hou.HDAViewerStateModule___getattr__(self, name)


# Register HDAViewerStateModule in _hou:
_hou.HDAViewerStateModule_swigregister(HDAViewerStateModule)


class HelpBrowser(PaneTab):
    r"""

    hou.HelpBrowser

    Class representing a help browser pane tab. Provides methods for
    controlling the help browser.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_HelpBrowser

    def __repr__(self) -> "std::string":
        return _hou.HelpBrowser___repr__(self)

    def displayHelp(self, node_type: "NodeType") -> "void":
        r"""

        displayHelp(self, node_type)

            Loads the help for the specified node type.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
        return _hou.HelpBrowser_displayHelp(self, node_type)

    def displayHelpPath(self, help_path: "char const *") -> "void":
        r"""

        displayHelpPath(self, help_path)

            Loads the help for the specified help path. The path can either be a
            Houdini help URL (i.e. op:Sop/copy, tool:curve) or a raw help path
            (i.e. /nodes/sop/copy, shelf/curve).


        """
        return _hou.HelpBrowser_displayHelpPath(self, help_path)

    def displayHelpPyPanel(self, interface_name: "char const *") -> "void":
        r"""

        displayHelpPyPanel(self, interface_name)

            Loads the help for the python panel with the specified name.

            Raises HOM_Error if the interface name is invalid.


        """
        return _hou.HelpBrowser_displayHelpPyPanel(self, interface_name)

    def homePage(self) -> "std::string":
        r"""

        homePage(self) -> str

            Returns the home page URL of this help browser.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
        return _hou.HelpBrowser_homePage(self)

    def setHomePage(self, home_page: "char const *") -> "void":
        r"""

        setHomePage(self, home_page)

            Sets the home page for this help browser to the specified URL.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted, and raises HOM_Error if home_page is not given.


        """
        return _hou.HelpBrowser_setHomePage(self, home_page)

    def url(self) -> "std::string":
        r"""

        url(self) -> str

            Return the current URL of this help browser.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
        return _hou.HelpBrowser_url(self)

    def setUrl(self, url: "char const *") -> "void":
        r"""

        setUrl(self, url)

            Loads the specified URL.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted, and raises HOM_Error if url is not given.


        """
        return _hou.HelpBrowser_setUrl(self, url)

    def showUI(self, show: "bool") -> "void":
        r"""

        showUI(self, show)

            Shows or hides the help browser's navigation controls.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
        return _hou.HelpBrowser_showUI(self, show)


# Register HelpBrowser in _hou:
_hou.HelpBrowser_swigregister(HelpBrowser)


class hipFile(object):
    r"""

    hou.hipFile

    Functions for working with the current scene (.hip) file.


    NOTE
        Houdini inherits the current directory (sometimes called the current
        working directory) from the environment where you run it. Some
        functions return or accept paths relative to the current directory.
        You can check Houdini's current directory by calling os.getcwd(),
        and change it by calling os.chdir.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_hipFile

    def __repr__(self) -> "std::string":
        return _hou.hipFile___repr__(self)

    def save(
        self, file_name: "char const *" = None, save_to_recent_files: "bool" = True
    ) -> "void":
        r"""

        save(file_name=None, save_to_recent_files=True)

            Saves the current scene to a .hip file.


            file_name
                If this is a string, saves the current scene to a file at this
                path, like File > Save As. The path can be absolute or relative
                to the current directory.

                If this is None, saves the scene to its current path
                (hou.hipFile.path), like File > Save.

                If intermediate directories in the path do not exist, Houdini
                will create them.

            save_to_recent_files
                In a graphical session, whether to add this file to the list of
                recent files in the File > Open Recent Files menu. The default
                is True.

                In a non-graphical session (hython), the function always acts
                like save_to_recent_files is off.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_save(self, file_name, save_to_recent_files)

    def saveAndIncrementFileName(self) -> "void":
        r"""

        saveAndIncrementFileName()

            Saves the scene to its current path (same as File > Save), but
            increments a number at the end of the filename.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_saveAndIncrementFileName(self)

    def saveAndBackup(self) -> "std::string":
        r"""

        saveAndBackup() -> str

            Saves the current scene but first creates a backup of the previous
            saved state to a backup file in $HOUDINI_BACKUP_DIR with _bak and an
            increasing number added before the .hip extension. If
            $HOUDINI_BACKUP_DIR is not set, then this method creates the backup
            file in a backup directory in the same directory as the scene file.

            Returns the absolute path of the backup file.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_saveAndBackup(self)

    def saveAsBackup(self) -> "std::string":
        r"""

        saveAsBackup() -> str

            Saves the current scene to a new file in $HOUDINI_BACKUP_DIR with
            _bak and an increasing number added before the .hip extension. If
            $HOUDINI_BACKUP_DIR is not set, this saves the file to a backup
            directory in the same directory as the scene file.

            Returns the absolute path of the backup file.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_saveAsBackup(self)

    def basename(self) -> "std::string":
        r"""

        basename() -> str

            Return the filename portion of the current scene's path (including
            the .hip extension).


        """
        return _hou.hipFile_basename(self)

    def name(self) -> "std::string":
        r"""

        name() -> str

            Return the path of the current hip file relative to the current
            directory. Remember that a file may not exist at this path if the
            current scene hasn't been saved yet.

            This function returns a relative path from the current directory.
            For example, if the current directory is /home/alyah/ and the
            current scene file is /home/alyah/Houdini/Projects/city.hip, this
            would return Houdini/Projects/city.hip. If the current scene file,
            this is the same as calling hou.hipFile.basename().

            If you want an absolute path to the current scene file, use
            Hom:hou.hipFile#path instead.


        """
        return _hou.hipFile_name(self)

    def path(self) -> "std::string":
        r"""

        path() -> str

            Return the absolute file path of the current scene file. Remember
            that a file may not exist at this path if the current scene hasn't
            been saved yet.


        """
        return _hou.hipFile_path(self)

    def setName(self, file_name: "char const *") -> "void":
        r"""

        setName(file_name)

            Sets the in-memory path of the current scene file. This is the path
            Houdini will save to if the user chooses File > Save or you call
            hou.hipFile.save without a file path.


            file_name
                The path to use. This can be an absolute path or relative to the
                current directory.

            This function does not save the scene, it only changes the path
            Houdini thinks the scene should be saved at. To actually save the
            scene to a new path, use hou.hipFile.save.


        """
        return _hou.hipFile_setName(self, file_name)

    def saveMode(self) -> "HOM_EnumValue &":
        r"""

        saveMode(self) -> hou.saveMode

            Return the save mode of the current scene, either
            hou.saveMode.Binary or hou.saveMode.Text.


        """
        return _hou.hipFile_saveMode(self)

    def setSaveMode(self, savemode: "EnumValue") -> "void":
        r"""

        setSaveMode(self, save_mode)

            Set the save mode of the current scene to either hou.saveMode.Binary
            or hou.saveMode.Text.


        """
        return _hou.hipFile_setSaveMode(self, savemode)

    def clear(self, suppress_save_prompt: "bool" = False) -> "void":
        r"""

        clear(suppress_save_prompt=False)

            Clears the contents of the current scene file, starting a new
            unsaved file.


            suppress_save_prompt
                Normally, in a graphical session, this function acts the same as
                if the user had chosen File > New, and prompts to save the
                current file if it has unsaved changes. You can force Houdini to
                clear without prompting by passing suppress_save_prompt=True.

                In a non-graphical session (hython), the function always acts
                like suppress_save_prompt is on.


        """
        return _hou.hipFile_clear(self, suppress_save_prompt)

    def load(
        self,
        file_name: "char const *",
        suppress_save_prompt: "bool" = False,
        ignore_load_warnings: "bool" = False,
    ) -> "void":
        r"""

        load(file_name, suppress_save_prompt=False, ignore_load_warnings=False)

            Loads a new scene (.hip) file.

            Raises hou.OperationFailed if Houdini cannot read the file.

            Raises hou.LoadWarning if loading the new file triggers warnings
            (such as missing assets). You can prevent these exceptions by
            passing ignore_load_warnings=True.


            file_name
                The path to the scene file to load.

            suppress_save_prompt
                Normally, in a graphical session, this function acts the same as
                if the user had chosen File > Open, and prompts to save the
                current file if it has unsaved changes. You can force Houdini to
                load the new file without prompting by passing
                suppress_save_prompt=True.

                In a non-graphical session (hython), the function always acts
                like suppress_save_prompt is on.

            ignore_load_warnings
                Prevents Houdini from raising hou.LoadWarning exceptions if
                loading the new file triggers warnings (such as missing assets).


        """
        return _hou.hipFile_load(
            self, file_name, suppress_save_prompt, ignore_load_warnings
        )

    def merge(self, *args, **kwargs) -> "void":
        r"""

        merge(file_name, node_pattern=\"*\", overwrite_on_conflict=False,
        ignore_load_warnings=False)

            Imports the contents of the file at path file_name into the current
            scene. (This does not save the current scene file.)

            Raises hou.LoadWarning if loading the new file triggers warnings
            (such as missing assets). You can prevent these exceptions by
            passing ignore_load_warnings=True.


            node_pattern
                Only merge in nodes matching this pattern.

            overwrite_on_conflict
                What to do if merged-in nodes have the same path/name as
                existing nodes. If this is True, merged in nodes replace
                existing nodes. If this is False (the default), merged in nodes
                are renamed if the conflict with existing nodes.

                See hou.hipFile.collisionNodesIfMerged to check for conflicts
                before merging.

            ignore_load_warnings
                Prevents Houdini from raising hou.LoadWarning exceptions if
                loading the new file triggers warnings (such as missing assets).

            Raises hou.OperationFailed if the file to merge doesn't exist or
            Houdini cannot read the file.

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_merge(self, *args, **kwargs)

    def collisionNodesIfMerged(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        collisionNodesIfMerged(file_name, node_pattern=\"*\") -> tuple of hou.Node

            Returns a sequence of hou.Node objects representing the nodes that
            would have conflicts if you tried to merge the given file with
            hou.hipFile.merge.


            node_pattern
                Only check nodes matching this pattern.

            Raises hou.OperationFailed if the file to merge doesn't exist or
            Houdini cannot read the file.

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_collisionNodesIfMerged(self, *args, **kwargs)

    def isLoadingHipFile(self) -> "bool":
        r"""

        isLoadingHipFile() -> bool

            Returns True if Houdini is currently loading a scene file.


        """
        return _hou.hipFile_isLoadingHipFile(self)

    def isShuttingDown(self) -> "bool":
        r"""

        isShuttingDown() -> bool

            Returns True if Houdini is currently exiting.


        """
        return _hou.hipFile_isShuttingDown(self)

    def isNewFile(self) -> "bool":
        r"""

        isNewFile() -> bool

            Returns whether the current Houdini file is a new file or is a
            previously loaded file.

            This function only works accurately in a graphical session. In a
            non-graphical session (hython) it will always return True if the
            filename matches the default filename.


        """
        return _hou.hipFile_isNewFile(self)

    def hasUnsavedChanges(self) -> "bool":
        r"""

        hasUnsavedChanges() -> bool

            Returns whether the current Houdini session has been modified since
            it was last saved. (This is sometimes referred to as the current
            file being dirty.)

            This function only works in a graphical session. In a non-graphical
            session (hython) it will always return True.


        """
        return _hou.hipFile_hasUnsavedChanges(self)

    def groupColorTable(
        self,
    ) -> "std::map< std::string,HOM_Color,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_Color > > >":
        r"""

        groupColorTable() -> dict of str to hou.Color

            Returns a dictionary of color overrides for the viewport group list.
            The viewport group list automatically assigns colors to groups based
            on a hash of the group name. The group color table is a dictionary
            of overrides to these default color assignments. This allows
            particular important groups to be assigned distinctive colors. The
            group color table is saved with the hip file. The color table can be
            modified with hou.hipFile.setGroupColorTable.


        """
        return _hou.hipFile_groupColorTable(self)

    def setGroupColorTable(
        self,
        color_table: "std::map< std::string,HOM_Color,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_Color > > > const &",
    ) -> "void":
        r"""

        setGroupColorTable(color_table)

            Sets a dictionary of color overrides for the viewport group list.
            The viewport group list automatically assigns colors to groups based
            on a hash of the group name. The group color table is a dictionary
            of overrides to these default color assignments. This allows
            particular important groups to be assigned distinctive colors. The
            group color table is saved with the hip file. The current color
            table can be queried with hou.hipFile.groupColorTable.

            The supplied color_table must be a dict of str to hou.Color. The
            following example will cause groups names 'special_group' to appear
            with a red overlay:

          > color_table = { 'special_group' : hou.Color([1,0,0]) }
          > hou.hipFile.setGroupColorTable(color_table)

        """
        return _hou.hipFile_setGroupColorTable(self, color_table)

    def importFBX(
        self, *args, **kwargs
    ) -> "std::pair< HOM_ElemPtr< HOM_Node >,std::string >":
        r"""

        importFBX(file_name, suppress_save_prompt=False, merge_into_scene=True,
        import_cameras=True, import_joints_and_skin=True, import_geometry=True,
        import_lights=True, import_animation=True, import_materials=True,
        resample_animation=False, resample_interval=1.0,
        override_framerate=False,framerate=-1,
        hide_joints_attached_to_skin=True,
        convert_joints_to_zyx_rotation_order=False,
        material_mode=hou.fbxMaterialMode.FBXShaderNodes,
        compatibility_mode=hou.fbxCompatibilityMode.Maya,
        single_precision_vertex_caches=False, triangulate_nurbs=False,
        triangulate_patches=False, import_global_ambient_light=False,
        import_blend_deformers_as_blend_sops=False,
        segment_scale_already_baked_in=True,
        convert_file_paths_to_relative=True, unlock_geometry=False,
        unlock_deformations=False, import_nulls_as_subnets=False,
        import_into_object_subnet=True,
        convert_into_y_up_coordinate_system=False, create_sibling_bones=True,
        override_scene_frame_range=False, convert_units=False) -> (hou.ObjNode,
        str)

            Imports the contents of an FBX file into the scene, like when the
            user chooses File > Import > FBX. Returns a tuple of the parent
            Subnetwork Object node containing the FBX nodes (see
            import_into_object_subnet option) and a string containing any
            generated load messages.

            Important: see the help for the FBX import dialog for information on
            the various options.


            import_into_object_subnet
                When this is True (the default), Houdini creates a new
                Subnetwork node at the object level and puts imported FBX nodes
                inside the subnet. If you pass import_into_object_subnet=False,
                Houdini creates the FBX nodes directly at the object level (and
                the first item in the returned tuple will be the /obj network
                node).

            Raises hou.OperationFailed if the file to merge doesn't exist or
            Houdini cannot read the file.

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
        return _hou.hipFile_importFBX(self, *args, **kwargs)

    def addEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addEventCallback(self, callback)

            Register a Python callback to be called whenever a .hip file event
            occurs (for example, file load, file save).


            callback
                Any callable Python object that expects one argument. The
                argument is an hou.hipFileEventType enum value.

            See how to write a scene event callback for more information.

          > def scene_event_callback(event_type):
          >     hou.ui.displayMessage(\"An event of type {} occured\".format(event_type))
          >
          > hou.hipFile.addEventCallback(scene_event_callback)

        """
        return _hou.hipFile_addEventCallback(self, callback)

    def removeEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeEventCallback(callback)

            Removes a Python callback that was previously registered with
            hou.hipFile.addEventCallback. See hou.hipFile.addEventCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
        return _hou.hipFile_removeEventCallback(self, callback)

    def clearEventCallbacks(self) -> "void":
        r"""

        clearEventCallbacks()

            Removes all Python callbacks that have been registered with
            hou.hipFile.addEventCallback.


        """
        return _hou.hipFile_clearEventCallbacks(self)

    def eventCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        eventCallbacks() -> tuple of callback

            Returns a tuple of all the callback functions that have been
            registered with hou.hipFile.addEventCallback.


        """
        return _hou.hipFile_eventCallbacks(self)


# Register hipFile in _hou:
_hou.hipFile_swigregister(hipFile)


class hmath(object):
    r"""

    hou.hmath

    Houdini and 3D related math functions.

    See hou.Geometry.transformPrims and hou.Matrix4.explode for matrix
    transform examples.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_hmath

    def __repr__(self) -> "std::string":
        return _hou.hmath___repr__(self)

    def identityTransform(self) -> "HOM_Matrix4 *":
        r"""

        identityTransform() -> hou.Matrix4

            Returns the identity matrix. This is the same as hou.Matrix4(1) but
            may make your code more understandable.

          > >>> hou.hmath.identityTransform()
          > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]>

            See hou.Matrix4.


        """
        return _hou.hmath_identityTransform(self)

    def buildTranslate(self, *args) -> "HOM_Matrix4 *":
        r"""

        buildTranslate(tx, ty, tz) -> hou.Matrix4

            Returns a transformation matrix containing only a translation. You
            can build more complex transformations by multiplying this with
            another transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3.

          > forward_z = hou.hmath.buildTranslate(0, 0, 1)
          > forward_x = hou.hmath.buildTranslate(hou.Vector3(1, 0, 0))

        """
        return _hou.hmath_buildTranslate(self, *args)

    def buildScale(self, *args) -> "HOM_Matrix4 *":
        r"""

        buildScale(sx, sy, sz) -> hou.Matrix4

            Returns a transformation matrix containing only a scale. You can
            build more complex transformations by multiplying this with another
            transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3. To apply a uniform scale, use the
            same value for x, y, and z.

          > stretch = hou.hmath.buildScale(2, 1, 1)
          > uniform = hou.hmath.buildScale(hou.Vector3(2, 2, 2))

            See hou.Geometry.createNURBSSurface for an example.


        """
        return _hou.hmath_buildScale(self, *args)

    def buildShear(self, *args) -> "HOM_Matrix4 *":
        r"""

        buildShear(shearx, sheary, shearz) -> hou.Matrix4

            Returns a transformation matrix containing only a shear. You can
            build more complex transformations by multiplying this with another
            transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3.

            See Wikipedia's shear matrix page for more information.


        """
        return _hou.hmath_buildShear(self, *args)

    def buildRotate(self, *args) -> "HOM_Matrix4 *":
        r"""

        buildRotate(rx, ry, rz, order=\"xyz\") -> hou.Matrix4

            Returns a transformation matrix containing only a rotation, given
            Euler angles in degrees. You can build more complex transformations
            by multiplying this with another transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3.

          > xform1 = hou.hmath.buildRotate(45, 45, 0)
          > xform2 = hou.hmath.buildRotate(hou.Vector3(90, 0, 90))

            order
                A string containing a permutation of the letters x, y, and z
                that controls the order of rotations.

            See Wikipedia's Euler angles page for more information.


        """
        return _hou.hmath_buildRotate(self, *args)

    def buildRotateAboutAxis(
        self, axis: "_DoubleTuple", angle_in_deg: "double"
    ) -> "HOM_Matrix4 *":
        r"""

        buildRotateAboutAxis(axis, angle_in_deg) -> hou.Matrix4

            Returns a transformation matrix containing only a rotation computed
            from an axis and a rotation amount. You can build more complex
            transformations by multiplying this with another transform matrix.


            axis
                A hou.Vector3 normal defining an axis to rotate around. For
                example, hou.Vector3(0, 1, 1) would rotate around a diagonal
                pointed along positive Y and Z.

            angle_in_deg
                Number of degrees of rotation around the axis to store in the
                matrix.

          > turn_45_around_yz = hou.hmath.buildRotateAboutAxis(hou.Vector3(0, 1, 1), 45)

            If you want to convert Euler angles into a corresponding axis and
            angle, you can use the following code:

          > def extractAxisAndAngleFromRotateMatrix(m):
          >     '''
          >     Given a matrix, return an (Vector3, float) tuple containing the
          >     axis and angle.  See Wikipedia's rotation representation page for
          >     more details.
          >     '''
          >
          >     import math
          >
          >     acos_input = (m.at(0, 0) + m.at(1, 1) + m.at(2, 2) - 1.0) * 0.5
          >     if acos_input < -1.0 or acos_input > 1.0:
          >         return None
          >
          >     angle = math.acos(acos_input)
          >     if angle >= -1e-6 and angle <= 1e-6:
          >         # There is no rotation.  Choose an arbitrary axis and a rotation of 0.
          >         return hou.Vector3(1, 0, 0), 0.0
          >
          >     inv_sin = 1.0 / (2.0 * math.sin(angle))
          >     axis = hou.Vector3(
          >         (m.at(1, 2) - m.at(2, 1)) * inv_sin,
          >         (m.at(2, 0) - m.at(0, 2)) * inv_sin,
          >         (m.at(0, 1) - m.at(1, 0)) * inv_sin)
          >     return axis, hou.hmath.radToDeg(angle)
          >
          > def eulerToAxisAndAngle(angles):
          >     return extractAxisAndAngleFromRotateMatrix(hou.hmath.buildRotate(angles))

            See Wikipedia's axis angle page and rotation representation page for
            more information.


        """
        return _hou.hmath_buildRotateAboutAxis(self, axis, angle_in_deg)

    def buildRotateZToAxis(self, axis: "_DoubleTuple") -> "HOM_Matrix4 *":
        r"""

        buildRotateZToAxis(axis) -> hou.Matrix4

            Returns a transformation matrix rotating the z-axis onto the given
            axis. You can build more complex transformations by multiplying this
            with another transform matrix.


            axis
                A hou.Vector3 defining an axis to rotate the z-axis to.

          > rotate_z_to_x = hou.hmath.buildRotateZToAxis(hou.Vector3(1, 0, 0))

            The rotation picked is the shortest rotation. If the goal vector is
            pointed the opposite direction of the z-axis, an arbitrary but
            consistent rotation that maps to the negative z-axis will be picked.


        """
        return _hou.hmath_buildRotateZToAxis(self, axis)

    def buildTransform(self, *args, **kwargs) -> "HOM_Matrix4 *":
        r"""

        buildTransform(values_dict, transform_order=\"srt\", rotate_order=\"xyz\")
        -> hou.Matrix4

            Takes a dictionary containing mapping strings to vectors (such as
            produced by hou.Matrix4.explode), and returns a hou.Matrix4
            transformation. You can use this to explode a matrix, modify one or
            a few components, and then recompose into a matrix, or to generate a
            matrix from scratch from a few components.

            The dictionary can contain any of the following keys: translate,
            rotate, scale, shear, pivot, pivot_rotate. The values can be
            hou.Vector3 objects or 3-tuples of floats.


            transform_order
                A string containing a permutation of the letters s, r, and t.
                The rotate, scale, and translate results are dependent on the
                order in which you perform those operations, and this string
                specifies that order.

            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes. This does not apply to the pivot_rotate

                angles, which are always applied in \"xyz\" order.

            This function could be re-implemented like this:

          > def buildTransform(values_dict, transform_order=\"srt\", rotate_order=\"xyz\"):
          >     # Take the return value from explode, along with the transform and
          >     # rotate order, and rebuild the original matrix.
          >     result = hou.hmath.identityTransform()
          >     for operation_type in transform_order:
          >         if operation_type == \"t\":
          >             result *= hou.hmath.buildTranslate(values_dict[\"translate\"])
          >         elif operation_type == \"s\":
          >             result *= hou.hmath.buildScale(values_dict[\"scale\"])
          >             if \"shear\" in values_dict:
          >                 result *= hou.hmath.buildShear(values_dict[\"shear\"])
          >         elif operation_type == \"r\":
          >             result *= hou.hmath.buildRotate(values_dict[\"rotate\"], rotate_order)
          >         else:
          >             raise ValueError(\"Invalid transform order\")
          >     return result

        """
        return _hou.hmath_buildTransform(self, *args, **kwargs)

    def _buildTransformTRS(self, *args) -> "HOM_Matrix4 *":
        return _hou.hmath__buildTransformTRS(self, *args)

    def _buildTransformTRSS(self, *args) -> "HOM_Matrix4 *":
        return _hou.hmath__buildTransformTRSS(self, *args)

    def _buildTransformTR(self, *args) -> "HOM_Matrix4 *":
        return _hou.hmath__buildTransformTR(self, *args)

    def _buildTransform(self, *args) -> "HOM_Matrix4 *":
        return _hou.hmath__buildTransform(self, *args)

    def degToRad(self, degrees: "double") -> "double":
        r"""

        degToRad(degrees) -> float

            Given a value in degrees, return the corresponding value in radians.

            This function is equivalent to degrees * math.pi / 180.0.


        """
        return _hou.hmath_degToRad(self, degrees)

    def radToDeg(self, radians: "double") -> "double":
        r"""

        radToDeg(radians) -> double

            Given a value in radians, return the corresponding value in degrees.

            This function is equivalent to radians * 180.0 / math.pi.


        """
        return _hou.hmath_radToDeg(self, radians)

    def noise1d(self, pos: "_DoubleTuple") -> "double":
        r"""

        noise1d(self, pos) -> float

            Given a sequence of 1 to 4 floats representing a position in
            N-dimensional space, return a single float corresponding to 1
            dimensional noise.

            This function matches the output of the noise() function from VEX.


        """
        return _hou.hmath_noise1d(self, pos)

    def noise3d(self, pos: "_DoubleTuple") -> "HOM_Vector3":
        r"""

        noise3d(self, pos) -> hou.Vector3

            Given a sequence of 1 to 4 floats representing a position in
            N-dimensional space, return a hou.Vector3 object representing the
            vector noise at the given position.

            This function matches the output of the noise() function from VEX.


        """
        return _hou.hmath_noise3d(self, pos)

    def fit(
        self,
        value: "double",
        oldmin: "double",
        oldmax: "double",
        newmin: "double",
        newmax: "double",
    ) -> "double":
        r"""

        fit(value, old_min, old_max, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range old_min and old_max. If the value is outside
            the old_min to old_max range, it will be clamped to the new range.

          > >>> hou.hmath.fit(3, 1, 4, 5, 20)
          > 15.0

        """
        return _hou.hmath_fit(self, value, oldmin, oldmax, newmin, newmax)

    def fit01(self, value: "double", newmin: "double", newmax: "double") -> "double":
        r"""

        fit01(value, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range 0 and 1. If the value is outside the 0 to 1
            range, it will be clamped to the new range.

            This function is a shortcut for hou.hmath.fit(value, 0.0, 1.0,
            new_min, new_max).


        """
        return _hou.hmath_fit01(self, value, newmin, newmax)

    def fit10(self, value: "double", newmin: "double", newmax: "double") -> "double":
        r"""

        fit10(value, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range 1 to 0. If the value is outside the 1 to 0
            range, it will be clamped to the new range.

            This function is a shortcut for hou.hmath.fit(value, 1.0, 0.0,
            new_min, new_max).


        """
        return _hou.hmath_fit10(self, value, newmin, newmax)

    def fit11(self, value: "double", newmin: "double", newmax: "double") -> "double":
        r"""

        fit11(value, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range -1 to 1. If the value is outside the -1 to 1
            range, it will be clamped to the new range.

            This function is a shortcut for hou.hmath.fit(value, -1.0, 1.0,
            new_min, new_max).


        """
        return _hou.hmath_fit11(self, value, newmin, newmax)

    def sign(self, value: "double") -> "double":
        r"""

        sign(value) -> int

            Returns 1.0 if value is positive, -1.0 if negative and 0.0 if value
            is zero.

            Note that you can achieve the same effect with Python's built-in cmp
            function: float(cmp(value, 0)).


        """
        return _hou.hmath_sign(self, value)

    def clamp(self, value: "double", min: "double", max: "double") -> "double":
        r"""

        clamp(value, min, max) -> float

            Returns the value clamped to the range min to max. See also
            hou.hmath.wrap. This function is useful in expressions to prevent a
            value from going outside the specified range.


        """
        return _hou.hmath_clamp(self, value, min, max)

    def smooth(self, value: "double", min: "double", max: "double") -> "double":
        r"""

        smooth(value, min, max) -> float

            Takes a value and range and returns a smooth interpolation between 0
            and 1.

            When value is less than min, the return value is 0. If value is
            greater than max, the return value is 1.

          > >>> hou.hmath.smooth(5, 0, 20)
          > 0.15625
          > >>> hou.hmath.smooth(10, 0, 20)
          > 0.5
          > >>> hou.hmath.smooth(15, 0, 20)
          > 0.84375
          > # Visualize the output of this function by positioning geometry objects at  various locations.
          > def createSpheres(num_spheres=40):
          >     for i in range(num_spheres):
          >         sphere = hou.node(\"/obj\").createNode(\"geo\").createNode(\"sphere\")
          >         sphere.parmTuple(\"rad\").set((0.1, 0.1, 0.1))
          >         sphere.setDisplayFlag(True)
          >
          >         # Given a value between 0 and 5, we'll call smooth with a range
          >         # of 0 to 3, and the resulting y value will be between 0 and 1.
          >         x = 5.0 * i / num_spheres
          >         y = hou.hmath.smooth(x, 0, 3)
          >         sphere.parent().setParmTransform(hou.hmath.buildTranslate((x, y, 0)))

        """
        return _hou.hmath_smooth(self, value, min, max)

    def wrap(self, value: "double", min: "double", max: "double") -> "double":
        r"""

        wrap(value, min, max)

            Similar to the hou.hmath.clamp function in that the resulting value
            will always fall between the specified minimum and maximum value.
            However, it will create a saw-tooth wave for continuously increasing
            or decreasing parameter values.


        """
        return _hou.hmath_wrap(self, value, min, max)

    def rand(self, seed: "double") -> "double":
        r"""

        rand(seed) -> float

            Returns a pseudo-random number from 0 to 1. Using the same seed will
            always give the same result.


        """
        return _hou.hmath_rand(self, seed)

    def orient2d(
        self, pa: "_DoubleTuple", pb: "_DoubleTuple", point: "_DoubleTuple"
    ) -> "double":
        r"""

        orient2d(pa, pb, point) -> float

            Performs an adaptive exact sidedness test of the 2d point against
            the line defined by pa and pb.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
        return _hou.hmath_orient2d(self, pa, pb, point)

    def orient3d(
        self,
        pa: "_DoubleTuple",
        pb: "_DoubleTuple",
        pc: "_DoubleTuple",
        point: "_DoubleTuple",
    ) -> "double":
        r"""

        orient3d(pa, pb, pc, point) -> float

            Performs an adaptive exact sidedness test of the 3d point against
            the plane defined by pa, pb, and pc.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
        return _hou.hmath_orient3d(self, pa, pb, pc, point)

    def inCircle(
        self,
        pa: "_DoubleTuple",
        pb: "_DoubleTuple",
        pc: "_DoubleTuple",
        point: "_DoubleTuple",
    ) -> "double":
        r"""

        inCircle(pa, pb, pc, point) -> float

            Performs an adaptive exact inside test of the 2d point against the
            circle defined by pa, pb, and pc. pa, pb, and pc must be in counter-
            clockwise order to get a positive value for interior points.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
        return _hou.hmath_inCircle(self, pa, pb, pc, point)

    def inSphere(
        self,
        pa: "_DoubleTuple",
        pb: "_DoubleTuple",
        pc: "_DoubleTuple",
        pd: "_DoubleTuple",
        point: "_DoubleTuple",
    ) -> "double":
        r"""

        inSphere(pa, pb, pc, pd, point) -> float

            Performs an adaptive exact inside test of the 3d point against the
            sphere defined by pa, pb, pc, and pd. Note that inconsistent
            orientation of the four sphere defining points will reverse the sign
            of the result.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
        return _hou.hmath_inSphere(self, pa, pb, pc, pd, point)

    def intersectPlane(
        self,
        plane_point: "Vector3",
        plane_dir: "Vector3",
        line_origin: "Vector3",
        line_dir: "Vector3",
    ) -> "HOM_Vector3":
        r"""

        intersectPlane(plane_point, plane_normal, line_origin, line_dir) ->
        hou.Vector3

            Takes a plane defined by an origin point and normal vector
            (plane_point and plane_normal) and a line defined by an origin and
            direction (line_origin and line_dir) and returns a hou.Vector3 value
            representing the XYZ coordinates of the intersection point between
            the line and plane. All arguments must be hou.Vector3.

          > hou.hmath.intersectPlane(
          >     hou.Vector3(0, 0, 0), hou.Vector3(0, 1, 0),
          >     hou.Vector3(0.212, 1.56, 0), hou.Vector3(0, 0.62, -0.34)
          > )  # -> hou.Vector3(0.212, -1.19209e-07, 0.855484)

            (Note that line runs forward and backward along the line_dir from
            the origin. That is, even if line_dir points away from the plane,
            you will get the intersection behind the origin.)

          > hou.hmath.intersectPlane(
          >     hou.Vector3(0, 0, 0), hou.Vector3(0, 1, 0),  # Ground plane
          >     hou.Vector3(0, 1, 0), hou.Vector3(0, 1, 0)  # Line up from 1u above ground
          > )  # -> hou.Vector3(0, 0, 0)

            This function raises an exception if the line is parallel to the
            plane, or if the line_dir has no length, or even if the line is not
            mathematically parallel but parallel enough that the answer would be
            outside roughly a -100000, -100000 to 100000, 100000 square.


        """
        return _hou.hmath_intersectPlane(
            self, plane_point, plane_dir, line_origin, line_dir
        )

    def combineLocalTransform(self, *args, **kwargs) -> "HOM_Matrix4 *":
        r"""

        combineLocalTransform(local, world, parent_local=None,
        mode=hou.scaleInheritanceMode.Default) -> hou.Matrix4

            Returns a new world transform given its local and parent world
            transforms.


        """
        return _hou.hmath_combineLocalTransform(self, *args, **kwargs)

    def extractLocalTransform(self, *args, **kwargs) -> "HOM_Matrix4 *":
        r"""

        extractLocalTransform(world, parent_world, parent_local,
        mode=hou.scaleInheritanceMode.Default, effective_local=None) ->
        hou.Matrix4

            Returns a new local transform given its world and new parent
            transforms. If effective_local is given, then it is a hou.Matrix4
            modified to be the effective local transform taking into account
            mode.


        """
        return _hou.hmath_extractLocalTransform(self, *args, **kwargs)

    def slerpTransforms(
        self,
        xforms: "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > > const &",
        input_weights: "_DoubleTuple",
        normalize_weigths: "bool" = True,
        slerp_method: "int" = 1,
        slerp_flip_mehtod: "int" = 1,
    ) -> "HOM_Matrix4 *":
        r"""

        slerpTransforms( xforms, input_weights, normalize_weights, slerp_method,
        slerp_flip_method) -> hou.Matrix4

            Spherically blend transforms by decomposing into separate
            quaternions. xforms is the array of hou.Matrix4 transforms to blend.
            input_weights is an array of floats with the same size as the
            xforms. Set normalize_weights to True to normalize the input
            weights. slerp_method can be 0 to blend using normalized linear
            interpolation of quaternions or 1 to use an iterative method.
            slerp_flip_method defines a flip methid for slerp to ensure
            consistency during blending. It can be 0 to use the hemisphere of
            the first quaternion, or 1 to compare each adjacent quaternions when
            using NLERP.


        """
        return _hou.hmath_slerpTransforms(
            self,
            xforms,
            input_weights,
            normalize_weigths,
            slerp_method,
            slerp_flip_mehtod,
        )


# Register hmath in _hou:
_hou.hmath_swigregister(hmath)


class hotkeys(object):
    r"""

    hou.hotkeys

    Module containing hotkey related functions.

    See hotkeys for information about hotkeys in Houdini.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_hotkeys

    def __repr__(self) -> "std::string":
        return _hou.hotkeys___repr__(self)

    def assignments(
        self, hotkey_symbol: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.hotkeys_assignments(self, hotkey_symbol)

    def hotkeyDescription(self, hotkey_symbol: "char const *") -> "std::string":
        r"""

        hotkeyDescription(hotkey_symbol) -> str

            Returns the long description/help for a the given symbol string.

          > desc = hou.hotkeys.hotkeyDescription(\"h.open\")
          > # \"Open a file\"

        """
        return _hou.hotkeys_hotkeyDescription(self, hotkey_symbol)

    def hotkeyLabel(self, hotkey_symbol: "char const *") -> "std::string":
        r"""

        hotkeyLabel(hotkey_symbol) -> str

            Return the human-readable label for a symbol string.


            hotkey_symbol
                The target hotkey symbol name.

          > label = hou.hotkeys.hotkeyLabel(\"h.open\")
          > # \"Open\"

        """
        return _hou.hotkeys_hotkeyLabel(self, hotkey_symbol)

    def isKeyMatch(self, key: "char const *", hotkey_symbol: "char const *") -> "bool":
        r"""

        isKeyMatch(key, hotkey_symbol) -> bool

            Return True is key is a match for the given hotkey symbol. If key is
            a keyvoard shortcut string then it must match one of the keyboard
            shortcuts assigned to the hotkey. If key is a hotkey symbol then it
            must be a string match to hotkey_symbol.


            key
                Either a keyboard sequence string or a hotkey symbol. This is
                typically something given to us by an event processing system
                which would either know the hotkey invoked (like when a button
                is clicked) or just the key sequence pressed.

            hotkey_symbol
                The hotkey to check for a match against.


        """
        return _hou.hotkeys_isKeyMatch(self, key, hotkey_symbol)

    def isKeycodeMatch(self, key_code: "int", hotkey_symbol: "char const *") -> "bool":
        r"""

        isKeycodeMatch(key_code, hotkey_symbol) -> bool

            Return True is keycode is a match for the given hotkey symbol.


            key_code
                A keycode from a keyboard event.

            hotkey_symbol
                The hotkey to check for a match against.


        """
        return _hou.hotkeys_isKeycodeMatch(self, key_code, hotkey_symbol)

    def findConflicts(
        self, hotkey_symbol: "char const *", key: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        findConflicts(symbol, key) -> tuple of str

            Returns a sequence of symbol strings in ancestor and/or descendent
            contexts relative to symbol (including the symbol you passed in
            itself) that use the given key. This lets you see existing or
            potential conflicts.

            An example of a conflict would be if a high level action (for
            example, h.copy) has hotkey [Ctrl + C], and a lower-level action
            (for example, h.panes.gview.state.sop.demo.duplicate) also uses
            [Ctrl + C], then where you're in that state, the higher-level Copy
            key won't be available because it's overridden by the lower-level
            key.

          > # Find potential conflicts with K on the top-level Add Keyframe command
          > symbols = hou.findConflicts(\"h.add_key\", \"k\")
          > # Returns ('h.pane.gview.state.sop.topobuild.bridge', 'h.add_key'),
          > # meaning K is assigned to both h.add_key and
          > # h.pane.gview.state.sop.topobuild.bridge
          > # in the same hierarchy
          >
          > # Find potential conflicts with Ctrl + C on the top-level Copy command
          > symbols = hou.findConflicts(\"h.copy\", \"ctrl+c\")  # (Use cmd+c on Mac)
          > # Returns (\"h.copy\",) meaning there are no conflicts (the symbol
          > # you checked is the only symbol in that hierarchy using that key)

        """
        return _hou.hotkeys_findConflicts(self, hotkey_symbol, key)

    def changeIndex(self) -> "int":
        r"""

        changeIndex() -> int

            Return the monotonically increasing change index from the hotkey
            manager. This number increases by one whenever any change is made to
            the hotkey manager. If a module is caching any information from the
            hotkey manager it should check this change index to see if any
            changes have been made and thus the cache should be refreshed.


        """
        return _hou.hotkeys_changeIndex(self)

    def commandsInContext(
        self, context: "char const *"
    ) -> "std::vector< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >,std::allocator< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > > >":
        r"""

        commandsInContext(context) -> tuple of dict

            Return all hotkey commands at the given parent hotkey context.

            Each command is a dict with the following keys: symbol, label, and
            help.


            context
                The hotkey symbol of the context.


        """
        return _hou.hotkeys_commandsInContext(self, context)

    def contextsInContext(
        self, context: "char const *"
    ) -> "std::vector< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >,std::allocator< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > > >":
        r"""

        contextsInContext(context) -> tuple of dict

            Return all hotkey contexts at the given parent hotkey context.

            Each command is a dict with the following keys: symbol, label, and
            help.


            context
                The hotkey symbol of the context.


        """
        return _hou.hotkeys_contextsInContext(self, context)

    def addCommand(self, *args) -> "bool":
        r"""

        addCommand(hotkey_symbol, label, description, assignments) -> bool

            Registers a new configurable hotkey command with Houdini. The
            context it belongs to should already exist, see
            hou.hotkeys.addContext.

            A hotkey symbol represents an action, for example deleting the
            selected geometry when a certain tool is active. The user can change
            the actual key assigned to the action using the hotkey editor. After
            registering the symbol you can programmatically assign a default key
            using hou.hotkeys.addAssignment.

            To add a delete action to the demo python state, you would do
            something like this:

          > # Add a hotkey context for the demo python state
          > demo_context = \"h.pane.gview.state.sop.demo\"
          > hou.hotkeys.addContext(demo_context, \"demo Operation\", \"These keys apply to the demo operations\")
          >
          > # Add hotkeys to the \"demo\" state
          > delete_symbol = demo_context + \".delete\"
          > hou.hotkeys.addCommand(
          >     delete_symbol,
          >     \"Delete Selected\",
          >     \"Delete the selected geometry\"
          > )
          > commit_symbol = demo_context + \".commit\"
          > hou.hotkeys.addCommand(
          >     commit_symbol,
          >     \"Commit Changes\",
          >     \"Save changes to parameters and start a new cache\"
          > )
          > cancel_symbol = demo_context + \".cancel\"
          > hou.hotkeys.addCommand(
          >     cancel_symbol,
          >     \"Cancel Changes\",
          >     \"Discard any  changes and return to an empty cache\"
          > )

            hotkey_symbol
                A string containing a full dotted hotkey symbol.

            label
                A human readable title for the action. For example, Delete
                Selected.

            description
                A human readable description of the action. This should
                generally be one to three sentences of help text for the action.

            assignments
                An optional list of shortcut strings to be used as the default
                assignments for this command.


        """
        return _hou.hotkeys_addCommand(self, *args)

    def addContext(
        self,
        hotkey_symbol: "char const *",
        label: "char const *",
        description: "char const *",
    ) -> "bool":
        r"""

        addContext(hotkey_symbol, label, long_description ) -> bool

            Registers a new hotkey context with Houdini. A context should be
            created before creating contexts or commands within that context.

            Currently this is only useful for adding hotkeys to Python states.


            hotkey_symbol
                A string containing a full dotted hotkey symbol representing the
                context. Currently the only useful value for hotkey_symbol is:

              > h.pane.gview.state.sop

            label
                A human readable title for the context. For example, Demo State
                Operation.

            description
                A human readable description of the context. This should
                generally be one to three sentences of help text for the action.


        """
        return _hou.hotkeys_addContext(self, hotkey_symbol, label, description)

    def removeHotkeySymbol(self, hotkey_symbol: "char const *") -> "void":
        r"""

        removeHotkeySymbol(hotkey_symbol)

            Removes an existing hotkey previously created with .


            hotkey_symbol
                A string containing a full dotted hotkey symbol.

                Currently this is only useful for removing hotkeys of Python SOP
                states, so symbol will be in the form:

                h.pane.gview.state.sop.<state_name>.<action_name>

          > hou.hotkeys.removeHotkeySymbol(\"h.pane.gview.state.sop.demo.delete\")

        """
        return _hou.hotkeys_removeHotkeySymbol(self, hotkey_symbol)

    def hotkeySymbol(
        self, english_context: "char const *", english_command: "char const *" = None
    ) -> "std::string":
        r"""

        hotkeySymbol(context_label_path, command_label=None) -> str or None

            Does a reverse-lookup to retrieve the hotkey symbol given the human-
            readable context label(s). If you supply only a context label, the
            function returns the context's prefix symbol. If you also supply a
            command label, the function returns the command's hotkey symbol.


            context_label_path
                A string containing a path through the hierarchy of human-
                readable context labels, starting with and separated by slashes.
                For example, \"/Houdini/Panes/Geometry Viewers\".

            command_label
                An optional human-readable command label, for example \"Box
                Selection\".

          > hou.hotkeySymbol(\"/Houdini/Panes/Geometry Viewers\", \"Box Selection\")
          > # \"h.pane.gview.selectstylebox\"

        """
        return _hou.hotkeys_hotkeySymbol(self, english_context, english_command)

    def clearAssignments(self, hotkey_symbol: "char const *") -> "bool":
        r"""

        clearAssignments(hotkey_symbol) -> bool

            Removes any keys assigned to the given action.

          > hou.hotkeys.clearAssignments(\"h.pane.gview.state.sop.demo.delete\")

            hotkey_symbol
                The symbol string for the action you want to remove hotkeys
                from.

            RELATED

                hou.hotkeys.addCommand


        """
        return _hou.hotkeys_clearAssignments(self, hotkey_symbol)

    def addAssignment(
        self, hotkey_symbol: "char const *", key: "char const *"
    ) -> "bool":
        r"""

        addAssignment(hotkey_symbol, key) -> bool

            Assigns a key (or key combination) to a hotkey symbol.

          > hou.hotkeys.addAssignment(\"h.pane.gview.state.sop.demo.delete\", \"alt+k\")
          > hou.hotkeys.addAssignment(\"h.pane.gview.state.sop.demo.delete\", \"shift+del\")

            Returns True if the assignment succeeds, or False if the symbol is
            unknown or the key string is not valid.


            hotkey_symbol
                The symbol string for the action you want to assign a hotkey to.

            key
                A string specifying the key (or key combination) to assign to
                the action. For example, \"shift+del\".


        """
        return _hou.hotkeys_addAssignment(self, hotkey_symbol, key)

    def removeAssignment(
        self, hotkey_symbol: "char const *", key: "char const *"
    ) -> "bool":
        r"""

        removeAssignment(hotkey_symbol, key) -> bool

            Removes a key (or key combination) from a hotkey symbol.

          > hou.hotkeys.removeAssignment(\"h.pane.gview.state.sop.demo.delete\", \"alt+k\")

            hotkey_symbol
                The target hotkey symbol name.

            key
                The key string identifier to remove. For example, \"shift+del\".


        """
        return _hou.hotkeys_removeAssignment(self, hotkey_symbol, key)

    def _getHotkeysStatus(
        self, hotkey_symbol: "char const *", modifier_mask: "int" = 0
    ) -> "std::map< std::string,std::vector< std::string,std::allocator< std::string > >,std::less< std::string >,std::allocator< std::pair< std::string const,std::vector< std::string,std::allocator< std::string > > > > >":
        return _hou.hotkeys__getHotkeysStatus(self, hotkey_symbol, modifier_mask)

    def availableKeycodes(
        self, hotkey_symbol: "char const *", modifier_mask: "int" = 0
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        availableKeycodes(hotkey_symbol, modifiers=0) -> tuple of int

            Return all available shortcut keycodes with their conflict status
            bits set w.r.t. the specified hotkey symbol. A keycode is considered
            available if it isn't assigned to another hotkey within this
            context.


            hotkey_symbol
                The target hotkey symbol name.

            modifiers
                UI_KeyBindings modifier key bits to be applied. Only keycodes
                with these modifier bits are returned.


        """
        return _hou.hotkeys_availableKeycodes(self, hotkey_symbol, modifier_mask)

    def keycodeToString(self, keycode: "int", modifiers: "short" = 0) -> "std::string":
        r"""

        keycodeToString(keycode, modifiers=0) -> str

            Convert a hotkeymanager keycode to a key string.


            modifiers
                UI_KeyBindings modifier key bits to be applied.


        """
        return _hou.hotkeys_keycodeToString(self, keycode, modifiers)

    def stringToKeycode(self, key: "char const *", modifiers: "short" = 0) -> "int":
        r"""

        stringToKeycode(key, modifiers=0) -> int

            Convert a keystring to a hotkeymanager keycode.


            modifiers
                UI_KeyBindings modifier key bits to be applied.


        """
        return _hou.hotkeys_stringToKeycode(self, key, modifiers)

    def _createBackupTables(self) -> "void":
        return _hou.hotkeys__createBackupTables(self)

    def _restoreBackupTables(self) -> "void":
        return _hou.hotkeys__restoreBackupTables(self)

    def revertToDefaults(
        self, hotkey_symbol: "char const *", one_level_only: "bool"
    ) -> "void":
        r"""

        revertToDefaults(hotkey_symbol, one_level_only)

            Revert the specified hotkey to its defaults from the keymap.


            hotkey_symbol
                The hotkey symbol (command or context) to reset.

            one_level_only
                When False, this item and its children are all set to their
                default. When True, only this context or command is reset. This
                only has an effect for contexts since commands have no children.


        """
        return _hou.hotkeys_revertToDefaults(self, hotkey_symbol, one_level_only)

    def saveOverrides(self) -> "bool":
        r"""

        saveOverrides() -> bool

            Save changes to the hotkeys as overrides to the current keymap.
            Changes are things that are different from their default value e.g.
            modifying a shortcut key assignment. Note that adding a new hotkey
            command with addHotkey will treat it as a new default so that it
            won't be saved unless a change is made to it after it is added.


        """
        return _hou.hotkeys_saveOverrides(self)

    def saveAsKeymap(self, name: "char const *", path: "char const *" = None) -> "bool":
        r"""

        saveAsKeymap(name, path=None) -> bool

            Save the currently defined hotkeys as a keymap. This combines the
            loaded keymap with all of the defined overrides into a single new
            keymap. Returns True upon successful save.


            name
                The name of the new keymap.

            path
                Optional save path for the new keymap. If None then it will be
                saved into the user prefs dir with a filename derived from the
                keymap name.


        """
        return _hou.hotkeys_saveAsKeymap(self, name, path)

    def loadKeymap(self, name: "char const *", path: "char const *" = None) -> "bool":
        r"""

        loadKeymap(name, path=None) -> bool

            Save the currently defined hotkeys as a keymap. This combines the
            loaded keymap with all of the defined overrides into a single new
            keymap. Returns True upon successful load.


            name
                The name of the keymap to load.

            path
                Optional path for the keymap to load. If None then it will be
                searched in the search path.


        """
        return _hou.hotkeys_loadKeymap(self, name, path)

    def importKeymap(self, name: "char const *", path: "char const *") -> "bool":
        r"""

        importKeymap(name, path=None) -> bool

            Copy the specified keymap into the user preferences directory and
            save it with an appropriate name. Returns True upon successful
            import.


            name
                The new name of the keymap.

            path
                The path of the keymap to import.


        """
        return _hou.hotkeys_importKeymap(self, name, path)

    def keymaps(
        self,
    ) -> "std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >":
        r"""

        keymaps() -> tuple or str

            Return a list of tuples of all the keymaps found. The tuple has the
            keymap's name and path.


        """
        return _hou.hotkeys_keymaps(self)

    def currentKeymap(self) -> "std::string":
        r"""

        currentKeymap() -> str

            Return the name of the currently loaded keymap.


        """
        return _hou.hotkeys_currentKeymap(self)


# Register hotkeys in _hou:
_hou.hotkeys_swigregister(hotkeys)


class ik(object):
    r"""

    hou.ik

    Module containing functions related to inverse kinematics.

    API



    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ik

    def __repr__(self) -> "std::string":
        return _hou.ik___repr__(self)

    def solveFBIK(self, *args, **kwargs) -> "void":
        r"""

        hou.ik.solveFBIK

        Applies a full-body inverse kinematics algorithm to a skeleton.

        USAGE
          solveFBIK(skeleton, targets, iters=30, tolerance=1e-5, pin_root=False)

        This solver is equivalent to the solvefbik() VEX function.


        skeleton
            The hou.ik.Skeleton to solve. The joints' transforms will be updated
            with the solution.

        targets
            A list of hou.ik.Target specifying the goal transforms for
            particular joints. Raises hou.ValueError if any of the targets are
            not attached to a joint, or if multiple targets are attached to the
            same joint.

        iters
            The maximum number of iterations to perform. The solver may
            terminate early if the tolerance parameter is used.

        tolerance
            The tolerance to use when checking for convergence, defaults to
            1e-5. If positions converge to within this tolerance, the algorithm
            will stop. If 0, the solver will always perform exactly iters
            iterations.

        pin_root
            Specifies whether the root joint is allowed to translate.


        """
        return _hou.ik_solveFBIK(self, *args, **kwargs)

    def solvePhysFBIK(self, *args, **kwargs) -> "void":
        r"""

        hou.ik.solvePhysFBIK

        Applies a full-body inverse kinematics algorithm to a skeleton, with
        optional control over the center of mass.

        USAGE
          solvePhysFBIK(skeleton, targets, com_target=None, iters=30,
          damping=0.5, tolerance=1e-5)

        This solver is equivalent to the solvephysfbik() VEX function.


        skeleton
            The hou.ik.Skeleton to solve. The joints' transforms will be updated
            with the solution.

        targets
            A list of hou.ik.Target specifying the goal transforms for
            particular joints. Raises hou.ValueError if any of the targets are
            not attached to a joint, or if multiple targets are attached to the
            same joint.

        com_target
            An optional hou.ik.Target which specifies the goal position of the
            skeleton's center of mass.

        iters
            The maximum number of iterations to perform. The solver may
            terminate early if the tolerance parameter is used.

        damping
            Damping factor for the solver. Larger values will produce more
            stable results when, for example, a target is unreachable. A value
            that is too large, however, will require more iterations to
            converge. Around 0.5 is typically a suitable initial value.

        tolerance
            The tolerance to use when checking for convergence, defaults to
            1e-5. If positions converge to within this tolerance, the algorithm
            will stop. If 0, the solver will always perform exactly iters
            iterations.


        """
        return _hou.ik_solvePhysFBIK(self, *args, **kwargs)

    def _newSkeleton(self) -> "HOM_ik_Skeleton *":
        return _hou.ik__newSkeleton(self)

    def _newTarget(
        self,
        joint: "_ik_Joint",
        goal_transform: "Matrix4",
        joint_offset: "Matrix4",
        target_type: "EnumValue",
        weight: "double",
        priority: "int",
        depth: "int",
    ) -> "HOM_ik_Target *":
        return _hou.ik__newTarget(
            self,
            joint,
            goal_transform,
            joint_offset,
            target_type,
            weight,
            priority,
            depth,
        )


# Register ik in _hou:
_hou.ik_swigregister(ik)


class _ik_Joint(object):
    r"""

    hou.ik.Joint

    Represents a joint in an inverse kinematics skeleton.

    Joints can be created using hou.ik.Skeleton.addJoint.

    RELATED

      * hou.ik.Skeleton

      * hou.ik.Target


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete__ik_Joint

    def __eq__(self, joint: "HOM_PtrOrNull< HOM_ik_Joint >") -> "bool":
        return _hou._ik_Joint___eq__(self, joint)

    def __ne__(self, joint: "HOM_PtrOrNull< HOM_ik_Joint >") -> "bool":
        return _hou._ik_Joint___ne__(self, joint)

    def __hash__(self) -> "int":
        return _hou._ik_Joint___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou._ik_Joint___repr__(self)

    def worldTransform(self) -> "HOM_Matrix4 *":
        r"""

        worldTransform() -> hou.Matrix4

            Returns the joint's world space transform.


        """
        return _hou._ik_Joint_worldTransform(self)

    def setWorldTransform(self, xform: "Matrix4") -> "void":
        r"""

        setWorldTransform(xform)

            Sets the joint's world space transform (a hou.Matrix4).


        """
        return _hou._ik_Joint_setWorldTransform(self, xform)

    def parent(self) -> "HOM_ik_Joint *":
        r"""

        parent() -> hou.ik.Joint

            Returns the joint's parent, or None for a root joint.


        """
        return _hou._ik_Joint_parent(self)

    def setParent(self, parent: "_ik_Joint") -> "void":
        return _hou._ik_Joint_setParent(self, parent)

    def rotationOrder(self) -> "std::string":
        r"""

        rotationOrder() -> str

            Returns the joint's rotation order. See
            hou.ik.Joint.setRotationOrder.


        """
        return _hou._ik_Joint_rotationOrder(self)

    def setRotationOrder(self, rotate_order: "char const *") -> "void":
        r"""

        setRotationOrder(rotate_order)

            Sets the joint's rotation order.


            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.


        """
        return _hou._ik_Joint_setRotationOrder(self, rotate_order)

    def rotationWeights(self) -> "HOM_Vector3 *":
        r"""

        rotationWeights() -> hou.Vector3

            Returns the weights for the joint's rotation axes. See
            hou.ik.Joint.setRotationWeights.


        """
        return _hou._ik_Joint_rotationWeights(self)

    def setRotationWeights(self, weights: "Vector3") -> "void":
        r"""

        setRotationWeights(weights)

            Sets a hou.Vector3 specifying the weight of each rotation axis.
            Given a larger relative weight, the solution will tend to be
            achieved by rotating around that axis. A weight of zero will disable
            the rotation axis.


        """
        return _hou._ik_Joint_setRotationWeights(self, weights)

    def translationWeights(self) -> "HOM_Vector3 *":
        r"""

        translationWeights() -> hou.Vector3

            Returns the weights for the joint's translation axes. See
            hou.ik.Joint.setTranslationWeights.


        """
        return _hou._ik_Joint_translationWeights(self)

    def setTranslationWeights(self, weights: "Vector3") -> "void":
        r"""

        setTranslationWeights(weights)

            Sets a hou.Vector3 specifying the weight of each translation axis.
            Given a larger relative weight, the solution will tend to be
            achieved by translating along that axis. A weight of zero will
            disable the translation axis. To set up an unpinned root joint, the
            root's translation weight should be non-zero (e.g. hou.Vector3(1, 1,
            1)).


        """
        return _hou._ik_Joint_setTranslationWeights(self, weights)

    def mass(self) -> "double":
        r"""

        mass() -> float

            Returns the mass of the body attached to this joint. See
            hou.ik.Joint.setMass.


        """
        return _hou._ik_Joint_mass(self)

    def setMass(self, mass: "double") -> "void":
        r"""

        setMass(mass)

            Sets the mass of the body attached to this joint. This is only used
            by solvers that support center of mass targets, such as
            hou.ik.solvePhysFBIK.


        """
        return _hou._ik_Joint_setMass(self, mass)

    def localCenterOfMass(self) -> "HOM_Vector3 *":
        r"""

        localCenterOfMass() -> hou.Vector3

            Returns the local space position of the body attached to this joint.
            See hou.ik.Joint.setLocalCenterOfMass.


        """
        return _hou._ik_Joint_localCenterOfMass(self)

    def setLocalCenterOfMass(self, com: "Vector3") -> "void":
        r"""

        setLocalCenterOfMass(position)

            Sets the local space position of the body attached to this joint. A
            position of hou.Vector3(0, 0, 0) will position the center of mass at
            the joint's world space position. This is only used by solvers that
            support center of mass targets, such as hou.ik.solvePhysFBIK.


        """
        return _hou._ik_Joint_setLocalCenterOfMass(self, com)

    def rotationLimits(
        self,
    ) -> "std::pair< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        rotationLimits() -> (hou.Vector3, hou.Vector3)

            Returns the lower and upper rotation limits (in radians) for the
            joint, relative to the rest transform. If
            hou.ik.Joint.hasRotationLimits() is False, (None, None) is returned.


        """
        return _hou._ik_Joint_rotationLimits(self)

    def setRotationLimits(self, lower: "Vector3", upper: "Vector3") -> "void":
        r"""

        setRotationLimits(lower, upper)

            Sets the lower and upper rotation limits (a hou.Vector3 in radians)
            for the joint.


        """
        return _hou._ik_Joint_setRotationLimits(self, lower, upper)

    def translationLimits(
        self,
    ) -> "std::pair< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        translationLimits() -> (hou.Vector3, hou.Vector3)

            Returns the lower and upper translation limits for the joint,
            relative to the rest transform.


        """
        return _hou._ik_Joint_translationLimits(self)

    def setTranslationLimits(self, lower: "Vector3", upper: "Vector3") -> "void":
        r"""

        setTranslationLimits(lower, upper)

            Sets the lower and upper translation limits for the joint.


        """
        return _hou._ik_Joint_setTranslationLimits(self, lower, upper)

    def restTransform(self) -> "HOM_Matrix4 *":
        r"""

        restTransform() -> hou.Matrix4

            Returns the joint's rest pose, or None if it has not been set.


        """
        return _hou._ik_Joint_restTransform(self)

    def setRestTransform(self, xform: "Matrix4") -> "void":
        r"""

        setRestTransform(xform)

            Sets a local space hou.Matrix4 specifying the joint's rest pose. If
            not specified, the identity transform is used.

            The solver will attempt to maintain this local transform based on
            the rest rotation weights and rest translation weights. This has a
            priority lower than any of the end effector targets.

            Additionally, joint limits are enforced relative to this rest
            transform.


        """
        return _hou._ik_Joint_setRestTransform(self, xform)

    def restRotationWeights(self) -> "HOM_Vector3 *":
        r"""

        restRotationWeights() -> hou.Vector3

            Returns the rest weights for the joint's rotation axes. See
            hou.ik.Joint.setRestRotationWeights.


        """
        return _hou._ik_Joint_restRotationWeights(self)

    def setRestRotationWeights(self, weights: "Vector3") -> "void":
        r"""

        setRestRotationWeights(weights)

            Sets a hou.Vector3 specifying how strongly the solver attempts to
            match the rest transform for the rotation axes. A value of 0.1 is
            typically a suitable value when enabling this behavior, and a value
            of 0 will disable the constraint. The default value is {0,0,0}.


        """
        return _hou._ik_Joint_setRestRotationWeights(self, weights)

    def restTranslationWeights(self) -> "HOM_Vector3 *":
        r"""

        restTranslationWeights() -> hou.Vector3

            Returns the rest weights for the joint's translation axes. See
            hou.ik.Joint.setRestTranslationWeights.


        """
        return _hou._ik_Joint_restTranslationWeights(self)

    def setRestTranslationWeights(self, weights: "Vector3") -> "void":
        r"""

        setRestTranslationWeights(weights)

            Sets a hou.Vector3 specifying how strongly the solver attempts to
            match the rest transform for the translation axes. A value of 0.1 is
            typically a suitable value when enabling this behavior, and a value
            of 0 will disable the constraint. The default value is {0,0,0}.


        """
        return _hou._ik_Joint_setRestTranslationWeights(self, weights)


# Register _ik_Joint in _hou:
_hou._ik_Joint_swigregister(_ik_Joint)


class _ik_Skeleton(object):
    r"""

    hou.ik.Skeleton

    Represents a skeleton for use with inverse kinematics solvers.

    RELATED

      * hou.ik.Joint


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        hou.ik.Skeleton

        Represents a skeleton for use with inverse kinematics solvers.

        RELATED

          * hou.ik.Joint


        """
        _hou._ik_Skeleton_swiginit(self, _hou.new__ik_Skeleton())

    __swig_destroy__ = _hou.delete__ik_Skeleton

    def __eq__(self, skel: "HOM_PtrOrNull< HOM_ik_Skeleton >") -> "bool":
        return _hou._ik_Skeleton___eq__(self, skel)

    def __ne__(self, skel: "HOM_PtrOrNull< HOM_ik_Skeleton >") -> "bool":
        return _hou._ik_Skeleton___ne__(self, skel)

    def __hash__(self) -> "int":
        return _hou._ik_Skeleton___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou._ik_Skeleton___repr__(self)

    def addJoint(self, *args, **kwargs) -> "HOM_ik_Joint *":
        r"""

        addJoint(self, world_transform=hou.Matrix4(1.0), parent=None,
        rotation_weights=hou.Vector3(1,1,1),
        translation_weights=hou.Vector3(0,0,0), mass=1.0,
        local_com=hou.Vector3(0,0,0)) -> hou.ik.Joint

            Appends a new joint to the skeleton.


            world_transform
                See hou.ik.Joint.setWorldTransform

            parent
                See hou.ik.Joint.setParent

            rotation_weights
                See hou.ik.Joint.setRotationWeights

            translation_weights
                See hou.ik.Joint.setTranslationWeights

            mass
                See hou.ik.Joint.setMass

            local_com
                See hou.ik.Joint.setLocalCenterOfMass


        """
        return _hou._ik_Skeleton_addJoint(self, *args, **kwargs)

    def joints(self) -> "HOM_IterableList< HOM_ik_Joint > *":
        r"""

        joints(self) -> tuple of hou.ik.Joint

            Returns a list of the joints in the skeleton. The list follows the
            order in which the joints were added to the skeleton.


        """
        return _hou._ik_Skeleton_joints(self)

    def centerOfMass(self) -> "HOM_Vector3 *":
        r"""

        centerOfMass() -> hou.Vector3

            Returns the world space position of the skeleton's center of mass.
            This is computed from the mass, center of mass, and world transform
            of each joint.


        """
        return _hou._ik_Skeleton_centerOfMass(self)


# Register _ik_Skeleton in _hou:
_hou._ik_Skeleton_swigregister(_ik_Skeleton)


class _ik_Target(object):
    r"""

    hou.ik.Target

    Represents a position or orientation target for inverse kinematics
    solvers.

    RELATED

      * hou.ik.Joint

      * hou.ik.targetType


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(joint=None, goal_transform=hou.Matrix4(1.0),
        joint_offset=hou.Matrix4(1.0), target_type=hou.ik.targetType.Position,
        weight=1.0, priority=0, depth=-1)

            Creates a new target.


            joint
                See hou.ik.Target.setJoint.

            goal_transform
                See hou.ik.Target.setGoalTransform.

            joint_offset
                See hou.ik.Target.setJointOffset.

            target_type
                See hou.ik.Target.setTargetType.

            weight
                See hou.ik.Target.setWeight.

            priority
                See hou.ik.Target.setPriority.

            depth
                See hou.ik.Target.setDepth.


        """
        _hou._ik_Target_swiginit(self, _hou.new__ik_Target(*args, **kwargs))

    __swig_destroy__ = _hou.delete__ik_Target

    def __eq__(self, target: "HOM_PtrOrNull< HOM_ik_Target >") -> "bool":
        return _hou._ik_Target___eq__(self, target)

    def __ne__(self, target: "HOM_PtrOrNull< HOM_ik_Target >") -> "bool":
        return _hou._ik_Target___ne__(self, target)

    def __hash__(self) -> "int":
        return _hou._ik_Target___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou._ik_Target___repr__(self)

    def joint(self) -> "HOM_ik_Joint *":
        r"""

        joint() -> hou.ik.Joint

            Returns the joint that the target is attached to, or None.


        """
        return _hou._ik_Target_joint(self)

    def setJoint(self, joint: "_ik_Joint") -> "void":
        r"""

        setJoint(joint)

            Sets the hou.ik.Joint that the target is attached to. This may be
            None if, for example, the target defines a goal position for the
            skeleton's center of mass.


        """
        return _hou._ik_Target_setJoint(self, joint)

    def goalTransform(self) -> "HOM_Matrix4 *":
        r"""

        goalTransform() -> hou.Matrix4

            Returns the world space goal transform.


        """
        return _hou._ik_Target_goalTransform(self)

    def setGoalTransform(self, xform: "Matrix4") -> "void":
        r"""

        setGoalTransform(xform)

            Sets the target world space transform (a hou.Matrix4) for the joint.


        """
        return _hou._ik_Target_setGoalTransform(self, xform)

    def jointOffset(self) -> "HOM_Matrix4 *":
        r"""

        jointOffset() -> hou.Matrix4

            Returns the local space joint offset transform. See
            hou.ik.Target.setJointOffset.


        """
        return _hou._ik_Target_jointOffset(self)

    def setJointOffset(self, offset: "Matrix4") -> "void":
        r"""

        setJointOffset(xform)

            Sets a local space transform (a hou.Matrix4) that is combined with
            the joint transform to produce the transform that the solver
            attempts to align with the goal transform. This can be used to place
            the target at an offset from the joint (for example, at the end of a
            bone).


        """
        return _hou._ik_Target_setJointOffset(self, offset)

    def targetType(self) -> "HOM_EnumValue &":
        r"""

        targetType() -> hou.ik.targetType

            Returns the target's type. See hou.ik.Target.setTargetType.


        """
        return _hou._ik_Target_targetType(self)

    def setTargetType(self, target_type: "EnumValue") -> "void":
        r"""

        setTargetType(target_type)

            Sets a hou.ik.targetType, which specifies whether the target affects
            position, orientation, or both.


        """
        return _hou._ik_Target_setTargetType(self, target_type)

    def weight(self) -> "double":
        r"""

        weight() -> float

            Returns the target's weight. See hou.ik.Target.setWeight.


        """
        return _hou._ik_Target_weight(self)

    def setWeight(self, weight: "double") -> "void":
        r"""

        setWeight(weight)

            Sets a float specifying the importance of the target. When multiple
            targets have the same priority level, targets with a higher relative
            weight are more likely to be reached.


        """
        return _hou._ik_Target_setWeight(self, weight)

    def priority(self) -> "int":
        r"""

        priority() -> int

            Returns the target's priority level. See hou.ik.Target.setPriority.


        """
        return _hou._ik_Target_priority(self)

    def setPriority(self, level: "int") -> "void":
        r"""

        setPriority(priority)

            Sets an int specifying the target's priority level. Targets from a
            lower priority level cannot interfere with targets from a higher
            priority level. For example, priority levels can be used to ensure
            that the feet remain planted when manipulating the upper body of a
            skeleton.


        """
        return _hou._ik_Target_setPriority(self, level)

    def depth(self) -> "int":
        r"""

        depth() -> int

            Returns the target's depth. See hou.ik.Target.setDepth.


        """
        return _hou._ik_Target_depth(self)

    def setDepth(self, depth: "int") -> "void":
        r"""

        setDepth(depth)

            Specifies the number of parent joints that can be adjusted to
            achieve the goal transform. A negative depth indicates that the
            entire chain can be affected.


        """
        return _hou._ik_Target_setDepth(self, depth)


# Register _ik_Target in _hou:
_hou._ik_Target_swigregister(_ik_Target)


class IndexPairPropertyTable(object):
    r"""

    hou.IndexPairPropertyTable

    Describes properties of an index pair attribute.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_IndexPairPropertyTable

    def __eq__(
        self, proptable: "HOM_PtrOrNull< HOM_IndexPairPropertyTable >"
    ) -> "bool":
        return _hou.IndexPairPropertyTable___eq__(self, proptable)

    def __ne__(
        self, proptable: "HOM_PtrOrNull< HOM_IndexPairPropertyTable >"
    ) -> "bool":
        return _hou.IndexPairPropertyTable___ne__(self, proptable)

    def __hash__(self) -> "int":
        return _hou.IndexPairPropertyTable___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.IndexPairPropertyTable___repr__(self)

    def attrib(self) -> "HOM_Attrib *":
        r"""

        attrib(self) -> hou.Attrib

            Return the parent index pair attribute.


        """
        return _hou.IndexPairPropertyTable_attrib(self)

    def numIndices(self) -> "int":
        return _hou.IndexPairPropertyTable_numIndices(self)

    def propertyNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        propertyNames(self) -> tuple of string

            Return a list of all property names.


        """
        return _hou.IndexPairPropertyTable_propertyNames(self)

    def propertyDataType(self, prop_name: "char const *") -> "HOM_EnumValue *":
        r"""

        propertyDataType(self, property_name) -> hou.attribData enum value

            Return the property's data type (int, float or string).


        """
        return _hou.IndexPairPropertyTable_propertyDataType(self, prop_name)

    def propertySize(self, prop_name: "char const *") -> "int":
        r"""

        propertySize(self, property_name) -> int

            Return the number of data components in the property value.


        """
        return _hou.IndexPairPropertyTable_propertySize(self, prop_name)

    def floatPropertyValueAtIndex(
        self, prop_name: "char const *", idx: "int"
    ) -> "double":
        r"""

        floatPropertyValueAtIndex(self, property_name, row) -> float

            Return the property value for a particular floating point property.

            Raises hou.OperationFailed if no property exists with this name or
            the property is not float of size 1.


        """
        return _hou.IndexPairPropertyTable_floatPropertyValueAtIndex(
            self, prop_name, idx
        )

    def floatListPropertyValueAtIndex(
        self, prop_name: "char const *", idx: "int"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        floatListPropertyValueAtIndex(self, property_name, row) -> tuple of
        float

            Return a list of property values for a particular floating point
            property.

            Raises hou.OperationFailed if no property exists with this name.


        """
        return _hou.IndexPairPropertyTable_floatListPropertyValueAtIndex(
            self, prop_name, idx
        )

    def intPropertyValueAtIndex(self, prop_name: "char const *", idx: "int") -> "int":
        r"""

        intPropertyValueAtIndex(self, property_name, row) -> int

            Return the property value for a particular integer property.

            Raises hou.OperationFailed if no property exists with this name or
            the property is not integer of size 1.


        """
        return _hou.IndexPairPropertyTable_intPropertyValueAtIndex(self, prop_name, idx)

    def intListPropertyValueAtIndex(
        self, prop_name: "char const *", idx: "int"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        intListPropertyValueAtIndex(self, property_name, row) -> tuple of int

            Return a list of property values for a particular integer property.

            Raises hou.OperationFailed if no property exists with this name.


        """
        return _hou.IndexPairPropertyTable_intListPropertyValueAtIndex(
            self, prop_name, idx
        )

    def stringPropertyValueAtIndex(
        self, prop_name: "char const *", idx: "int"
    ) -> "std::string":
        r"""

        stringPropertyValueAtIndex(self, property_name, row) -> string

            Return the property value for a particular string property.

            Raises hou.OperationFailed if no property exists with this name or
            the property is not string of size 1.


        """
        return _hou.IndexPairPropertyTable_stringPropertyValueAtIndex(
            self, prop_name, idx
        )

    def stringListPropertyValueAtIndex(
        self, prop_name: "char const *", idx: "int"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        stringListPropertyValueAtIndex(self, property_name, row) -> tuple of
        string

            Return a list of property values for a particular string property.

            Raises hou.OperationFailed if no property exists with this name.


        """
        return _hou.IndexPairPropertyTable_stringListPropertyValueAtIndex(
            self, prop_name, idx
        )


# Register IndexPairPropertyTable in _hou:
_hou.IndexPairPropertyTable_swigregister(IndexPairPropertyTable)


class IndirectInput(NetworkMovableItem):
    r"""

    hou.IndirectInput

    An abstract base class for a network item that can be used as an input
    to nodes in the same network, but which is not a node itself.

    There are two specific forms of an indirect input. The
    hou.SubnetIndirectInput provides a way to connect nodes outside a sub-
    network to nodes inside the sub-network. The hou.NetworkDot allows
    connections to be routed through a network along any path.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_IndirectInput

    def outputs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        return _hou.IndirectInput_outputs(self)

    def outputConnections(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > >":
        return _hou.IndirectInput_outputConnections(self)

    def input(self) -> "HOM_Node *":
        return _hou.IndirectInput_input(self)

    def inputOutputIndex(self) -> "int":
        return _hou.IndirectInput_inputOutputIndex(self)

    def inputItem(self) -> "HOM_NetworkMovableItem *":
        r"""

        inputItem(self) -> hou.NetworkMovableItem

            Returns the item connected directly to the input side of this
            indirect input. This may be a node, indirect input, or None if
            nothing is connected. Note that the returned item may not be inside
            the same parent network as this object if it is a
            hou.SubnetIndirectInput.


        """
        return _hou.IndirectInput_inputItem(self)

    def inputItemOutputIndex(self) -> "int":
        r"""

        inputItemOutputIndex(self) -> int

            Returns the index of the output connection on the network item
            connected directly to the input side of this object. Returns 0 if
            nothing is connected. This value will only be non-zero if a hou.Node
            is connected to this object since all other network items only has a
            single output connector.


        """
        return _hou.IndirectInput_inputItemOutputIndex(self)

    def setColorDefault(self) -> "void":
        return _hou.IndirectInput_setColorDefault(self)

    def setUseColorFromOutput(self, use_output_color: "bool") -> "void":
        return _hou.IndirectInput_setUseColorFromOutput(self, use_output_color)

    def useColorFromOutput(self) -> "bool":
        return _hou.IndirectInput_useColorFromOutput(self)

    def setSymbolicColorName(self, name: "char const *") -> "void":
        return _hou.IndirectInput_setSymbolicColorName(self, name)

    def symbolicColorName(self) -> "std::string":
        return _hou.IndirectInput_symbolicColorName(self)


# Register IndirectInput in _hou:
_hou.IndirectInput_swigregister(IndirectInput)


class InterruptableOperation(object):
    r"""

    hou.InterruptableOperation

    Use this class to turn any Python code block into an interruptable
    operation.


    NOTE
        hou.InterruptableOperation does not work in the Python Shell. For
        testing purposes, use a shelf tool instead.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(
        self,
        operation_name: "char const *",
        long_operation_name: "char const *" = None,
        open_interrupt_dialog: "bool" = False,
    ):
        r"""

        __init__(self, operation_name, long_operation_name=None,
        open_interrupt_dialog=False)

            Construct a new InterruptableOperation.


            operation_name
                A description of the interruptable operation that appears in the
                progress bar of the interrupt dialog.

            long_operation_name
                A description of the long, or higher-level, operation. If it is
                not None, a second progress bar appears on the interrupt dialog
                with the long operation name in it.

            open_interrupt_dialog
                Determines whether the interrupt dialog should appear or not.

            The constructor should only be called from within a with statement.
            For example:

          > with hou.InterruptableOperation(
          >         \"Performing Tasks\", open_interrupt_dialog=True) as operation:
          >     for i in num_tasks:
          >         #
          >         # PERFORM TASK HERE.
          >         #
          >
          >         # Update operation progress.
          >         percent = float(i) / float(num_tasks)
          >         operation.updateProgress(percent)

            In Python 2.5, the with statement is not enabled by default. To
            enable it, you need to add the following line at the beginning of
            your script/module:

          > from __future__ import with_statement

            You can nest multiple interruptable operations. This is ideal when
            you have a long operation consisting of several smaller operations.
            For example:

          > # Start the overall, long operation.
          > with hou.InterruptableOperation(
          >         \"Performing\", \"Performing Tasks\",
          >         open_interrupt_dialog=True) as operation:
          >     for i in num_tasks:
          >         # Update long operation progress.
          >         overall_percent = float(i) / float(num_tasks)
          >         operation.updateLongProgress(overall_percent)
          >
          >         # Start the sub-operation.
          >         with hou.InterruptableOperation(
          >                 \"Performing Task %i\" % i) as suboperation:
          >             for j in num_subtasks:
          >                 # Update sub-operation progress.
          >                 percent = float(j) / float(num_subtasks)
          >                 suboperation.updateProgress(percent)
          >
          >                 #
          >                 # PERFORM SUBTASK HERE.
          >                 #

        """
        _hou.InterruptableOperation_swiginit(
            self,
            _hou.new_InterruptableOperation(
                operation_name, long_operation_name, open_interrupt_dialog
            ),
        )

    __swig_destroy__ = _hou.delete_InterruptableOperation

    def __repr__(self) -> "std::string":
        return _hou.InterruptableOperation___repr__(self)

    def updateLongProgress(
        self, percentage: "double" = -1.0, long_op_status: "char const *" = None
    ) -> "void":
        r"""

        updateLongProgress(self, percentage=-1.0, long_op_status=None)

            Update the progress percentage and status of the long, or high-
            level, operation. At the same time, check if the operation was
            interrupted by the user.


            percentage
                A fractional number between 0.0 and 1.0. A value of 0.0 means
                that no progress has been made while 1.0 means that the
                operation is complete. A negative percentage indicates that the
                progress percentage is not available.

            long_op_status
                Text describing the current status of the long operation. The
                status will overwrite the text in the 2nd progress bar of the
                interrupt dialog. To keep the previous text in the progress bar,
                set this parameter to None.

            Raises hou.OperationInterrupted if the user has chosen to interrupt
            the operation.

            Raises hou.OperationFailed if the interruptable operation object was
            constructed outside of a with statement.


        """
        return _hou.InterruptableOperation_updateLongProgress(
            self, percentage, long_op_status
        )

    def updateProgress(self, percentage: "double" = -1.0) -> "void":
        r"""

        updateProgress(self, percentage=-1.0)

            Update the progress percentage of the operation. At the same time,
            check if the operation was interrupted by the user.


            percentage
                A fractional number between 0.0 and 1.0. A value of 0.0 means
                that no progress has been made while 1.0 means that the
                operation is complete. A negative percentage indicates that the
                progress percentage is not available.

            Raises hou.OperationInterrupted if the user has chosen to interrupt
            the operation.

            Raises hou.OperationFailed if the interruptable operation object was
            constructed outside of a with statement.


        """
        return _hou.InterruptableOperation_updateProgress(self, percentage)

    def __enter__(self) -> "HOM_InterruptableOperation *":
        return _hou.InterruptableOperation___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.InterruptableOperation___exit__(self, type, value, traceback)


# Register InterruptableOperation in _hou:
_hou.InterruptableOperation_swigregister(InterruptableOperation)


class IntParmTemplate(ParmTemplate):
    r"""

    hou.IntParmTemplate

    Describes a parameter tuple containing integer values.

    Note that integer parameters may also be menu parameters. Integer
    parameters with menus are conceptually the same as parameters derived
    from hou.MenuParmTemplate.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, num_components, default_value=(), min=0,
        max=10, min_is_strict=False, max_is_strict=False,
        look=hou.parmLook.Regular, naming_scheme=hou.parmNamingScheme.XYZW,
        menu_items=(), menu_labels=(), icon_names=(),
        item_generator_script=None, item_generator_script_language=None,
        menu_type=hou.menuType.Normal, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new IntParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            default_value
                See the defaultValue method for more information.

            min
                See the minValue method for more information.

            max
                See the maxValue method for more information.

            min_is_strict
                See the minIsStrict method for more information.

            max_is_strict
                See the maxIsStrict method for more information.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            menu_items
                See the menuItems method for more information. Note that
                num_components must be 1 if menu items are supplied.

            menu_labels
                See the menuLabels method for more information.

                If this parameter is not given, it defaults to the value of the
                menu_items parameter.

            icon_names
                See the iconNames method for more information.

                If this parameter is an empty tuple, the menu will not contain
                icons.

            item_generator_script
                See the itemGeneratorScript method for more information. Note
                that num_components must be 1 if a script is given.

            item_generator_script_language
                See the itemGeneratorScriptLanguage method for more information.
                If this parameter is None it defaults to
                hou.scriptLanguage.Python.

            menu_type
                See the menuType method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
        _hou.IntParmTemplate_swiginit(self, _hou.new_IntParmTemplate(*args, **kwargs))

    __swig_destroy__ = _hou.delete_IntParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.IntParmTemplate___repr__(self)

    def minValue(self) -> "int":
        r"""

        minValue(self) -> int

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
        return _hou.IntParmTemplate_minValue(self)

    def setMinValue(self, min_value: "int") -> "void":
        r"""

        setMinValue(self, min_value)

            Set the minimum value of the parameter.

            See the minValue method for more information.


        """
        return _hou.IntParmTemplate_setMinValue(self, min_value)

    def maxValue(self) -> "int":
        r"""

        maxValue(self) -> int

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
        return _hou.IntParmTemplate_maxValue(self)

    def setMaxValue(self, max_value: "int") -> "void":
        r"""

        setMaxValue(self, max_value)

            Set the maximum value of the parameter.

            See the maxValue method for more information.


        """
        return _hou.IntParmTemplate_setMaxValue(self, max_value)

    def minIsStrict(self) -> "bool":
        r"""

        minIsStrict(self) -> bool

            Returns whether the minimum value is strictly enforced.

            If a minimum value is not strictly enforced, the slider will not let
            you change the value below the minimum, but you can set the value to
            be lower than the minimum by typing it in, changing it via
            hou.Parm.setValue, or using the ladder handle.

            If it is strictly enforced and you try to change it below the
            minimum value using any mechanism, Houdini will set it to the
            minimum value.

            See also the minValue method.


        """
        return _hou.IntParmTemplate_minIsStrict(self)

    def setMinIsStrict(self, on: "bool") -> "void":
        r"""

        setMinIsStrict(self, on)

            Set whether the minimum value is strictly enforced.

            See the minIsStrict method for more information.


        """
        return _hou.IntParmTemplate_setMinIsStrict(self, on)

    def maxIsStrict(self) -> "bool":
        r"""

        maxIsStrict(self) -> bool

            Return whether the maximum value is strictly enforced.

            See the minIsStrict method for more information.


        """
        return _hou.IntParmTemplate_maxIsStrict(self)

    def setMaxIsStrict(self, on: "bool") -> "void":
        r"""

        setMaxIsStrict(self, on)

            Set whether the maximum value is strictly enforced.

            See the maxIsStrict method for more information.


        """
        return _hou.IntParmTemplate_setMaxIsStrict(self, on)

    def defaultValue(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        defaultValue(self) -> tuple of int

            Return the default value for new parameter instances.

            For example, suppose this parm template is named divisions, the
            naming scheme is XYZW, it has 3 components, and the default value is
            (10, 20, 30). The corresponding parm tuple instance on a node would
            be named divisions and would contain parameters divisionsx,
            divisionsy, and divisionsz. When the node is created, divisionsx
            would be 10, divisionsy would be 20, and divisionsz would be 30.


        """
        return _hou.IntParmTemplate_defaultValue(self)

    def setDefaultValue(self, default_value: "_IntTuple") -> "void":
        r"""

        setDefaultValue(self, tuple_of_default_values)

            Set the default value for new parameter instances to a sequence of
            ints.

            See the defaultValue method for more information. Note that if the
            number of ints in the sequence is different from the number of
            components in the parm template, any extra values will be discarded
            and any missing values will become zeros.


        """
        return _hou.IntParmTemplate_setDefaultValue(self, default_value)

    def defaultExpression(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.

            For example, suppose this parm template is named divisions, the
            naming scheme is XYZW, it has 3 components, the default value is
            (10, 20, 30), the default expression is ($F, hou.frame(), ) and the
            default expression language is (hou.scriptLanguage.Hscript,
            hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
            corresponding parm tuple instance on a node would be named divisions
            and would contain parameters divisionsx, divisionsy, divisionsz.
            When the node is created, divisionsx would have a default Hscript
            expression of $F, divisionsy would have a default Python expression
            of hou.frame(), and divisionsz would have a default value of 30.


        """
        return _hou.IntParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "_StringTuple") -> "void":
        r"""

        setDefaultExpression(self, tuple_of_default_expressions)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.IntParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
        return _hou.IntParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
        return _hou.IntParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "_EnumTuple"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """
        return _hou.IntParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )

    def menuItems(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuItems(self) -> tuple of str

            Return the tuple of internal menu names. If this integer does not
            use a menu, returns an empty tuple.

            These internal menu names are not displayed in the UI, but they can
            be passed to hou.Parm.set.


        """
        return _hou.IntParmTemplate_menuItems(self)

    def setMenuItems(self, menu_items: "_StringTuple") -> "void":
        r"""

        setMenuItems(self, menu_items)

            Set the internal menu names to the given sequence of strings.

            See the menuItems method for more information.

            If the new number of menu items is less than the old number, the
            menu labels will be shortened and the default value will be modified
            if it is out of range.


        """
        return _hou.IntParmTemplate_setMenuItems(self, menu_items)

    def menuLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuLabels(self) -> tuple of str

            Return the tuple of menu labels displayed in the UI. These labels
            are used when this parm template uses a menu.


        """
        return _hou.IntParmTemplate_menuLabels(self)

    def setMenuLabels(self, menu_labels: "_StringTuple") -> "void":
        r"""

        setMenuLabels(self, menu_labels)

            Set the menu labels displayed in the UI to the given sequence of
            strings.

            If the number of menu labels is less than the number of menu items,
            Houdini uses the internal menu item names for the missing labels. If
            the number of labels is more than the number of menu items, Houdini
            discards the extra labels.

            If you want to change both the menu items and menu labels, be sure
            to change the menu items first.


        """
        return _hou.IntParmTemplate_setMenuLabels(self, menu_labels)

    def iconNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        iconNames(self) -> tuple of str

            Return the tuple of icons corresponding to the menu items. If there
            are no icons, returns a tuple of empty strings.

            These icons are used when this parm template uses a menu.


        """
        return _hou.IntParmTemplate_iconNames(self)

    def setIconNames(self, icon_names: "_StringTuple") -> "void":
        r"""

        setIconNames(self, icon_names)

            Set the icon names to the given sequence of strings.


        """
        return _hou.IntParmTemplate_setIconNames(self, icon_names)

    def itemGeneratorScript(self) -> "std::string":
        r"""

        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

            Return the script used to generate menu items, or an empty string if
            there is no such script.


        """
        return _hou.IntParmTemplate_itemGeneratorScript(self)

    def setItemGeneratorScript(self, item_generator_script: "char const *") -> "void":
        r"""

        setItemGeneratorScript(self, item_generator_script)

            Set the script used to generate menu items.

            See the itemGeneratorScript method for more information.


        """
        return _hou.IntParmTemplate_setItemGeneratorScript(self, item_generator_script)

    def itemGeneratorScriptLanguage(self) -> "HOM_EnumValue &":
        return _hou.IntParmTemplate_itemGeneratorScriptLanguage(self)

    def setItemGeneratorScriptLanguage(self, language: "EnumValue") -> "void":
        r"""

        setItemGeneratorScriptLanguage(self, language)

            Set the script language used to generate menu items to a
            hou.scriptLanguage enum value.

            See the itemGeneratorScriptLanguage method for more information.


        """
        return _hou.IntParmTemplate_setItemGeneratorScriptLanguage(self, language)

    def menuType(self) -> "HOM_EnumValue &":
        r"""

        menuType(self) -> hou.menuType enum value

            Return the type of menu. See hou.menuType for more information.


        """
        return _hou.IntParmTemplate_menuType(self)

    def setMenuType(self, menu_type: "EnumValue") -> "void":
        r"""

        setMenuType(self, menu_type)

            Set the type of menu to a hou.menuType enum value.

            See the menuType method for more information.


        """
        return _hou.IntParmTemplate_setMenuType(self, menu_type)

    def menuUseToken(self) -> "bool":
        r"""

        menuUseToken(self) -> bool

            Return whether the parameter is set to the token value instead of
            the index.

            See also the setMenuUseToken method.


        """
        return _hou.IntParmTemplate_menuUseToken(self)

    def setMenuUseToken(self, menuusetoken: "bool") -> "void":
        r"""

        setMenuUseToken(self, on)

            Set whether the parameter is set to the token value instead of the
            index.

            See also the menuUseToken method.


        """
        return _hou.IntParmTemplate_setMenuUseToken(self, menuusetoken)


# Register IntParmTemplate in _hou:
_hou.IntParmTemplate_swigregister(IntParmTemplate)


class IPRViewer(PaneTab):
    r"""

    hou.IPRViewer

    An interactive preview render (IPR) window.

    The IPR viewer progressively refines a render, first providing a rough
    view of the rendered image and eventually providing the fully rendered
    image. When you change a shader value, move an object, etc., the viewer
    will re-render the image.

    When you Ctrl+click on a pixel in the rendered image, Houdini searches
    $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. The version of
    this file that ships with Houdini pops up the shader contributing the
    pixel, or an information window if there is is no shader. If Houdini
    cannot find that Python file it then looks for the Hscript file
    scripts/ipr/pickpixel.cmd.

    When you drag a SHOP node onto the rendered image, Houdini searches for
    and runs scripts/ipr/dragdrop.py. By default, this script assigns the
    SHOP to the object contributing the pixel. If it cannot find a Python
    version, Houdini then looks for scripts/ipr/dragdrop.cmd.

    Note that shelf scripts can access the last location the user clicked on
    with hou.IPRViewer.lastClickLocation.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_IPRViewer

    def __repr__(self) -> "std::string":
        return _hou.IPRViewer___repr__(self)

    def isPaused(self) -> "bool":
        r"""

        isPaused(self) -> bool

            Indicates whether the IPR session is paused. If there is no active
            session, this returns false.


        """
        return _hou.IPRViewer_isPaused(self)

    def isRendering(self) -> "bool":
        r"""

        isRendering(self) -> bool

            Indicates whether the IPR session has an render in progress. Returns
            True even if the render is paused.


        """
        return _hou.IPRViewer_isRendering(self)

    def isActive(self) -> "bool":
        r"""

        isActive(self) -> bool

            Indicates whether an active IPR sessions exists.


        """
        return _hou.IPRViewer_isActive(self)

    def killRender(self) -> "void":
        r"""

        killRender(self)

            Kills the active IPR session (if there is one).


        """
        return _hou.IPRViewer_killRender(self)

    def pauseRender(self) -> "void":
        r"""

        pauseRender(self)

            Pauses the active IPR session (if there is one).


        """
        return _hou.IPRViewer_pauseRender(self)

    def resumeRender(self) -> "void":
        r"""

        resumeRender(self)

            Resumes the active IPR session (if there is one).


        """
        return _hou.IPRViewer_resumeRender(self)

    def startRender(self) -> "void":
        r"""

        startRender(self)

            Start a new render if there is no active IPR session or issue a re-
            render if there is one.


        """
        return _hou.IPRViewer_startRender(self)

    def isPreviewOn(self) -> "bool":
        r"""

        isPreviewOn(self) -> bool

            Return whether or not the Preview checkbox is checked. When it is
            unchecked, the viewer will not progressively refine the image using
            IPR, and will instead use the rendering engine from the ROP node to
            render it.

            See also hou.IPRViewer.setPreview.


        """
        return _hou.IPRViewer_isPreviewOn(self)

    def setPreview(self, on: "bool") -> "void":
        r"""

        setPreview(self, on)

            Check or uncheck the Preview checkbox.

            See hou.IPRViewer.isPreviewOn for more information.


        """
        return _hou.IPRViewer_setPreview(self, on)

    def isAutoSaveOn(self) -> "bool":
        r"""

        isAutoSaveOn(self) -> bool

            Returns whether or not the Auto Save toggle is selected. When turned
            on, IPR will periodically save the render progress to the auto save
            file path. The time between saves can be configured by setting the
            auto save time.

            See also hou.IPRViewer.setAutoSave.


        """
        return _hou.IPRViewer_isAutoSaveOn(self)

    def setAutoSave(self, on: "bool") -> "void":
        r"""

        setAutoSave(self, on)

            Set or unset the Auto Save toggle.

            See hou.IPRViewer.isAutoSaveOn for more information.


        """
        return _hou.IPRViewer_setAutoSave(self, on)

    def autoSavePath(self) -> "std::string":
        r"""

        autoSavePath(self) -> str

            Returns the render save path. This is the path that is used when the
            IPR viewer is set to automatically save render progress to disk.

            See also hou.IPRViewer.setSavePath.


        """
        return _hou.IPRViewer_autoSavePath(self)

    def setAutoSavePath(self, path: "char const *") -> "void":
        r"""

        setAutoSavePath(self, path)

            Sets the render progress save path.

            See also hou.IPRViewer.autoSavePath for more information.


        """
        return _hou.IPRViewer_setAutoSavePath(self, path)

    def isAutoUpdateOn(self) -> "bool":
        r"""

        isAutoUpdateOn(self) -> bool

            Return whether or not the Auto-Update checkbox is checked. When it
            is unchecked, the viewer will not refresh when objects, shaders,
            lights, etc. change. In this case, you can force a re-render by
            clicking on the Render button.

            See also hou.IPRViewer.setAutoUpdate.


        """
        return _hou.IPRViewer_isAutoUpdateOn(self)

    def setAutoUpdate(self, on: "bool") -> "void":
        r"""

        setAutoUpdate(self, on)

            Check or uncheck the Auto-Update checkbox.

            See hou.IPRViewer.isAutoUpdateOn for more information.


        """
        return _hou.IPRViewer_setAutoUpdate(self, on)

    def autoSaveTime(self) -> "double":
        r"""

        autoSaveTime(self) -> float

            Returns the time between IPR auto saves in seconds. When auto saving
            is on, a render progress image is written out at this rate.

            See also hou.IPRViewer.setAutoSaveTime.


        """
        return _hou.IPRViewer_autoSaveTime(self)

    def setAutoSaveTime(self, time: "double") -> "void":
        r"""

        setAutoSaveTime(self, float)

            Sets the auto save time in seconds.

            See also hou.IPRViewer.autoSaveTime for more information.


        """
        return _hou.IPRViewer_setAutoSaveTime(self, time)

    def delay(self) -> "double":
        r"""

        delay(self) -> float

            Return the contents of the viewer's Delay field. This value
            determines how long Houdini waits between when you change a
            parameter value and when it starts re-rendering.

            See also hou.IPRViewer.setDelay and hou.IPRViewer.updateTime.


        """
        return _hou.IPRViewer_delay(self)

    def setDelay(self, time: "double") -> "void":
        r"""

        setDelay(self, time)

            Set the contents of the viewer's Delay field.

            See hou.IPRViewer.delay for more information.


        """
        return _hou.IPRViewer_setDelay(self, time)

    def updateTime(self) -> "double":
        r"""

        updateTime(self) -> float

            Return the contents of the viewer's Update Time field. This value
            determines approximately how long each progressive refinement should
            take. Smaller values will produce more progressive renders where
            detail is added more gradually.

            See also hou.IPRViewer.setUpdateTime and hou.IPRViewer.delay.


        """
        return _hou.IPRViewer_updateTime(self)

    def setUpdateTime(self, time: "double") -> "void":
        r"""

        setUpdateTime(self, time)

            Set the contents of the viewer's Update Time field.

            See hou.IPRViewer.updateTime for more information.


        """
        return _hou.IPRViewer_setUpdateTime(self, time)

    def lastClickLocation(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        lastClickLocation(self) -> (int, int)

            Return the x and y coordinates for the pixel location where the user
            last clicked in the IPR viewer. Note that this location might be
            outside the image: the x and y coordinates can be negative and can
            be greater than or equal to the image resolution. Note that if the
            user never clicked in the viewer, the x and y coordinates will be
            negative.

            You would typically call this method from a shelf script. For
            example, a user can click on a pixel in the IPR viewer and then
            click on the shelf to perform an action on that pixel (e.g. display
            the shader parameters, assign a shader, etc.).

            Use hou.IPRViewer.imageResolution to get the valid range for pixel
            coordinates.

            Note that when you Ctrl-click on a pixel, Houdini searches
            $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. This script
            can access the viewer with kwargs[\"viewer\"] and the location where
            the user clicked with kwargs[\"position\"].

            The following script opens a floating parameter window for the
            shader corresponding to the pixel the user last clicked on.

          > viewer = hou.ui.paneTabOfType(hou.paneTabType.IPRViewer)
          > px, py = viewer.lastClickLocation()
          >
          > if (px < 0 or px > viewer.imageResolution()[0] or
          >         py < 0 or py >= viewer.imageResolution()[1]):
          >     hou.ui.displayMessage(\"Click on the image and then run this script again\")
          > else:
          >     material = viewer.materialNode(px, py)
          >
          >     if material is not None:
          >         parm_window = hou.ui.curDesktop().createFloatingPaneTab(
          >             hou.paneTabType.Parm)
          >         parm_window.setCurrentNode(material)
          >         parm_window.setPin(True)
          >     else:
          >         hou.ui.displayMessage(\"Click on an object to bring up the shader.\")

        """
        return _hou.IPRViewer_lastClickLocation(self)

    def ropNode(self) -> "HOM_Node *":
        r"""

        ropNode(self) -> hou.RopNode or None

            Return the ROP node that is selected in the viewer, or None if
            nothing is selected.


        """
        return _hou.IPRViewer_ropNode(self)

    def setRopNode(self, rop_node: "Node") -> "void":
        r"""

        setRopNode(self, rop_node)

            Set the ROP node to use for rendering.


        """
        return _hou.IPRViewer_setRopNode(self, rop_node)

    def imageResolution(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        imageResolution(self) -> (int, int)

            Return the resolution of the image.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
        return _hou.IPRViewer_imageResolution(self)

    def cropRegion(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        cropRegion(self) -> (float, float, float, float)

            Return the x0, x1, y0, and y1 normalized coordinates of the
            subregion that is selected, where (x0, y0) is the bottom-left corner
            and (x1, y1) is the top-right corner of the subregion.

            You can optionally tell the IPR viewer to only re-render only a
            portion of the image. To select a subportion of the image, hold down
            shift and select the box.

            Note that the bottom-left corner is (0.0, 0.0) and the top-right
            corner is (1.0, 1.0). For example, if the entire image is being
            rendered, this method returns (0.0, 1.0, 0.0, 1.0).


        """
        return _hou.IPRViewer_cropRegion(self)

    def planes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        planes(self) -> tuple of str

            Return the names of the image planes in the rendered output.

            Note that the special Op_Id image plane contains the
            hou.Node.sessionId ids of the object nodes in the image. -1
            indicates that there is no object node associated with the pixel.
            Use hou.IPRViewer.objectNode to access the object corresponding to
            that id.

            Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
            primitives in the image. Use hou.IPRViewer.prim to access the
            primitive corresponding to that id.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
        return _hou.IPRViewer_planes(self)

    def displayedPlane(self) -> "std::string":
        r"""

        displayedPlane(self) -> str

            Return the name of the currently-displayed image plane in the
            rendered output.

            Note that the special Op_Id image plane contains the
            hou.Node.sessionId ids of the object nodes in the image. -1
            indicates that there is no object node associated with the pixel.
            Use hou.IPRViewer.objectNode to access the object corresponding to
            that id.

            Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
            primitives in the image. Use hou.IPRViewer.prim to access the
            primitive corresponding to that id.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
        return _hou.IPRViewer_displayedPlane(self)

    def pixel(
        self, plane_name: "char const *", x: "int", y: "int"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        pixel(self, plane_name, x, y) -> tuple of float

            Return the value of a pixel in one plane of the image. This method
            returns a tuple of 1 to 4 floats, depending on the type of image
            plane.

            Note that the color plane is named C.

            Raises hou.OperationFailed if the plane name is invalid, the pixel
            location is outside the image, or the viewer does not contain an
            image.

            You can determine the number of components in the image plane using
            the following: len(viewer.pixel(plane_name, 0, 0)).

          > >>> viewer.pixel(\"C\", 300, 200)
          > (0.69970703125, 0.46728515625, 0.289794921875, 1.0)

        """
        return _hou.IPRViewer_pixel(self, plane_name, x, y)

    def pixels(
        self, plane_name: "char const *"
    ) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        r"""

        pixels(self, plane_name) -> tuple of tuple of float

            Returns the value of all pixels in one plane of the image. This
            method returns a tuple of tuples of 1 to 4 floats, depending on the
            type of image plane. The results are in row-major order, starting at
            the bottom left corner of the IPR image.

            Note that the color plane is named C.

            Raises hou.OperationFailed if the plane name is invalid or the
            viewer does not contain an image.

          > >>> all_pixels = viewer.pixels(\"C\")
          > >>> width = viewer.imageResolution()[0]
          > >>> all_pixels[width*200 + 300]
          > (0.69970703125, 0.46728515625, 0.289794921875, 1.0)

        """
        return _hou.IPRViewer_pixels(self, plane_name)

    def evaluatedStyleSheetJSON(self, x: "int", y: "int") -> "std::string":
        r"""

        evaluatedStyleSheetJSON(self, x, y) -> str

            Returns a JSON string describing the material style sheet at a given
            pixel. If no style sheet is active, an empty string is returned.


        """
        return _hou.IPRViewer_evaluatedStyleSheetJSON(self, x, y)

    def evaluatedStyleSheetPaths(
        self, x: "int", y: "int"
    ) -> "std::vector< std::pair< std::string,int >,std::allocator< std::pair< std::string,int > > >":
        r"""

        evaluatedStyleSheetPaths(self, x, y) -> tuple of str

            Returns a list of paths to the styles that contribute to the style
            sheet at the current pixel.


        """
        return _hou.IPRViewer_evaluatedStyleSheetPaths(self, x, y)

    def saveFrame(self, *args) -> "bool":
        r"""

        saveFrame(self, file_path, snapshot=0, xres=-1, yres=-1, color='C',
        alpha='C', scope='*', lut='', gamma=1.0, convert=True) -> bool

            Saves the current IPR render to the specified file path. It is
            possible to save an in progress/incomplete render.

            The output image type is inferred from the file extension on the
            provided file path. The snapshot parameter controls which IPR
            snapshot to save. A value of 0 indicates the active render.

            The native IPR resolution is used by default, however a custom
            resolution can be specified with the xres and yres parameters. The
            color and alpha parameters control which render planes are used when
            writing RGBA images like .jpg or .png. If a deep image format such
            as .pic or .exr is used, the scope parameter can be used to specify
            which image planes to include in the output.


        """
        return _hou.IPRViewer_saveFrame(self, *args)

    def objectNode(self, x: "int", y: "int") -> "HOM_Node *":
        r"""

        objectNode(self, x, y) -> hou.ObjNode or None

            Return the object node contributing the pixel at the specified
            location, or None if there is no object at the pixel or if the pixel
            location is outside the image bounds

            The following function returns the SOP node containing the geometry
            that contributes the pixel to the final image:

          > def sopNode(viewer, x, y):
          >     obj_node = viewer.objectNode(x, y)
          >     return (obj_node.renderNode() if obj_node is not None else None)

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
        return _hou.IPRViewer_objectNode(self, x, y)

    def prim(self, x: "int", y: "int") -> "HOM_Prim *":
        r"""

        prim(self, x, y) -> hou.Prim or None

            Return the geometry primitive contributing the pixel at the
            specified location, or None if there is nothing at the pixel or if
            the pixel location is outside the image bounds

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
        return _hou.IPRViewer_prim(self, x, y)

    def materialNode(self, x: "int", y: "int") -> "HOM_Node *":
        r"""

        materialNode(self, x, y) -> hou.ShopNode or None

            Return the SHOP node contributing the pixel at the specified
            location, or None if there is nothing at the pixel, the pixel
            location is outside the image bounds, or there is no shader on the
            geometry.

            This method first checks the primitive corresponding to the pixel
            and returns the SHOP corresponding to its shop_materialpath
            attribute. If the primitive does not have this attribute then it
            returns the SHOP assigned to the object. If no SHOP is assigned to
            the object, it returns None.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
        return _hou.IPRViewer_materialNode(self, x, y)

    def usingOCIO(self) -> "bool":
        r"""

        usingOCIO(self) -> bool

            Query if OpenColorIO is being used for color correction in the
            viewer.


        """
        return _hou.IPRViewer_usingOCIO(self)

    def setUsingOCIO(self, enable: "bool") -> "void":
        r"""

        setUsingOCIO(self, enable)

            Enable or disable OpenColorIO for color correction in the viewer.


        """
        return _hou.IPRViewer_setUsingOCIO(self, enable)

    def setOCIODisplayView(
        self, display: "char const *" = None, view: "char const *" = None
    ) -> "void":
        r"""

        setOCIODisplayView(self, display=\"\", view=\"\")

            Set the OpenColorIO display name, view name, or both. The display
            and view together define the output colorspace for the viewer, and
            any number of color transforms (Looks) to be performed on the linear
            viewport image.


        """
        return _hou.IPRViewer_setOCIODisplayView(self, display, view)

    def getOCIODisplay(self) -> "std::string":
        r"""

        getOCIODisplay(self) -> str

            Return the current OpenColorIO display used for color correction.


        """
        return _hou.IPRViewer_getOCIODisplay(self)

    def getOCIOView(self) -> "std::string":
        r"""

        getOCIOView(self) -> str

            Return the current OpenColorIO view used for color correction.


        """
        return _hou.IPRViewer_getOCIOView(self)


# Register IPRViewer in _hou:
_hou.IPRViewer_swigregister(IPRViewer)


class Keyframe(BaseKeyframe):
    r"""

    hou.Keyframe

    Class representing the default keyframe type, a numerical keyframe.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values)

            Return a new Keyframe object. You can pass no parameters (the result
            will have no value set), a float value, a float value and float
            time, or a Keyframe object.


        """
        _hou.Keyframe_swiginit(self, _hou.new_Keyframe(*args))

    __swig_destroy__ = _hou.delete_Keyframe

    def __eq__(self, keyframe: "HOM_PtrOrNull< HOM_BaseKeyframe >") -> "bool":
        return _hou.Keyframe___eq__(self, keyframe)

    def __hash__(self) -> "int":
        return _hou.Keyframe___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Keyframe___repr__(self)

    def evaluatedType(self) -> "HOM_EnumValue &":
        r"""

        evaluatedType(self) -> hou.parmData enum value

            Return the data type of the keyframe's evaluated value. For
            keyframes storing numerical values this method returns
            hou.parmData.Float.


        """
        return _hou.Keyframe_evaluatedType(self)

    def setValue(self, value: "double") -> "void":
        r"""

        setValue(self, value)

            Sets the value leaving the keyframe.


        """
        return _hou.Keyframe_setValue(self, value)

    def value(self) -> "double":
        r"""

        value(self) -> double

            Returns the value leaving the keyframe.

            This method raises hou.KeyframeValueNotSet if the value has not been
            set.


        """
        return _hou.Keyframe_value(self)

    def isValueSet(self) -> "bool":
        r"""

        isValueSet(self) -> bool

            Returns True if the value entering or leaving the keyframe has been
            set.


        """
        return _hou.Keyframe_isValueSet(self)

    def setInValue(self, in_value: "double") -> "void":
        r"""

        setInValue(self, in_value)

            Sets the value entering the keyframe. Sets the value leaving the
            keyframe, if not already set. Unties the value.


        """
        return _hou.Keyframe_setInValue(self, in_value)

    def unsetInValue(self) -> "void":
        r"""

        unsetInValue(self)

            Unsets the value entering the keyframe and tie the values.


        """
        return _hou.Keyframe_unsetInValue(self)

    def inValue(self) -> "double":
        r"""

        inValue(self) -> double

            Returns the value entering the keyframe.

            This method raises hou.KeyframeValueNotSet if the value has not been
            set or the value is tied.


        """
        return _hou.Keyframe_inValue(self)

    def isValueTied(self) -> "bool":
        r"""

        isValueTied(self) -> bool

            Returns True if the value entering the keyframe has not been set.


        """
        return _hou.Keyframe_isValueTied(self)

    def isValueUsed(self) -> "bool":
        r"""

        isValueUsed(self) -> bool

            Returns True if the value entering or leaving the keyframe is being
            used.


        """
        return _hou.Keyframe_isValueUsed(self)

    def useValue(self, use: "bool") -> "void":
        r"""

        useValue(self, on)

            Sets the value used flag.


        """
        return _hou.Keyframe_useValue(self, use)

    def setSlope(self, slope: "double") -> "void":
        r"""

        setSlope(self, slope)

            Sets the slope leaving the keyframe.


        """
        return _hou.Keyframe_setSlope(self, slope)

    def slope(self) -> "double":
        r"""

        slope(self) -> double

            Returns the slope leaving the keyframe.

            This method raises hou.KeyframeValueNotSet if the slope has not been
            set.


        """
        return _hou.Keyframe_slope(self)

    def isSlopeSet(self) -> "bool":
        r"""

        isSlopeSet(self) -> bool

            Returns True if the slope entering or leaving the keyframe has been
            set.


        """
        return _hou.Keyframe_isSlopeSet(self)

    def isSlopeUsed(self) -> "bool":
        r"""

        isSlopeUsed(self) -> bool

            Returns True if the slope entering or leaving the keyframe is being
            used.


        """
        return _hou.Keyframe_isSlopeUsed(self)

    def useSlope(self, use: "bool") -> "void":
        r"""

        useSlope(self, on)

            Sets the slope used flag.


        """
        return _hou.Keyframe_useSlope(self, use)

    def isSlopeAuto(self) -> "bool":
        r"""

        isSlopeAuto(self) -> bool

            Returns True if the slope leaving the keyframe is set to automatic.


        """
        return _hou.Keyframe_isSlopeAuto(self)

    def setSlopeAuto(self, on: "bool") -> "void":
        r"""

        setSlopeAuto(self, on)

            Sets the slope leaving the keyframe to automatic.


        """
        return _hou.Keyframe_setSlopeAuto(self, on)

    def setInSlope(self, in_slope: "double") -> "void":
        r"""

        setInSlope(self, in_slope)

            Sets the slope entering the keyframe. Sets the slope leaving the
            keyframe, if not already set. Unties the slope.


        """
        return _hou.Keyframe_setInSlope(self, in_slope)

    def unsetInSlope(self) -> "void":
        r"""

        unsetInSlope(self)

            Unsets the slope entering the keyframe and tie the slope.


        """
        return _hou.Keyframe_unsetInSlope(self)

    def inSlope(self) -> "double":
        r"""

        inSlope(self) -> double

            Returns the slope entering the keyframe.

            This method raises hou.KeyframeValueNotSet if the slope has not been
            set or the slope is tied.


        """
        return _hou.Keyframe_inSlope(self)

    def isSlopeTied(self) -> "bool":
        r"""

        isSlopeTied(self) -> bool

            Returns True if the slope entering the keyframe has not been set.


        """
        return _hou.Keyframe_isSlopeTied(self)

    def isInSlopeAuto(self) -> "bool":
        r"""

        isInSlopeAuto(self) -> bool

            Returns True if the slope entering the keyframe is set to automatic.


        """
        return _hou.Keyframe_isInSlopeAuto(self)

    def setInSlopeAuto(self, on: "bool") -> "void":
        r"""

        setInSlopeAuto(self, on)

            Sets the slope entering the keyframe to automatic.


        """
        return _hou.Keyframe_setInSlopeAuto(self, on)

    def setAccel(self, accel: "double") -> "void":
        r"""

        setAccel(self, accel)

            Sets the acceleration leaving the keyframe.


        """
        return _hou.Keyframe_setAccel(self, accel)

    def accel(self) -> "double":
        r"""

        accel(self) -> double

            Returns the acceleration leaving the keyframe.

            This function raises hou.KeyframeValueNotSet if the acceleration has
            not been set.


        """
        return _hou.Keyframe_accel(self)

    def isAccelSet(self) -> "bool":
        r"""

        isAccelSet(self) -> bool

            Returns True if the acceleration entering or leaving the keyframe
            has been set.


        """
        return _hou.Keyframe_isAccelSet(self)

    def isAccelUsed(self) -> "bool":
        r"""

        isAccelUsed(self) -> bool

            Returns True if the acceleration entering or leaving the keyframe is
            being used.


        """
        return _hou.Keyframe_isAccelUsed(self)

    def useAccel(self, use: "bool") -> "void":
        r"""

        useAccel(self, on)

            Sets the acceleration used flag.


        """
        return _hou.Keyframe_useAccel(self, use)

    def setInAccel(self, in_accel: "double") -> "void":
        r"""

        setInAccel(self, in_accel)

            Sets the acceleration entering the keyframe. Sets the acceleration
            leaving the keyframe, if not already set. Unties the acceleration.


        """
        return _hou.Keyframe_setInAccel(self, in_accel)

    def unsetInAccel(self) -> "void":
        r"""

        unsetInAccel(self)

            Unsets the acceleration entering the keyframe and tie the
            acceleration.


        """
        return _hou.Keyframe_unsetInAccel(self)

    def inAccel(self) -> "double":
        r"""

        inAccel(self) -> double

            Returns the acceleration entering the keyframe.

            This method raises hou.KeyframeValueNotSet if the acceleration has
            not been set or it is tied.


        """
        return _hou.Keyframe_inAccel(self)

    def isAccelTied(self) -> "bool":
        r"""

        isAccelTied(self) -> bool

            Returns True if the acceleration entering the keyframe has not been
            set.


        """
        return _hou.Keyframe_isAccelTied(self)

    def interpretAccelAsRatio(self, on: "bool") -> "void":
        r"""

        interpretAccelAsRatio(self, on)

            Sets whether Houdini should interpret the acceleration values
            entering and leaving the keyframe as a single ratio. When set to
            True, the ratio of the in-acceleration to out-acceleration is always
            maintained. If, for example, the in-acceleration is made to be twice
            as large using the Animation Editor, then the out-acceleration will
            automatically be adjusted to be twice as large as well. This is the
            default behavior for Houdini keyframes.


        """
        return _hou.Keyframe_interpretAccelAsRatio(self, on)

    def isAccelInterpretedAsRatio(self) -> "bool":
        r"""

        isAccelInterpretedAsRatio(self) -> bool

            Returns True if the acceleration values entering and leaving the
            keyframe are interpreted as a ratio by Houdini.


        """
        return _hou.Keyframe_isAccelInterpretedAsRatio(self)


# Register Keyframe in _hou:
_hou.Keyframe_swigregister(Keyframe)


class LabelParmTemplate(ParmTemplate):
    r"""

    hou.LabelParmTemplate

    Describes a label parameter. Unlike most other parameters, labels do not
    store parameter values.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, column_labels=(), is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None, tags={})

            Create a new LabelParmTemplate instance.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            column_labels
                See the setColumnLabels method for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            tags
                See hou.ParmTemplate.tags for more information.

            Note that the number of components in a label parm template
            corresponds to the number of column labels.


        """
        _hou.LabelParmTemplate_swiginit(
            self, _hou.new_LabelParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_LabelParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.LabelParmTemplate___repr__(self)

    def labelParmType(self) -> "HOM_EnumValue &":
        r"""

        labelParmType() -> hou.labelParmType

            Returns the label parm type for this parm template.


        """
        return _hou.LabelParmTemplate_labelParmType(self)

    def setLabelParmType(self, label_parm_type: "EnumValue") -> "void":
        r"""

        setLabelParmType(label_parm_type)

            Sets the label parm type to a hou.labelParmType enum value.


        """
        return _hou.LabelParmTemplate_setLabelParmType(self, label_parm_type)

    def columnLabels(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        columnLabels() -> tuple of str

            Return the tuple of strings of column labels. Normally, label parm
            templates do not have any column labels. However, they may have
            these extra labels that are displayed in addition to the main label.

            Note that the number of components in a label parm template
            corresponds to the number of column labels.


        """
        return _hou.LabelParmTemplate_columnLabels(self)

    def setColumnLabels(self, column_labels: "_StringTuple") -> "void":
        r"""

        setColumnLabels(column_labels)

            Set the column labels to a sequence of strings.

            The parameter editor in the <Type Properties Dialog> always has at
            least one column label, so if you supply an empty sequence there
            will be one column label that is an empty string.

            See the columnLabels method for more information.


        """
        return _hou.LabelParmTemplate_setColumnLabels(self, column_labels)


# Register LabelParmTemplate in _hou:
_hou.LabelParmTemplate_swigregister(LabelParmTemplate)


class logging(object):
    r"""

    hou.logging

    Module containing functions and classes for logging warnings and errors.

    Houdini's logging system consists of sources and sinks. Sources generate
    and distribute log entries. Sinks receive log entries from sources, and
    do something with them. Sources are global, and identified by a unique
    name string (such as Node Errors which is a source that generates a log
    entry for every message, warning, or error generated by nodes). There
    can be any number of sinks created in a Houdini session, and each one
    can connect to a different set of sources. Thus you could create one
    sink that sends all node errors to a file, another sink that sends all
    rendering messages to a different file, and a third sink that captures
    in memory all log entries generated by any sink (the same source may be
    connected to multiple sinks). This system allows for fine grained
    control over which log entries are captured, and what is done with each
    log entry.

    API



    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_logging

    def __repr__(self) -> "std::string":
        return _hou.logging___repr__(self)

    def sources(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        hou.logging.sources

        Return a tuple of all available log source names.

        USAGE
          sources() -> tuple of str

        The HDK can be used to create additional log sources, but the default
        list of sources returned by this method will be:

          * Generic Logging: Logs generated by Houdini which do not fall into
            any other category.

          * Licensing: Messages related to acquiring licenses to run Houdini.

          * Mocap Stream: Messages generated by motion capture devices.

          * Networking: Messages generated by networking components such as
            Houdini's built-in web server.

          * Node Errors: All messages, warnings, and errors generated by Houdini
            nodes.

          * Rendering: Messages generated by Karma running within the Houdini
            process. Use hou.logging.setRenderLogVerbosity to set the equivalent
            of the verbosity command line argument for external rendering
            processes.

          * Standard Error: Text sent to the stderr stream.

          * Standard Output: Text sent to the stdout stream.

          * USD Logging: Messages generated in the USD logging system.


        """
        return _hou.logging_sources(self)

    def setRenderLogVerbosity(self, verbosity: "int") -> "void":
        r"""

        hou.logging.setRenderLogVerbosity

        Set the Karma logging verbosity level.

        USAGE
          setRenderLogVerbosity(verbosity)

        Set the current logging verbosity level for Karma running within the
        current Houdini session. This is equivalent to the value of the -V
        values passed to the husk process for a command line render. Values
        range from 0 to 9, and high values can impact the performance of the
        render.


        """
        return _hou.logging_setRenderLogVerbosity(self, verbosity)

    def renderLogVerbosity(self) -> "int":
        r"""

        hou.logging.renderLogVerbosity

        Return the Karma logging verbosity level.

        USAGE
          renderLogVerbosity() -> int

        Return the current logging verbosity level for Karma running within the
        current Houdini session. This is equivalent to the value of the -V
        values passed to the husk process for a command line render. Values
        range from 0 to 9, and high values can impact the performance of the
        render.


        """
        return _hou.logging_renderLogVerbosity(self)

    def saveLogsToFile(
        self,
        logs: "std::vector< HOM_logging_LogEntry,std::allocator< HOM_logging_LogEntry > > const &",
        filepath: "char const *",
    ) -> "void":
        r"""

        hou.logging.saveLogsToFile

        Save a tuple of LogEntry objects to a file in JSON format.

        USAGE
          saveLogsToFile(logs, filepath)

        Creates a file containing a JSON representation of a collection of
        hou.logging.LogEntry objects. This file can be converted back to a tuple
        of hou.logging.LogEntry objects by calling hou.logging.loadLogsFromFile
        with the same filepath.


        logs
            Iterable object containing hou.Logging.LogEntry objects which are to
            be saved to disk in a JSON format the preserves all available
            information from each entry.

        filepath
            Path to the file on disk where the log entries will be written.


        """
        return _hou.logging_saveLogsToFile(self, logs, filepath)

    def loadLogsFromFile(
        self, filepath: "char const *"
    ) -> "std::vector< HOM_logging_LogEntry,std::allocator< HOM_logging_LogEntry > >":
        r"""

        hou.logging.loadLogsFromFile

        Load a tuple of LogEntry objects saved in JSON format from a file.

        USAGE
          loadLogsFromFile(filepath) -> tuple of hou.logging.LogEntry

        Returns a tuple of log entries stored in a JSON file on disk. This file
        was most likely created with a call to hou.logging.saveLogsToFile.


        filepath
            The path to the file containing the JSON representation of an array
            of log entries.


        """
        return _hou.logging_loadLogsFromFile(self, filepath)

    def createSource(self, source_name: "char const *") -> "void":
        r"""

        hou.logging.createSource

        Create a new logging source which can send out log entries generated in
        python.

        USAGE
          createSource(source_name)

        Creates a new logging source that can be passed as the source_name
        argument to the hou.logging.log method. That method will create new
        logging sources automatically, but it can be useful to create logging
        sources before any logs are generated by that source so the user can
        enable the source in the Log Viewer pane.


        source_name
            The name for the new logging source. If this name matches any
            existing source (as returned by hou.logging.sources), this method
            does nothing.


        """
        return _hou.logging_createSource(self, source_name)

    def log(
        self, entry: "_logging_LogEntry", source_name: "char const *" = None
    ) -> "void":
        r"""

        hou.logging.log

        Send a LogEntry object to all log sinks connected to a logging source.

        USAGE
          log(entry, source_name = None)

        Sends a hou.logging.LogEntry from a source with the specified
        source_name.


        entry
            A hou.logging.LogEntry object which will be sent from the named
            logging source to all connected sinks. The source attribute of the
            log entry object will be automatically overridden to use the
            specified source_name.

        source_name
            The name of the logging source from which the log entry is sent.
            Only logging sources compatible with sending python log entries can
            be used here. If no value is specified, the value is assumed to be
            Python Logging. Other valid values are Generic Logging, or any value
            that does not match an existing logging source name. In this case a
            new logging source is automatically created as if
            hou.logging.createSource had been called.


        """
        return _hou.logging_log(self, entry, source_name)

    def defaultSink(self, force_create: "bool" = False) -> "HOM_logging_MemorySink *":
        r"""

        hou.logging.defaultSink

        Return a shared memory sink object owned by the current Houdini session.

        USAGE
          defaultSink(force_create) -> hou.logging.MemorySink or None

        Every Houdini session can have a single shared hou.logging.MemorySink
        object which is used by all Log Viewer panes to display logs generated
        by the current Houdini session. This function provides access to this
        shared sink object.


        force_create
            If the default sink for the current Houdini session has not been
            created, this parameter controls whether the default sink should be
            created. Otherwise this method will return None. If the default sink
            has already been created, this parameter has no effect.


        """
        return _hou.logging_defaultSink(self, force_create)


# Register logging in _hou:
_hou.logging_swigregister(logging)


class _logging_FileSink(_logging_Sink):
    r"""

    hou.logging.FileSink

    Represents a logging destination that writes log entries to a file.

    This kind of sink can be used to send log entries to a file on disk.
    Some of the log entry details are lost in writing the data to disk, as
    each log entry is output simply as a time stamp followed by the message
    text. So for most situations, using the Log Viewer pane to investigate
    log entries will be preferable.


    Tip
        In order to ensure all logs are captured and committed to disk, this
        sink type opens the log file, writes the log entry, and closes the
        file for each log message. This can introduce noticeable performance
        issues if a large amount of information is being logged. Therefore
        it is strongly recommended that the destination file be local to the
        machine running Houdini, and preferably be kept on an SSD hard
        drive.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, filepath: "char const *"):
        r"""

        __init__(self, filepath)

            Creates a new file sink object which writes logs to the specified
            file path.


        """
        _hou._logging_FileSink_swiginit(self, _hou.new__logging_FileSink(filepath))

    __swig_destroy__ = _hou.delete__logging_FileSink

    def __repr__(self) -> "std::string":
        return _hou._logging_FileSink___repr__(self)

    def filePath(self) -> "std::string":
        r"""

        filePath() -> str

            Returns the path to the file where logs are written.


        """
        return _hou._logging_FileSink_filePath(self)


# Register _logging_FileSink in _hou:
_hou._logging_FileSink_swigregister(_logging_FileSink)


class _logging_LogEntry(object):
    r"""

    hou.logging.LogEntry

    Represents a single log message that is sent by a source to a sink.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(
        self,
        message: "char const *" = None,
        source: "char const *" = None,
        source_context: "char const *" = None,
        severity: "EnumValue" = None,
        verbosity: "int" = 0,
        time: "double" = 0.0,
        thread_id: "int" = 0,
        has_external_info: "bool" = False,
        external_host_name: "char const *" = None,
        external_identifier: "char const *" = None,
        external_command_line: "char const *" = None,
        external_process_id: "int" = 0,
    ):
        r"""

        __init__(self, message = None, source = None, source_context = None,
        severity = None, verbosity = 0, time = 0.0, thread_id = 0,
        has_external_info = False, external_host_name = None,
        external_identifier = None, external_command_line = None,
        external_process_id = 0)

            Return a new LogEntry with the provided data members.


        """
        _hou._logging_LogEntry_swiginit(
            self,
            _hou.new__logging_LogEntry(
                message,
                source,
                source_context,
                severity,
                verbosity,
                time,
                thread_id,
                has_external_info,
                external_host_name,
                external_identifier,
                external_command_line,
                external_process_id,
            ),
        )

    __swig_destroy__ = _hou.delete__logging_LogEntry

    def __hash__(self) -> "int":
        return _hou._logging_LogEntry___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou._logging_LogEntry___repr__(self)

    def source(self) -> "std::string":
        r"""

        source() -> str

            Return the names of the source that generated this log entry.


        """
        return _hou._logging_LogEntry_source(self)

    def sourceContext(self) -> "std::string":
        r"""

        sourceContext() -> str

            Return an optional string that identifies the context within the
            source that generated this log entry. One example is that the Node
            Errors source sets this value to the path of the specific Houdini
            node that generated the log entry.


        """
        return _hou._logging_LogEntry_sourceContext(self)

    def message(self) -> "std::string":
        r"""

        message() -> str

            Return the main log entry message text.


        """
        return _hou._logging_LogEntry_message(self)

    def severity(self) -> "HOM_EnumValue *":
        r"""

        severity() -> hou.severityType

            Return an optional severity value for the log entry. This value will
            be set for node error logs, USD logs, and other sources with a well
            defined set of logging severity levels.


        """
        return _hou._logging_LogEntry_severity(self)

    def verbosity(self) -> "int":
        r"""

        verbosity() -> int

            Return an optional verbosity value for the log entry. This value
            will be set for rendering logs, and indicates the minimum
            hou.logging.renderLogVerbosity level required for Karma to generate
            this log entry.


        """
        return _hou._logging_LogEntry_verbosity(self)

    def time(self) -> "double":
        r"""

        time() -> float

            Return the time at which this log entry was generated. This value is
            expressed as the number of seconds since January 1, 1970, 00:00:00
            (UTC). This value can be converted to a local time using the python
            time module using code such as time.strftime(\"%H:%M:%S\",
            time.localtime(log.time())). Although log entries from a single
            source should always arrive in chronological order, some sources may
            delay their log reporting, and so log entries may arrive at a sink
            out of order.


        """
        return _hou._logging_LogEntry_time(self)

    def threadId(self) -> "int":
        r"""

        threadId() -> int

            Return a number that uniquely identifies within a given Houdini
            session which thread in the process generated the log entry. This
            can be useful to establish a chronology of log entries when multiple
            threads are generating logs simultaneously.


        """
        return _hou._logging_LogEntry_threadId(self)

    def hasExternalInfo(self) -> "bool":
        r"""

        hasExternalInfo() -> bool

            Return True if this log entry was generated by a process other than
            the current Houdini session. In this case, the various methods
            starting with external will return meaningful information. If this
            method returns False, the external methods should not be called on
            this object.


        """
        return _hou._logging_LogEntry_hasExternalInfo(self)

    def externalHostName(self) -> "std::string":
        r"""

        externalHostName() -> str

            If the external process was running on a different machine, return
            the name of the machine running the process. Otherwise return an
            empty string.


        """
        return _hou._logging_LogEntry_externalHostName(self)

    def externalIdentifier(self) -> "std::string":
        r"""

        externalIdentifier() -> str

            Return an optional string to help identify the machine or process
            which generated the log entry. The meaning of this value varies
            depending on the logging source.


        """
        return _hou._logging_LogEntry_externalIdentifier(self)

    def externalCommandLine(self) -> "std::string":
        r"""

        externalCommandLine() -> str

            Return the full command line used to launch the external process
            that generated this log entry.


        """
        return _hou._logging_LogEntry_externalCommandLine(self)

    def externalProcessId(self) -> "int":
        r"""

        externalProcessId() -> int

            Return the process identifier (pid) of the process that generated
            the log entry.


        """
        return _hou._logging_LogEntry_externalProcessId(self)

    def _asVoidPointer(self) -> "void *":
        return _hou._logging_LogEntry__asVoidPointer(self)


# Register _logging_LogEntry in _hou:
_hou._logging_LogEntry_swigregister(_logging_LogEntry)


class _logging_MemorySink(_logging_Sink):
    r"""

    hou.logging.MemorySink

    Represents a logging destination that stores log entries in memory.

    All log entries sent to this sink are held in memory forever unless
    stealLogEntries is called. Depending on the frequency of logging, this
    can eventually result in a very large amount of memory being consumed by
    these logs, however in most normal operating circumstances this is very
    unlikely to be a problem.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        hou.logging.MemorySink

        Represents a logging destination that stores log entries in memory.

        All log entries sent to this sink are held in memory forever unless
        stealLogEntries is called. Depending on the frequency of logging, this
        can eventually result in a very large amount of memory being consumed by
        these logs, however in most normal operating circumstances this is very
        unlikely to be a problem.


        """
        _hou._logging_MemorySink_swiginit(self, _hou.new__logging_MemorySink())

    __swig_destroy__ = _hou.delete__logging_MemorySink

    def __repr__(self) -> "std::string":
        return _hou._logging_MemorySink___repr__(self)

    def logEntries(self) -> "HOM_IterableList< HOM_logging_LogEntry > *":
        r"""

        logEntries() -> iterable of hou.logging.LogEntry

            Return an iterable object that represents all the log entries held
            in memory by this sink object.


        """
        return _hou._logging_MemorySink_logEntries(self)

    def stealLogEntries(
        self,
    ) -> "std::vector< HOM_logging_LogEntry,std::allocator< HOM_logging_LogEntry > >":
        r"""

        stealLogEntries() -> tuple of hou.logging.LogEntry

            Returns a tuple of all log entries that were held in memory by this
            sink object. In addition, all log entries owned by this sink object
            are cleared from memory. Thus subsequent calls to logEntries or
            stealLogEntries will not return any of these log entries again.


        """
        return _hou._logging_MemorySink_stealLogEntries(self)


# Register _logging_MemorySink in _hou:
_hou._logging_MemorySink_swigregister(_logging_MemorySink)


class LopLockedStage(object):
    r"""

    hou.LopLockedStage

    Guarantees the lifetime of a USD stage created by a LOP node.

    This object is returned by a call to hou.Geometry.importLop. This object
    must remain in scope as long as the hou.Geometry object contains packed
    primitives representing USD primitives created from the LOP node. Once
    this object leaves scope, it may become impossible to view or unpack the
    USD packed primitives in the hou.Geometry object.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_LopLockedStage

    def __eq__(self, stage: "HOM_PtrOrNull< HOM_LopLockedStage >") -> "bool":
        return _hou.LopLockedStage___eq__(self, stage)

    def __ne__(self, stage: "HOM_PtrOrNull< HOM_LopLockedStage >") -> "bool":
        return _hou.LopLockedStage___ne__(self, stage)

    def __hash__(self) -> "int":
        return _hou.LopLockedStage___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.LopLockedStage___repr__(self)

    def rootLayerIdentifier(self) -> "std::string":
        r"""

        rootLayerIdentifier(self) -> str

            Returns the identifier for the root layer of the stage held by this
            object. This will always be an anonymous layer identifier.


        """
        return _hou.LopLockedStage_rootLayerIdentifier(self)


# Register LopLockedStage in _hou:
_hou.LopLockedStage_swigregister(LopLockedStage)


class LopNetwork(Node):
    r"""

    hou.LopNetwork

    Represents a lighting node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_LopNetwork

    def __repr__(self) -> "std::string":
        return _hou.LopNetwork___repr__(self)

    def isDebugFlagSet(self) -> "bool":
        r"""

        isDebugFlagSet(self) -> bool

            Returns True if the node's debug flag is turned on. Returns False
            otherwise.


        """
        return _hou.LopNetwork_isDebugFlagSet(self)

    def setDebugFlag(self, on: "bool") -> "void":
        r"""

        setDebugFlag(self, on)

            Turns the node's debug flag on or off. The debug flag on a LOP node
            is used to force the node to create its own USD Layer and apply its
            edits in that new layer. This makes it easier to track which scene
            graph modifications were made by which LOP node. Setting this flag
            will also affect the performance of the LOP Network since
            composition of the USD stage takes longer if there are more layers.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.LopNetwork_setDebugFlag(self, on)

    def displayNode(self) -> "HOM_Node *":
        r"""

        displayNode(self) -> Node

            Return the LOP node inside this network with its display flag on.
            Otherwise, return None.


        """
        return _hou.LopNetwork_displayNode(self)

    def viewerNode(self) -> "HOM_Node *":
        r"""

        viewerNode(self) -> Node

            Return the LOP node inside this LOP network with its display flag
            on. This method exists to mirror the matching hou.LopNode.viewerNode
            method. But unlike that method, in a LOP network, unless there are
            no child nodes at all, there will always be a node with the display
            flag set, so this method will return the same values as the
            displayNode method.


        """
        return _hou.LopNetwork_viewerNode(self)

    def viewportOverrides(
        self, lop: "LopNode", output_index: "int" = 0
    ) -> "HOM_LopViewportOverrides *":
        r"""

        viewportOverrides(self, lop, output_index = 0) ->
        hou.LopViewportOverrides

            Return a hou.LopViewportOverrides object that allows editing of the
            current session-only modifications which should be applied to any
            scene being viewed in a Scene Graph Tree pane or a Scene Viewer
            pane.

            The lop must be a hou.LopNode object. The cooked stage from this LOP
            Node is used to perform the requested edit operations in the
            returned hou.LopViewportOverrides object. The output_index controls
            which output of this LOP node will be used to author the stage
            presented through the hou.LopViewportOverrides.stage method. The
            layer_index parameter controls which specific session sublayer is to
            be modified.


        """
        return _hou.LopNetwork_viewportOverrides(self, lop, output_index)

    def saveNamedViewportOverrides(self, name: "char const *") -> "void":
        r"""

        saveNamedViewportOverrides(self, name)

            Saves the current set of session overrides to the LOP Network under
            the specified name. This set of overrides will be saved to the hip
            file, and can be restored with the loadNamedViewportOverrides
            method.


        """
        return _hou.LopNetwork_saveNamedViewportOverrides(self, name)

    def loadNamedViewportOverrides(self, name: "char const *") -> "void":
        r"""

        loadNamedViewportOverrides(self, name)

            Loads the session overrides saved under the specified name on the
            LOP Network. This set of overrides will be applied to any viewport
            pointed at this LOP Network. These named session override sets can
            be created with the saveNamedViewportOverrides method.


        """
        return _hou.LopNetwork_loadNamedViewportOverrides(self, name)

    def namedViewportOverrides(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        namedViewportOverrides(self) -> tuple of str

            Returns a list of the named session overrides saved on the LOP
            Network. The names returned from this method can be passed to the
            loadNamedViewportOverrides method to load a particular set of
            overrides saved with the saveNamedViewportOverrides method.


        """
        return _hou.LopNetwork_namedViewportOverrides(self)

    def viewportOverridesLayer(self, *args, **kwargs) -> "InterpreterObject":
        r"""

        viewportOverridesLayer(self, layer_id) -> pxr.Sdf.Layer

            Return a pxr.Sdf.Layer object that holds the specified viewport
            overrides layer. This layer should be treated as read only. To
            modify a viewport overrides layer, use the viewportOverrides method.
            The layer_id must be one of the hou.lopViewportOverridesLayer
            values. Each layer is used to hold a different type of edit. In
            strongest to weakest order the available layers are:


            Custom
                Reserved for use by tools created by users. Houdini itself will
                not author opinions on this layer. Use the
                hou.LopViewportOverrides.layer method to access and edit this
                layer.

            SoloGeometry
                Used to express soloing opinions on geometry, for making all
                geometry invisible except for a specific set.

            SoloLights
                Used to express soloing opinions on lights, for deactivating all
                lights except for a specific set.

            Base
                Used for most edits performed in the scene graph tree, such as
                deactivating or hiding individual primitives.


        """
        return _hou.LopNetwork_viewportOverridesLayer(self, *args, **kwargs)

    def viewportLoadMasks(self) -> "HOM_LopViewportLoadMasks *":
        r"""

        viewportLoadMasks(self) -> hou.LopViewportLoadMasks

            Returns the load masking configuration for the viewport currently
            set on the LOP Network. This controls payload loading, stage
            population masking, and layer muting on any viewport pointed at this
            LOP Network.


        """
        return _hou.LopNetwork_viewportLoadMasks(self)

    def setViewportLoadMasks(self, load_masks: "LopViewportLoadMasks") -> "void":
        r"""

        setViewportLoadMasks(self, payload_config)

            Sets a new load masking configuration on the LOP Network.


        """
        return _hou.LopNetwork_setViewportLoadMasks(self, load_masks)

    def saveNamedViewportLoadMasks(
        self, name: "char const *", load_masks: "LopViewportLoadMasks"
    ) -> "void":
        r"""

        saveNamedViewportLoadMasks(self, name)

            Saves the supplied load masking configuration to the LOP Network
            under the specified name. This configuration will be saved to the
            hip file, and can be restored with the loadNamedViewportLoadMasks
            method.


        """
        return _hou.LopNetwork_saveNamedViewportLoadMasks(self, name, load_masks)

    def loadNamedViewportLoadMasks(
        self, name: "char const *"
    ) -> "HOM_LopViewportLoadMasks *":
        r"""

        loadNamedViewportLoadMasks(self, name) -> hou.LopViewportLoadMasks

            Returns the load masking configuration saved under the specified
            name on the LOP Network. Raises a hou.OperationFailed exception if
            there is no load masking configuration stored under the specified
            name.


        """
        return _hou.LopNetwork_loadNamedViewportLoadMasks(self, name)

    def namedViewportLoadMasks(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        namedViewportLoadMasks(self) -> tuple of str

            Returns a list of the named load masking configurations saved on the
            LOP Network. The names returned from this method can be passed to
            the loadNamedViewportLoadMasks method to load a particular load
            masking configuration saved with the saveNamedViewportLoadMasks
            method.


        """
        return _hou.LopNetwork_namedViewportLoadMasks(self)

    def editablePostLayer(
        self, name: "char const *", lop: "LopNode", output_index: "int" = 0
    ) -> "HOM_LopPostLayer *":
        r"""

        editablePostLayer(self, name) -> hou.LopPostLayer

            Return a hou.LopPostLayer object which can be used to manipulate the
            contents of a post-layer on this LOP Network. If the specified layer
            does not exist, it will be created as the weakest post-layer. If it
            does exist, the current contents of the layer are composed onto the
            stage accessible through the LopPostLayer object. In either case,
            all stronger post-layers will be composed on the stage accessible
            through the LopPostLayer.

            A LopPostLayer object must be used to begin a with block. When the
            block exist the LopPostLayer object is destroyed, and the modified
            post-layer is saved to the LOP Network.


        """
        return _hou.LopNetwork_editablePostLayer(self, name, lop, output_index)

    def postLayerNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        postLayerNames(self) -> tuple of str

            Returns the names of all post-layers authored on the LOP Network.
            These names can be passed to the other post-layer methods on this
            object to uniquely identify a specific post-layer to operate on. The
            list is ordered from strongest to weakest in terms of its effect on
            the composed stage.


        """
        return _hou.LopNetwork_postLayerNames(self)

    def postLayer(self, name: "char const *") -> "InterpreterObject":
        r"""

        postLayer(self, name) -> pxr.Sdf.Layer or None

            Returns a non-editable pxr.Sdf.Layer object that can be used to
            inspect the contents of a post-layer without triggering any change
            notifications as would occur when calling editablePostLayer. If
            there is no post-layer with the specified name, None is returned
            instead.


        """
        return _hou.LopNetwork_postLayer(self, name)

    def removePostLayer(self, name: "char const *") -> "void":
        r"""

        removePostLayer(self, name)

            Removes a post-layer from the LOP Network. If the specified name
            does not identify an existing post-layer, this method does nothing.


        """
        return _hou.LopNetwork_removePostLayer(self, name)

    def selection(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectionWithInstanceIds(self) -> tuple of str

            Return a tuple of strings representing all the scene graph locations
            of the instances currently selected in the LOP Network parent of
            this LOP node.


        """
        return _hou.LopNetwork_selection(self)

    def selectionLayerId(self) -> "std::string":
        r"""

        selectionLayerId(self) -> str

            Return a string with the layer identifier of the specific USD layer
            that should be displayed in the Scene Graph Details pane. Set this
            value with the hou.LopNetwork.setSelection method.


        """
        return _hou.LopNetwork_selectionLayerId(self)

    def selectionCurrentPrim(self) -> "std::string":
        r"""

        selectionCurrentPrim(self) -> str

            Return a string with the path to the scene graph primitive that
            should be displayed in the Scene Graph Details pane. Set this value
            with the hou.LopNetwork.setSelection method.


        """
        return _hou.LopNetwork_selectionCurrentPrim(self)

    def selectionWithInstanceIds(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.LopNetwork_selectionWithInstanceIds(self)

    def setSelection(
        self,
        selection: "_StringTuple",
        layerid: "char const *" = None,
        currentprim: "char const *" = None,
    ) -> "void":
        r"""

        setSelection(self, selection, layerid = None, currentprim = None)

            Accepts a tuple of strings holding the scene graph locations which
            should become the selection in the LOP Network parent of this LOP
            node. This selection will be reflected in the Scene Graph Tree pane
            and the LOP viewport.

            The optional layerid parameter can be a string which is the layer
            identifier of a specific layer that should be displayed in the Scene
            Graph Details pane. Similarly the currentprim string can be supplied
            to have the Scene Graph Details pane show the information for a
            primitive at a specific path. The currentprim is usually in the
            selection list, but it doesn't need to be. Passing None for layerid
            or currentprim leave these values on the LOP Network unchanged.


        """
        return _hou.LopNetwork_setSelection(self, selection, layerid, currentprim)

    def selectionRules(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_LopSelectionRule >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_LopSelectionRule > > > >":
        r"""

        selectionRules(self) -> dict of str to hou.LopSelectionRule

            Return a dictionary mapping string names to hou.LopSelectionRule
            objects that match the selection rules stored on the LOP Network
            that owns this LOP node.


        """
        return _hou.LopNetwork_selectionRules(self)

    def clearSelectionRules(self) -> "void":
        r"""

        clearSelectionRules(self)

            Deletes all selection rules stored on the LOP Network that owns this
            LOP node.


        """
        return _hou.LopNetwork_clearSelectionRules(self)

    def setSelectionRule(
        self, name: "char const *", rule: "LopSelectionRule"
    ) -> "void":
        r"""

        setSelectionRule(self, name, rule)

            Stores a named selection rule on the LOP Network that owns this LOP
            node. The rule parameter must be a hou.LopSelectionRule or None. Use
            None to remove a single named rule from the LOP Network.

            The selection rule name can be a slash-separated path, in which case
            the selection rule will appear in the Scene Graph Tree pane as part
            of a nested hierarchy. This in no way affects the operation of the
            rule, serving only as a way of organizing sets of rules.


        """
        return _hou.LopNetwork_setSelectionRule(self, name, rule)


# Register LopNetwork in _hou:
_hou.LopNetwork_swigregister(LopNetwork)


class LopNode(Node):
    r"""

    hou.LopNode

    Represents a lighting node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_LopNode

    def __repr__(self) -> "std::string":
        return _hou.LopNode___repr__(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns whether this node's bypass flag is on.


        """
        return _hou.LopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turns this node's bypass flag on or off, making this node have no
            effect.


        """
        return _hou.LopNode_bypass(self, on)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Returns whether this node's display flag is on.


        """
        return _hou.LopNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turn this node's display flag on or off.


        """
        return _hou.LopNode_setDisplayFlag(self, on)

    def isDebugFlagSet(self) -> "bool":
        r"""

        isDebugFlagSet(self) -> bool

            Returns True if the node's debug flag is turned on. Returns False
            otherwise.


        """
        return _hou.LopNode_isDebugFlagSet(self)

    def setDebugFlag(self, on: "bool") -> "void":
        r"""

        setDebugFlag(self, on)

            Turns the node's debug flag on or off. The debug flag on a LOP node
            is used to force the node to create its own USD Layer and apply its
            edits in that new layer. This makes it easier to track which scene
            graph modifications were made by which LOP node. Setting this flag
            will also affect the performance of the LOP Network since
            composition of the USD stage takes longer if there are more layers.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.LopNode_setDebugFlag(self, on)

    def displayNode(self) -> "HOM_Node *":
        r"""

        displayNode(self) -> Node

            If this is a LOP Network or a subnet LOP, return the LOP node inside
            the subnet with its display flag on. Otherwise, return None.


        """
        return _hou.LopNode_displayNode(self)

    def viewerNode(self) -> "HOM_Node *":
        r"""

        viewerNode(self) -> Node

            If this is a subnet LOP, return the LOP node inside the subnet with
            its display flag on. If the subnet LOP doesn't contain any children
            with a display flag set, the viewer node of the containing LOP
            Network or subnet is returned. This algorithm is the one used to
            determine which LOP node's stage to display in the 3D viewport. This
            recursive approach allows the user to work on the nodes inside a
            sub-network while viewing the result of the containing LOP network
            in the viewport.


        """
        return _hou.LopNode_viewerNode(self)

    def editableLayer(self) -> "InterpreterObject":
        r"""

        editableLayer(self) -> pxr.Sdf.Layer

            Returns a pxr.Sdf.Layer object with permission to edit that
            represents the active layer in a Python LOP.


        """
        return _hou.LopNode_editableLayer(self)

    def activeLayer(
        self,
        output_index: "int" = 0,
        ignore_errors: "bool" = False,
        use_last_cook_context_options: "bool" = True,
    ) -> "InterpreterObject":
        r"""

        activeLayer(self, output_index = 0, ignore_errors = False,
        use_last_cook_context_options = True) -> pxr.Sdf.Layer

            Returns a pxr.Sdf.Layer object representing the USD layer that has
            been modified by this node.

            The ignore_errors can be set to True to indicate that if this LOP
            node is in an error state after cooking, this method should search
            up the network looking for the first node not in an error state, and
            return the active layer from that node instead.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set,


        """
        return _hou.LopNode_activeLayer(
            self, output_index, ignore_errors, use_last_cook_context_options
        )

    def editableStage(self) -> "InterpreterObject":
        r"""

        editableStage(self) -> pxr.Usd.Stage

            Returns a pxr.Usd.Stage object with permission to edit that
            represents the USD stage input to a Python LOP.


        """
        return _hou.LopNode_editableStage(self)

    def stage(
        self,
        output_index: "int" = 0,
        apply_viewport_overrides: "bool" = False,
        ignore_errors: "bool" = False,
        use_last_cook_context_options: "bool" = True,
        apply_post_layers: "bool" = True,
    ) -> "InterpreterObject":
        r"""

        stage(self, output_index = 0, apply_viewport_overrides = False,
        ignore_errors = False, use_last_cook_context_options = True,
        apply_post_layers = True) -> pxr.Usd.Stage

            Returns a pxr.Usd.Stage object representing the USD stage output
            from this node. Set apply_viewport_overrides to True to return a
            stage with its session layer set with any temporary activation or
            visibility settings configured in the scene graph tree. Set it to
            False to return the stage without these overrides applied in the
            session layer.

            The apply_post_layers flag controls whether or not the returned
            stage will have the LOP Network's post-layers applied to the session
            layer.

            The ignore_errors flag can be set to True to indicate that if this
            LOP node is in an error state after cooking, this method should
            search up the network looking for the first node not in an error
            state, and return the stage from that node instead.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set,


        """
        return _hou.LopNode_stage(
            self,
            output_index,
            apply_viewport_overrides,
            ignore_errors,
            use_last_cook_context_options,
            apply_post_layers,
        )

    def sourceLayer(
        self,
        layer_index: "int" = 0,
        output_index: "int" = 0,
        use_last_cook_context_options: "bool" = True,
    ) -> "InterpreterObject":
        r"""

        sourceLayer(self, layer_index = 0, output_index = 0,
        use_last_cook_context_options = True) -> pxr.Sdf.Layer

            Return a pxr.Sdf.Layer object representing the specific requested
            USD layer that is used to build the stage that is the output of this
            node.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set,


        """
        return _hou.LopNode_sourceLayer(
            self, layer_index, output_index, use_last_cook_context_options
        )

    def stagePrimStats(
        self,
        primpath: "char const *" = None,
        output_index: "int" = 0,
        apply_viewport_overrides: "bool" = False,
        ignore_errors: "bool" = False,
        do_geometry_counts: "bool" = False,
        do_separate_purposes: "bool" = False,
        use_last_cook_context_options: "bool" = True,
        apply_post_layers: "bool" = True,
    ) -> "InterpreterObject":
        r"""

        stagePrimStats(self, primpath = None, output_index = 0,
        apply_viewport_overrides = False, ignore_errors = False,
        do_geometry_counts = False, do_separate_purposes = False,
        use_last_cook_context_options = True, apply_post_layers = True) -> dict

            Returns a dictionary of statistics about the specified USD primitive
            on the USD stage output from this node. These statistics include a
            count of primitives of each type, the number of primitives with
            loaded and unloaded payloads, and other useful information about the
            type and complexity of information under the specified primitive.

            Set apply_viewport_overrides to True to return statistics from a
            stage with its session layer set with any temporary activation or
            visibility settings configured in the scene graph tree. Set it to
            False to return the statistics for the stage with an empty session
            layer.

            The apply_post_layers flag controls whether or not the stats will be
            generated with the LOP Network's post-layers applied to the session
            layer.

            The ignore_errors parameter can be set to True to indicate that if
            this LOP node is in an error state after cooking, this method should
            search up the network looking for the first node not in an error
            state, and return the statistics from that node instead.

            The do_geometry_counts parameter can be set to True to generate more
            details information about some USD primitive types, such as the
            total number of polygons on Mesh primitives, the number of curves on
            BasisCurves primitives, and the number of instances in
            PointInstancer primitives. The generation of these statistics may
            involve reading additional data from USD files on disk.

            Set do_separate_purposes to True to return per-purpose statistics,
            as well as the total counts. This separation into purposes applies
            to both basic primitive counts and the detailed geometry counts.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set,


        """
        return _hou.LopNode_stagePrimStats(
            self,
            primpath,
            output_index,
            apply_viewport_overrides,
            ignore_errors,
            do_geometry_counts,
            do_separate_purposes,
            use_last_cook_context_options,
            apply_post_layers,
        )

    def lastModifiedPrims(self) -> "InterpreterObject":
        r"""

        lastModifiedPrims(self) -> tuple of pxr.Sdf.Path

            Returns the paths of the USD primitives modified by this node's last
            cook.


        """
        return _hou.LopNode_lastModifiedPrims(self)

    def inputPrims(self, inputidx: "int") -> "InterpreterObject":
        r"""

        inputPrims(self, inputidx) -> tuple of pxr.Sdf.Path

            Returns the paths of the USD primitives modified by the specified
            input of this node. Returns None if the input is not connected. This
            method is roughly equivalent to:

          > lopnode.inputs()[inputidx].lastModifiedPrims()

        """
        return _hou.LopNode_inputPrims(self, inputidx)

    def setLastModifiedPrims(self, primpaths: "InterpreterObject") -> "void":
        r"""

        setLastModifiedPrims(self, primpaths)

            When used in a Python based LOP node, this method sets the value
            that will be returned by subsequent calls to lastModifiedPrims. The
            primpaths parameter must be an iterable of pxr.Sdf.Path objects or
            strings.


        """
        return _hou.LopNode_setLastModifiedPrims(self, primpaths)

    def loadMasks(
        self,
        output_index: "int" = 0,
        force_cook: "bool" = False,
        use_last_cook_context_options: "bool" = True,
    ) -> "HOM_LopViewportLoadMasks *":
        r"""

        loadMasks(self, output_index = 0, force_cook = False,
        use_last_cook_context_options = True) -> hou.LopViewportLoadMasks

            Returns the load masking configuration cooked into the stage at this
            LOP node. This object controls stage population masking and layer
            muting. These masks can be set using the Load Masks LOP. These load
            masks will affect the primitives available on the stage when cooking
            this node or nodes below it.

            The output_index parameter specifies the output connector of the LOP
            node from which to fetch the load mask. The force_cook flag can be
            set to True to cause the LOP node to cook before returning the load
            mask.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set,


        """
        return _hou.LopNode_loadMasks(
            self, output_index, force_cook, use_last_cook_context_options
        )

    def sourceLayerCount(
        self, output_index: "int" = 0, use_last_cook_context_options: "bool" = True
    ) -> "int":
        r"""

        sourceLayerCount(self, output_index = 0, use_last_cook_context_options =
        True) -> int

            Returns the number of source layers that are used to build the stage
            at the output of this node. The result from this method will be one
            greater than the maximum value that can be passed to the sourceLayer
            method.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set,


        """
        return _hou.LopNode_sourceLayerCount(
            self, output_index, use_last_cook_context_options
        )

    def layersAboveLayerBreak(
        self, output_index: "int" = 0, use_last_cook_context_options: "bool" = True
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        layersAboveLayerBreak(self, output_index = 0,
        use_last_cook_context_options = True) -> tuple of str

            Returns the identifiers of all layers that will be removed by layer
            flattening or USD save operations because they were added to the
            stage above a Layer Break LOP. These are identifiers may include
            anonymous layer identifiers and paths to USD layers on disk.


        """
        return _hou.LopNode_layersAboveLayerBreak(
            self, output_index, use_last_cook_context_options
        )

    def selectionRule(
        self, inputidx: "int" = -1, pattern: "char const *" = None
    ) -> "HOM_LopSelectionRule *":
        r"""

        selectionRule(self, inputidx=-1, pattern=None) -> hou.LopSelectionRule

            Returns a selection rule pre-configured to evaluate its pattern
            using this node as the source of the USD stage when calling
            hou.LopSelectionRule.expandedPaths or similar methods that take a
            LOP node as a parameter. The inputidx parameter can further be used
            to cause selection rule evaluations to use the USD stage of one of
            the inputs to this node, instead of this node itself. This shortcut
            can simplify the code for evaluating a rule repeatedly.

            The optional pattern parameter populates the selection rule with the
            supplied pattern string. This is equivalent to creating the rule and
            then calling hou.LopSelectionRule.setPathPattern.


        """
        return _hou.LopNode_selectionRule(self, inputidx, pattern)

    def network(self) -> "HOM_Node *":
        r"""

        network(self) -> hou.LopNetwork

            Return the LOP Network that contains this LOP Node.


        """
        return _hou.LopNode_network(self)

    def addLockedGeometry(self, *args) -> "std::string":
        r"""

        addLockedGeometry(self, identifier, geo, args = {}) -> str

            Adds a locked copy of a hou.Geometry to a registry, so that it can
            be used as a USD reference or sublayer.

            The returned string is a USD layer identifier that can be used when
            adding a composition arc.

            If an args dictionary is specified, the contents must be pre-
            converted to be strings. For example: { 't': '1.0' } is valid, but {
            't': 1.0 } is not.


            NOTE
                The registry entries created by using this function are tied to
                this LOP node and will be destroyed when the LOP node is
                destroyed.

            Example:

          > geo = hou.Geometry()
          > geo.loadFromFile('$HH/geo/shaderteapot.bgeo')
          > node = hou.pwd()
          > stage = node.editableStage()
          > layer_id = node.addLockedGeometry('teapot', geo)
          > node.addSubLayer(layer_id)

            See also hou.lop.addLockedGeometry


        """
        return _hou.LopNode_addLockedGeometry(self, *args)

    def addHeldLayer(self, identifier: "char const *") -> "void":
        r"""

        addHeldLayer(self, identifier)

            Add the USD layer specified by the identifier argument to an
            internal registry to prevent it from being deleted by USD if the
            layer is no longer part of a composed stage (for example if it was
            created by a Python LOP inside as Subnet which then had the Bypass
            flag enabled).

            Note the loputils.createPythonLayer method will automatically call
            this, and hou.LopNode.addSubLayer similarly holds the layer
            automatically.

          > import loputils
          > from pxr import Sdf
          > node = hou.pwd()
          > stage = node.editableStage()
          > layer = loputils.createPythonLayer(node)
          > subLayer1 = loputils.createPythonLayer(node)
          > subLayer2 = Sdf.Layer.CreateAnonymous()
          > node.addHeldLayer(subLayer2.identifier)
          > layer.subLayerPaths.append(subLayer1)
          > layer.subLayerPaths.append(subLayer2)
          > node.addSubLayer(layer.identifier)

        """
        return _hou.LopNode_addHeldLayer(self, identifier)

    def addSubLayer(self, identifier: "char const *") -> "void":
        r"""

        addSubLayer(self, identifier)

            Add the USD layer specified by the identifier argument as a sublayer
            to the root layer of the USD stage. The layer identifier can refer
            to an existing file on disk, or an anonymous layer created earlier
            in the python script. Call editableStage() before calling this
            method, or it will raise an exception.

            Houdini has certain requirements for anonymous layers authored by
            LOP nodes to ensure that they can be saved to disk in a predictable
            way. The loputils.createPythonLayer method creates a new layer,
            properly configured so that it can be added to the LOP stage and
            saved to disk like any other LOP-authored layer.

          > import loputils
          > from pxr import Sdf
          > node = hou.pwd()
          > stage = node.editableStage()
          > layer = loputils.createPythonLayer(node, '$HIP/myfile.usda')
          > p = Sdf.CreatePrimInLayer(layer, '/cube')
          > p.specifier = Sdf.SpecifierDef
          > p.typeName = 'Cube'
          > node.addSubLayer(layer.identifier)

        """
        return _hou.LopNode_addSubLayer(self, identifier)


# Register LopNode in _hou:
_hou.LopNode_swigregister(LopNode)


class lop(object):
    r"""

    hou.lop

    Module containing functions related to Houdini LOP nodes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_lop

    def __repr__(self) -> "std::string":
        return _hou.lop___repr__(self)

    def defaultNewPrimPath(self) -> "std::string":
        r"""

        defaultNewPrimPath() -> str

            Return the USD primitive path that will be used by default on new
            LOP nodes with a primpath parameter with a default of /$OS.


        """
        return _hou.lop_defaultNewPrimPath(self)

    def setDefaultNewPrimPath(self, path: "char const *") -> "void":
        r"""

        setDefaultNewPrimPath(path)

            Set the USD primitive path that will be used by default on new LOP
            nodes with a primpath parameter with a default of /$OS. This
            identifies a parameter that is used to create a new USD primitive.
            Being able to control this default makes it easier to conform to
            studio-wide standard naming conventions for primitive paths.


        """
        return _hou.lop_setDefaultNewPrimPath(self, path)

    def defaultCollectionsPrimPath(self) -> "std::string":
        r"""

        defaultCollectionsPrimPath() -> str

            Return the USD primitive path that will be used as the default
            location when creating new collections. If not set, the default
            value is /collections.


        """
        return _hou.lop_defaultCollectionsPrimPath(self)

    def setDefaultCollectionsPrimPath(self, path: "char const *") -> "void":
        r"""

        setDefaultCollectionsPrimPath(path)

            Set the USD primitive path that will be used as the default location
            when creating new collections. Being able to control this default
            makes it easier to conform to studio-wide standard naming
            conventions for primitive paths.


        """
        return _hou.lop_setDefaultCollectionsPrimPath(self, path)

    def defaultCollectionsPrimType(self) -> "std::string":
        r"""

        defaultCollectionsPrimType() -> str

            Return the USD primitive type that will be created for holding
            collections when the destination primitive doesn't already exist. If
            not set, the default value is an empty string, indicating that a
            typeless primitive will be created.


        """
        return _hou.lop_defaultCollectionsPrimType(self)

    def setDefaultCollectionsPrimType(self, primtype: "char const *") -> "void":
        r"""

        setDefaultCollectionsPrimType(path)

            Set the USD primitive type that will be created for holding
            collections when the destination primitive doesn't already exist.
            Being able to control this default makes it easier to conform to
            studio-wide standard conventions for using primitive types.


        """
        return _hou.lop_setDefaultCollectionsPrimType(self, primtype)

    def defaultLightsPrimPath(self) -> "std::string":
        r"""

        defaultLightsPrimPath() -> str

            Return the USD primitive path that will be used as the default
            location when creating new lights. If not set, the default value is
            /lights.


        """
        return _hou.lop_defaultLightsPrimPath(self)

    def setDefaultLightsPrimPath(self, path: "char const *") -> "void":
        r"""

        setDefaultLightsPrimPath(path)

            Set the USD primitive path that will be used as the default location
            when creating new lights. Being able to control this default makes
            it easier to conform to studio-wide standard naming conventions for
            primitive paths.


        """
        return _hou.lop_setDefaultLightsPrimPath(self, path)

    def defaultCamerasPrimPath(self) -> "std::string":
        r"""

        defaultCamerasPrimPath() -> str

            Return the USD primitive path that will be used as the default
            location when creating new cameras. If not set, the default value is
            /cameras.


        """
        return _hou.lop_defaultCamerasPrimPath(self)

    def setDefaultCamerasPrimPath(self, path: "char const *") -> "void":
        r"""

        setDefaultCamerasPrimPath(path)

            Set the USD primitive path that will be used as the default location
            when creating new cameras. Being able to control this default makes
            it easier to conform to studio-wide standard naming conventions for
            primitive paths.


        """
        return _hou.lop_setDefaultCamerasPrimPath(self, path)

    def defaultTransformSuffix(self) -> "std::string":
        r"""

        defaultTransformSuffix() -> str

            Return the string that will be used as the default suffix on
            transform attribute names.


        """
        return _hou.lop_defaultTransformSuffix(self)

    def setDefaultTransformSuffix(self, suffix: "char const *") -> "void":
        r"""

        setDefaultTransformSuffix(suffix)

            Set the string that will be used as the default suffix on transform
            attribute names. USD transforms always start with xformOp: followed
            by the transform type (translate, rotate, transform), followed by an
            optional suffix that describes the transform. This string is the
            default Houdini will use in situations where this suffix can be
            provided, which can help make USD layers authored in LOPs conform to
            studio-wide standard naming conventions.


        """
        return _hou.lop_setDefaultTransformSuffix(self, suffix)

    def showResolvedPaths(self) -> "bool":
        r"""

        showResolvedPaths() -> bool

            Return True if the option to show resolved layer file paths is
            turned on.


        """
        return _hou.lop_showResolvedPaths(self)

    def setShowResolvedPaths(self, show_resolved_paths: "bool") -> "void":
        r"""

        setShowResolvedPaths(show_resolved_paths)

            Set the option to control whether panels that show layer file paths
            should display the exact path set on the layer, or the path after
            passing it through the USD path resolver. The resolved path will
            generally be a full path to a file on disk, where the unresolved
            path may be a relative path, a search path, or a path format that is
            specific to a custom resolver.


        """
        return _hou.lop_setShowResolvedPaths(self, show_resolved_paths)

    def panesFollowCurrentNode(self) -> "bool":
        r"""

        panesFollowCurrentNode() -> bool

            Return True if LOP panes such as the Scene Graph Tree and Scene
            Graph Details should follow the current node selected in the network
            editor.


        """
        return _hou.lop_panesFollowCurrentNode(self)

    def setPanesFollowCurrentNode(self, follow_current_node: "bool") -> "void":
        r"""

        setPanesFollowCurrentNode(follow_current_node)

            Set the option for LOP panes such as the Scene Graph Tree and Scene
            Graph Details to follow the current node selected in the network
            editor. If set to False, these panes will instead show information
            for the LOP node with its display flag set.


        """
        return _hou.lop_setPanesFollowCurrentNode(self, follow_current_node)

    def panesShowViewportStage(self) -> "bool":
        r"""

        panesShowViewportStage() -> bool

            Return True if LOP panes such as the Scene Graph Tree and Scene
            Graph Details should show information about the USD stage generated
            by applying any viewport overrides set in the Scene Graph Tree.


        """
        return _hou.lop_panesShowViewportStage(self)

    def setPanesShowViewportStage(self, show_viewport_stage: "bool") -> "void":
        r"""

        setPanesShowViewportStage(show_viewport_stage)

            Set the option for LOP panes such as the Scene Graph Tree and Scene
            Graph Details to show information about the USD stage generated by
            applying any viewport overrides set in the Scene Graph Tree.

            Turning this option off will improve the performance of these panes
            when there are viewport overrides applied to the scene. The tradeoff
            is that the values shown in the scene graph tree and scene graph
            details for visibility and activation may not match what is shown in
            the viewport. However it will better match the scene description
            that would be used by a final render, as viewport overrides are not
            included in the USD sent to a final render.


        """
        return _hou.lop_setPanesShowViewportStage(self, show_viewport_stage)

    def panesShowPostLayers(self) -> "bool":
        r"""

        panesShowPostLayers() -> bool

            Return True if LOP panes such as the Scene Graph Tree and Scene
            Graph Details should show information about the USD stage generated
            by applying any post-layers applied to the parent LOP Network.


        """
        return _hou.lop_panesShowPostLayers(self)

    def setPanesShowPostLayers(self, show_post_layers: "bool") -> "void":
        r"""

        setPanesShowPostLayers(show_post_layers)

            Set the option for LOP panes such as the Scene Graph Tree and Scene
            Graph Details to show information about the USD stage generated by
            applying any post-layers applied to the parent LOP Network.


        """
        return _hou.lop_setPanesShowPostLayers(self, show_post_layers)

    def autoSetAssetResolverContext(self) -> "bool":
        r"""

        autoSetAssetResolverContext() -> bool

            Return True if the Sublayer and Reference LOP nodes should
            automatically use their first USD layer loaded from disk as the
            resolver context asset path passed to the USD stage to define it's
            asset resolver context.


        """
        return _hou.lop_autoSetAssetResolverContext(self)

    def setAutoSetAssetResolverContext(self, auto_set_context: "bool") -> "void":
        r"""

        setAutoSetAssetResolverContext(auto_set_context)

            Pass in a value of True if the Sublayer and Reference LOP nodes
            should automatically use their first USD layer loaded from disk as
            the resolver context asset path passed to the USD stage to define
            it's asset resolver context. The resolver context is used by the USD
            asset resolver to help find the right files when opening a layer
            file in the context of a particular stage. Often this resolver
            context can be determined by looking at the root layer of the stage.
            In the case of LOPs, the first layer loaded by a Sublayer or
            Reference LOP is the closest thing we have to a root layer. This
            preference makes it easier to implement this workflow. The
            alternative involves using a Configure Stage LOP as the first node
            in the LOP Network to explicitly set the resolver context asset
            path. Similarly this option only affects a Sublayer or Reference LOP
            if it is the first node in the chain.


        """
        return _hou.lop_setAutoSetAssetResolverContext(self, auto_set_context)

    def updateRendererInBackground(self) -> "bool":
        r"""

        updateRendererInBackground() -> bool

            Return True if the LOP viewport has been configured to run update
            tasks in the background.


        """
        return _hou.lop_updateRendererInBackground(self)

    def setUpdateRendererInBackground(self, update_in_background: "bool") -> "void":
        r"""

        setUpdateRendererInBackground(update_in_background)

            Pass in a value of True to cause the LOP viewport to run update
            tasks in the background, which results in better interactivity but
            allows the viewport display to be temporarily out of sync with the
            current cooked LOP stage.


        """
        return _hou.lop_setUpdateRendererInBackground(self, update_in_background)

    def loadPayloadsByDefault(self) -> "bool":
        r"""

        loadPayloadsByDefault() -> bool

            Return True if new LOP Networks will be created with the option to
            load all payloads in the viewport enabled.


        """
        return _hou.lop_loadPayloadsByDefault(self)

    def setLoadPayloadsByDefault(self, load_payloads: "bool") -> "void":
        r"""

        setLoadPayloadsByDefault(load_payloads)

            Pass in a value of True to cause new LOP Networks to be created with
            the option to load all payloads in the viewport enabled. Pass in a
            value of False to disable the loading of payloads in the viewport
            for any new LOP Networks. No existing LOP Networks are affected by
            this method. The default value for this preference is True.


        """
        return _hou.lop_setLoadPayloadsByDefault(self, load_payloads)

    def allowViewportOnlyPayloads(self) -> "bool":
        r"""

        allowViewportOnlyPayloads() -> bool

            Return True if the scene graph tree can allow the user to force the
            loading of a payload into the viewport which has been prevented from
            loading by a Configure Stage node. Return False if the scene graph
            tree should prevent the explicit loading of such payloads. This
            value ensures that the viewport will only show payloads that have
            been processed by the LOP network, eliminating a potential mismatch
            between the scene displayed in the viewport, and the same scene
            rendered with the USD Render ROP with a different set of loaded
            payloads processed by the LOP Network.


        """
        return _hou.lop_allowViewportOnlyPayloads(self)

    def setAllowViewportOnlyPayloads(
        self, allow_viewport_only_payloads: "bool"
    ) -> "void":
        r"""

        setAllowViewportOnlyPayloads(allow_viewport_only_payloads)

            Set the flag that indicates whether the viewport is allowed to load
            payloads that have been specified as unloaded by a Configure Stage
            node.


        """
        return _hou.lop_setAllowViewportOnlyPayloads(self, allow_viewport_only_payloads)

    def useSimplifiedLinkerUi(self) -> "bool":
        return _hou.lop_useSimplifiedLinkerUi(self)

    def setUseSimplifiedLinkerUi(self, use_simplified_linker_ui: "bool") -> "void":
        return _hou.lop_setUseSimplifiedLinkerUi(self, use_simplified_linker_ui)

    def defaultMetersPerUnit(self) -> "double":
        r"""

        defaultMetersPerUnit() -> float

            Return the default meters per unit metric that will be saved into
            USD layers that do not have this value explicitly set. A value of
            zero indicates that Houdini's Unit Length option will be used to
            generate an equivalent meters per unit value.


        """
        return _hou.lop_defaultMetersPerUnit(self)

    def setDefaultMetersPerUnit(self, meters_per_unit: "double") -> "void":
        r"""

        setDefaultMetersPerUnit(meters_per_unit)

            Set the default meters per unit metric that will be saved into USD
            layers that do not have this value explicitly set. A value of zero
            indicates that Houdini's Unit Length option should be used to
            generate an equivalent meters per unit value.


        """
        return _hou.lop_setDefaultMetersPerUnit(self, meters_per_unit)

    def defaultUpAxis(self) -> "std::string":
        r"""

        defaultUpAxis() -> str

            Return the default up axis value that will be saved into USD layers
            that do not have this value explicitly set. An empty string
            indicates that the USD up axis fallback value
            (pxr.UsdGeom.GetFallbackUpAxis) should be used.


        """
        return _hou.lop_defaultUpAxis(self)

    def setDefaultUpAxis(self, up_axis: "char const *") -> "void":
        r"""

        setDefaultUpAxis(up_axis)

            Set the default up axis that will be saved into USD layers that do
            not have this value explicitly set. An empty string indicates that
            the USD up axis fallback value (pxr.UsdGeom.GetFallbackUpAxis)
            should be used. Other acceptable values are Y and Z. Trying to set
            any other value will raise a hou.ValueError exception.


        """
        return _hou.lop_setDefaultUpAxis(self, up_axis)

    def savePreferences(self) -> "bool":
        r"""

        savePreferences() -> bool

            Saves out the current LOP preferences to
            $HOME/houdiniX.Y/solaris.pref. This happens automatically when the
            preferences are modified in the preferences dialog, and when exiting
            Houdini. But in a batch scripting environment, changes made to these
            preferences will not be saved automatically, so this method must be
            used. Returns True is the preference file was saved successfully.


        """
        return _hou.lop_savePreferences(self)

    def reloadLayer(
        self, layer_path: "char const *", recursive: "bool" = False
    ) -> "void":
        r"""

        reloadLayer(layer_path, recursive = False)

            This method calls the USD Reload method for the specified layer
            path. In addition, it updates internal Houdini data structures of
            the reload so that they can update. This method should be used in
            place of the pxr.Sdf.Layer.Reload or similar methods when running in
            Houdini.

            Setting the recursive parameter to True will cause Houdini to
            recursively look for other layers referenced by the specified layer,
            and reload them as well.


        """
        return _hou.lop_reloadLayer(self, layer_path, recursive)

    def makeValidPrimName(self, name: "char const *") -> "std::string":
        r"""

        makeValidPrimName(name) -> str

            This function ensures that a string meets the requirements of a
            legal USD primitive name that can be used as part of a valid
            primitive path. Invalid characters such as spaces and most
            punctuation will be converted to underscores. Note that this means
            the translation is not reversible. If the original string is already
            a legal primitive name, the name is returned unchanged.


        """
        return _hou.lop_makeValidPrimName(self, name)

    def makeValidPrimPath(
        self, path: "char const *", allow_relative: "bool" = False
    ) -> "std::string":
        r"""

        makeValidPrimPath(path, allow_relative = False) -> str

            This function ensures that a string meets the requirements of a
            legal USD primitive path that can be converted into a psx.Sdf.Path
            object. Invalid characters such as spaces and most punctuation will
            be converted to underscores. Note that this means the translation is
            not reversible. If the original string is already a legal primitive
            path, the string is returned unchanged.

            If the allow_relative value is True, the path is allowed to be a
            relative primitive path. A relative path is one that starts with ./
            or ../. If this argument is False, only absolute paths (which start
            with /) are allowed. Relative prefixes are simply removed from the
            path and the returned path will always start with a /.


        """
        return _hou.lop_makeValidPrimPath(self, path, allow_relative)

    def createParmsForProperty(self, *args) -> "HOM_ParmTemplateGroup *":
        r"""

        createParmsForProperty(source, primpath, propertyname, parametername,
        prepend_control_parm, prefix_xform_parms) -> [Hom:hou.ParmTemplateGroup]

            Given a property on a USD stage, this method returns a
            hou.ParmTemplateGroup object that describes the parameters that can
            be placed on an Edit Properties LOP node to control that USD
            property.


            source
                Either a hou.LopNode object or a string. If a hou.LopNode, the
                property is extracted from the USD stage owned by that LOP node.
                If a string, the USD file on disk at the specified path will be
                loaded, and the property extracted from there.

            primpath
                Path to the USD primitive where the property lives.

            propertyname
                The name of the USD property for which parameters will be
                created.

            parametername
                The name of the parameter to generate. This value can be a
                string or None, in which case the parameter name will match the
                property name. It is the parameter names that determines the
                name of the property that will be authored by the Edit
                Properties node, so setting a value for this parameter will
                cause a different property to be authored than the one used to
                generate the parameter.

            prepend_control_parm
                Set to True if the returned parameter template group should
                include a menu for choosing whether the property value should be
                set, ignored, or one of the other standard actions supported by
                the Edit Properties node.

            prefix_xform_parms
                If the specified property is a transform property, this method
                will generate separate translate, rotate, scale, and other
                parameters that get combined to generate a transformation
                matrix. If this option is set to False, these additional
                parameters will use standard Houdini transform parameter names
                like t, s, and r. If set to True, these parameter will be
                prefixed by the property name, which means the parameter names
                will not conflict with other transform parameters on the Edit
                Properties node.


        """
        return _hou.lop_createParmsForProperty(self, *args)

    def createParmsForParameter(
        self,
        source: "ParmTemplate",
        parametername: "char const *" = None,
        usdvaluetype: "char const *" = None,
        prepend_control_parm: "bool" = True,
    ) -> "HOM_ParmTemplateGroup *":
        r"""

        createParmsForParameter(source, parametername, prepend_control_parm) ->
        [Hom:hou.ParmTemplateGroup]

            Given a source node parameter, this method returns a
            hou.ParmTemplateGroup object that describes the parameters that can
            be placed on an Edit Properties LOP node to control a value of a
            corresponding USD property.

            The returned group contains a control parameter that decides how the
            USD property is changed and a value parameter, which is very similar
            to the given parameter, except for disable-when condition and a few
            other small differences.


            source
                A hou.ParmTemplate object on which to base the returned edit
                parameter group.

            parametername
                The name of the parameter to generate. This value can be a
                string or None, in which case the parameter name will match the
                given parameter.

            prepend_control_parm
                Set to True if the returned parameter template group should
                include a menu for choosing whether the property value should be
                set, ignored, or one of the other standard actions supported by
                the Edit Properties node.


        """
        return _hou.lop_createParmsForParameter(
            self, source, parametername, usdvaluetype, prepend_control_parm
        )

    def setParmTupleFromProperty(
        self,
        parmtuple: "ParmTuple",
        source: "LopNode",
        primpath: "char const *",
        propertyname: "char const *",
    ) -> "void":
        r"""

        setParmTupleFromProperty(parmtuple, source, primpath, propertyname)

            Set the value of a node parameter tuple from the value of a property
            on a USD primitive. If the parameter cannot be set because the data
            type of the parameter is not compatible with the data type of the
            USD property, or the USD property cannot be found, raises a
            hou.OperationFailed exception.


            parmtuple
                A hou.ParmTuple object specifying the parameter which should be
                set to the value of the USD property.

            source
                A hou.LopNode object holding the USD stage from which the USD
                property value will be extracted.

            primpath
                A string indicating the scene graph path of the USD primitive.

            propertyname
                A string indicating the name of the property on the USD
                primitive.


        """
        return _hou.lop_setParmTupleFromProperty(
            self, parmtuple, source, primpath, propertyname
        )

    def shaderTranslatorID(self, node: "Node") -> "int":
        r"""

        shaderTranslatorID(node) -> int

            Returns the ID of the shader translator for the given node. The ID
            is specific to Houdini session and can change between them.


        """
        return _hou.lop_shaderTranslatorID(self, node)

    def shaderRenderContextName(
        self, node: "Node", node_output_name: "char const *"
    ) -> "std::string":
        r"""

        shaderRenderContextName(node, node_output_name) -> str

            Returns the render context name for the given node and output. It is
            used in the USD material primitive output name, to associate the
            connected shader with a given renderer.


            node
                The shader node to whose render context name to return.

            node_output_name
                The output name for which to return the render context name.
                Nodes can have several output, each for a different renderer.


        """
        return _hou.lop_shaderRenderContextName(self, node, node_output_name)

    def translateShader(
        self,
        node: "Node",
        node_output_name: "char const *",
        material_prim_path: "char const *",
        shader_parent_prim_path: "char const *",
        shader_prim_name: "char const *" = None,
    ) -> "std::string":
        r"""

        translateShader(node, node_output_name, material_prim_path,
        container_prim_path, shader_prim_name) -> str

            Creates a new shader primitive and returns a path to the shader
            primitive output.


            node
                The shader node to translate into a USD shader primitive.

            node_output_name
                The node output that represents the shader to translate (if the
                node is a material), or an output value that is needed as an
                input to another USD shader primitive.

            material_prim_path
                The USD path to the material primitive that contains the USD
                shader.

            container_prim_path
                The path to the parent primitive (ie, NodeGraph or Material) in
                which the USD shader should be directly authored.

            shader_prim_name
                The name to be used for the created USD shader primitive. If not
                provided, it will be inferred from the node.


        """
        return _hou.lop_translateShader(
            self,
            node,
            node_output_name,
            material_prim_path,
            shader_parent_prim_path,
            shader_prim_name,
        )

    def reportShaderTranslation(
        self, node: "Node", usd_shader_path: "char const *"
    ) -> "void":
        r"""

        reportShaderTranslation(node, usd_shader_path)

            Adds an entry to the table of known shader translations. This allows
            LOPs to find out the USD shader primitives given a shader VOP node,
            which is necessary for incremental re-translation of shaders.


            node
                The shader node that was translated into a USD shader primitive.

            usd_shader_path
                The USD shader primitive path to which the node was translated.


        """
        return _hou.lop_reportShaderTranslation(self, node, usd_shader_path)

    def shaderNodeType(self, shader_name: "char const *") -> "HOM_NodeType *":
        r"""

        shaderNodeType(shader_name) -> hou.NodeType

            Returns a shader hou.NodeType given the shader name.

            Shader name is generic identifier of the abstract shader entity, and
            the returned node type is a representation of that shader in a form
            of the node of that type.

            For example, shader \"foo\" may correspond to a VOP node of type
            my_namespace::FooShader::2.0.


        """
        return _hou.lop_shaderNodeType(self, shader_name)

    def availableRendererNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        availableRendererNames() -> tuple of str

            Returns a tuple with the internal names of registered renderer
            plugins.


        """
        return _hou.lop_availableRendererNames(self)

    def availableRendererLabels(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        availableRendererLabels() -> tuple of str

            Returns a tuple with the display labels of registered renderer
            plugins.


        """
        return _hou.lop_availableRendererLabels(self)

    def outputProcessors(
        self,
    ) -> "std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >":
        r"""

        outputProcessors() -> tuple of tuple of str

            Returns a tuple holding the internal name and user facing label for
            each output processor plugin in the registry. See the USD ROP for
            more information about output processors.


        """
        return _hou.lop_outputProcessors(self)

    def outputProcessorParms(self, name: "char const *") -> "HOM_ParmTemplateGroup *":
        r"""

        outputProcessorParms(name) -> hou.ParmTemplateGroup

            Returns the parameters that can be used to configure the output
            processor with an internal name that matches the name parameter. See
            the USD ROP for more information about output processors.


        """
        return _hou.lop_outputProcessorParms(self, name)

    def usdVersionInfo(
        self,
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        usdVersionInfo() -> dict of str to str

            Returns a dictionary holding information about the USD library built
            into Houdini.


            usdversion
                The USD release number converted to a string. USD releases take
                the form YY.MM, where YY and MM are the year and month in which
                the release occurred.

            packageurl
                The URL of the git repository from which the USD library was
                built.

            packagerevision
                The git commit hash code for the specific branch used to build
                the USD library.

            The packageurl and packagerevision values may return an empty string
            if the USD library that ships with Houdini is replaced with a custom
            USD build.


        """
        return _hou.lop_usdVersionInfo(self)

    def usdOutputMinimumSeverity(self) -> "HOM_EnumValue &":
        r"""

        usdOutputMinimumSeverity() -> hou.severityType

            Returns the minimum USD message severity that will be output to
            standard output. The USD library can produce a variety of messages
            indicating error or warning conditions, or just status messages. If
            such a message is generated while a LOP node is cooking, the message
            will never be output to the console, regardless of this setting.


        """
        return _hou.lop_usdOutputMinimumSeverity(self)

    def setUsdOutputMinimumSeverity(self, severity: "EnumValue") -> "void":
        r"""

        setUsdOutputMinimumSeverity(hou.severityType)

            Sets the minimum message severity produced by the USD library that
            should be written to standard output. This method only controls the
            output of messages produced when a LOP node is not cooking.


        """
        return _hou.lop_setUsdOutputMinimumSeverity(self, severity)

    def addLockedGeometry(self, *args) -> "std::string":
        r"""

        addLockedGeometry(self, identifier, geo, args = {}) -> str

            Adds a locked copy of a hou.Geometry to a registry, so that it can
            be used as a USD reference or sublayer.

            The returned string is a USD layer identifier that can be used when
            adding a composition arc.

            If an args dictionary is specified, the contents must be pre-
            converted to be strings. For example: { 't': '1.0' } is valid, but {
            't': 1.0 } is not.


            NOTE
                The registry entries created by using this function must be
                explicitly removed via hou.lop.removeLockedGeometry.

            Example:

          > from pxr import Usd
          > geo = hou.Geometry()
          > geo.loadFromFile('shaderteapot.bgeo')
          > stage = Usd.Stage.CreateInMemory()
          > layer_id = hou.lop.addLockedGeometry('teapot', geo)
          > stage.GetRootLayer().subLayerPaths.append(layer_id)

            See also hou.LopNode.addLockedGeometry


        """
        return _hou.lop_addLockedGeometry(self, *args)

    def removeLockedGeometry(self, identifier: "char const *") -> "bool":
        r"""

        removeLockedGeometry(self, identifier) -> bool

            Removes a locked hou.Geometry from the registry, returning a bool to
            indicate success or failure.


            NOTE
                The identifier should be the str value returned from a previous
                call to hou.lop.addLockedGeometry.

            Example:

          > geo = hou.Geometry()
          > geo.loadFromFile('shaderteapot.bgeo')
          > layer_id = hou.lop.addLockedGeometry('teapot', geo)
          > hou.lop.removeLockedGeometry(layer_id)

        """
        return _hou.lop_removeLockedGeometry(self, identifier)

    def availableRendererInfo(self) -> "InterpreterObject":
        r"""

        availableRendererInfo() -> list of dict

            Returns a list of dicts containing meta data for registered renderer
            plugins.


        """
        return _hou.lop_availableRendererInfo(self)

    def addPreferenceChangeCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addPreferenceChangeCallback(callback)

            Registers a callback function that is invoked any time one of these
            preferences is changed.


        """
        return _hou.lop_addPreferenceChangeCallback(self, callback)

    def removePreferenceChangeCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removePreferenceChangeCallback(callback)

            Deregisters a callback function previously registered with a call to
            addPreferenceChangeCallback.


        """
        return _hou.lop_removePreferenceChangeCallback(self, callback)


# Register lop in _hou:
_hou.lop_swigregister(lop)


class LopInstanceIdRule(object):
    r"""

    hou.LopInstanceIdRule

    Stores a string that expresses a pattern to select instances from a
    point instancer primitive by id.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__(self)

            Create a LopInstanceIdRule object with default settings.


        """
        _hou.LopInstanceIdRule_swiginit(self, _hou.new_LopInstanceIdRule())

    def __eq__(self, rule: "HOM_PtrOrNull< HOM_LopInstanceIdRule >") -> "bool":
        return _hou.LopInstanceIdRule___eq__(self, rule)

    def __ne__(self, rule: "HOM_PtrOrNull< HOM_LopInstanceIdRule >") -> "bool":
        return _hou.LopInstanceIdRule___ne__(self, rule)

    def __hash__(self) -> "int":
        return _hou.LopInstanceIdRule___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.LopInstanceIdRule___repr__(self)

    def instanceIds(
        self, lopnode: "LopNode"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        instanceIds(self, lopnode) -> tuple of int

            Calculates the instance ids that match the pattern on the point
            instancer primitive on the stage generated by the provided LOP node
            object. The returned tuple of integers are ids from the point
            instancer's ids attribute. If no ids attribute is set on the point
            instancer, the instances are assumed to have increasing ids starting
            at 0.


        """
        return _hou.LopInstanceIdRule_instanceIds(self, lopnode)

    def primPath(self) -> "std::string":
        r"""

        primPath(self) -> str

            Return the path to the point instancer primitive that is used to
            evaluate the instance id pattern.


        """
        return _hou.LopInstanceIdRule_primPath(self)

    def setPrimPath(self, primpath: "char const *") -> "void":
        r"""

        setPrimPath(self, primpath)

            Sets the path to the point instancer primitive that is used to
            evaluate the instance id pattern.


        """
        return _hou.LopInstanceIdRule_setPrimPath(self, primpath)

    def instanceIdPattern(self) -> "std::string":
        r"""

        instanceIdPattern(self) -> str

            Return the pattern that described the instance ids that should be
            returned by the instanceIds method. This pattern accepts standard
            Houdini numeric range formatting, like what is provided in SOP group
            parameters.


        """
        return _hou.LopInstanceIdRule_instanceIdPattern(self)

    def setInstanceIdPattern(self, pattern: "char const *") -> "void":
        r"""

        setInstanceIdPattern(self, pattern)

            Sets the pattern that described the instance ids that should be
            returned by the instanceIds method. This pattern accepts standard
            Houdini numeric range formatting, like what is provided in SOP group
            parameters, such as 2-5 to indicate ids between 2 and 5, or ^15 to
            exclude id number 15.


        """
        return _hou.LopInstanceIdRule_setInstanceIdPattern(self, pattern)

    __swig_destroy__ = _hou.delete_LopInstanceIdRule


# Register LopInstanceIdRule in _hou:
_hou.LopInstanceIdRule_swigregister(LopInstanceIdRule)


class LopPostLayer(object):
    r"""

    hou.LopPostLayer

    Provides the ability to author post-layer data on a LOP Network.

    This object is used to define a with block in Python, which guarantees a
    well defined lifetime. Inside this block, this object provides access to
    an editable USD layer. When the block ends and this object is destroyed,
    the changes made to the USD layer are saved to the LOP Network, and any
    viewers pointed at nodes inside that LOP Network will be updated
    appropriately.

    This object is returned by a call to hou.LopNetwork.editablePostLayer.

    A post-layer is a concept within Solaris which allows USD layers to be
    added to the session layer of every LOP node's composed stage. These
    layers live outside the LOP node cook process, and so their content does
    not affect the operation of any LOP nodes. For example, primitives
    defined in a post-layer cannot be seen by any LOP nodes. But any request
    to access the stage of a LOP node will contain the content of these
    post-layers unless you specifically request that post-layers be excluded
    (using the apply_post_layers parameter in hou.LopNode.stage or turning
    off post layers in the Scene Viewer). Disabling post-layers should
    generally only be required when debugging the post-layer content.

    Because these are session layers, their opinions are stronger than any
    opinions authored by LOP nodes (which author opinions on the stage's
    root layer). Unlike Viewport Overrides, the content of these layers is
    also saved by the USD and USD Render ROPs, and so will affect final
    renders.

    Use cases for post-layers include the creation of standard primitives
    (like Render Settings) which should be available anywhere in the LOP
    Network. Another use case would be to apply a final pass to the scene
    graph data, such as disabling all materials for quick render tests. But
    since post-layers can only be authored by python code, integrating them
    into an artist's workflow will always require some custom user
    interface, though that interface may be as simple as providing
    checkboxes to turn certain post-layers on or off.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_LopPostLayer

    def __repr__(self) -> "std::string":
        return _hou.LopPostLayer___repr__(self)

    def __enter__(self) -> "HOM_LopPostLayer *":
        return _hou.LopPostLayer___enter__(self)

    def layer(self) -> "InterpreterObject":
        return _hou.LopPostLayer_layer(self)

    def stage(self) -> "InterpreterObject":
        return _hou.LopPostLayer_stage(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.LopPostLayer___exit__(self, type, value, traceback)


# Register LopPostLayer in _hou:
_hou.LopPostLayer_swigregister(LopPostLayer)


class LopSelectionRule(object):
    r"""

    hou.LopSelectionRule

    Stores a set of rules that define how to make a selection of scene graph
    primitives.

    See for more information on primitive patterns.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, pattern: "char const *" = None):
        r"""

        __init__(self, pattern=None)

            Create a LopSelectionRule object with default settings.

            The optional pattern parameter populates the selection rule with the
            supplied pattern string. This is equivalent to creating the rule and
            then calling hou.LopSelectionRule.setPathPattern.


        """
        _hou.LopSelectionRule_swiginit(self, _hou.new_LopSelectionRule(pattern))

    def expandedPaths(
        self,
        lopnode: "LopNode" = None,
        return_ancestors: "bool" = False,
        fallback_to_new_paths: "bool" = False,
        stage: "InterpreterObject" = None,
    ) -> "InterpreterObject":
        r"""

        expandedPaths(self, lopnode=None, return_ancestors=False,
        fallback_to_new_paths=False, stage=None) -> tuple of pxr.Sdf.Path

            Calculates the scene graph primitive selection using the scene graph
            from the provided LOP node object. If this selection rule was
            created with a call to hou.LopNode.selectionRule this parameter is
            optional. Instead of providing a LOP node, provide a Usd.Stage
            object as the stage parameter to evaluate the pattern on that stage.

            Returns the full paths to every scene graph primitive matching the
            selection rules. All collections in the path pattern are expanded to
            list their included prims explicitly.

            If return_ancestors is set to True, after the full set of primitives
            is calculated, if there are any primitives with all of their direct
            children in the set, the parent primitive is added to the set, and
            the child primitives are removed from the set. This reduced set can
            be very useful to reduce the number of primitives that need to be
            modified if the modification is one that inherits down the scene
            graph tree (such as visibility or activation).

            The fallback_to_new_paths parameter can be set to True to allow the
            selection rule to return scene graph paths if the pattern consists
            entirely of explicit paths which do not correspond to any existing
            primitives on the stage. Such paths may be used to express desired
            scene graph locations for new primitives. If the pattern contains a
            mix of existing paths and new paths, this method will always return
            only the existing paths. The new paths in such a scenario can be
            accessed by calling hou.LopSelectionRule.newPaths.


        """
        return _hou.LopSelectionRule_expandedPaths(
            self, lopnode, return_ancestors, fallback_to_new_paths, stage
        )

    def firstPath(
        self,
        lopnode: "LopNode" = None,
        return_ancestors: "bool" = False,
        fallback_to_new_paths: "bool" = False,
        stage: "InterpreterObject" = None,
    ) -> "InterpreterObject":
        r"""

        firstPath(self, lopnode=None, return_ancestors=False,
        fallback_to_new_paths=False, stage=None) -> pxr.Sdf.Path

            Behaves exactly like hou.LopSelectionRule.expandedPaths, but returns
            only a single path, which will be the first match (alphabetically
            sorted) of all matches (or the first new path if no matches are
            found).


        """
        return _hou.LopSelectionRule_firstPath(
            self, lopnode, return_ancestors, fallback_to_new_paths, stage
        )

    def collectionAwarePaths(
        self,
        lopnode: "LopNode" = None,
        fallback_to_new_paths: "bool" = False,
        stage: "InterpreterObject" = None,
    ) -> "InterpreterObject":
        r"""

        collectionAwarePaths(self, lopnode=None, fallback_to_new_paths=False,
        stage=None) -> tuple of pxr.Sdf.Path

            Calculates the scene graph primitive selection using the scene graph
            from the provided LOP node object. If this selection rule was
            created with a call to hou.LopNode.selectionRule this parameter is
            optional. Instead of providing a LOP node, provide a Usd.Stage
            object as the stage parameter to evaluate the pattern on that stage.

            Returns the full paths to every scene graph primitive or collection
            matching the selection pattern. Unlike the expandedPaths method,
            collections are not expanded to explicitly list their contents as
            primitives. Instead the full path of the collection itself is
            returned.

            If the primitive pattern contains any exclusions the included
            collections cannot be accurately tracked, so the results of this
            method will be the same as for expandedPaths.

            The fallback_to_new_paths parameter can be set to True to allow the
            selection rule to return scene graph paths if the pattern consists
            entirely of explicit paths which do not correspond to any existing
            primitives on the stage. Such paths may be used to express desired
            scene graph locations for new primitives. If the pattern contains a
            mix of existing paths and new paths, this method will always return
            only the existing paths. The new paths in such a scenario can be
            accessed by calling hou.LopSelectionRule.newPaths.


        """
        return _hou.LopSelectionRule_collectionAwarePaths(
            self, lopnode, fallback_to_new_paths, stage
        )

    def newPaths(
        self, lopnode: "LopNode" = None, stage: "InterpreterObject" = None
    ) -> "InterpreterObject":
        r"""

        newPaths(self, lopnode=None, stage=None) -> tuple of pxr.Sdf.Path

            Calculates the scene graph primitive selection using the scene graph
            from the provided LOP node object. If this selection rule was
            created with a call to hou.LopNode.selectionRule this parameter is
            optional. Instead of providing a LOP node, provide a Usd.Stage
            object as the stage parameter to evaluate the pattern on that stage.

            Nothing will be returned by this method unless the pattern consists
            entirely of explicit paths. Paths which represent existing
            primitives on the USD stage are not returned by this method.


        """
        return _hou.LopSelectionRule_newPaths(self, lopnode, stage)

    def __eq__(self, rule: "HOM_PtrOrNull< HOM_LopSelectionRule >") -> "bool":
        return _hou.LopSelectionRule___eq__(self, rule)

    def __ne__(self, rule: "HOM_PtrOrNull< HOM_LopSelectionRule >") -> "bool":
        return _hou.LopSelectionRule___ne__(self, rule)

    def __hash__(self) -> "int":
        return _hou.LopSelectionRule___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.LopSelectionRule___repr__(self)

    def lastError(self) -> "std::string":
        r"""

        lastError(self) -> str

            Any status or error messages generated the last time expandedPaths
            or collectionAwarePaths was called. This will generally contain
            information about invalid pattern strings.


        """
        return _hou.LopSelectionRule_lastError(self)

    def lastErrorSeverity(self) -> "HOM_EnumValue *":
        r"""

        lastErrorSeverity(self) -> hou.severityType

            The error status of the last time expandedPaths or
            collectionAwarePaths was called. If this value is anything other
            than hou.severityType.None, the lastError method will return a
            string with more information.


        """
        return _hou.LopSelectionRule_lastErrorSeverity(self)

    def lastMayBeTimeVarying(self) -> "bool":
        r"""

        lastMayBeTimeVarying(self) -> bool

            A boolean indicating if the most recent calculation of the members
            of this selection rule might produce a time varying result. This may
            occur if the selection rule depends on a time varying attribute such
            as the transform or bounding box of some primitives.


        """
        return _hou.LopSelectionRule_lastMayBeTimeVarying(self)

    def pathPattern(self) -> "std::string":
        r"""

        pathPattern(self) -> str

            Return the path pattern string used in this selection rule.


        """
        return _hou.LopSelectionRule_pathPattern(self)

    def setPathPattern(self, pattern: "char const *") -> "void":
        r"""

        setPathPattern(self, pattern)

            Sets the path pattern string used in this selection rule.

            See for the pattern syntax.


        """
        return _hou.LopSelectionRule_setPathPattern(self, pattern)

    def traversalDemands(self) -> "int":
        r"""

        traversalDemands(self) -> int

            Return an integer value that expresses any demands made on the USD
            primitives while traversing the scene graph looking for matches.


        """
        return _hou.LopSelectionRule_traversalDemands(self)

    def setTraversalDemands(self, demands: "int") -> "void":
        r"""

        setTraversalDemands(self, options)

            Set demands that must be met by primitives while traversing the
            scene graph. These demands are expressed as an integer value. This
            value can be any combination of the hou.lopTraversalDemands values.

            Multiple demands can be combined with the | operator. The following
            builds a rule that will only return USD primitives that are active
            and defined:

          > >>> rule = hou.LopSelectionRule()
          > >>> rule.SetTraversalDemands(hou.lopTraversalDemands.Active | hou.lopTraversalDemands.Defined)

        """
        return _hou.LopSelectionRule_setTraversalDemands(self, demands)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> str

            Return the icon that should be associated with this selection rule
            when displaying it in the Scene Graph Tree collection panel.


        """
        return _hou.LopSelectionRule_icon(self)

    def setIcon(self, icon: "char const *") -> "void":
        r"""

        setIcon(self, icon)

            Set the path to the icon file that should be associated with this
            selection rule in the Scene Graph Tree collection panel. This string
            can be a path to an image or SVG file on disk, or the name of any
            standard Houdini icon.


        """
        return _hou.LopSelectionRule_setIcon(self, icon)

    def sourceNode(self) -> "HOM_Node *":
        r"""

        sourceNode(self) -> hou.LopNode or None

            Return the LOP node that was used to create this rule, if it was
            created by calling hou.LopNode.selectionRule. Otherwise return None.


        """
        return _hou.LopSelectionRule_sourceNode(self)

    def sourceNodeInputIndex(self) -> "int":
        r"""

        sourceNodeInputIndex(self) -> int

            Return the input index parameter used to create this rule, if it was
            created by calling hou.LopNode.selectionRule. Otherwise return -1.


        """
        return _hou.LopSelectionRule_sourceNodeInputIndex(self)

    __swig_destroy__ = _hou.delete_LopSelectionRule


# Register LopSelectionRule in _hou:
_hou.LopSelectionRule_swigregister(LopSelectionRule)


class LopViewportLoadMasks(object):
    r"""

    hou.LopViewportLoadMasks

    Stores a description of which payloads on the USD stage should be loaded
    into the viewport.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__(self)

            Create a LopViewportLoadMasks object with default settings. This
            object describes various options for controlling which primitives
            and layers are composed together on the stage that is visible in the
            viewport. This object allows for the control of the stage population
            mask, the loading of payload primitives, and the muting of layers
            from disk. The default settings populate and load all primitives and
            layers.


        """
        _hou.LopViewportLoadMasks_swiginit(self, _hou.new_LopViewportLoadMasks())

    def __eq__(self, masks: "HOM_PtrOrNull< HOM_LopViewportLoadMasks >") -> "bool":
        return _hou.LopViewportLoadMasks___eq__(self, masks)

    def __ne__(self, masks: "HOM_PtrOrNull< HOM_LopViewportLoadMasks >") -> "bool":
        return _hou.LopViewportLoadMasks___ne__(self, masks)

    def __hash__(self) -> "int":
        return _hou.LopViewportLoadMasks___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.LopViewportLoadMasks___repr__(self)

    def setPopulateAll(self, populate_all: "bool" = True) -> "void":
        r"""

        setPopulateAll(self, populate_all = True)

            Configures the stage mask to include the entire scene graph. This
            clears the current list of paths to populate because it is not
            needed. If populate_all is set to False, and populateAll is
            currently set to True, this method is equivalent to calling
            setPopulatePaths with an empty path list. If populateAll is already
            False, calling this method with a populate_all value of False will
            do nothing. Calling any method which manipulates the list of paths
            to populate will automatically set this flag back to False.


        """
        return _hou.LopViewportLoadMasks_setPopulateAll(self, populate_all)

    def populateAll(self) -> "bool":
        r"""

        populateAll(self) -> bool

            Returns True if the stage mask is configured to include the entire
            scene graph. If True, the explicit list of paths has no meaning.


        """
        return _hou.LopViewportLoadMasks_populateAll(self)

    def populatePaths(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        populatePaths(self) -> tuple of str

            Return the list of all paths which should be populated on the stage.
            Descendants of explicitly named primitives will also populate on the
            stage.


        """
        return _hou.LopViewportLoadMasks_populatePaths(self)

    def isPathPopulated(
        self, path: "char const *", exact_match: "bool" = True
    ) -> "bool":
        r"""

        isPathPopulated(self, path, exact_match = True) -> bool

            Return True if the specified scene graph path is explicitly named in
            the list of paths to populate. If exact_match is False, this method
            also returns true if any ancestor of the supplied path is in the set
            of paths to populate.


        """
        return _hou.LopViewportLoadMasks_isPathPopulated(self, path, exact_match)

    def setPopulatePaths(self, paths: "_StringTuple") -> "void":
        r"""

        setPopulatePaths(self, paths)

            Set the list of paths which should be populated on the stage.


        """
        return _hou.LopViewportLoadMasks_setPopulatePaths(self, paths)

    def addPopulatePath(self, path: "char const *") -> "void":
        r"""

        addPopulatePath(self, path)

            Adds a single path to the list of paths to populate. If the path is
            already in the list of paths, this method does nothing.


        """
        return _hou.LopViewportLoadMasks_addPopulatePath(self, path)

    def removePopulatePath(
        self, path: "char const *", remove_children: "bool" = False
    ) -> "void":
        r"""

        removePopulatePath(self, path)

            Removes a single path from the list of paths to populate . If the
            path is not in the list of paths, this method does nothing.

            If remove_children is set to True, all children of the primitive at
            path are also removed from the set of populated paths.


        """
        return _hou.LopViewportLoadMasks_removePopulatePath(self, path, remove_children)

    def muteLayers(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        muteLayers(self) -> tuple of str

            Return the list of all muted layer identifiers.


        """
        return _hou.LopViewportLoadMasks_muteLayers(self)

    def isLayerMuted(self, identifier: "char const *") -> "bool":
        r"""

        isLayerMuted(self, identifier) -> bool

            Return True if the specified layer identifier should be ignored when
            composing the stage.


        """
        return _hou.LopViewportLoadMasks_isLayerMuted(self, identifier)

    def setMuteLayers(self, identifiers: "_StringTuple") -> "void":
        r"""

        setMuteLayers(self, identifiers)

            Set the list of layer identifiers that should be muted.


        """
        return _hou.LopViewportLoadMasks_setMuteLayers(self, identifiers)

    def addMuteLayer(self, identifier: "char const *") -> "void":
        r"""

        addMuteLayer(self, identifier)

            Adds a single layer identifier to the list of muted layer
            identifiers. If the identifier is already being muted, this method
            does nothing.


        """
        return _hou.LopViewportLoadMasks_addMuteLayer(self, identifier)

    def removeMuteLayer(self, identifier: "char const *") -> "void":
        r"""

        removeMuteLayer(self, identifier)

            Removes a single layer identifier from the list of muted layer
            identifiers. If the identifier is not being muted, this method does
            nothing.


        """
        return _hou.LopViewportLoadMasks_removeMuteLayer(self, identifier)

    def setLoadAll(self, load_all: "bool" = True) -> "void":
        r"""

        setLoadAll(self, load_all = True)

            Set the flag indicating that all payloads should be loaded by
            default. If load_all is set to False, and loadAll is currently set
            to True, this method is equivalent to calling setLoadPaths with an
            empty path list. If loadAll is already False, calling this method
            with a load_all value of False will do nothing. Calling any method
            which manipulates the list of paths to be loaded will automatically
            set this flag back to False.


        """
        return _hou.LopViewportLoadMasks_setLoadAll(self, load_all)

    def loadAll(self) -> "bool":
        return _hou.LopViewportLoadMasks_loadAll(self)

    def loadPaths(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        loadPaths(self) -> tuple of str

            Return a list of all scene graph branches which will load their
            payloads in the viewport. Descendants of explicitly named primitives
            will also load their payloads.


        """
        return _hou.LopViewportLoadMasks_loadPaths(self)

    def isPathLoaded(self, path: "char const *", exact_match: "bool" = True) -> "bool":
        r"""

        isPathLoaded(self, path, exact_match = True) -> bool

            Return True if the specified scene graph path is explicitly named in
            the list of paths to load. If exact_match is False, this method also
            returns true if any ancestor of the supplied path is in the set of
            paths to load.


        """
        return _hou.LopViewportLoadMasks_isPathLoaded(self, path, exact_match)

    def isAnyChildPathLoaded(self, path: "char const *") -> "bool":
        r"""

        isAnyChildPathLoaded(self, path) -> bool

            Return True if the specified scene graph path or any of its children
            appear in the list of paths to load.


        """
        return _hou.LopViewportLoadMasks_isAnyChildPathLoaded(self, path)

    def setLoadPaths(self, paths: "_StringTuple") -> "void":
        r"""

        setLoadPaths(self, paths)

            Set the list of scene graph paths which should load their payloads
            in the viewport.


        """
        return _hou.LopViewportLoadMasks_setLoadPaths(self, paths)

    def addLoadPath(self, path: "char const *") -> "void":
        r"""

        addLoadPath(self, path)

            Adds a single path to the list of scene graph paths which will load
            their payloads inthe viewport. If the path is already in the list,
            this method does nothing.


        """
        return _hou.LopViewportLoadMasks_addLoadPath(self, path)

    def removeLoadPath(
        self, path: "char const *", remove_children: "bool" = False
    ) -> "void":
        r"""

        removeLoadPath(self, path, remove_children = False)

            Removes a single path from the list of scene graph paths which will
            load their payloads in the viewport. If the path is not in the list,
            this method does nothing.

            If remove_children is set to True, all children of the primitive at
            path are also removed from the set of loaded paths.


        """
        return _hou.LopViewportLoadMasks_removeLoadPath(self, path, remove_children)

    __swig_destroy__ = _hou.delete_LopViewportLoadMasks


# Register LopViewportLoadMasks in _hou:
_hou.LopViewportLoadMasks_swigregister(LopViewportLoadMasks)


class LopViewportOverrides(object):
    r"""

    hou.LopViewportOverrides

    Used to edit the current session overlay layer that is applied to the
    current LOP node's scene graph.

    This object is a context manager. You can create one using
    hou.LopNetwork.viewportOverrides. At the end of the with block, the
    notification of the session edits is propagated to viewer panes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_LopViewportOverrides

    def __repr__(self) -> "std::string":
        return _hou.LopViewportOverrides___repr__(self)

    def __enter__(self) -> "HOM_LopViewportOverrides *":
        return _hou.LopViewportOverrides___enter__(self)

    def setDrawMode(
        self, prims: "LopSelectionRule", drawmode: "char const *"
    ) -> "void":
        r"""

        setDrawMode(self, prims, drawmode)

            Change the draw mode of USD primitives by editing the session layer
            of a LOP Network. The draw mode of a primitive is only respected if
            the primitive is part of a valid, contiguous USD model hierarchy.
            The LOP Network to edit is determined by looking at the LOP node
            used to create this session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            drawmode
                A string value indicating the new draw mode for the USD
                primitives. Only primitives that are part of a valid USD model
                hierarchy can have their draw mode changed. The allowed values
                for this string are default (draw the full geometry), origin
                (draw a set of axes at the origin of the primitive), bounds
                (draw a bounding box around the primitive), and cards (draw
                three axis-aligned cards that fill the primitive's bounding
                box).


        """
        return _hou.LopViewportOverrides_setDrawMode(self, prims, drawmode)

    def setActive(self, prims: "LopSelectionRule", active: "bool") -> "void":
        r"""

        setActive(self, prims, active)

            Change the active state of USD primitives by editing the session
            layer of a LOP Network. Deactivated primitives do not appear in the
            viewport, and cannot be expanded in the scene graph tree. The LOP
            Network to edit is determined by looking at the LOP node used to
            create this session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            active
                A boolean value indicating the new activation state of the USD
                primitives.


        """
        return _hou.LopViewportOverrides_setActive(self, prims, active)

    def setVisible(self, prims: "LopSelectionRule", visible: "bool") -> "void":
        r"""

        setVisible(self, prims, visible)

            Change the visibility of USD primitives by editing the session layer
            of a LOP Network. Invisible primitives are not drawn in the
            viewport, but still appear in the scene graph tree. The LOP Network
            to edit is determined by looking at the LOP node used to create this
            session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            visible
                A boolean value indicating whether the USD primitives should be
                visible.


        """
        return _hou.LopViewportOverrides_setVisible(self, prims, visible)

    def setSelectable(
        self, prims: "LopSelectionRule", active: "bool", solo: "bool" = False
    ) -> "void":
        r"""

        setSelectable(self, prims, selectable, solo = False)

            Change the selectability of USD primitives by editing the session
            layer of a LOP Network. Unselectable primitives are ignored when
            performing a selection operation in the viewport. The LOP Network to
            edit is determined by looking at the LOP node used to create this
            session editor object. All descendants of an unselectable primitive
            are also unselectable, even if they are explicitly set as
            selectable. An unselectable setting on and ancestor primitive takes
            precedence.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            selectable
                A boolean value indicating the new selectable value of the USD
                primitives.

            solo
                A boolean value indicating that the supplied set of primitives
                should be the only primitives in the scene that are selectable
                (or not selectable). This may involve modifying the selectable
                attribute on many primitives across the scene, not just the
                specified primitives.


        """
        return _hou.LopViewportOverrides_setSelectable(self, prims, active, solo)

    def setSoloLights(self, prims: "LopSelectionRule" = None) -> "void":
        r"""

        setSoloLights(self, prims)

            Deactivates any lights not specified by the prims parameter.


            prims
                A hou.LopSelectionRule object that specifies which USD light
                primitives should be remain active after running this method. Or
                can be None to disable any existing soloing of lights.


        """
        return _hou.LopViewportOverrides_setSoloLights(self, prims)

    def addSoloLights(self, prims: "LopSelectionRule") -> "void":
        r"""

        addSoloLights(self, prims)

            Adds lights to the set of activated lights in the scene.


            prims
                A hou.LopSelectionRule object that specifies which USD light
                primitives should be added to the set of solo active lights.


        """
        return _hou.LopViewportOverrides_addSoloLights(self, prims)

    def removeSoloLights(self, prims: "LopSelectionRule") -> "void":
        r"""

        removeSoloLights(self, prims)

            Remove lights from the set of activated lights in the scene. If all
            lights are removed from the solo lights group, all lights in the
            scene will be activated.


            prims
                A hou.LopSelectionRule object that specifies which USD light
                primitives should be removed from the set of solo active lights.


        """
        return _hou.LopViewportOverrides_removeSoloLights(self, prims)

    def setSoloGeometry(self, prims: "LopSelectionRule" = None) -> "void":
        r"""

        setSoloGeometry(self, prims)

            Turns off the visibility of any geometry not specified by the prims
            parameter.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives should be remain visible after running this method.
                Any descendants of the specified primitives will also be made
                visible. This parameter can also be None to disable any existing
                soloing of geometry.


        """
        return _hou.LopViewportOverrides_setSoloGeometry(self, prims)

    def addSoloGeometry(self, prims: "LopSelectionRule") -> "void":
        r"""

        addSoloGeometry(self, prims)

            Adds geometry primitives to the set of activated geometry in the
            scene.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives should be added to the set of solo visible geometry.


        """
        return _hou.LopViewportOverrides_addSoloGeometry(self, prims)

    def removeSoloGeometry(self, prims: "LopSelectionRule") -> "void":
        r"""

        removeSoloGeometry(self, prims)

            Remove geometry from the set of visible geometry in the scene. If
            all geometry are removed from the solo geometry group, all geometry
            in the scene will be made visible.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives should be removed from the set of solo visible
                geometry.


        """
        return _hou.LopViewportOverrides_removeSoloGeometry(self, prims)

    def setDisplayOpacity(self, prims: "LopSelectionRule", opacity: "float") -> "void":
        r"""

        setDisplayOpacity(self, prims, opacity)

            Change the display opacity of USD primitives by editing the session
            layer of a LOP Network. The LOP Network to edit is determined by
            looking at the LOP node used to create this session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            opacity
                A float value between 0 (fully transparent) and 1 (fully
                opaque).


        """
        return _hou.LopViewportOverrides_setDisplayOpacity(self, prims, opacity)

    def clear(
        self, layer_id: "EnumValue" = None, from_prim: "char const *" = None
    ) -> "void":
        r"""

        clear(self, layer_id = None, from_prim = None)

            Clears one or all viewport overrides layers.


            layer_id
                A hou.lopViewportOverridesLayer value to clear a specific
                overrides layer, or None to clear all layers.

            from_prim
                A path to the primitive that is the root of the portion of the
                scene graph tree from which the overrides should be cleared. Set
                to None to clear overrides for the whole scene graph.


        """
        return _hou.LopViewportOverrides_clear(self, layer_id, from_prim)

    def layer(self) -> "InterpreterObject":
        r"""

        layer(self) -> pxr.Sdf.Layer

            Return the pxr.Sdf.Layer object that contains current custom session
            edits to the scene graph. These edits are accessible using the
            hou.lopViewportOverridesLayer.Custom layer id. This layer does not
            include opinions set using built in Houdini panels. This layer only
            hold opinions authored through the layer returned by this method.
            This object can be modified using the pxr.Sdf.Layer API to make
            further session modifications to the scene graph.


        """
        return _hou.LopViewportOverrides_layer(self)

    def stage(self) -> "InterpreterObject":
        r"""

        stage(self) -> pxr.Sdf.Stage

            Return the pxr.Usd.Stage object that contains all the current
            session edits to the scene graph. This object can be modified using
            the pxr.Usd.Stage API to make further session modifications to the
            scene graph.


        """
        return _hou.LopViewportOverrides_stage(self)

    def soloLights(self) -> "InterpreterObject":
        r"""

        soloLights(self) -> tuple of pxr.Sdf.Path

            Return a set containing the paths to all solo active light
            primitives.


        """
        return _hou.LopViewportOverrides_soloLights(self)

    def soloGeometry(self) -> "InterpreterObject":
        r"""

        soloGeometry(self) -> tuple of pxr.Sdf.Path

            Return a set containing the paths to all solo visible geometry
            primitives.


        """
        return _hou.LopViewportOverrides_soloGeometry(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.LopViewportOverrides___exit__(self, type, value, traceback)


# Register LopViewportOverrides in _hou:
_hou.LopViewportOverrides_swigregister(LopViewportOverrides)


class Matrix2(object):
    r"""

    hou.Matrix2

    A 2x2 matrix of floating point values.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values)

            Return a new Matrix2. You can pass no parameters (the result will
            contain all zeros), a float (the result's diagonal values will
            contain that float and the rest is all zeros), a sequence of 4
            floats, or a sequence of sequences of 2 floats.

          > >>> hou.Matrix2()
          > <hou.Matrix2 [[0, 0], [0, 0]]]>
          >
          > >>> hou.Matrix2(1)
          > <hou.Matrix2 [[1, 0], [0, 1]]>
          >
          > >>> hou.Matrix2((0, 1, 2, 3))
          > <hou.Matrix2 [[0, 1], [2, 3]]>
          >
          > >>> hou.Matrix2(((0, 1), (3, 4)))
          > <hou.Matrix2 [[0, 1], [2, 3]]>

            Note that Houdini's matrices are stored in row-major order, so the
            matrix's contents are grouped by row.


        """
        _hou.Matrix2_swiginit(self, _hou.new_Matrix2(*args))

    __swig_destroy__ = _hou.delete_Matrix2

    def __eq__(self, matrix2: "HOM_PtrOrNull< HOM_Matrix2 >") -> "bool":
        return _hou.Matrix2___eq__(self, matrix2)

    def __ne__(self, matrix2: "HOM_PtrOrNull< HOM_Matrix2 >") -> "bool":
        return _hou.Matrix2___ne__(self, matrix2)

    def isAlmostEqual(
        self, matrix2: "Matrix2", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, matrix2, tolerance=0.00001) -> bool

            Returns whether this matrix is equal to another, within a tolerance.


        """
        return _hou.Matrix2_isAlmostEqual(self, matrix2, tolerance)

    def __hash__(self) -> "int":
        return _hou.Matrix2___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Matrix2___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Matrix2___repr__(self)

    def at(self, row: "int", col: "int") -> "double":
        r"""

        at(self, row, col) -> double

            Return the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 1,
            inclusive. Note that negative indices will not index from the end.


        """
        return _hou.Matrix2_at(self, row, col)

    def asTuple(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        asTuple(self) -> tuple of float

            Return the contents of the matrix as a tuple of 4 floats.


        """
        return _hou.Matrix2_asTuple(self)

    def asTupleOfTuples(
        self,
    ) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        r"""

        asTupleOfTuples(self) -> tuple of tuple of float

            Return the contents of the matrix as a tuple of tuples of 2 floats.


        """
        return _hou.Matrix2_asTupleOfTuples(self)

    def setAt(self, row: "int", col: "int", value: "double") -> "void":
        r"""

        setAt(self, row, col, value)

            Set the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 1,
            inclusive. Note that negative indices will not index from the end.


        """
        return _hou.Matrix2_setAt(self, row, col, value)

    def setTo(self, *args) -> "void":
        r"""

        setTo(self, tuple)

            Set this matrix's contents. The sequence may contain either 4 floats
            or 2 sequences, each with 2 floats.

            See hou.Matrix2.__init__ for examples of suitable parameter values.


        """
        return _hou.Matrix2_setTo(self, *args)

    def setToIdentity(self) -> "void":
        r"""

        setToIdentity(self)

            Set this matrix to the multiplicative identity, having 1's in the
            diagonal.

            The matrix will contain the values [[1, 0], [0, 1]]. Note that you
            can construct a new matrix with these values using hou.Matrix2(1).


        """
        return _hou.Matrix2_setToIdentity(self)

    def setToZero(self) -> "void":
        r"""

        setToZero(self)

            Set this matrix to contain all zeros.

            Note that you can construct a new matrix with all zeros with
            hou.Matrix2().


        """
        return _hou.Matrix2_setToZero(self)

    def __add__(self, matrix2: "Matrix2") -> "HOM_Matrix2":
        r"""

        __add__(self, matrix2) -> hou.Matrix2

            Add two matrices by adding corresponding entries together and return
            a new matrix. This method lets you write m1 + m2, where m1 and m2
            are Matrix2 objects.


        """
        return _hou.Matrix2___add__(self, matrix2)

    def __sub__(self, matrix2: "Matrix2") -> "HOM_Matrix2":
        r"""

        __sub__(self, matrix2) -> hou.Matrix2

            Subtract another matrix from this one, subtracting corresponding
            entries, and return a new matrix. This method lets you write m1 -
            m2, where m1 and m2 are Matrix2 objects.


        """
        return _hou.Matrix2___sub__(self, matrix2)

    def __mul__(self, *args) -> "HOM_Matrix2":
        r"""

        __mul__(self, matrix2_or_scalar) -> hou.Matrix2

            Multiply this matrix by another matrix or by a scalar, returning a
            new matrix. This method lets you write m1 * m2, where m1 and m2 are
            Matrix2 objects, or m1 * s, where s is a float.

            See Wikipedia's matrix multiplication page for details on how each
            element in the result is computed.


        """
        return _hou.Matrix2___mul__(self, *args)

    def preMult(self, matrix2: "Matrix2") -> "HOM_Matrix2":
        r"""

        preMult(self, matrix2) -> hou.Matrix2

            Returns matrix2 * self. Note that __mul__ returns self * matrix2,
            which is a different result because matrix multiplication is not
            commutative.


        """
        return _hou.Matrix2_preMult(self, matrix2)

    def transposed(self) -> "HOM_Matrix2":
        r"""

        transposed(self) -> hou.Matrix2

            Return the transpose of this matrix. The result is such that
            self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 1.

            See Wikipedia's transpose page for more information.


        """
        return _hou.Matrix2_transposed(self)

    def inverted(self) -> "HOM_Matrix2":
        r"""

        inverted(self) -> hou.Matrix2

            Return the inverse of this matrix.

            Raises hou.OperationFailed if the matrix is not invertible.
            Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix2(1)) is
            True.

            See Wikipedia's invertible matrix page for more information.


        """
        return _hou.Matrix2_inverted(self)

    def determinant(self) -> "double":
        r"""

        determinant(self) -> double

            Return the determinant of the matrix.

            See Wikipedia's determinant page.


        """
        return _hou.Matrix2_determinant(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.Matrix2__asVoidPointer(self)


# Register Matrix2 in _hou:
_hou.Matrix2_swigregister(Matrix2)


class Matrix3(object):
    r"""

    hou.Matrix3

    A 3x3 matrix of floating point values.

    3x3 matrices are typically used in Houdini to represent a 3D rotation
    (with a possible scale). Most places in Houdini use hou.Matrix4, which
    can store generation 3D transformations (including translations).

    Note that you can construct a general transformation Matrix4 from a
    Matrix3 by writing hou.Matrix4(matrix3).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values)

            Return a new Matrix3. You can pass no parameters (the result will
            contain all zeros), a float (the result's diagonal values will
            contain that float and the rest is all zeros), a sequence of 9
            floats, or a sequence of sequences of 3 floats.

          > >>> hou.Matrix3()
          > <hou.Matrix3 [[0, 0, 0], [0, 0, 0], [0, 0, 0]]>
          >
          > >>> hou.Matrix3(1)
          > <hou.Matrix3 [[1, 0, 0], [0, 1, 0], [0, 0, 1]]>
          >
          > >>> hou.Matrix3((0, 1, 2, 3, 4, 5, 6, 7, 8))
          > <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>
          >
          > >>> hou.Matrix3(((0, 1, 2), (3, 4, 5), (6, 7, 8)))
          > <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>

            Note that Houdini's matrices are stored in row-major order, so the
            matrix's contents are grouped by row.


        """
        _hou.Matrix3_swiginit(self, _hou.new_Matrix3(*args))

    __swig_destroy__ = _hou.delete_Matrix3

    def __eq__(self, matrix3: "HOM_PtrOrNull< HOM_Matrix3 >") -> "bool":
        return _hou.Matrix3___eq__(self, matrix3)

    def __ne__(self, matrix3: "HOM_PtrOrNull< HOM_Matrix3 >") -> "bool":
        return _hou.Matrix3___ne__(self, matrix3)

    def isAlmostEqual(
        self, matrix3: "Matrix3", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, matrix3, tolerance=0.00001) -> bool

            Returns whether this matrix is equal to another, within a tolerance.


        """
        return _hou.Matrix3_isAlmostEqual(self, matrix3, tolerance)

    def __hash__(self) -> "int":
        return _hou.Matrix3___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Matrix3___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Matrix3___repr__(self)

    def at(self, row: "int", col: "int") -> "double":
        r"""

        at(self, row, col) -> double

            Return the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 2,
            inclusive. Note that negative indices will not index from the end.


        """
        return _hou.Matrix3_at(self, row, col)

    def asTuple(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        asTuple(self) -> tuple of float

            Return the contents of the matrix as a tuple of 9 floats.


        """
        return _hou.Matrix3_asTuple(self)

    def asTupleOfTuples(
        self,
    ) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        r"""

        asTupleOfTuples(self) -> tuple of tuple of float

            Return the contents of the matrix as a tuple of tuples of 3 floats.


        """
        return _hou.Matrix3_asTupleOfTuples(self)

    def setAt(self, row: "int", col: "int", value: "double") -> "void":
        r"""

        setAt(self, row, col, value)

            Set the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 2,
            inclusive. Note that negative indices will not index from the end.


        """
        return _hou.Matrix3_setAt(self, row, col, value)

    def setTo(self, *args) -> "void":
        r"""

        setTo(self, tuple)

            Set this matrix's contents. The sequence may contain either 9 floats
            or 3 sequences, each with 3 floats.

            See hou.Matrix3.__init__ for examples of suitable parameter values.


        """
        return _hou.Matrix3_setTo(self, *args)

    def setToIdentity(self) -> "void":
        r"""

        setToIdentity(self)

            Set this matrix to the multiplicative identity, having 1's in the
            diagonal.

            The matrix will contain the values [[1, 0, 0], [0, 1, 0], [0, 0,
            1]]. Note that you can construct a new matrix with these values
            using hou.Matrix3(1).


        """
        return _hou.Matrix3_setToIdentity(self)

    def setToZero(self) -> "void":
        r"""

        setToZero(self)

            Set this matrix to contain all zeros.

            Note that you can construct a new matrix with all zeros with
            hou.Matrix3().


        """
        return _hou.Matrix3_setToZero(self)

    def __add__(self, matrix3: "Matrix3") -> "HOM_Matrix3":
        r"""

        __add__(self, matrix3) -> hou.Matrix3

            Add two matrices by adding corresponding entries together and return
            a new matrix. This method lets you write m1 + m2, where m1 and m2
            are Matrix3 objects.


        """
        return _hou.Matrix3___add__(self, matrix3)

    def __sub__(self, matrix3: "Matrix3") -> "HOM_Matrix3":
        r"""

        __sub__(self, matrix3) -> hou.Matrix3

            Subtract another matrix from this one, subtracting corresponding
            entries, and return a new matrix. This method lets you write m1 -
            m2, where m1 and m2 are Matrix3 objects.


        """
        return _hou.Matrix3___sub__(self, matrix3)

    def __mul__(self, *args) -> "HOM_Matrix3":
        r"""

        __mul__(self, matrix3_or_scalar) -> hou.Matrix3

            Multiply this matrix by another matrix or by a scalar, returning a
            new matrix. This method lets you write m1 * m2, where m1 and m2 are
            Matrix3 objects, or m1 * s, where s is a float.

            See Wikipedia's matrix multiplication page for details on how each
            element in the result is computed. Also see hou.Matrix4.


        """
        return _hou.Matrix3___mul__(self, *args)

    def preMult(self, matrix3: "Matrix3") -> "HOM_Matrix3":
        r"""

        preMult(self, matrix3) -> hou.Matrix3

            Returns matrix3 * self. Note that __mul__ returns self * matrix3,
            which is a different result because matrix multiplication is not
            commutative.


        """
        return _hou.Matrix3_preMult(self, matrix3)

    def transposed(self) -> "HOM_Matrix3":
        r"""

        transposed(self) -> hou.Matrix3

            Return the transpose of this matrix. The result is such that
            self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 2.

            See Wikipedia's transpose page for more information.


        """
        return _hou.Matrix3_transposed(self)

    def inverted(self) -> "HOM_Matrix3":
        r"""

        inverted(self) -> hou.Matrix3

            Return the inverse of this matrix.

            Raises hou.OperationFailed if the matrix is not invertible.
            Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix3(1)) is
            True.

            See Wikipedia's invertible matrix page for more information.


        """
        return _hou.Matrix3_inverted(self)

    def determinant(self) -> "double":
        r"""

        determinant(self) -> double

            Return the determinant of the matrix.

            See Wikipedia's determinant page.


        """
        return _hou.Matrix3_determinant(self)

    def extractRotates(self, *args, **kwargs) -> "HOM_Vector3":
        r"""

        extractRotates(self, rotate_order=\"xyz\") -> hou.Vector3

            Return a Vector3 of Euler angles, in degrees, representing the
            rotation component of this matrix. Rotating about the coordinate
            axes in the specified order by these amounts will yield the rotation
            contained in this matrix.


            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.

            Raises hou.OperationFailed if the matrix does not represent a valid
            rotation matrix (e.g. it is singular) or the rotate order is not a
            permutation of the string 'xyz'.

            See also hou.Matrix4.explode and hou.Matrix4.extractRotates.


            WARNING
                If there are scales or shears in the matrix, the results are as
                if they were first removed on the left side. (ie. SR -> R). If
                you wish to control for this, first use
                hou.Matrix3.removeScalesAndShears with the desired transform
                order.


        """
        return _hou.Matrix3_extractRotates(self, *args, **kwargs)

    def removeScalesAndShears(
        self, *args, **kwargs
    ) -> "std::pair< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        removeScalesAndShears(self, transform_order=\"srt\") -> tuple of
        (hou.Vector3, hou.Vector3)

            Remove scales and shears from this matrix and return them as a tuple
            of (scales, shears).


            transform_order
                A 3 character string containing a permutation of the letters s,
                r, and t. If s occurs before r, then the scales/shears are
                extracted from the left of this matrix. Otherwise, they will be
                extracted from the right instead.

            Raises hou.OperationFailed if transform_order is invalid.

            See also: hou.Matrix3.extractRotates, hou.Matrix4.extractRotates,
            hou.Matrix4.extractRotationMatrix3


        """
        return _hou.Matrix3_removeScalesAndShears(self, *args, **kwargs)

    def _asVoidPointer(self) -> "void *":
        return _hou.Matrix3__asVoidPointer(self)


# Register Matrix3 in _hou:
_hou.Matrix3_swigregister(Matrix3)


class Matrix4(object):
    r"""

    hou.Matrix4

    A 4x4 matrix of floating point values.

    4x4 matrices are typically used in Houdini to represent a 3D
    transformation (e.g. some combination of rotation, scaling, shearing,
    and translation). A single matrix compactly represents a transformation,
    and is much easier to deal with than multiple translate, rotate, scale,
    shear, transformation order, and rotation order values.

    Note that Houdini's matrices are stored in row-major format, and vectors
    that are multiplied with matrices are treated as row vectors. So, if p
    is a hou.Vector4 representing a point and M is a Matrix4, you write p*M,
    not M*p. Similarly, p*M1*M2 will first transform p by M1, and then
    transform it by M2.


    NOTE
        Most mathematical notations treat vectors and points as column
        vectors instead of row vectors. They will often use A*B*C (or simply
        ABC) to refer to a combined transform that first applies C's
        transform, then B's, and then applies A's. However, the convention
        is different in Houdini. To represent the equivalent matrix
        expression in Houdini, you need to concatenate the transforms in the
        reverse order. So, you would instead write C'*B'*A', where C', B',
        A' are the transpose of C, B, A respectively.

    You can multiply Vector3s or Vector4s by Matrix4s. If you multiply a
    Vector3, it is the same as multiplying a Vector4 where the fourth
    component is 1 (see hou.Vector3.__mul__).

    To transform a normal (as opposed to a point or vector), you need to
    multiply by the inverse transpose of the matrix. For example, suppose:


    p
        is a hou.Vector3 object representing a position (or a hou.Vector4
        with p[3]==1)

    v
        is a hou.Vector4 object representing a vector (a direction with a
        length but no fixed location in space), with v[3]==0

    n
        is a hou.Vector4 object representing a normal, with v[3]==0

    m
        is a Matrix4 object representing a transform matrix

    Then you would write:

    > p * m # to transform the point
    > v * m # to transform the vector
    > n * m.inverted().transposed() # to transform the normal
    > # (note that m.inverted().transposed() is mathematically equivalent to m.transposed().inverted())

    Here is a concrete example:

    > >>> m = hou.hmath.buildTranslate((1, 1, 2))
    > >>> m
    > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 2, 1]]>
    > >>> p = hou.Vector3(1, 2, 3)
    > >>> p * m
    > <hou.Vector3 [2, 3, 5]>

    Both VEX and the UT_DMatrix4 class in the Houdini Development Kit (HDK)
    also store matrices in row-major format.

    RELATED

      * hou.hmath

      * hou.Matrix3

      * hou.Quaternion

      * hou.Vector3

      * hou.Vector4


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values)

            Return a new Matrix4. You can pass no parameters (the result will
            contain all zeros), a float (the result's diagonal values will
            contain that float and the rest is all zeros), a sequence of 16
            floats, a sequence of sequences of 4 floats, or a hou.Matrix3.

          > >>> hou.Matrix4()
          > <hou.Matrix4 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]>
          >
          > >>> hou.Matrix4(1)
          > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]>
          >
          > >>> hou.Matrix4((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
          > <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>
          >
          > >>> hou.Matrix4(((0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11), (12, 13, 14, 15)))
          > <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>
          >
          > >>> matrix3 = hou.Matrix3((0, 1, 2, 3, 4, 5, 6, 7, 8))
          > >>> matrix3
          > <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>
          > >>> hou.Matrix4(matrix3)
          > <hou.Matrix4 [[0, 1, 2, 0], [3, 4, 5, 0], [6, 7, 8, 0], [0, 0, 0, 1]]>

            Note that Houdini's matrices are stored in row-major order, so the
            matrix's contents are grouped by row.


        """
        _hou.Matrix4_swiginit(self, _hou.new_Matrix4(*args))

    __swig_destroy__ = _hou.delete_Matrix4

    def __eq__(self, matrix4: "HOM_PtrOrNull< HOM_Matrix4 >") -> "bool":
        return _hou.Matrix4___eq__(self, matrix4)

    def __ne__(self, matrix4: "HOM_PtrOrNull< HOM_Matrix4 >") -> "bool":
        return _hou.Matrix4___ne__(self, matrix4)

    def isAlmostEqual(
        self, matrix4: "Matrix4", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, matrix4, tolerance=0.00001) -> bool

            Return whether this matrix is equal to another, within a tolerance.


        """
        return _hou.Matrix4_isAlmostEqual(self, matrix4, tolerance)

    def __hash__(self) -> "int":
        return _hou.Matrix4___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Matrix4___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Matrix4___repr__(self)

    def at(self, row: "int", col: "int") -> "double":
        r"""

        at(self, row, col) -> float

            Return the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 3,
            inclusive. Note that negative indices will not index from the end.


        """
        return _hou.Matrix4_at(self, row, col)

    def asTuple(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        asTuple(self) -> tuple of float

            Return the contents of the matrix as a tuple of 16 floats.


        """
        return _hou.Matrix4_asTuple(self)

    def asTupleOfTuples(
        self,
    ) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        r"""

        asTupleOfTuples(self) -> tuple of tuple of float

            Return the contents of the matrix as a tuple of tuples of 4 floats.


        """
        return _hou.Matrix4_asTupleOfTuples(self)

    def setAt(self, row: "int", col: "int", value: "double") -> "void":
        r"""

        setAt(self, row, col, value)

            Set the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 3,
            inclusive. Note that negative indices will not index from the end.


        """
        return _hou.Matrix4_setAt(self, row, col, value)

    def setTo(self, *args) -> "void":
        r"""

        setTo(self, sequence)

            Set this matrix's contents. The sequence may contain either 16
            floats or 4 sequences, each with 4 floats.

            See hou.Matrix4.__init__ for examples of suitable parameter values.


        """
        return _hou.Matrix4_setTo(self, *args)

    def setToIdentity(self) -> "void":
        r"""

        setToIdentity(self)

            Set this matrix to the multiplicative identity, having 1's in the
            diagonal.

            The matrix will contain the values [[1, 0, 0, 0], [0, 1, 0, 0], [0,
            0, 1, 0], [0, 0, 0, 1]]. Note that you can construct a new matrix
            with these values using hou.hmath.identityTransform or
            hou.Matrix4(1).


        """
        return _hou.Matrix4_setToIdentity(self)

    def setToZero(self) -> "void":
        r"""

        setToZero(self)

            Set this matrix to contain all zeros.

            Note that you can construct a new matrix with all zeros with
            hou.Matrix4().


        """
        return _hou.Matrix4_setToZero(self)

    def __add__(self, matrix4: "Matrix4") -> "HOM_Matrix4":
        r"""

        __add__(self, matrix4) -> hou.Matrix4

            Add two matrices by adding corresponding entries together and return
            a new matrix. This method lets you write m1 + m2, where m1 and m2
            are Matrix4 objects.


        """
        return _hou.Matrix4___add__(self, matrix4)

    def __sub__(self, matrix4: "Matrix4") -> "HOM_Matrix4":
        r"""

        __sub__(self, matrix4) -> hou.Matrix4

            Subtract another matrix from this one, subtracting corresponding
            entries, and return a new matrix. This method lets you write m1 -
            m2, where m1 and m2 are Matrix4 objects.


        """
        return _hou.Matrix4___sub__(self, matrix4)

    def __mul__(self, *args) -> "HOM_Matrix4":
        r"""

        __mul__(self, matrix4_or_scalar) -> hou.Matrix4

            Multiply this matrix by another matrix or by a scalar, returning a
            new matrix. This method lets you write m1 * m2, where m1 and m2 are
            Matrix4 objects, or m1 * s, where s is a float.

            If m1 and m2 are transformation matrices and v is a vector, v * m1 *
            m2 will transform v by m1, and then transform it by m2. This
            ordering occurs because Houdini's Matrices are stored in row-major
            format, and is opposite from the ordering used in traditional
            mathematical notation. Note that m1 * v is not a valid expression in
            Houdini

            See the Matrix4 class documentation and hou.Vector3.__mul__ for more
            information. See Wikipedia's matrix multiplication page for details
            on how each element in the result is computed.


        """
        return _hou.Matrix4___mul__(self, *args)

    def preMult(self, matrix4: "Matrix4") -> "HOM_Matrix4":
        r"""

        preMult(self, matrix4) -> hou.Matrix4

            Returns matrix4 * self. Note that __mul__ returns self * matrix4,
            which is a different result because matrix multiplication is not
            commutative.


        """
        return _hou.Matrix4_preMult(self, matrix4)

    def transposed(self) -> "HOM_Matrix4":
        r"""

        transposed(self) -> hou.Matrix4

            Return the transpose of this matrix. The result is such that
            self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 3.

            See Wikipedia's transpose page for more information.


        """
        return _hou.Matrix4_transposed(self)

    def inverted(self) -> "HOM_Matrix4":
        r"""

        inverted(self) -> hou.Matrix4

            Return the inverse of this matrix.

            Raises hou.OperationFailed if the matrix is not invertible.
            Otherwise, (self *
            self.inverted()).isAlmostEqual(hou.hmath.identityTransform()) is
            True.

            See Wikipedia's invertible matrix page for more information.


        """
        return _hou.Matrix4_inverted(self)

    def determinant(self) -> "double":
        r"""

        determinant(self) -> float

            Return the determinant of the matrix.

            See Wikipedia's determinant page.


        """
        return _hou.Matrix4_determinant(self)

    def explode(
        self, *args, **kwargs
    ) -> "std::map< std::string,HOM_Vector3,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_Vector3 > > >":
        r"""

        explode(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -> dict of str to
        hou.Vector3

            Return a dictionary with keys 'rotate', 'scale', 'translate', and
            'shear' whose values are hou.Vector3 objects. When applied in the
            specified order, the corresponding rotations, scales (and shears),
            and translations will give this matrix.

            The rotation is returned as a set of Euler angles, in degrees. See
            Wikipedia's Euler angles page for more information.


            transform_order
                A string containing a permutation of the letters s, r, and t.
                The rotate, scale, and translate results are dependent on the
                order in which you perform those operations, and this string
                specifies that order.

                For example, imagine a transformation where you first translate
                in x by one unit, then you rotate in z by 45 degrees. With a
                transform order of 'trs' (translate, rotate, scale), the
                translate component is (1, 0, 0). However, this same
                transformation could be constructed, for example, by first
                scaling, then rotating, and then translating. For this
                transformation order, the translate component would be (1.0 /
                math.sqrt(2), 1.0 / math.sqrt(2), 0).

            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.

            pivot
                A Vector3 containing a position about which rotations and scales
                are performed. By default, this parameter is set to the origin.

            pivot_rotate
                A Vector3 containing the Euler angles about the x, y, and z
                axes, in degrees, that specifies the base rotation about the
                pivot. These angles are always processed in 'xyz' order.

            Raises hou.OperationFailed if the matrix does not represent a valid
            transform matrix (e.g. it is singular), the transform order is not a
            permutation of the string 'srt', or the rotate order is not a
            permutation of the string 'xyz'.

            See hou.hmath.buildRotateAboutAxis for an example of how to convert
            Euler angles into an axis and rotation.

            See hou.ObjNode.setParmTransform for an example. This method is the
            inverse of hou.hmath.buildTransform. See also the other functions in
            hou.hmath that build transformation matrices.


        """
        return _hou.Matrix4_explode(self, *args, **kwargs)

    def extractTranslates(self, *args, **kwargs) -> "HOM_Vector3":
        r"""

        extractTranslates(self, transform_order='srt',
        pivot_rotate=hou.Vector3(), pivot=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, hou.Vector3(), pivot,
            pivot_rotate)['translate']. See hou.Matrix4.explode for more
            information.

          > >>> matrix = hou.hmath.buildTranslate(1, 0, 0) * hou.hmath.buildRotate(0, 0, 45)
          > >>> matrix.extractTranslates('trs')
          > <hou.Vector3 [4, 0, 0]>
          > >>> matrix.extractTranslates('srt')
          > <hou.Vector3 [0.707107, 0.707107, 0]>

        """
        return _hou.Matrix4_extractTranslates(self, *args, **kwargs)

    def extractRotates(self, *args, **kwargs) -> "HOM_Vector3":
        r"""

        extractRotates(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, rotate_order, pivot,
            pivot_rotate)['rotate']. See hou.Matrix4.explode for more
            information.


        """
        return _hou.Matrix4_extractRotates(self, *args, **kwargs)

    def extractScales(self, *args, **kwargs) -> "HOM_Vector3":
        r"""

        extractScales(self, transform_order='srt', pivot=hou.Vector3(),
        pivot_rotate=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, rotate_order, pivot,
            pivot_rotate)['scale']. See hou.Matrix4.explode for more
            information.


        """
        return _hou.Matrix4_extractScales(self, *args, **kwargs)

    def extractShears(self, *args, **kwargs) -> "HOM_Vector3":
        r"""

        extractShears(self, transform_order='srt', pivot=hou.Vector3(),
        pivot_rotate=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, rotate_order, pivot,
            pivot_rotate)['shear']. See hou.Matrix4.explode for more
            information.


        """
        return _hou.Matrix4_extractShears(self, *args, **kwargs)

    def extractRotationMatrix3(self) -> "HOM_Matrix3 *":
        r"""

        extractRotationMatrix3(self) -> hou.Matrix3

            Extracts the 3x3 rotation matrix from this matrix, assuming it is a
            transformation matrix. If it fails to extract the rotation, for
            example if scaling is zero on one axis, it returns the identity
            matrix instead.


        """
        return _hou.Matrix4_extractRotationMatrix3(self)

    def setToPerspective(
        self,
        zoom: "double",
        image_aspect: "double" = 1,
        pixel_aspect: "double" = 1,
        clip_near: "double" = 0,
        clip_far: "double" = 1,
        window_xmin: "double" = 0,
        window_xmax: "double" = 1,
        window_ymin: "double" = 0,
        window_ymax: "double" = 1,
    ) -> "void":
        r"""

        setToOrthographic(self, zoom, orthowidth=1, image_aspect=1,
        pixel_aspect=1, clip_near=0, clip_far=1, window_xmin=0, window_xmax=1,
        window_ymin=0, window_ymax=1)

            Set this matrix to an orthographic projection matrix with the given
            parameters.

            Sometimes the zoom is expressed in terms of focal and aperture. In
            this case: zoom = focal/aperture. Sometimes the image_aspect is
            expressed in terms of xres and yres. In this case: image_aspect =
            xres / yres.


        """
        return _hou.Matrix4_setToPerspective(
            self,
            zoom,
            image_aspect,
            pixel_aspect,
            clip_near,
            clip_far,
            window_xmin,
            window_xmax,
            window_ymin,
            window_ymax,
        )

    def setToOrthographic(
        self,
        zoom: "double",
        orthowidth: "double" = 1,
        image_aspect: "double" = 1,
        pixel_aspect: "double" = 1,
        clip_near: "double" = 0,
        clip_far: "double" = 1,
        window_xmin: "double" = 0,
        window_xmax: "double" = 1,
        window_ymin: "double" = 0,
        window_ymax: "double" = 1,
    ) -> "void":
        return _hou.Matrix4_setToOrthographic(
            self,
            zoom,
            orthowidth,
            image_aspect,
            pixel_aspect,
            clip_near,
            clip_far,
            window_xmin,
            window_xmax,
            window_ymin,
            window_ymax,
        )

    def _asVoidPointer(self) -> "void *":
        return _hou.Matrix4__asVoidPointer(self)


# Register Matrix4 in _hou:
_hou.Matrix4_swigregister(Matrix4)


class MenuParmTemplate(ParmTemplate):
    r"""

    hou.MenuParmTemplate

    Describes a menu parameter containing evaluating to integer values. Note
    that StringParmTemplates may also have menus.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, menu_items, menu_labels=(), default_value=0,
        icon_names=(), item_generator_script='',
        item_generator_script_language=None, disable_when=None,
        menu_type=hou.menuType.Normal, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=\"\",
        default_expression_language=hou.scriptLanguage.Hscript,
        store_default_value_as_string=False, menu_use_token=False,
        is_button_strip=False, strip_uses_icons=False)


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            menu_items
                See the menuItems method for more information.

            menu_labels
                See the menuLabels method for more information.

                If this parameter is not given, it defaults to the value of the
                menu_items parameter.

            default_value
                See the defaultValue method for more information.

            icon_names
                See the iconNames method for more information.

                If this parameter is an empty tuple, the menu will not contain
                icons.

            item_generator_script
                See the itemGeneratorScript method for more information.

            item_generator_script_language
                See the itemGeneratorScriptLanguage method for more information.
                If this parameter is None it defaults to
                hou.scriptLanguage.Python.

            menu_type
                See the menuType method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.

            store_default_value_as_string
                If set to True then the template stores the chosen default
                string instead of the default index in dialog scripts and other
                parameter formats internal to Houdini. menu_use_token: See the
                menuUseToken method for more information.

            is_button_strip
                See hou.ParmTemplate.isButtonStrip for more information.

            strip_uses_icons
                See hou.ParmTemplate.isIconStrip for more information.

            Note that MenuParmTemplates have only one component.


        """
        _hou.MenuParmTemplate_swiginit(self, _hou.new_MenuParmTemplate(*args, **kwargs))

    __swig_destroy__ = _hou.delete_MenuParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.MenuParmTemplate___repr__(self)

    def defaultValue(self) -> "int":
        r"""

        defaultValue(self) -> int

            Return the index of the default menu item.

            See also the defaultValueAsString method.


        """
        return _hou.MenuParmTemplate_defaultValue(self)

    def defaultValueAsString(self) -> "std::string":
        return _hou.MenuParmTemplate_defaultValueAsString(self)

    def setDefaultValue(self, default_value: "int") -> "void":
        r"""

        setDefaultValue(self, default_value)

            Set the index of the default menu item.

            Note that if this index is out of range of the menu item entries, it
            will be adjusted. If the menu is driven by a script, i.e. the
            itemGeneratorScript is set to a non-empty value, the default value
            is not adjusted.


        """
        return _hou.MenuParmTemplate_setDefaultValue(self, default_value)

    def defaultExpression(self) -> "std::string":
        r"""

        defaultExpression(self) -> string

            Return the expression, which when evaluated, returns the index of
            the default menu item.

            The default expression takes precedence over the default value. If
            the default expression is not set (i.e. an empty string), then the
            default value is used instead.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
        return _hou.MenuParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "std::string const &") -> "void":
        r"""

        setDefaultExpression(self, default_expression)

            Set the default expression, which when evaluated, returns the index
            of the default menu item.

            If default_expression is the empty string, then the default
            expression is unset.


        """
        return _hou.MenuParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(self) -> "HOM_EnumValue &":
        r"""

        defaultExpressionLanguage(self) -> hou.scriptLanguage

            Return the default expression language.

            The default expression language only applies if the default
            expression is set. If the default expression is not set, then the
            expression language is set to hou.scriptLanguage.Hscript.


        """
        return _hou.MenuParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "EnumValue"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language.

            See the defaultExpressionLanguage method for more information.


        """
        return _hou.MenuParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )

    def menuItems(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuItems(self) -> tuple of str

            Return the tuple of internal menu names.

            These internal menu names are not displayed in the UI, but they can
            be passed to hou.Parm.set and will be returned by
            hou.Parm.evalAsString for menu parameters.


        """
        return _hou.MenuParmTemplate_menuItems(self)

    def setMenuItems(self, menu_items: "_StringTuple") -> "void":
        r"""

        setMenuItems(self, menu_items)

            Set the internal menu names to the given sequence of strings.

            See the menuItems method for more information.

            If the new number of menu items is less than the old number, the
            menu labels will be shortened and the default value will be modified
            if it is out of range.


        """
        return _hou.MenuParmTemplate_setMenuItems(self, menu_items)

    def menuLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuLabels(self) -> tuple of str

            Return the tuple of menu labels displayed in the UI.


        """
        return _hou.MenuParmTemplate_menuLabels(self)

    def setMenuLabels(self, menu_labels: "_StringTuple") -> "void":
        r"""

        setMenuLabels(self, menu_labels)

            Set the menu labels displayed in the UI to the given sequence of
            strings.

            If the number of menu labels is less than the number of menu items,
            Houdini uses the internal menu item names for the missing labels. If
            the number of labels is more than the number of menu items, Houdini
            discards the extra labels.

            If you want to change both the menu items and menu labels, be sure
            to change the menu items first.


        """
        return _hou.MenuParmTemplate_setMenuLabels(self, menu_labels)

    def iconNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        iconNames(self) -> tuple of str

            Return the tuple of icons corresponding to the menu items. If there
            are no icons, returns a tuple of empty strings.


        """
        return _hou.MenuParmTemplate_iconNames(self)

    def setIconNames(self, icon_names: "_StringTuple") -> "void":
        r"""

        setIconNames(self, icon_names)

            Set the icon names to the given sequence of strings.


        """
        return _hou.MenuParmTemplate_setIconNames(self, icon_names)

    def itemGeneratorScript(self) -> "std::string":
        r"""

        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

            Return the programming language for the script that generates menu
            items.


        """
        return _hou.MenuParmTemplate_itemGeneratorScript(self)

    def setItemGeneratorScript(self, item_generator_script: "char const *") -> "void":
        r"""

        setItemGeneratorScript(self, item_generator_script)

            Set the script used to generate menu items.

            See the itemGeneratorScript method for more information.


        """
        return _hou.MenuParmTemplate_setItemGeneratorScript(self, item_generator_script)

    def itemGeneratorScriptLanguage(self) -> "HOM_EnumValue &":
        return _hou.MenuParmTemplate_itemGeneratorScriptLanguage(self)

    def setItemGeneratorScriptLanguage(self, language: "EnumValue") -> "void":
        r"""

        setItemGeneratorScriptLanguage(self, language)

            Set the script language used to generate menu items to a
            hou.scriptLanguage enum value.

            See the itemGeneratorScriptLanguage method for more information.


        """
        return _hou.MenuParmTemplate_setItemGeneratorScriptLanguage(self, language)

    def menuType(self) -> "HOM_EnumValue &":
        r"""

        menuType(self) -> hou.menuType enum value

            Return the type of menu. Note that some menu types only apply to
            string parameters with menus, so the meaningful menu types for
            MenuParmTemplates are hou.menuType.Normal (for standard menus) and
            hou.menuType.Mini for menus that only display a dropdown arrow. See
            hou.menuType for more information.


        """
        return _hou.MenuParmTemplate_menuType(self)

    def setMenuType(self, menu_type: "EnumValue") -> "void":
        r"""

        setMenuType(self, menu_type)

            Set the type of menu to a hou.menuType enum value.

            See the menuType method for more information.


        """
        return _hou.MenuParmTemplate_setMenuType(self, menu_type)

    def menuUseToken(self) -> "bool":
        r"""

        menuUseToken(self) -> bool

            Return whether the parameter is set to the token value instead of
            the index.

            See also the setMenuUseToken method.


        """
        return _hou.MenuParmTemplate_menuUseToken(self)

    def setMenuUseToken(self, menuusetoken: "bool") -> "void":
        r"""

        setMenuUseToken(self, on)

            Set whether the parameter is set to the token value instead of the
            index.

            See also the menuUseToken method.


        """
        return _hou.MenuParmTemplate_setMenuUseToken(self, menuusetoken)

    def isButtonStrip(self) -> "bool":
        r"""

        isButtonStrip(self) -> bool

            Return whether the parameter is set to use the button strip widget.


        """
        return _hou.MenuParmTemplate_isButtonStrip(self)

    def isIconStrip(self) -> "bool":
        r"""

        isIconStrip(self) -> bool

            Return whether the parameter is set to use the icon strip widget.


        """
        return _hou.MenuParmTemplate_isIconStrip(self)

    def isMenu(self) -> "bool":
        r"""

        isMenu(self) -> bool

            Return whether the parameter is set to use the drop down menu
            widget.


        """
        return _hou.MenuParmTemplate_isMenu(self)

    def setAsButtonStrip(self) -> "void":
        r"""

        setAsButtonStrip(self)

            Set the parameter to use a Button Strip widget.

            See also the setAsMenu, setAsIconStrip methods.


        """
        return _hou.MenuParmTemplate_setAsButtonStrip(self)

    def setAsIconStrip(self) -> "void":
        r"""

        setAsIconStrip(self)

            Set the parameter to use a Icon Strip widget.

            See also the setAsMenu, setAsButtonStrip methods.


        """
        return _hou.MenuParmTemplate_setAsIconStrip(self)

    def setAsMenu(self) -> "void":
        r"""

        setAsMenu(self)

            Turn back the parameter to a default menu drop down.

            See also the setAsButtonStrip, setAsIconStrip methods.


        """
        return _hou.MenuParmTemplate_setAsMenu(self)


# Register MenuParmTemplate in _hou:
_hou.MenuParmTemplate_swigregister(MenuParmTemplate)


class NetworkDot(IndirectInput):
    r"""

    hou.NetworkDot

    A small dot in a network that allows wires to be routed along specific
    paths without affecting the data passing through them.

    Network dots are allowed to have a single input, but may have many
    outputs. They can be moved around to force a wire connecting two nodes
    to follow a specific path. They can also be used as scaffolding for a
    set of nodes that you want to be able to quickly add or remove in a
    larger network.

    New dots are created by calling hou.Node.createNetworkDot on the node
    that will contain the dot. A list of all existing dots in a network can
    be generated by calling hou.Node.networkDots.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NetworkDot

    def __repr__(self) -> "std::string":
        return _hou.NetworkDot___repr__(self)

    def __hash__(self) -> "int":
        return _hou.NetworkDot___hash__(self)

    def __eq__(self, dot: "HOM_PtrOrNull< HOM_NetworkDot >") -> "bool":
        return _hou.NetworkDot___eq__(self, dot)

    def __ne__(self, dot: "HOM_PtrOrNull< HOM_NetworkDot >") -> "bool":
        return _hou.NetworkDot___ne__(self, dot)

    def isPinned(self) -> "bool":
        r"""

        isPinned(self) -> bool

            Returns the pinned state of this dot. See hou.NetworkDot.setPinned
            for a more detailed discussion of the meaning of a pinned dot.


        """
        return _hou.NetworkDot_isPinned(self)

    def setPinned(self, pinned: "bool") -> "void":
        r"""

        setPinned(self, pinned)

            Sets the boolean pinned state of this dot. Pinned dots are not
            functionally different from unpinned dots, but are treated
            differently by the network editor. A pinned dot remains even if its
            input and output connections are removed. An unpinned dot will be
            deleted automatically by the network editor if its input or last
            output is cut.

            The following code is a greatly simplified version of the code for
            automatically deleting unconnected dots, which will delete any dots
            that are not pinned and that don't have an input connection:

          > >>> net = hou.node('/obj')
          > >>> net.createNetworkDot().setPinned(False)
          > >>> net.createNetworkDot().setPinned(True)
          > >>> net.networkDots()
          > (<hou.NetworkDot dot1 in /obj>, <hou.NetworkDot dot2 in /obj>)
          > >>> for dot in net.networkDots():
          > ...   if not dot.isPinned():
          > ...     if dot.inputItem() is None:
          > ...       dot.destroy()
          > ...
          > >>> net.networkDots()
          > (<hou.NetworkDot dot2 in /obj>,)

        """
        return _hou.NetworkDot_setPinned(self, pinned)

    def setInput(self, *args) -> "void":
        r"""

        setInput(self, input_index, item_to_become_input, output_index=0)

            Connects a network item to the input of this dot, exactly like the
            two parameter form of this function. But this second signature
            matches the signature of hou.Node.setInput, which allows code to run
            on either a network dot or a node. The value of the input_index is
            ignored.


        """
        return _hou.NetworkDot_setInput(self, *args)

    def inputConnections(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > >":
        r"""

        inputConnections(self) -> tuple of hou.NodeConnection

            Returns a tuple of hou.NodeConnection objects for the connection
            coming into this dot. The tuple will have a length of one if
            anything is connected to the input of this dot. Returns an empty
            tuple if nothing is connected.


        """
        return _hou.NetworkDot_inputConnections(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Delete this dot. Connections in and out of the dot are automatically
            re-established such that the behavior of the network will be
            unchanged by the removal of this dot.


        """
        return _hou.NetworkDot_destroy(self)


# Register NetworkDot in _hou:
_hou.NetworkDot_swigregister(NetworkDot)


class NetworkEditor(PathBasedPaneTab):
    r"""

    hou.NetworkEditor

    Represents a Network Editor panetab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NetworkEditor

    def __repr__(self) -> "std::string":
        return _hou.NetworkEditor___repr__(self)

    def isShowingConnectors(self) -> "bool":
        r"""

        isShowingConnectors(self) -> bool

            Return True if the network editor zoom level is high enough that
            input and output connectors are visible. This can be useful in
            network editor event handlers that expect the user to click on a
            connector. If the connectors are not visible, some alternative
            interaction is required.


        """
        return _hou.NetworkEditor_isShowingConnectors(self)

    def isUnderCursor(self) -> "bool":
        return _hou.NetworkEditor_isUnderCursor(self)

    def isPosInside(
        self, pos: "Vector2", ignore_floating_windows: "bool" = True
    ) -> "bool":
        r"""

        isPosInside(self, pos, ignore_floating_windows=True) -> bool

            Return True if the hou.Vector2 passed as the pos parameter is inside
            the network view. The values in pos are mouse coordinates expressed
            relative to the network editor pane.


            ignore_floating_windows
                When set to True, isPosInside will ignore any windows floating
                over the network view at the given position and will return True
                as long as the position is inside the network view area. When
                set to False, isPosInside will additionally check for floating
                windows and will return True if the position is inside the
                network view and if no other window is on top of the network
                view at the given position.


        """
        return _hou.NetworkEditor_isPosInside(self, pos, ignore_floating_windows)

    def setCursorPosition(self, pos: "Vector2") -> "void":
        r"""

        setCursorPosition(self, pos)

            Moves the mouse cursor to the position specified by the hou.Vector2
            pos parameter.


        """
        return _hou.NetworkEditor_setCursorPosition(self, pos)

    def cursorPosition(self, confine_to_view: "bool" = True) -> "HOM_Vector2":
        r"""

        cursorPosition(self, confine_to_view=True) -> hou.Vector2

            Return the current mouse cursor position expressed in network view
            coordinates. If confine_to_view is True, the returned value will be
            clipped to the area of the network currently visible in the network
            editor.

            Here is an example of moving a node underneath the mouse cursor:

          > # Get the network editor.
          > net_editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          >
          > # Get the node.
          > node = hou.node(\"/obj/myNode\")
          >
          > # Set the node's new position.
          > node.setPosition(net_editor.cursorPosition())

        """
        return _hou.NetworkEditor_cursorPosition(self, confine_to_view)

    def screenBounds(self) -> "HOM_BoundingRect":
        r"""

        screenBounds(self) -> hou.BoundingRect

            Return the screen space bounds of the network editor viewing area.
            This does not include the menu bar, toolbar, or other UI elements.
            Only the area where the network contents are displayed is returned.
            The bounds are relative to the network area itself, so the lower
            left corner of the returned bounding box will always be (0, 0).


        """
        return _hou.NetworkEditor_screenBounds(self)

    def visibleBounds(self) -> "HOM_BoundingRect":
        r"""

        visibleBounds(self) -> hou.BoundingRect

            Return the network space bounds of the network editor viewing area.


        """
        return _hou.NetworkEditor_visibleBounds(self)

    def setVisibleBounds(
        self,
        bounds: "BoundingRect",
        transition_time: "float" = 0.0,
        max_scale: "float" = 0.0,
        set_center_when_scale_rejected: "bool" = False,
    ) -> "void":
        r"""

        setVisibleBounds(self, bounds, transition_time=0.0, max_scale=0.0,
        set_center_when_scale_rejected=False)

            Sets the visible bounds of the network editor viewing area,
            expressed in network space coordinates. This method will never alter
            the screen space size or location of the network editor. If the area
            specified by the bounds parameter has a different aspect ratio from
            the actual network editor, this method will automatically adjust the
            bounds to ensure that the area specified is fully visible.


            bounds
                A hou.BoundingRect specifying the area that should be visible in
                the network editor.

            transition_time
                The amount of time, in seconds, over which the network editor
                will animate the transition from the current visible bounds to
                the new visible bounds.

            max_scale
                If set to a non-zero value, this parameter controls the maximum
                zoom level that will be allowed. The default maximum scale used
                by the network editor code is 100.

            set_centered_when_scale_rejected
                If set to True, but the new zoom level is determined to be the
                same as the previous zoom, no change is made to the bounds at
                all. This prevents a bounds change, that was intended as a pure
                zoom, from inadvertently panning the view if the zoom doesn't
                actually change.


        """
        return _hou.NetworkEditor_setVisibleBounds(
            self, bounds, transition_time, max_scale, set_center_when_scale_rejected
        )

    def setLocatingEnabled(self, enabled: "bool") -> "void":
        r"""

        setLocatingEnabled(self, enabled)

            Enables or disables highlighting of UI elements under the mouse in
            the network editor. When disabled, mouse events sent to the network
            editor event processing code will never specify a located or
            selected UI element. In some modes (such as when in a viewing state
            where mouse events only modify the view) it is desirable to disable
            this behavior.


        """
        return _hou.NetworkEditor_setLocatingEnabled(self, enabled)

    def locatingEnabled(self) -> "bool":
        r"""

        locatingEnabled(self) -> bool

            Return True if the network editor will highlight UI elements under
            the mouse, and allow clicking on those UI elements.


        """
        return _hou.NetworkEditor_locatingEnabled(self)

    def lengthToScreen(self, len: "float") -> "float":
        r"""

        lengthToScreen(self, len) -> float

            Given a length value len, expressed in network units, return the
            equivalent length in screen units (pixels). The result will depend
            on the current zoom level of the network editor.


        """
        return _hou.NetworkEditor_lengthToScreen(self, len)

    def lengthFromScreen(self, len: "float") -> "float":
        r"""

        lengthFromScreen(self, len) -> float

            Given a length value len, expressed in screen units (pixels), return
            the equivalent length in network units. The result will depend on
            the current zoom level of the network editor.


        """
        return _hou.NetworkEditor_lengthFromScreen(self, len)

    def sizeToScreen(self, size: "Vector2") -> "HOM_Vector2":
        r"""

        sizeToScreen(self, size) -> hou.Vector2

            Given a box size value size as a hou.Vector2, expressed in network
            units, return the equivalent size in screen units (pixels). This is
            equivalent to making two separate calls to lengthToScreen() for the
            width and height. The result will depend on the current zoom level
            of the network editor.


        """
        return _hou.NetworkEditor_sizeToScreen(self, size)

    def sizeFromScreen(self, size: "Vector2") -> "HOM_Vector2":
        r"""

        sizeFromScreen(self, size) -> hou.Vector2

            Given a box size value size as a hou.Vector2, expressed in screen
            units (pixels), return the equivalent size in network units. This is
            equivalent to making two separate calls to lengthFromScreen() for
            the width and height. The result will depend on the current zoom
            level of the network editor.


        """
        return _hou.NetworkEditor_sizeFromScreen(self, size)

    def posToScreen(self, pos: "Vector2") -> "HOM_Vector2":
        r"""

        posToScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in network
            units, return the equivalent position in screen units (pixels). The
            result will depend on both the current zoom level and view position
            of the network editor.


        """
        return _hou.NetworkEditor_posToScreen(self, pos)

    def posFromScreen(self, pos: "Vector2") -> "HOM_Vector2":
        r"""

        posFromScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in screen
            units (pixels), return the equivalent position in network units. The
            result will depend on both the current zoom level and view position
            of the network editor.


        """
        return _hou.NetworkEditor_posFromScreen(self, pos)

    def overviewPosToScreen(self, pos: "Vector2") -> "HOM_Vector2":
        r"""

        overviewPosToScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in network
            units, return the equivalent position in screen units (pixels)
            within the overview gadget in the network editor. This method
            returns a value that assumes the overview area is visible, even if
            it is not.


        """
        return _hou.NetworkEditor_overviewPosToScreen(self, pos)

    def overviewPosFromScreen(self, pos: "Vector2") -> "HOM_Vector2":
        r"""

        overviewPosFromScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in screen
            units (pixels) within the overview gadget, return the equivalent
            position in network units. This method returns a value that assumes
            the overview area is visible, even if it is not. If the provided
            position is outside the overview area, this method returns a value
            that assumes the overview gadget extends as far as required to reach
            the specified coordinates.


        """
        return _hou.NetworkEditor_overviewPosFromScreen(self, pos)

    def overviewVisible(self) -> "bool":
        r"""

        overviewVisible(self) -> bool

            Return a boolean indicating whether or not the overview gadget is
            currently visible. This result reflects the true state of the
            overview gadget even if the overview is configured to display
            automatically.


        """
        return _hou.NetworkEditor_overviewVisible(self)

    def overviewVisibleIfAutomatic(self) -> "bool":
        r"""

        overviewVisibleIfAutomatic(self) -> bool

            Return a boolean indicating whether or not the overview gadget would
            currently be visible if it was configured to display automatically.
            In other words, this method returns True if any part of the network
            is currently outside the visible bounds of the editor.


        """
        return _hou.NetworkEditor_overviewVisibleIfAutomatic(self)

    def networkItemsInBox(
        self,
        pos1: "Vector2",
        pos2: "Vector2",
        for_drop: "bool" = False,
        for_select: "bool" = False,
    ) -> "std::vector< UT_Tuple< HOM_ElemPtr< HOM_NetworkItem >,std::string,int >,std::allocator< UT_Tuple< HOM_ElemPtr< HOM_NetworkItem >,std::string,int > > >":
        r"""

        networkItemsInBox(self, pos1, pos2, for_drop=False, for_select=False) ->
        tuple of (hou.NetworkItem, str, int)

            Return any network items inside the bounding box defined by the
            hou.Vector2 points pos1 and pos2. These points are specified in
            screen space, which makes it easy to call this function given a
            mouse position.

            The returned tuple of triples are sorted in increasing distance from
            the center of the specified bounding box. Each triple consists of a
            network item (which may be a node, sticky note, wire, etc.), a
            string which describes the part of the UI for that item that was
            found in the box, and an optional index value which differentiates
            between different instances of the same item/name combination. For
            example, if the connector for input 2 of the node geo1 was the only
            thing inside the provided box, the return value would be:

          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> editor.networkItemsInBox(pos1, pos2)
          > ((<hou.ObjNode of type subnet at /obj/subnet1>, 'input', 2),)

            One of for_drop or for_select may be set to True to use a different
            criteria for deciding what a valid target is. By default, any UI
            widget that highlights with the mouse over it will be returned by
            this method. Setting for_drop to True will return only UI widgets
            that can be drop targets. Setting for_select to True will only
            return UI widgets that result in the item being selected when box
            picking.


        """
        return _hou.NetworkEditor_networkItemsInBox(
            self, pos1, pos2, for_drop, for_select
        )

    def setDropTargetItem(
        self, item: "NetworkItem", name: "char const *", index: "int"
    ) -> "void":
        r"""

        setDropTargetItem(self, item, name, index)

            When the user is performing a drag and drop operation within the
            network editor, it is important that they receive some feedback
            about where the thing they are dragging will be dropped if they let
            go of the mouse button. This indication is provided by highlighting
            the drop target in the UI. This method allows the current drop
            target to be specified in python code. Usually the item, name, and
            index will be values returned in one of the tuples from the
            networkItemsInBox method.


        """
        return _hou.NetworkEditor_setDropTargetItem(self, item, name, index)

    def dropTargetItem(
        self,
    ) -> "UT_Tuple< HOM_ElemPtr< HOM_NetworkItem >,std::string,int >":
        r"""

        dropTargetItem(self) -> (hou.NetworkItem, str, int)

            Return the currently set drop target item information. These are
            just the values passed into the last call to setDropTargetItem.


        """
        return _hou.NetworkEditor_dropTargetItem(self)

    def setDecoratedItem(self, item: "NetworkItem", interactive: "bool") -> "void":
        r"""

        setDecoratedItem(self, item, interactive)

            This method is similar to setDropTargetItem in that it tells the
            network editor to highlight a particular item when drawing it. In
            the case of the decorated item, however, only the network item needs
            to be provided. The result of setting a node as the decorated item
            is to bring up the node ring. Network dots may also be the decorated
            item, in which case the input and output connectors for the dot are
            shown. The interactive boolean flag indicates whether the user is
            allowed to interact with the decorations. If not, the node ring is
            drawn faded, and its buttons cannot be clicked. This non-interactive
            mode corresponds to having the Control key pressed while moving the
            mouse around the network editor.


        """
        return _hou.NetworkEditor_setDecoratedItem(self, item, interactive)

    def decoratedItem(self) -> "HOM_NetworkItem *":
        r"""

        decoratedItem(self) -> hou.NetworkItem

            Return the currently set decorated item. This is just the item value
            passed into the last call to setDecoratedItem.


        """
        return _hou.NetworkEditor_decoratedItem(self)

    def decorationInteractive(self) -> "bool":
        r"""

        decorationInteractive(self) -> bool

            Return whether the currently decorated item is interactive. This is
            just the interactive value passed into the last call to
            setDecoratedItem.


        """
        return _hou.NetworkEditor_decorationInteractive(self)

    def setPreSelectedItems(
        self,
        items: "std::vector< HOM_NetworkItem *,std::allocator< HOM_NetworkItem * > > const &",
    ) -> "void":
        r"""

        setPreSelectedItems(self, items)

            When box selecting items in the network, it is useful to be able to
            see what will be selected if the mouse button is released. These
            items are drawn to the overlay layer of the network editor canvas in
            a light blue color with transparency. The network items passed as a
            tuple to this method are the ones that get drawn with this pre-
            selection highlight.


        """
        return _hou.NetworkEditor_setPreSelectedItems(self, items)

    def preSelectedItems(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkItem >,std::allocator< HOM_ElemPtr< HOM_NetworkItem > > >":
        r"""

        preSelectedItems(self) -> tuple of hou.NetworkItem

            Return the currently pre-selected items. These are just the values
            passed into the last call to setPreSelectedItems.


        """
        return _hou.NetworkEditor_preSelectedItems(self)

    def setNetworkBoxPendingRemovals(self, items: "_NetworkMovableItemTuple") -> "void":
        r"""

        setNetworkBoxPendingRemovals(self, items)

            When moving items around the network, network boxes automatically
            resize to contain their child items as they move. To indicate that
            items will be removed from their network box, pass them as a tuple
            to this method. Doing so will cause their network box containers to
            not resize to fit the items as they move.


        """
        return _hou.NetworkEditor_setNetworkBoxPendingRemovals(self, items)

    def networkBoxPendingRemovals(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
        r"""

        networkBoxPendingRemovals(self) -> tuple of hou.NetworkMovableItem

            Return the items currently pending remove from their network box.
            These are just the values passed into the last call to
            setNetworkBoxPendingRemovals.


        """
        return _hou.NetworkEditor_networkBoxPendingRemovals(self)

    def setFootprints(
        self,
        footprints: "std::vector< HOM_NetworkFootprint,std::allocator< HOM_NetworkFootprint > > const &",
    ) -> "void":
        r"""

        setFootprints(self, footprints)

            Configure the footprint rings that the network editor should
            display. The footprints parameter must be a tuple of
            hou.NetworkFootprint objects. See that class for more information.


        """
        return _hou.NetworkEditor_setFootprints(self, footprints)

    def footprints(
        self,
    ) -> "std::vector< HOM_NetworkFootprint,std::allocator< HOM_NetworkFootprint > >":
        r"""

        footprints(self) -> tuple of hou.NetworkFootprint

            Return the current footprint configuration as a tuple of
            hou.NetworkFootprint objects. These are just the values passed into
            the last call to setFootprints.


        """
        return _hou.NetworkEditor_footprints(self)

    def setCursorMap(
        self,
        cursors: "std::map< std::pair< std::string,int >,std::string,std::less< std::pair< std::string,int > >,std::allocator< std::pair< std::pair< std::string,int > const,std::string > > >",
    ) -> "void":
        r"""

        setCursorMap(self, cursors)

            Tells the network editor which mouse cursor to use based on what UI
            widget is under the mouse. This configuration is specified as a
            dictionary mapping a tuple to a string. The string is the name of
            the cursor, which can be any of the cursor file names from the
            $HFS/houdini/config/Cursors directory. Each tuple consists of a
            string and an integer. The string is the name of the UI widget, and
            the integer represents the specific index value within that UI
            widget.

            The following code sets the network editor to show a connect cursor
            for all node inputs and outputs:

          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> editor.setCursorMap({
          > ... ('input', -1): 'wire',
          > ... ('output', -1): 'wire'
          > ... })

            The following code sets the network editor to show an appropriate
            resize icon based on the specific section of the sticky note border
            under the mouse:

          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> editor.setCursorMap({
          > ... ('stickynoteborder', 0): 'arrowSWNE',
          > ... ('stickynoteborder', 1): 'arrowLeftRight',
          > ... ('stickynoteborder', 2): 'arrowNWSE',
          > ... ('stickynoteborder', 3): 'arrowUpDown',
          > ... ('stickynoteborder', 4): 'arrowSWNE',
          > ... ('stickynoteborder', 5): 'arrowLeftRight',
          > ... ('stickynoteborder', 6): 'arrowNWSE',
          > ... ('stickynoteborder', 7): 'arrowUpDown'
          > ... })

        """
        return _hou.NetworkEditor_setCursorMap(self, cursors)

    def cursorMap(
        self,
    ) -> "std::map< std::pair< std::string,int >,std::string,std::less< std::pair< std::string,int > >,std::allocator< std::pair< std::pair< std::string,int > const,std::string > > >":
        r"""

        cursorMap(self) -> dict of (str, int) to str

            Return the current mouse cursor configuration. This will just be the
            dictionary passed into the last call to setCursorMap.


        """
        return _hou.NetworkEditor_cursorMap(self)

    def setDefaultCursor(self, cursor_name: "char const *") -> "void":
        r"""

        setDefaultCursor(self, cursor_name)

            Tells the network editor which mouse cursor to use when none of the
            UI mentioned in the dictionary sent to setCursorMap() is under the
            mouse.


        """
        return _hou.NetworkEditor_setDefaultCursor(self, cursor_name)

    def defaultCursor(self) -> "std::string":
        r"""

        defaultCursor(self) -> str

            Return the default mouse cursor set by the last call to
            setDefaultCursor().


        """
        return _hou.NetworkEditor_defaultCursor(self)

    def setBackgroundImages(
        self,
        images: "std::vector< HOM_NetworkImage,std::allocator< HOM_NetworkImage > > const &",
    ) -> "void":
        r"""

        setBackgroundImages(self, images)

            Configures the background images to be displayed in the network
            editor. The network editor saves and loads the image descriptions
            into the user data for each network, which allows a different set of
            background images for each network. The images are specified as a
            tuple of hou.NetworkImage objects. See the documentation of that
            class for more information.


        """
        return _hou.NetworkEditor_setBackgroundImages(self, images)

    def backgroundImages(
        self,
    ) -> "std::vector< HOM_NetworkImage,std::allocator< HOM_NetworkImage > >":
        r"""

        backgroundImages(self) -> tuple of hou.NetworkImage

            Return the descriptors for the current set of background images
            being displayed in the network editor. This will be the tuple passed
            into the last call to setBackgroundImages.


        """
        return _hou.NetworkEditor_backgroundImages(self)

    def itemRect(
        self, item: "NetworkMovableItem", adjusted: "bool" = True
    ) -> "HOM_BoundingRect":
        r"""

        itemRect(self, item, adjusted=True) -> hou.BoundingRect

            Return the bounding rectangle of the hou.NetworkMovableItem
            specified by the item parameter. If the adjusted parameter is set to
            True, any adjustments to this item's size and position set in the
            most recent call to setAdjustments() will be taken into account. If
            False, these adjustments will be ignored. Note that for nodes, only
            the node body is taken into account, not the node name, badges, or
            other decorations.


        """
        return _hou.NetworkEditor_itemRect(self, item, adjusted)

    def itemInputPos(
        self, item: "NetworkMovableItem", input_index: "int", adjusted: "bool" = True
    ) -> "HOM_Vector2":
        r"""

        itemInputPos(self, item, input_index, adjusted=True) -> hou.Vector2

            Return the center point of the input connector of the hou.Node or
            hou.NetworkDot specified by item. The input_index parameter
            specifies the specific input of interest. For network dots, this
            value must be zero. If the adjusted parameter is set to True, any
            adjustments to this item's size and position set in the most recent
            call to setAdjustments() will be taken into account. If False, these
            adjustments will be ignored.


        """
        return _hou.NetworkEditor_itemInputPos(self, item, input_index, adjusted)

    def itemInputDir(
        self, item: "NetworkMovableItem", input_index: "int"
    ) -> "HOM_Vector2":
        r"""

        itemInputDir(self, item, input_index) -> hou.Vector2

            Return a normalized vector indicating the direction at which the
            wire connected to the specified input should emerge from its
            connector. The item parameter may be a hou.Node or hou.NetworkDot.
            The input_index specifies which input is of interest. This value
            must be zero if the item is a network dot.


        """
        return _hou.NetworkEditor_itemInputDir(self, item, input_index)

    def itemOutputPos(
        self, item: "NetworkMovableItem", output_index: "int", adjusted: "bool" = True
    ) -> "HOM_Vector2":
        r"""

        itemOutputPos(self, item, output_index, adjusted=True) -> hou.Vector2

            Return the center point of the output connector of the hou.Node,
            hou.NetworkDot, or hou.SubnetIndirectInput specified by item. The
            output_index parameter specifies the specific output of interest.
            For network dots and subnet indirect inputs, this value must be
            zero. If the adjusted parameter is set to True, any adjustments to
            this item's size and position set in the most recent call to
            setAdjustments() will be taken into account. If False, these
            adjustments will be ignored.


        """
        return _hou.NetworkEditor_itemOutputPos(self, item, output_index, adjusted)

    def itemOutputDir(
        self, item: "NetworkMovableItem", output_index: "int"
    ) -> "HOM_Vector2":
        r"""

        itemOutputDir(self, item, output_index) -> hou.Vector2

            Return a normalized vector indicating the direction at which the
            wire connected to the specified output should emerge from its
            connector. The item parameter may be a hou.Node, hou.NetworkDot, or
            hou.SubnetIndirectInput. The output_index specifies which output is
            of interest. This value must be zero if the item is a network dot or
            subnet indirect input.


        """
        return _hou.NetworkEditor_itemOutputDir(self, item, output_index)

    def allVisibleRects(
        self, ignore_items: "_NetworkMovableItemTuple", adjusted: "bool" = True
    ) -> "std::vector< std::pair< HOM_ElemPtr< HOM_NetworkMovableItem >,HOM_BoundingRect >,std::allocator< std::pair< HOM_ElemPtr< HOM_NetworkMovableItem >,HOM_BoundingRect > > >":
        r"""

        allVisibleRects(self, ignore_items) -> tuple of (hou.NetworkMovableItem,
        hou.BoundingRect)

            This method is equivalent to calling itemRect() for every network
            item that is currently visible in the network editor. Getting these
            results in a single method call is significantly faster, and
            eliminates the need to test each item for visibility. This method is
            used for finding items to snap against when moving nodes. The
            ignore_items parameter is a tuple of hou.NetworkMovableItem objects
            that should not be returned in the result tuple.


        """
        return _hou.NetworkEditor_allVisibleRects(self, ignore_items, adjusted)

    def setAdjustments(
        self,
        items: "std::vector< HOM_NetworkItem *,std::allocator< HOM_NetworkItem * > > const &",
        adjustments: "std::vector< HOM_NetworkAnimValue,std::allocator< HOM_NetworkAnimValue > > const &",
        auto_remove: "bool" = False,
    ) -> "void":
        r"""

        setAdjustments(self, items, adjustments, auto_remove=False)

            Configures temporary adjustments to the sizes and locations of
            network items in the editor. The items parameter is a tuple of
            hou.NetworkMovableItem objects. The adjustments parameter is a tuple
            of hou.NetworkAnimValue objects to associate with each network item
            in the items tuple. See the documentation of that class for more
            information about specifying adjustments.

            The auto_remove parameter may be set to True to indicate that the
            network editor should automatically delete the adjustments once the
            animation on them has completed. This is useful for animations
            performed at the end of a user action, where the following events do
            not relate to the changes being made, and so it is easier not to
            have to manage the reset of the adjustment values explicitly in the
            future.


        """
        return _hou.NetworkEditor_setAdjustments(self, items, adjustments, auto_remove)

    def setShapes(
        self,
        shapes: "std::vector< HOM_NetworkShape *,std::allocator< HOM_NetworkShape * > > const &",
    ) -> "void":
        r"""

        setShapes(self, shapes)

            The shapes parameter specifies a tuple of hou.NetworkShape objects
            which will be drawn into the network editor. See documentation of
            the network shape class and its subclasses for more information.


        """
        return _hou.NetworkEditor_setShapes(self, shapes)

    def setOverlayShapes(
        self,
        shapes: "std::vector< HOM_NetworkShape *,std::allocator< HOM_NetworkShape * > > const &",
    ) -> "void":
        r"""

        setOverlayShapes(self, shapes)

            The shapes parameter specifies a tuple of hou.NetworkShape objects
            which will be drawn into the overlay layer of the network editor
            canvas. See documentation of the network shape class and its
            subclasses for more information.


        """
        return _hou.NetworkEditor_setOverlayShapes(self, shapes)

    def setTooltip(self, tooltip: "char const *") -> "void":
        r"""

        setTooltip(self, tooltip)

            Sets the tooltip string that should be shown under the mouse if it
            remains stationary for a short time. This string should generally be
            set to correspond to the network item currently under the mouse
            cursor. Because it appears after a delay, it is okay to make this
            text more verbose than the prompt text passed to setPromptText().


        """
        return _hou.NetworkEditor_setTooltip(self, tooltip)

    def tooltip(self) -> "std::string":
        r"""

        tooltip(self) -> str

            Return the current tooltip string. This is the value that was last
            passed to the setTooltip() method.


        """
        return _hou.NetworkEditor_tooltip(self)

    def setPrompt(self, prompt: "char const *") -> "void":
        r"""

        setPrompt(self, prompt)

            Sets the prompt text that appears at the bottom of the network
            editor. This string should generally be set to correspond to the
            network item currently under the mouse cursor. This text should be
            fairly brief. More detailed information can be put into the tooltip
            through the setTooltip() method.


        """
        return _hou.NetworkEditor_setPrompt(self, prompt)

    def prompt(self) -> "std::string":
        r"""

        prompt(self) -> str

            Return the current prompt string. This is the value that was last
            passed to the setPromptText() method.


        """
        return _hou.NetworkEditor_prompt(self)

    def flashMessage(
        self, image: "char const *", message: "char const *", duration: "float"
    ) -> "void":
        r"""

        flashMessage(self, image, message, duration)

            Causes a message to appear briefly in the upper left corner of the
            network editor, then fade away. The image parameter specifies an
            icon or image file that should be displayed along with the text
            specified in the message parameter. Either of these parameters may
            be None if only an image or only text is desired. The duration
            parameter specifies the time in seconds before the message should
            fade away.


        """
        return _hou.NetworkEditor_flashMessage(self, image, message, duration)

    def openTabMenu(self, *args, **kwargs) -> "void":
        r"""

        openTabMenu(self, key=None, auto_place=False, branch=False,
        src_item=None, src_connector_index=-1, dest_item=None,
        dest_connector_index=-1, node_position=None, src_items=[],
        src_indexes=[], dest_items=[], dest_indexes=[])

            Opens the tab menu in the network editor. When the user chooses a
            tool from the tab menu, the parameters passed to this function
            determine the context information that will be sent to the tool
            script. Generally, most tools treat these parameters in a consistent
            way as described below.


            key
                The key used (if any) to open the menu. This same key pressed
                with the menu up will cause the menu to close.

            auto_place
                Set to True to make the tab menu turn on auto placement when a
                tool is chosen from the menu. The new node will be placed at a
                position determined automatically by the tab menu based on the
                source and destination nodes.

            branch
                Set to True to cause the new node to create a new branch instead
                of inserting the new node between the source and destination
                nodes.

            src_item
                The node, dot, or subnet indirect input that will be connected
                to the input of the new node created by the tab menu.

            src_item_connector_index
                The output index of the node that will be connected to the input
                of the new node created by the tab menu.

            dest_item
                The node or dot that will be connected to the output of the new
                node created by the tab menu.

            dest_connector_index
                The input index of the node or dot that will be connected to the
                output of the new node created by the tab menu.

            node_position
                The location to use for the new node created by the tab menu.

            src_items
                A list of nodes, dot, or subnet indirect inputs that will be
                connected to the input of the new node created by the tab menu.
                This parameter (and all other list-based source and destination
                paramaters) take precedence over the single item parameters if
                both are specified.

            src_item_connector_indexes
                A list of output indexes of the nodes that will be connected to
                the input of the new node created by the tab menu.

            dest_items
                A list of nodes or dots that will be connected to the output of
                the new node created by the tab menu.

            dest_connector_indexes
                A list of input indexes of the nodes or dots that will be
                connected to the output of the new node created by the tab menu.


        """
        return _hou.NetworkEditor_openTabMenu(self, *args, **kwargs)

    def openNodeMenu(self, *args, **kwargs) -> "void":
        r"""

        openNodeMenu(self, node = None, items = [])

            Brings up a node context menu under the current mouse position. The
            two parameters contol which node(s) will be affected by the menu
            option chosen by the user. If a hou.Node object is specified in the
            node parameter, the menu operation will affect that node, and, if
            that node is currently selected, all other selected network items
            will also be affected. If the items parameter is passed a non-empty
            list of hou.NetworkMovableItem objects, those items and only those
            items will be affected by the menu, regardless of the current
            selection.

            If the chosen menu item only operates on a single node, the original
            node parameter value or the last hou.Node object in the items list
            will be affected. If the selected menu item can affect multiple
            nodes, all nodes will be affected. And in the few cases where
            network items other than nodes may be altered by a menu item, all
            items (nodes or otherwise) will be affected.


        """
        return _hou.NetworkEditor_openNodeMenu(self, *args, **kwargs)

    def openVopEffectsMenu(self, node: "VopNode", input_index: "int") -> "void":
        r"""

        openVopEffectsMenu(self, node, input_index)

            Brings up the VOP node effects menu for the hou.VopNode specified in
            the node parameter, at the input specified by the input_index
            parameter.


        """
        return _hou.NetworkEditor_openVopEffectsMenu(self, node, input_index)

    def openVopOutputInfoMenu(self, node: "VopNode", output_index: "int") -> "void":
        r"""

        openVopOutputInfoMenu(self, node, output_index)

            Brings up the VOP node output info menu for the hou.VopNode
            specified in the node parameter, at the output specified by the
            output_index parameter. This menu is used to control the behavior of
            the VOP node when the Debug or Bypass flags are enabled.


        """
        return _hou.NetworkEditor_openVopOutputInfoMenu(self, node, output_index)

    def openNameEditor(
        self, item: "NetworkMovableItem", select_all: "bool" = False
    ) -> "int":
        r"""

        openNameEditor(self, item, select_all = False) -> int

            Opens an input field for editing the name of the node specified in
            the item parameter. Returns an integer id which is passed to the
            network editor as part of an event indicating when the user finishes
            editing the text.

            If select_all is set to True, the editor is opened with all text
            selected.


        """
        return _hou.NetworkEditor_openNameEditor(self, item, select_all)

    def openCommentEditor(
        self, item: "NetworkMovableItem", select_all: "bool" = False
    ) -> "int":
        r"""

        openCommentEditor(self, item, select_all = False) -> int

            Opens an input field for editing the comment of the network box
            specified in the item parameter. Returns an integer id which is
            passed to the network editor as part of an event indicating when the
            user finishes editing the text.

            If select_all is set to True, the editor is opened with all text
            selected.


        """
        return _hou.NetworkEditor_openCommentEditor(self, item, select_all)

    def openNoteEditor(
        self, stickynote: "StickyNote", select_all: "bool" = False
    ) -> "int":
        r"""

        openNoteEditor(self, stickynote, select_all = False) -> int

            Opens an input field for editing the text of the sticky note
            specified in the stickynote parameter. Returns an integer id which
            is passed to the network editor as part of an event indicating when
            the user finishes editing the text.

            If select_all is set to True, the editor is opened with all text
            selected.


        """
        return _hou.NetworkEditor_openNoteEditor(self, stickynote, select_all)

    def closeTextEditor(self, id: "int", apply_changes: "bool" = True) -> "void":
        r"""

        closeTextEditor(self, id, apply_changes = True)

            Immediately closes and commits any changes made to input fields
            opened with the openNameEditor(), openCommentEditor(), or
            openNoteEditor() methods. The id parameter is the value returned by
            the method that opened the editor. Set the apply_changes parameter
            to False if the changes made to the input field should not be
            applied.


        """
        return _hou.NetworkEditor_closeTextEditor(self, id, apply_changes)

    def runShelfTool(self, tool_name: "char const *") -> "void":
        r"""

        runShelfTool(self, tool_name)

            Run the named shelf tool in the network editor.


        """
        return _hou.NetworkEditor_runShelfTool(self, tool_name)

    def scheduleTimerEvent(self, seconds: "float") -> "int":
        r"""

        scheduleTimerEvent(self, seconds) -> int

            Requests that a timer event be sent to the network editor after
            seconds has elapsed. The returned integer id is included in the
            triggered event to differentiate between timers if more than one is
            scheduled at a time.


        """
        return _hou.NetworkEditor_scheduleTimerEvent(self, seconds)

    def handleCurrentKeyboardEvent(self, resend: "bool" = False) -> "void":
        r"""

        handleCurrentKeyboardEvent(self, resend=False)

            Requests that the network editor handle the current keyboard event.
            This method only makes sense when handling a keyboard event.

            If the resend parameter is set to True, the keyboard event is sent
            to the network editor's python handling code a second time rather
            than the network editor handling the keyboard event itself. This is
            useful if the network editor is in a state or mode that does not
            know how to handle a key, but which the state recognizes as one that
            should exit the current state, and possibly trigger some other
            python event handling code. This parameter is used in the state for
            selecting the position of a new node if the Tab key is pressed
            (which exits the positions selection state, and triggers a new Tab
            menu instead).

            If this method is not called when handling a keyboard event, the
            network editor assumes that the python event handling code has
            handled the keyboard event.


        """
        return _hou.NetworkEditor_handleCurrentKeyboardEvent(self, resend)

    def setVolatileKeys(self, keys: "_StringTuple") -> "void":
        r"""

        setVolatileKeys(self, keys)

            The keys parameter specifies a tuple of keyboard keys that should be
            processed as volatile keys. This means they generate a \"keydown\"
            event when the key is pressed, and a \"keyup\" event when the key is
            released. All other keys simply send a \"keyhit\" event after the key
            is released, with no notification when the key is first pressed. The
            key strings are of the form returned by the hou.ui.hotkeys method,
            which is a combination of the symbol on the key, and any modifier
            keys involved, such as \"Ctrl+Shift+G\".


        """
        return _hou.NetworkEditor_setVolatileKeys(self, keys)

    def isVolatileKeyDown(self, key: "char const *") -> "bool":
        r"""

        isVolatileKeyDown(self, key) -> bool

            Return True if the specified keyboard key is currently pressed. This
            allows the current state of a volatile key to be tested without
            seeing the \"keydown\" event triggered when the user pressed the key.
            Calling this method with a key that has not been registered through
            the setVolatileKeys method will always return False even if the key
            is currently pressed. The key string is of the form returned by the
            hou.ui.hotkeys method, which is a combination of the symbol on the
            key, and any modifier keys involved, such as \"Ctrl+Shift+G\".


        """
        return _hou.NetworkEditor_isVolatileKeyDown(self, key)

    def setPref(self, pref: "char const *", value: "char const *") -> "void":
        r"""

        setPref(self, pref, value)

            Sets the preference named pref to value. The value is always a
            string, and must be converted to or from a number, enum, or other
            format as appropriate. If the preference specified by pref is a
            global preference, all network editors will automatically update
            with the new value. Otherwise the change will only affect this
            network editor.


        """
        return _hou.NetworkEditor_setPref(self, pref, value)

    def getPref(self, pref: "char const *") -> "std::string":
        r"""

        getPref(self, pref) -> str

            Return the value of the preference named pref. This preference may
            be a global or local preference. The returned value is always a
            string which can be interpreted as a number or other data structure
            as appropriate for the specific preference.


        """
        return _hou.NetworkEditor_getPref(self, pref)

    def setPrefs(
        self,
        prefs: "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const &",
    ) -> "void":
        r"""

        setPrefs(self, prefs)

            Sets a number of preference values with a single method call. The
            prefs parameter must be a python dictionary mapping preference name
            strings to value strings. The preferences may be local or global,
            but this method is most often used for saving and loading the local
            preferences for a single network editor.


        """
        return _hou.NetworkEditor_setPrefs(self, prefs)

    def getPrefs(
        self,
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        getPrefs(self) -> dict of str to str

            Return all global and local preferences for this network editor as a
            python dictionary mapping preference name strings to value strings.


        """
        return _hou.NetworkEditor_getPrefs(self)

    def registerPref(
        self, pref: "char const *", value: "char const *", _global: "bool"
    ) -> "void":
        r"""

        registerPref(self, pref, value, global)

            Registers a preference with the name pref, and default value value.
            If global is True, this preference is treated as a global preference
            that is applied to all network editors and saved in
            $HOUDINI_USER_PREF_DIR/networkeditor.pref. Otherwise the preference
            is considered local to each network editor, and will be saved to the
            desk file with each network editor instance.

            Registering a preference is required to ensure the preference is
            saved when it is not a preference used internally by the network
            editor. The preference that enables snapping, or the one to enable
            dropping a node onto an existing wire are examples of preferences
            that are only used by the python event handling code, and so must be
            explicitly registered. This registration should be done in response
            to the network editor initialization event which is sent once to
            each network editor when it is first created.


        """
        return _hou.NetworkEditor_registerPref(self, pref, value, _global)

    def badges(
        self,
    ) -> "std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > >":
        r"""

        badges(self) -> tuple of tuple of str

            Return descriptions of the optional node badges that can be shown in
            the network editor. Each tuple contained in the returned value
            contains three strings describing the badge. The first is the
            preference value that controls whether the badge is hidden, or
            appears as a small or large icon. The second string is a description
            of the badge. The third string is the name of the badge icon. These
            values can be used to present an interface for configuring the
            badges.


        """
        return _hou.NetworkEditor_badges(self)

    def textBadges(
        self,
    ) -> "std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > >":
        r"""

        textBadges(self) -> tuple of tuple of str

            Return descriptions of the optional node text that can be shown in
            the network editor. Each tuple contained in the returned value
            contains three strings describing the text. The first is the
            preference value that controls whether the text is hidden, or
            appears as truncated or full text. The second string is a
            description of the text. The third string is the name of an icon
            that can be used to represent the meaning of the text. These values
            can be used to present an interface for configuring the text.


        """
        return _hou.NetworkEditor_textBadges(self)

    def nodeShapes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        nodeShapes(self) -> tuple of str

            Return a list of all valid node shape names. These are the values
            that can be set into the user data of a node to control the shape of
            a specific node. They are also the shape names that can be used as
            defaults for node types.

            This code sets a node to a random shape:

          > >>> import random
          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> shapes = editor.nodeShapes()
          > >>> hou.node('/obj/geo1').setUserData('nodeshape', random.choice(shapes))

        """
        return _hou.NetworkEditor_nodeShapes(self)

    def reloadNodeShapes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        reloadNodeShapes(self) -> tuple of str

            Forces all node shape files to be reloaded. This may cause new
            shapes to become available, or existing shapes to be removed.
            Returns a tuple of strings that indicate the name of each loaded
            node shape, and any error messages generated while parsing each
            shape. Use nodeShapes() to get a simple list of all successfully
            loaded shapes after calling this method.


        """
        return _hou.NetworkEditor_reloadNodeShapes(self)

    def redraw(self) -> "void":
        r"""

        redraw(self)

            Forces the network editor to redraw. This may be necessary in cases
            where your code updates aspects of your Houdini session which
            indirectly affect the drawing of the network editor (such as
            changing default node shapes and colors). Direct changes to the
            network (such as changing the shape or color of a specific node)
            should automatically cause the network editor to redraw. Only use
            this function when you see that a redraw is not being triggered
            automatically by the your code.


        """
        return _hou.NetworkEditor_redraw(self)

    def setDragSourceData(self, items: "_NetworkMovableItemTuple") -> "void":
        r"""

        setDragSourceData(self, items)

            Controls the network items that are put into the drag and drop
            buffer. The values in this buffer are only used when dragging items
            out of the network editor (such as when the user drags a node from
            the network editor onto a textport, or a parameter dialog.


        """
        return _hou.NetworkEditor_setDragSourceData(self, items)

    def setDragSourceWorkItem(self, item_id: "int") -> "void":
        r"""

        setDragSourceWorkItem(self, work_item_id)

            Controls the Id of the pdg.WorkItem that is stored into the drag and
            drop buffer. The work item ID in the buffer is used when when
            dragging an item from a TOP node into a textport, Python shell, etc.


        """
        return _hou.NetworkEditor_setDragSourceWorkItem(self, item_id)

    def popEventContext(self) -> "void":
        return _hou.NetworkEditor_popEventContext(self)

    def parmScrollPosition(self) -> "HOM_Vector2":
        r"""

        parmScrollPosition(self) -> hou.Vector2

            Return the Parameter Editor scroll bars position as percentages.


        """
        return _hou.NetworkEditor_parmScrollPosition(self)

    def setParmScrollPosition(self, position: "Vector2") -> "void":
        r"""

        setParmScrollPosition(self,pos)

            Set Parameter Editor scroll bars position as hou.Vector2
            percentages.


        """
        return _hou.NetworkEditor_setParmScrollPosition(self, position)

    def setParmFilterEnabled(self, on: "bool") -> "void":
        r"""

        setParmFilterEnabled(self,on)

            Enable Parameter Editor filtering. hou.parmFilterCriteria.


        """
        return _hou.NetworkEditor_setParmFilterEnabled(self, on)

    def parmFilterEnabled(self) -> "bool":
        r"""

        parmFilterEnabled(self) -> bool

            Return True if Parameter Editor filtering is enabled.


        """
        return _hou.NetworkEditor_parmFilterEnabled(self)

    def setParmFilterExactMatch(self, on: "bool") -> "void":
        r"""

        setParmFilterExactMatch(self,on)

            Set Parameter Editor filtering to use exact pattern matching.


        """
        return _hou.NetworkEditor_setParmFilterExactMatch(self, on)

    def parmFilterExactMatch(self) -> "bool":
        r"""

        parmFilterExactMatch(self) -> bool

            Return True if Parameter Editor filtering uses exact pattern
            matching.


        """
        return _hou.NetworkEditor_parmFilterExactMatch(self)

    def setParmFilterPattern(self, filter: "char const *") -> "void":
        r"""

        setParmFilterPattern(self,pattern)

            Set the Parameter Editor filter pattern. The filter pattern is
            applied on a hou.parmFilterCriteria string from parameters that
            match the hou.parmFilterMode. The pattern matching can use exact
            name matching or find the pattern within the string. The filter
            pattern can be a list of pattern separated by commas and can also
            contain wildcard '*' character.


        """
        return _hou.NetworkEditor_setParmFilterPattern(self, filter)

    def parmFilterPattern(self) -> "std::string":
        r"""

        parmFilterPattern(self) -> str

            Return the Parameter Editor filter pattern.


        """
        return _hou.NetworkEditor_parmFilterPattern(self)

    def setParmFilterMode(self, *args) -> "void":
        r"""

        setParmFilterMode(self,mode)

            Set the Parameter Editor filter mode. The hou.parmFilterMode defines
            on which parameters to apply the filter pattern.


        """
        return _hou.NetworkEditor_setParmFilterMode(self, *args)

    def parmFilterMode(self) -> "HOM_EnumValue &":
        r"""

        parmFilterMode(self) -> hou.parmFilterMode

            Return the Parameter Editor hou.parmFilterMode.


        """
        return _hou.NetworkEditor_parmFilterMode(self)

    def setParmFilterCriteria(self, *args) -> "void":
        r"""

        setParmFilterCriteria(self,criteria)

            Set the Parameter Editor filter criteria. The hou.parmFilterCriteria
            defines how the filter pattern is applied to parameters.


        """
        return _hou.NetworkEditor_setParmFilterCriteria(self, *args)

    def parmFilterCriteria(self) -> "HOM_EnumValue &":
        r"""

        parmFilterCriteria(self) -> hou.parmFilterCriteria

            Return the Parameter Editor hou.parmFilterCriteria.


        """
        return _hou.NetworkEditor_parmFilterCriteria(self)

    def _scrollToParms(self, parms: "char const *") -> "void":
        return _hou.NetworkEditor__scrollToParms(self, parms)

    def _filterParms(self, parms: "char const *") -> "void":
        return _hou.NetworkEditor__filterParms(self, parms)

    def pushEventContext(
        self, module: "char const *", data: "InterpreterObject"
    ) -> "bool":
        r"""

        eventContextData(self) -> dict

            Accesses the context data passed into the most recent call to the
            hou.NetworkEditor.pushEventContext method. If no calls have been
            made to this method, there is still a python dict available to store
            any global information that may be used by the network editor event
            handling code. As an example, the current view bounds for each
            network visited by the editor are stored as part of this context
            data dictionary.


        """
        return _hou.NetworkEditor_pushEventContext(self, module, data)

    def eventContextData(self) -> "InterpreterObject":
        return _hou.NetworkEditor_eventContextData(self)


# Register NetworkEditor in _hou:
_hou.NetworkEditor_swigregister(NetworkEditor)


class NetworkAnimValue(object):
    r"""

    hou.NetworkAnimValue

    A value to adjust the appearance of a network editor without changing
    the underlying node data.

    The hou.NetworkEditor pane allows network items to be moved or resized
    by user interactions without actually changing the node positions or
    sizes. This is accomplished by associating each NetworkAnimValue with a
    network item through the hou.NetworkEditor.setAdjustments method.
    NetworkAnimValues can either represent a single value, or they can
    represent an animation from one value to another. The actual animation
    is displayed automatically by the network editor.

    For example, to following code would animate the position of a couple of
    nodes:

    > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > >>> n1 = hou.node('/obj/geo1')
    > >>> pos1 = n1.position()
    > >>> newpos1 = pos1 + hou.Vector2(5, 5)
    > >>> anim1 = hou.NetworkAnimValue(1.0, pos1, newpos1)
    > >>> n2 = hou.node('/obj/geo2')
    > >>> pos2 = n2.position()
    > >>> newpos2 = pos2 + hou.Vector2(5, 5)
    > >>> anim2 = hou.NetworkAnimValue(1.0, pos2, newpos2)
    > >>> editor.setAdjustments([n1, n2], [anim1, anim2], auto_remove=True)
    > >>> n1.setPosition(newpos1)
    > >>> n2.setPosition(newpos2)

    Note that the new positions are set on the nodes immediately. But the
    animation starts them at their original positions, and makes it look
    like they move slowly to their new positions. Also note that the
    auto_remove parameter in the call to setAdjustments() has been set to
    True. This is because we are using the adjustments only to animate the
    nodes to their new positions, which have already been set. Once the
    animation is complete, the adjustments can be thrown away. Without this
    parameter, the adjustments would remain on the network editor until the
    next call the setAdjustments.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, duration, value_start, value_end)

            Construct a new adjustment value that does change over time. The
            value can be a float, hou.Vector2, hou.Vector3, or hou.Vector4. To
            animate a node or other item's position, use a hou.Vector2 value. To
            animate a size and position (such as for a hou.NetworkBox) use a
            hou.Vector4, where the values within the vector are
            hou.Vector4(x_position, y_position, width, height).

            The duration value is expressed in the number of seconds to get from
            the value_start to value_end. The values are interpolated linearly
            over time. The values provided are absolute values, not offsets.


        """
        _hou.NetworkAnimValue_swiginit(self, _hou.new_NetworkAnimValue(*args))

    __swig_destroy__ = _hou.delete_NetworkAnimValue

    def __repr__(self) -> "std::string":
        return _hou.NetworkAnimValue___repr__(self)

    def __eq__(self, item: "HOM_PtrOrNull< HOM_NetworkAnimValue >") -> "bool":
        return _hou.NetworkAnimValue___eq__(self, item)

    def __ne__(self, item: "HOM_PtrOrNull< HOM_NetworkAnimValue >") -> "bool":
        return _hou.NetworkAnimValue___ne__(self, item)


# Register NetworkAnimValue in _hou:
_hou.NetworkAnimValue_swigregister(NetworkAnimValue)


class NetworkFootprint(object):
    r"""

    hou.NetworkFootprint

    Describes the conditions under which a footprint ring should be
    displayed for a node in a network editor pane.

    A footprint in the network editor is a ring drawn behind the node in the
    network editor, such as the blue display flag ring around the wave1 node
    and the orange output flag ring around the wave2 node:


    This class describes to the network editor which nodes should be drawn
    with a footprint, and the color and position of that footprint. A tuple
    of these objects is passed to the hou.NetworkEditor.setFootprints
    method. This tuple should be updated every time the current network
    changes to a new node type category.

    The default footprint setup for SOP nodes is the following:

    > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > >>> editor.setFootprints([
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Display,
    >             hou.ui.colorFromName('GraphDisplayHighlight'), 1, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Render,
    >             hou.ui.colorFromName('GraphRenderHighlight'), 0, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Template,
    >             hou.ui.colorFromName('GraphTemplateHighlight'), 2, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Footprint,
    >             hou.ui.colorFromName('GraphTemplateHighlight'), 2, True
    >         ),
    >         hou.NetworkFootprint(
    >             'output',
    >             hou.ui.colorFromName('GraphOutputHighlight'), 1, True
    >         )
    >     ])

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, condition, color, ring, use_minimum_size)

            Construct a new footprint descriptor.


            condition
                Can be a hou.nodeFlag enum value, in which case any node with
                this flag set will be drawn with a footprint. Alternatively, a
                hou.nodeFootprint enum value, indicating an embedded network
                editor behavior that can be enabled to support the footprinting
                of node(s) according to a hard-coded rule set. Finally, a string
                value indicates a node type name, in which case any node of this
                type will be drawn with a footprint.

            color
                The color used to draw the ring expressed as a hou.Color.

            ring
                An integer value from 0 to 4 indicating which ring is being
                described. Ring 0 is a circle that extends from the center of
                the node. Each subsequent ring is thinner and further from the
                center of the node.

            use_minimum_size
                A boolean value. Set to True to indicate that the footprint
                should maintain a minimum visual size regardless of the network
                zoom level. Set to False if the footprint should scale with the
                network zoom level, even if that means the footprint becomes
                very small.


        """
        _hou.NetworkFootprint_swiginit(self, _hou.new_NetworkFootprint(*args))

    __swig_destroy__ = _hou.delete_NetworkFootprint

    def __repr__(self) -> "std::string":
        return _hou.NetworkFootprint___repr__(self)


# Register NetworkFootprint in _hou:
_hou.NetworkFootprint_swigregister(NetworkFootprint)


class NetworkImage(object):
    r"""

    hou.NetworkImage

    Describes a background image that can be displayed in a network editor
    pane.

    The network editor pane can display any number of images in the
    background behind the nodes of the network. These background images are
    described using this class, and set in the network editor using the
    hou.NetworkEditor.setBackgroundImages method.

    This code sets a single background image in the network editor:

    >
    > editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > image = hou.NetworkImage()
    > image.setPath('$HFS/houdini/pic/Mandril.pic')
    > image.setRect(hou.BoundingRect(0, 0, 5, 5))
    > editor.setBackgroundImages([image])

    The network editor pane provides a mode for creating and editing
    background images directly in the pane. The resulting image layout is
    saved into the user data for the current network so that the image
    arrangement is automatically saved and restored with the hip file.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, path, rect)

            Construct a new image descriptor. The path parameter is a string
            containing the path to the image file. The rect parameter is a
            hou.BoundingRect that specifies the location and size for drawing
            the image in the network.


        """
        _hou.NetworkImage_swiginit(self, _hou.new_NetworkImage(*args))

    __swig_destroy__ = _hou.delete_NetworkImage

    def __eq__(self, image: "HOM_PtrOrNull< HOM_NetworkImage >") -> "bool":
        return _hou.NetworkImage___eq__(self, image)

    def __ne__(self, image: "HOM_PtrOrNull< HOM_NetworkImage >") -> "bool":
        return _hou.NetworkImage___ne__(self, image)

    def __hash__(self) -> "int":
        return _hou.NetworkImage___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.NetworkImage___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.NetworkImage___repr__(self)

    def setPath(self, path: "char const *") -> "void":
        r"""

        setPath(self, path)

            Sets the path to the image file.


        """
        return _hou.NetworkImage_setPath(self, path)

    def path(self) -> "std::string":
        r"""

        path(self) -> str

            Return the path to the image file.


        """
        return _hou.NetworkImage_path(self)

    def setRelativeToPath(self, path: "char const *") -> "void":
        r"""

        setRelativeToPath(self, path)

            Images can be tied to network items such as nodes, network boxes, or
            sticky notes. This method sets the path to the network item to which
            this image is tied. Passing in an empty string indicates the
            location is not relative to any network item.


        """
        return _hou.NetworkImage_setRelativeToPath(self, path)

    def relativeToPath(self) -> "std::string":
        r"""

        relativeToPath(self) -> str

            Images can be tied to network items such as nodes, network boxes, or
            sticky notes. This method returns the path to the network item to
            which this image is tied (or an empty string if its location is not
            relative to any network item).


        """
        return _hou.NetworkImage_relativeToPath(self)

    def setRect(self, rect: "BoundingRect") -> "void":
        r"""

        setRect(self, rect)

            Sets the bounding rectangle that defines the size and position of
            the image within the network. If the relativeToPath() value is set,
            then the rectangle will be translated by the position of the network
            item to which this image is tied.


        """
        return _hou.NetworkImage_setRect(self, rect)

    def rect(self) -> "HOM_BoundingRect":
        r"""

        rect(self) -> hou.BoundingRect

            Returns the bounding rectangle that defines the size and position of
            the image within the network. If the relativeToPath() value is set,
            then the rectangle is translated by the position of the network item
            to which this image is tied.


        """
        return _hou.NetworkImage_rect(self)

    def setBrightness(self, brightness: "double") -> "void":
        r"""

        setBrightness(self, brightness)

            Sets the brightness adjustment for displaying this image in the
            network editor. This value should range from 0 to 1. Values less
            than 1 cause the image to be blended with the background of the
            network editor. An image with a brightness of 0 will appear as the
            background color, not black as is normally indicated by a brightness
            value of 0.


        """
        return _hou.NetworkImage_setBrightness(self, brightness)

    def brightness(self) -> "double":
        r"""

        brightness(self) -> float

            Return the brightness adjustment for displaying this image in the
            network editor. This value should range from 0 to 1. Values less
            than 1 cause the image to be blended with the background of the
            network editor. An image with a brightness of 0 will appear as the
            background color, not black as is normally indicated by a brightness
            value of 0.


        """
        return _hou.NetworkImage_brightness(self)


# Register NetworkImage in _hou:
_hou.NetworkImage_swigregister(NetworkImage)


class NetworkShape(object):
    r"""

    hou.NetworkShape

    The base class for extra shapes that can be drawn into a network editor.

    The network editor pane can be instructed to draw additional shapes to
    either the main canvas, or to the overlay area of the pane (drawn on top
    of the actual network). Each element that is drawn is described as a
    subclass of this NetworkShape base class, then passed to the network
    editor through either the hou.NetworkEditor.setShapes or
    hou.NetworkEditor.setOverlayShapes methods.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NetworkShape

    def __repr__(self) -> "std::string":
        return _hou.NetworkShape___repr__(self)


# Register NetworkShape in _hou:
_hou.NetworkShape_swigregister(NetworkShape)


class NetworkShapeLine(NetworkShape):
    r"""

    hou.NetworkShapeLine

    Describes a line that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a line that can be drawn
    into a network editor pane.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, start, end, color = hou.Color((1.0, 1.0, 1.0)), alpha =
        1.0, width = 1.0, screen_space = True, smooth = True, dashed = False)

            Constructs a new line descriptor.


            start
                A hou.Vector2 indicating the starting point of the line. May be
                in screen space or network units depending on the value of the
                screen_space parameter.

            end
                A hou.Vector2 indicating the ending point of the line. May be in
                screen space or network units depending on the value of the
                screen_space parameter.

            color
                The color of the line, expressed as a hou.Color.

            alpha
                The alpha used when drawing the line, expressed as a float value
                between 0 and 1.

            width
                A float value indicating the width of the line. This value is
                always expressed in pixels, regardless of the value of the
                screen_space parameter.

            screen_space
                A boolean value indicating whether the start and end parameters
                are expressed in screen space or network layout space. If set to
                True, the positions are expressed as pixels relative to the
                lower left corner of the pane. If False, the positions are
                expressed in network units.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line.

            dashed
                A boolean value indicating whether lines should be drawn as a
                series of dashes rather than as solid lines.


        """
        _hou.NetworkShapeLine_swiginit(self, _hou.new_NetworkShapeLine(*args, **kwargs))

    def __repr__(self) -> "std::string":
        return _hou.NetworkShapeLine___repr__(self)

    __swig_destroy__ = _hou.delete_NetworkShapeLine


# Register NetworkShapeLine in _hou:
_hou.NetworkShapeLine_swigregister(NetworkShapeLine)


class NetworkShapeBox(NetworkShape):
    r"""

    hou.NetworkShapeBox

    Describes a rectangular area that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a rectangle that can be
    drawn into a network editor pane.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, rect, color = hou.Color((1.0, 1.0, 1.0)), alpha = 1.0,
        fill = True, screen_space = True, smooth = True)

            Constructs a new box shape descriptor.


            rect
                A hou.BoundingRect object which describes the size and position
                of the box. It may describe the box in screen space or in the
                network layout space, depending on the value of the screen_space
                parameter. This is the only required parameter.

            color
                The color of the box, expressed as a hou.Color.

            alpha
                The alpha used when drawing the box, expressed as a float value
                between 0 and 1.

            fill
                A boolean value indicating whether the box should be filled, or
                just drawn as an outline.

            screen_space
                A boolean value indicating whether the rect parameter describes
                the box size and position in screen space or network layout
                space. If set to True, the rectangle is expressed as pixels
                relative to the lower left corner of the pane. If False, the
                rectangle is expressed in network units.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line. This parameter has no effect if fill is
                True.


        """
        _hou.NetworkShapeBox_swiginit(self, _hou.new_NetworkShapeBox(*args, **kwargs))

    def __repr__(self) -> "std::string":
        return _hou.NetworkShapeBox___repr__(self)

    __swig_destroy__ = _hou.delete_NetworkShapeBox


# Register NetworkShapeBox in _hou:
_hou.NetworkShapeBox_swigregister(NetworkShapeBox)


class NetworkShapeNodeShape(NetworkShape):
    r"""

    hou.NetworkShapeNodeShape

    Describes a node shape that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a node shape that can be
    drawn into a network editor pane. This can draw any of the node shapes
    available to the nodes in the network through the Shape Palette.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, rect, shape, color = hou.Color((1.0, 1.0, 1.0)), alpha =
        1.0, fill = True, screen_space = True, smooth = True)

            Constructs a new node shape descriptor.


            rect
                A hou.BoundingRect object which describes the size and position
                of the box. It may describe the box in screen space or in the
                network layout space, depending on the value of the screen_space
                parameter. This is the only required parameter.

            shape
                A string holding the name of the node shape to draw. The list of
                available node shapes can be retrieved with the
                hou.NetworkEditor.nodeShapes method.

            color
                The color of the node shape, expressed as a hou.Color.

            alpha
                The alpha used when drawing the node shape, expressed as a float
                value between 0 and 1.

            fill
                A boolean value indicating whether the node shape should be
                filled, or just drawn as an outline.

            screen_space
                A boolean value indicating whether the rect parameter describes
                the node shape size and position in screen space or network
                layout space. If set to True, the bounds are expressed as pixels
                relative to the lower left corner of the pane. If False, the
                bounds are expressed in network units.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line. This parameter has no effect if fill is
                True.


        """
        _hou.NetworkShapeNodeShape_swiginit(
            self, _hou.new_NetworkShapeNodeShape(*args, **kwargs)
        )

    def __repr__(self) -> "std::string":
        return _hou.NetworkShapeNodeShape___repr__(self)

    __swig_destroy__ = _hou.delete_NetworkShapeNodeShape


# Register NetworkShapeNodeShape in _hou:
_hou.NetworkShapeNodeShape_swigregister(NetworkShapeNodeShape)


class NetworkShapeConnection(NetworkShape):
    r"""

    hou.NetworkShapeConnection

    Describes a wire that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a wire that can be drawn
    into a network editor pane. This wire is drawn using the same wire style
    set on the current network.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, input_pos, input_dir, output_pos, output_dir, color =
        hou.Color((1.0, 1.0, 1.0)), alpha = 1.0, fade_factor = 0.0, smooth =
        True, dashed = False)

            Constructs a new connection descriptor. This is different from a
            hou.NetworkShapeLine because it is drawn using the same algorithm as
            a wire connecting two nodes, rather than always using a straight
            line.


            input_pos
                A hou.Vector2 indicating the starting point of the connection,
                expressed in network coordinates.

            input_dir
                A hou.Vector2 expressing the starting direction of the wire.

            output_pos
                A hou.Vector2 indicating the end point of the connection,
                expressed in network coordinates.

            output_dir
                A hou.Vector2 expressing the ending direction of the wire.

            color
                The color of the connection, expressed as a hou.Color.

            alpha
                The alpha used when drawing the connection, expressed as a float
                value between 0 and 1.

            fade_factor
                A float value indicating the amount of fading that should be
                applied to this connection if it exceeds the fade length. By
                setting this value to 0.0, all fading logic is disabled.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line.

            dashed
                A boolean value indicating whether lines should be drawn as a
                series of dashes rather than as solid lines.


        """
        _hou.NetworkShapeConnection_swiginit(
            self, _hou.new_NetworkShapeConnection(*args, **kwargs)
        )

    def __repr__(self) -> "std::string":
        return _hou.NetworkShapeConnection___repr__(self)

    __swig_destroy__ = _hou.delete_NetworkShapeConnection


# Register NetworkShapeConnection in _hou:
_hou.NetworkShapeConnection_swigregister(NetworkShapeConnection)


class Bundle(object):
    r"""

    hou.NodeBundle

    A named set of nodes whose contents can be from different networks. A
    bundle's contents may be fixed or may be determined from a pattern, and
    the contents may be filtered by node type.

    Unlike node groups, the nodes in a bundle may be from different node
    networks. For example, the same bundle may contain /obj/geo1 and
    /obj/subnet1/geo2. Node groups are primarily used to organize and
    display very large networks, while node bundles are normally used to
    track which objects are lit by a light, which objects are visible in a
    scene, etc.

    There are two types of node bundles: regular and smart. You can add and
    remove individual nodes to and from a regular bundle. The nodes in a
    smart bundle, on the other hand, are determined from a pattern stored in
    the bundle. As nodes matching the pattern are created or deleted in
    Houdini, the contents of the bundle will update automatically. You can
    use hou.NodeBundle.pattern to determine if the bundle is a smart bundle
    or a regular one.

    When a node matches the pattern in a smart bundle, that node and its
    children will be added to the bundle. For example, if the pattern in
    \"/obj/*\" and /obj/box_object1 is a geometry object, all the nodes inside
    /obj/box_object1 will be added to the bundle, recursively. Carets (^) in
    the pattern can be used to remove nodes; for example, \"/obj/*
    ^/obj/geo1\" will match everything in /obj except for /obj/geo1.

    A bundle may also have a filter to specify what types of nodes may be in
    the bundle. See hou.nodeTypeFilter for the possible filters. If you try
    to add a node to a regular bundle but the node does not match the
    filter, Houdini will fail to add the node. For smart bundles, the filter
    is applied after doing any pattern matching. For example, if the pattern
    is \"/obj/*\" and the filter is hou.nodeTypeFilter.Obj, the bundle will
    contain only the objects in /obj, without any SOPs, etc. inside them.
    Because the pattern is applied recursively, however, any objects inside
    object subnets will also be in the bundle.

    To specify a bundle in a node parameter that expects a list of nodes,
    prefix the bundle name with @. For example, you can enter @bundle1 in
    the light mask parameter of an object so it is lit by the nodes inside
    the bundle named bundle1.

    You can view and edit node bundles in Houdini's Bundle List pane. Use
    hou.nodeBundle_ and hou.nodeBundles to access existing node bundles, and
    hou.addNodeBundle to create a new bundle.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Bundle

    def __eq__(self, bundle: "HOM_PtrOrNull< HOM_NodeBundle >") -> "bool":
        return _hou.Bundle___eq__(self, bundle)

    def __ne__(self, bundle: "HOM_PtrOrNull< HOM_NodeBundle >") -> "bool":
        return _hou.Bundle___ne__(self, bundle)

    def __hash__(self) -> "int":
        return _hou.Bundle___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Bundle___repr__(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this bundle.


        """
        return _hou.Bundle_destroy(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of the bundle.


        """
        return _hou.Bundle_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Change the name of the bundle.

            Raises hou.OperationFailed if the name contains non-alphanumeric
            characters other than _, or if a bundle with that name already
            exists.


        """
        return _hou.Bundle_setName(self, name)

    def findBestFilter(self) -> "HOM_EnumValue &":
        r"""

        findBestFilter(self) -> hou.nodeTypeFilter enum value

            Return the most restrictive bundle filter that matches all the nodes
            in the bundle.

            See hou.nodeTypeFilter for the possible filters.
            hou.nodeTypeFilter.NoFilter is a special value to indicate that
            there is no filtering.


        """
        return _hou.Bundle_findBestFilter(self)

    def filter(self) -> "HOM_EnumValue &":
        r"""

        filter(self) -> hou.nodeTypeFilter enum value

            Return the bundle's filter. For smart bundles, the filter is applied
            after matching nodes to the pattern, and nodes whose types do not
            match the filter are removed from the bundle.

            See hou.nodeTypeFilter for the possible filters.
            hou.nodeTypeFilter.NoFilter is a special value to indicate that
            there is no filtering.

            See the class documentation for more information about filtering.


        """
        return _hou.Bundle_filter(self)

    def setFilter(self, filter: "EnumValue") -> "void":
        r"""

        setFilter(self, node_type_filter)

            Set this bundle's filter to a hou.nodeTypeFilter enumerated value.
            Use hou.nodeTypeFilter.NoFilter to clear the filter.

            See hou.NodeBundle.filter and the class documentation for more
            information.


        """
        return _hou.Bundle_setFilter(self, filter)

    def pattern(self) -> "InterpreterObject":
        r"""

        pattern(self) -> str or None

            Return None if this bundle is a regular bundle, or a string pattern
            if the bundle is a smart bundle.

            See the class documentation for more information on smart bundles.
            Note that if a node matches the pattern, all its subchildren will be
            in the bundle, as long as they match the filter. For example, if the
            pattern is \"/obj/*\" and the filter is hou.nodeTypeFilter.NoFilter,
            the bundle will contain all nodes under /obj, recursively.


        """
        return _hou.Bundle_pattern(self)

    def setPattern(self, pattern_or_none: "char const *") -> "void":
        r"""

        setPattern(self, pattern_or_none)

            Change the pattern of this bundle.

            Setting the pattern to None changes the bundle into a regular
            bundle. In this case, the bundle's contents are unchanged, but
            Houdini will no longer do pattern matching to determine the bundle's
            contents.

            If the pattern is a string, the bundle becomes a smart bundle and
            its contents immediately change to match the pattern. The bundle's
            contents will update as nodes are created and deleted in Houdini.

            See hou.NodeBundle.pattern and the class documentation for more
            information.


        """
        return _hou.Bundle_setPattern(self, pattern_or_none)

    def nodes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        nodes(self) -> tuple of hou.Node

            Return a tuple of the nodes in this bundle.


        """
        return _hou.Bundle_nodes(self)

    def containsNode(self, node: "Node") -> "bool":
        r"""

        containsNode(self, node) -> bool

            Return True if the node is in the bundle and False otherwise. node
            must be a hou.Node object.

            This method is a shortcut for node in bundle.nodes(). For bundles
            with many nodes, this method will be slightly faster.


        """
        return _hou.Bundle_containsNode(self, node)

    def addNode(self, node: "Node") -> "void":
        r"""

        addNode(self, node)

            Add a node to the bundle.

            Raises hou.OperationFailed if this bundle is a smart bundle, since
            the contents of smart bundles are automatically determined by their
            pattern.


        """
        return _hou.Bundle_addNode(self, node)

    def removeNode(self, base_node: "Node") -> "void":
        r"""

        removeNode(self, node)

            Remove a node from the bundle.

            Raises hou.OperationFailed if this bundle is a smart bundle, since
            the contents of smart bundles are automatically determined by their
            pattern.


        """
        return _hou.Bundle_removeNode(self, base_node)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove all nodes from the bundle.

            Raises hou.OperationFailed if this bundle is a smart bundle, since
            the contents of smart bundles are automatically determined by their
            pattern.


        """
        return _hou.Bundle_clear(self)

    def isSelected(self) -> "bool":
        r"""

        isSelected(self) -> bool

            Return True if the bundle is selected in the bundle list pane and
            False otherwise.


        """
        return _hou.Bundle_isSelected(self)

    def setSelected(self, on: "bool", clear_all_selected: "bool" = False) -> "void":
        r"""

        setSelected(self, on, clear_all_selected=false)

            Select this bundle in the bundle list pane. If clear_all_selected is
            True, only this bundle will remain selected. Otherwise, this bundle
            will be added to the existing selection.


        """
        return _hou.Bundle_setSelected(self, on, clear_all_selected)

    def convertToNormalBundle(self) -> "void":
        r"""

        convertToNormalBundle(self)

            Convert the bundle into a normal bundle. The smart bundle pattern is
            removed.

            Do nothing if the bundle is already a normal bundle.


        """
        return _hou.Bundle_convertToNormalBundle(self)

    def convertToSmartBundle(self) -> "void":
        r"""

        convertToSmartBundle(self)

            Convert the bundle into a smart bundle. A regular expression is
            constructed from the contents of the bundle and then set as the
            bundle pattern.

            Do nothing if the bundle is already a smart bundle.


        """
        return _hou.Bundle_convertToSmartBundle(self)


# Register Bundle in _hou:
_hou.Bundle_swigregister(Bundle)


class NodeConnection(NetworkItem):
    r"""

    hou.NodeConnection

    Represents a connection (wire) between two Nodes.

    OVERVIEW

        You can get a list of NodeConnection objects from a hou.Node
        instance using hou.Node.inputConnections and
        hou.Node.outputConnections.


        NOTE
            It is probably easier to use the hou.Node.inputs and
            hou.Node.outputs methods (which return the endpoints of a node's
            connections) to traverse the network, rather than dealing with
            the connections themselves.

        This object is read-only. To create or edit connections, use methods
        on the node, such as hou.Node.setNamedInput, hou.Node.setInput,
        hou.Node.setFirstInput, hou.Node.setNextInput,
        hou.Node.createInputNode, and hou.Node.createOutputNode.

    INPUT AND OUTPUT MEANING

        The hou.NodeConnection.outputNode and hou.NodeConnection.inputNode
        are named in relation to the input and output ends of the connector.
        So, outputNode() returns the node at the output end of this
        connection, in relation to the flow of data through the network.
        inputNode() returns the node that provides data to the output node.

        For the other methods on this object, if the method name starts with
        input, it is referring to data on the inputNode(). If the method
        name starts with output, it is referring to data from the
        outputNode(). There is one exception to this though: inputIndex()
        refers the the input number on the outputNode(), and outputIndex()
        refers to the output number of the inputNode().


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NodeConnection

    def __hash__(self) -> "int":
        return _hou.NodeConnection___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.NodeConnection___repr__(self)

    def __eq__(self, connection: "HOM_PtrOrNull< HOM_NodeConnection >") -> "bool":
        return _hou.NodeConnection___eq__(self, connection)

    def __ne__(self, connection: "HOM_PtrOrNull< HOM_NodeConnection >") -> "bool":
        return _hou.NodeConnection___ne__(self, connection)

    def outputNode(self) -> "HOM_Node *":
        r"""

        outputNode(self) -> hou.Node

            Return the node on the output side of this connection. This is the
            node that the connection goes to, in the direction of data flow. If
            this connection has a network dot as its output, this method returns
            None.


        """
        return _hou.NodeConnection_outputNode(self)

    def inputIndex(self) -> "int":
        r"""

        inputIndex(self) -> int

            Returns the index of the input connection on the node that the
            output side of this connections connects to.


        """
        return _hou.NodeConnection_inputIndex(self)

    def outputItem(self) -> "HOM_NetworkMovableItem *":
        r"""

        outputItem(self) -> hou.NetworkMovableItem

            Return the node or network dot on the output side of this
            connection. This is the node or dot that the connection goes to, in
            the direction of data flow. This method should never return None.


        """
        return _hou.NodeConnection_outputItem(self)

    def inputNode(self) -> "HOM_Node *":
        r"""

        inputNode(self) -> hou.Node

            Return the node on the input side of this connection. This is the
            node that the connection comes from, in the direction of data flow.
            If this connection goes through an indirect input, this will return
            the node connected to the parent node (or None if nothing is
            connected).


        """
        return _hou.NodeConnection_inputNode(self)

    def outputIndex(self) -> "int":
        r"""

        outputIndex(self) -> int

            Returns the index of the output connection on the node that the
            input side of this connections connects to. If this connection goes
            through an indirect input, this will return the index of the output
            connected to the parent node (or 0 if nothing is connected).


        """
        return _hou.NodeConnection_outputIndex(self)

    def subnetIndirectInput(self) -> "HOM_SubnetIndirectInput *":
        r"""

        subnetIndirectInput(self) -> hou.SubnetIndirectInput

            If this connection has a subnet indirect input connected to it
            instead of a node, return the corresponding object. Otherwise,
            return None. See hou.SubnetIndirectInput for information on subnet
            indirect inputs.


        """
        return _hou.NodeConnection_subnetIndirectInput(self)

    def inputItem(self) -> "HOM_NetworkMovableItem *":
        r"""

        inputItem(self) -> hou.NetworkMovableItem

            If this connection has a subnet indirect input connected to it,
            return the corresponding hou.SubnetIndirectInput object. If this
            connection has a node connected to it, return the corresponding
            hou.Node object. Otherwise, return None. This method is essentially
            equivalent to the following:

          > def getInputItem(node_connection):
          >     if node_connection.subnetIndirectInput() is not None:
          >         return node_connection.subnetIndirectInput()
          >     return node_connection.inputNode()

        """
        return _hou.NodeConnection_inputItem(self)

    def inputItemOutputIndex(self) -> "int":
        r"""

        inputItemOutputIndex(self) -> int

            Returns zero if this connection has a subnet indirect input
            connected to it. Otherwise return the index of the output connection
            on the node that the input side of this connections connects to. In
            combination with the inputItem method, node and subnet indirect
            inputs can be processed through a common code path for many use
            cases.


        """
        return _hou.NodeConnection_inputItemOutputIndex(self)

    def isSelected(self) -> "bool":
        r"""

        isSelected(self) -> bool

            Return True if this connection is selected.


        """
        return _hou.NodeConnection_isSelected(self)

    def setSelected(
        self, selected: "bool", clear_all_selected: "bool" = False
    ) -> "void":
        r"""

        setSelected(self, selected, clear_all_selected = False)

            Selects or de-selects this connection. If the clear_all_selected
            parameter is set to True, all other selections (both connections,
            and nodes, network boxes, etc.) will be cleared before this
            connection is selected.


        """
        return _hou.NodeConnection_setSelected(self, selected, clear_all_selected)

    def inputName(self) -> "std::string":
        r"""

        inputName(self) -> str

            Returns the name of the output connection on the node that the input
            side of this connections connects to.


        """
        return _hou.NodeConnection_inputName(self)

    def inputLabel(self) -> "std::string":
        r"""

        inputLabel(self) -> str

            Returns the label of the output connection on the node that the
            input side of this connections connects to.


        """
        return _hou.NodeConnection_inputLabel(self)

    def inputDataType(self) -> "std::string":
        return _hou.NodeConnection_inputDataType(self)

    def outputName(self) -> "std::string":
        r"""

        outputName(self) -> str

            Returns the name of the input connection on the node that the output
            side of this connections connects to.


        """
        return _hou.NodeConnection_outputName(self)

    def outputLabel(self) -> "std::string":
        r"""

        outputLabel(self) -> str

            Returns the label of the input connection on the node that the
            output side of this connections connects to.


        """
        return _hou.NodeConnection_outputLabel(self)

    def outputDataType(self) -> "std::string":
        return _hou.NodeConnection_outputDataType(self)


# Register NodeConnection in _hou:
_hou.NodeConnection_swigregister(NodeConnection)


class NodeInfoTree(object):
    r"""

    hou.NodeInfoTree

    A tree structure designed to contain information about nodes and the
    data they generate.

    This class represents a tree structure, where each branch of the tree
    can have any number of named sub-trees, as well as a two dimensional
    grid of strings. Most often this grid has two columns (Property and
    Value), with some number of rows to represent arbitrary key/value pairs.
    But the grid can also contain more complex data (such as the volume
    information in geometry data).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, tree_root: "UT_SharedPtr< UT_InfoTree >", tree: "UT_InfoTree *"):
        r"""

        hou.NodeInfoTree

        A tree structure designed to contain information about nodes and the
        data they generate.

        This class represents a tree structure, where each branch of the tree
        can have any number of named sub-trees, as well as a two dimensional
        grid of strings. Most often this grid has two columns (Property and
        Value), with some number of rows to represent arbitrary key/value pairs.
        But the grid can also contain more complex data (such as the volume
        information in geometry data).


        """
        _hou.NodeInfoTree_swiginit(self, _hou.new_NodeInfoTree(tree_root, tree))

    __swig_destroy__ = _hou.delete_NodeInfoTree

    def __repr__(self) -> "std::string":
        return _hou.NodeInfoTree___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of this branch of the tree.


        """
        return _hou.NodeInfoTree_name(self)

    def infoType(self) -> "std::string":
        r"""

        infoType(self) -> str

            Returns a string that can be used to describe the type of data
            stored in this tree. For example, a tree holding geometry
            information (generated either by a SOP node or a DOP node) will
            return \"Geometry\" from this method.


        """
        return _hou.NodeInfoTree_infoType(self)

    def branchOrder(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        branchOrder(self) -> tuple of str

            Returns the natural order of the child branches in the dictionary
            returned by branches(). This ordering is often not very important,
            but in situations where there are a large number of branches that do
            have some sort of natural order (such as the branches for each DOP
            object returned by a DOP node) this method can help organize the
            information.

            This code iterates through all child branches of a node's info tree
            in their natural order, assuming an RBD simulation created from a
            default sphere and torus object:

          > >>> nodeinfo = hou.node('/obj/AutoDopNetwork/output').infoTree()
          > >>> dopinfo = nodeinfo.branches()['DOP Info']
          > >>> objinfo = dopinfo.branches()['Objects']
          > >>> objbranches = objinfo.branches()
          > >>> for objname in objinfo.branchOrder():
          > ...   obj = objbranches[objname]
          > ...   print objname, ':', obj.branches()
          > ...
          > torus_object1 : {'Geometry': <hou.NodeInfoTree>}
          > sphere_object1 : {'Geometry': <hou.NodeInfoTree>}

        """
        return _hou.NodeInfoTree_branchOrder(self)

    def branches(
        self,
    ) -> "std::map< std::string,HOM_NodeInfoTree,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_NodeInfoTree > > >":
        r"""

        branches(self) -> dict of str to hou.NodeInfoTree

            Return a dictionary of all child branches. Each branch has a name,
            and is a full tree, which may have it's own branches, and so on.


        """
        return _hou.NodeInfoTree_branches(self)

    def headings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        headings(self) -> tuple of str

            Returns the titles of the columns for the data returned by the
            rows() method. Usually this will be simply ('Property', 'Value'),
            for rows that are simply key/value pairs. But in some cases the
            headings can help interpret the returned information.


        """
        return _hou.NodeInfoTree_headings(self)

    def rows(
        self,
    ) -> "std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > >":
        r"""

        rows(self) -> tuple of tuple of str

            Return a two dimensional grid of strings. The returned tuple
            represents the rows of the grid. The contained tuples each represent
            one row. All contained tuples will be the same length, which will be
            the length of the tuple returned by the headings() method.


        """
        return _hou.NodeInfoTree_rows(self)


# Register NodeInfoTree in _hou:
_hou.NodeInfoTree_swigregister(NodeInfoTree)


class NodeTypeCategory(object):
    r"""

    hou.NodeTypeCategory

    Represents a category of node types, such as surface nodes (SOPs) or
    dynamics nodes (DOPs).

    Use hou.nodeTypeCategories to get a dict of node type category names to
    NodeTypeCategory objects. You can use hou.objNodeTypeCategory,
    hou.sopNodeTypeCategory, etc. to directly access a particular node type
    category.

    See also hou.NodeType and hou.Node.

    > # Get the names of all the node type categories.
    > >>> hou.nodeTypeCategories().keys()
    > ['Shop', 'Cop2', 'CopNet', 'ChopNet', 'Object', 'Driver',
    > 'Chop', 'Sop', 'Manager', 'Vop', 'Director', 'Dop', 'VopNet']

    RELATED

      * hou.nodeTypeCategories

      * hou.objNodeTypeCategory

      * hou.sopNodeTypeCategory

      * hou.dopNodeTypeCategory

      * hou.cop2NodeTypeCategory

      * hou.shopNodeTypeCategory_

      * hou.vopNodeTypeCategory

      * hou.ropNodeTypeCategory

      * hou.chopNodeTypeCategory

      * hou.cop2NetNodeTypeCategory

      * hou.vopNetNodeTypeCategory

      * hou.chopNetNodeTypeCategory

      * hou.managerNodeTypeCategory

      * hou.rootNodeTypeCategory


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_NodeTypeCategory

    def __eq__(self, category: "HOM_PtrOrNull< HOM_NodeTypeCategory >") -> "bool":
        return _hou.NodeTypeCategory___eq__(self, category)

    def __ne__(self, category: "HOM_PtrOrNull< HOM_NodeTypeCategory >") -> "bool":
        return _hou.NodeTypeCategory___ne__(self, category)

    def __hash__(self) -> "int":
        return _hou.NodeTypeCategory___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.NodeTypeCategory___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of this node type category.


        """
        return _hou.NodeTypeCategory_name(self)

    def typeName(self) -> "std::string":
        return _hou.NodeTypeCategory_typeName(self)

    def label(self) -> "std::string":
        r"""

        label(self) -> str

            Returns the descriptive of this node type category that appears in
            network editor panes.


        """
        return _hou.NodeTypeCategory_label(self)

    def nodeTypes(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_NodeType >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_NodeType > > > >":
        r"""

        nodeTypes(self) -> dict of str to hou.NodeType

            Return a dict mapping node type names to node types in this
            category.

            For example, if this node type category is SOPs, the keys in the
            dictionary would be box, sphere, polyextrude, subdivide, etc.

            Note that the node types in this category may not all be instances
            of the same class. For example, most node types in the SOP node type
            category are instances of hou.SopNodeType, but some, like SHOP
            networks, CHOP networks, etc. are not.

          > # Access the box SOP's node type.
          > hou.sopNodeTypeCategory().nodeTypes()['box']
          > def findNodeTypes(node_type_category, pattern):
          >     '''Return a list of node types in a particular node type category
          >        whose names match a pattern.'''
          >     import fnmatch
          >
          >     return [node_type
          >         for node_type_name, node_type in node_type_category.nodeTypes().items()
          >         if fnmatch.fnmatch(node_type_name, pattern)]

            See also hou.nodeType_.


        """
        return _hou.NodeTypeCategory_nodeTypes(self)

    def nodeType(self, type_name: "char const *") -> "HOM_NodeType *":
        r"""

        nodeType(self, type_name) -> hou.NodeType or None

            Returns a single node type that matched the provided type name.
            Returns None if the type name doesn't match a node type in this
            category.


        """
        return _hou.NodeTypeCategory_nodeType(self, type_name)

    def nodeVerbs(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_SopVerb >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_SopVerb > > > >":
        r"""

        nodeVerbs(self) -> dict of str to hou.SopVerb

            Return a dict mapping verb names to node verbs in this category.

            Most verbs are named after their corresponding node type.
            Alternatively, given a hou.SopNode, one can use hou.SopNode.verb to
            extract the verb.


        """
        return _hou.NodeTypeCategory_nodeVerbs(self)

    def nodeVerb(self, verb_name: "char const *") -> "HOM_SopVerb *":
        r"""

        nodeVerb(self, name) -> hou.SopVerb or None

            Return a specific verb from the provided verb name. Returns None if
            no matching verb is found.


        """
        return _hou.NodeTypeCategory_nodeVerb(self, verb_name)

    def viewerStates(
        self, viewer_type: "EnumValue"
    ) -> "std::vector< HOM_ElemPtr< HOM_ViewerState >,std::allocator< HOM_ElemPtr< HOM_ViewerState > > >":
        r"""

        viewerStates(self, viewer_type) -> tuple of hou.ViewerState


        """
        return _hou.NodeTypeCategory_viewerStates(self, viewer_type)

    def loadDSO(self, dso_path: "char const *") -> "void":
        r"""

        loadDSO(self, dso_path)

            Loads the HDK custom operator identified by the given file path for
            this node type category. It will use the HOUDINI_DSO_PATH
            environment variable to find it if necessary.


        """
        return _hou.NodeTypeCategory_loadDSO(self, dso_path)

    def hasSubNetworkType(self) -> "bool":
        r"""

        hasSubNetworkType(self) -> bool

            Return True if the category contains a node type that creates sub-
            network nodes.


        """
        return _hou.NodeTypeCategory_hasSubNetworkType(self)

    def defaultShape(self) -> "std::string":
        return _hou.NodeTypeCategory_defaultShape(self)

    def clearDefaultShapes(self) -> "void":
        return _hou.NodeTypeCategory_clearDefaultShapes(self)

    def setDefaultShape(self, shape: "char const *") -> "void":
        return _hou.NodeTypeCategory_setDefaultShape(self, shape)

    def defaultColor(self) -> "HOM_Color":
        return _hou.NodeTypeCategory_defaultColor(self)

    def clearDefaultColors(self) -> "void":
        return _hou.NodeTypeCategory_clearDefaultColors(self)

    def setDefaultColor(self, color: "Color") -> "void":
        return _hou.NodeTypeCategory_setDefaultColor(self, color)

    def defaultWireStyle(self) -> "std::string":
        return _hou.NodeTypeCategory_defaultWireStyle(self)

    def setDefaultWireStyle(self, wirestyle: "char const *") -> "void":
        return _hou.NodeTypeCategory_setDefaultWireStyle(self, wirestyle)

    def _asVoidPointer(self) -> "void *":
        return _hou.NodeTypeCategory__asVoidPointer(self)


# Register NodeTypeCategory in _hou:
_hou.NodeTypeCategory_swigregister(NodeTypeCategory)


class OrboltURLHandler(object):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_OrboltURLHandler

    def __repr__(self) -> "std::string":
        return _hou.OrboltURLHandler___repr__(self)

    def updateProgressBar(self, percentage: "double") -> "void":
        return _hou.OrboltURLHandler_updateProgressBar(self, percentage)

    def closeSplashScreen(self, immediate: "bool" = False) -> "void":
        return _hou.OrboltURLHandler_closeSplashScreen(self, immediate)


# Register OrboltURLHandler in _hou:
_hou.OrboltURLHandler_swigregister(OrboltURLHandler)


class OrientedBoundingBox(object):
    r"""

    hou.OrientedBoundingBox

    An oriented 3D rectangular region.

    Computes an oriented bounding box for a set of points.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self)

            Constructs an empty bounding box.


        """
        _hou.OrientedBoundingBox_swiginit(self, _hou.new_OrientedBoundingBox(*args))

    __swig_destroy__ = _hou.delete_OrientedBoundingBox

    def __eq__(self, bbox: "HOM_PtrOrNull< HOM_OrientedBoundingBox >") -> "bool":
        return _hou.OrientedBoundingBox___eq__(self, bbox)

    def __ne__(self, bbox: "HOM_PtrOrNull< HOM_OrientedBoundingBox >") -> "bool":
        return _hou.OrientedBoundingBox___ne__(self, bbox)

    def isAlmostEqual(
        self, other: "OrientedBoundingBox", tol: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, bbox, tolerance=0.00001) -> bool

            Returns whether this bounding box is equal to another, subject to
            numerical tolerances.


        """
        return _hou.OrientedBoundingBox_isAlmostEqual(self, other, tol)

    def __hash__(self) -> "int":
        return _hou.OrientedBoundingBox___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.OrientedBoundingBox___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.OrientedBoundingBox___repr__(self)

    def __mul__(self, matrix4: "Matrix4") -> "HOM_OrientedBoundingBox":
        r"""

        __mul__(self, matrix4) -> OrientedBoundingBox

            Return a copy of this bounding box transformed by the given matrix.


        """
        return _hou.OrientedBoundingBox___mul__(self, matrix4)

    def center(self) -> "HOM_Vector3":
        r"""

        center(self) -> hou.Vector3

            Returns the position of the center of the bounding box.


        """
        return _hou.OrientedBoundingBox_center(self)

    def rotation(self) -> "HOM_Matrix3":
        return _hou.OrientedBoundingBox_rotation(self)

    def sizevec(self) -> "HOM_Vector3":
        r"""

        sizevec(self) -> hou.Vector3

            Returns a vector describing the size of the box in each of the the
            x, y and z axes relative to its rotated coordinate system (that is,
            where the x axis is the first row of rotation).


        """
        return _hou.OrientedBoundingBox_sizevec(self)

    def contains(self, point: "_DoubleTuple") -> "bool":
        r"""

        contains(self, point) -> bool

            Given a sequence of 3 floats (such as a hou.Vector3) describing a
            position, return whether the position is inside the box.


        """
        return _hou.OrientedBoundingBox_contains(self, point)

    def isValid(self) -> "bool":
        r"""

        isValid(self) -> bool

            Returns whether this bounding box is valid.


        """
        return _hou.OrientedBoundingBox_isValid(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.OrientedBoundingBox__asVoidPointer(self)


# Register OrientedBoundingBox in _hou:
_hou.OrientedBoundingBox_swigregister(OrientedBoundingBox)


class OrientedBoundingRect(object):
    r"""

    hou.OrientedBoundingRect

    An oriented 2D rectangular region.

    Computes an oriented bounding rectangle for a set of points.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(
        self, points: "std::vector< HOM_Vector2,std::allocator< HOM_Vector2 > > const &"
    ):
        r"""

        __init__(self, points)

            Constructs the minimum area oriented bounding rectangle for the
            given points (a sequence of hou.Vector2).


        """
        _hou.OrientedBoundingRect_swiginit(self, _hou.new_OrientedBoundingRect(points))

    __swig_destroy__ = _hou.delete_OrientedBoundingRect

    def __eq__(self, brect: "HOM_PtrOrNull< HOM_OrientedBoundingRect >") -> "bool":
        return _hou.OrientedBoundingRect___eq__(self, brect)

    def __ne__(self, brect: "HOM_PtrOrNull< HOM_OrientedBoundingRect >") -> "bool":
        return _hou.OrientedBoundingRect___ne__(self, brect)

    def isAlmostEqual(
        self, brect: "OrientedBoundingRect", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, brect, tolerance=0.00001) -> bool

            Returns whether this bounding rectangle is equal to another, subject
            to numerical tolerances.


        """
        return _hou.OrientedBoundingRect_isAlmostEqual(self, brect, tolerance)

    def __hash__(self) -> "int":
        return _hou.OrientedBoundingRect___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.OrientedBoundingRect___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.OrientedBoundingRect___repr__(self)

    def sizevec(self) -> "HOM_Vector2":
        r"""

        sizevec(self) -> hou.Vector2

            Returns a vector describing the size of the box in the x and y axes.


        """
        return _hou.OrientedBoundingRect_sizevec(self)

    def center(self) -> "HOM_Vector2":
        r"""

        center(self) -> hou.Vector2

            Returns the position of the center of the bounding rectangle.


        """
        return _hou.OrientedBoundingRect_center(self)

    def orientation(self) -> "HOM_Matrix2":
        r"""

        orientation(self) -> hou.Matrix2

            Returns a hou.Matrix2 that defines the orientation of the bounding
            rectangle.


        """
        return _hou.OrientedBoundingRect_orientation(self)


# Register OrientedBoundingRect in _hou:
_hou.OrientedBoundingRect_swigregister(OrientedBoundingRect)


class PackedFragment(PackedPrim):
    r"""

    hou.PackedFragment

    A packed fragment primitive.

    See packed primitives for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PackedFragment

    def __repr__(self) -> "std::string":
        return _hou.PackedFragment___repr__(self)

    def setEmbeddedGeometry(
        self, geometry: "Geometry", attrib: "char const *", name: "char const *"
    ) -> "void":
        r"""

        setEmbeddedGeometry(self, geo, attrib, name)

            Embeds into this primitive all primitives from geo with the value
            name for the primitive attribute attrib. Use read-only frozen
            geometry to share geometry between multiple packed fragment
            primitives. See hou.Geometry.freeze for more information.


        """
        return _hou.PackedFragment_setEmbeddedGeometry(self, geometry, attrib, name)


# Register PackedFragment in _hou:
_hou.PackedFragment_swigregister(PackedFragment)


class PackedGeometry(PackedPrim):
    r"""

    hou.PackedGeometry

    A packed geometry primitive.

    See packed primitives for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PackedGeometry

    def __repr__(self) -> "std::string":
        return _hou.PackedGeometry___repr__(self)

    def getEmbeddedGeometry(self) -> "HOM_Geometry *":
        r"""

        getEmbeddedGeometry(self) -> hou.Geometry

            Returns the geometry of this primitive.


        """
        return _hou.PackedGeometry_getEmbeddedGeometry(self)

    def setEmbeddedGeometry(self, geometry: "Geometry") -> "void":
        r"""

        setEmbeddedGeometry(self, geo)

            Embeds the provided geometry into this primitive. Use read-only
            frozen geometry to share geometry between multiple packed geometry
            primitives. See hou.Geometry.freeze for more information.


        """
        return _hou.PackedGeometry_setEmbeddedGeometry(self, geometry)


# Register PackedGeometry in _hou:
_hou.PackedGeometry_swigregister(PackedGeometry)


class Parm(object):
    r"""

    hou.Parm

    A parameter in a node. Each parameter has a unique name within its node
    and exists inside a parameter tuple.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Parm

    def __eq__(self, parm: "HOM_PtrOrNull< HOM_Parm >") -> "bool":
        return _hou.Parm___eq__(self, parm)

    def __ne__(self, parm: "HOM_PtrOrNull< HOM_Parm >") -> "bool":
        return _hou.Parm___ne__(self, parm)

    def __hash__(self) -> "int":
        return _hou.Parm___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Parm___repr__(self)

    def node(self) -> "HOM_Node *":
        r"""

        node(self) -> hou.Node

            Returns the node on which this parameter exists.


        """
        return _hou.Parm_node(self)

    def tuple(self) -> "HOM_ParmTuple *":
        r"""

        tuple(self) -> hou.ParmTuple

            Returns the hou.ParmTuple associated with this parameter.

            For example, calling this method on the Parm object for the
            translation parameter tx, would return a ParmTuple that contains
            Parm objects for the three translation parameters tx, ty and tz. If
            no tuple is associated with the parameter, then the parameter itself
            is returned in a tuple of size 1.


        """
        return _hou.Parm_tuple(self)

    def parmTemplate(self) -> "HOM_ParmTemplate *":
        r"""

        parmTemplate(self) -> hou.ParmTemplate

            Returns the template for this parameter.


        """
        return _hou.Parm_parmTemplate(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns this parameter's name.


        """
        return _hou.Parm_name(self)

    def path(self) -> "std::string":
        r"""

        path(self) -> str

            Returns the full path to this parameter.


        """
        return _hou.Parm_path(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Returns this parameter's label.


        """
        return _hou.Parm_description(self)

    def componentIndex(self) -> "int":
        r"""

        componentIndex(self) -> int

            Returns the component index of this parameter.

            For example, the translation parameter along the x-axis, tx, would
            return a component index of 0, while the translation parameter along
            the y-axis, ty would return a component index of 1.


        """
        return _hou.Parm_componentIndex(self)

    def menuContents(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuContents(self) -> tuple of str

            Returns a list of the tokens and labels for all possible menu items
            (for a menu parameter). This format is suitable for use in a
            parameter menu script. Raises hou.OperationFailed if this parameter
            is not a menu.


        """
        return _hou.Parm_menuContents(self)

    def menuLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuLabels(self) -> tuple of str

            Returns a list of labels for all possible menu items (for a menu
            parameter). Raises hou.OperationFailed if this parameter is not a
            menu.


        """
        return _hou.Parm_menuLabels(self)

    def menuItems(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuItems(self) -> tuple of str

            Returns a list of all possible menu items (for a menu parameter).
            Raises hou.OperationFailed if this parameter is not a menu.


        """
        return _hou.Parm_menuItems(self)

    def isDynamicMenu(self) -> "bool":
        r"""

        isDynamicMenu(self) -> bool

            Returns True if the parameter's menu item list is specified using
            custom logic defined in the Houdini source code. Returns False if
            the parameter's menu items are specified with a script or item list,
            or if the parameter is not a menu.


        """
        return _hou.Parm_isDynamicMenu(self)

    def pressButton(self, *args, **kwargs) -> "void":
        r"""

        pressButton(self, arguments={})

            Emulates clicking a button parameter to trigger its callback script.
            Raises hou.OperationFailed if the callback script could not be run.
            An optional dictionary of arguments can be passed to the callback
            script. Raises TypeError if a n argument value type is unsupported.


            NOTE
                This can be called on any type parameter to trigger its callback
                script, it is not limited to only button parameters.


            arguments
                An optional dictionary of arguments for the callback script. The
                dictionary is merged with the keyword values passed to the
                callback. The arguments values are single values of the
                following types: int, bool, float, str.


        """
        return _hou.Parm_pressButton(self, *args, **kwargs)

    def _setPending(self, *args) -> "void":
        return _hou.Parm__setPending(self, *args)

    def _set(self, *args) -> "void":
        return _hou.Parm__set(self, *args)

    def _setNone(self) -> "void":
        return _hou.Parm__setNone(self)

    def _setNonePending(self) -> "void":
        return _hou.Parm__setNonePending(self)

    def setFromParm(self, src: "Parm") -> "void":
        r"""

        setFromParm(self, src)

            Copies the value of an entire parameter, including channels, from
            the provided src parameter.


        """
        return _hou.Parm_setFromParm(self, src)

    def setFromParmDefaults(self, src: "Parm") -> "void":
        return _hou.Parm_setFromParmDefaults(self, src)

    def revertToDefaults(self) -> "void":
        r"""

        revertToRampDefaults(self)

            Change the value back to the default(s), removing all the non-
            default control points from the ramp.

            Raises TypeError if the parameter is not a ramp.


        """
        return _hou.Parm_revertToDefaults(self)

    def revertToAndRestorePermanentDefaults(self) -> "void":
        r"""

        revertToAndRestorePermanentDefaults(self)

            Changes the value back to the default that ships with Houdini, and
            restores that default.

            See also the revertToDefaults() method, and
            hou.ParmTuple.revertToAndRestorePermanentDefaults


        """
        return _hou.Parm_revertToAndRestorePermanentDefaults(self)

    def revertToRampDefaults(self) -> "void":
        return _hou.Parm_revertToRampDefaults(self)

    def hasTemporaryDefaults(self) -> "bool":
        r"""

        hasTemporaryDefaults(self) -> bool

            Returns whether a default has been explicitly set on the parameter.

            See also the revertToDefaults() and
            revertToAndRestorePermanentDefaults()methods.


        """
        return _hou.Parm_hasTemporaryDefaults(self)

    def isAtDefault(
        self,
        compare_temporary_defaults: "bool" = True,
        compare_expressions: "bool" = True,
    ) -> "bool":
        r"""

        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool

            Returns whether the parameter is currently at its default.

            compare_temporary_defaults: When <compare_temporary_defaults> is
            True, isAtDefault also checks

            compare_expressions: When <compare_Expressions> is True, isAtDefault
            compares the actual

            See also the revertToDefaults() and
            revertToAndRestorePermanentDefaults()methods.


        """
        return _hou.Parm_isAtDefault(
            self, compare_temporary_defaults, compare_expressions
        )

    def setExpression(
        self,
        expression: "char const *",
        language: "EnumValue" = None,
        replace_expression: "bool" = True,
    ) -> "void":
        r"""

        setExpression(self, expression, language=None, replace_expression=True)

            Sets this parameter's expression.

            expression: A string containing the expression that will go inside
            the parameter.

            language: Either a hou.exprLanguage enumeration value or None.

            If language is None and the parameter does not already contain an
            expression, the language will be the node's expression language.
            (See hou.Node.expressionLanguage.) Otherwise, if language is None
            and the parameter already has an expression, the expression language
            will not change.

            replace_expression: This parameter only has effect if the parameter
            already contains keyframes. If it is True, Houdini will replace the
            keyframe before the current time with one containing the new
            expression. Otherwise, it will always add a keyframe at the current
            time. Note that this behavior matches what happens when you edit an
            expression from Houdini's parameter dialog.

            Unlike hou.Parm.set, this method does not follow channel references.
            That is, if this parameter is referencing another parameter and you
            call setExpression(), it change the channel reference expression
            into the specified expression.

            If the parameter does not already contain any keyframes, this method
            is roughly equivalent to setting a keyframe at frame 1, where the
            keyframe's expression and language are the ones specified.

            This method can be approximately implemented as follows:

          > def setExpression(self, expression, language=None, replace_expression=None)
          > if self.template().type() == hou.parmTemplateType.String:
          >     k = hou.StringKeyframe()
          > else:
          >     k = hou.Keyframe()
          >
          > k.setExpression(expression, language)
          >
          > if len(self.keyframes()):
          >     if replace_expression:
          >     k.setTime(self.effectiveKeyframeAtFrame(hou.frame()).time())
          >     else:
          >     k.setTime(hou.time())
          > else
          >     k.setTime(0.0)
          >
          > self.setKeyframe(k)

            See also the expression, expressionLanguage, and setKeyframe
            methods, hou.Node.expressionLanguage, and hou.Node.setExpressions.


        """
        return _hou.Parm_setExpression(self, expression, language, replace_expression)

    def expression(self) -> "std::string":
        r"""

        expression(self) -> str

            Returns this parameter's expression.

            For example, a parameter might contain the Python expression frame()
            * 2. In this case hou.Parm.eval at frame 2 would return the value 4,
            while calling expression() would return the string frame() * 2.

            If the parameter does not contain an expression, this method will
            raise hou.OperationFailed. Also, if the parameter contains more than
            one keyframe then it could contain multiple different expressions,
            so it also raises hou.OperationFailed in that case.

            This method is roughly equivalent to...

          > parm.keyframes()[0].expression()

            See also the setExpression(), expressionLanguage(), keyframes(), and
            eval() methods.


        """
        return _hou.Parm_expression(self)

    def expressionLanguage(self) -> "HOM_EnumValue *":
        r"""

        expressionLanguage(self) -> hou.exprLanguage enum value

            Returns the parameter's expression's language.

            If the parameter does not contain an expression, this method will
            raise hou.OperationFailed. Also, if the parameter contains more than
            one keyframe then it could contain multiple different expressions,
            so it also raises hou.OperationFailed in that case.

            To change the expression language, use hou.Parm.setExpression and
            explicitly specify the language:
            parm.setExpression(parm.expression(), language).

            This method is roughly equivalent to...

          > parm.keyframes()[0].expressionLanguage()

            See also the expression(), setExpression(), keyframes(), and
            setExpressionLanguage() methods.


        """
        return _hou.Parm_expressionLanguage(self)

    def rawValue(self) -> "std::string":
        r"""

        rawValue(self) -> str

            Returns the parameter's raw text value without evaluation or
            expansion. If the parameter has an expression then the expression is
            returned otherwise the parameter's plain text value is returned.


        """
        return _hou.Parm_rawValue(self)

    def isShowingExpression(self) -> "bool":
        r"""

        isShowingExpression(self) -> bool

            Return whether this parameter is shown as an expression or as the

            See also the showExpression() method.


        """
        return _hou.Parm_isShowingExpression(self)

    def showExpression(self, value: "bool") -> "void":
        return _hou.Parm_showExpression(self, value)

    def setKeyframe(self, keyframe: "BaseKeyframe") -> "void":
        r"""

        setKeyframe(self, keyframe)

            Sets a keyframe on this parameter.

            Raises TypeError if keyframe is not of type hou.BaseKeyframe. Raises
            hou.PermissionError if this parameter is not writable.


        """
        return _hou.Parm_setKeyframe(self, keyframe)

    def setKeyframes(
        self,
        keyframes: "std::vector< HOM_BaseKeyframe *,std::allocator< HOM_BaseKeyframe * > > const &",
    ) -> "void":
        r"""

        setKeyframes(self, keyframes)

            Sets multiple keyframe on this parameter. Calling this method is
            more efficient than calling hou.Parm.setKeyframe several times
            because it sends out only one update event to Houdini for the entire
            batch of keyframes that are set.

            keyframes must be a tuple or list of hou.BaseKeyframe objects.

            Raises hou.PermissionError if this parameter is not writable.


        """
        return _hou.Parm_setKeyframes(self, keyframes)

    def keyframes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >":
        r"""

        keyframes(self) -> tuple of hou.BaseKeyframe

            Returns the keyframes on this parameter.


        """
        return _hou.Parm_keyframes(self)

    def keyframesInRange(
        self, start_frame: "double", end_frame: "double"
    ) -> "std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >":
        r"""

        keyframesInRange(self, start_frame, end_frame) -> tuple of
        hou.BaseKeyframe

            Returns a tuple of keyframes on this parameter that fall in the
            range start_frame to end_frame, inclusive. If no keyframes are found
            an empty tuple is returned.


        """
        return _hou.Parm_keyframesInRange(self, start_frame, end_frame)

    def keyframesBefore(
        self, frame: "double"
    ) -> "std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >":
        r"""

        keyframesBefore(self, frame) -> tuple of hou.BaseKeyframe

            Returns a tuple of keyframes on this parameter that occur at or
            before frame. If no keyframes are found an empty tuple is returned.


        """
        return _hou.Parm_keyframesBefore(self, frame)

    def keyframesAfter(
        self, frame: "double"
    ) -> "std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >":
        return _hou.Parm_keyframesAfter(self, frame)

    def evalAsFloat(self) -> "double":
        r"""

        evalAsFloat(self) -> float

            Evaluates this parameter at the current frame and returns the result
            as a float.

            Raises TypeError if the value cannot be converted to a float.


        """
        return _hou.Parm_evalAsFloat(self)

    def evalAsFloatAtFrame(self, frame: "double") -> "double":
        r"""

        evalAsFloatAtFrame(self, frame) -> float

            Evaluates this parameter at a certain frame and returns the result
            as a float.

            Raises TypeError if the value cannot be converted to a float.


        """
        return _hou.Parm_evalAsFloatAtFrame(self, frame)

    def evalAsInt(self) -> "int":
        r"""

        evalAsInt(self) -> int

            Evaluates this parameter at the current frame and returns the result
            as an integer.

            Raises TypeError if the value cannot be converted to an integer.


        """
        return _hou.Parm_evalAsInt(self)

    def evalAsIntAtFrame(self, frame: "double") -> "int":
        r"""

        evalAsIntAtFrame(self, frame) -> int

            Evaluates this parameter at a certain frame and returns the result
            as an integer.

            Raises TypeError if the value cannot be converted to an integer.


        """
        return _hou.Parm_evalAsIntAtFrame(self, frame)

    def evalAsString(self) -> "std::string":
        r"""

        evalAsString(self) -> str

            Evaluates this parameter at the current frame and returns the result
            as a string.

            If you want the string contents of the parameter before variable
            expansion and expression evaluation then call
            hou.Parm.unexpandedString.

            Raises TypeError if the value cannot be converted to a string.


        """
        return _hou.Parm_evalAsString(self)

    def evalAsStringAtFrame(self, frame: "double") -> "std::string":
        r"""

        evalAsStringAtFrame(self, frame) -> str

            Evaluates this parameter at a certain frame and returns the result
            as a string.

            If you want the string contents of the parameter before variable
            expansion and expression evaluation then call
            hou.Parm.unexpandedString.

            Raises TypeError if the value cannot be converted to a string.


        """
        return _hou.Parm_evalAsStringAtFrame(self, frame)

    def evalAsGeometry(self) -> "HOM_Geometry *":
        r"""

        evalAsGeometry(self) -> hou.Geometry

            Evaluates this parameter at the current frame and returns the result
            as a geometry.

            Raises TypeError if the parameter is not a geometry.


        """
        return _hou.Parm_evalAsGeometry(self)

    def evalAsGeometryAtFrame(self, frame: "double") -> "HOM_Geometry *":
        r"""

        evalAsGeometryAtFrame(self, frame) -> hou.Geometry

            Evaluates this parameter at a certain frame and returns the result
            as a geometry.

            Raises TypeError if the parameter is not a geometry.


        """
        return _hou.Parm_evalAsGeometryAtFrame(self, frame)

    def evalAsJSONMap(
        self,
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        evalAsJSONMap(self) -> dict of str to str

            Evaluates this parameter at the current frame and returns the result
            as a JSON map structure (i.e. Python dictionary).

            Raises TypeError or hou.OperationFailed if the parameter is not a
            JSON map data parameter.


        """
        return _hou.Parm_evalAsJSONMap(self)

    def evalAsJSONMapAtFrame(
        self, frame: "double"
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        evalAsJSONMapAtFrame(self, frame) -> dict of str to str

            Evaluates this parameter at a certain frame and returns the result
            as a JSON map structure (i.e. Python dictionary).

            Raises TypeError or hou.OperationFailed if the parameter is not a
            JSON map data parameter.


        """
        return _hou.Parm_evalAsJSONMapAtFrame(self, frame)

    def evalAsRamp(self) -> "HOM_Ramp *":
        r"""

        evalAsRamp(self) -> hou.Ramp

            Evaluates this parameter at the current frame and returns the result
            as a ramp.

            Raises TypeError if the parameter is not a ramp.


        """
        return _hou.Parm_evalAsRamp(self)

    def evalAsRampAtFrame(self, frame: "double") -> "HOM_Ramp *":
        r"""

        evalAsRampAtFrame(self, frame) -> hou.Ramp

            Evaluates this parameter at a certain frame and returns the result
            as a ramp.

            Raises TypeError if the parameter is not a ramp.


        """
        return _hou.Parm_evalAsRampAtFrame(self, frame)

    def evalAsNode(self) -> "HOM_Node *":
        r"""

        evalAsNode(self) -> hou.Node

            Evaluates this parameter at the current frame and returns the result
            as a hou.Node.

            If the parameter resolves to multiple node paths, None will be
            returned. See evalAsNodes for this.

            Raises TypeError if the value cannot be converted to a hou.Node.


        """
        return _hou.Parm_evalAsNode(self)

    def evalAsNodeAtFrame(self, frame: "double") -> "HOM_Node *":
        r"""

        evalAsNodeAtFrame(self, frame) -> hou.Node

            Evaluates this parameter at a certain frame and returns the result
            as a hou.Node.

            If the parameter resolves to multiple node paths, None will be
            returned. See evalAsNodesAtFrame for this.

            Raises TypeError if the value cannot be converted to a hou.Node.


        """
        return _hou.Parm_evalAsNodeAtFrame(self, frame)

    def evalAsNodes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        evalAsNodes(self) -> tuple of hou.Node

            Evaluates this parameter at the current frame and returns the result
            as a tuple of hou.Node.

            Raises TypeError if the value cannot be converted to a hou.Node.


        """
        return _hou.Parm_evalAsNodes(self)

    def evalAsNodesAtFrame(
        self, frame: "double"
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        evalAsNodesAtFrame(self, frame) -> tuple of hou.Node

            Evaluates this parameter at a certain frame and returns the result
            as a tuple of hou.Node.

            Raises TypeError if the value cannot be converted to a hou.Node.


        """
        return _hou.Parm_evalAsNodesAtFrame(self, frame)

    def evalAsNodePath(self) -> "std::string":
        r"""

        evalAsNodePath(self) -> str

            Evaluates this parameter at the current frame and returns the result
            as an absolute node path.

            If the parameter resolves to multiple node paths, an empty string
            will be returned. See evalAsNodePaths for this.


        """
        return _hou.Parm_evalAsNodePath(self)

    def evalAsNodePathAtFrame(self, frame: "double") -> "std::string":
        r"""

        evalAsNodePathAtFrame(self, frame) -> str

            Evaluates this parameter at a certain frame and returns the result
            as an absolute node path.

            If the parameter resolves to multiple node paths, an empty string
            will be returned. See evalAsNodePathsAtFrame for this.


        """
        return _hou.Parm_evalAsNodePathAtFrame(self, frame)

    def evalAsNodePaths(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        evalAsNodePaths(self) -> tuple of str

            Evaluates this parameter at the current frame and returns the result
            as a tuple of strings where each is an absolute node path.


        """
        return _hou.Parm_evalAsNodePaths(self)

    def evalAsNodePathsAtFrame(
        self, frame: "double"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        evalAsNodePathsAtFrame(self, frame) -> tuple of str

            Evaluates this parameter at a certain frame and returns the result
            as a tuple of strings where each is an absolute node path.


        """
        return _hou.Parm_evalAsNodePathsAtFrame(self, frame)

    def unexpandedString(self) -> "std::string":
        r"""

        unexpandedString(self) -> str

            Returns the contents of the parameter before dollar sign and back-
            tick expansion.

            Examples of unexpanded strings would be image$F.pic, $HIP/split.hda,
            or chs('../font1/text'). If you were to call eval() on them, Houdini
            would perform variable expansion and back-tick expression
            evaluation, so you would get back something like image1.pic instead
            of image$F.pic.

            Because only string parameters will attempt to do dollar sign and
            string expansion, this method will raise hou.OperationFailed if
            called from a non-string parameter.

            Suppose a string parameter contains keyframes. In this situation,
            Houdini will not attempt to do string expansion on the parameter's
            value, so calling this method will raise hou.OperationFailed.
            Instead of calling this method, you can call expression() to access
            the first Keyframe's expression. If there are multiple keyframes,
            you can call keyframes() to get a list of hou.StringKeyframe objects
            and call expression() on those objects to retrieve the expression.


        """
        return _hou.Parm_unexpandedString(self)

    def deleteKeyframeAtFrame(self, frame: "double") -> "void":
        r"""

        deleteKeyframeAtFrame(self, frame)

            Removes a keyframe from this parameter at the given frame.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.OperationFailed exception the
            parameter doesn't have a keyframe at the given frame.

            See also hou.Parm.deleteAllKeyframes.


        """
        return _hou.Parm_deleteKeyframeAtFrame(self, frame)

    def deleteAllKeyframes(self) -> "void":
        r"""

        deleteAllKeyframes(self)

            Removes all keyframes from this parameter.

            This has no effect if there are no keyframes to delete. The value of
            the parameter after all keyframes are removed will be the one it
            evaluated to at the current frame.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            See also hou.Parm.deleteKeyframeAtFrame and
            hou.ParmTuple.deleteAllKeyframes.


        """
        return _hou.Parm_deleteAllKeyframes(self)

    def getReferencedParm(self) -> "HOM_Parm *":
        r"""

        getReferencedParm(self) -> hou.Parm

            Returns the referenced parameter. If no parameter is referenced,
            returns this parameter.


        """
        return _hou.Parm_getReferencedParm(self)

    def parmsReferencingThis(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        parmsReferencingThis(self) -> tuple of hou.Parm

            Return a tuple of all the parameters in the scene that have channel
            references to this parameter.


        """
        return _hou.Parm_parmsReferencingThis(self)

    def isLocked(self) -> "bool":
        r"""

        isLocked(self) -> bool

            Returns whether this parameter is locked (uneditable).


        """
        return _hou.Parm_isLocked(self)

    def lock(self, on: "bool") -> "void":
        r"""

        lock(self, on)

            Locks (lock(True)) or unlocks (lock(False)) this parameter (this is,
            makes the value uneditable).

            Raises hou.PermissionError if this parameter is part of a locked
            digital asset.


        """
        return _hou.Parm_lock(self, on)

    def isAutoscoped(self) -> "bool":
        r"""

        isAutoscoped(self) -> bool

            Returns whether this parameter's autoscope property is on.


        """
        return _hou.Parm_isAutoscoped(self)

    def setAutoscope(self, on: "bool") -> "void":
        r"""

        setAutoscope(self, on)

            Changes the autoscope property of the parameter. If this property is
            on, this parameter is automatically scoped when the object is
            selected.


        """
        return _hou.Parm_setAutoscope(self, on)

    def isScoped(self) -> "bool":
        r"""

        isScoped(self) -> bool

            Returns whether this parameter's channel is scoped. If it is scoped,
            then it is loaded in the animation editor.


        """
        return _hou.Parm_isScoped(self)

    def setScope(self, on: "bool") -> "void":
        r"""

        setScope(self, on)

            Changes the scope property of this parameter's channel, which
            affects whether it is loaded in the animation editor.


        """
        return _hou.Parm_setScope(self, on)

    def isAutoSelected(self) -> "bool":
        r"""

        isAutoSelected(self) -> bool

            Returns whether this parameter's autoselect property is on.


        """
        return _hou.Parm_isAutoSelected(self)

    def setAutoSelect(self, on: "bool") -> "void":
        r"""

        setAutoSelect(self, on)

            Changes the autoselect property of the parameter. If this property
            is on, this parameter defines the default selection state when it is
            displayed in the animation editor.


        """
        return _hou.Parm_setAutoSelect(self, on)

    def isSelected(self) -> "bool":
        r"""

        isSelected(self) -> bool

            Returns whether this parameter's channel is selected. If it is
            selected, then it is selected in the animation editor.


        """
        return _hou.Parm_isSelected(self)

    def setSelect(self, on: "bool") -> "void":
        r"""

        setSelect(self, on)

            Changes the select property of this parameter's channel, which
            affects whether it is selected in the animation editor.


        """
        return _hou.Parm_setSelect(self, on)

    def alias(self) -> "std::string":
        r"""

        alias(self) -> str

            Returns the parameter's channel alias name. Returns an empty string
            if no such name exists.


        """
        return _hou.Parm_alias(self)

    def setAlias(self, alias_name: "char const *") -> "void":
        r"""

        setAlias(self, alias_name)

            Gives the parameter another name by which it can be referenced in
            channels. You can pass in an empty string to remove an existing
            alias name.


        """
        return _hou.Parm_setAlias(self, alias_name)

    def isSpare(self) -> "bool":
        r"""

        isSpare(self) -> bool

            Returns whether this parameter is a spare (user-defined) parameter.


        """
        return _hou.Parm_isSpare(self)

    def isTimeDependent(self) -> "bool":
        r"""

        isTimeDependent(self) -> bool

            Returns whether this parameter is time dependent, that is, its value
            changes depending on the point on the timeline at which it's
            evaluated. For example the parameter has an expression containing
            the $F (current frame number) variable.


        """
        return _hou.Parm_isTimeDependent(self)

    def isMultiParmInstance(self) -> "bool":
        r"""

        isMultiParmInstance(self) -> bool

            Return whether this parameter is an instance of a multi parm. For
            example, the pt0x, pt1x, pt2x, etc. parameters in an add SOP are
            instances of a multiparm.


        """
        return _hou.Parm_isMultiParmInstance(self)

    def isMultiParmParent(self) -> "bool":
        r"""

        isMultiParmParent(self) -> bool

            Return whether this parameter is a parent multi parm, ie: the number
            of instances parameter.


        """
        return _hou.Parm_isMultiParmParent(self)

    def parentMultiParm(self) -> "HOM_Parm *":
        r"""

        parentMultiParm(self) -> hou.Parm

            Return the parent multi-parameter if this parameter is a multi-
            parameter instance and None otherwise.


        """
        return _hou.Parm_parentMultiParm(self)

    def multiParmInstanceIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        multiParmInstanceIndices(self) -> tuple of int

            If this parameter is a multi-parameter instance, then return a tuple
            of indices of where the parameter appears in the multi-parameter
            block and any nested blocks. Indices for outer multi-parameter
            blocks are listed first.

            For example if this parameter appears as the fourth instance in the
            multi-parameter block then (3,) is returned.

            As another example if this parameter appears as the third instance
            in the multi-parameter block and the block itself appears as the
            first instance of an outer multi-parameter block then (0, 2) is
            returned.


        """
        return _hou.Parm_multiParmInstanceIndices(self)

    def multiParmInstancesPerItem(self) -> "int":
        r"""

        multiParmInstancesPerItem(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
        return _hou.Parm_multiParmInstancesPerItem(self)

    def multiParmInstancesCount(self) -> "int":
        r"""

        multiParmInstancesCount(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
        return _hou.Parm_multiParmInstancesCount(self)

    def multiParmStartOffset(self) -> "int":
        r"""

        multiParmStartOffset(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return the starting index used when building multi
            parameter names. The default value is 1.

            Returns 0 if this parameter is not for a multiparm.


        """
        return _hou.Parm_multiParmStartOffset(self)

    def multiParmInstances(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Parm >,std::allocator< HOM_ElemPtr< HOM_Parm > > >":
        r"""

        multiParmInstances(self) -> tuple of hou.Parm

            If this parameter corresponds to the number of instances for a
            multiparm, return all the parameters corresponding to all instances
            of this multiparm.

            Returns an empty tuple if this parameter is not for a multiparm.


        """
        return _hou.Parm_multiParmInstances(self)

    def insertMultiParmInstance(self, inst_index: "int") -> "void":
        r"""

        insertMultiParmInstance(self, index)

            Insert a new multi parm instance before the given index. To append a
            new multi parm instance, set the index to be the current number of
            instances. The current number can be queried by calling evalAsInt on
            the this parameter.


        """
        return _hou.Parm_insertMultiParmInstance(self, inst_index)

    def removeMultiParmInstance(self, inst_index: "int") -> "void":
        r"""

        removeMultiParmInstance(self, index)

            Removes the multi parm instance at the given index.


        """
        return _hou.Parm_removeMultiParmInstance(self, inst_index)

    def containingFolders(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        containingFolders(self) -> tuple of str

            Returns a tuple of strings corresponding to the names of the folders
            containing this parameter.

            For example, if this parameter is in the Shading folder and the
            Shading folder is inside the Render folder, this method will return
            (Render, Shading). Note that by folder name, we mean the label used
            in the parameter dialog, not the internal parameter name.

            Returns an empty tuple if this parameter is not inside a folder.

            Note that calling this method on many parameters may be slow. For a
            faster alternative, see hou.Node.parmsInFolder.

            See also the containingFolderSetParmTuples method, and
            hou.Node.parmTuplesInFolder.


        """
        return _hou.Parm_containingFolders(self)

    def containingFolderIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        containingFolderIndices(self) -> tuple of int

            Return a tuple of indices corresponding to the folders containing
            this parameter. Each index refers to a folder in the corresponding
            folder set parameter.

            This method can be implemented as follows:

          > def containingFolderIndices(self):
          > return tuple(
          >     list(folder_set_parm_tuple.parmTemplate().folderNames()).index(
          >     folder_name)
          >     for folder_set_parm_tuple, folder_name in zip(
          >     parm.containingFolderSetParmTuples(), parm.containingFolders()))

            This example makes a parameter visible in the parameter pane by
            opening all the folders containing it.

          > def makeParmVisible(parm):
          > for folder_set_parm_tuple, folder_index in zip(
          >     parm.containingFolderSetParmTuples(),
          >     parm.containingFolderIndices()):
          >     folder_set_parm_tuple[0].set(folder_index)

        """
        return _hou.Parm_containingFolderIndices(self)

    def containingFolderSetParmTuples(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        r"""

        containingFolderSetParmTuples(self) -> tuple of hou.ParmTuple

            Return a tuple of ParmTuples corresponding to the folders containing
            this parameter.

            For example, if this parameter is in the Shading folder and the
            Shading folder is inside the Render folder, this method will return
            a tuple containing the Render parm tuple and the Shading parm tuple.
            Any parm tuples returned will be folder sets.

            If this parameter is not inside a folder, an empty tuple is
            returned.

            See also the containingFolders() method, and hou.Node.parmsInFolder
            and hou.Node.parmTuplesInFolder.


        """
        return _hou.Parm_containingFolderSetParmTuples(self)

    def asCode(
        self,
        brief: "bool" = False,
        save_values: "bool" = True,
        save_keyframes: "bool" = True,
        save_keys_in_frames: "bool" = False,
        save_flag_values: "bool" = True,
        save_aliases: "bool" = True,
        function_name: "char const *" = None,
    ) -> "std::string":
        r"""

        asCode(self, brief=False, save_values=True, save_keyframes=True,
        save_keys_in_frames=False, save_flag_values=True, save_aliases=True,
        function_name=None) -> str

            Returns a script of Python statements that can be executed to set
            the parameter tuple's values, flags and other properties. To run the
            script, use either Python's exec or execfile functions.


            brief
                When <brief> is True, the output script omits commands for
                setting values and flags that are set to the factory defaults.
                The script also omits keyframe commands that set unused values,
                slopes and accelerations. The value of <brief> must be either
                True or False. save_values: When <save_values> is True, asCode
                outputs commands for setting the parameter tuple's values. The
                value of <save_values> must be either True or False.

            save_keyframes
                When <save_keyframes> is True, asCode outputs commands for
                creating the parameter tuple's keyframes (if any). The value of
                <save_keyframes> must be either True or False.

            save_keys_in_frames
                When <save_keys_in_frames> is True, asCode outputs commands for
                setting channel and key times in samples (frames) instead of
                seconds. This parameter has no effect if <save_keyframes> is set
                to False. The value of <save_keys_in_frames> must be either True
                or False.

            save_flag_values
                When <save_flag_values> is True, asCode outputs commands for
                setting the parameter tuple's flag values. The value of
                <save_flag_values> must be either True or False.

            save_aliases
                When <save_aliases> is True, asCode outputs commands for setting
                the parameter tuple's channel aliases. The value of
                <save_aliases> must be either True or False.

            function_name
                If <function_name> is specified, then the output script is
                wrapped in a Python function definition with the given name.
                <function_name> must be a non-zero length string consisting of
                only alphanumeric and underscore characters. Any invalid
                characters are internally converted to underscores.

            The wrapper function takes in a single argument which must be a
            reference to an existing node parameter tuple. For symmetry, the
            function also returns the parameter tuple reference.

            Here is an example of saving the output to a file and then loading
            it back into Houdini:

          > # Get a reference to the target parameter tuple.
          > pt = hou.parmTuple(\"/obj/geo1/t\")
          >
          > # Execute asCode and write the output script to file.
          > script = pt.asCode()
          > f = open(\"set_parm_tuple_properties.py\", \"w\")
          > f.write(script)
          > f.close()
          >
          > # Execute the script.  This will set the values, flag values
          > # and other properties on /obj/geo1's t parameter tuple.  It will
          > # also store a reference to the t parameter tuple into a variable
          > # named 'hou_parm_tuple'.
          > execfile(\"set_parm_tuple_properties.py\")

            Here is an example of saving the output into a function and then
            calling it in Houdini:

          > # Get a reference to the target parameter tuple.
          > node = hou.parmTuple(\"/obj/geo1/t\")
          >
          > # Execute asCode and write the function definition to file.
          > func = p.asCode(function_name=\"setParmTupleProperties\")
          > f = open(\"parmtuplelib.py\", \"w\")
          > f.write(func)
          > f.close()
          >
          > # Call the function definition to set the properties on another
          > # parameter tuple.
          > import parmtuplelib
          > hou_parm_tuple = parmtuplelib.setParmTupleProperties(node.parm(\"t\"))

        """
        return _hou.Parm_asCode(
            self,
            brief,
            save_values,
            save_keyframes,
            save_keys_in_frames,
            save_flag_values,
            save_aliases,
            function_name,
        )

    def createClip(
        self,
        parent_node: "Node",
        name: "char const *",
        create_new: "bool",
        apply_immediately: "bool",
        current_value_only: "bool" = False,
        create_locked: "bool" = False,
        set_value_to_default: "bool" = False,
    ) -> "HOM_Node *":
        r"""

        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only, create_locked, set_value_to_default) -> hou.ChopNode

            Creates a Channel CHOP representing this parameter. The Channel CHOP
            is created with the given name as a child of the given parent node.
            The parent_node is typically created via
            hou.Node.findOrCreateMotionEffectsNetwork.

            create_new: Always create a new Channel CHOP. If set to False, then
            if a Channel CHOP already exists with the same name, it will be re-
            used. If the parameter already exists on the Channel CHOP, the older
            parameter will be removed first.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation

            See also hou.Node.findOrCreateMotionEffectsNetwork.


        """
        return _hou.Parm_createClip(
            self,
            parent_node,
            name,
            create_new,
            apply_immediately,
            current_value_only,
            create_locked,
            set_value_to_default,
        )

    def appendClip(
        self,
        chop_node: "Node",
        apply_immediately: "bool",
        current_value_only: "bool" = False,
        create_locked: "bool" = False,
        set_value_to_default: "bool" = False,
    ) -> "void":
        r"""

        appendClip(self, chop_node, apply_immediately, current_value_only,
        create_locked, set_value_to_default)

            Appends this parameter to the specified Channel CHOP.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation


        """
        return _hou.Parm_appendClip(
            self,
            chop_node,
            apply_immediately,
            current_value_only,
            create_locked,
            set_value_to_default,
        )

    def _clipData(
        self,
        start: "double",
        end: "double",
        binary: "bool" = True,
        use_blosc_compression: "bool" = True,
        sample_rate: "double" = 0,
    ) -> "HOM_BinaryString":
        return _hou.Parm__clipData(
            self, start, end, binary, use_blosc_compression, sample_rate
        )

    def _setClipData(self, *args, **kwargs) -> "void":
        return _hou.Parm__setClipData(self, *args, **kwargs)

    def _saveClip(
        self,
        file_name: "std::string",
        start: "double",
        end: "double",
        sample_rate: "double" = 0,
    ) -> "void":
        return _hou.Parm__saveClip(self, file_name, start, end, sample_rate)

    def _loadClip(self, *args, **kwargs) -> "void":
        return _hou.Parm__loadClip(self, *args, **kwargs)

    def overrideTrack(self) -> "HOM_Track *":
        r"""

        overrideTrack(self) -> hou.Track or None

            Returns the CHOP track overriding this parameter, if any.


        """
        return _hou.Parm_overrideTrack(self)

    def isOverrideTrackActive(self) -> "bool":
        r"""

        isOverrideTrackActive(self) -> bool

            Returns True if the CHOP track overriding this parameter is active.


        """
        return _hou.Parm_isOverrideTrackActive(self)

    def copyToParmClipboard(self) -> "void":
        r"""

        copyToParmClipboard(self)

            Copies this to the parameter clipboard. See also
            hou.parmClipboardContents.


        """
        return _hou.Parm_copyToParmClipboard(self)

    def isDisabled(self) -> "bool":
        r"""

        isDisabled(self) -> bool

            Returns the disable state of the parameter, ignoring the lock state.
            This can be used to read the result of a disable-when conditional.

            It is recommended that hou.Node.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
        return _hou.Parm_isDisabled(self)

    def disable(self, on: "bool") -> "void":
        r"""

        disable(self, on)

            Sets the UI disable state of this parameter in its node. This is not
            the same as locking a parameter, as the underlying value can still
            be modified. It's closer to what a disable-when conditional does,
            when a parameter is disabled automatically by it.


        """
        return _hou.Parm_disable(self, on)

    def isHidden(self) -> "bool":
        r"""

        isHidden(self) -> bool

            Returns the hidden state of the parameter. This can be used to read
            the result of a hide-when conditional.

            It is recommended that hou.Node.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
        return _hou.Parm_isHidden(self)

    def hide(self, on: "bool") -> "void":
        r"""

        hide(self, on)

            Sets the UI hidden state of this parameter in its node. Calling this
            method has the same effect as changing the Invisible checkbox on the
            Edit Parameter Interface dialog, or hiding the parameter with a
            hide-when conditional.

            However, changing the UI state with this function is transient and
            does not affect node parameter templates, which means that the new
            state is not saved to .hip file and can be restored when refreshing
            the node to its spare parameter templates.

            To permanently change the UI state of a parameter on a node, please
            use hou.ParmTemplate.hide instead:

          > parms = hou.node('/obj/node').parmTemplateGroup()
          > p = parms.find('lookatpath')
          > p.hide(True)
          > parms.replace('lookatpath', p)
          > hou.node('/obj/node').setParmTemplateGroup(parms)

        """
        return _hou.Parm_hide(self, on)

    def isVisible(self) -> "bool":
        r"""

        isVisible(self) -> bool

            Returns whether or not this parameter would be visible in the
            parameter dialog for this node. It checks both the parameter's
            template, and the hidden state of the parameter. This is equivalent
            to the following code (but runs faster because it avoids creating
            the hou.ParmTemplate):

          > >>> p = hou.parm('/obj/geo1/tx')
          > >>> not p.isHidden() and not p.parmTemplate().isHidden()
          > True

        """
        return _hou.Parm_isVisible(self)

    def isConstrained(self) -> "bool":
        r"""

        isConstrained(self) -> bool

            Returns True if the Parm's parent node is an OBJ that is cooked and
            has constraints.


        """
        return _hou.Parm_isConstrained(self)

    def keyframeExtrapolation(self, before: "bool") -> "HOM_EnumValue &":
        return _hou.Parm_keyframeExtrapolation(self, before)

    def setKeyframeExtrapolation(self, before: "bool", e: "EnumValue") -> "void":
        r"""

        setKeyframeExtrapolation(self, before, extrapol)

            Sets a extrapolation on this parameter for time before the first
            keyframe or after the last keyframe. Extrapolation defines how a
            parm value is evaluated outside the keyframe range.


            before
                If set to true, the extrapolation for evaluations before the
                first keyframe will be set. If set to false, the extrapolation
                for evaluations after the last keyframe will be set.

            extrapol
                A hou.parmExtrapolate enumeration value.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.OperationFailed exception the
            parameter doesn't have a valid animation channel.


        """
        return _hou.Parm_setKeyframeExtrapolation(self, before, e)

    def keyframesRefit(self, *args) -> "void":
        r"""

        keyframesRefit(self, refit, refit_tol, refit_preserve_extrema,
        refit_bezier, resample, resample_rate, resample_tol, range, range_start,
        range_end, bake_chop)

            Performs a refitting operation with resampling and range controls.


            refit
                If set to true, a cubic refitting will be performed with the
                supplied refit options. If set to false, the refitting is
                skipped and only the resampling or range operation will be
                performed.

            refit_tol
                Refit Tolerance in absolute value.

            refit_preserve_extrema
                Preserves the keys that are local minima or maxima.

            refit_bezier
                If True, the new keyframes will be set to use bezier() segments.
                If False, the new keyframes will be set to use cubic() segments.

            resample
                If True, a resampling operation is performed prior to the
                refitting. If False, the channel is used as is.

            resample_rate
                Resample rate in frames. If set to 1.0, a keyframe will be added
                at every frame.

            resample_tol
                Resample Tolerance in frames. If set to 1.0, the resampling
                won't happen if a frame exists within one frame.

            range
                If True, the range_start and range_end arguments are used. It's
                useful when baking cycles when using cycle/cycle offset or
                oscillate channel extrapolation. If False, the channel range
                will be used based on the first and last keyframes.

            range_start
                Start frame of the range.

            range_end
                End frame of the range.

            bake_chop
                A hou.parmBakeChop enumeration value.


        """
        return _hou.Parm_keyframesRefit(self, *args)

    def uiBackgroundColor(self) -> "HOM_Color *":
        r"""

        uiBackgroundColor(self) -> hou.Color

            Returns the background color used to indicate the state of this parm
            in parm dialogs. Raises hou.NotAvailable if there is no UI.


        """
        return _hou.Parm_uiBackgroundColor(self)

    def _moveKeyframes(
        self,
        keyframe_ids: "_IntTuple",
        time_offsets: "_DoubleTuple",
        value_offsets: "_DoubleTuple",
    ) -> "void":
        return _hou.Parm__moveKeyframes(self, keyframe_ids, time_offsets, value_offsets)

    def _deleteKeyframes(self, keyframe_ids: "_IntTuple") -> "void":
        return _hou.Parm__deleteKeyframes(self, keyframe_ids)

    def _moveAllKeyframes(
        self, time_offset: "double", value_offset: "double"
    ) -> "void":
        return _hou.Parm__moveAllKeyframes(self, time_offset, value_offset)

    def eval(self) -> "InterpreterObject":
        r"""

        eval(self) -> int, float, or str

            Evaluates this parameter at the current frame and returns the
            result. See also the evalAtFrame and evalAtTime methods.


        """
        return _hou.Parm_eval(self)

    def evalAtFrame(self, frame: "double") -> "InterpreterObject":
        r"""

        evalAtFrame(self, frame) -> int, float, or str

            Evaluate this parameter at a given frame and return the result as an
            integer, float or string.

            See also evalAtTime.


        """
        return _hou.Parm_evalAtFrame(self, frame)

    def evalAtTime(self, time: "double") -> "InterpreterObject":
        r"""

        evalAtTime(self, time) -> int, float, or str

            Evaluate this parameter at a given time and return the result as an
            integer, float or string.

            See also evalAtFrame.


        """
        return _hou.Parm_evalAtTime(self, time)


# Register Parm in _hou:
_hou.Parm_swigregister(Parm)


class ParameterEditor(PathBasedPaneTab):
    r"""

    hou.ParameterEditor

    Represents a Parameter Editor panetab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ParameterEditor

    def __repr__(self) -> "std::string":
        return _hou.ParameterEditor___repr__(self)

    def scrollPosition(self) -> "HOM_Vector2":
        r"""

        scrollPosition(self) -> hou.Vector2

            Return the Parameter Editor scroll bars position as percentages.


        """
        return _hou.ParameterEditor_scrollPosition(self)

    def setScrollPosition(self, position: "Vector2") -> "void":
        r"""

        setScrollPosition(self,pos)

            Set Parameter Editor scroll bars position as hou.Vector2
            percentages.


        """
        return _hou.ParameterEditor_setScrollPosition(self, position)

    def setFilterEnabled(self, on: "bool") -> "void":
        r"""

        setFilterEnabled(self,on)

            Enable Parameter Editor filtering. hou.parmFilterCriteria.


        """
        return _hou.ParameterEditor_setFilterEnabled(self, on)

    def filterEnabled(self) -> "bool":
        r"""

        filterEnabled(self) -> bool

            Return True if Parameter Editor filtering is enabled.


        """
        return _hou.ParameterEditor_filterEnabled(self)

    def setFilterPattern(self, filter: "char const *") -> "void":
        r"""

        setFilterPattern(self,pattern)

            Set the Parameter Editor filter pattern. The filter pattern is
            applied on a hou.parmFilterCriteria string from parameters that
            match the hou.parmFilterMode. The pattern matching can use exact
            name matching or find the pattern within the string. The filter
            pattern can be a list of pattern separated by commas and can also
            contain wildcard '*' character.


        """
        return _hou.ParameterEditor_setFilterPattern(self, filter)

    def filterPattern(self) -> "std::string":
        r"""

        filterPattern(self) -> str

            Return the Parameter Editor filter pattern.


        """
        return _hou.ParameterEditor_filterPattern(self)

    def setFilterExactMatch(self, on: "bool") -> "void":
        r"""

        setFilterExactMatch(self,on)

            Set Parameter Editor filtering to use exact pattern matching.


        """
        return _hou.ParameterEditor_setFilterExactMatch(self, on)

    def filterExactMatch(self) -> "bool":
        r"""

        filterExactMatch(self) -> bool

            Return True if Parameter Editor filtering uses exact pattern
            matching.


        """
        return _hou.ParameterEditor_filterExactMatch(self)

    def setFilterMode(self, *args) -> "void":
        r"""

        setFilterMode(self,mode)

            Set the Parameter Editor filter mode. The hou.parmFilterMode defines
            on which parameters to apply the filter pattern.


        """
        return _hou.ParameterEditor_setFilterMode(self, *args)

    def filterMode(self) -> "HOM_EnumValue &":
        r"""

        filterMode(self) -> hou.parmFilterMode

            Return the Parameter Editor hou.parmFilterMode.


        """
        return _hou.ParameterEditor_filterMode(self)

    def setFilterCriteria(self, *args) -> "void":
        r"""

        setFilterCriteria(self,criteria)

            Set the Parameter Editor filter criteria. The hou.parmFilterCriteria
            defines how the filter pattern is applied to parameters.


        """
        return _hou.ParameterEditor_setFilterCriteria(self, *args)

    def filterCriteria(self) -> "HOM_EnumValue &":
        r"""

        filterCriteria(self) -> hou.parmFilterCriteria

            Return the Parameter Editor hou.parmFilterCriteria.


        """
        return _hou.ParameterEditor_filterCriteria(self)

    def isShowingParmDialog(self) -> "bool":
        r"""

        isShowingParmDialog(self) -> bool

            Return True if the Parameter Editor is currently displaying a
            parameter dialog (as opposed to, for example, a Python Panel).


        """
        return _hou.ParameterEditor_isShowingParmDialog(self)

    def setShowParmDialog(self, show: "bool") -> "void":
        r"""

        setShowParmDialog(self,show)

            Set the Parameter Editor to display a parameter dialog if show is
            True, and switch to a Python Panel if show is False.

            Raise hou.OperationFailed if the Parameter Editor's current node has
            no corresponding Python Panel interface and show is set to False.


        """
        return _hou.ParameterEditor_setShowParmDialog(self, show)

    def _scrollToParms(self, parms: "char const *") -> "void":
        return _hou.ParameterEditor__scrollToParms(self, parms)

    def _filterParms(self, parms: "char const *") -> "void":
        return _hou.ParameterEditor__filterParms(self, parms)

    def setMultiParmTab(self, parm: "char const *", index: "int") -> "void":
        r"""

        setMultiParmTab(self,parm, tab_index)

            Switch a Multi Parameter Tab to a given tab using a parameter name.


        """
        return _hou.ParameterEditor_setMultiParmTab(self, parm, index)

    def multiParmTab(self, parm: "char const *") -> "int":
        r"""

        multiParmTab(self,parm) -> int

            Returns the currently visible tab index using a parameter name.


        """
        return _hou.ParameterEditor_multiParmTab(self, parm)

    def visibleParms(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        r"""

        visibleParms(self) -> tuple of hou.ParmTuple

            Returns the currently visible parameters.


        """
        return _hou.ParameterEditor_visibleParms(self)


# Register ParameterEditor in _hou:
_hou.ParameterEditor_swigregister(ParameterEditor)


class ParmTuple(object):
    r"""

    hou.ParmTuple

    A tuple of one or more node parameters. Each parameter tuple has a
    unique name within its node.

    The ParmTuple class behaves like a Python sequence, so you can index
    into it using square brackets, iterate over it, call len on it, etc. The
    elements inside the parameter tuple are hou.Parm objects.

    A parameter tuple's name may only contain letters, numbers, and
    underscores. For example, objects contain a parameter tuple named \"t\"
    that contains three integer parameters. The names of the parameters
    inside the tuple are determined from the parameter tuple's name and its
    naming scheme. For example, the \"t\" parameter uses the XYZW naming
    scheme, so the three parameters inside it are named \"tx\", \"ty\", and
    \"tz\". Note that if the parameter tuple only contains one parameter, the
    tuple and the parameter inside it may have the same name.

    In addition to a name, a parameter tuple also has a label that is
    displayed to the user in the parameter dialog. For example, the \"t\"
    parameter's label is \"Translate\". The label may contain spaces and
    punctuation characters.

    Each parameter in a tuple stores a value. Different instances of parm
    tuples in different nodes will store their own set of parameter values.
    The value in a parameter may be animated, in which case the parameter
    evaluates to a different result depending on the current time on the
    playbar. See hou.Keyframe for more information about animated
    parameters.

    Each hou.NodeType has a set of parameter tuple descriptions associated
    with it, and each instance of a hou.Node has a corresponding set of
    parameter tuple instances. The parameter tuples store specific values
    that are saved with the node. The descriptions of the parameter tuples,
    however, are represented by a hou.ParmTemplate. A parameter template
    describes the type, default values, ranges, etc. of a parameter tuple.

    See also hou.parmTuple_ and hou.Node.parmTuple.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ParmTuple

    def __eq__(self, parm_tuple: "HOM_PtrOrNull< HOM_ParmTuple >") -> "bool":
        return _hou.ParmTuple___eq__(self, parm_tuple)

    def __ne__(self, parm_tuple: "HOM_PtrOrNull< HOM_ParmTuple >") -> "bool":
        return _hou.ParmTuple___ne__(self, parm_tuple)

    def __hash__(self) -> "int":
        return _hou.ParmTuple___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.ParmTuple___repr__(self)

    def node(self) -> "HOM_Node *":
        r"""

        node(self) -> hou.Node

            Return the node containing this parameter tuple.


        """
        return _hou.ParmTuple_node(self)

    def parmTemplate(self) -> "HOM_ParmTemplate *":
        r"""

        parmTemplate(self) -> hou.ParmTemplate

            Return this parameter tuple's template.

            Note that a folder parameter will have a hou.FolderSetParmTemplate
            template and a multiparm parameter will have a
            hou.FolderParmTemplate template.


        """
        return _hou.ParmTuple_parmTemplate(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this parameter tuple. Note that the parameter
            tuple's name and its naming scheme determine the names of the
            parameters inside it.

          > >>> node = hou.node(\"/obj\").createNode(\"geo\")
          > >>> node.parmTuple(\"t\").parmTemplate().namingScheme()
          > parmNamingScheme.XYZW
          > >>> [parm.name() for parm in node.parmTuple(\"t\")]
          > ['tx', 'ty', 'tz']
          >
          > >>> parm_tuple = node.parent().createNode(\"cam\").parmTuple(\"dcolor\")
          > >>> parm_tuple.parmTemplate().namingScheme()
          > parmNamingScheme.RGBA
          > >>> [parm.name() for parm in parm_tuple]
          > ['dcolorr', 'dcolorg', 'dcolorb']

        """
        return _hou.ParmTuple_name(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> str

            Return this parameter tuple's label that is displayed in the
            parameter dialog.


        """
        return _hou.ParmTuple_description(self)

    def _set(self, *args) -> "void":
        return _hou.ParmTuple__set(self, *args)

    def setPending(self, *args) -> "void":
        r"""

        setPending(self, values)

            Sets the value of a parameter in the tuple at the current frame and
            marks it as pending if the parameter is keyed.


            values
                A sequence of floats or strings, corresponding to the components
                of this parameter tuple.

            For example, the parameter tuple for translation contains Parm
            objects for translation along each of the axes, tx, ty and tz. If
            set is called with following tuple of floats, (2.5, 4.0, 5.5), then
            the parameter tx with be set to 2.5, ty will be set to 4.0 and tz
            will be set to 5.5.

            Raises hou.InvalidSize if values has a different length than this
            parameter tuple. Raises hou.PermissionError if any of the parameters
            in this parameter tuple are not writable.


        """
        return _hou.ParmTuple_setPending(self, *args)

    def revertToDefaults(self) -> "void":
        r"""

        revertToDefaults(self)

            Changes the value back to the default(s). See also the
            revertToAndRestoreFactoryDefaults() method.


        """
        return _hou.ParmTuple_revertToDefaults(self)

    def revertToAndRestorePermanentDefaults(self) -> "void":
        r"""

        revertToAndRestorePermanentDefaults(self)

            Changes the value back to the defaults that ship with Houdini, and
            restore those defaults.

            See also the revertToDefaults() method.


        """
        return _hou.ParmTuple_revertToAndRestorePermanentDefaults(self)

    def isAtDefault(
        self,
        compare_temporary_defaults: "bool" = True,
        compare_expressions: "bool" = True,
    ) -> "bool":
        r"""

        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool

            Returns whether the parameter tuple is currently at its defaults.

            compare_temporary_defaults: When <compare_temporary_defaults> is
            True, isDefault also checks

            compare_expressions: When <compare_Expressions> is True, isDefault
            compares the actual

            See also the revertToDefaults() and
            revertToAndRestorePermanentDefaults()methods.


        """
        return _hou.ParmTuple_isAtDefault(
            self, compare_temporary_defaults, compare_expressions
        )

    def evalAsFloats(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        evalAsFloats(self) -> tuple of float

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple of floats.

            Raises TypeError if a value cannot be converted to a float.


        """
        return _hou.ParmTuple_evalAsFloats(self)

    def evalAsFloatsAtFrame(
        self, frame: "double"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        evalAsFloatsAtFrame(self, frame) -> tuple of float

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple of floats.

            Raises TypeError if a value cannot be converted to a float.


        """
        return _hou.ParmTuple_evalAsFloatsAtFrame(self, frame)

    def evalAsInts(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        evalAsInts(self) -> tuple of int

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple of integers.

            Raises TypeError if a value cannot be converted to an integer.


        """
        return _hou.ParmTuple_evalAsInts(self)

    def evalAsIntsAtFrame(
        self, frame: "double"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        evalAsIntsAtFrame(self, frame) -> tuple of int

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple of integers.

            Raises TypeError if a value cannot be converted to an integer.


        """
        return _hou.ParmTuple_evalAsIntsAtFrame(self, frame)

    def evalAsStrings(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        evalAsStrings(self) -> tuple of str

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple of strings.

            Raises TypeError if a value cannot be converted to a string.


        """
        return _hou.ParmTuple_evalAsStrings(self)

    def evalAsStringsAtFrame(
        self, frame: "double"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        evalAsStringsAtFrame(self, frame) -> tuple of str

            Evaluates the parameter tuple at a frame and returns the result as a
            tuple of strings.

            Raises TypeError if a value cannot be converted to a string.


        """
        return _hou.ParmTuple_evalAsStringsAtFrame(self, frame)

    def evalAsRamps(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Ramp >,std::allocator< HOM_ElemPtr< HOM_Ramp > > >":
        r"""

        evalAsRamps(self) -> hou.Ramp

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing a hou.Ramp object.

            Raises TypeError if this is not a ramp parameter.


        """
        return _hou.ParmTuple_evalAsRamps(self)

    def evalAsRampsAtFrame(
        self, frame: "double"
    ) -> "std::vector< HOM_ElemPtr< HOM_Ramp >,std::allocator< HOM_ElemPtr< HOM_Ramp > > >":
        r"""

        evalAsRampsAtFrame(self, frame) -> hou.Ramp

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple containing a hou.Ramp object.

            Raises TypeError if this is not a ramp parameter.


        """
        return _hou.ParmTuple_evalAsRampsAtFrame(self, frame)

    def evalAsGeometries(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Geometry >,std::allocator< HOM_ElemPtr< HOM_Geometry > > >":
        r"""

        evalAsGeometries(self) -> tuple of hou.Geometry

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing a hou.Geometry object.

            Raises TypeError if a value cannot be converted to a hou.Geometry.


        """
        return _hou.ParmTuple_evalAsGeometries(self)

    def evalAsGeometriesAtFrame(
        self, frame: "double"
    ) -> "std::vector< HOM_ElemPtr< HOM_Geometry >,std::allocator< HOM_ElemPtr< HOM_Geometry > > >":
        r"""

        evalAsGeometriesAtFrame(self, frame) -> tuple of hou.Geometry

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple containing a hou.Geometry object.

            Raises TypeError if a value cannot be converted to a hou.Geometry.


        """
        return _hou.ParmTuple_evalAsGeometriesAtFrame(self, frame)

    def evalAsJSONMaps(
        self,
    ) -> "std::vector< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >,std::allocator< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > > >":
        r"""

        evalAsJSONMaps(self) -> tuple of dict of str to str

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing JSON map structures (i.e. Python
            dictionary).

            Raises TypeError or hou.OperationFailed if the parameter tuple is
            not a JSON map data parameter tuple.


        """
        return _hou.ParmTuple_evalAsJSONMaps(self)

    def evalAsJSONMapsAtFrame(
        self, frame: "double"
    ) -> "std::vector< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >,std::allocator< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > > >":
        r"""

        evalAsJSONMapsAtFrame(self, frame) -> tuple of dict of str to str

            Evaluates this parameter tuple at a certain frame and returns the
            result as a a tuple containing JSON map structures (i.e. Python
            dictionary).

            Raises TypeError or hou.OperationFailed if the parameter tuple is
            not a JSON map data parameter tuple.


        """
        return _hou.ParmTuple_evalAsJSONMapsAtFrame(self, frame)

    def lock(self, *args) -> "void":
        r"""

        lock(self, bool_values)

            Lock or unlock all the parameters in this tuple. Houdini displays
            locked parameters as disabled and does not let you change their
            values.


            bool_values
                Either a single True or False value to be applied to all
                components of this parameter or a sequence of them where each
                value corresponds to a single component. Where an element of
                bool_values is True, that component will be locked (uneditable),
                and where an element is False, the corresponding component will
                be unlocked (editable).

            For example, the parameter tuple for translation contains Parm
            objects for translation along each of the axes, tx, ty and tz. If
            lock is called with the following tuple of boolean values, (True,
            True, False), then the parameter tx and ty will be locked and made
            non-editable, while tz will be unlocked and made editable.

            Raises hou.InvalidSize if bool_values has a different length than
            this parameter tuple. Raises hou.PermissionError if any of the
            parameters in this parameter tuple are not writable.


        """
        return _hou.ParmTuple_lock(self, *args)

    def setAutoscope(self, bool_values: "_BoolTuple") -> "void":
        r"""

        setAutoscope(self, bool_values)

            Changes the autoscope property of components of this parameter
            tuple.


            bool_values
                A sequence of True or False values, where each value corresponds
                to a component of this parameter. Where an element of
                bool_values is True, that component will be autoscope.

            For example, the parameter tuple for translation contains Parm
            objects for translation along each of the axes, tx, ty and tz. If
            setAutoscope is called with the following tuple of boolean values,
            (True, True, False), then the parameter tx and ty will be
            automatically scoped, while tz will not.

            Raises hou.InvalidSize if values has a different length than this
            parameter tuple. Raises hou.PermissionError if any of the parameters
            in this parameter tuple are not writable.


        """
        return _hou.ParmTuple_setAutoscope(self, bool_values)

    def isSpare(self) -> "bool":
        r"""

        isSpare(self) -> bool

            Returns whether the parameter is a spare (user-defined) parameter.


        """
        return _hou.ParmTuple_isSpare(self)

    def isTimeDependent(self) -> "bool":
        r"""

        isTimeDependent(self) -> bool

            Returns whether any of the parameters in the tuple are time
            dependent, that is, a parameter's value changes depending on the
            point on the timeline at which it's evaluated. For example the
            parameter has an expression containing the $F (current frame number)
            variable.


        """
        return _hou.ParmTuple_isTimeDependent(self)

    def isMultiParmInstance(self) -> "bool":
        r"""

        isMultiParmInstance(self) -> bool

            Return whether this parameter is an instance of a multi parm. For
            example, the pt0, pt1, pt2, etc. parameter tuples in an add SOP are
            instances of a multiparm.


        """
        return _hou.ParmTuple_isMultiParmInstance(self)

    def isMultiParmParent(self) -> "bool":
        r"""

        isMultiParmParent(self) -> bool

            Return whether this parameter is a parent multi parm, the number of
            instances parameter or returns None otherwise


        """
        return _hou.ParmTuple_isMultiParmParent(self)

    def parentMultiParm(self) -> "HOM_Parm *":
        r"""

        parentMultiParm(self) -> hou.Parm

            Return the parent multi-parameter if this parameter is a multi-
            parameter instance and None otherwise.


        """
        return _hou.ParmTuple_parentMultiParm(self)

    def multiParmInstanceIndices(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        multiParmInstanceIndices(self) -> tuple of int

            If this parameter is a multi-parameter instance, then return a tuple
            of indices of where the parameter appears in the multi-parameter
            block and any nested blocks. Indices for outer multi-parameter
            blocks are listed first.

            For example if this parameter appears as the fourth instance in the
            multi-parameter block then (3,) is returned.

            As another example if this parameter appears as the third instance
            in the multi-parameter block and the block itself appears as the
            first instance of an outer multi-parameter block then (0, 2) is
            returned.


        """
        return _hou.ParmTuple_multiParmInstanceIndices(self)

    def multiParmInstancesPerItem(self) -> "int":
        r"""

        multiParmInstancesPerItem(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
        return _hou.ParmTuple_multiParmInstancesPerItem(self)

    def multiParmInstancesCount(self) -> "int":
        r"""

        multiParmInstancesCount(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
        return _hou.ParmTuple_multiParmInstancesCount(self)

    def multiParmStartOffset(self) -> "int":
        r"""

        multiParmStartOffset(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return the starting index used when building multi
            parameter names. The default value is 1.

            Returns 0 if this parameter is not for a multiparm.


        """
        return _hou.ParmTuple_multiParmStartOffset(self)

    def multiParmInstances(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        r"""

        multiParmInstances(self) -> tuple of hou.ParmTuple

            If this parameter corresponds to the number of instances for a
            multiparm, return all the parameter tuples corresponding to all
            instances of this multiparm.

            Returns an empty tuple if this parameter is not for a multiparm.


        """
        return _hou.ParmTuple_multiParmInstances(self)

    def containingFolders(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.ParmTuple_containingFolders(self)

    def containingFolderIndices(self) -> "std::vector< int,std::allocator< int > >":
        return _hou.ParmTuple_containingFolderIndices(self)

    def containingFolderSetParmTuples(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        return _hou.ParmTuple_containingFolderSetParmTuples(self)

    def setKeyframe(
        self,
        keyframes: "std::vector< HOM_BaseKeyframe *,std::allocator< HOM_BaseKeyframe * > > const &",
    ) -> "void":
        r"""

        setKeyframe(self, keyframe_vector)

            Sets a keyframe on this parameter.


            keyframe_vector
                A sequence of keyframes for each component of the parameter
                tuple.

            Raises TypeError if keyframe is not of type hou.BaseKeyframe. Raises
            hou.PermissionError if this parameter is not writable. Raises
            hou.InvalidSize if keyframe_vector has a different length than this
            parameter tuple.


        """
        return _hou.ParmTuple_setKeyframe(self, keyframes)

    def deleteKeyframeAtFrame(self, frame: "double") -> "void":
        r"""

        deleteKeyframeAtFrame(self, frame)

            Removes a keyframe from this parameter tuple at the given frame.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.OperationFailed exception the
            parameter doesn't have a keyframe at the given frame.

            See also hou.ParmTuple.deleteAllKeyframes.


        """
        return _hou.ParmTuple_deleteKeyframeAtFrame(self, frame)

    def deleteAllKeyframes(self) -> "void":
        r"""

        deleteAllKeyframes(self)

            Remove all the keyframes from this parameter tuple.

            This method be approximately implemented as follows:

          > def deleteAllKeyframes(self):
          > for parm in self:
          >     parm.deleteAllKeyframes()

            See also hou.Parm.deleteAllKeyframes.


        """
        return _hou.ParmTuple_deleteAllKeyframes(self)

    def __getitem__(self, index: "int") -> "HOM_Parm *":
        r"""

        __getitem__(self, index) -> hou.Parm

            Return the Parm object for the specified component of this parameter
            tuple. Negative indices will index from the end.

            This method makes instances of this class appear like a tuple, and
            lets you iterate over the parms in a ParmTuple.

            Raises IndexError if the index is not valid.

          > >>> parm_tuple = hou.node(\"/obj\").createNode(\"geo\").parmTuple(\"t\")
          > >>> for parm in parm_tuple:
          > ...     print parm.name(),
          > tx ty tz
          > >>> tuple(parm_tuple)
          > (<hou.Parm tx in /obj/geo1>, <hou.Parm ty in /obj/geo1>, <hou.Parm tz in /obj/geo1>)

        """
        return _hou.ParmTuple___getitem__(self, index)

    def __len__(self) -> "int":
        r"""

        __len__(self) -> int

            Return the number of hou.Parms in this parameter tuple.


        """
        return _hou.ParmTuple___len__(self)

    def createClip(
        self,
        parent_node: "Node",
        name: "char const *",
        create_new: "bool",
        apply_immediately: "bool",
        current_value_only: "bool" = False,
        create_locked: "bool" = False,
        set_value_to_default: "bool" = False,
    ) -> "HOM_Node *":
        r"""

        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only, create_locked, set_value_to_default) -> hou.ChopNode

            Creates a Channel CHOP representing this parameter. The Channel CHOP
            is created with the given name as a child of the given parent node.
            The parent_node is typically created via
            hou.Node.findOrCreateMotionEffectsNetwork.

            create_new: Always create a new Channel CHOP. If set to False, then
            if a Channel CHOP already exists with the same name, it will be re-
            used. If the parameter already exists on the Channel CHOP, the older
            parameter will be removed first.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation

            See also hou.Node.findOrCreateMotionEffectsNetwork.


        """
        return _hou.ParmTuple_createClip(
            self,
            parent_node,
            name,
            create_new,
            apply_immediately,
            current_value_only,
            create_locked,
            set_value_to_default,
        )

    def appendClip(
        self,
        chop_node: "Node",
        apply_immediately: "bool",
        current_value_only: "bool" = False,
        create_locked: "bool" = False,
        set_value_to_default: "bool" = False,
    ) -> "void":
        r"""

        appendClip(self, chop_node, apply_immediately, current_value_only,
        create_locked, set_value_to_default)

            Appends this parameter to the specified Channel CHOP.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation


        """
        return _hou.ParmTuple_appendClip(
            self,
            chop_node,
            apply_immediately,
            current_value_only,
            create_locked,
            set_value_to_default,
        )

    def _clipData(
        self,
        start: "double",
        end: "double",
        binary: "bool" = True,
        use_blosc_compression: "bool" = True,
        sample_rate: "double" = 0,
    ) -> "HOM_BinaryString":
        return _hou.ParmTuple__clipData(
            self, start, end, binary, use_blosc_compression, sample_rate
        )

    def _setClipData(self, *args, **kwargs) -> "void":
        return _hou.ParmTuple__setClipData(self, *args, **kwargs)

    def _saveClip(
        self,
        file_name: "std::string",
        start: "double",
        end: "double",
        sample_rate: "double" = 0,
    ) -> "void":
        return _hou.ParmTuple__saveClip(self, file_name, start, end, sample_rate)

    def _loadClip(self, *args, **kwargs) -> "void":
        return _hou.ParmTuple__loadClip(self, *args, **kwargs)

    def copyToParmClipboard(self) -> "void":
        r"""

        copyToParmClipboard(self)

            Copies this to the parameter clipboard. See also
            hou.parmClipboardContents.


        """
        return _hou.ParmTuple_copyToParmClipboard(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.ParmTuple__asVoidPointer(self)

    def asCode(
        self,
        brief: "bool" = False,
        save_values: "bool" = True,
        save_keyframes: "bool" = True,
        save_keys_in_frames: "bool" = False,
        save_flag_values: "bool" = True,
        save_aliases: "bool" = True,
        function_name: "char const *" = None,
    ) -> "std::string":
        return _hou.ParmTuple_asCode(
            self,
            brief,
            save_values,
            save_keyframes,
            save_keys_in_frames,
            save_flag_values,
            save_aliases,
            function_name,
        )

    def help(self) -> "std::string":
        return _hou.ParmTuple_help(self)

    def helpUrl(self) -> "std::string":
        return _hou.ParmTuple_helpUrl(self)

    def isDisabled(self) -> "bool":
        r"""

        isDisabled(self) -> bool

            Returns the disable state of the parameter tuple, ignoring the lock
            state. This can be used to read the result of a disable-when
            conditional.

            It is recommended that hou.Node.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
        return _hou.ParmTuple_isDisabled(self)

    def disable(self, on: "bool") -> "void":
        r"""

        disable(self, on)

            Sets the UI disable state of this parameter tuple in its node. This
            is not the same as locking a parameter, as the underlying value can
            still be modified. It's closer to what a disable-when conditional
            does, when a parameter is disabled automatically by it.


        """
        return _hou.ParmTuple_disable(self, on)

    def isHidden(self) -> "bool":
        r"""

        isHidden(self) -> bool

            Returns the hidden state of the parameter tuple. This can be used to
            read the result of a hide-when conditional.

            It is recommended that hou.Node.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
        return _hou.ParmTuple_isHidden(self)

    def hide(self, on: "bool") -> "void":
        r"""

        hide(self, on)

            Sets the UI hidden state of this parameter tuple in its node.
            Calling this method is equivalent to changing the Invisible checkbox
            on the Edit Parameter Interface dialog, or hiding the parameter with
            a hide-when conditional.

            To hide a folder, use hou.Node.setParmTemplateGroup. This method
            cannot be used to hide a folder because a parm tuple corresponds to
            a set of folders, not an individual folder.

            To change the visibility of all new instances of the node type
            defined by a digital asset, use
            hou.HDADefinition.setParmTemplateGroup as in the following example:

          > def showParmTupleInDefinition(parm_tuple, visible):
          >     '''parm_tuple is a hou.ParmTuple on an instance of the digital asset.'''
          >     definition = parm_tuple.node().type().definition()
          >     parm_template_group = definition.parmTemplateGroup()
          >     parm_template = parm_template_group.find(parm_tuple.name())
          >     parm_template.hide(not visible)
          >     parm_template_group.replace(parm_tuple.name(), parm_template)
          >     definition.setParmTemplateGroup(parm_template_group)

        """
        return _hou.ParmTuple_hide(self, on)

    def isConstrained(self) -> "bool":
        return _hou.ParmTuple_isConstrained(self)

    def isShowingExpression(self) -> "bool":
        return _hou.ParmTuple_isShowingExpression(self)

    def showExpression(self, value: "bool") -> "void":
        return _hou.ParmTuple_showExpression(self, value)

    def eval(self) -> "InterpreterObject":
        r"""

        eval(self) -> tuple of int, float, str, or hou.Ramp

            Evalute this parameter tuple at the current frame and returns the
            result as a tuple of integers, floats or strings, or a hou.Ramp
            object, depending on the type of the parameter.

            See also the evalAtFrame and evalAtTime methods.


        """
        return _hou.ParmTuple_eval(self)

    def evalAtFrame(self, frame: "double") -> "InterpreterObject":
        r"""

        evalAtFrame(self, frame) -> tuple of int, float, str, or hou.Ramp

            Evalute the parameter tuple at a given frame and return the result
            as a tuple of integers, floats, strings, or a Ramp object, depending
            on the type of the parameter.

            See also evalAtTime.


        """
        return _hou.ParmTuple_evalAtFrame(self, frame)

    def evalAtTime(self, time: "double") -> "InterpreterObject":
        r"""

        evalAtTime(self, time) -> tuple of int, float, str, or hou.Ramp

            Evalute the parameter tuple at a given time and return the result as
            a tuple of integers, floats, strings, or a Ramp object, depending on
            the type of the parameter.

            See also evalAtFrame.


        """
        return _hou.ParmTuple_evalAtTime(self, time)


# Register ParmTuple in _hou:
_hou.ParmTuple_swigregister(ParmTuple)


class perfMon(object):
    r"""

    hou.perfMon

    Module containing performance monitor related functions.

    RELATED

      * hou.PerfMonProfile

      * hou.PerfMonEvent

      * hou.PerfMonRecordOptions

      * Performance monitor pane


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_perfMon

    def __repr__(self) -> "std::string":
        return _hou.perfMon___repr__(self)

    def startProfile(
        self, title: "char const *", options: "PerfMonRecordOptions" = None
    ) -> "HOM_PerfMonProfile *":
        r"""

        startProfile(title, options=None) -> hou.PerfMonProfile

            Create a new profile and start it so that it can record events. When
            the profile is stopped, it will generate statistics for the events
            that it recorded.


            options
                A hou.PerfMonRecordOptions object that specifies the types of
                Houdini events and statistics to record. If None is passed in or
                if the options argument is not specified, then the profile will
                record all events and statistics.


        """
        return _hou.perfMon_startProfile(self, title, options)

    def loadProfile(self, file_path: "char const *") -> "HOM_PerfMonProfile *":
        r"""

        loadProfile(file_path) -> hou.PerfMonProfile

            Load a profile from disk and return the loaded profile.

            Raises hou.OperationFailed if file_path points to a file that does
            not exist or is not a valid Houdini performance monitor profile
            file.


        """
        return _hou.perfMon_loadProfile(self, file_path)

    def activeProfile(self) -> "HOM_PerfMonProfile *":
        r"""

        activeProfile() -> hou.PerfMonProfile or None

            Return the profile currently visible in the performance monitor
            pane, or


        """
        return _hou.perfMon_activeProfile(self)

    def startTimedEvent(
        self, description: "char const *", auto_nest_events: "bool" = True
    ) -> "HOM_PerfMonEvent *":
        r"""

        startTimedEvent(description, auto_nest_events=True) -> hou.PerfMonEvent

            This method is deprecated in favor of startEvent.


        """
        return _hou.perfMon_startTimedEvent(self, description, auto_nest_events)

    def startEvent(
        self, description: "char const *", auto_nest_events: "bool" = True
    ) -> "HOM_PerfMonEvent *":
        r"""

        startEvent(description, auto_nest_events=True) -> hou.PerfMonEvent

            Create a generic event and start it. When the event is stopped, it
            will be logged by the performance monitor and added to any profiles
            that are recording script or memory statistics.

            Use this function to time and measure memory growth in generic
            scripts, functions or code blocks.

            Return the new event.


            description
                The description of the event that you are starting. For example,
                this can be a function name or a script name or a description of
                a code block.

            auto_nest_events
                If set to True, the event will automatically 'nest' other events
                that are started and stopped while this event is running. When
                the event is stopped, it will decrement the times and memory of
                its nested events from its total time and memory. That way, the
                event's total time and memory will reflect the work performed in
                the event itself and not in any of its nested events.

            Raises hou.OperationFailed if description is an empty string.


        """
        return _hou.perfMon_startEvent(self, description, auto_nest_events)

    def startTimedCookEvent(
        self, description: "char const *", node: "Node"
    ) -> "HOM_PerfMonEvent *":
        r"""

        startTimedCookEvent(description, node) -> hou.PerfMonEvent

            This method is deprecated in favor of startCookEvent.


        """
        return _hou.perfMon_startTimedCookEvent(self, description, node)

    def startCookEvent(
        self, description: "char const *", node: "Node"
    ) -> "HOM_PerfMonEvent *":
        r"""

        startCookEvent(description, node) -> hou.PerfMonEvent

            Create an event that is related to node cooking and start it. When
            the event is stopped, it will be logged by the performance monitor
            and added to any profiles that are recording cook or memory
            statistics.

            Use this function to time code blocks and measure memory growth in
            the Code section of Python operators.

            Return the cook event.


            description
                The description of the event that you are timing. For example,
                this can be a function name or a description of a code block.

            node
                The node that the timed event applies to. This must be a
                hou.Node object. When calling startCookEvent() from within the
                Code section of a Python operator, set node to the current node
                (i.e. hou.pwd()).

            Raises hou.OperationFailed if description is an empty string or if
            node does not exist.


        """
        return _hou.perfMon_startCookEvent(self, description, node)

    def startPaneEvent(
        self, panetype: "char const *", operation: "char const *"
    ) -> "HOM_PerfMonEvent *":
        r"""

        startPaneEvent(panetype, operation) -> hou.PerfMonEvent

            Create an event that is related to the operation of a scriped pane
            and start it. When the event is stopped, it will be logged by the
            performance monitor and added to any profiles that are recording
            cook or memory statistics.

            Use this function to time code blocks and measure memory growth in
            the code for python panels.

            Return the cook event.


            panetype
                A description of the python panel running this code.

            operation
                The specific operation being timed by this event.

            Raises hou.OperationFailed if either panetype or operation are empty
            strings.


        """
        return _hou.perfMon_startPaneEvent(self, panetype, operation)

    def isRecording(self) -> "bool":
        r"""

        isRecording() -> bool

            Return True if the performance monitor is recording Houdini events.


        """
        return _hou.perfMon_isRecording(self)


# Register perfMon in _hou:
_hou.perfMon_swigregister(perfMon)


class PerfMonEvent(object):
    r"""

    hou.PerfMonEvent

    Represents an event that is recorded by the performance monitor and used
    to generate time and memory growth statistics for profiles.

    Note that all methods in this class may raise an hou.OperationFailed
    exception if the event was not actually recorded in the Performance
    Monitor. This can happen if hou.perfMon.startEvent or
    hou.perfMon.startCookEvent was called when the Performance Monitor was
    not recording.


    NOTE
        The stopTime(), memory() and time() methods have been removed.
        Memory and time values are now returned by the stop() method.

    RELATED

      * hou.perfMon

      * hou.PerfMonProfile

      * hou.PerfMonRecordOptions

      * Performance monitor pane


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PerfMonEvent

    def __repr__(self) -> "std::string":
        return _hou.PerfMonEvent___repr__(self)

    def id(self) -> "int":
        r"""

        id(self) -> int

            Return the event's unique identifier which is used internally by the
            performance monitor.

            This method is deprecated.


        """
        return _hou.PerfMonEvent_id(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the event name.

            This method is deprecated.


        """
        return _hou.PerfMonEvent_name(self)

    def object(self) -> "std::string":
        r"""

        object(self) -> str

            Return the object that the event applies to. Return None if the
            event is not associated with an object.


        """
        return _hou.PerfMonEvent_object(self)

    def isAutoNestEnabled(self) -> "bool":
        r"""

        isAutoNestEnabled(self) -> bool

            Return True if the event will automatically 'nest' other events that
            are started and stopped while this event is running. When the event
            is stopped, it will decrement the times and memory of its nested
            events from its total time and memory. That way, the event's total
            time and memory will reflect the work performed in the event itself
            and not in any of its nested events.


        """
        return _hou.PerfMonEvent_isAutoNestEnabled(self)

    def stop(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        stop(self)

            Stop the event timer and return a 2-tuple, (<time>, <memory>),
            containing the event's elapsed time and memory growth.

            The elapsed time is the number of milliseconds that the event was
            timing for. The memory growth is the increase in memory usage by
            Houdini (in bytes) from when the event started and when it stopped.

            If the event was not recording memory, then the returned memory
            value is 0.0. Likewise, if the event was not recording time, then
            the returned time value is 0.0.

            Raises hou.OperationFailed if the event is already stopped.


        """
        return _hou.PerfMonEvent_stop(self)

    def isTiming(self) -> "bool":
        r"""

        isTiming(self) -> bool

            This method is deprecated in favor of isRunning.


        """
        return _hou.PerfMonEvent_isTiming(self)

    def isRunning(self) -> "bool":
        r"""

        isRunning(self) -> bool

            Return true if the event is running, that is, if the event has been
            started but not stopped.


        """
        return _hou.PerfMonEvent_isRunning(self)

    def startTime(self) -> "double":
        r"""

        startTime(self) -> float

            Return the start time of the event in milliseconds since the epoch
            date.

            Raises hou.OperationFailed if the event does not contain any time
            data. This can happen if the event was started when the Performance
            Monitor was not recording any time statistics.


        """
        return _hou.PerfMonEvent_startTime(self)

    def __enter__(self) -> "HOM_PerfMonEvent *":
        return _hou.PerfMonEvent___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.PerfMonEvent___exit__(self, type, value, traceback)


# Register PerfMonEvent in _hou:
_hou.PerfMonEvent_swigregister(PerfMonEvent)


class PerfMonProfile(object):
    r"""

    hou.PerfMonProfile

    Represents a performance monitor profile.

    RELATED

      * hou.perfMon

      * hou.PerfMonEvent

      * hou.PerfMonRecordOptions

      * Performance monitor pane


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PerfMonProfile

    def __repr__(self) -> "std::string":
        return _hou.PerfMonProfile___repr__(self)

    def id(self) -> "int":
        r"""

        id(self) -> int

            Return the profile's unique identifier which is used internally by
            the performance monitor.


        """
        return _hou.PerfMonProfile_id(self)

    def title(self) -> "std::string":
        r"""

        title(self) -> str

            Return the profile title.


        """
        return _hou.PerfMonProfile_title(self)

    def isActive(self) -> "bool":
        r"""

        isActive(self) -> bool

            Return True if the profile is either recording events or is paused.


        """
        return _hou.PerfMonProfile_isActive(self)

    def isPaused(self) -> "bool":
        r"""

        isPaused(self) -> bool

            Return True if the profile is paused from recording.


        """
        return _hou.PerfMonProfile_isPaused(self)

    def isRecordingCookStats(self) -> "bool":
        r"""

        isRecordingCookStats(self) -> bool

            Return True if the profile is recording cook events and statistics.


        """
        return _hou.PerfMonProfile_isRecordingCookStats(self)

    def isRecordingPDGCookStats(self) -> "bool":
        r"""

        isRecordingPDGCookStats(self) -> bool

            Return True if the profile is recording PDG node cook events and
            statistics.


        """
        return _hou.PerfMonProfile_isRecordingPDGCookStats(self)

    def isRecordingSolveStats(self) -> "bool":
        r"""

        isRecordingSolveStats(self) -> bool

            Return True if the profile is recording simulation solver events and
            statistics.


        """
        return _hou.PerfMonProfile_isRecordingSolveStats(self)

    def isRecordingDrawStats(self) -> "bool":
        r"""

        isRecordingDrawStats(self) -> bool

            Return True if the profile is recording draw events and statistics.


        """
        return _hou.PerfMonProfile_isRecordingDrawStats(self)

    def isRecordingGPUDrawStats(self) -> "bool":
        r"""

        isRecordingGPUDrawStats(self) -> bool

            Return True if the profile is recording GPU draw events and
            statistics.


        """
        return _hou.PerfMonProfile_isRecordingGPUDrawStats(self)

    def isRecordingViewportStats(self) -> "bool":
        r"""

        isRecordingViewportStats(self) -> bool

            Return True if the profile is recording viewport events and
            statistics.


        """
        return _hou.PerfMonProfile_isRecordingViewportStats(self)

    def isRecordingScriptStats(self) -> "bool":
        r"""

        isRecordingScriptStats(self) -> bool

            Return True if the profile is recording script events and
            statistics.


        """
        return _hou.PerfMonProfile_isRecordingScriptStats(self)

    def isRecordingRenderStats(self) -> "bool":
        r"""

        isRecordingRenderStats(self) -> bool

            Return True if the profile is recording statistics related to
            rendering.


        """
        return _hou.PerfMonProfile_isRecordingRenderStats(self)

    def isRecordingThreadStats(self) -> "bool":
        r"""

        isRecordingThreadStats(self) -> bool

            Return True if the profile is recording thread statistics.


        """
        return _hou.PerfMonProfile_isRecordingThreadStats(self)

    def isRecordingFrameStats(self) -> "bool":
        r"""

        isRecordingFrameStats(self) -> bool

            Return True if the profile is recording frame events and statistics.


        """
        return _hou.PerfMonProfile_isRecordingFrameStats(self)

    def isRecordingMemoryStats(self) -> "bool":
        return _hou.PerfMonProfile_isRecordingMemoryStats(self)

    def isRecordingErrors(self) -> "bool":
        r"""

        isRecordingErrors(self) -> bool

            Return True if the profile is recording errors.


        """
        return _hou.PerfMonProfile_isRecordingErrors(self)

    def stop(self) -> "void":
        r"""

        stop(self)

            Stop the profile from recording and generate statistics for the
            events that it has already recorded.

            Raises hou.OperationFailed if the profile is not active.


        """
        return _hou.PerfMonProfile_stop(self)

    def cancel(self) -> "void":
        r"""

        cancel(self)

            Stop the profile from recording timed events and remove it from the
            performance monitor.

            Raises hou.OperationFailed if the profile is not active, that is,
            the profile is neither recording nor paused.


        """
        return _hou.PerfMonProfile_cancel(self)

    def pause(self) -> "void":
        r"""

        pause(self)

            Pause the profile from recording events and statistics.

            Raises hou.OperationFailed if the profile is stopped or already
            paused.


        """
        return _hou.PerfMonProfile_pause(self)

    def resume(self) -> "void":
        r"""

        resume(self)

            Unpause the profile so that it can record events and statistics.

            Raises hou.OperationFailed if the profile is stopped or is already
            recording (i.e. not paused).


        """
        return _hou.PerfMonProfile_resume(self)

    def save(self, file_path: "char const *") -> "void":
        r"""

        save(self, file_path)

            Save the profile to disk.

            Raises hou.OperationFailed if the profile is still active or if the
            file could not be written to disk (i.e. permission problems).


        """
        return _hou.PerfMonProfile_save(self, file_path)

    def exportAsCSV(self, file_path: "char const *") -> "void":
        r"""

        exportAsCSV(self, file_path)

            Export the profile statistics to disk using a comma-separated (CSV)
            format. The exported .csv file can be loaded into a spreadsheet
            application such as Microsoft Excel and used to generate graphs.

            Raises hou.OperationFailed if the profile is still active or if the
            .csv file could not be written to disk (i.e. permission problems).


        """
        return _hou.PerfMonProfile_exportAsCSV(self, file_path)

    def _stats(self) -> "std::string":
        return _hou.PerfMonProfile__stats(self)


# Register PerfMonProfile in _hou:
_hou.PerfMonProfile_swigregister(PerfMonProfile)


class PerfMonRecordOptions(object):
    r"""

    hou.PerfMonRecordOptions

    Represents the set of options used by the Performance Monitor and
    specifies the type of statistics to be recorded in a profile.

    RELATED

      * hou.perfMon

      * hou.PerfMonProfile

      * Performance monitor pane


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(
        self,
        cook_stats: "bool" = True,
        pdg_cook_stats: "bool" = True,
        solve_stats: "bool" = True,
        draw_stats: "bool" = True,
        gpu_draw_stats: "bool" = False,
        viewport_stats: "bool" = True,
        script_stats: "bool" = True,
        render_stats: "bool" = True,
        thread_stats: "bool" = False,
        frame_stats: "bool" = True,
        memory_stats: "bool" = False,
        errors: "bool" = True,
        pane_stats: "bool" = True,
    ):
        r"""

        hou.PerfMonRecordOptions

        Represents the set of options used by the Performance Monitor and
        specifies the type of statistics to be recorded in a profile.

        RELATED

          * hou.perfMon

          * hou.PerfMonProfile

          * Performance monitor pane


        """
        _hou.PerfMonRecordOptions_swiginit(
            self,
            _hou.new_PerfMonRecordOptions(
                cook_stats,
                pdg_cook_stats,
                solve_stats,
                draw_stats,
                gpu_draw_stats,
                viewport_stats,
                script_stats,
                render_stats,
                thread_stats,
                frame_stats,
                memory_stats,
                errors,
                pane_stats,
            ),
        )

    __swig_destroy__ = _hou.delete_PerfMonRecordOptions

    def __repr__(self) -> "std::string":
        return _hou.PerfMonRecordOptions___repr__(self)

    def recordCookStats(self) -> "bool":
        r"""

        recordCookStats(self) -> bool

            Return True if cook statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordCookStats(self)

    def recordPDGCookStats(self) -> "bool":
        r"""

        recordPDGCookStats(self) -> bool

            Return True if PDG node and work item cook statistics should be
            recorded.


        """
        return _hou.PerfMonRecordOptions_recordPDGCookStats(self)

    def recordSolveStats(self) -> "bool":
        r"""

        recordSolveStats(self) -> bool

            Return True if DOP solver statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordSolveStats(self)

    def recordDrawStats(self) -> "bool":
        r"""

        recordDrawStats(self) -> bool

            Return True if node draw statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordDrawStats(self)

    def recordGPUDrawStats(self) -> "bool":
        r"""

        recordGPUDrawStats(self) -> bool

            Return True if node GPU draw statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordGPUDrawStats(self)

    def recordViewportStats(self) -> "bool":
        r"""

        recordViewportStats(self) -> bool

            Return True if viewport statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordViewportStats(self)

    def recordPaneStats(self) -> "bool":
        r"""

        recordPaneStats(self) -> bool

            Return True if non-viewport pane statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordPaneStats(self)

    def recordScriptStats(self) -> "bool":
        r"""

        recordScriptStats(self) -> bool

            Return True if hscript and Python script statistics should be
            recorded.


        """
        return _hou.PerfMonRecordOptions_recordScriptStats(self)

    def recordRenderStats(self) -> "bool":
        r"""

        recordRenderStats(self) -> bool

            Return True if Mantra render statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordRenderStats(self)

    def recordThreadStats(self) -> "bool":
        r"""

        recordThreadStats(self) -> bool

            Return True if thread statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordThreadStats(self)

    def recordFrameStats(self) -> "bool":
        r"""

        recordFrameStats(self) -> bool

            Return True if frame statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordFrameStats(self)

    def recordMemoryStats(self) -> "bool":
        r"""

        recordMemoryStats(self) -> bool

            Return True if memory statistics should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordMemoryStats(self)

    def recordErrors(self) -> "bool":
        r"""

        recordErrors(self) -> bool

            Return True if warnings and errors should be recorded.


        """
        return _hou.PerfMonRecordOptions_recordErrors(self)

    def setRecordCookStats(self, record: "bool") -> "void":
        r"""

        setRecordCookStats(self, record)

            Turn the recording of cook statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordCookStats(self, record)

    def setRecordPDGCookStats(self, record: "bool") -> "void":
        r"""

        setRecordPDGCookStats(self, record)

            Turn the recording of PDG node cook statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordPDGCookStats(self, record)

    def setRecordSolveStats(self, record: "bool") -> "void":
        r"""

        setRecordSolveStats(self, record)

            Turn the recording of DOP solver statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordSolveStats(self, record)

    def setRecordDrawStats(self, record: "bool") -> "void":
        r"""

        setRecordDrawStats(self, record)

            Turn the recording of node draw statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordDrawStats(self, record)

    def setRecordGPUDrawStats(self, record: "bool") -> "void":
        r"""

        setRecordGPUDrawStats(self, record)

            Turn the recording of node GPU draw statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordGPUDrawStats(self, record)

    def setRecordViewportStats(self, record: "bool") -> "void":
        r"""

        setRecordViewportStats(self, record)

            Turn the recording of viewport statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordViewportStats(self, record)

    def setRecordPaneStats(self, record: "bool") -> "void":
        r"""

        setRecordPaneStats(self, record)

            Turn the recording of non-viewport pane statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordPaneStats(self, record)

    def setRecordScriptStats(self, record: "bool") -> "void":
        r"""

        setRecordScriptStats(self, record)

            Turn the recording of hscript and Python statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordScriptStats(self, record)

    def setRecordRenderStats(self, record: "bool") -> "void":
        r"""

        setRecordRenderStats(self, record)

            Turn the recording of Mantra render statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordRenderStats(self, record)

    def setRecordThreadStats(self, record: "bool") -> "void":
        r"""

        setRecordThreadStats(self, record)

            Turn the recording of thread statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordThreadStats(self, record)

    def setRecordFrameStats(self, record: "bool") -> "void":
        r"""

        setRecordFrameStats(self, record)

            Turn the recording of frame statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordFrameStats(self, record)

    def setRecordMemoryStats(self, record: "bool") -> "void":
        r"""

        setRecordMemoryStats(self, record)

            Turn the recording of memory statistics on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordMemoryStats(self, record)

    def setRecordErrors(self, record: "bool") -> "void":
        r"""

        setRecordErrors(self, record)

            Turn the recording of warnings and errors on or off.


        """
        return _hou.PerfMonRecordOptions_setRecordErrors(self, record)


# Register PerfMonRecordOptions in _hou:
_hou.PerfMonRecordOptions_swigregister(PerfMonRecordOptions)


class PerformanceMonitor(PaneTab):
    r"""

    hou.PerformanceMonitor

    Represents a Performance Monitor panetab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PerformanceMonitor

    def __repr__(self) -> "std::string":
        return _hou.PerformanceMonitor___repr__(self)

    def isLiveUpdatesEnabled(self) -> "bool":
        r"""

        isLiveUpdatesEnabled(self) -> bool

            Return whether live updates is enabled.


        """
        return _hou.PerformanceMonitor_isLiveUpdatesEnabled(self)

    def enableLiveUpdates(self, on: "bool") -> "void":
        r"""

        enableLiveUpdates(self, on)

            Enable or disable live updates for recordings. If live updates is
            enabled, then statistics are displayed in the statistics viewer and
            are periodically updated while the performance monitor is recording.


        """
        return _hou.PerformanceMonitor_enableLiveUpdates(self, on)

    def isRecording(self) -> "bool":
        r"""

        isRecording(self) -> bool

            Return whether the performance monitor is recording.


        """
        return _hou.PerformanceMonitor_isRecording(self)

    def startRecording(self) -> "void":
        r"""

        startRecording(self)

            Start recording in the performance monitor.

            Raises hou.OperationFailed if the performance monitor is already
            recording.


        """
        return _hou.PerformanceMonitor_startRecording(self)

    def stopRecording(self) -> "void":
        r"""

        stopRecording(self)

            Stop recording in the performance monitor.

            Raises hou.OperationFailed if the performance monitor is already
            stopped.


        """
        return _hou.PerformanceMonitor_stopRecording(self)

    def isSamplingCookStats(self) -> "bool":
        r"""

        isSamplingCookStats(self) -> bool

            Return whether the sampling of cook statistics is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingCookStats(self)

    def isSamplingPDGCookStats(self) -> "bool":
        r"""

        isSamplingPDGCookStats(self) -> bool

            Return whether the sampling of PDG node cook statistics is turned
            on.


        """
        return _hou.PerformanceMonitor_isSamplingPDGCookStats(self)

    def isSamplingErrors(self) -> "bool":
        r"""

        isSamplingErrors(self) -> bool

            Return whether the sampling of warnings and errors is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingErrors(self)

    def isSamplingFrameStats(self) -> "bool":
        r"""

        isSamplingFrameStats(self) -> bool

            Return whether the sampling of frame statistics is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingFrameStats(self)

    def isSamplingMemoryStats(self) -> "bool":
        return _hou.PerformanceMonitor_isSamplingMemoryStats(self)

    def isSamplingObjectDrawStats(self) -> "bool":
        r"""

        isSamplingObjectDrawStats(self) -> bool

            Return whether the sampling of object drawing statistics is turned
            on.


        """
        return _hou.PerformanceMonitor_isSamplingObjectDrawStats(self)

    def isSamplingObjectGPUDrawStats(self) -> "bool":
        r"""

        isSamplingObjectGPUDrawStats(self) -> bool

            Return whether the sampling of object GPU drawing statistics is
            turned on.


        """
        return _hou.PerformanceMonitor_isSamplingObjectGPUDrawStats(self)

    def isSamplingScriptStats(self) -> "bool":
        r"""

        isSamplingScriptStats(self) -> bool

            Return whether the sampling of script statistics is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingScriptStats(self)

    def isSamplingSolveStats(self) -> "bool":
        r"""

        isSamplingSolveStats(self) -> bool

            Return whether the sampling of DOP solve statistics is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingSolveStats(self)

    def isSamplingThreadStats(self) -> "bool":
        r"""

        isSamplingThreadStats(self) -> bool

            Return whether the sampling of thread statistics is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingThreadStats(self)

    def isSamplingViewportStats(self) -> "bool":
        r"""

        isSamplingViewportStats(self) -> bool

            Return whether the sampling of viewport statistics is turned on.


        """
        return _hou.PerformanceMonitor_isSamplingViewportStats(self)

    def sampleCookStats(self, on: "bool") -> "void":
        r"""

        sampleCookStats(self, on)

            Turn sampling of cook statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleCookStats(self, on)

    def samplePDGCookStats(self, on: "bool") -> "void":
        r"""

        samplePDGCookStats(self, on)

            Turn sampling of PDG node cook statistics on or off.


        """
        return _hou.PerformanceMonitor_samplePDGCookStats(self, on)

    def sampleErrors(self, on: "bool") -> "void":
        r"""

        sampleErrors(self, on)

            Turn sampling of warnings and errors on or off.


        """
        return _hou.PerformanceMonitor_sampleErrors(self, on)

    def sampleFrameStats(self, on: "bool") -> "void":
        r"""

        sampleFrameStats(self, on)

            Turn sampling of frame statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleFrameStats(self, on)

    def sampleMemoryStats(self, on: "bool") -> "void":
        return _hou.PerformanceMonitor_sampleMemoryStats(self, on)

    def sampleObjectDrawStats(self, on: "bool") -> "void":
        r"""

        sampleObjectDrawStats(self, on)

            Turn sampling of object drawing statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleObjectDrawStats(self, on)

    def sampleObjectGPUDrawStats(self, on: "bool") -> "void":
        r"""

        sampleObjectGPUDrawStats(self, on)

            Turn sampling of object GPU drawing statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleObjectGPUDrawStats(self, on)

    def sampleScriptStats(self, on: "bool") -> "void":
        r"""

        sampleScriptStats(self, on)

            Turn sampling of script statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleScriptStats(self, on)

    def sampleSolveStats(self, on: "bool") -> "void":
        r"""

        sampleSolveStats(self, on)

            Turn sampling of DOP solve statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleSolveStats(self, on)

    def sampleThreadStats(self, on: "bool") -> "void":
        r"""

        sampleThreadStats(self, on)

            Turn sampling of thread statistics on or off. Note that turning on
            thread sampling can add overhead to the processing times (i.e. cook
            times, solve times, etc.) in the scene.


        """
        return _hou.PerformanceMonitor_sampleThreadStats(self, on)

    def sampleViewportStats(self, on: "bool") -> "void":
        r"""

        sampleViewportStats(self, on)

            Turn sampling of object-drawing statistics on or off.


        """
        return _hou.PerformanceMonitor_sampleViewportStats(self, on)

    def objectView(self) -> "HOM_EnumValue &":
        r"""

        objectView(self) -> hou.perfMonObjectView enum value

            Return the structure type that is used to view objects in the
            statistics viewer.


        """
        return _hou.PerformanceMonitor_objectView(self)

    def setObjectView(self, structure: "EnumValue") -> "void":
        r"""

        setObjectView(self, view)

            Set the structure type to use when viewing objects in the statistics
            viewer.


        """
        return _hou.PerformanceMonitor_setObjectView(self, structure)

    def timeFormat(self) -> "HOM_EnumValue &":
        r"""

        timeFormat(self) -> hou.perfMonTimeFormat enum value

            Return the format that is used to view times in the statistics
            viewer.


        """
        return _hou.PerformanceMonitor_timeFormat(self)

    def setTimeFormat(self, format: "EnumValue") -> "void":
        r"""

        setTimeFormat(self, format)

            Set the format to use when viewing times in the statistics viewer.


        """
        return _hou.PerformanceMonitor_setTimeFormat(self, format)

    def timeUnit(self) -> "HOM_EnumValue &":
        r"""

        timeUnit(self) -> hou.perfMonTimeUnit enum value

            Return the unit that is used to view times in the statistics viewer.


        """
        return _hou.PerformanceMonitor_timeUnit(self)

    def setTimeUnit(self, unit: "EnumValue") -> "void":
        r"""

        setTimeUnit(self, unit)

            Set the unit to use when viewing times in the statistics viewer.


        """
        return _hou.PerformanceMonitor_setTimeUnit(self, unit)


# Register PerformanceMonitor in _hou:
_hou.PerformanceMonitor_swigregister(PerformanceMonitor)


class playbar(object):
    r"""

    hou.playbar

    The animation playbar module.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_playbar

    def __repr__(self) -> "std::string":
        return _hou.playbar___repr__(self)

    def isPlaying(self) -> "bool":
        r"""

        isPlaying(self) -> bool

            Return True if the playbar is playing. Return False otherwise.


        """
        return _hou.playbar_isPlaying(self)

    def play(self) -> "void":
        r"""

        play(self)

            Play in the forward direction.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_play(self)

    def stop(self) -> "void":
        r"""

        stop(self)

            Stop playing.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_stop(self)

    def reverse(self) -> "void":
        r"""

        reverse(self)

            Play in the reverse direction.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_reverse(self)

    def jumpToNextKeyframe(self) -> "void":
        return _hou.playbar_jumpToNextKeyframe(self)

    def jumpToPreviousKeyframe(self) -> "void":
        return _hou.playbar_jumpToPreviousKeyframe(self)

    def playMode(self) -> "HOM_EnumValue &":
        r"""

        playMode(self) -> hou.playMode

            Return the playbar's play mode.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_playMode(self)

    def setPlayMode(self, mode: "EnumValue") -> "void":
        r"""

        setPlayMode(self, mode)

            Set the play mode to one of the following: hou.playMode.Loop - Loop
            to the start of the range when the playback slider reaches the end
            of the range. hou.playMode.Once - Stop playback when the slider
            reaches the end of the range. hou.playMode.Zigzag - Play in the
            forward direction until reaching the end of the playback range, then
            play in the reverse direction.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setPlayMode(self, mode)

    def frameIncrement(self) -> "double":
        r"""

        frameIncrement(self) -> float

            Return the frame increment step size.


        """
        return _hou.playbar_frameIncrement(self)

    def setFrameIncrement(self, increment: "double") -> "void":
        r"""

        setFrameIncrement(self, increment)

            Set the frame increment step size. This value is ignored when
            playing with realtime playback turned on.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setFrameIncrement(self, increment)

    def playbackRange(self) -> "HOM_Vector2 *":
        r"""

        playbackRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end frame of the playback
            range.


        """
        return _hou.playbar_playbackRange(self)

    def setPlaybackRange(self, start: "double", end: "double") -> "void":
        r"""

        setPlaybackRange(self, start, end)

            Set the playback range.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setPlaybackRange(self, start, end)

    def isRangeRestricted(self) -> "bool":
        r"""

        isRangeRestricted(self) -> bool

            Return true if playback is restricted to within the playbar's start
            frame and end frame.


        """
        return _hou.playbar_isRangeRestricted(self)

    def setRestrictRange(self, on: "bool") -> "void":
        r"""

        setRestrictRange(self, on)

            Turn restriction on the playback range on or off. When the
            restriction is turned on, playback will remain with the start and
            end frames of the playback range.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setRestrictRange(self, on)

    def usesIntegerFrames(self) -> "bool":
        r"""

        usesIntegerFrames(self) -> bool

            Return True if playback uses integer frame values. Return False
            otherwise.


        """
        return _hou.playbar_usesIntegerFrames(self)

    def setUseIntegerFrames(self, on: "bool") -> "void":
        r"""

        setUseIntegerFrames(self, on)

            Turn integer frame values on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setUseIntegerFrames(self, on)

    def isRealTime(self) -> "bool":
        r"""

        isRealTime(self) -> bool

            Return True if realtime playback is turned on. Return False
            otherwise.


        """
        return _hou.playbar_isRealTime(self)

    def setRealTime(self, on: "bool") -> "void":
        r"""

        setRealTime(self, on)

            Turn realtime playback either on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setRealTime(self, on)

    def realTimeFactor(self) -> "double":
        r"""

        realTimeFactor(self) -> float

            Return the multiplier factor used when playing with realtime
            playback turned on.


        """
        return _hou.playbar_realTimeFactor(self)

    def setRealTimeFactor(self, factor: "double") -> "void":
        r"""

        setRealTimeFactor(self, factor)

            Set the realtime playback multiplier. A multiplier value of less
            than 1 slows down the playback. A multiplier value of greater than 1
            speeds up the playback. A multiplier value equal to 1 maintains
            realtime playback. The multiplier has no effect if realtime playback
            is turned off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setRealTimeFactor(self, factor)

    def isRealTimeSkipping(self) -> "bool":
        r"""

        isRealTimeSkipping(self) -> bool

            Return True if realtime playback skipping is turned on. Return False
            otherwise.


        """
        return _hou.playbar_isRealTimeSkipping(self)

    def setRealTimeSkipping(self, on: "bool") -> "void":
        r"""

        setRealTimeSkipping(self, on)

            Turn realtime playback skipping either on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_setRealTimeSkipping(self, on)

    def isAudioShown(self) -> "bool":
        r"""

        isAudioShown(self) -> bool

            Return True if the display of audio in the playbar is turned on.
            Return False otherwise.


        """
        return _hou.playbar_isAudioShown(self)

    def showAudio(self, on: "bool") -> "void":
        r"""

        showAudio(self, on)

            Turn display of audio on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_showAudio(self, on)

    def areKeysShown(self) -> "bool":
        r"""

        areKeysShown(self) -> bool

            Return True if the display of keyframes in the playbar is turned on.
            Return False otherwise.


        """
        return _hou.playbar_areKeysShown(self)

    def showKeys(self, on: "bool") -> "void":
        r"""

        showKeys(self, on)

            Turn display of keyframes on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_showKeys(self, on)

    def isSimCacheShown(self) -> "bool":
        return _hou.playbar_isSimCacheShown(self)

    def showSimCache(self, on: "bool") -> "void":
        return _hou.playbar_showSimCache(self, on)

    def isRangeSliderShown(self) -> "bool":
        r"""

        isRangeSliderShown(self) -> bool

            Return True if the display of the range slider in the playbar is
            turned on. Return False otherwise.


        """
        return _hou.playbar_isRangeSliderShown(self)

    def showRangeSlider(self, on: "bool") -> "void":
        r"""

        showRangeSlider(self, on)

            Turn display of the range slider on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_showRangeSlider(self, on)

    def areTicksShown(self) -> "bool":
        r"""

        areTicksShown(self) -> bool

            Return True if the display of frame ticks in the playbar is turned
            on. Return False otherwise.


        """
        return _hou.playbar_areTicksShown(self)

    def showTicks(self, on: "bool") -> "void":
        r"""

        showTicks(self, on)

            Turn display of the frame ticks on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
        return _hou.playbar_showTicks(self, on)

    def moveToBottom(self) -> "void":
        r"""

        moveToBottom(self)

            Move the playbar to the bottom of the desktop.

            Raises hou.NotAvailable if the user interface is not available.


        """
        return _hou.playbar_moveToBottom(self)

    def moveToPane(self, pane: "Pane") -> "void":
        r"""

        moveToPane(self, pane)

            Move the playbar to the bottom of the specified pane.

            Raises hou.ObjectWasDeleted if pane does not point to a valid pane.
            Raises hou.NotAvailable if the user interface is not available.


        """
        return _hou.playbar_moveToPane(self, pane)

    def addEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addEventCallback(self, callback)

            Register a Python callback to be called whenever a playbar event
            occurs (i.e. frame change, playback stopped).


            callback
                Any callable Python object that expects two arguments. The first
                argument is a hou.playbarEvent enum value and the second
                argument is a float storing the frame number of when the event
                took place.

          > def outputPlaybarEvent(event_type, frame):
          >     print \"Playbar event\", event_type, \"at frame\", frame
          >
          > hou.playbar.addEventCallback(outputPlaybarEvent)

        """
        return _hou.playbar_addEventCallback(self, callback)

    def removeEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeEventCallback(callback)

            Remove a Python callback that was previously registered with
            hou.playbar.addEventCallback. See hou.playbar.addEventCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
        return _hou.playbar_removeEventCallback(self, callback)

    def clearEventCallbacks(self) -> "void":
        r"""

        clearEventCallbacks()

            Remove all Python callbacks that have been registered with
            hou.playbar.addEventCallback.


        """
        return _hou.playbar_clearEventCallbacks(self)

    def eventCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        eventCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.playbar.addEventCallback.


        """
        return _hou.playbar_eventCallbacks(self)

    def selectedKeyframes(
        self,
    ) -> "std::map< HOM_ElemPtr< HOM_Parm >,std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > >,std::less< HOM_ElemPtr< HOM_Parm > >,std::allocator< std::pair< HOM_ElemPtr< HOM_Parm > const,std::vector< HOM_ElemPtr< HOM_BaseKeyframe >,std::allocator< HOM_ElemPtr< HOM_BaseKeyframe > > > > > >":
        return _hou.playbar_selectedKeyframes(self)

    def selectionRange(self) -> "HOM_Vector2 *":
        r"""

        selectionRange(self) -> hou.Vector2 or None

            This function exists for backwards compatibility.

            Returns a 2-tuple containing the start and end frame of the
            selection range. If there are multiple selections, the returned
            2-tuple contains the start and end frame of the selection that
            occurs first on the playbar. If there is no selection, then None is
            returned.


        """
        return _hou.playbar_selectionRange(self)

    def selectionRanges(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Vector2 >,std::allocator< HOM_ElemPtr< HOM_Vector2 > > >":
        r"""

        selectionRanges(self) -> tuple of hou.Vector2

            Returns a list of 2-tuples containing the start and end frame of
            each selection range.


        """
        return _hou.playbar_selectionRanges(self)

    def timelineRange(self) -> "HOM_Vector2 *":
        return _hou.playbar_timelineRange(self)

    def timeRange(self) -> "HOM_Vector2 *":
        r"""

        timeRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end times of the global
            time range.


        """
        return _hou.playbar_timeRange(self)

    def setTimeRange(self, start: "double", end: "double") -> "void":
        r"""

        setTimeRange(self, start, end)

            Set the global time range using time in seconds.


        """
        return _hou.playbar_setTimeRange(self, start, end)

    def frameRange(self) -> "HOM_Vector2 *":
        r"""

        frameRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end frame of the global
            time range.


        """
        return _hou.playbar_frameRange(self)

    def setFrameRange(self, start: "double", end: "double") -> "void":
        r"""

        setFrameRange(self, start, end)

            Set the global time range using frame numbers.


        """
        return _hou.playbar_setFrameRange(self, start, end)

    def channelList(self) -> "HOM_ChannelList *":
        r"""

        channelList(self) -> hou.ChannelList

            Return a copy of the current channel list.


        """
        return _hou.playbar_channelList(self)

    def setChannelList(self, l: "ChannelList") -> "void":
        r"""

        setChannelList(self, [Hom:hou.ChannelList])

            Set the current channel list.


        """
        return _hou.playbar_setChannelList(self, l)

    def channelListFromSelection(self) -> "HOM_ChannelList *":
        r"""

        channelListFromSelection(self) -> hou.ChannelList

            Return a channel list from the selected nodes. This relies on the
            auto-add to channel list flags.


        """
        return _hou.playbar_channelListFromSelection(self)

    def channelListFromNodes(self, nodes: "_NodeTuple") -> "HOM_ChannelList *":
        r"""

        channelListFromNodes(self,nodes) -> hou.ChannelList

            Return a channel list from the a list of nodes. This relies on the
            auto-add to channel list flags.


        """
        return _hou.playbar_channelListFromNodes(self, nodes)

    def channelListFromParms(
        self, parms: "std::vector< HOM_Parm *,std::allocator< HOM_Parm * > > const &"
    ) -> "HOM_ChannelList *":
        r"""

        channelListFromParms(self,parms) -> hou.ChannelList

            Return a channel list from the a list of parameters. This relies on
            the auto-add to channel list flags.


        """
        return _hou.playbar_channelListFromParms(self, parms)

    def channelListFromParmTuples(
        self,
        parms: "std::vector< HOM_ParmTuple *,std::allocator< HOM_ParmTuple * > > const &",
    ) -> "HOM_ChannelList *":
        r"""

        channelListFromParmTuples(self,parms) -> hou.ChannelList

            Return a channel list from the a list of parameter tuples. This
            relies on the auto-add to channel list flags.


        """
        return _hou.playbar_channelListFromParmTuples(self, parms)


# Register playbar in _hou:
_hou.playbar_swigregister(playbar)


class Point(object):
    r"""

    hou.Point

    Represents a point on a geometry primitive, such as a polygon or NURBS
    surface.

    Each Point object resides inside a Geometry object and stores a 3D
    position. Points may be shared between primitives (such as polygons),
    and the set of points and primitives describes a 3D shape.

    Each point can store arbitrary values in named attributes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Point

    def __eq__(self, point: "HOM_PtrOrNull< HOM_Point >") -> "bool":
        return _hou.Point___eq__(self, point)

    def __ne__(self, point: "HOM_PtrOrNull< HOM_Point >") -> "bool":
        return _hou.Point___ne__(self, point)

    def __hash__(self) -> "int":
        return _hou.Point___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Point___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Returns the hou.Geometry object containing this point.


        """
        return _hou.Point_geometry(self)

    def number(self) -> "int":
        r"""

        number(self) -> int

            Returns the point number of this point. Points are numbered
            sequentially across the entire Geometry starting from 0, and the
            points returned by hou.Geometry.points are in point number order.


        """
        return _hou.Point_number(self)

    def position(self) -> "HOM_Vector3 *":
        r"""

        position(self) -> hou.Vector3

            Return the position of this point as a hou.Vector3 containing the
            (X, Y, Z) values.

            You can transform the Vector3 using a hou.Matrix4:

          > xform = hou.node(\"/obj/geo1\").worldTransform()  # Matrix4
          > new_pos = point.position() * xform

            This method is a shortcut for accessing the P attribute of the
            point. However, it is not equivalent, because point.attribValue(\"P\")
            returns a 3-tuple of floats, not a Vector3 object:

          > point.position()
          > # is equivalent to
          > hou.Vector3(point.attribValue(\"P\"))

        """
        return _hou.Point_position(self)

    def setPosition(self, position: "_DoubleTuple") -> "void":
        r"""

        setPosition(self, position)

            Changes the point's location. You would typically call this method
            from the code of a Python-defined SOP.

            position is any sequence of floats, such has a hou.Vector3 or a
            tuple or list of floats, of length 3 or 4. The fourth coordinate
            corresponds to the weight, and is usually 1. The weight is typically
            used by NURBS curves and sequences. If the sequence is of size 3,
            the weight will be unchanged.

            This method is a shortcut for calling hou.Point.setAttribValue on
            the P attribute.

          > point.setPosition((x, y, z))
          > # is the same as
          > point.setAttribValue(\"P\", (x, y, z))

            Raises hou.GeometryPermissionError if the geometry is not
            modifiable. Raises hou.InvalidSize if the length of position is not
            3 or 4.


        """
        return _hou.Point_setPosition(self, position)

    def weight(self) -> "double":
        r"""

        weight(self) -> float

            Return the weight of this point. Point weights are displayed in
            Houdini's geometry spreadsheet as the fourth component of the
            position. Point weights are used by NURBS.

            Usually, the weight is 1.0.

            This method is an alternative for accessing the Pw attribute of the
            point that will still work even when the Pw attribute does not
            exist.

          > point.weight()
          > # is equivalent to
          > point.attribValue(\"Pw\")
          > # if the \"Pw\" attribute exists, and otherwise returns 1.0

            You can build a hou.Vector4 containing both the position and weight:

          > hou.Vector4(tuple(point.position()) + (point.weight(),))

            See also hou.Point.position.


        """
        return _hou.Point_weight(self)

    def setWeight(self, weight: "double") -> "void":
        r"""

        setWeight(self, weight)

            Change the point's weight. You would typically call this method from
            the code of a Python-defined SOP.

            This method is an alternative for calling hou.Point.setAttribValue
            on the Pw attribute that will create the attribute if necessary.

            See hou.Point.weight for more information about a point's weight.
            See also hou.Point.setPosition.


        """
        return _hou.Point_setWeight(self, weight)

    def attribType(self) -> "HOM_EnumValue &":
        r"""

        attribType(self) -> hou.attribType enum value

            Always returns hou.attribType.Point.

            This is only useful if you want to write generic code that works
            whether the input objects are hou.Prim, hou.Point, or hou.Vertex.
            They all have an attribType() method that returns the right
            attribType value for the given object.


        """
        return _hou.Point_attribType(self)

    def floatAttribValue(self, *args) -> "double":
        r"""

        floatAttribValue(self, name_or_attrib) -> float

            Return the point attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not float of size 1.

            In most cases, you'll just use hou.Point.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
        return _hou.Point_floatAttribValue(self, *args)

    def floatListAttribValue(
        self, *args
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the point attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Point.attribValue.


        """
        return _hou.Point_floatListAttribValue(self, *args)

    def intAttribValue(self, *args) -> "int64":
        r"""

        intAttribValue(self, name_or_attrib) -> int

            Return the point attribute value for a particular integer attribute
            of size 1. The attribute may be specified by name or by hou.Attrib
            object. See hou.Point.floatAttribValue for more information.


        """
        return _hou.Point_intAttribValue(self, *args)

    def intListAttribValue(
        self, *args
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the point attribute value for a particular integer attribute.
            The attribute may be specified by name or by hou.Attrib object. The
            return value is a tuple of ints. See hou.Point.floatListAttribValue
            for more information.


        """
        return _hou.Point_intListAttribValue(self, *args)

    def stringAttribValue(self, *args) -> "std::string":
        r"""

        stringAttribValue(self, name_or_attrib) -> str

            Return the point attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. See
            hou.Point.floatAttribValue for more information.


        """
        return _hou.Point_stringAttribValue(self, *args)

    def stringListAttribValue(
        self, *args
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the point attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. The
            return value is a tuple of strings.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Point.floatAttribValue for more information.


        """
        return _hou.Point_stringListAttribValue(self, *args)

    def dictAttribValue(
        self, *args
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        dictAttribValue(self, name_or_attrib) -> dict

            Return the point attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Point.floatAttribValue for more information.


        """
        return _hou.Point_dictAttribValue(self, *args)

    def dictListAttribValue(
        self, *args
    ) -> "std::vector< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >,std::allocator< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > > >":
        r"""

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the point attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Point.floatAttribValue for more information.


        """
        return _hou.Point_dictListAttribValue(self, *args)

    def setAttribValue(self, *args) -> "void":
        r"""

        setAttribValue(self, name_or_attrib, attrib_value)

            Store an attribute value in this point. The attribute may be
            specified by name or by hou.Attrib object, and must be an existing
            point attribute in the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute's data type does not match the value passed in. If
            the attribute's size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute's size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See hou.Geometry.addAttrib for an example.

            See also:

          * hou.Prim.setAttribValue

          * hou.Vertex.setAttribValue

          * hou.Geometry.setGlobalAttribValue


        """
        return _hou.Point_setAttribValue(self, *args)

    def _getPointParent(self) -> "HOM_Point *":
        return _hou.Point__getPointParent(self)

    def _getPointTransform(self) -> "HOM_Matrix4 *":
        return _hou.Point__getPointTransform(self)

    def _attribInfo(
        self,
        name: "char const *",
        attr_data_type: "int &",
        attr_size: "int &",
        is_array_type: "bool &",
    ) -> "void":
        return _hou.Point__attribInfo(
            self, name, attr_data_type, attr_size, is_array_type
        )

    def attribValue(self, *args) -> "InterpreterObject":
        r"""

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return value stored in this point for a particular attribute. The
            attribute may be specified by name or by hou.Attrib object.

            Looking up an attribute value using a hou.Attrib object is slightly
            faster than looking it up by name. When looking up attribute values
            inside a loop, look up the hou.Attrib object outside the loop, and
            pass it into this method.

            Note that the point position attribute is named P and is 4 floats in
            size. This attribute always exists.

            When looking up the attribute values of all points, it is faster to
            call hou.Geometry.pointFloatAttribValues or
            hou.Geometry.pointFloatAttribValuesAsString than to call this method
            for each point in the geometry.

            Raises hou.OperationFailed if no attribute exists with this name.

          > # Create an object containing two SOPs: a box SOP wired into a color SOP.
          > geo_node = hou.node(\"/obj\").createNode(\"geo\")
          > box = geo_node.createNode(\"box\")
          > color = geo_node.createNode(\"color\")
          > color.setFirstInput(box)
          >
          > # Grab the color SOP's geometry, get its first point, and print out the
          > # value of the Cd attribute.
          > geo = color.geometry()
          > point = geo.iterPoints()[0]
          > print point.attribValue(\"Cd\")
          >
          > # Look up the Cd attribute and illustrate how to access the attribute
          > # value using the attribute object.
          > cd_attribute = geo.findPointAttrib(\"Cd\")
          > print point.attribValue(cd_attribute)

        """
        return _hou.Point_attribValue(self, *args)

    def vertices(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Vertex >,std::allocator< HOM_ElemPtr< HOM_Vertex > > >":
        r"""

        vertices(self) -> tuple of hou.Vertex

            Returns a tuple of the vertices that reference this point.

            This requires a search through a primitive's vertices, so the cost
            grows with the total number of vertices across this point's
            primitives.


        """
        return _hou.Point_vertices(self)

    def prims(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        prims(self) -> tuple of hou.Prim

            Returns a tuple of the primitives that reference this point.


        """
        return _hou.Point_prims(self)


# Register Point in _hou:
_hou.Point_swigregister(Point)


class PointGroup(object):
    r"""

    hou.PointGroup

    A named group of points inside a Geometry object.

    Point groups reside inside the geometry, and each point group has a
    unique name.

    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing point number). When creating a group using the group SOP, use
    the <Create Ordered> checkbox to create an ordered group. When creating
    one from Python, Use the is_ordered parameter of
    hou.Geometry.createPointGroup to control whether a group is ordered.

    See hou.Point for more information about points. See also hou.PrimGroup,
    hou.VertexGroup, and hou.EdgeGroup.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PointGroup

    def __eq__(self, point_group: "HOM_PtrOrNull< HOM_PointGroup >") -> "bool":
        return _hou.PointGroup___eq__(self, point_group)

    def __ne__(self, point_group: "HOM_PtrOrNull< HOM_PointGroup >") -> "bool":
        return _hou.PointGroup___ne__(self, point_group)

    def __hash__(self) -> "int":
        return _hou.PointGroup___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.PointGroup___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
        return _hou.PointGroup_geometry(self)

    def name(self) -> "std::string":
        r"""

        name(self)

            Return the name of the group. Each point group has a unique name.


        """
        return _hou.PointGroup_name(self)

    def iterPoints(self) -> "HOM_IterableList< HOM_Point > *":
        r"""

        iterPoints(self) -> generator of hou.Point

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.PointGroup.points allocates and returns a tuple of all
            the points in the group, this method returns a generator object that
            will yield hou.Point objects on demand.


        """
        return _hou.PointGroup_iterPoints(self)

    def points(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        points(self) -> tuple of hou.Point

            Return the contents of this group.

            See also hou.PointGroup.iterPoints.


        """
        return _hou.PointGroup_points(self)

    def contains(self, point: "Point") -> "bool":
        r"""

        contains(self, point) -> bool

            Return whether or not a point is in this group.

            Raises hou.OperationFailed if the point belongs to a different
            geometry object than this group.


        """
        return _hou.PointGroup_contains(self, point)

    def isOrdered(self) -> "bool":
        r"""

        isOrdered(self) -> bool

            Returns whether or not this group is ordered.


        """
        return _hou.PointGroup_isOrdered(self)

    def add(self, *args) -> "void":
        r"""

        add(self, point_or_list_or_point_group)

            If given a hou.Point or a list of hou.Point's, add the point(s) to
            the group. If given a hou.PointGroup, merge the contents of the
            other point group with this group (the other group is unaffected).
            You would typically call this method from the code of a Python-
            defined SOP.

            It is ok to add points to the group that were already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the point or point group belong to a
            different geometry object than this group.


        """
        return _hou.PointGroup_add(self, *args)

    def remove(self, *args) -> "void":
        r"""

        remove(self, point_or_list_or_point_group)

            If given a hou.Point or a list of hou.Point's, remove the point from
            the group. If given a hou.PointGroup, remove all points in the other
            group from this group (the other group is unaffected). You would
            typically call this method from the code of a Python-defined SOP.

            It is not an error to try to remove a point from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the point belongs to a different
            geometry object than this group.


        """
        return _hou.PointGroup_remove(self, *args)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove all points from this group. You would typically call this
            method from the code of a Python-defined SOP.

            The points remain in the geometry; only the group is affected.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.PointGroup_clear(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.PointGroup_destroy(self)

    def pointCount(self) -> "int64":
        r"""

        pointCount(self, point) -> int

            Returns the number of points in this group.


        """
        return _hou.PointGroup_pointCount(self)

    def optionType(self, option_name: "char const *") -> "HOM_EnumValue &":
        r"""

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
        return _hou.PointGroup_optionType(self, option_name)

    def setOption(self, *args) -> "void":
        r"""

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See
            hou.PointGroup.options for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
        return _hou.PointGroup_setOption(self, *args)

    def removeOption(self, name: "char const *") -> "void":
        r"""

        removeOption(self, name)

            Remove an entry in the dictionary of options. See
            hou.PointGroup.options for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
        return _hou.PointGroup_removeOption(self, name)

    def dataId(self) -> "HOM_AttribDataId *":
        r"""

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
        return _hou.PointGroup_dataId(self)

    def incrementDataId(self) -> "void":
        r"""

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
        return _hou.PointGroup_incrementDataId(self)

    def options(self) -> "InterpreterObject":
        r"""

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.PointGroup.options, hou.PointGroup.setOption and
            hou.PointGroup.removeOption.


        """
        return _hou.PointGroup_options(self)

    def option(self, option_name: "char const *") -> "InterpreterObject":
        return _hou.PointGroup_option(self, option_name)


# Register PointGroup in _hou:
_hou.PointGroup_swigregister(PointGroup)


class Polygon(Face):
    r"""

    hou.Polygon

    A Polygon is a kind of Face whose vertices are connected via straight
    lines.

    Currently, hou.Face, and its base class hou.Prim contain all the
    necessary methods for polygon inspection and manipulation.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Polygon

    def __repr__(self) -> "std::string":
        return _hou.Polygon___repr__(self)


# Register Polygon in _hou:
_hou.Polygon_swigregister(Polygon)


class PrimGroup(object):
    r"""

    hou.PrimGroup

    A named group of primitives inside a Geometry object.

    Primitive groups reside inside the geometry, and each primitive group
    has a unique name.

    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing primitive number). When creating a group using the group SOP,
    use the <Create Ordered> checkbox to create an ordered group. When
    creating one from Python, Use the is_ordered parameter of
    hou.Geometry.createPrimGroup to control whether a group is ordered.

    See hou.Prim for more information about primitives. See also
    hou.PointGroup, hou.VertexGroup, and hou.EdgeGroup.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PrimGroup

    def __eq__(self, prim_group: "HOM_PtrOrNull< HOM_PrimGroup >") -> "bool":
        return _hou.PrimGroup___eq__(self, prim_group)

    def __ne__(self, prim_group: "HOM_PtrOrNull< HOM_PrimGroup >") -> "bool":
        return _hou.PrimGroup___ne__(self, prim_group)

    def __hash__(self) -> "int":
        return _hou.PrimGroup___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.PrimGroup___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
        return _hou.PrimGroup_geometry(self)

    def name(self) -> "std::string":
        r"""

        name(self)

            Return the name of the group. Each primitive group has a unique
            name.


        """
        return _hou.PrimGroup_name(self)

    def iterPrims(self) -> "HOM_IterableList< HOM_Prim > *":
        r"""

        iterPrims(self) -> generator of hou.Prim

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.PrimGroup.prims allocates and returns a tuple of all the
            primitives in the group, this method returns a generator object that
            will yield hou.Prim objects on demand.


        """
        return _hou.PrimGroup_iterPrims(self)

    def prims(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        prims(self) -> tuple of hou.Prim

            Return the contents of this group.

            See also hou.PrimGroup.iterPrims.


        """
        return _hou.PrimGroup_prims(self)

    def contains(self, prim: "Prim") -> "bool":
        r"""

        contains(self, prim) -> bool

            Return whether or not a primitive is in this group.

            Raises hou.OperationFailed if the primitive belongs to a different
            geometry object than this group.


        """
        return _hou.PrimGroup_contains(self, prim)

    def isOrdered(self) -> "bool":
        r"""

        isOrdered(self) -> bool

            Returns whether or not this group is ordered.


        """
        return _hou.PrimGroup_isOrdered(self)

    def add(self, *args) -> "void":
        r"""

        add(self, prim_or_list_or_prim_group)

            If given a hou.Prim or a list of hou.Prim's, add the primitive(s) to
            the group. If given a hou.PrimGroup, merge the contents of the other
            primitive group with this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is okay to add primitives to the group that were already in the
            group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the primitive or primitive group
            belong to a different geometry object than this group.


        """
        return _hou.PrimGroup_add(self, *args)

    def remove(self, *args) -> "void":
        r"""

        remove(self, prim_or_list_or_prim_group)

            If given a hou.Prim or a list of hou.Prim's, remove the primitive(s)
            from the group. If given a hou.PrimGroup, remove all primitives in
            the other group from this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is not an error to try to remove a primitive from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the primitive belongs to a different
            geometry object than this group.


        """
        return _hou.PrimGroup_remove(self, *args)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove all primitives from this group. You would typically call this
            method from the code of a Python-defined SOP.

            The primitives remain in the geometry; only the group is affected.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.PrimGroup_clear(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.PrimGroup_destroy(self)

    def primCount(self) -> "int64":
        r"""

        primCount(self) -> int

            Returns the number of primitives in this group.


        """
        return _hou.PrimGroup_primCount(self)

    def optionType(self, option_name: "char const *") -> "HOM_EnumValue &":
        r"""

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
        return _hou.PrimGroup_optionType(self, option_name)

    def setOption(self, *args) -> "void":
        r"""

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See hou.PrimGroup.options
            for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
        return _hou.PrimGroup_setOption(self, *args)

    def removeOption(self, name: "char const *") -> "void":
        r"""

        removeOption(self, name)

            Remove an entry in the dictionary of options. See
            hou.PrimGroup.options for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
        return _hou.PrimGroup_removeOption(self, name)

    def dataId(self) -> "HOM_AttribDataId *":
        r"""

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
        return _hou.PrimGroup_dataId(self)

    def incrementDataId(self) -> "void":
        r"""

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
        return _hou.PrimGroup_incrementDataId(self)

    def options(self) -> "InterpreterObject":
        r"""

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.PrimGroup.options, hou.PrimGroup.setOption and
            hou.PrimGroup.removeOption.


        """
        return _hou.PrimGroup_options(self)

    def option(self, option_name: "char const *") -> "InterpreterObject":
        return _hou.PrimGroup_option(self, option_name)


# Register PrimGroup in _hou:
_hou.PrimGroup_swigregister(PrimGroup)


class properties(object):
    r"""

    hou.properties

    A module for accessing standard render properties.

    This module provides functions for querying the set of standard
    properties that appear under the Render Properties tab when editing the
    parameters of a node or node type. This can make it easier to add these
    render properties programmatically to your nodes or assets.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_properties

    def __repr__(self) -> "std::string":
        return _hou.properties___repr__(self)

    def classes(
        self, *args
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        classes(tags=None) -> tuple of str

            Returns a list of render property classes. If the tags argument is
            provided, only those classes that match the provided tag expression
            will be returned.


        """
        return _hou.properties_classes(self, *args)

    def classLabel(self, class_name: "char const *") -> "std::string":
        r"""

        classLabel(class_name) -> str

            Returns the descriptive label for the provided render property
            class.


        """
        return _hou.properties_classLabel(self, class_name)

    def categories(
        self, class_name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        categories(class_name) -> tuple of str

            Returns the property categories in the provided render property
            class.


        """
        return _hou.properties_categories(self, class_name)

    def parameters(
        self, class_name: "char const *", category_name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        parameters(class_name, category_name) -> tuple of str

            Returns the names of all parameters under the category within the
            provided render property class.


        """
        return _hou.properties_parameters(self, class_name, category_name)

    def parmTemplate(
        self, class_name: "char const *", parm_name: "char const *"
    ) -> "HOM_ParmTemplate *":
        r"""

        parmTemplate(class_name, parm_name) -> hou.ParmTemplate

            Returns an object that represents the template for the specified
            render property parameter. This parameter may be a folder parameter
            if several parameters are intended to be added as a group.


        """
        return _hou.properties_parmTemplate(self, class_name, parm_name)


# Register properties in _hou:
_hou.properties_swigregister(properties)


class PythonPanel(PathBasedPaneTab):
    r"""

    hou.PythonPanel

    Class representing a pane tab that can display an embedded PySide or
    PyQt interface.

    See also hou.pypanel and hou.PythonPanelInterface.


    NOTE
        PySide and PyQt interfaces can only be created from the main Houdini
        application thread. You cannot call any method in this class from a
        separate thread (i.e. do not call from a Python Shell).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PythonPanel

    def activeInterface(self) -> "HOM_PythonPanelInterface *":
        r"""

        activeInterface(self) -> hou.PythonPanelInterface

            Returns the interface currently assigned to the Python Panel, or
            None if no interface has been assigned.


        """
        return _hou.PythonPanel_activeInterface(self)

    def setActiveInterface(self, interface: "PythonPanelInterface") -> "void":
        r"""

        setActiveInterface(self, interface)

            Show the specified interface in the Python Panel. interface is a
            hou.PythonPanelInterface object.

            Raises hou.OperationFailed if interface is not an installed Python
            Panel interface.


        """
        return _hou.PythonPanel_setActiveInterface(self, interface)

    def reloadActiveInterface(self) -> "void":
        r"""

        reloadActiveInterface(self)

            Reload the current interface in the Python Panel.

            Reloading destroys the old generated interface, reloads the Python
            Panel's script, and then runs the script to generate a new
            interface.


        """
        return _hou.PythonPanel_reloadActiveInterface(self)

    def showToolbar(self, show: "bool") -> "void":
        r"""

        showToolbar(self, show)

            Show or hide the toolbar. show must be either True or False.


        """
        return _hou.PythonPanel_showToolbar(self, show)

    def isToolbarShown(self) -> "bool":
        r"""

        isToolbarShown(self) -> bool

            Return True if the toolbar is shown and False otherwise.


        """
        return _hou.PythonPanel_isToolbarShown(self)

    def expandToolbar(self, expand: "bool") -> "void":
        return _hou.PythonPanel_expandToolbar(self, expand)

    def isToolbarExpanded(self) -> "bool":
        r"""

        isToolbarExpanded(self) -> bool

            Return True if the toolbar is expanded and False otherwise.


        """
        return _hou.PythonPanel_isToolbarExpanded(self)

    def label(self) -> "std::string":
        r"""

        label(self) -> str

            Return the label that appears in the Python Panel's pane tab button.
            If the Python Panel is not contained in a pane tab but is in a
            floating window then the label appearing in the window title bar is
            returned.


        """
        return _hou.PythonPanel_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self, label)

            Set the Python Panel's label. The label appears in the tab button of
            the pane tab containing the Python Panel or in the window title bar
            if the Python Panel is not contained in a pane tab but in a floating
            window.

            You can set a custom label through one of the Python Panel
            interface's hook functions. For example, to set the label when the
            interface is first created:

          > def onCreateInterface():
          >     # Set a custom label on the containing pane tab.
          >     pane_tab = kwargs[\"paneTab\"]
          >     pane_tab.setLabel(\"My Custom Label\")
          >
          >     widget = QWidget()
          >     return widget

        """
        return _hou.PythonPanel_setLabel(self, label)

    def activeInterfaceScriptErrors(self) -> "std::string":
        r"""

        activeInterfaceScriptErrors(self) -> str

            Returns any errors that were raised when executing the active
            interface's script. Returns an empty string if there were no errors.


        """
        return _hou.PythonPanel_activeInterfaceScriptErrors(self)

    def __repr__(self) -> "std::string":
        return _hou.PythonPanel___repr__(self)

    def activeInterfaceRootWidget(self) -> "InterpreterObject":
        r"""

        activeInterfaceRootWidget(self) -> Qt.QtWidgets.QWidget subclass

            Returns a reference to the user-defined root widget created by the
            active interface in the Python Panel. Returns None if there is no
            active interface or widget.


        """
        return _hou.PythonPanel_activeInterfaceRootWidget(self)


# Register PythonPanel in _hou:
_hou.PythonPanel_swigregister(PythonPanel)


class pypanel(object):
    r"""

    hou.pypanel

    Module containing functions related to Python panels.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_pypanel

    def __repr__(self) -> "std::string":
        return _hou.pypanel___repr__(self)

    def installFile(self, file_path: "char const *") -> "void":
        r"""

        installFile(file_path)

            Install all the Python Panel interfaces defined in the given
            .pypanel file into the current Houdini session.


            file_path
                The .pypanel file to load.


        """
        return _hou.pypanel_installFile(self, file_path)

    def interfacesInFile(
        self, file_path: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_PythonPanelInterface >,std::allocator< HOM_ElemPtr< HOM_PythonPanelInterface > > >":
        r"""

        interfacesInFile(file_path) -> tuple of hou.PythonPanelInterface

            Return all the Python Panel interface definitions inside the given
            .pypanel file. See hou.PythonPanelInterface for more information.

            Raises hou.OperationFailed if file_path does not refer to a valid
            .pypanel file.


        """
        return _hou.pypanel_interfacesInFile(self, file_path)

    def interfaces(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_PythonPanelInterface >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_PythonPanelInterface > > > >":
        r"""

        interfaces() -> dict of str to hou.PythonPanelInterface

            Return all the Python Panel interface definitions currently
            installed. Returns a dictionary mapping interface names to
            corresponding hou.PythonPanelInterface instances.

            See hou.PythonPanelInterface for more information.


        """
        return _hou.pypanel_interfaces(self)

    def interfaceByName(self, name: "char const *") -> "HOM_PythonPanelInterface *":
        r"""

        interfaceByName(name) -> hou.PythonPanelInterface

            Return the Python Panel interface definition that corresponds to the
            given interface name.

            Return None if no such interface definition exists.


        """
        return _hou.pypanel_interfaceByName(self, name)

    def setMenuInterfaces(self, names: "_StringTuple") -> "void":
        r"""

        setMenuInterfaces(names)

            Set the Python Panel drop-down menu to the list of interface names.
            Note that __separator__ is a valid name to indicate a separator in
            the list.

            Raises hou.OperationFailed if names contains interfaces that are not
            installed


        """
        return _hou.pypanel_setMenuInterfaces(self, names)

    def menuInterfaces(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuInterfaces() -> tuple of str

            Return a tuple of the names of the interfaces currently shown in the
            Python Panel drop-down menu.


        """
        return _hou.pypanel_menuInterfaces(self)


# Register pypanel in _hou:
_hou.pypanel_swigregister(pypanel)


class PythonPanelInterface(object):
    r"""

    hou.PythonPanelInterface

    Represents the definition of a Python panel interface.

    RELATED

      * hou.pypanel

      * hou.PythonPanel


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_PythonPanelInterface

    def __eq__(self, interface: "HOM_PtrOrNull< HOM_PythonPanelInterface >") -> "bool":
        return _hou.PythonPanelInterface___eq__(self, interface)

    def __ne__(self, interface: "HOM_PtrOrNull< HOM_PythonPanelInterface >") -> "bool":
        return _hou.PythonPanelInterface___ne__(self, interface)

    def __hash__(self) -> "int":
        return _hou.PythonPanelInterface___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.PythonPanelInterface___repr__(self)

    def id(self) -> "int":
        r"""

        id(self) -> int

            Returns the id for this interface.


        """
        return _hou.PythonPanelInterface_id(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name for this interface.


        """
        return _hou.PythonPanelInterface_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self,name)

            Sets the name for this interface.


        """
        return _hou.PythonPanelInterface_setName(self, name)

    def label(self) -> "std::string":
        r"""

        label(self) -> str

            Returns the label for this interface.


        """
        return _hou.PythonPanelInterface_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self,label)

            Sets the label for this interface.


        """
        return _hou.PythonPanelInterface_setLabel(self, label)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> str

            Returns the icon for this interface.


        """
        return _hou.PythonPanelInterface_icon(self)

    def setIcon(self, icon: "char const *") -> "void":
        r"""

        setIcon(self,icon)

            Sets the icon for this interface.


        """
        return _hou.PythonPanelInterface_setIcon(self, icon)

    def script(self) -> "std::string":
        r"""

        script(self) -> str

            Returns the script for this interface.


        """
        return _hou.PythonPanelInterface_script(self)

    def setScript(self, script: "char const *") -> "void":
        r"""

        setScript(self,script)

            Sets the script for this interface.


        """
        return _hou.PythonPanelInterface_setScript(self, script)

    def help(self) -> "std::string":
        return _hou.PythonPanelInterface_help(self)

    def setHelp(self, script: "char const *") -> "void":
        return _hou.PythonPanelInterface_setHelp(self, script)

    def helpURL(self) -> "std::string":
        return _hou.PythonPanelInterface_helpURL(self)

    def setHelpURL(self, script: "char const *") -> "void":
        return _hou.PythonPanelInterface_setHelpURL(self, script)

    def filePath(self) -> "std::string":
        r"""

        filePath(self) -> str

            Returns the file path for this interface.


        """
        return _hou.PythonPanelInterface_filePath(self)

    def setFilePath(self, filePath: "char const *") -> "void":
        r"""

        setFilePath(self,script)

            Sets the file path for this interface.


        """
        return _hou.PythonPanelInterface_setFilePath(self, filePath)


# Register PythonPanelInterface in _hou:
_hou.PythonPanelInterface_swigregister(PythonPanelInterface)


class Quadric(Prim):
    r"""

    hou.Quadric

    A Quadric is a kind of geometry primitive (Prim object) that represents
    a 3-dimensional surface defined by a quadratic polynomial equation (e.g.
    a sphere or tube).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Quadric

    def __repr__(self) -> "std::string":
        return _hou.Quadric___repr__(self)

    def transform(self) -> "HOM_Matrix3 *":
        r"""

        transform(self) -> hou.Matrix3

            Return the 3x3 matrix associated with this quadric. This matrix
            determines what type of quadric it is.

            See Wikipedia's Quadric page for more information.


        """
        return _hou.Quadric_transform(self)

    def getTransform(self) -> "HOM_Matrix3 *":
        return _hou.Quadric_getTransform(self)

    def vertex(self, index: "int") -> "HOM_Vertex *":
        r"""

        vertex(self, index) -> hou.Vertex

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
        return _hou.Quadric_vertex(self, index)


# Register Quadric in _hou:
_hou.Quadric_swigregister(Quadric)


class Quaternion(object):
    r"""

    hou.Quaternion

    A representation of a 3D rotation (or orientation). You can smoothly
    interpolate between two rotation values by interpolating between two
    quaternions.

    Quaternions provide an easy way to nicely interpolate between two
    rotation values, and avoid the gimbal lock and direction changes caused
    by interpolating Euler angles. They can easily be converted to and from
    rotation matrices, Euler angles, and angle-axis rotations.

    A quaternion is represented by a vector of 4 floats (x, y, z, and w).
    Any rotation in three dimensions is a rotation by some angle about some
    axis, and you can think of the (x, y, z) portion of the quaternion as
    storing the axis and the w portion as storing a (representation of) the
    angle.

    See Wikipedia's Quaternion page and its Quaternions and space rotation
    page for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self)

            You can construct a quaternion from a 3x3 rotation matrix, a 4x4
            rotation matrix, a rotation about an axis, Euler angles, or an (x,
            y, z, w) tuple. Note that rotations are represented as unit
            quaternions (i.e. quaternions of length 1), so constructing a
            quaternion from an arbitrary (x, y, z, w) tuple will not necessarily
            give a unit quaternion.

          > # Construct a quaternion from a rotation matrix.
          > hou.Quaternion(matrix3)
          > hou.Quaternion(matrix4)
          >
          > # Construct a quaternion from a rotation about an arbitrary axis.
          > hou.Quaternion(90, (1, 1, 0))
          >
          > # Construct a quaternion from Euler angles.
          > quaternion = hou.Quaternion()
          > quaternion.setToEulerRotates((rx, ry, rz), rotate_order=\"xyz\")
          >
          > # Another way to construct a quaternion from Euler angles by first
          > # constructing a matrix.
          > hou.Quaternion(hou.hmath.buildRotate((rx, ry, rz), \"xyz\"))
          >
          > # Construct a quaternion with specific x, y, z, and w values.
          > hou.Quaternion(x, y, z, w)
          >
          > # Construct a quaternion with x, y, z, set to zero and w set to one.
          > # This quaternion corresponds to the identity quaternion (i.e. no
          > # rotation).
          > hou.Quaternion()

            See also hou.hmath.buildRotate, hou.hmath.buildRotateAboutAxis, and
            hou.Matrix4.extractRotationMatrix3.


        """
        _hou.Quaternion_swiginit(self, _hou.new_Quaternion(*args))

    __swig_destroy__ = _hou.delete_Quaternion

    def __eq__(self, quaternion: "HOM_PtrOrNull< HOM_Quaternion >") -> "bool":
        return _hou.Quaternion___eq__(self, quaternion)

    def __ne__(self, quaternion: "HOM_PtrOrNull< HOM_Quaternion >") -> "bool":
        return _hou.Quaternion___ne__(self, quaternion)

    def isAlmostEqual(
        self, quaternion: "Quaternion", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, quaternion, tolerance=0.00001) -> bool

            Returns whether this quaternion is equal to another, within a
            numerical tolerance.


        """
        return _hou.Quaternion_isAlmostEqual(self, quaternion, tolerance)

    def almostEqual(
        self, quaternion: "Quaternion", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        almostEqual(self, quaternion, tolerance=0.00001) -> bool

            Deprecated. Use Quaternion.isAlmostEqual instead.


        """
        return _hou.Quaternion_almostEqual(self, quaternion, tolerance)

    def __hash__(self) -> "int":
        return _hou.Quaternion___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Quaternion___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Quaternion___repr__(self)

    def __getitem__(self, index: "int") -> "double":
        r"""

        __getitem__(self, index) -> float

            Return one of the four float values stored in the quaternion. This
            method, along with hou.Quaternion.__setitem__ and
            hou.Quaternion.__len__, make quaternions behave like sequences of 4
            floats so you can use Python's square bracket notation, sequence
            iteration, etc.

          > >>> q = hou.Quaternion(1, 2, 3, 4)
          > >>> for value in q:
          > ...     print value
          > 1
          > 2
          > 3
          > 4
          > >>> q[2]
          > 3
          > >>> len(q)
          > 4

        """
        return _hou.Quaternion___getitem__(self, index)

    def __setitem__(self, index: "int", value: "double") -> "void":
        r"""

        __setitem__(self, index, value)

            Set one of the four float values stored in the quaternion. See
            hou.Quaternion.__getitem__ for more information.


        """
        return _hou.Quaternion___setitem__(self, index, value)

    def __len__(self) -> "int":
        r"""

        __len__(self) -> int

            Return 4, the number of float elements in the quaternion. See
            hou.Quaternion.__getitem__ for more information.


        """
        return _hou.Quaternion___len__(self)

    def setTo(self, tuple: "_DoubleTuple") -> "void":
        r"""

        setTo(self, tuple)

            Set the quaternion's 4 float values (x, y, z, and w). tuple must be
            a sequence of 4 floats.

            This method will modify an existing quaternion object. Use
            hou.Quaternion.__init__ to construct a new quaternion from these
            four values.

            See also hou.Quaternion.__setitem__.


        """
        return _hou.Quaternion_setTo(self, tuple)

    def setToRotationMatrix(self, *args) -> "void":
        r"""

        setToRotationMatrix(self, matrix3_or_matrix4)

            Set this quaternion to contain the rotation component of the
            transformation in a hou.Matrix3 or hou.Matrix4.

            See also hou.Quaternion.extractRotationMatrix3.


        """
        return _hou.Quaternion_setToRotationMatrix(self, *args)

    def setToAngleAxis(self, angle_in_deg: "double", axis: "_DoubleTuple") -> "void":
        r"""

        setToAngleAxis(self, angle_in_deg, axis)

            Set this quaternion to contain the rotation about an axis by the
            given angle. angle_in_deg is in degrees and axis is a sequence of 3
            floats.

            This method can also be implemented as follows:

          > def setToAngleAxis(self, angle_in_deg, axis):
          >     self.setToRotationMatrix(
          >         hou.hmath.buildRotateAboutAxis(axis, angle_in_deg))

            See also hou.Quaternion.extractAngleAxis.


        """
        return _hou.Quaternion_setToAngleAxis(self, angle_in_deg, axis)

    def setToVectors(self, v1: "Vector3", v2: "Vector3") -> "void":
        r"""

        setToVectors(self, a, b)

            Sets this quaternion to the quaternion which rotates the hou.Vector3
            a onto the vector b.


        """
        return _hou.Quaternion_setToVectors(self, v1, v2)

    def setToEulerRotates(self, *args, **kwargs) -> "void":
        r"""

        setToEulerRotates(self, angles_in_deg, rotate_order=\"xyz\")

            Set this quaternion to contain the rotation specified by Euler
            rotations about the x, y, and z coordinate axes.

            This method can also be implemented as follows:

          > def setToEulerRotates(self, angles_in_deg, rotate_order=\"xyz\"):
          >     self.setToRotationMatrix(
          >         hou.hmath.buildRotate(angles_in_deg, rotate_order))

            See also hou.Quaternion.extractEulerRotates and
            hou.hmath.buildRotate.


        """
        return _hou.Quaternion_setToEulerRotates(self, *args, **kwargs)

    def conjugate(self) -> "HOM_Quaternion":
        r"""

        conjugate(self) -> hou.Quaternion

            Return a quaternion containing the opposite rotation of that stored
            in this quaternion. Intuitively, for unit length quaternions, the
            quaternion returned contains a rotation by the same angle about an
            axis pointing in the opposite direction.


        """
        return _hou.Quaternion_conjugate(self)

    def inverse(self) -> "HOM_Quaternion":
        r"""

        inverse(self) -> hou.Quaternion

            Return a quaternion containing the multiplicative inverse of this
            quaternion. For unit quaternions, the inverse is the same as the
            conjugate.

            See also hou.Quaternion.conjugate.


        """
        return _hou.Quaternion_inverse(self)

    def dot(self, quaternion: "Quaternion") -> "double":
        r"""

        dot(self, other) -> float

            Return the dot product of this quaternion with another one.


        """
        return _hou.Quaternion_dot(self, quaternion)

    def __add__(self, quaternion: "Quaternion") -> "HOM_Quaternion":
        r"""

        __add__(self, quaternion) -> hou.Quaternion

            Return a new quaternion containing the sum of this quaternion and
            another. This method lets you write quaternion1 + quaternion2.

            The sum of two quaternions is defined to be the vector containing
            the pairwise sum of their elements.


        """
        return _hou.Quaternion___add__(self, quaternion)

    def __sub__(self, quaternion: "Quaternion") -> "HOM_Quaternion":
        r"""

        __sub__(self, quaternion) -> hou.Quaternion

            Return a new quaternion containing the result of subtracting another
            quaternion from this one. This method lets you write quaternion1 -
            quaternion2.


        """
        return _hou.Quaternion___sub__(self, quaternion)

    def __mul__(self, *args) -> "HOM_Quaternion":
        r"""

        __mul__(self, quaternion_or_scalar) -> hou.Quaternion

            Multiply this quaternion by either another quaternion or a scalar.
            This method lets you write quaternion1 * quaternion2 and quaternion
            * scalar. This method returns a new hou.Quaternion and does not
            change this object's value.

            The product of two quaternions is defined to be the vector
            containing the pairwise product of their elements. Multiplying a
            quaternion by a scalar multiplies each of the elements by that
            scalar.


        """
        return _hou.Quaternion___mul__(self, *args)

    def slerp(self, other: "Quaternion", fraction: "double") -> "HOM_Quaternion":
        r"""

        slerp(self, other, fraction) -> hou.Quaternion

            Perform spherical linear interpolation between this quaternion and
            another, returning a new quaternion. fraction is a float from 0.0 to
            1.0, where 0.0 gives this quaternion and 1.0 gives the other
            quaternion. This method is very useful to smoothly interpolate
            between two different rotations.

            See Wikipedia's Slerp page for more information.

            The following example will nicely interpolate between two sets of
            Euler rotations.

          > def interpolateEulerRotations(rotation1, rotation2, fraction, rotate_order=\"xyz\"):
          >     quaternion1 = hou.Quaternion()
          >     quaternion1.setToEulerRotates(rotation1, rotate_order)
          >     quaternion2 = hou.Quaternion()
          >     quaternion2.setToEulerRotates(rotation2, rotate_order)
          >
          >     return quaternion1.slerp(quaternion2, fraction).extractEulerRotates(rotate_order)

        """
        return _hou.Quaternion_slerp(self, other, fraction)

    def normalized(self) -> "HOM_Quaternion":
        r"""

        normalized(self) -> hou.Quaternion

            Return a normalized version of this quaternion (i.e. a version of
            this quaternion whose length is one). Quaternions that represent
            rotations are always normalized.

            Normalizing a quaternion whose length is zero or near zero will
            return a new quaternion with the same values.

            This method can be implemented as follows (for non-zero length
            quaternions):

          > def normalized(self):
          >     return self * (1.0 / self.length())

        """
        return _hou.Quaternion_normalized(self)

    def length(self) -> "double":
        r"""

        length(self) -> float

            Return the length of the quaternion. When quaternions represent
            rotations, their length is one.

            A quaternion's length is compute the same as a Vector4's:
            hou.Vector4(self).length()


        """
        return _hou.Quaternion_length(self)

    def extractRotationMatrix3(self) -> "HOM_Matrix3 *":
        r"""

        extractRotationMatrix3(self) -> hou.Matrix3

            Return a 3x3 rotation matrix corresponding to the rotation in the
            quaternion.

            To create a hou.Matrix4 instead of a hou.Matrix3, you can easily
            create a Matrix4 from the Matrix3:

          > hou.Matrix4(quaternion.extractRotationMatrix3())

            If the quaternion is the zero quaternion, this method does not raise
            an exception. Instead, it returns the identity matrix.

            See also hou.Quaternion.setToRotationMatrix.


        """
        return _hou.Quaternion_extractRotationMatrix3(self)

    def extractAngleAxis(self) -> "std::pair< double,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        extractAngleAxis(self) -> (float, hou.Vector3)

            Return an axis and a rotation about that axis corresponding to the
            rotation in the quaternion. The return value is a 2-tuple containing
            a float and a hou.Vector3. The returned axis vector is normalized.

            If this quaternion is the zero quaternion, the angle returned is
            zero and the vector is the zero vector. Otherwise, if it is not
            normalized, the return values will correspond to the rotation
            represented by the normalized quaternion.

            See also hou.Quaternion.setToAngleAxis.


        """
        return _hou.Quaternion_extractAngleAxis(self)

    def extractEulerRotates(self, *args) -> "HOM_Vector3":
        r"""

        extractEulerRotates(self, rotate_order=\"xyz\") -> hou.Vector3

            Return the Euler rotations (the x, y, and z rotation values, in
            degrees, about the coordinate axes) corresponding to the rotation in
            the quaternion.

            This method can also be implemented as follows:

          > def extractEulerRotates(self, rotate_order=\"xyz\"):
          >     return hou.Matrix4(self.extractRotationMatrix3()).explode(rotate_order=rotate_order)[\"rotate\"]

            See also hou.Quaternion.setToEulerRotates.


        """
        return _hou.Quaternion_extractEulerRotates(self, *args)

    def rotate(self, v: "Vector3") -> "HOM_Vector3":
        r"""

        rotate(self, vec) -> hou.Vector3

            Rotates the given hou.Vector3 by this quaternion and returns the
            result.


        """
        return _hou.Quaternion_rotate(self, v)

    def _asVoidPointer(self) -> "void *":
        return _hou.Quaternion__asVoidPointer(self)


# Register Quaternion in _hou:
_hou.Quaternion_swigregister(Quaternion)


class qt(object):
    r"""

    hou.qt

    Module containing Qt related functions.

    CLASSES



    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_qt

    def __repr__(self) -> "std::string":
        return _hou.qt___repr__(self)

    def _mainWindow(self) -> "void *":
        return _hou.qt__mainWindow(self)

    def _floatingPanelWindow(self, panel: "FloatingPanel") -> "void *":
        r"""

        hou.qt.floatingPanelWindow

        Return a QWidget instance representing the window for the specified
        floating panel.

        USAGE
          floatingPanelWindow(self, panel) -> QWidget

        Return a QWidget instance representing the window for the provided
        hou.FloatingPanel. If the provided panel is None, this method returns
        the mainWindow. This method is helpful for parenting a PySide or PyQt
        dialog to a particular floating panel. Parenting to a panel keeps the
        dialog alive for the lifetime of the panel so that the dialog is not
        destroyed prematurely by Python. Parenting also causes the dialog to
        inherit the Houdini style sheet set on the main window, and depending on
        the dialog configuration, can keep the dialog on top of the floating
        panel.

        Here is an example of parenting a dialog to the panel that contains a
        particular pane tab:

        > from hutil.Qt import QtCore
        >
        > panetab = hou.ui.findPaneTab('panetab1')
        > panel = panetab.pane().floatingPanel()
        > dialog = MyDialog()
        > dialog.setParent(hou.qt.floatingPanelWindow(panel), QtCore.Qt.Window)
        > dialog.show()

        """
        return _hou.qt__floatingPanelWindow(self, panel)

    def _createWindow(self) -> "void *":
        return _hou.qt__createWindow(self)

    def _createDialog(self) -> "void *":
        return _hou.qt__createDialog(self)

    def _createMenu(self) -> "void *":
        return _hou.qt__createMenu(self)

    def _createIcon(
        self, icon_name: "char const *", width: "int", height: "int"
    ) -> "void *":
        return _hou.qt__createIcon(self, icon_name, width, height)

    def _createParmDialog(
        self,
        hom_node: "Node",
        showTitleBar: "bool",
        compact: "bool",
        labelsize: "double",
    ) -> "void *":
        return _hou.qt__createParmDialog(
            self, hom_node, showTitleBar, compact, labelsize
        )

    def _setParmDialogNode(self, widget: "void *", hom_node: "Node") -> "void":
        return _hou.qt__setParmDialogNode(self, widget, hom_node)

    def _parmDialogNode(self, widget: "void *") -> "HOM_Node *":
        return _hou.qt__parmDialogNode(self, widget)

    def _getParmDialogValueNames(
        self, widget: "void *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.qt__getParmDialogValueNames(self, widget)

    def _getParmDialogValue(
        self, widget: "void *", name: "char const *"
    ) -> "std::string":
        return _hou.qt__getParmDialogValue(self, widget, name)

    def _setParmDialogValue(
        self, widget: "void *", name: "char const *", value: "char const *"
    ) -> "bool":
        return _hou.qt__setParmDialogValue(self, widget, name, value)

    def _pressParmDialogButton(self, widget: "void *", name: "char const *") -> "bool":
        return _hou.qt__pressParmDialogButton(self, widget, name)

    def _getParmDialogVisibleParms(
        self, widget: "void *"
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        return _hou.qt__getParmDialogVisibleParms(self, widget)

    def _getColor(self, color_name: "char const *") -> "void *":
        return _hou.qt__getColor(self, color_name)

    def _getCursor(self, cursor_name: "char const *") -> "void *":
        return _hou.qt__getCursor(self, cursor_name)

    def _getBrush(self, color_name: "char const *") -> "void *":
        return _hou.qt__getBrush(self, color_name)

    def styleSheet(self, file_path: "char const *" = None) -> "std::string":
        r"""

        hou.qt.styleSheet

        Return the Houdini style sheet.

        USAGE
          styleSheet(file_path=None) -> str

        If file_path is not None, then return the style sheet stored in the
        given file rather than the Houdini style sheet. Style placeholders, such
        as color placeholders (i.e. @MenuBG@) and scaled size placeholders (i.e.
        @14px@), are evaluated and expanded in the returned style sheet.

        Return an empty string if the specified file path does not exist or if
        there is a syntax error in the style sheet.

        The returned style sheet can be applied to Qt widgets. Note that child
        widgets automatically inherit the parent widget's style sheet.

        > import Qt.QtWidgets as QtWidgets
        >
        > # Get the Houdini style sheet.
        > stylesheet = hou.qt.styleSheet()
        >
        > # Apply the Houdini style to a widget.
        > parent_widget = QtWidgets.QWidget()
        > parent_widget.setStyleSheet(stylesheet)
        >
        > child_button = QtWidgets.QPushButton()
        > child_button.setText(\"Hello World\")
        >
        > # Parenting the child button inherits the parent's Houdini style sheet.
        > child_button.setParent(parent_widget)

        """
        return _hou.qt_styleSheet(self, file_path)

    def _qtKeyToUIKey(
        self, qtKey: "int", qtKeymodifiers: "int"
    ) -> "std::map< std::string,int,std::less< std::string >,std::allocator< std::pair< std::string const,int > > >":
        return _hou.qt__qtKeyToUIKey(self, qtKey, qtKeymodifiers)

    def _qtKeyToString(
        self, qtKey: "int", qtKeymodifiers: "int", qtkeystring: "std::string"
    ) -> "std::string":
        return _hou.qt__qtKeyToString(self, qtKey, qtKeymodifiers, qtkeystring)

    def inchesToPixels(self, inches: "double") -> "double":
        r"""

        hou.qt.inchesToPixels

        Converts inches to pixels, accounting for both Qt and Houdini's dpi
        settings.

        USAGE
          inchesToPixels(inches) -> float


        """
        return _hou.qt_inchesToPixels(self, inches)

    def pixelsToInches(self, pixels: "double") -> "double":
        r"""

        hou.qt.pixelsToInches

        Converts pixels to inches, accounting for both Qt and Houdini's dpi
        settings.

        USAGE
          pixelsToInches(pixels) -> float


        """
        return _hou.qt_pixelsToInches(self, pixels)

    def skipClosingMenusForCurrentButtonPress(self) -> "void":
        r"""

        hou.qt.skipClosingMenusForCurrentButtonPress

        Disable automatic closing of menus for the current mouse button event.

        USAGE
          skipClosingMenusForCurrentButtonPress()

        Normally a mouse button event sent to any Qt widget in the Houdini
        process will cause all open Houdini menus to close. However if a mouse
        button event to a Qt widget is what causes a Houdini menu to open (such
        as through a call to hou.NetworkEditor.openNodeMenu), it is necessary to
        disable this automatic menu closing temporarily. Otherwise the menu that
        was just opened would be immediately closed. This method does exactly
        this, disabling the automatic menu closing until the next mouse button
        release event, at which time the automatic menu closing is re-enabled.


        """
        return _hou.qt_skipClosingMenusForCurrentButtonPress(self)

    def _launchRenderGalleryBackgroundRender(
        self,
        delegate: "char const *",
        usd_filepath: "char const *",
        rendersettings_prim: "char const *",
        override_camera: "char const *",
        override_res_x: "int",
        override_res_y: "int",
        lopnet_path: "char const *",
        item_id: "char const *",
    ) -> "bool":
        return _hou.qt__launchRenderGalleryBackgroundRender(
            self,
            delegate,
            usd_filepath,
            rendersettings_prim,
            override_camera,
            override_res_x,
            override_res_y,
            lopnet_path,
            item_id,
        )

    def _renderGalleryBackgroundRenderMouseClick(
        self, x: "int", y: "int", lopnet_path: "char const *", item_id: "char const *"
    ) -> "void":
        return _hou.qt__renderGalleryBackgroundRenderMouseClick(
            self, x, y, lopnet_path, item_id
        )

    def _stopRenderGalleryBackgroundRender(
        self, lopnet_path: "char const *", item_id: "char const *"
    ) -> "void":
        return _hou.qt__stopRenderGalleryBackgroundRender(self, lopnet_path, item_id)

    def _channelPathMimeType(self) -> "std::string":
        return _hou.qt__channelPathMimeType(self)

    def _chopTrackPathMimeType(self) -> "std::string":
        return _hou.qt__chopTrackPathMimeType(self)

    def _galleryEntryMimeType(self) -> "std::string":
        return _hou.qt__galleryEntryMimeType(self)

    def _galleryEntryNameMimeType(self) -> "std::string":
        return _hou.qt__galleryEntryNameMimeType(self)

    def _itemPathMimeType(self) -> "std::string":
        return _hou.qt__itemPathMimeType(self)

    def _nodeFlagPathMimeType(self) -> "std::string":
        return _hou.qt__nodeFlagPathMimeType(self)

    def _nodePathMimeType(self) -> "std::string":
        return _hou.qt__nodePathMimeType(self)

    def _orboltNodeTypeNameMimeType(self) -> "std::string":
        return _hou.qt__orboltNodeTypeNameMimeType(self)

    def _paneTabNameMimeType(self) -> "std::string":
        return _hou.qt__paneTabNameMimeType(self)

    def _parmPathMimeType(self) -> "std::string":
        return _hou.qt__parmPathMimeType(self)

    def _persistentHandleNameMimeType(self) -> "std::string":
        return _hou.qt__persistentHandleNameMimeType(self)

    def _primitivePathMimeType(self) -> "std::string":
        return _hou.qt__primitivePathMimeType(self)

    def _shelfNameMimeType(self) -> "std::string":
        return _hou.qt__shelfNameMimeType(self)

    def _shelfToolNameMimeType(self) -> "std::string":
        return _hou.qt__shelfToolNameMimeType(self)

    def _takeNameMimeType(self) -> "std::string":
        return _hou.qt__takeNameMimeType(self)

    def _usdPrimitivePathMimeType(self) -> "std::string":
        return _hou.qt__usdPrimitivePathMimeType(self)

    def _usdPrimitivePythonMimeType(self) -> "std::string":
        return _hou.qt__usdPrimitivePythonMimeType(self)

    def _usdPropertyPathMimeType(self) -> "std::string":
        return _hou.qt__usdPropertyPathMimeType(self)

    def _usdPropertyPythonMimeType(self) -> "std::string":
        return _hou.qt__usdPropertyPythonMimeType(self)

    def _assetGalleryEntryMimeType(self) -> "std::string":
        return _hou.qt__assetGalleryEntryMimeType(self)

    def _galleryNameRole(self) -> "int":
        return _hou.qt__galleryNameRole(self)

    def _galleryThumbRole(self) -> "int":
        return _hou.qt__galleryThumbRole(self)

    def _galleryCreationDateRole(self) -> "int":
        return _hou.qt__galleryCreationDateRole(self)

    def _galleryStarRole(self) -> "int":
        return _hou.qt__galleryStarRole(self)

    def _galleryDiffMarkerRole(self) -> "int":
        return _hou.qt__galleryDiffMarkerRole(self)

    def _galleryColorRole(self) -> "int":
        return _hou.qt__galleryColorRole(self)

    def _galleryTagsRole(self) -> "int":
        return _hou.qt__galleryTagsRole(self)

    def _galleryThumbValidRole(self) -> "int":
        return _hou.qt__galleryThumbValidRole(self)

    def _galleryMetadataRole(self) -> "int":
        return _hou.qt__galleryMetadataRole(self)

    def _gallerySnapshotFileRole(self) -> "int":
        return _hou.qt__gallerySnapshotFileRole(self)

    def _gallerySnapshotRole(self) -> "int":
        return _hou.qt__gallerySnapshotRole(self)

    def _galleryRenderingRole(self) -> "int":
        return _hou.qt__galleryRenderingRole(self)


# Register qt in _hou:
_hou.qt_swigregister(qt)


class RadialItem(object):
    r"""

    hou.RadialItem

    RELATED

      * hou.ui.RadialMenu

      * hou.ui.RadialScriptItem

      * hou.ui.RadialSubmenu


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_RadialItem

    def __repr__(self) -> "std::string":
        return _hou.RadialItem___repr__(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            This method is deprecated, and it has no effect. To remove an item
            from a submenu, use hou.ui.RadialSubmenu.remove instead. To
            unregister a top-level menu, use hou.ui.RadialMenu.destroy.


        """
        return _hou.RadialItem_destroy(self)

    def type(self) -> "HOM_EnumValue &":
        r"""

        type(self) -> hou.radialItemType

            Returns this radial menu item's type.


        """
        return _hou.RadialItem_type(self)


# Register RadialItem in _hou:
_hou.RadialItem_swigregister(RadialItem)


class RadialScriptItem(RadialItem):
    r"""

    hou.RadialScriptItem

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_RadialScriptItem

    def __repr__(self) -> "std::string":
        return _hou.RadialScriptItem___repr__(self)

    def isSubmenu(self) -> "bool":
        r"""

        isSubmenu(self) -> bool

            Returns whether this item is a submenu or action.


        """
        return _hou.RadialScriptItem_isSubmenu(self)

    def label(self) -> "char const *":
        r"""

        label(self) -> str

            Returns this radial menu item's label.


        """
        return _hou.RadialScriptItem_label(self)

    def setLabel(self, s: "char const *") -> "void":
        r"""

        setLabel(self)

            Sets this radial menu item's label.


        """
        return _hou.RadialScriptItem_setLabel(self, s)

    def icon(self) -> "char const *":
        r"""

        icon(self) -> str

            Returns this radial menu item's icon.


        """
        return _hou.RadialScriptItem_icon(self)

    def setIcon(self, s: "char const *") -> "void":
        r"""

        setIcon(self)

            Sets this radial menu item's icon.


        """
        return _hou.RadialScriptItem_setIcon(self, s)

    def check(self) -> "char const *":
        r"""

        check(self) -> str

            Returns a Python expression used to determine the radial menu item's
            checked state.


        """
        return _hou.RadialScriptItem_check(self)

    def setCheck(self, s: "char const *") -> "void":
        r"""

        setCheck(self)

            Sets the Python expression used to determine the radial menu item's
            checked state.


        """
        return _hou.RadialScriptItem_setCheck(self, s)

    def script(self) -> "char const *":
        r"""

        script(self) -> str

            Returns Python code that will be run when the radial menu item is
            activated.


        """
        return _hou.RadialScriptItem_script(self)

    def setScript(self, s: "char const *") -> "void":
        r"""

        setScript(self)

            Sets the Python code that will be run when the radial menu item is
            activated.


        """
        return _hou.RadialScriptItem_setScript(self, s)

    def shortcut(self) -> "char const *":
        r"""

        shortcut(self) -> str

            Returns a string description of the shortcut for selecting this
            radial menu item.


        """
        return _hou.RadialScriptItem_shortcut(self)

    def setShortcut(self, s: "char const *") -> "void":
        r"""

        setShortcut(self)

            Sets the shortcut for selecting this radial menu item.


        """
        return _hou.RadialScriptItem_setShortcut(self, s)

    def setActionCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        setActionCallback(self)

            Sets the callback that will be used this menu item is selected.

            For dynamic menus (i.e., self.isSubmenu() must be True),
            radialmenu.setRadialMenu() may be called in side the function.
            Alternatively, either hou.ui.injectRadialItem or
            hou.ui.injectRadialMenu should be called to dynamically populate the
            menu.

            Note that this is only applicable to temporary items created via
            hou.ui.createRadialItem. For registered menu items, the script text
            will be used.


        """
        return _hou.RadialScriptItem_setActionCallback(self, callback)

    def setCheckCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        setCheckCallback(self)

            Sets the callback to determine the item's checked state. This is
            only used if the item is an action (i.e., self.isSubmenu() returns
            False).

            Note that this is only applicable to temporary items created via
            hou.ui.createRadialItem. For registered menu items, the script text
            will be used.


        """
        return _hou.RadialScriptItem_setCheckCallback(self, callback)


# Register RadialScriptItem in _hou:
_hou.RadialScriptItem_swigregister(RadialScriptItem)


class RadialSubmenu(RadialItem):
    r"""

    hou.RadialSubmenu

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_RadialSubmenu

    def __repr__(self) -> "std::string":
        return _hou.RadialSubmenu___repr__(self)

    def label(self) -> "char const *":
        r"""

        label(self) -> str

            Returns this submenu's label.


        """
        return _hou.RadialSubmenu_label(self)

    def setLabel(self, s: "char const *") -> "void":
        r"""

        setLabel(self)

            Sets this submenu's label.


        """
        return _hou.RadialSubmenu_setLabel(self, s)

    def shortcut(self) -> "char const *":
        r"""

        shortcut(self) -> str

            Returns a string description of the shortcut for selecting this
            submenu.


        """
        return _hou.RadialSubmenu_shortcut(self)

    def setShortcut(self, s: "char const *") -> "void":
        r"""

        setShortcut(self)

            Sets the shortcut for selecting this submenu.


        """
        return _hou.RadialSubmenu_setShortcut(self, s)

    def remove(self, location: "EnumValue") -> "void":
        return _hou.RadialSubmenu_remove(self, location)

    def item(self, location: "EnumValue") -> "HOM_RadialItem *":
        r"""

        item(self, [Hom:hou.radialItemLocation]) -> hou.RadialItem

            Returns the radial menu item at the specified location. Returns None
            if no radial menu item exists at the specified location.


        """
        return _hou.RadialSubmenu_item(self, location)

    def items(
        self,
    ) -> "std::map< HOM_EnumValue *,HOM_ElemPtr< HOM_RadialItem >,std::less< HOM_EnumValue * >,std::allocator< std::pair< HOM_EnumValue *const,HOM_ElemPtr< HOM_RadialItem > > > >":
        r"""

        items(self) -> dict of hou.radialItemLocation to hou.RadialItem

            Returns a dict mapping radial item locations to radial menu items.


        """
        return _hou.RadialSubmenu_items(self)

    def createSubmenu(
        self,
        location: "EnumValue",
        label: "char const *" = None,
        shortcut: "char const *" = None,
    ) -> "HOM_RadialSubmenu *":
        r"""

        createSubmenu(self, [Hom:hou.radialItemLocation], label=None) ->
        hou.RadialSubmenu

            Creates a submenu at the specified location (replacing any existing
            radial menu item) and initializing the submenu's label. The new
            submenu is returned.


        """
        return _hou.RadialSubmenu_createSubmenu(self, location, label, shortcut)

    def createScriptItem(
        self,
        location: "EnumValue",
        label: "char const *" = None,
        icon: "char const *" = None,
        check: "char const *" = None,
        script: "char const *" = None,
        shortcut: "char const *" = None,
    ) -> "HOM_RadialScriptItem *":
        r"""

        createScriptItem(self, [Hom:hou.radialItemLocation], label=None,
        icon=None, check=None, script=None) -> hou.RadialScriptItem

            Creates a script item at the specified location (replacing any
            existing radial menu item) and initializing the script item's label,
            icon, expression specifying the checked state, and script executed
            when the item is activated. The new script item is returned.


        """
        return _hou.RadialSubmenu_createScriptItem(
            self, location, label, icon, check, script, shortcut
        )


# Register RadialSubmenu in _hou:
_hou.RadialSubmenu_swigregister(RadialSubmenu)


class RadialMenu(object):
    r"""

    hou.RadialMenu
      * Use hou.ui.radialMenus or hou.ui.radialMenu to get a reference to an
        existing menu.

      * Use hou.ui.createRadialMenu to create a new menu.

    RELATED

      * hou.ui.radialMenu

      * hou.ui.radialMenus

      * hou.ui.createRadialMenu

      * hou.RadialItem

      * hou.RadialSubmenu

      * hou.RadialScriptItem


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_RadialMenu

    def __repr__(self) -> "std::string":
        return _hou.RadialMenu___repr__(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Deletes this radial menu. The menu will be unregistered.


        """
        return _hou.RadialMenu_destroy(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns this radial menu's name.


        """
        return _hou.RadialMenu_name(self)

    def categories(self) -> "char const *":
        r"""

        categories(self) -> str

            Returns a comma separated list of this radial menu's categories.


        """
        return _hou.RadialMenu_categories(self)

    def setCategories(self, s: "std::string const &") -> "void":
        r"""

        setCategories(self, categories)

            Sets this radial menu's categories (specified as a comma separated
            list).


        """
        return _hou.RadialMenu_setCategories(self, s)

    def sourceFile(self) -> "char const *":
        r"""

        sourceFile(self) -> str

            Returns the name of the file from which this radial menu was loaded
            or saved.


        """
        return _hou.RadialMenu_sourceFile(self)

    def save(self, s: "std::string const &") -> "void":
        r"""

        save(self, filename)

            Saves this radial menu to the specified file.


        """
        return _hou.RadialMenu_save(self, s)

    def root(self) -> "HOM_RadialItem *":
        r"""

        root(self) -> hou.RadialItem

            Returns the root menu item. For regular menus, hou.ui.RadialSubmenu
            will be returned. For script menus, hou.ui.RadialScriptItem will be
            returned.


        """
        return _hou.RadialMenu_root(self)

    def label(self) -> "char const *":
        r"""

        label(self) -> str

            This method is deprecated. Use root().label() instead


        """
        return _hou.RadialMenu_label(self)

    def setLabel(self, s: "char const *") -> "void":
        r"""

        setLabel(self)

            This method is deprecated. Use root().setLabel() instead


        """
        return _hou.RadialMenu_setLabel(self, s)

    def shortcut(self) -> "char const *":
        r"""

        shortcut(self) -> str

            This method is deprecated. Use root().shortcut() instead


        """
        return _hou.RadialMenu_shortcut(self)

    def setShortcut(self, s: "char const *") -> "void":
        r"""

        setShortcut(self)

            This method is deprecated. Use root().setShortcut() instead


        """
        return _hou.RadialMenu_setShortcut(self, s)

    def item(self, location: "EnumValue") -> "HOM_RadialItem *":
        r"""

        item(self, [Hom:hou.radialItemLocation]) -> hou.RadialItem

            This method is deprecated. Use root().item() instead. Raises
            hou.NotAvailable if the root is a script menu.


        """
        return _hou.RadialMenu_item(self, location)

    def items(
        self,
    ) -> "std::map< HOM_EnumValue *,HOM_ElemPtr< HOM_RadialItem >,std::less< HOM_EnumValue * >,std::allocator< std::pair< HOM_EnumValue *const,HOM_ElemPtr< HOM_RadialItem > > > >":
        r"""

        items(self) -> dict of hou.radialItemLocation to hou.RadialItem

            This method is deprecated. Use root().items() instead Raises
            hou.NotAvailable if the root is a script menu.


        """
        return _hou.RadialMenu_items(self)

    def createSubmenu(
        self,
        location: "EnumValue",
        label: "char const *" = None,
        shortcut: "char const *" = None,
    ) -> "HOM_RadialSubmenu *":
        r"""

        createSubmenu(self, [Hom:hou.radialItemLocation], label=None) ->
        hou.RadialSubmenu

            This method is deprecated. Use root().createSubmenu() instead.
            Raises hou.NotAvailable if the root is a script menu.


        """
        return _hou.RadialMenu_createSubmenu(self, location, label, shortcut)

    def createScriptItem(
        self,
        location: "EnumValue",
        label: "char const *" = None,
        icon: "char const *" = None,
        check: "char const *" = None,
        script: "char const *" = None,
        shortcut: "char const *" = None,
    ) -> "HOM_RadialScriptItem *":
        r"""

        createScriptItem(self, [Hom:hou.radialItemLocation], label=None,
        icon=None, check=None, script=None) -> hou.RadialScriptItem

            This method is deprecated. Use root().createScriptItem() instead.
            Raises hou.NotAvailable if the root is a script menu.


        """
        return _hou.RadialMenu_createScriptItem(
            self, location, label, icon, check, script, shortcut
        )


# Register RadialMenu in _hou:
_hou.RadialMenu_swigregister(RadialMenu)


class Ramp(object):
    r"""

    hou.Ramp

    A Ramp represents a function that yields either floating point values or
    colors. You can evaluate this function between 0.0 and 1.0, and the
    function's shape is determined by a sequence of values at key positions
    between 0.0 and 1.0.

    If you evaluate a ramp parameter on a node, Houdini will return a Ramp
    object.

    You can check the curve basis of a ramp you get from a parameter by
    calling the hou.Ramp.basis method,which returns a hou.rampBasis value.

    In the Hermite basis, the curve passes through the odd control points,
    and the even control points control the tangent at the previous point.
    See the Wikipedia article on Hermite spline curves for more information.

    To get a smooth curve, you should evenly space the control points.

    RELATED

      * spline()


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, basis, keys, values) -> float


            basis
                A sequence of hou.rampBasis values, one for each key. The ramp
                basis for a key determines how Houdini interpolates from the key
                up until the next key. If there is no next key, Houdini will
                hold the value constant until the end of the [0,1] domain,
                regardless of the ramp basis.

            keys
                A sequence of floats, one for each key, each between 0.0 and
                1.0, inclusive. Each key represents the location in the [0,1]
                domain of its corresponding value.

            values
                A sequence of values, where each value corresponds to a key.
                When asked to evaluate at a value where there is no key, Houdini
                will interpolate between adjacent values using the basis
                function for the key on the left.

                This sequence is either a sequence of floats or a sequence of
                triples of floats. In the former case, the newly-created ramp
                will evaluate to a single floating-point value. In the latter
                case, it will evaluate to a color.

            Raises hou.InvalidSize if the keys and values sequences are not not
            same size, or if values contains subsequences of floats that are not
            3 elements long.

          > >>> lin = hou.rampBasis.Linear
          >
          > # Create a ramp that linearly interpolates between 2.5 and 4.5.
          > >>> r = hou.Ramp((lin, lin), (0, 1), (2.5, 4.5))
          > >>> r
          > <hou.Ramp is_color=False num_keys=2 data=((t=0, 2.5), (t=1, 4.5))>
          > >>> r.lookup(0.0)
          > 2.5
          > >>> r.lookup(0.5)
          > 3.5
          > >>> r.lookup(1.0)
          > 4.5
          >
          > # Create a color ramp that linearly interpolates from black to red.
          > >>> hou.Ramp((lin, lin), (0, 1), ((0.0, 0.0, 0.0), (1.0, 0.0, 0.2)))
          > <hou.Ramp is_color=True num_keys=2 data=((t=0, rgb=(0, 0, 0)), (t=1, rgb=(1, 1, 1)))>

        """
        _hou.Ramp_swiginit(self, _hou.new_Ramp(*args))

    __swig_destroy__ = _hou.delete_Ramp

    def __repr__(self) -> "std::string":
        return _hou.Ramp___repr__(self)

    def isColor(self) -> "bool":
        r"""

        isColor(self) -> bool

            Return True if this is a color ramp, and False if it is a single
            float ramp.


        """
        return _hou.Ramp_isColor(self)

    def colorType(self) -> "HOM_EnumValue &":
        r"""

        colorType(self) -> colorType

            If this is a color ramp, return the color space that is used during
            interpolation. The default is hou.colorType.RGB.

            Raises hou.OperationFailed if this ramp is not a color ramp.


        """
        return _hou.Ramp_colorType(self)

    def setColorType(self, enum_value: "EnumValue") -> "void":
        r"""

        setColorType(self, hou.colorType)

            If this is a color ramp, set the color space that is used during
            interpolation. The default is hou.colorType.RGB.

            To obtain a more perceptually uniform interpolation, use
            hou.colorType.LAB. To obtain a ramp that matches the rainbow, use
            hou.colorType.HSV.

            Raises hou.OperationFailed if this ramp is not a color ramp.


        """
        return _hou.Ramp_setColorType(self, enum_value)

    def basis(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        basis(self) -> tuple of hou.rampBasis enum values

            Return a tuple of hou.rampBasis enumeration values that determine
            how Houdini interpolates between the keys in the ramp. See
            hou.Ramp.__init__ for more information.


        """
        return _hou.Ramp_basis(self)

    def keys(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        keys(self) -> tuple of float

            Return a tuple of floats between 0.0 and 1.0 containing the ramp key
            positions. See hou.Ramp.__init__ for more information.


        """
        return _hou.Ramp_keys(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.Ramp__asVoidPointer(self)

    def lookup(self, pos: "double") -> "InterpreterObject":
        r"""

        lookup(self, position) -> float or tuple

            Return the value of the ramp at a specified position in the interval
            [0.0, 1.0). position will be clamped if outside this interval.

            Returns a float (for floating-point value ramps) or a tuple of 3
            floats (for color ramps).


        """
        return _hou.Ramp_lookup(self, pos)

    def values(self) -> "InterpreterObject":
        r"""

        values(self) -> tuple of float or tuple of tuple of float

            Return a tuple of floats (for a float ramp) or a tuple of tuples of
            3 floats (for a color ramp) corresponding to the values in the ramp
            stored at each key. See hou.Ramp.__init__ for more information.


        """
        return _hou.Ramp_values(self)


# Register Ramp in _hou:
_hou.Ramp_swigregister(Ramp)


class RampParmTemplate(ParmTemplate):
    r"""

    hou.RampParmTemplate

    Parameter template for a ramp parameter.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, ramp_parm_type, default_value=2,
        default_basis=None, show_controls=True, color_type=None,
        disable_when=None, is_hidden=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression_language=hou.scriptLanguage.Hscript)

            Construct a new RampParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            ramp_parm_type
                See the parmType method for more information.

            default_value
                The default number of ramp keys in new ramp parameter instances.
                See the defaultValue method for more information.

            default_basis
                See the defaultBasis method for more information. If this
                parameter is not specified it defaults to hou.rampBasis.Linear.

                The following example uses a Catmull-Rom basis:

              > r = hou.RampParmTemplate(
              >     \"myRamp\", \"My Ramp\", hou.rampParmType.Color,
              >     default_basis=hou.rampBasis.CatmullRom)

            show_controls
                See the showsControls method for more information.

            color_type
                See the colorType method for more information. If this parameter
                is not specified it defaults to hou.colorType.RGB.

                The following example uses an L*a*b* color space:

              > r = hou.RampParmTemplate(
              >     \"myRamp\", \"My Ramp\", hou.rampParmType.Color,
              >     color_type=hou.colorType.LAB)

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
        _hou.RampParmTemplate_swiginit(self, _hou.new_RampParmTemplate(*args, **kwargs))

    __swig_destroy__ = _hou.delete_RampParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.RampParmTemplate___repr__(self)

    def defaultValue(self) -> "int":
        r"""

        defaultValue(self) -> int

            Return this is the default number of ramp keys in new ramp parameter
            instances.


        """
        return _hou.RampParmTemplate_defaultValue(self)

    def setDefaultValue(self, default_value: "int") -> "void":
        r"""

        setDefaultValue(self, default_value)

            Set the default number of ramp keys to be used in new ramp parameter
            instances.


        """
        return _hou.RampParmTemplate_setDefaultValue(self, default_value)

    def defaultExpression(self) -> "std::string":
        r"""

        defaultExpression(self) -> string

            Return the expression, which when evaluated, returns the number of
            ramp keys to be used in new ramp parameter instances.

            The default expression takes precedence over the default value. If
            the default expression is not set (i.e. an empty string), then the
            default value is used instead.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
        return _hou.RampParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "std::string const &") -> "void":
        r"""

        setDefaultExpression(self, default_expression)

            Set the default expression, which when evaluated, returns the number
            of ramp keys to be used in new ramp parameter instances.

            If default_expression is the empty string, then the default
            expression is unset.


        """
        return _hou.RampParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(self) -> "HOM_EnumValue &":
        r"""

        defaultExpressionLanguage(self) -> hou.scriptLanguage

            Return the default expression language.

            The default expression language only applies if the default
            expression is set. If the default expression is not set, then the
            expression language is set to hou.scriptLanguage.Hscript.


        """
        return _hou.RampParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "EnumValue"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language.

            See the defaultExpressionLanguage method for more information.


        """
        return _hou.RampParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )

    def parmType(self) -> "HOM_EnumValue &":
        return _hou.RampParmTemplate_parmType(self)

    def setParmType(self, ramp_parm_type: "EnumValue") -> "void":
        r"""

        setParmType(self, ramp_parm_type)

            Set the type of this ramp to a hou.rampParmType enum value.


        """
        return _hou.RampParmTemplate_setParmType(self, ramp_parm_type)

    def defaultBasis(self) -> "HOM_EnumValue &":
        r"""

        defaultBasis(self) -> hou.rampBasis enum value

            The basis function used to control how values are interpolated
            between ramp keys. This value may be None to denote
            hou.rampBasis.Linear. This is merely a convenience wrapper for the
            ramp parameter specific tag and a value of None means that the tag
            does not exist.

            See hou.rampBasis for more information.


        """
        return _hou.RampParmTemplate_defaultBasis(self)

    def setDefaultBasis(self, default_basis: "EnumValue") -> "void":
        r"""

        setDefaultBasis(self, ramp_basis)

            Set the basis function used to control how values are interpolated
            between ramp keys. ramp_basis is a hou.rampBasis enum value. This is
            a convenience wrapper for the creating ramp parameter specific tag.


        """
        return _hou.RampParmTemplate_setDefaultBasis(self, default_basis)

    def colorType(self) -> "HOM_EnumValue &":
        r"""

        colorType(self) -> hou.colorType enum value

            The color space in which to interpolate color ramp keys.

            See hou.colorType for more information on color spaces.


        """
        return _hou.RampParmTemplate_colorType(self)

    def setColorType(self, color_type: "EnumValue") -> "void":
        r"""

        setColorType(self, color_type)

            Set the color space in which to interpolate color ramp keys to a
            hou.colorType enum value.


        """
        return _hou.RampParmTemplate_setColorType(self, color_type)

    def showsControls(self) -> "bool":
        r"""

        showsControls(self) -> bool

            Return whether new instances of this ramp parameter have the
            controls expanded by default. The user may later expand or collapse
            the ramp controls on the parameter.


        """
        return _hou.RampParmTemplate_showsControls(self)

    def setShowsControls(self, on: "bool") -> "void":
        r"""

        setShowsControls(self, on)

            Set whether new instances of this ramp parameter have the controls
            expanded by default.


        """
        return _hou.RampParmTemplate_setShowsControls(self, on)


# Register RampParmTemplate in _hou:
_hou.RampParmTemplate_swigregister(RampParmTemplate)


class RedrawBlock(object):
    r"""

    hou.RedrawBlock

    Use this class to collect multiple redraws for any Python code block and
    only redraw once.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        r"""

        __init__(self)

            Construct a new RedrawBlock.

            The constructor should only be called from within a with statement.
            For example:

          > with hou.RedrawBlock() as redrawblock:
          >     #
          >     # Perform tasks
          >     #

            All tasks within the code block will have their redraw requests
            collected and deferred until after the code in the block is
            complete. Once the code block is complete (or an exception causes a
            jump out of the block), a single redraw per window with redraw
            requests will be performed. This cuts down on redraw flickering for
            a long set of commands.


            WARNING
                Use care with Redraw Blocks. If an operation requires user
                interaction it should not be within a Redraw Block, otherwise
                the user will not see any prompts or the results of their
                actions.


        """
        _hou.RedrawBlock_swiginit(self, _hou.new_RedrawBlock())

    __swig_destroy__ = _hou.delete_RedrawBlock

    def __repr__(self) -> "std::string":
        return _hou.RedrawBlock___repr__(self)

    def __enter__(self) -> "HOM_RedrawBlock *":
        return _hou.RedrawBlock___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.RedrawBlock___exit__(self, type, value, traceback)


# Register RedrawBlock in _hou:
_hou.RedrawBlock_swigregister(RedrawBlock)


class ReferencePlane(object):
    r"""

    hou.ReferencePlane

    The reference grid (a.k.a. reference plane) in the scene viewer pane
    tab.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ReferencePlane

    def __repr__(self) -> "std::string":
        return _hou.ReferencePlane___repr__(self)

    def sceneViewer(self) -> "HOM_SceneViewer *":
        r"""

        sceneViewer(self) -> hou.SceneViewer

            Return the scene viewer containing this plane.


        """
        return _hou.ReferencePlane_sceneViewer(self)

    def isVisible(self) -> "bool":
        r"""

        isVisible(self) -> bool

            Return whether the grid is visible in the viewer.


        """
        return _hou.ReferencePlane_isVisible(self)

    def setIsVisible(self, on: "bool") -> "void":
        r"""

        setIsVisible(self, on)

            Make this grid visible or invisible in the viewer.


        """
        return _hou.ReferencePlane_setIsVisible(self, on)

    def transform(self) -> "HOM_Matrix4 *":
        r"""

        transform(self) -> hou.Matrix4

            Return the transformation matrix for this plane.

            When the transformation matrix is the identity matrix, the plane's
            bottom-left corner is at the origin and it sits in the XY plane. In
            this orientation, increasing the number of cells in x or the size of
            a cell in x grows the plane outward from the origin along the
            x-axis. Similarly, increasing the number of cells or size of a cell
            in y grows the plane along the y-axis.

            Note that the transformation matrix does not contain any scale
            information. The reference plane extends to infinity.

            The following function will return the normal of the plane:

          > def normal(reference_plane):
          >     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()

        """
        return _hou.ReferencePlane_transform(self)

    def setTransform(self, matrix: "Matrix4") -> "void":
        r"""

        setTransform(self, matrix)

            Set the transformation matrix for this plane to a hou.Matrix4.

            This matrix is used to translate and rotate the plane. See the
            transform method for more information.

            Note that scale information inside the transformation matrix is
            ignored.

            The following function will change the position of the origin of the
            plane:

          > def set_origin(reference_plane, new_origin):
          >     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(reference_plane))
          >     reference_plane.setTransform(reference_plane.transform() * translation)
          >
          > def origin(reference_plane):
          >     return hou.Vector3(0, 0, 0) * reference_plane.transform()

            The following function will change the normal of the plane:

          > def set_normal(reference_plane, normal_vector):
          >     existing_rotation = hou.Matrix4(reference_plane.transform().extractRotationMatrix3())
          >     rotation = existing_rotation * normal(reference_plane).matrixToRotateTo(normal_vector)
          >     translation = hou.hmath.buildTranslate(origin(reference_plane))
          >     reference_plane.setTransform(rotation * translation)
          >
          > def normal(reference_plane):
          >     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()
          >
          > def origin(reference_plane):
          >     return hou.Vector3(0, 0, 0) * reference_plane.transform()

        """
        return _hou.ReferencePlane_setTransform(self, matrix)

    def cellSize(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        cellSize(self) -> tuple of float

            Return the x and y sizes (width and height) of one cell in the grid
            of cells. The return value is a tuple of two floats.


        """
        return _hou.ReferencePlane_cellSize(self)

    def setCellSize(self, size: "_DoubleTuple") -> "void":
        r"""

        setCellSize(self, size)

            Change the x and y sizes (width and height) of each cell in the grid
            of cells. size is a sequence of two floats.

            Changing the size of each cell will change the total size of the
            grid.


        """
        return _hou.ReferencePlane_setCellSize(self, size)

    def numberOfCellsPerRulerLine(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        numberOfCellsPerRulerLine(self) -> tuple of int

            Return the number of cells in the x and y directions between ruler
            lines. Ruler lines are darker than the normal lines drawn between
            grid cells.


        """
        return _hou.ReferencePlane_numberOfCellsPerRulerLine(self)

    def setNumberOfCellsPerRulerLine(self, number: "_IntTuple") -> "void":
        return _hou.ReferencePlane_setNumberOfCellsPerRulerLine(self, number)


# Register ReferencePlane in _hou:
_hou.ReferencePlane_swigregister(ReferencePlane)


class RopNode(Node):
    r"""

    hou.RopNode

    Represents a render output node.

    RELATED

      * render


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_RopNode

    def __repr__(self) -> "std::string":
        return _hou.RopNode___repr__(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns whether this node's bypass flag is on.


        """
        return _hou.RopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turns the node's bypass flag on or off, making this node have no
            effect.


        """
        return _hou.RopNode_bypass(self, on)

    def isLocked(self) -> "bool":
        r"""

        isLocked(self) -> bool

            Returns whether this node's lock flag is on.


        """
        return _hou.RopNode_isLocked(self)

    def setLocked(self, on: "bool") -> "void":
        r"""

        setLocked(self, on)

            Sets this node's lock flag on or off. The lock flag caches the
            node's data and the data from its inputs and prevents them from
            being recalculated during cooking.


        """
        return _hou.RopNode_setLocked(self, on)

    def inputDependencies(
        self,
    ) -> "std::vector< std::pair< HOM_ElemPtr< HOM_Node >,std::vector< double,std::allocator< double > > >,std::allocator< std::pair< HOM_ElemPtr< HOM_Node >,std::vector< double,std::allocator< double > > > > >":
        r"""

        inputDependencies(self) -> (tuple of hou.RopNode, tuple of tuples of
        float)

            Returns the input dependencies of the ROP node, consisting of ROPs,
            and the frames that need to be be rendered prior to rendering the
            ROP.

            This method returns a tuple of two elements:

          * The first element is a sequence of the hou.RopNode objects
            representing the input dependencies.

          * The second element is a sequence, where each element corresponds to
            the RopNode object at the same position in the first sequence, and
            is a sequence of floats representing the frames that must be
            rendered for the corresponding RopNode.


        """
        return _hou.RopNode_inputDependencies(self)

    def render(self, *args, **kwargs) -> "void":
        r"""

        render(self, frame_range=(), res=(), output_file=None,
        output_format=None, to_flipbook=False, quality=2, ignore_inputs=False,
        method=RopByRop, ignore_bypass_flags=False, ignore_lock_flags=False,
        verbose=False, output_progress=False)

            Renders this node and optionally any of its inputs. Inputs are
            recursively processed (unless ignore_inputs is True), so that all
            descendents are rendered in the proper order before this node is
            rendered.


            frame_range
                Sequence of 2 or 3 values, overrides the frame range and frame
                increment to render. The first two values specify the start and
                end frames, and the third value (if given) specifies the frame
                increment. If no frame increment is given and the ROP node
                doesn't specify a frame increment, then a value of 1 will be
                used. If no frame range is given, and the ROP node doesn't
                specify a frame range, then the current frame will be rendered.

            res
                Sequence of two scaling factors that will be used to scale the
                resolution of the image, along the x- and y-axes. The scaling
                factors will be applied to the node and all dependencies that
                are also rendered.

            output_file
                Overrides the location to which the image is written.

            output_format
                Overrides the format of the image.

            to_flipbook
                If True, renders this node to a flipbook.

            quality
                Overrides the render quality.

            ignore_inputs
                If True, renders only this node (does not render any of its
                dependencies).

            method
                Either hou.renderMethod.RopByRop or
                hou.renderMethod.FrameByFrame. The default is ROP by ROP: each
                ROP will render its entire sequence before proceeding to the
                next ROP. If you specify FrameByFrame, all ROPs will render the
                first frame, then the second, etc.

                This parameter is only relevant when rendering ROPs in a
                dependency network.

            ignore_bypass_flags
                If True, renders this node even if its bypass flag is on.

            ignore_lock_flags
                If True, ignores any lock flags on this node and its
                dependencies.

            verbose
                If True, then the method will print messages during the render.
                For example, a message is printed when each frame starts
                rendering.

            output_progress
                If True, then the method will print Alfred-style progress
                messages. This argument does not apply if the verbose argument
                is set to False.


        """
        return _hou.RopNode_render(self, *args, **kwargs)

    def removeAllRenderEventCallbacks(self) -> "void":
        r"""

        removeAllRenderEventCallbacks(self)

            Remove all render event callbacks added to this node.

            See hou.Node.addRenderEventCallback for more information.


        """
        return _hou.RopNode_removeAllRenderEventCallbacks(self)

    def addRenderEventCallback(
        self, callback: "InterpreterObject", run_before_script: "bool" = False
    ) -> "void":
        r"""

        addRenderEventCallback(self, callback, run_before_script = False)

            Registers a Python callback that Houdini call whenever a render
            event occurs on this particular node instance. The event callback is
            run immediately before or after the correspoding script callback on
            the ROP node, such as the Pre Frame or Post Frame script, depending
            on the value of run_before_script.

            Callbacks only persist for the current session -- they're not saved
            to the .hip file. If you want persistent callbacks in every session,
            you can add them in code in 456.py (runs when the user opens a .hip
            file). See where to add Python scripting for more information.
            Alternatively, you can add your callback to the script hook
            parameters on the ROP node parameter interface.


            callback
                A callable Python object, such as a function or bound method.
                The callback is invoked with the hou.RopNode instance that it
                was added to, the hou.ropRenderEventType that indicates the type
                of event that occurred, and the time at which the event occured.

            run_before_script
                A boolean value that indicates whether or not the callback
                should be inovked before the correpsonding script callback on
                the ROP node. By default, callbacks are invoked after the script
                has completed.


            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to a render event.

            The following example shows to set up a function that's called
            whenever a ROP node finishes rendering a frame

          >
          > def frame_completed(rop_node, render_event_type, time):
          >     if render_event_type = hou.ropRenderEventType.PostFrame:
          >         print(\"{} finished rendering frame at t={}\", node.name(), time)
          >
          > hou.node(\"/out/geometry1\").addRenderEventCallback(frame_completed)

            See also hou.RopNode.removeRenderEventCallback and
            hou.RopNode.removeAllRenderEventCallbacks.


        """
        return _hou.RopNode_addRenderEventCallback(self, callback, run_before_script)

    def removeRenderEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeRenderEventCallback(self, callback)

            Removes a render event callback that was previously added on this
            node.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.RopNode.addRenderEventCallback for more information.


        """
        return _hou.RopNode_removeRenderEventCallback(self, callback)


# Register RopNode in _hou:
_hou.RopNode_swigregister(RopNode)


class SceneGraphTree(PathBasedPaneTab):
    r"""

    hou.SceneGraphTree

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_SceneGraphTree

    def __repr__(self) -> "std::string":
        return _hou.SceneGraphTree___repr__(self)

    def showInactivePrimitives(self) -> "bool":
        r"""

        showInactivePrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether inactive USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_showInactivePrimitives(self)

    def setShowInactivePrimitives(self, show: "bool") -> "void":
        r"""

        setShowInactivePrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether inactive USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_setShowInactivePrimitives(self, show)

    def showInvisiblePrimitives(self) -> "bool":
        r"""

        showInvisiblePrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether invisible USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_showInvisiblePrimitives(self)

    def setShowInvisiblePrimitives(self, show: "bool") -> "void":
        r"""

        setShowInvisiblePrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether invisible USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_setShowInvisiblePrimitives(self, show)

    def showOverPrimitives(self) -> "bool":
        r"""

        showOverPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether pure override USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_showOverPrimitives(self)

    def setShowOverPrimitives(self, show: "bool") -> "void":
        r"""

        setShowOverPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether pure override USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_setShowOverPrimitives(self, show)

    def showClassPrimitives(self) -> "bool":
        r"""

        showClassPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether class specifier USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_showClassPrimitives(self)

    def setShowClassPrimitives(self, show: "bool") -> "void":
        r"""

        setShowClassPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether class specifier USD primitives appear in the tree.


        """
        return _hou.SceneGraphTree_setShowClassPrimitives(self, show)

    def showPrototypePrimitives(self) -> "bool":
        r"""

        showPrototypePrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether implicit prototype primitives appear in the tree.


        """
        return _hou.SceneGraphTree_showPrototypePrimitives(self)

    def setShowPrototypePrimitives(self, show: "bool") -> "void":
        r"""

        setShowPrototypePrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether implicit prototype primitives appear in the tree.


        """
        return _hou.SceneGraphTree_setShowPrototypePrimitives(self, show)

    def showLayerInfoPrimitives(self) -> "bool":
        r"""

        showLayerInfoPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether Houdini Layer Info primitives appear in the tree.


        """
        return _hou.SceneGraphTree_showLayerInfoPrimitives(self)

    def setShowLayerInfoPrimitives(self, show: "bool") -> "void":
        r"""

        setShowLayerInfoPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether Houdini Layer Info primitives appear in the tree.


        """
        return _hou.SceneGraphTree_setShowLayerInfoPrimitives(self, show)

    def showHiddenInUiPrimitives(self) -> "bool":
        r"""

        showHiddenInUiPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether primitives configured to be hidden in the UI should
            appear in the tree.


        """
        return _hou.SceneGraphTree_showHiddenInUiPrimitives(self)

    def setShowHiddenInUiPrimitives(self, show: "bool") -> "void":
        r"""

        setShowHiddenInUiPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether primitives configured to be hidden in the UI appear
            in the tree.


        """
        return _hou.SceneGraphTree_setShowHiddenInUiPrimitives(self, show)

    def allColumns(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        allColumns(self) -> tuple of str

            Return a tuple of strings with the symbolic names of all the columns
            that can be enabled in the scene graph tree. This corresponds to the
            set of all columns listed under the scene graph tree settings menu.


        """
        return _hou.SceneGraphTree_allColumns(self)

    def visibleColumns(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        visibleColumns(self) -> tuple of str

            Return a tuple of strings with the symbolic names of all the columns
            that are currently enabled in the scene graph tree. This corresponds
            to the set of columns listed under the scene graph tree settings
            menu that are checked.


        """
        return _hou.SceneGraphTree_visibleColumns(self)

    def setVisibleColumns(self, columns: "_StringTuple") -> "void":
        r"""

        setVisibleColumns(self, columns)

            Return a tuple of strings with the symbolic names of all the columns
            that are currently enabled in the scene graph tree. This corresponds
            to the set of columns listed under the scene graph tree settings
            menu that are checked.


        """
        return _hou.SceneGraphTree_setVisibleColumns(self, columns)

    def filterPattern(self) -> "std::string":
        r"""

        filterPattern(self) -> str

            Return the current value set in the scene graph tree filter field.
            Only primitives that match this pattern (and their ancestor
            primitives) appear in the scene graph tree. This pattern supports
            all the standard primitive pattern matching capabilities described
            in Primitive matching patterns.


        """
        return _hou.SceneGraphTree_filterPattern(self)

    def setFilterPattern(self, pattern: "char const *") -> "void":
        r"""

        setFilterPattern(self, pattern)

            Set the pattern string in the scene graph tree filter field.


        """
        return _hou.SceneGraphTree_setFilterPattern(self, pattern)

    def filterVisible(self) -> "bool":
        r"""

        filterVisible(self) -> bool

            Return True if the filter field for the scene graph tree is expanded
            and visible. This field appears at the bottom of the tree, just
            above the splitter bar. Return False if this field has been
            collapsed and is not visible.


        """
        return _hou.SceneGraphTree_filterVisible(self)

    def setFilterVisible(self, visible: "bool") -> "void":
        r"""

        setFilterVisible(self, visible)

            Expand or collapse the filter field at the bottom of the scene graph
            tree. Note that the filter is applied whether or not the input field
            is visible.


        """
        return _hou.SceneGraphTree_setFilterVisible(self, visible)

    def splitPosition(self) -> "float":
        r"""

        splitPosition(self) -> float

            Return a number indicating the position of the splitter bar that
            separates the scene graph tree from the collection tree. The value
            will between -1.0 and 2.0. Any value between 0.0 and 1.0 indicates
            that both panes are visible, and the value indicates the proportion
            of the space taken up by the collection tree (i.e. the value
            reflects the distance of the splitter bar from the bottom of the
            pane).

            A value greater than 1.0 indicates that the splitter bar is at the
            top of the pane, hiding the scene graph tree. Subtracting 1.0 from
            the value indicates the position of the splitter bar before the
            scene graph tree was collapsed.

            A value less than 0.0 indicates that the splitter bar is at the
            bottom of the pane, hiding the collection tree. Adding 1.0 to the
            value indicates the position of the splitter bar before the
            collection tree was collapsed.


        """
        return _hou.SceneGraphTree_splitPosition(self)

    def setSplitPosition(self, position: "float") -> "void":
        r"""

        setSplitPosition(self, position)

            Set the position of the splitter bar that separates the scene graph
            tree from the collection tree. This value must be between -1.0 and
            2.0. See splitPosition for a description of the meaning of the
            position value.


        """
        return _hou.SceneGraphTree_setSplitPosition(self, position)

    def collectionPrimitives(self) -> "std::string":
        r"""

        collectionPrimitives(self) -> str

            Return the string pattern that controls which USD primitives are
            searched to populate the collection panel at the bottom of the scene
            graph tree.


        """
        return _hou.SceneGraphTree_collectionPrimitives(self)

    def setCollectionPrimitives(self, pattern: "char const *") -> "void":
        r"""

        setCollectionPrimitives(self, pattern)

            Set the string pattern that controls which USD primitive are
            searched to populate the collection panel at the bottom of the scene
            graph tree.


        """
        return _hou.SceneGraphTree_setCollectionPrimitives(self, pattern)

    def collectionFilterPattern(self) -> "std::string":
        r"""

        collectionFilterPattern(self) -> str

            Return the current value set in the collection tree filter field.
            Only collections and selection rules that match this pattern (and
            their ancestors) appear in the collection tree. This pattern uses
            standard Houdini string matching techniques to test each entry in
            the tree.


        """
        return _hou.SceneGraphTree_collectionFilterPattern(self)

    def setCollectionFilterPattern(self, pattern: "char const *") -> "void":
        r"""

        setCollectionFilterPattern(self, pattern)

            Set the pattern string in the collection tree filter field.


        """
        return _hou.SceneGraphTree_setCollectionFilterPattern(self, pattern)

    def collectionFilterVisible(self) -> "bool":
        r"""

        collectionFilterVisible(self) -> bool

            Return True if the filter field for the collection tree is expanded
            and visible. This field appears at the bottom of the tree, just
            above the splitter bar. Return False if this field has been
            collapsed and is not visible.


        """
        return _hou.SceneGraphTree_collectionFilterVisible(self)

    def setCollectionFilterVisible(self, visible: "bool") -> "void":
        r"""

        setCollectionFilterVisible(self, visible)

            Expand or collapse the filter field at the bottom of the collection
            tree. Note that the filter is applied whether or not the input field
            is visible.


        """
        return _hou.SceneGraphTree_setCollectionFilterVisible(self, visible)

    def collapsePrimitives(self, prims: "InterpreterObject") -> "void":
        r"""

        collapsePrimitives(self, paths)

            Collapse the scene graph tree locations indicated by the strings or
            pxr.Sdf.Path objects in the iterable paths parameter. Descendants of
            these primitives will no longer be visible in the tree. If a
            primitive in paths is not currently visible or is already collapsed,
            the tree will not change.


        """
        return _hou.SceneGraphTree_collapsePrimitives(self, prims)

    def expandPrimitives(
        self,
        prims: "InterpreterObject",
        collapse_others: "bool" = False,
        expand_leaf_primitives: "bool" = False,
    ) -> "void":
        r"""

        expandPrimitives(self, paths, collapse_others=False,
        expand_leaf_primitives=False)

            Expand the scene graph tree such that the locations indicated by the
            strings or pxr.Sdf.Path objects in the iterable paths parameter are
            visible. If collapse_others is True, all scene graph tree locations
            will be collapsed before expanding any primitives, leaving the tree
            in a state where exactly the provided list of scene graph locations
            will be visible. If expand_leaf_primitives is True, then the tree
            will be expanded such that all the primitives in the paths object
            will not just be made visible, but will be expanded, making all of
            their children visible as well.


        """
        return _hou.SceneGraphTree_expandPrimitives(
            self, prims, collapse_others, expand_leaf_primitives
        )

    def expandedPrimitives(
        self, include_leaf_primitives: "bool" = False
    ) -> "InterpreterObject":
        r"""

        expandedPrimitives(self, include_leaf_primitives=False) -> list of
        pxr.Sdf.Path

            Return a list of scene graph locations that are expanded in the
            scene graph tree. If include_leaf_primitives is True, all children
            of expanded primitives will also be returned in the list,
            effectively returning a list of all visible primitives in the tree.
            Otherwise only primitives that are actually expanded are returned,
            meaning that no leaf primitives (which have no children) will ever
            be returned in this mode.


        """
        return _hou.SceneGraphTree_expandedPrimitives(self, include_leaf_primitives)


# Register SceneGraphTree in _hou:
_hou.SceneGraphTree_swigregister(SceneGraphTree)


class SceneViewer(PathBasedPaneTab):
    r"""

    hou.SceneViewer

    Pane tab type dedicated to displaying the current scene. This is usually
    the biggest pane in the center of the pane layout.

    OVERVIEW

        A viewer is a type of pane that shows the scene. The viewer's
        contents is conceptually divided into viewports. By default, the
        scene viewer shows a single viewport, the Perspective view. However,
        you can use the view layout controls to, for example, split the view
        into four viewports (Perspective, Top, Front, and Right views).
        Viewports are the parts of the interface that actually display the
        scene to the user.

        To get a reference to a scene viewer, see the following methods:


        hou.ui.paneTabOfType
            Use hou.ui.paneTabOfType(hou.paneTabType.SceneViewer) to get a
            Scene Viewer pane tab in the current pane layout. If the current
            layout has no Scene Viewer pane tab, this returns None.

            To be more precise about which viewer you grab in a possible
            multi-viewer layout, see also hou.ui.curDesktop to get a
            hou.Desktop object representing the current pane layout, and
            hou.Desktop.sceneViewers to get a list of scene viewer pane tabs
            in the current layout.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_SceneViewer

    def __repr__(self) -> "std::string":
        return _hou.SceneViewer___repr__(self)

    def viewerType(self) -> "HOM_EnumValue &":
        r"""

        viewerType(self) -> hou.stateViewerType enum value

            Returns the type of the viewer, either Scene for a viewer looking at
            Objects, SOPs, or DOPs; or SceneGraph for a viewer looking at LOPs.


        """
        return _hou.SceneViewer_viewerType(self)

    def viewports(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_GeometryViewport >,std::allocator< HOM_ElemPtr< HOM_GeometryViewport > > >":
        r"""

        viewports(self) -> tuple of hou.GeometryViewports


        """
        return _hou.SceneViewer_viewports(self)

    def findViewport(self, name: "char const *") -> "HOM_GeometryViewport *":
        r"""

        findViewport(self, name) -> hou.GeometryViewport


        """
        return _hou.SceneViewer_findViewport(self, name)

    def curViewport(self) -> "HOM_GeometryViewport *":
        r"""

        curViewport(self) -> hou.GeometryViewport

            Returns this viewer's current viewport. The current viewport is the
            one containing the mouse cursor. If the cursor is not in a viewport,
            then the selected, or active, viewport is returned.


        """
        return _hou.SceneViewer_curViewport(self)

    def selectedViewport(self) -> "HOM_GeometryViewport *":
        r"""

        selectedViewport(self) -> hou.GeometryViewport

            Returns this viewer's selected viewport. Viewports can be selected
            by holding [Space] and pressing the [N] key.


        """
        return _hou.SceneViewer_selectedViewport(self)

    def currentState(self) -> "std::string":
        r"""

        currentState(self) -> string

            Returns the name of the viewer's current tool state.


        """
        return _hou.SceneViewer_currentState(self)

    def enterViewState(self, wait_for_exit: "bool" = False) -> "void":
        r"""

        enterViewState(self, wait_for_exit=False)

            Enters the viewer into view tool state. If wait_for_exit is True,
            then the function will not return until the viewer exits the tool.


        """
        return _hou.SceneViewer_enterViewState(self, wait_for_exit)

    def enterCurrentNodeState(self, wait_for_exit: "bool" = False) -> "void":
        r"""

        enterCurrentNodeState(self, wait_for_exit=False)

            Enters the viewer into the node-specific tool state of the last
            selected node. If wait_for_exit is True, then the function will not
            return until the viewer exits the tool.


        """
        return _hou.SceneViewer_enterCurrentNodeState(self, wait_for_exit)

    def enterTranslateToolState(self, wait_for_exit: "bool" = False) -> "void":
        r"""

        enterTranslateToolState(self, wait_for_exit=False)

            Enters the viewer into translate tool state. This is available only
            for the node contexts that support the move tools. If wait_for_exit
            is True, then the function will not return until the viewer exits
            the tool.


        """
        return _hou.SceneViewer_enterTranslateToolState(self, wait_for_exit)

    def enterRotateToolState(self, wait_for_exit: "bool" = False) -> "void":
        r"""

        enterRotateToolState(self, wait_for_exit=False)

            Enters the viewer into rotate tool state. This is available only for
            the node contexts that support the move tools. If wait_for_exit is
            True, then the function will not return until the viewer exits the
            tool.


        """
        return _hou.SceneViewer_enterRotateToolState(self, wait_for_exit)

    def enterScaleToolState(self, wait_for_exit: "bool" = False) -> "void":
        r"""

        enterScaleToolState(self, wait_for_exit=False)

            Enters the viewer into scale tool state. This is available only for
            the node contexts that support the move tools. If wait_for_exit is
            True, then the function will not return until the viewer exits the
            tool.


        """
        return _hou.SceneViewer_enterScaleToolState(self, wait_for_exit)

    def setCurrentState(self, *args, **kwargs) -> "void":
        r"""

        setCurrentState(self, state, wait_for_exit=False,
        generate=hou.stateGenerateMode.Insert, request_new_on_generate=True,
        ex_situ_generate=False)

            Sets the current tool state of the viewer. If wait_for_exit is True,
            then the function will not return until the viewer exits the tool.


            generate
                A hou.stateGenerateMode enumeration value to specify how a new
                node should be generated, inserted inline or into a new branch.

            request_new_on_generate
                Some states reuse the current node whenever possible. Setting
                this argument to True requests that such states generate a new
                node.

            ex_situ_generate
                Some states do things like initialize their selectors from
                stashed temporary selections or cook selections during
                generation. Such actions make sense when the state is launched
                in situ, but are not desired if the script first changed network
                levels or displayed nodes so that the viewer context the state
                starts with differs from the one the user sees when triggering
                the script. Setting this argument to True tells the state not to
                assume that the viewer context at the time of generation matches
                what the user expects.


        """
        return _hou.SceneViewer_setCurrentState(self, *args, **kwargs)

    def _waitForStateExit(self, state: "char const *" = None) -> "void":
        return _hou.SceneViewer__waitForStateExit(self, state)

    def _currentBaseState(self) -> "std::string":
        return _hou.SceneViewer__currentBaseState(self)

    def _getCurrentStateParmNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.SceneViewer__getCurrentStateParmNames(self)

    def _evalCurrentStateParm(self, name: "char const *") -> "std::string":
        return _hou.SceneViewer__evalCurrentStateParm(self, name)

    def _setCurrentStateParm(
        self, name: "char const *", value: "char const *"
    ) -> "bool":
        return _hou.SceneViewer__setCurrentStateParm(self, name, value)

    def _pressCurrentStateButton(self, name: "char const *") -> "bool":
        return _hou.SceneViewer__pressCurrentStateButton(self, name)

    def isCreateInContext(self) -> "bool":
        r"""

        isCreateInContext(self) -> bool


        """
        return _hou.SceneViewer_isCreateInContext(self)

    def isWorldSpaceLocal(self) -> "bool":
        r"""

        isWorldSpaceLocal(self) -> bool

            Returns true if values that would normally be in world space are
            actually in the local space of the current object. This includes
            things like the return values of selectPositions(),
            hou.GeometryViewport::mapToScreen(),
            hou.GeometryViewport::mapToWorld(),
            hou.GeometryViewport().viewPivot(), etc.


        """
        return _hou.SceneViewer_isWorldSpaceLocal(self)

    def viewportLayout(self) -> "HOM_EnumValue &":
        r"""

        viewportLayout(self) -> hou.geometryViewportLayout

            Returns the current viewport layout as a hou.geometryViewportLayout
            value.


        """
        return _hou.SceneViewer_viewportLayout(self)

    def setViewportLayout(self, layout: "EnumValue", single: "int" = -1) -> "void":
        r"""

        setViewportLayout(self, layout, single=-1)

            Sets the viewer's viewport layout.


            layout
                A hou.geometryViewportLayout value. For example, to set the
                viewer to show four viewports at the corners:

              > viewer_pane.setViewportLayout(hou.geometryViewportLayout.Quad)

            single
                If you specify the layout, this argument lets you specify which
                of the four viewports from the quad view to show as the single

                -1

                Use the current viewport (the viewport the mouse is/was over).

                0

                Use the top-left viewport from the quad layout (usually the Top
                view).

                1

                Use the top-right viewport from the quad layout (usually the
                Perspective view).

                2

                Use the bottom-left viewport from the quad layout (usually the
                Front view).

                3

                Use the bottom-right viewport from the quad layout (usually the
                Right view).


        """
        return _hou.SceneViewer_setViewportLayout(self, layout, single)

    def selectObjects(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        selectObjects(self, prompt='Select objects', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        allow_multisel=True, allowed_types=('*',), icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[],
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\"\")
        -> tuple of Nodes


        """
        return _hou.SceneViewer_selectObjects(self, *args, **kwargs)

    def selectGeometry(self, *args, **kwargs) -> "HOM_GeometrySelection *":
        r"""

        selectGeometry(self, prompt='Select geometry', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        initial_selection = None, initial_selection_type = None, ordered=False,
        geometry_types=(), primitive_types=(), allow_obj_sel=True, icon=None,
        label=None, prior_selection_paths=[], prior_selection_ids=[],
        prior_selections=[], allow_other_sops=True, consume_selections=True,
        toolbox_templategroup=None, toolbox1_templategroup=None,
        confirm_existing=False, pick_at_obj_level=False, select_parm=\"\") ->
        GeometrySelection


        """
        return _hou.SceneViewer_selectGeometry(self, *args, **kwargs)

    def selectDynamics(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
        r"""

        selectDynamics(self, prompt='Select dynamics objects', sel_index=0,
        allow_objects=True, allow_modifiers=False, quick_select=False,
        use_existing_selection=True, allow_multisel=True, icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[],
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\"\")
        -> tuple of hou.DopData


        """
        return _hou.SceneViewer_selectDynamics(self, *args, **kwargs)

    def selectDynamicsPoints(
        self, *args, **kwargs
    ) -> "std::vector< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > >,std::allocator< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > > > >":
        r"""

        selectDynamicsPoints(self, prompt='Select dynamics points', sel_index=0,
        quick_select=False, use_existing_selection=True, allow_multisel=True,
        only_select_points=True, object_based_point_selection=False,
        use_last_selected_object=False, icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[],
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\"\")
        -> tuple of (hou.DopData, hou.GeometrySelection)


        """
        return _hou.SceneViewer_selectDynamicsPoints(self, *args, **kwargs)

    def selectDynamicsPolygons(
        self, *args, **kwargs
    ) -> "std::vector< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > >,std::allocator< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > > > >":
        r"""

        selectDynamicsPolygons(self, prompt='Select dynamics polygons',
        sel_index=0, quick_select=False, use_existing_selection=True,
        object_based_point_selection=False, use_last_selected_object=False,
        icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[],
        prior_selections=[], toolbox_templategroup=None,
        toolbox1_templategroup=None, select_parm=\"\") -> tuple of (hou.DopData,
        hou.GeometrySelection)


        """
        return _hou.SceneViewer_selectDynamicsPolygons(self, *args, **kwargs)

    def selectSceneGraph(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectSceneGraph(self, prompt='Select primitives', preselection=[],
        prim_mask=hou.scenePrimMask.ViewerSetting, quick_select=False,
        use_existing_selection=True, confirm_existing=False,
        allow_multisel=True, allow_drag=True, propagate_selection=True,
        path_prefix_mask='', prim_kind='', validate_selection_for_node=None,
        select_parm='', allow_kind_mismatch=hou.optionalBool.NoOpinion,
        allow_instance_proxies=hou.optionalBool.NoOpinion) -> tuple of string


        """
        return _hou.SceneViewer_selectSceneGraph(self, *args, **kwargs)

    def selectSceneGraphInstances(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectSceneGraphInstances(self, prompt='Select point instances',
        preselection=[], quick_select=False, use_existing_selection=True,
        confirm_existing=False, allow_multisel=True, allow_drag=True,
        path_prefix_mask=\"\", instance_level=0, instance_indices_only=False,
        validate_selection_for_node=None, select_parm=\"\") -> tuple of string


        """
        return _hou.SceneViewer_selectSceneGraphInstances(self, *args, **kwargs)

    def selectPositions(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_Vector3 >,std::allocator< HOM_ElemPtr< HOM_Vector3 > > >":
        r"""

        selectPositions(self, prompt='Click to specify a position',
        number_of_positions=1, min_number_of_positions=-1,
        connect_positions=True, show_coordinates=True, bbox=BoundingBox(),
        position_type=positionType.WorldSpace, icon=None, label=None,
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\"\")
        -> tuple of Vector3s


        """
        return _hou.SceneViewer_selectPositions(self, *args, **kwargs)

    def selectOrientedPositions(
        self, *args, **kwargs
    ) -> "std::vector< std::pair< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Matrix3 > >,std::allocator< std::pair< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Matrix3 > > > >":
        r"""

        selectOrientedPositions(self, prompt='Click to specify a position',
        number_of_positions=1, min_number_of_positions=-1,
        connect_positions=True, show_coordinates=True,
        bbox=BoundingBox(),icon=None, label=None, toolbox_templategroup=None,
        toolbox1_templategroup=None, select_parm=\"\") -> tuple of (Vector3,
        Matrix3) tuples

            This method is very similar to hou.SceneViewer.selectPositions,
            except the position type is always world space, and instead of a
            tuple of positions this returns a tuple of (position, orientation)
            pairs, with the position a hou.Vector3 and the orientation a
            hou.Matrix3. This allows you to prompt the user for oriented
            position, respecting possible orientation aids such as the
            construction plane and alignment.


        """
        return _hou.SceneViewer_selectOrientedPositions(self, *args, **kwargs)

    def selectDrawableGeometry(self, *args, **kwargs) -> "void":
        r"""

        selectDrawableGeometry(self, drawable_selection,
        selection_modifier=hou.pickModifier.Replace)

            Performs a drawable geometry selection. This method works only when
            a drawable selector is running, it can be called either from the
            python state implementing the selector or from a regular python
            script. Calling this method will trigger the python state's
            onSelection handler.

            Raises hou.OperationFailed if no drawable selector is running or
            hou.InvalidInput if the input arguments are invalid.


            drawable_selection
                A dictionary describing the drawable elements to select, the
                content of the dictionary is described here.

            selection_modifier
                The selection modifier for the selection. Defaults to
                hou.pickModifier.Replace.


        """
        return _hou.SceneViewer_selectDrawableGeometry(self, *args, **kwargs)

    def currentGeometrySelection(self) -> "HOM_GeometrySelection *":
        r"""

        currentGeometrySelection(self) -> hou.GeometrySelection

            Returns the current geometry selection if the viewer is in a
            geometry select mode and otherwise returns None.


        """
        return _hou.SceneViewer_currentGeometrySelection(self)

    def currentGeometrySelectionParm(self) -> "std::string":
        r"""

        currentGeometrySelectionParm(self) -> string

            Returns the current geometry selection parameter string if the
            viewer is doing a scripted selection. This holds the select_parm
            argument given to methods such as selectGeometry.


        """
        return _hou.SceneViewer_currentGeometrySelectionParm(self)

    def setCurrentGeometrySelection(
        self,
        geometry_type: "EnumValue",
        nodes: "_NodeTuple",
        selections: "std::vector< HOM_Selection *,std::allocator< HOM_Selection * > > const &",
    ) -> "void":
        r"""

        setCurrentGeometrySelection(self, geometry_type, nodes, selections)

            Replaces a current geometry selection if the viewer is in a geometry
            select mode and otherwise raises hou.NotAvailable. Any of the
            specified selections not matching geometry_type will be
            automatically converted to that type where possible.


        """
        return _hou.SceneViewer_setCurrentGeometrySelection(
            self, geometry_type, nodes, selections
        )

    def currentSceneGraphSelection(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        currentSceneGraphSelection(self) -> tuple of string


        """
        return _hou.SceneViewer_currentSceneGraphSelection(self)

    def setCurrentSceneGraphSelection(self, selection: "_StringTuple") -> "void":
        r"""

        setCurrentSceneGraphSelection(selection)


        """
        return _hou.SceneViewer_setCurrentSceneGraphSelection(self, selection)

    def locateSceneGraphPrim(self, *args) -> "UT_Tuple< double,std::string >":
        r"""

        locateSceneGraphPrim(self, x, y) -> (float, string)

            Find the primitive located at at the specified pixel coordinates.
            Returns a tuple of screen depth at the hit location and primitive
            path. Returns (-1, ) when no primitive is found.


        """
        return _hou.SceneViewer_locateSceneGraphPrim(self, *args)

    def sceneGraphStageLocked(self) -> "bool":
        r"""

        sceneGraphStageLocked(self) -> bool

            Return True if the viewer's USD stage is locked to its current
            state, so that it does not update when changes are made to the LOP
            Network. This is similar to the Manual Update Mode, but only affects
            this viewer pane. All other Houdini panes, such as the Scene Graph
            Tree or Scene Graph Details will continue to update with new stage
            contents from the LOP network.


        """
        return _hou.SceneViewer_sceneGraphStageLocked(self)

    def setSceneGraphStageLocked(self, locked: "bool") -> "void":
        r"""

        setSceneGraphStageLocked(self, locked)

            Set the flag indicating that this viewer should not update its stage
            contents in response to changes in the LOP Network.


        """
        return _hou.SceneViewer_setSceneGraphStageLocked(self, locked)

    def snappingMode(self) -> "HOM_EnumValue &":
        r"""

        snappingMode(self)


        """
        return _hou.SceneViewer_snappingMode(self)

    def setSnappingMode(self, snapping_mode: "EnumValue") -> "void":
        r"""

        setSnappingMode(self, snapping_mode)


        """
        return _hou.SceneViewer_setSnappingMode(self, snapping_mode)

    def isSnappingToCurrentGeometry(self) -> "bool":
        r"""

        isSnappingToCurrentGeometry(self)

            Returns whether snapping to current geometry is enabled for the
            current snapping mode.


        """
        return _hou.SceneViewer_isSnappingToCurrentGeometry(self)

    def setSnapToCurrentGeometry(self, on: "bool") -> "void":
        r"""

        setSnapToCurrentGeometry(self, on)

            Sets whether or not snapping to current geometry is enabled for the
            current snapping mode.


        """
        return _hou.SceneViewer_setSnapToCurrentGeometry(self, on)

    def isSnappingToTemplates(self) -> "bool":
        r"""

        isSnappingToTemplates(self)


        """
        return _hou.SceneViewer_isSnappingToTemplates(self)

    def setSnapToTemplates(self, on: "bool") -> "void":
        r"""

        setSnapToTemplates(self, on)


        """
        return _hou.SceneViewer_setSnapToTemplates(self, on)

    def isSnappingToOtherObjects(self) -> "bool":
        r"""

        isSnappingToOtherObjects(self)


        """
        return _hou.SceneViewer_isSnappingToOtherObjects(self)

    def setSnapToOtherObjects(self, on: "bool") -> "void":
        r"""

        setSnapToOtherObjects(self, on)


        """
        return _hou.SceneViewer_setSnapToOtherObjects(self, on)

    def isSnappingToGuides(self) -> "bool":
        r"""

        isSnappingToGuides(self) -> bool

            Returns whether snapping to guides is enabled for the current
            snapping mode.


        """
        return _hou.SceneViewer_isSnappingToGuides(self)

    def setSnapToGuides(self, on: "bool") -> "void":
        r"""

        setSnapToGuides(self, on)

            Sets whether or not snapping to guides is enabled for the current
            snapping mode.


        """
        return _hou.SceneViewer_setSnapToGuides(self, on)

    def isDepthSnapping(self) -> "bool":
        r"""

        isDepthSnapping(self)


        """
        return _hou.SceneViewer_isDepthSnapping(self)

    def setDepthSnapping(self, on: "bool") -> "void":
        r"""

        setDepthSnapping(self, on)


        """
        return _hou.SceneViewer_setDepthSnapping(self, on)

    def isOrientingOnSnap(self) -> "bool":
        r"""

        isOrientingOnSnap(self)


        """
        return _hou.SceneViewer_isOrientingOnSnap(self)

    def setOrientOnSnap(self, on: "bool") -> "void":
        r"""

        setOrientOnSnap(self, on)


        """
        return _hou.SceneViewer_setOrientOnSnap(self, on)

    def snappingGravity(self) -> "float":
        r"""

        snappingGravity(self): -> float

            Returns the gravity value for the current snapping mode.


        """
        return _hou.SceneViewer_snappingGravity(self)

    def snappingPriorities(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        snappingPriorities(self): -> tuple of hou.snappingPriority values

            Returns a tuple of hou.snappingPriority values for the current
            snapping mode. The values are sorted in order of priority
            (descending) as set in the Snap options window. Returns an empty
            tuple if the mode has no priorities.


        """
        return _hou.SceneViewer_snappingPriorities(self)

    def isPickingVisibleGeometry(self) -> "bool":
        r"""

        isPickingVisibleGeometry(self)

            Returns true if the viewer is configured to only pick visible
            components when performing an area-based selection. This option
            corresponds to the matching check box in the component selection
            button's context menu.


        """
        return _hou.SceneViewer_isPickingVisibleGeometry(self)

    def setPickingVisibleGeometry(self, on: "bool") -> "void":
        r"""

        setPickingVisibleGeometry(self, on)

            Turns on or off the option to select only visible components when
            performing area-based selections such as box or brush picking.


        """
        return _hou.SceneViewer_setPickingVisibleGeometry(self, on)

    def isPickingContainedGeometry(self) -> "bool":
        r"""

        isPickingContainedGeometry(self)

            Returns true if the viewer is configured to only pick fully
            contained components when performing an area-based selection. This
            option corresponds to the matching check box in the component
            selection button's context menu.


        """
        return _hou.SceneViewer_isPickingContainedGeometry(self)

    def setPickingContainedGeometry(self, on: "bool") -> "void":
        r"""

        setPickingContainedGeometry(self, on)

            Turns on or off the option to select only fully contained components
            when performing area-based selections such as box or brush picking.


        """
        return _hou.SceneViewer_setPickingContainedGeometry(self, on)

    def isGroupPicking(self) -> "bool":
        r"""

        isGroupPicking(self)

            Returns true if group, attribute, or connectivity information will
            be used to automatically expand selections made in this viewer. This
            option corresponds to the matching check box in the component
            selection button's context menu.


        """
        return _hou.SceneViewer_isGroupPicking(self)

    def setGroupPicking(self, on: "bool") -> "void":
        r"""

        setGroupPicking(self, on)

            Turns on or off the group, attribute, or connectivity based picking.
            When turned on, the group list gadget is automatically made visible.


        """
        return _hou.SceneViewer_setGroupPicking(self, on)

    def isWholeGeometryPicking(self) -> "bool":
        r"""

        isWholeGeometryPicking(self)

            Returns true if selections made in this viewer will automatically
            expand to include the whole geometry. This option corresponds to the
            matching check box in the component selection button's context menu.


        """
        return _hou.SceneViewer_isWholeGeometryPicking(self)

    def setWholeGeometryPicking(self, on: "bool") -> "void":
        r"""

        setWholeGeometryPicking(self, on)

            Turns on or off the option to expand selections made in this viewer
            to include the entire geometry.


        """
        return _hou.SceneViewer_setWholeGeometryPicking(self, on)

    def isSecureSelection(self) -> "bool":
        r"""

        isSecureSelection(self)

            Returns true if secure selection is turned on in this viewer. This
            option corresponds to the secure selection option in the select
            tool's context menu.


        """
        return _hou.SceneViewer_isSecureSelection(self)

    def setSecureSelection(self, on: "bool") -> "void":
        r"""

        setSecureSelection(self, on)

            Turns on or off the secure selection option in this viewer.


        """
        return _hou.SceneViewer_setSecureSelection(self, on)

    def isPickingCurrentNode(self) -> "bool":
        r"""

        isPickingCurrentNode(self)

            Returns true if selections made in this viewer will pick from the
            Current SOP. If not, the pick occurs on the Display SOP. This option
            corresponds to the current/display option in the component selection
            button's context menu.


        """
        return _hou.SceneViewer_isPickingCurrentNode(self)

    def setPickingCurrentNode(self, on: "bool") -> "void":
        r"""

        setPickingCurrentNode(self, on)

            Tells this viewer whether picks should be made on the Current SOP or
            on the Display SOP.


        """
        return _hou.SceneViewer_setPickingCurrentNode(self, on)

    def pickGeometryType(self) -> "HOM_EnumValue &":
        r"""

        pickGeometryType(self)

            Returns the type of geometry that will be picked in this viewer.
            This option corresponds to the component types selectable in the
            component selection button's context menu.


        """
        return _hou.SceneViewer_pickGeometryType(self)

    def setPickGeometryType(self, geometry_type: "EnumValue") -> "void":
        r"""

        setPickGeometryType(self, geometry_type)

            Sets the type of geometry that will be picked in this viewer. This
            value can be changed at any time by the user, or when a selector is
            invoked.


        """
        return _hou.SceneViewer_setPickGeometryType(self, geometry_type)

    def selectionMode(self) -> "HOM_EnumValue &":
        r"""

        selectionMode(self)

            Returns the selection mode of the viewer of type hou.selectionMode.


        """
        return _hou.SceneViewer_selectionMode(self)

    def setSelectionMode(self, style: "EnumValue") -> "void":
        r"""

        setSelectionMode(self, selection_mode)

            Sets the selection mode of this view. The value for 'selection_mode'
            must be from hou.selectionMode.


        """
        return _hou.SceneViewer_setSelectionMode(self, style)

    def pickStyle(self) -> "HOM_EnumValue &":
        r"""

        pickStyle(self)

            Returns the style of area picking currently being used by this
            viewer. This option corresponds to the picking style specified in
            the select tool's context menu.


        """
        return _hou.SceneViewer_pickStyle(self)

    def setPickStyle(self, style: "EnumValue") -> "void":
        r"""

        setPickStyle(self, style)

            Sets the style of area picking to be used by this viewer.


        """
        return _hou.SceneViewer_setPickStyle(self, style)

    def pickModifier(self) -> "HOM_EnumValue &":
        r"""

        pickModifier(self)

            Returns the manner in which additional selection are combined with
            the existing selection. Consider using
            hou.SceneViewer.toolPickModifier instead if you want the pick
            modifer as selected in the select tool menu.


        """
        return _hou.SceneViewer_pickModifier(self)

    def setPickModifier(self, modifier: "EnumValue") -> "void":
        r"""

        setPickModifier(self, modifier)

            Sets the method used to modify the existing selection when a new
            selection is made. Modifier keys can still be used to alter this
            behavior. Only the default operation (with no modifier keys) is
            affected by this setting. Note that the select state will revert to
            the default pick modifier upon termination, so to make your change
            persist beyond this you will also need to change this default using
            setDefaultPickModifier().


        """
        return _hou.SceneViewer_setPickModifier(self, modifier)

    def defaultPickModifier(self) -> "HOM_EnumValue &":
        r"""

        defaultPickModifier(self)

            Returns the default pick modifier to which Houdini will revert after
            a select state terminates.


        """
        return _hou.SceneViewer_defaultPickModifier(self)

    def setDefaultPickModifier(self, modifier: "EnumValue") -> "void":
        r"""

        setDefaultPickModifier(self, modifier)

            Sets the default pick modifier to which Houdini will revert after a
            select state terminates.


        """
        return _hou.SceneViewer_setDefaultPickModifier(self, modifier)

    def pickFacing(self) -> "HOM_EnumValue &":
        r"""

        pickFacing(self)

            Returns a value indicating whether the user is able to pick front
            facing components, back facing components, or both. This option
            corresponds to the front and back facing options in the component
            selection button's context menu.


        """
        return _hou.SceneViewer_pickFacing(self)

    def setPickFacing(self, facing: "EnumValue") -> "void":
        r"""

        setPickFacing(self, facing)

            Sets the option of whether to restrict selection to front facing,
            back facing, or either type of components.


        """
        return _hou.SceneViewer_setPickFacing(self, facing)

    def activePickModifier(self) -> "HOM_EnumValue &":
        r"""

        activePickModifier(self)

            This method is similar to hou.SceneViewer.pickModifier but returns
            the pick modifier as selected in the select tool menu.


        """
        return _hou.SceneViewer_activePickModifier(self)

    def isGroupListVisible(self) -> "bool":
        r"""

        isGroupListVisible(self)

            Returns true if the group list gadget has been turned on for this
            viewer. This function only refers to the option to show the group
            list when not selecting groups in the viewer. In that case the group
            list will be visible, but this function may still return False.


        """
        return _hou.SceneViewer_isGroupListVisible(self)

    def setGroupListVisible(self, on: "bool") -> "void":
        r"""

        setGroupListVisible(self, on)

            Turns on or off the group list gadget for this viewer.


        """
        return _hou.SceneViewer_setGroupListVisible(self, on)

    def isGroupListColoringGeometry(self) -> "bool":
        r"""

        isGroupListColoringGeometry(self)

            Returns true if the group list gadget is configured to color
            geometry in the viewer based on group membership or attribute value.


        """
        return _hou.SceneViewer_isGroupListColoringGeometry(self)

    def setGroupListColoringGeometry(self, on: "bool") -> "void":
        r"""

        setGroupListColoringGeometry(self, on)

            Turns on or off the group list gadget to coloring of geometry in the
            viewer based on group membership or attribute value.


        """
        return _hou.SceneViewer_setGroupListColoringGeometry(self, on)

    def isGroupListShowingEmptyGroups(self) -> "bool":
        r"""

        isGroupListShowingEmptyGroups(self)

            Returns true if the group list gadget is including empty groups in
            its list.


        """
        return _hou.SceneViewer_isGroupListShowingEmptyGroups(self)

    def setGroupListShowingEmptyGroups(self, on: "bool") -> "void":
        r"""

        setGroupListShowingEmptyGroups(self, on)

            Turns on or off the display of empty groups in the group list
            gadget.


        """
        return _hou.SceneViewer_setGroupListShowingEmptyGroups(self, on)

    def isGroupListShowingOnlyPreSelectedGroups(self) -> "bool":
        r"""

        isGroupListShowingOnlyPreSelectedGroups(self)

            Returns true if the group list is showing only groups that contain
            one or more selected or pre-selected components.


        """
        return _hou.SceneViewer_isGroupListShowingOnlyPreSelectedGroups(self)

    def setGroupListShowingOnlyPreSelectedGroups(self, on: "bool") -> "void":
        r"""

        setGroupListShowingOnlyPreSelectedGroups(self, on)

            Turns on or off the trimming of the group list to show only groups
            that contain one or more selected or pre-selected components.


        """
        return _hou.SceneViewer_setGroupListShowingOnlyPreSelectedGroups(self, on)

    def isGroupListCondensingPathHierarchies(self) -> "bool":
        r"""

        isGroupListCondensingPathHierarchies(self)

            Returns true if the group list will condense the hierarchy of groups
            defined by a string attribute representing a path.


        """
        return _hou.SceneViewer_isGroupListCondensingPathHierarchies(self)

    def setGroupListCondensingPathHierarchies(self, on: "bool") -> "void":
        r"""

        setGroupListCondensingPathHierarchies(self, on)

            Turns on or off the condensing of the hierarchy in the group list.
            This applies to components grouped by string attributes representing
            a path. Turning this option on can fit more information into the
            list, but can make it harder to distinguish levels in the hierarchy.


        """
        return _hou.SceneViewer_setGroupListCondensingPathHierarchies(self, on)

    def groupListSize(self) -> "HOM_Vector2 *":
        r"""

        groupListSize(self)

            Returns the width and height in inches of the group list gadget.


        """
        return _hou.SceneViewer_groupListSize(self)

    def setGroupListSize(self, width: "double", height: "double") -> "void":
        r"""

        setGroupListSize(self, width, height)

            Sets the size in inches of the group list gadget.


        """
        return _hou.SceneViewer_setGroupListSize(self, width, height)

    def groupListType(self) -> "HOM_EnumValue &":
        r"""

        groupListType(self)

            Returns the type of component listed in the group list gadget.


        """
        return _hou.SceneViewer_groupListType(self)

    def setGroupListType(self, group_list_type: "EnumValue") -> "void":
        r"""

        setGroupListType(self, group_list_type)

            Sets the type of component listed in the group list gadget. This can
            be set to a specific component type or to follow the current
            component selection type.


        """
        return _hou.SceneViewer_setGroupListType(self, group_list_type)

    def groupListMask(self) -> "std::string":
        r"""

        groupListMask(self)

            Returns true if the group list gadget has been turned on for this
            viewer.


        """
        return _hou.SceneViewer_groupListMask(self)

    def setGroupListMask(self, mask: "char const *") -> "void":
        r"""

        setGroupListMask(self, mask)

            Sets the mask value in the group list gadget for this viewer. This
            can be a filter applied to the component groups, or an attribute
            name (starting with an @ character), or a connectivity type.


        """
        return _hou.SceneViewer_setGroupListMask(self, mask)

    def constructionPlane(self) -> "HOM_ConstructionPlane *":
        r"""

        constructionPlane(self) -> hou.ConstructionPlane

            Return the construction plane (or grid) in the perspective viewport
            of this viewer.

            See hou.ConstructionPlane for more information.


        """
        return _hou.SceneViewer_constructionPlane(self)

    def referencePlane(self) -> "HOM_ReferencePlane *":
        r"""

        referencePlane(self) -> hou.ReferencePlane

            Return the reference plane (or grid) in the perspective viewport of
            this viewer.

            See hou.ReferencePlane for more information.


        """
        return _hou.SceneViewer_referencePlane(self)

    def flipbookSettings(self) -> "HOM_FlipbookSettings *":
        r"""

        flipbookSettings(self) -> hou.FlipbookSettings

            Access to the flipbook dialog settings, which can be queried, set,
            or copied.


        """
        return _hou.SceneViewer_flipbookSettings(self)

    def flipbook(
        self,
        viewport: "GeometryViewport" = None,
        settings: "FlipbookSettings" = None,
        open_dialog: "bool" = False,
    ) -> "void":
        r"""

        flipbook(self, viewport=None, settings=None, open_dialog=False)

            Capture a flipbook. A flipbook creates a quick preview animation by
            taking consecutive screenshots of a viewport at each frame.

            Launch a flipbook for viewport if specified or the current viewport
            if viewport is not. Optionally a hou.FlipbookSettings object can be
            passed to settings which will override the current settings. This
            override will only affect the current flipbook and not change the
            dialog settings. If open_dialog is True, the flipbook dialog is
            presented to the user, otherwise a flipbook is launched immediately.


        """
        return _hou.SceneViewer_flipbook(self, viewport, settings, open_dialog)

    def runShelfTool(self, tool_name: "char const *") -> "void":
        r"""

        runShelfTool(self, tool_name)

            Run the named shelf tool in the current viewport.


        """
        return _hou.SceneViewer_runShelfTool(self, tool_name)

    def beginStateUndo(self, label: "char const *") -> "void":
        r"""

        beginStateUndo(self, label)

            Opens an undo block to perform undoable operations with the current
            viewer state. All operations performed after the opening will appear
            as one single operation on the undo stack. Use
            hou.SceneViewer.endStateUndo to close an open block.

            beginStateUndo and endStateUndo can be used for managing an undo
            block that begins in one function but ends in another one. Only one
            undo block is supported for a sequence of undoable operations.
            Exceptions will be raised if a call to a second beginStateUndo is
            detected before the undo block is closed by endStateUndo.

            Python state example of a valid undo block:

          > def onMouseEvent(self, kwargs):
          >     ui_event = kwargs[\"ui_event\"]
          >     node = kwargs[\"node\"]
          >     if ui_event.reason() == hou.uiEventReason.Start:
          >         # left mouse button pressed
          >         self.scale = node.parent().parm(\"scale\").evalAsFloat()
          >         self.scene_viewer.beginStateUndo('scale')
          >
          >     if ui_event.reason() == hou.uiEventReason.Active:
          >         # left mouse button down while the mouse is moving
          >         self.scale *= 1.01
          >         node.parent().parm(\"scale\").set(self.scale)
          >
          >     if ui_event.reason() == hou.uiEventReason.Changed:
          >         # left mouse button released
          >         self.scene_viewer.endStateUndo()

            Example of a non-valid undo block that raises an exception:

          > def onMouseEvent(self, kwargs):
          >     ui_event = kwargs[\"ui_event\"]
          >     node = kwargs[\"node\"]
          >     if ui_event.reason() == hou.uiEventReason.Start:
          >         # left mouse button pressed
          >         self.tx = node.parent().parm(\"tx\").evalAsFloat()
          >         self.scale = node.parent().parm(\"scale\").evalAsFloat()
          >         self.scene_viewer.beginStateUndo('scale')
          >
          >     if ui_event.reason() == hou.uiEventReason.Active:
          >         # left mouse button down while the mouse is moving
          >         self.scale *= 1.01
          >         node.parent().parm(\"scale\").set(self.scale)
          >
          >         self.scene_viewer.beginStateUndo('move x')
          >         self.tx += 0.2
          >         node.parent().parm(\"tx\").set(self.tx)
          >         self.scene_viewer.endStateUndo()
          >
          >     if ui_event.reason() == hou.uiEventReason.Changed:
          >         # left mouse button released
          >         self.scene_viewer.endStateUndo()

            label
                The label of the undo block used for displaying the undo
                operation in the Edit menu. An exception is raised if the label
                is empty.


        """
        return _hou.SceneViewer_beginStateUndo(self, label)

    def endStateUndo(self) -> "void":
        r"""

        endStateUndo(self)

            Closes an undo block previously opened with
            hou.SceneViewer.beginStateUndo.

            endStateUndo will raise an exception if called before
            beginStateUndo.


        """
        return _hou.SceneViewer_endStateUndo(self)

    def setPromptMessage(self, *args) -> "void":
        r"""

        setPromptMessage(self, msg, msg_type=promptMessageType.Prompt)

            Sets the viewport to display a message at the bottom of the screen.


            msg
                Text message to display.

            msg_type
                A hou.promptMessageType value representing the type of message
                to display. Defaults to hou.promptMessageType.Prompt.


        """
        return _hou.SceneViewer_setPromptMessage(self, *args)

    def clearPromptMessage(self) -> "void":
        r"""

        clearPromptMessage(self)

            Clear the prompt message previously set with
            hou.SceneViewer.setPromptMessage.


        """
        return _hou.SceneViewer_clearPromptMessage(self)

    def flashMessage(
        self,
        image: "std::string const &",
        msg: "std::string const &",
        duration: "float" = 1.0,
        viewport: "GeometryViewport" = None,
    ) -> "void":
        return _hou.SceneViewer_flashMessage(self, image, msg, duration, viewport)

    def showHandle(self, name: "std::string const &", value: "bool") -> "void":
        r"""

        showHandle(self, name, value)

            Shows or hides a display handle linked to the current tool state.
            This API is typically used with Python states and can be called from
            any python state callbacks -- with one small caveat. Avoid calling
            showHandle from the python state constructor, doing so will lead to
            a runtime error.

            See also hou.Handle.show.


            name
                The name of the handle as specified with
                hou.ViewerStateTemplate.bindHandle

            value
                Bool value, True to show the handle, False to hide it.


        """
        return _hou.SceneViewer_showHandle(self, name, value)

    def openVisualizerEditor(self, vis: "ViewportVisualizer") -> "void":
        r"""

        openVisualizerEditor(self, visualizer)

            If the provided ViewportVisualizer exists, open the interactive
            visualizer editor dialog for that visualizer.


        """
        return _hou.SceneViewer_openVisualizerEditor(self, vis)

    def openOptionDialog(self, path: "char const *", label: "char const *") -> "void":
        r"""

        openOptionDialog(self, path, label)

            Opens Display Options dialog and highlight the specified label.


            path
                A colon-separated string that specifies the tab and group(s) the
                label belongs to. E.g, Geometry:Volume Quality.

            label
                The label to be highlighted.


        """
        return _hou.SceneViewer_openOptionDialog(self, path, label)

    def triggerStateSelector(self, *args, **kwargs) -> "void":
        r"""

        triggerStateSelector(self, action, name=None)

            Triggers an action on a selector of the current state. The state
            must be a Python state type or an exception is thrown.


            action
                The type of action to trigger as specified with
                hou.triggerSelectorAction.

            name
                The name of a selector to trigger, should match the name used
                for registering the selector, see
                hou.ViewerStateTemplate.bindGeometrySelector or
                hou.ViewerStateTemplate.bindObjectSelector for details.

                The value can be empty (default) in which case the state first
                registered selector is triggered. An exception is thrown if name
                is not a known selector.


        """
        return _hou.SceneViewer_triggerStateSelector(self, *args, **kwargs)

    def currentStateSelector(self) -> "std::string":
        r"""

        currentStateSelector(self) -> string

            Returns the name of the current state selector. If no selector is
            active, an empty string is returned. The state must be a Python
            state type or an exception is thrown.


        """
        return _hou.SceneViewer_currentStateSelector(self)

    def showCurrentSopGeometry(self, value: "bool") -> "void":
        r"""

        showCurrentSopGeometry(self, value)

            Set the geometry display flag, on or off, on the current SOP node.
            When the flag is on, the viewport displays the geometry attached to
            the node, or hides when it's off. The flag is on by default when a
            SOP state enters.

            Consider this scenario, the display flag is set to true on a
            downstream node, but an upstream node is selected. When you enter
            the node's state, normally the viewport will show the upstream
            node's geometry in wireframe, but the display node in shaded. In
            some cases, the state wants to set parameters on the selected node
            whose result is best visualized in the downstream node. In this
            case, showCurrentSopGeometry can be used to turn off the display of
            the upstream node's geometry.


            NOTE
                For SOP Python states, Houdini remembers the current node's
                geometry display flag when the state enters and will set it back
                to its original value when the state exits.

            See hou.SceneViewer.isShowingCurrentSopGeometry.


        """
        return _hou.SceneViewer_showCurrentSopGeometry(self, value)

    def isShowingCurrentSopGeometry(self) -> "bool":
        r"""

        isShowingCurrentSopGeometry(self, value) -> bool

            Returns the current node's geometry display flag. See
            hou.SceneViewer.showCurrentSopGeometry.


        """
        return _hou.SceneViewer_isShowingCurrentSopGeometry(self)

    def showOperationBar(self, on: "bool") -> "void":
        r"""

        isShowingOperationBar(self) -> bool

            Return True if the Operation Toolbar is shown at the top of the
            viewport.


        """
        return _hou.SceneViewer_showOperationBar(self, on)

    def isShowingOperationBar(self) -> "bool":
        return _hou.SceneViewer_isShowingOperationBar(self)

    def showColorCorrectionBar(self, on: "bool") -> "void":
        r"""

        showColorCorrectionBar(self,show)

            Show or hide the Color Correct Toolbar at the bottom of the
            viewport.


        """
        return _hou.SceneViewer_showColorCorrectionBar(self, on)

    def isShowingColorCorrectionBar(self) -> "bool":
        r"""

        isShowingColorCorrectionBar(self) -> bool

            Return True if the Color Correction Toolbar is shown at the bottom
            of the viewport.


        """
        return _hou.SceneViewer_isShowingColorCorrectionBar(self)

    def showMemoryBar(self, on: "bool") -> "void":
        r"""

        showMemoryBar(self,show)

            Show or hide the Memory Toolbar at the bottom of the viewport.


        """
        return _hou.SceneViewer_showMemoryBar(self, on)

    def isShowingMemoryBar(self) -> "bool":
        r"""

        isShowingMemoryBar(self) -> bool

            Return True if the Memory Toolbar is shown at the bottom of the
            viewport.


        """
        return _hou.SceneViewer_isShowingMemoryBar(self)

    def showDisplayOptionsBar(self, on: "bool") -> "void":
        r"""

        showDisplayOptionsBar(self,show)

            Show or hide the Display Options Toolbar to the right side of the
            viewport.


        """
        return _hou.SceneViewer_showDisplayOptionsBar(self, on)

    def isShowingDisplayOptionsBar(self) -> "bool":
        r"""

        isShowingDisplayOptionsBar(self) -> bool

            Return True if the Display Options Toolbar is shown to the right
            side of the viewport.


        """
        return _hou.SceneViewer_isShowingDisplayOptionsBar(self)

    def showSelectionBar(self, on: "bool") -> "void":
        r"""

        showSelectionBar(self,show)

            Show or hide the Selection Toolbar to the left side of the viewport.


        """
        return _hou.SceneViewer_showSelectionBar(self, on)

    def isShowingSelectionBar(self) -> "bool":
        r"""

        isShowingSelectionBar(self) -> bool

            Return True if the Selection Toolbar is shown to the left side of
            the viewport.


        """
        return _hou.SceneViewer_isShowingSelectionBar(self)

    def setIncludeColorCorrectionBar(self, on: "bool") -> "void":
        r"""

        setIncludeColorCorrectionBar(self,on)

            Include the optional Color Correction Toolbar at the bottom of the
            viewport.


        """
        return _hou.SceneViewer_setIncludeColorCorrectionBar(self, on)

    def includeColorCorrectionBar(self) -> "bool":
        r"""

        includeColorCorrectionBar(self) -> bool

            Return True if optional Color Correction Toolbar is included at the
            bottom of the viewport.


        """
        return _hou.SceneViewer_includeColorCorrectionBar(self)

    def setIncludeMemoryBar(self, on: "bool") -> "void":
        r"""

        setIncludeMemoryBar(self,on)

            Include the optional Memory Toolbar at the bottom of the viewport.


        """
        return _hou.SceneViewer_setIncludeMemoryBar(self, on)

    def includeMemoryBar(self) -> "bool":
        r"""

        includeMemoryBar(self) -> bool

            Return True if optional Memory Toolbar is included at the bottom of
            the viewport.


        """
        return _hou.SceneViewer_includeMemoryBar(self)

    def setGeometryVisibility(self, sop: "SopNode", on: "bool") -> "void":
        r"""

        setGeometryVisibility(self, sop_node, on)

            Control a viewport visibility override for a given geometry node.
            This can be used by a Python State to temporary hide the viewport
            geometry when a state draws an alternate visualization using
            drawables. The viewport geometry visibility doesn't persist and is
            reverted to True when switching the display flag or reselecting
            nodes. Raises hou.InvalidInput if the geometry isn't in the current
            viewport.


        """
        return _hou.SceneViewer_setGeometryVisibility(self, sop, on)

    def geometryVisibility(self, sop: "SopNode") -> "bool":
        r"""

        geometryVisibility(self, sop_node)

            Return False if setGeometryVisibility was called to hide the
            geometry or True otherwise. Raises hou.InvalidInput if the geometry
            isn't in the current viewport.


        """
        return _hou.SceneViewer_geometryVisibility(self, sop)

    def usingOCIO(self) -> "bool":
        r"""

        usingOCIO(self) -> bool

            Query if OpenColorIO is being used for color correction in the
            viewer.


        """
        return _hou.SceneViewer_usingOCIO(self)

    def setUsingOCIO(self, enable: "bool") -> "void":
        r"""

        setUsingOCIO(self, enable)

            Enable or disable OpenColorIO for color correction in the viewer.


        """
        return _hou.SceneViewer_setUsingOCIO(self, enable)

    def setOCIODisplayView(
        self, display: "char const *" = None, view: "char const *" = None
    ) -> "void":
        r"""

        setOCIODisplayView(self, display=\"\", view=\"\")

            Set the OpenColorIO display name, view name, or both. The display
            and view together define the output colorspace for the viewer, and
            any number of color transforms (Looks) to be performed on the linear
            viewport image.


        """
        return _hou.SceneViewer_setOCIODisplayView(self, display, view)

    def getOCIODisplay(self) -> "std::string":
        r"""

        getOCIODisplay(self) -> str

            Return the current OpenColorIO display used for color correction.


        """
        return _hou.SceneViewer_getOCIODisplay(self)

    def getOCIOView(self) -> "std::string":
        r"""

        getOCIOView(self) -> str

            Return the current OpenColorIO view used for color correction.


        """
        return _hou.SceneViewer_getOCIOView(self)

    def geometry(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        geometry(self) -> tuple of int

            Returns the position and size of the viewer in the UI space. The
            tuple elements are returned in viewport coordinates, relative to the
            lower-left corner position of the main window.

             1. X position (lower left)

             2. Y position (lower left)

             3. Width dimension

             4. Height dimension


        """
        return _hou.SceneViewer_geometry(self)

    def runStateCommand(
        self, name: "std::string const &", args: "InterpreterObject" = None
    ) -> "void":
        r"""

        runStateCommand(self, name, args=None)

            Executes a command implemented by the active python state. A state
            command can be invoked by specifying a name identifier along with
            input arguments.

            An exception is thrown if the state is not a Python state type or
            the state is not running.


            name
                The command name identifier.

            args
                A python object holding the command specific arguments. Defaults
                to None.

            An implementation example of a state command.

          > import hou
          > import viewerstate.utils as su
          >
          > class State(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >         self.text_size = 5
          >         self.text_color = 'yellow'
          >
          >         # drawable for drawing a text string in the viewport
          >         self.text_drawable = hou.TextDrawable(self.scene_viewer, 'text_drawable_name',
          >             params = {'margins': (10.0,-10.0),
          >                 'origin' : hou.drawableTextOrigin.UpperLeft,
          >                 'multi_line' : True} )
          >         self.text_drawable.show(True)
          >
          >     def onCommand( self, kwargs ):
          >         # Command to update the viewport text
          >         name = kwargs['command']
          >         args = kwargs['command_args']
          >         state_parms = kwargs['state_parms']
          >
          >         if name == 'update_text':
          >             # update settings
          >             state_parms['text']['value'] = args['text'];
          >             self.text_color = args['color']
          >             self.text_size = args['size']
          >             # force a viewport redraw
          >             self.scene_viewer.curViewport().draw()
          >
          >     def onDraw( self, kwargs ):
          >         # Draw the text in the viewport upper left
          >         handle = kwargs['draw_handle']
          >         state_parms = kwargs['state_parms']
          >
          >         (x,y,width,height) = self.scene_viewer.curViewport().size()
          >         text = '<font color=\"%s\", size=%d>%s</font>' % (self.text_color,
          >             self.text_size, state_parms['text']['value'])
          >         self.text_drawable.draw( handle, params = {'text': text, 'translate': (0.0, height, 0.0)} )
          >
          >
          > def registerState():
          >     state_typename = kwargs['type'].definition().sections()['DefaultState'].contents()
          >     state_label = \"State command demo\"
          >     state_cat = hou.objNodeTypeCategory()
          >
          >     template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
          >
          >     template.bindFactory(State)
          >
          >     template.bindParameter( hou.parmTemplateType.String, name=\"text\", label=\"Text\",
          >         default_value=\"Lorem ipsum dolor sit amet.\" )
          >
          >     hou.ui.registerViewerState(template)
          >
          >
          > def unregisterState():
          >     state_typename = kwargs['type'].definition().sections()['DefaultState'].contents()
          >     try:
          >         hou.ui.unregisterViewerState(state_typename)
          >     except hou.StateNotRegistered:
          >         pass
          >     except:
          >         raise

            Here's how to invoke the command.

          > import toolutils
          >
          > args = { 'text': text, 'color': color, 'size': size }
          > toolutils.sceneViewer().runStateCommand( 'update_text', args = args )

        """
        return _hou.SceneViewer_runStateCommand(self, name, args)

    def isViewingSceneGraph(self) -> "bool":
        r"""

        isViewingSceneGraph(self) -> bool

            Returns True if the scene viewer is viewing a USD stage in LOPs.


        """
        return _hou.SceneViewer_isViewingSceneGraph(self)

    def stage(self) -> "InterpreterObject":
        r"""

        stage(self) -> Usd.Stage

            Returns the USD stage being displayed, if the scene viewer is
            viewing LOPs.


        """
        return _hou.SceneViewer_stage(self)

    def stageSerial(self) -> "int":
        r"""

        stageSerial(self) -> int

            Integer that is increased every time the Scene Graph View data is
            modified. Only count on this number to be bigger when changes occur,
            and not necessarily incremented by 1.


        """
        return _hou.SceneViewer_stageSerial(self)

    def setShowGeometry(self, show: "bool") -> "void":
        r"""

        setShowGeometry(self, show)

            Show or hide the scene geometry when viewing LOPs.


        """
        return _hou.SceneViewer_setShowGeometry(self, show)

    def showGeometry(self) -> "bool":
        r"""

        showGeometry(self) -> bool

            Query if the scene geometry is displayed when viewing LOPs.


        """
        return _hou.SceneViewer_showGeometry(self)

    def setShowCameras(self, show: "bool") -> "void":
        r"""

        setShowCameras(self, show)

            Show or hide the camera guides when viewing LOPs.


        """
        return _hou.SceneViewer_setShowCameras(self, show)

    def showCameras(self) -> "bool":
        r"""

        showCameras(self) -> bool

            Query if the camera guides are displayed when viewing LOPs.


        """
        return _hou.SceneViewer_showCameras(self)

    def setShowLights(self, show: "bool") -> "void":
        r"""

        setShowLights(self, show)

            Show or hide the light guides when viewing LOPs.


        """
        return _hou.SceneViewer_setShowLights(self, show)

    def showLights(self) -> "bool":
        r"""

        showLights(self) -> bool

            Query if the light guides are displayed when viewing LOPs.


        """
        return _hou.SceneViewer_showLights(self)

    def setShowSelection(self, show: "bool") -> "void":
        r"""

        setShowSelection(self, show)

            Show the selection highlight when viewing LOPs.


        """
        return _hou.SceneViewer_setShowSelection(self, show)

    def showSelection(self) -> "bool":
        r"""

        showSelection(self) -> bool

            Query if the selection highlight is displayed when viewing LOPs.


        """
        return _hou.SceneViewer_showSelection(self)

    def setShowRenderTime(self, show: "bool") -> "void":
        return _hou.SceneViewer_setShowRenderTime(self, show)

    def showRenderTime(self) -> "bool":
        r"""

        showRenderTime(self) -> bool

            Query if the render time and progress is shown when viewing LOPs.
            Not all renderers may provide this information.


        """
        return _hou.SceneViewer_showRenderTime(self)

    def setShowRenderStats(self, show: "bool") -> "void":
        return _hou.SceneViewer_setShowRenderStats(self, show)

    def showRenderStats(self) -> "bool":
        r"""

        showRenderStats(self, show)

            Query if the renderer time and progress are shown when viewing LOPs.


        """
        return _hou.SceneViewer_showRenderStats(self)

    def setSelectionKind(self, kind: "char const *") -> "void":
        r"""

        setSelectionKind(self, kind)

            Set the kind of primitive selection to be performed. 'kind' can be
            one of the USD primitive kinds (component, subcomponent, model,
            group, assembly, leaf primitive) or a custom kind. An exception is
            thrown if kind is not recognized. Case sensitivity is ignored. This
            will set the selection mode to primitive selection if point instance
            selection was active.


        """
        return _hou.SceneViewer_setSelectionKind(self, kind)

    def setSelectionPointInstances(self, topmost: "bool") -> "void":
        r"""

        setSelectionPointInstances(self, topmost)

            Switches to point instance selection mode. If 'topmost' is 'True',
            the topmost point instance will be selected when selecting nested
            instances. Otherwise the bottommost point instance (leaf instance)
            will be selected. If point instances are not nested, 'topmost' has
            no effect.


        """
        return _hou.SceneViewer_setSelectionPointInstances(self, topmost)

    def selectionKind(self) -> "std::string":
        r"""

        selectionKind(self) -> str

            Query the current primitive kind that would be selected if the user
            entered the select state. This will return a null string if leaf
            primitives would be selected.


        """
        return _hou.SceneViewer_selectionKind(self)

    def isSelectingPointInstances(self) -> "bool":
        r"""

        isSelectingPointInstances(self) -> bool

            Return True if the current selection state is selecting point
            instances, or False if it is selecting primitives.


        """
        return _hou.SceneViewer_isSelectingPointInstances(self)

    def isSelectingTopmostInstance(self) -> "bool":
        r"""

        isSelectingTopmostInstance(self) -> bool

            Query if the instance selection mode is selecting the topmost
            instance level (True) or the leaf instance level (False).


        """
        return _hou.SceneViewer_isSelectingTopmostInstance(self)

    def setSelectionAllowKindMismatch(self, allow: "bool") -> "void":
        r"""

        setSelectionAllowKindMismatch(self, allow)

            Allow selection operations to return primitives that do not match
            the current selectionKind. When set to False, primitives returned
            from a selection will always be of the requested kind, even if this
            means that a user selection returns no results. For example, if the
            selectionKind is assembly, and the user click on a mesh that is part
            of a component model, but that component is not inside an assembly,
            nothing will be selected. When set to True, the selectionKind is
            treated as a hint rather than a requirement. In this mode, the
            user's selection will always return something, even if that means
            violating the requested selectionKind. In the previously given
            example, the selection operation would return the group primitive
            closest to the root of the hierarchy. Or if the component is not in
            a group, the component prim would be returned. Or if the user
            clicked on a primitive that is not part of a USD model hierarchy at
            all (such as a Camera primitive), the leaf primitive would be
            returned.


        """
        return _hou.SceneViewer_setSelectionAllowKindMismatch(self, allow)

    def selectionAllowKindMismatch(self) -> "bool":
        r"""

        selectionAllowKindMismatch(self)

            Query the current state of the flag indicating whether selection
            operations can return primitives that do not match the current
            selectionKind.


        """
        return _hou.SceneViewer_selectionAllowKindMismatch(self)

    def setSelectionAllowInstanceProxies(self, allow: "bool") -> "void":
        r"""

        setSelectionAllowInstanceProxies(self, allow)

            Allow selection operations to return instance proxy primitives. If
            set to True, instance proxy primitives are selected and returned
            from a selection operation exactly like any other primitive. If
            False, then before applying the selectionKind requirement each leaf
            primitive in a selection operation is traversed upwards through the
            hierarchy until a non-instance proxy primitive is found. Then the
            selectionKind requirement is enforced starting from this instance
            root primitive.

            Many LOP operations are not allowed on instance proxy primitives
            (since opinions expressed on such primitives are ignored by the USD
            composition system). So it is often useful to prevent the user from
            selecting such unsupported primitives in the first place.


        """
        return _hou.SceneViewer_setSelectionAllowInstanceProxies(self, allow)

    def selectionAllowInstanceProxies(self) -> "bool":
        r"""

        selectionAllowInstanceProxies(self)

            Query the state of the flag indicating if selections may return
            instance proxy primitives.


        """
        return _hou.SceneViewer_selectionAllowInstanceProxies(self)

    def setSelectionAllowHiddenPrims(self, allow: "bool") -> "void":
        r"""

        setSelectionAllowHiddenPrims(self, allow)

            Allow selection operations to return hidden primitives. If set to
            True, hidden primitives can be selected and returned from a
            selection operation. If False, then before applying the
            selectionKind requirement each leaf primitive in a selection
            operation is traversed upwards through the hierarchy until a non-
            hidden primitive is found. Then the selectionKind requirement is
            enforced.

            A hidden primitive is one that has been marked with special metadata
            in the scene graph tree. Hidden primitives are not normally
            displayed in the scene graph tree, and so it is usually desirable to
            also prevent them from being directly selected in the viewer. The
            hidden flag is often used specifically to control primitive
            selection to ensure that transforms and other edits occur only at
            desirable locations in the scene graph hierarchy, acoording to the
            conventions of your pipeline.


        """
        return _hou.SceneViewer_setSelectionAllowHiddenPrims(self, allow)

    def selectionAllowHiddenPrims(self) -> "bool":
        r"""

        selectionAllowHiddenPrims(self)

            Query the state of the flag indicating if selections may return
            hidden primitives.


        """
        return _hou.SceneViewer_selectionAllowHiddenPrims(self)

    def setStageControlsPlaybar(self, controls_playbar: "bool") -> "void":
        r"""

        setStageControlsPlaybar(self, controls_playbar)

            Specify whether the metadata from the stage shown in this viewer
            should be used to set the playbar range and playback rate. Only one
            viewer may have this option enabled at a time. Turning it on for one
            viewer will turn it off for all other viewers.

            If enabled, the stage's StartTimeCode, EndTimeCode, and
            TimeCodesPerSecond values are used to set the start frame, and
            frame, and FPS options of the playbar respectively. The playbar step
            option is set to a value of TimeCodesPerSecond/FramesPerSecond from
            the stage metadata.

            The Houdini playbar more closely corresponds to the USD concept of
            timecodes than frames. This makes it much easier to author animated
            USD data.


        """
        return _hou.SceneViewer_setStageControlsPlaybar(self, controls_playbar)

    def stageControlsPlaybar(self) -> "bool":
        r"""

        stageControlsPlaybar(self) -> bool

            Return True if the metadata from the stage shown in this viewer is
            used to control the playbar range and playback rate. Otherwise
            return False.


        """
        return _hou.SceneViewer_stageControlsPlaybar(self)

    def hydraRenderers(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        hydraRenderers(self) -> tuple of str

            Query the list of renderers that are available to LOPs.


        """
        return _hou.SceneViewer_hydraRenderers(self)

    def setHydraRenderer(self, ren_name: "std::string const &") -> "void":
        r"""

        setHydraRenderer(self, ren_name)

            Set the current renderer in LOPs.


        """
        return _hou.SceneViewer_setHydraRenderer(self, ren_name)

    def currentHydraRenderer(self) -> "std::string":
        r"""

        currentHydraRenderer(self) -> str

            Query the current renderer in LOPs.


        """
        return _hou.SceneViewer_currentHydraRenderer(self)

    def restartRenderer(self) -> "void":
        r"""

        restartRenderer(self)

            Restart the current renderer in LOPs, which causes the scene to be
            rebuilt from scratch.


        """
        return _hou.SceneViewer_restartRenderer(self)

    def showProxyPurpose(
        self, enable: "bool", renderer: "char const *" = None
    ) -> "void":
        r"""

        showProxyPurpose(self, show_proxy, renderer = None)

            Show (True) or hide prims tagged with the Proxy purpose in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_showProxyPurpose(self, enable, renderer)

    def showGuidePurpose(
        self, enable: "bool", renderer: "char const *" = None
    ) -> "void":
        r"""

        showGuidePurpose(self, show_guide, renderer = None)

            Show (True) or hide prims tagged with the Guide purpose in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_showGuidePurpose(self, enable, renderer)

    def showRenderPurpose(
        self, enable: "bool", renderer: "char const *" = None
    ) -> "void":
        r"""

        showRenderPurpose(self, show_render, renderer = None)

            Show (True) or hide prims tagged with the Render purpose in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_showRenderPurpose(self, enable, renderer)

    def useViewportOverrides(
        self, enable: "bool", renderer: "char const *" = None
    ) -> "void":
        r"""

        useViewportOverrides(self, use_overrides, renderer = None)

            Control whether the viewer should apply overrides (such as draw mode
            and visibility) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_useViewportOverrides(self, enable, renderer)

    def useViewportLoadMasks(
        self, enable: "bool", renderer: "char const *" = None
    ) -> "void":
        r"""

        useViewportLoadMasks(self, use_loadmasks, renderer = None)

            Control whether the viewer should apply load masks (such as payload
            loading) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_useViewportLoadMasks(self, enable, renderer)

    def usePostLayers(self, enable: "bool", renderer: "char const *" = None) -> "void":
        r"""

        usePostLayers(self, use_postlayers, renderer = None)

            Control whether the viewer should apply post-layers from the LOP
            Network.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_usePostLayers(self, enable, renderer)

    def showingProxyPurpose(self, renderer: "char const *" = None) -> "bool":
        r"""

        showingProxyPurpose(self, renderer = None) -> bool

            Return True if prims with the Proxy purpose are being shown in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_showingProxyPurpose(self, renderer)

    def showingGuidePurpose(self, renderer: "char const *" = None) -> "bool":
        r"""

        showingGuidePurpose(self, renderer = None) -> bool

            Return True if prims with the Guide purpose are being shown in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_showingGuidePurpose(self, renderer)

    def showingRenderPurpose(self, renderer: "char const *" = None) -> "bool":
        r"""

        showingRenderPurpose(self, renderer = None) -> bool

            Return True if prims with the Render purpose are being shown in
            LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_showingRenderPurpose(self, renderer)

    def usingViewportOverrides(self, renderer: "char const *" = None) -> "bool":
        r"""

        usingViewportOverrides(self, renderer = None) -> bool

            Return True if the viewer is applying overrides (such as draw mode
            and visibility) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_usingViewportOverrides(self, renderer)

    def usingViewportLoadMasks(self, renderer: "char const *" = None) -> "bool":
        r"""

        usingViewportLoadMasks(self, renderer = None) -> bool

            Return True if the viewer is applying load masks (such as payload
            loading) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_usingViewportLoadMasks(self, renderer)

    def usingPostLayers(self, renderer: "char const *" = None) -> "bool":
        r"""

        usingPostLayers(self, renderer = None) -> bool

            Return True if the viewer is applying post-layers set on the LOP
            Network.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
        return _hou.SceneViewer_usingPostLayers(self, renderer)

    def addEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addEventCallback(self, callback)

            Register a Python callback to be called whenever a viewer event
            occurs.


            callback
                Any callable Python object that expects keyworded arguments
                specific to an event type. One

            callback can listen to all viewer events.

            The kwargs contains the following:

          * event_type: The viewer event.

          * desktop: The desktop object holding the scene viewer.

          * viewer: The scene viewer object listening to this event.

          > def onViewerCB(**kwargs):
          >         event_type=kwargs['event_type']
          >         desktop=kwargs['desktop']
          >         viewer=kwargs['viewer']
          >
          >         print( \"event type=\",event_type )
          >         print( \"desktop=\",desktop )
          >         print( \"viewer=\",viewer )
          >
          > curSceneViewer = [item for item in hou.ui.curDesktop().currentPaneTabs() if item.type() == hou.paneTabType.SceneViewer][0]
          > curSceneViewer.addEventCallback(onViewerCB)

        """
        return _hou.SceneViewer_addEventCallback(self, callback)

    def removeEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeEventCallback(self,callback)

            Remove a specific Python callback that have been registered with
            hou.sceneViewerEvent.addEventCallback.


        """
        return _hou.SceneViewer_removeEventCallback(self, callback)

    def clearEventCallbacks(self) -> "void":
        r"""

        clearEventCallbacks(self)

            Remove all Python callbacks that have been registered with
            hou.sceneViewerEvent.addEventCallback.


        """
        return _hou.SceneViewer_clearEventCallbacks(self)

    def eventCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        eventCallbacks(self) -> tuple of callbacks

            Return a tuple of all the Python callbacks that have been registered
            with hou.sceneViewerEvent.addEventCallback.


        """
        return _hou.SceneViewer_eventCallbacks(self)

    def qtWindow(self) -> "InterpreterObject":
        r"""

        qtWindow(self) -> QtWidgets.QWidget

            Create and return a new Qt Window for the scene viewer.


            The returned window is parented to the main Qt window and can be
            used for parenting a Qt widget like a dialog or a window.


        """
        return _hou.SceneViewer_qtWindow(self)

    def _hudInfo(self, *args, **kwargs) -> "void":
        return _hou.SceneViewer__hudInfo(self, *args, **kwargs)


# Register SceneViewer in _hou:
_hou.SceneViewer_swigregister(SceneViewer)


class ScriptEvalContext(object):
    r"""

    hou.ScriptEvalContext

    Use this to temporarily change the scripting evaluation context within a
    Python code block.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, node_or_parm)

            Constructs a new ScriptEvalContext context manager. When used inside
            a with code block, node and parameter evaluations will use the
            argument to resolve relative paths and for adding data dependencies.
            The code block will also have its hou.pwd() modified accordingly.

            When constructed with a node, it behaves the same as calling
            hou.setPwd() and then restoring it to the old node when the code
            block ends. For example,

          > with hou.scriptEvalContext(some_node):
          >     print hou.pwd() # prints path for some_node

            is equivalent to,

          > old_node = hou.pwd()
          > hou.setPwd(some_node)
          > print hou.pwd() # prints path for some_node
          > hou.setPwd(old_node)

            When constructed with a parameter, relative node and parameter paths
            inside the code block will be resolved using the parameter's owner
            node. Data dependencies will be added from the referenced parameter
            or node to this parameter. This changes what hou.evaluatingParm will
            return. Here's an example:

          > with hou.scriptEvalContext(some_parameter):
          >     # prints path for some_parameter's owner node
          >     print hou.pwd()
          >     # prints path for some_parameter
          >     print hou.evaluatingParm()
          >     # adds data dependency from the sibling test to some_parameter
          >     x = ch(\"test\")

        """
        _hou.ScriptEvalContext_swiginit(self, _hou.new_ScriptEvalContext(*args))

    __swig_destroy__ = _hou.delete_ScriptEvalContext

    def __repr__(self) -> "std::string":
        return _hou.ScriptEvalContext___repr__(self)

    def node(self) -> "HOM_Node *":
        r"""

        node(self)

            Return the hou.Node for this context.


        """
        return _hou.ScriptEvalContext_node(self)

    def parm(self) -> "HOM_Parm *":
        r"""

        parm(self)

            Return the hou.Parm for this context. Returns None if this context
            was created from a hou.Node.

            RELATED

              * hou.evaluatingParm


        """
        return _hou.ScriptEvalContext_parm(self)

    def __enter__(self) -> "HOM_ScriptEvalContext *":
        return _hou.ScriptEvalContext___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.ScriptEvalContext___exit__(self, type, value, traceback)


# Register ScriptEvalContext in _hou:
_hou.ScriptEvalContext_swigregister(ScriptEvalContext)


class Selection(object):
    r"""

    hou.Selection

    A class that represents a geometry component selection.

    Component selections are not tied to any specific hou.Geometry.
    Therefore most method on this class must be passed a Geometry object to
    look up information about individual components. This explicit
    separation allows the selection class to be used as a utility class for
    processing geometry topology (growing the set of components, shrinking
    it, finding the boundary, etc.). This separation also avoids any
    expectations that changing the contents of a selection object might be
    expected to update the selection visible on some geometry in the
    viewport. Setting the visible viewport selection must always be an
    explicit operation on a hou.SopNode in order for Houdini to be able to
    track changes properly.

    If a selection object is returned from a call to hou.Geometry.selection,
    hou.GeometrySelection.selections, or a hou.SopNode.selection, the
    selection cannot be modified. A copy of the selection must be made first
    with the freeze() method. This new selection can be modified, and passed
    back into a hou.SopNode.setSelection if desired. Because each SOP has a
    selection for each component type, when you set a new selection it will
    replace the existing selection of that component type. Note that this
    may not result in the visible selection in the viewport changing if the
    viewport is not currently configured to select that component type. The
    viewport selection type can be controlled with the hou.SceneViewer
    class. A selection created by calling any of the hou.Selection()
    initializer methods are created in a modifiable state, so a call to
    freeze() is not required.

    A selection returned from a hou.Geometry or a hou.SopNode is a reference
    to the source selection, and so will change if the selection on the
    source geometry is changed. This seems like a departure from the
    separation of selection objects from any particular geometry, however it
    matches the behavior of the hou.Geometry class returned from a SOP node.
    This is because the underlying selection data is shared with the SOP
    rather than copied. The freeze() method can be used to force a copy of
    the selection data that is disconnected from any particular SOP (as well
    as allowing the selection contents to be modified).


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, edges)

            Creates a new edge component selection from the passed in sequence
            of hou.Edge objects.


        """
        _hou.Selection_swiginit(self, _hou.new_Selection(*args))

    __swig_destroy__ = _hou.delete_Selection

    def __repr__(self) -> "std::string":
        return _hou.Selection___repr__(self)

    def freeze(self) -> "HOM_Selection *":
        r"""

        freeze(self) -> hou.Selection

            Returns a copy of the Selection object. This copy can be modified
            with any of the functions that alter the selection.


        """
        return _hou.Selection_freeze(self)

    def invert(self, geo: "Geometry") -> "void":
        r"""

        invert(self, geo)

            Using the supplied hou.Geometry object for reference, inverts the
            current selection. The selection will contain only those components
            that were not in the selection before this method call.


        """
        return _hou.Selection_invert(self, geo)

    def convert(
        self,
        geo: "Geometry",
        selection_type: "EnumValue",
        select_only_whole: "bool" = False,
    ) -> "void":
        r"""

        convert(self, geo, selection_type, select_only_whole=False)

            Using the supplied hou.Geometry object for reference, converts the
            current selection to the new hou.geometryType. If select_only_whole
            is True, select only the edges or primitives that have all their
            points selected.


        """
        return _hou.Selection_convert(self, geo, selection_type, select_only_whole)

    def boundary(self, geo: "Geometry", uv_connectivity: "bool" = False) -> "void":
        r"""

        boundary(self, geo, uv_connectivity = False)

            Using the supplied hou.Geometry object for reference, changes the
            selection to contain those components on the boundary of the current
            selection. The uv_connectivity parameter controls whether to use
            topology or uv attribute values to determine whether components are
            connected.


        """
        return _hou.Selection_boundary(self, geo, uv_connectivity)

    def grow(self, geo: "Geometry", uv_connectivity: "bool" = False) -> "void":
        r"""

        grow(self, geo, uv_connectivity = False)

            Using the supplied hou.Geometry object for reference, adds to the
            selection any components connected to the current selection. The
            uv_connectivity parameter controls whether to use topology or uv
            attribute values to determine whether components are connected.


        """
        return _hou.Selection_grow(self, geo, uv_connectivity)

    def shrink(self, geo: "Geometry", uv_connectivity: "bool" = False) -> "void":
        r"""

        shrink(self, geo, uv_connectivity = False)

            Using the supplied hou.Geometry object for reference, removes from
            the selection any components on the boundary of the current
            selection. The uv_connectivity parameter controls whether to use
            topology or uv attribute values to determine whether components are
            connected.


        """
        return _hou.Selection_shrink(self, geo, uv_connectivity)

    def combine(
        self, geo: "Geometry", selection: "Selection", modifier: "EnumValue"
    ) -> "void":
        r"""

        combine(self, geo, selection, modifier)

            Using the supplied hou.Geometry object for reference, combines this
            selection with another.


            geo
                A hou.Geometry object that is used when doing any selection
                conversions.

            selection
                A hou.Selection object that will be combined with the current
                selection. If this selection does not have the same component
                type as the current selection, an implicit conversion to the
                current component type is performed before combining the
                selections.

            modifier
                A hou.pickModifier value that controls how the selections will
                be combined. This lets you perform a union, intersection, or
                other operation on a pairs of selections.


        """
        return _hou.Selection_combine(self, geo, selection, modifier)

    def clear(self) -> "void":
        r"""

        clear(self)

            Removes all components from the current selection.


        """
        return _hou.Selection_clear(self)

    def selectionType(self) -> "HOM_EnumValue &":
        r"""

        selectionType(self)

            Returns a hou.geometryType value indicating the type of component
            referenced by this selection.


        """
        return _hou.Selection_selectionType(self)

    def numSelected(self) -> "int":
        r"""

        numSelected(self)

            Returns the number of components in the selection.


        """
        return _hou.Selection_numSelected(self)

    def prims(
        self, geo: "Geometry"
    ) -> "std::vector< HOM_ElemPtr< HOM_Prim >,std::allocator< HOM_ElemPtr< HOM_Prim > > >":
        r"""

        prims(self, geo) -> tuple of hou.Prim

            Returns a tuple of all primitives in the selection. If the selection
            does not contain primitives, an implicit conversion to primitives is
            performed to generate the return value.


        """
        return _hou.Selection_prims(self, geo)

    def points(
        self, geo: "Geometry"
    ) -> "std::vector< HOM_ElemPtr< HOM_Point >,std::allocator< HOM_ElemPtr< HOM_Point > > >":
        r"""

        points(self, geo) -> tuple of hou.Point

            Returns a tuple of all points in the selection. If the selection
            does not contain points, an implicit conversion to points is
            performed to generate the return value.


        """
        return _hou.Selection_points(self, geo)

    def vertices(
        self, geo: "Geometry"
    ) -> "std::vector< HOM_ElemPtr< HOM_Vertex >,std::allocator< HOM_ElemPtr< HOM_Vertex > > >":
        r"""

        vertices(self, geo) -> tuple of hou.Vertex

            Returns a tuple of all vertices in the selection. If the selection
            does not contain vertices, an implicit conversion to vertices is
            performed to generate the return value.


        """
        return _hou.Selection_vertices(self, geo)

    def edges(
        self, geo: "Geometry"
    ) -> "std::vector< HOM_ElemPtr< HOM_Edge >,std::allocator< HOM_ElemPtr< HOM_Edge > > >":
        r"""

        edges(self, geo) -> tuple of hou.Edge

            Returns a tuple of all edges in the selection. If the selection does
            not contain edges, an implicit conversion to edges is performed to
            generate the return value.


        """
        return _hou.Selection_edges(self, geo)

    def selectionString(
        self,
        geo: "Geometry",
        force_numeric: "bool" = False,
        collapse_where_possible: "bool" = True,
        asterisk_to_select_all: "bool" = False,
    ) -> "std::string":
        r"""

        selectionString(self, geo, force_numeric = False,
        collapse_where_possible = True, asterisk_to_select_all = False) -> str

            Returns a string that specifies the selected components. The format
            of this string is appropriate for use in SOP Group parameter fields.


            geo
                A hou.Geometry object that is used when generating the selection
                string (such as determining if all components are selected).

            force_numeric
                Set this to True to force the generated string to contain only
                numeric ranges, even if the selection was constructed with group
                or attribute based selection.

            collapse_where_possible
                Set this to True to cause numeric ranges to be collapsed as much
                as possible, regardless of the selection order. So for example
                if the user selected primitive 3, then 2, then 1, the generated
                selection string would either be '3 2 1' or '1-3' depending on
                this parameter.

            asterisk_to_select_all
                When this parameter is set to False, if a selection contains all
                components in the supplied geometry, the resulting value is an
                empty string. This is appropriate when using the resulting
                string in a SOP node Group parameter. If this parameter is set
                to True, a full selection will return a value of '*' instead.


        """
        return _hou.Selection_selectionString(
            self, geo, force_numeric, collapse_where_possible, asterisk_to_select_all
        )


# Register Selection in _hou:
_hou.Selection_swigregister(Selection)


class Selector(object):
    r"""

    hou.Selector

    Describes how Houdini should prompt the user to choose geometry in the
    viewport when creating a new SOP node instance.

    Use hou.SopNodeType.addSelector to create a selector and add it to a SOP
    node type. When the user creates a new instance of a node type in the
    viewer, Houdini will invoke all of its selectors sequentially. Each
    selector prompts the user to select geometry. When all selectors have
    been invoked, Houdini creates the new node and each selector connects
    its input nodes and fills in any group parameters on the node to match
    what was selected.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Selector

    def __repr__(self) -> "std::string":
        return _hou.Selector___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Return the name of this selector. The name is unique within the node
            type it is attached to.


        """
        return _hou.Selector_name(self)

    def nodeType(self) -> "HOM_NodeType *":
        r"""

        nodeType(self) -> hou.NodeType

            Return the node type that this selector is attached to.


        """
        return _hou.Selector_nodeType(self)

    def selectorType(self) -> "std::string":
        r"""

        selectorType(self) -> str

            Return the name of the type of selector to use. Different selectors
            have different behaviors. For example prims will select only
            primitives and is used, for example, by the cookie SOP. points will
            select only points, and is used by SOPs like the point SOP.
            everything will select any geometry, and is used for SOPs like xform
            and blast.

            See hou.SopNodeType.selectors for example code that returns all the
            available selector types.


        """
        return _hou.Selector_selectorType(self)

    def geometryTypes(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        geometryTypes(self) -> tuple of hou.geometryType enum values

            Return a tuple of hou.geometryType enumeration values. This tuple
            describes which geometry entities (e.g. points, primitives, edges,
            etc.) the selector allows. Note that this list is a property of the
            selector type and you cannot specify it when creating a new
            selector. Instead, you must choose a selector type with the desired
            geometry types.

            See hou.SopNodeType.selectors for a function that returns a list of
            all the selector types. The following function will return the
            geometry types for a particular selector type.

          > def geometryTypesForSelectorType(selector_type):
          >     '''Given a selector type name, return the tuple of geometry types it
          >        will select.'''
          >     # First find a node type that uses this selector.
          >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
          >         # Skip manager nodes, like shopnets, ropnets, etc.
          >         if not isinstance(node_type, hou.SopNodeType):
          >             continue
          >
          >         for selector in node_type.selectors():
          >             if selector_type == selector.selectorType():
          >                 return selector.geometryTypes()
          >
          >     # The selector type name is invalid.
          >     raise hou.OperationFailed(\"Invalid selector type\")

        """
        return _hou.Selector_geometryTypes(self)

    def groupTypeParmValues(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        groupTypeParmValues(self) -> tuple of int

            Return a tuple of indices mapping geometry types to indices on the
            geometry type parameter menu.

            Whether or not a selector is ordered is a property of the selector
            type, and you cannot specify it when creating a new selector.
            Instead, you must choose the appropriate selector type. For example,
            the everything selector can select primitives, primitive groups,
            points, point groups, edges, and breakpoints. It sets a group type
            menu parameter to match the type of selection, and this menu must
            have the entries Guess from Group, Breakpoints, Edges, Points, and
            Primitives. For an everything selector, this method returns (4, 4,
            3, 3, 2, 1), mapping the geometry element types to 0-based entries
            in the menu. For example, if the user selects edges, the selector
            will look up the fifth element (2) and set the menu parameter to the
            item at index 2 (Edges).

            The length of the tuple of ints is the same as
            len(self.geometryTypes). If this selector is not intended to work
            with a menu parameter, each value in the tuple will be -1.

            See also hou.Selector.geometryTypes.


        """
        return _hou.Selector_groupTypeParmValues(self)

    def ordered(self) -> "bool":
        r"""

        ordered(self) -> bool

            Return whether or not this selector preserves the order in which the
            user selected the geometry.

            For example, the selector is for points and the user clicks on
            points 1, 0, and 2, in that order, an ordered selector will set the
            SOP's group parameter to \"1 0 2\", while an unordered selector will
            set it to \"0-2\". For SOPs where the order of the group selector
            matters, use ordered selectors.

            Whether or not a selector is ordered is a property of the selector
            type, and you cannot specify it when creating a new selector.
            Instead, you must choose the appropriate selector type. For example,
            prims is an unordered selector type, but ordered_prims is ordered.
            See hou.Selector.geometryTypes for a function that can be adapted to
            determine if a selector is ordered, and see
            hou.SopNodeType.selectors for a function to list all the selector
            types.


        """
        return _hou.Selector_ordered(self)

    def prompt(self) -> "std::string":
        r"""

        prompt(self) -> str

            A string to display at the bottom of the viewer to instruct the user
            what to select.


        """
        return _hou.Selector_prompt(self)

    def primitiveTypes(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        primitiveTypes(self) -> tuple of hou.primType enum values

            Return a sequence of hou.primType enumeration values to specify what
            primitive types are allowed.

            Note that if you pass an empty sequence for the primitive_types
            parameter in hou.SopNodeType.addSelector and then call this method
            on the newly-created selector, this method will return a tuple of
            all primitive types.


        """
        return _hou.Selector_primitiveTypes(self)

    def groupParmName(self) -> "std::string":
        r"""

        groupParmName(self) -> str

            Return the name of the SOP node parameter containing the group
            field. The selector will set this parameter to the string
            representing the points, primitives, edges, etc. chosen by the user
            in the viewer. It is typically named group.


        """
        return _hou.Selector_groupParmName(self)

    def groupTypeParmName(self) -> "std::string":
        r"""

        groupTypeParmName(self) -> str

            Return the name of the SOP node parameter containing the menu of
            geometry types. If the selector can select multiple geometry types
            (e.g. points or primitives), it will set this parameter to match the
            type of geometry the user chose. The transform SOP, for example, has
            a Group Type parameter that tells it how to interpret the string in
            the Group parameter. For such selectors, the parameter is typically
            named grouptype. For selectors that do not allow multiple geometry
            types, this parameter is usually .


        """
        return _hou.Selector_groupTypeParmName(self)

    def inputIndex(self) -> "int":
        r"""

        inputIndex(self) -> int

            Return the index of the input connector on the SOP node where the
            selector should wire input SOPs. A cookie SOP, for example, has two
            input connectors and one selector for each input connector.


        """
        return _hou.Selector_inputIndex(self)

    def inputRequired(self) -> "bool":
        r"""

        inputRequired(self) -> bool

            Return whether or not this input is required or optional. If the
            user does not select any geometry and the input is not required, the
            selector will not connect anything to its input connector.


        """
        return _hou.Selector_inputRequired(self)

    def allowDragging(self) -> "bool":
        r"""

        allowDragging(self) -> bool

            Return whether the user is allowed to select the geometry and begin
            manipulating the handles with a single mouse click. A transform SOP,
            for example, lets you select the geometry and drag it right away.
            Dragging the geometry forces the selector to finish immediately, the
            selector connects the input and sets the group parameter, and
            subsequent mouse movements are passed to the handle which translates
            the geometry by changing parameter values.


        """
        return _hou.Selector_allowDragging(self)

    def emptyStringSelectsAll(self) -> "bool":
        r"""

        emptyStringSelectsAll(self) -> bool

            Return whether or not use an empty string in the group parameter if
            the user selects all the geometry. If False, Houdini will place an
            asterisk (*) in the group parameter when the user selects all the
            geometry. Most SOPs use an empty string.


        """
        return _hou.Selector_emptyStringSelectsAll(self)

    def extraInfo(self) -> "std::string":
        r"""

        extraInfo(self) -> str

            Returns an optional extra info string that contains additional
            settings.


        """
        return _hou.Selector_extraInfo(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this selector from its node type.

            See also hou.SopNodeType.addSelector.


        """
        return _hou.Selector_destroy(self)


# Register Selector in _hou:
_hou.Selector_swigregister(Selector)


class SeparatorParmTemplate(ParmTemplate):
    r"""

    hou.SeparatorParmTemplate

    Template for a separator parameter. Separators are just lines between
    parameters and do not store any parameter values.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, is_hidden=False, tags={})

            Creates a new SeparatorParmTemplate instance.


            name
                See hou.ParmTemplate.name for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            tags
                See hou.ParmTemplate.tags for more information.


        """
        _hou.SeparatorParmTemplate_swiginit(
            self, _hou.new_SeparatorParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_SeparatorParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.SeparatorParmTemplate___repr__(self)


# Register SeparatorParmTemplate in _hou:
_hou.SeparatorParmTemplate_swigregister(SeparatorParmTemplate)


class Shelf(ShelfElement):
    r"""

    hou.Shelf

    Represents a tab of shelf tools.

    You can't instantiate this object directly, call hou.shelves.newShelf
    instead.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Shelf

    def __repr__(self) -> "std::string":
        return _hou.Shelf___repr__(self)

    def tools(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Tool >,std::allocator< HOM_ElemPtr< HOM_Tool > > >":
        r"""

        tools(self) -> tuple of hou.Tool

            Returns the tools on this shelf tab.


        """
        return _hou.Shelf_tools(self)

    def setTools(
        self, tools: "std::vector< HOM_Tool *,std::allocator< HOM_Tool * > > const &"
    ) -> "void":
        r"""

        setTools(self, tools)

            Replaces the current contents of the shelf with the given list of
            hou.Tool objects.


        """
        return _hou.Shelf_setTools(self, tools)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Removes this shelf tab from Houdini and deletes it from the shelf
            defintion file.


        """
        return _hou.Shelf_destroy(self)


# Register Shelf in _hou:
_hou.Shelf_swigregister(Shelf)


class ShelfDock(object):
    r"""

    hou.ShelfDock

    Represents the shelf area at the top of the screen, within which shelf
    sets and shelf tabs exist.

    The shelf docking area on any given desktop has space for any number of
    shelf sets, each of which may contain shelf tabs.

    RELATED

      * hou.Desktop


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ShelfDock

    def __repr__(self) -> "std::string":
        return _hou.ShelfDock___repr__(self)

    def shelfSets(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ShelfSet >,std::allocator< HOM_ElemPtr< HOM_ShelfSet > > >":
        r"""

        shelfSets(self) -> tuple of hou.ShelfSet

            Returns a list of the shelf sets in the current shelf dock.


        """
        return _hou.ShelfDock_shelfSets(self)

    def iconsize(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        iconsize(self) -> (int, int)

            Returns the height and width, in pixels, of the icons in the shelf
            at the current Display Tools As setting.


        """
        return _hou.ShelfDock_iconsize(self)

    def show(self, on: "bool") -> "void":
        r"""

        show(self, on)

            Show or hide the shelf dock by uncollapsing or collapsing its stow
            bar.


        """
        return _hou.ShelfDock_show(self, on)


# Register ShelfDock in _hou:
_hou.ShelfDock_swigregister(ShelfDock)


class ShelfSet(ShelfElement):
    r"""

    hou.ShelfSet

    Represents a collection of shelf tabs.

    You can't instantiate this object directly, call hou.shelves.newShelfSet
    instead.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ShelfSet

    def __repr__(self) -> "std::string":
        return _hou.ShelfSet___repr__(self)

    def shelves(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Shelf >,std::allocator< HOM_ElemPtr< HOM_Shelf > > >":
        r"""

        shelves(self) -> tuple of hou.Shelf

            Returns the shelf tabs in this shelf set.


        """
        return _hou.ShelfSet_shelves(self)

    def setShelves(
        self,
        shelves: "std::vector< HOM_Shelf *,std::allocator< HOM_Shelf * > > const &",
    ) -> "void":
        r"""

        setShelves(self, shelves)

            Replaces the current contents of the shelf with the given list of
            hou.Shelf objects.


        """
        return _hou.ShelfSet_setShelves(self, shelves)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Removes this shelf set from Houdini and deletes it from the shelf
            definition file.


        """
        return _hou.ShelfSet_destroy(self)


# Register ShelfSet in _hou:
_hou.ShelfSet_swigregister(ShelfSet)


class ShellIO(object):
    r"""

    hou.ShellIO

    A proxy object that replaces Python's stdin, stdout, and stderr streams
    within Houdini.

    This class is mostly an implementation detail of how Houdini replaces
    Python's standard streams with versions that allow Python input and
    output in Houdini windows and pane tabs.

    The methods that might be useful outside of internal SideFX scripts are
    addCloseCallback(), removeCloseCallback(), and callbacks(). These let
    you register functions that Houdini calls when the Python shell window
    or pane tab is closed (the equivalent of atexit() scripts in regular
    Python).

    The other methods should be considered internal implementation details,
    and you should not use them.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_ShellIO

    def readline(self, size: "int" = -1) -> "InterpreterObject":
        r"""

        readline(self, size=-1) -> string

            Implemented as part of the file-like object interface.


        """
        return _hou.ShellIO_readline(self, size)

    def addCloseCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addCloseCallback(callback)

            Register a Python callback to be called whenever the last Houdini
            Python Shell is closed.

            The argument is a callable object that expects no parameters.

          > def cleanup():
          >     # Here is where you would run your cleanup code when
          >     # the Python shell has closed.
          >     pass
          >
          > hou.ui.shellIO().addCloseCallback(cleanup)

            You might use this function to cleanly terminate any mechanisms that
            are dependent on the Python shell. For example, you can register a
            callback which disables an object from logging output messages to
            the shell.


        """
        return _hou.ShellIO_addCloseCallback(self, callback)

    def removeCloseCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeCloseCallback(callback)

            Remove a Python callback that was previously registered with
            hou.ShellIO.addCloseCallback. See hou.ShellIO.addCloseCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
        return _hou.ShellIO_removeCloseCallback(self, callback)

    def closeCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        closeCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.ShellIO.addCloseCallback.


        """
        return _hou.ShellIO_closeCallbacks(self)

    def CloseCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        return _hou.ShellIO_CloseCallbacks(self)

    def addExitCallback(self, callback: "InterpreterObject") -> "void":
        return _hou.ShellIO_addExitCallback(self, callback)

    def removeExitCallback(self, callback: "InterpreterObject") -> "void":
        return _hou.ShellIO_removeExitCallback(self, callback)

    def exitCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        return _hou.ShellIO_exitCallbacks(self)

    def write(self, data: "std::string const &") -> "void":
        r"""

        write(self, data)

            Implemented as part of the file-like object interface.


        """
        return _hou.ShellIO_write(self, data)

    def getAndClearWrittenData(self) -> "std::string":
        r"""

        getAndClearWrittenData(self) -> string


        """
        return _hou.ShellIO_getAndClearWrittenData(self)

    def addDataForReading(self, data: "char const *") -> "void":
        r"""

        addDataForReading(self, data)


        """
        return _hou.ShellIO_addDataForReading(self, data)

    def addEOFForReading(self) -> "void":
        r"""

        addEOFForReading(self)


        """
        return _hou.ShellIO_addEOFForReading(self)

    def interruptShellThread(self) -> "void":
        r"""

        interruptShellThread(self)


        """
        return _hou.ShellIO_interruptShellThread(self)

    def isWaitingForCommand(self) -> "bool":
        r"""

        isWaitingForCommand(self) -> bool


        """
        return _hou.ShellIO_isWaitingForCommand(self)

    def setIsWaitingForCommand(self, on: "bool") -> "void":
        r"""

        setIsWaitingForCommand(self, on)


        """
        return _hou.ShellIO_setIsWaitingForCommand(self, on)

    def isatty(self) -> "bool":
        r"""

        isatty(self) -> bool

            Implemented as part of the file-like object interface.


        """
        return _hou.ShellIO_isatty(self)

    def flush(self) -> "void":
        return _hou.ShellIO_flush(self)


# Register ShellIO in _hou:
_hou.ShellIO_swigregister(ShellIO)


class shelves(object):
    r"""

    hou.shelves

    Contains functions for working with shelf tabs and shelf tools.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_shelves

    def __repr__(self) -> "std::string":
        return _hou.shelves___repr__(self)

    def shelfSets(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_ShelfSet >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_ShelfSet > > > >":
        r"""

        shelfSets() -> dict of str to hou.ShelfSet

            Returns a dictionary mapping the internal name of every known shelf
            tab to a corresponding hou.Shelf object.


        """
        return _hou.shelves_shelfSets(self)

    def shelves(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_Shelf >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_Shelf > > > >":
        r"""

        shelves() -> dict of str to hou.Shelf

            Returns a dictionary mapping the internal name of every known shelf
            tab to a corresponding hou.Shelf object.


        """
        return _hou.shelves_shelves(self)

    def tools(
        self,
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_Tool >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_Tool > > > >":
        r"""

        tools() -> dict of str to hou.Tool

            Returns a dictionary mapping the internal name of every known tool
            to a corresponding hou.Tool object.


            NOTE
                If you only want to get a single tool by its internal name, use
                the tool function. Using shelves.tool(name) is much faster that
                constructing this dictionary and then pulling a single tool out
                of it.


        """
        return _hou.shelves_tools(self)

    def tool(self, tool_name: "char const *") -> "HOM_Tool *":
        r"""

        tool(tool_name) -> hou.Tool or None

            Gets a reference to a hou.Tool by its internal name.

          > >>> hou.shelves.tool(\"geometry_sphere\")
          > <hou.Tool 'geometry_sphere'>

        """
        return _hou.shelves_tool(self, tool_name)

    def isToolDeleted(self, tool_name: "char const *") -> "bool":
        return _hou.shelves_isToolDeleted(self, tool_name)

    def loadFile(self, file_path: "char const *") -> "void":
        r"""

        loadFile(file_path)

            Reads a shelf file and adds any shelves and tools defined in that
            file to Houdini.


        """
        return _hou.shelves_loadFile(self, file_path)

    def reloadShelfFiles(self) -> "void":
        r"""

        reloadShelfFiles()

            Reloading the shelf files found in the search path and update the
            shelf UI with any changed information.


        """
        return _hou.shelves_reloadShelfFiles(self)

    def runningTool(self) -> "HOM_Tool *":
        r"""

        runningTool() -> hou.Tool or None


        """
        return _hou.shelves_runningTool(self)

    def beginChangeBlock(self) -> "void":
        r"""

        beginChangeBlock()

            Prevents Houdini from automatically rewriting shelf information
            files until endChangeBlock is called.

            Normally, many shelf editing functions and methods cause Houdini to
            rewrite the shelf definition files with the new information. If
            you're changing a lot of shelves/tools at once, it could be quite
            slow as each individual change is written separately.

            To speed up batch changes, call beginChangeBlock() first, then
            perform the edits, then call endChangeBlock(). This delays rewriting
            the shelf files until the end when all changes are written at once.

          > # Change the icon of every tool to MISC_angry_fruit_salad.
          > # DON'T ACTUALLY DO THIS!
          >
          > # First, turn off writing changes
          > hou.shelves.beginChangeBlock()
          >
          > for shelf in hou.shelves.shelves().values():
          >     for tool in shelf.tools():
          >         tool.setIcon(\"MISC/angry_fruit_salad\")
          >
          > # Finish the change block and write all the changes to disk
          > hou.shelves.endChangeBlock()

            Each call to beginChangeBlock must have a matching call to
            endChangeBlock or Houdini will never actually write your changes to
            disk.


        """
        return _hou.shelves_beginChangeBlock(self)

    def endChangeBlock(self) -> "void":
        r"""

        endChangeBlock()

            See beginChangeBlock above.


        """
        return _hou.shelves_endChangeBlock(self)

    def newShelfSet(
        self,
        file_path: "char const *" = None,
        name: "char const *" = None,
        label: "char const *" = None,
    ) -> "HOM_ShelfSet *":
        r"""

        newShelfSet(file_path=None, name=None, label=None) -> hou.ShelfSet

            Returns a new hou.ShelfSet object using the provided options. You
            must use this function to create new shelf sets, you can't
            instantiate the ShelfSet class directly.


        """
        return _hou.shelves_newShelfSet(self, file_path, name, label)

    def newShelf(
        self,
        file_path: "char const *" = None,
        name: "char const *" = None,
        label: "char const *" = None,
    ) -> "HOM_Shelf *":
        r"""

        newShelf(file_path=None, name=None, label=None) -> hou.Shelf

            Returns a new hou.Shelf object using the provided options. You must
            use this function to create new shelf tabs, you can't instantiate
            the Shelf class directly.


        """
        return _hou.shelves_newShelf(self, file_path, name, label)

    def newTool(self, *args, **kwargs) -> "HOM_Tool *":
        r"""

        newTool(file_path=None, name=None, label=None, script=None,
        language=hou.scriptLanguage.Python, icon=None, help=None, help_url=None,
        network_categories=(), viewer_categories=(), cop_viewer_categories=(),
        network_op_type=None, viewer_op_type=None, locations=()) -> hou.Tool

            Returns a new hou.Tool object using the provided options. You must
            use this function to create new shelf tabs, you can't instantiate
            the Tool class directly.


        """
        return _hou.shelves_newTool(self, *args, **kwargs)

    def _newAssetTool(
        self,
        name: "char const *" = None,
        label: "char const *" = None,
        icon: "char const *" = None,
        help: "char const *" = None,
        help_url: "char const *" = None,
    ) -> "HOM_Tool *":
        return _hou.shelves__newAssetTool(self, name, label, icon, help, help_url)

    def defaultFilePath(self) -> "std::string":
        r"""

        defaultFilePath() -> str


        """
        return _hou.shelves_defaultFilePath(self)

    def defaultToolName(
        self, nodetype_category_name: "char const *", nodetype_name: "char const *"
    ) -> "std::string":
        return _hou.shelves_defaultToolName(self, nodetype_category_name, nodetype_name)


# Register shelves in _hou:
_hou.shelves_swigregister(shelves)


class ShopNode(Node):
    r"""

    hou.ShopNode

    The base class for all SHOP nodes in Houdini. An instance of this class
    corresponds to exactly one instance of a node in Houdini.

    See hou.Node for more information.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ShopNode

    def __repr__(self) -> "std::string":
        return _hou.ShopNode___repr__(self)

    def shaderString(self, *args) -> "std::string":
        r"""

        shaderString(self, render_type=None) -> str

            Return the shader string generated by this shader for the given
            render type. This string is written to the file that is read in by
            the renderer.


            render_type
                A string representing the renderer. If this string is empty or
                is \"*\", Houdini uses the default render type for this shader.
                Possible render types include \"VMantra\" (Mantra), \"RIB\"
                (RenderMan), \"OGL\" (OpenGL), \"OGL2\" (OpenGL 2), and \"I3D\" (Image
                3D).

                You can use hou.ShopNodeType.renderMask to determine the render
                types supported by this SHOP's type. You can also use
                hou.shopNodeTypeCategory.renderers to get all the possible
                render types. Note that some SHOP types, like the properties
                SHOP or the switch SHOP, have a render mask of \"*\" to indicate
                that they will work with any shader type.

            If you pass in an unknown or unsupported render type, this method
            returns an empty string.

          > >>> for node_type_name in (\"v_plastic\", \"ri_matte\"):
          > ...     hou.node(\"/shop\").createNode(node_type_name)
          >
          > <hou.ShopNode of type v_plastic at /shop/v_plastic1>
          > <hou.ShopNode of type ri_matte at /shop/ri_matte1>
          >
          > >>> for shop in hou.node(\"/shop\").children():
          > ...     for render_type in shop.type().renderMask().split():
          > ...         print shop.name(), \"supports\", render_type
          > ...         print \"    shader_string:\", shop.shaderString(render_type)
          > ...         print
          > v_plastic1 supports VMantra
          >     shader_string: opdef:/Shop/v_plastic
          >
          > v_plastic1 supports OGL
          >     shader_string: /shop/v_plastic1
          >
          > ri_matte1 supports RIB
          >     shader_string: \"matte\"
          >
          > ri_matte1 supports OGL
          >     shader_string: /shop/ri_matte1

        """
        return _hou.ShopNode_shaderString(self, *args)

    def shaderCode(self, *args) -> "std::string":
        return _hou.ShopNode_shaderCode(self, *args)

    def shaderName(
        self, as_otl_path: "bool" = True, shader_type_name: "char const *" = None
    ) -> "std::string":
        r"""

        shaderName(self, as_otl_path=True, shader_type_name=None) -> str

            Return the name of the shader inside this SHOP. If as_otl_path is
            True, returns an opdef: path to the SHOP type. The shader_type_name
            is a string indicating the shader context type to use; some nodes
            may provide several shader types, and each may have a different
            name. This is applicable only to multi-context shader nodes, such as
            a vopnet material shop.


        """
        return _hou.ShopNode_shaderName(self, as_otl_path, shader_type_name)

    def supportedRenderers(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        supportedRenderers(self) -> tuple of str

            Returns a list of strings describing the renderers this shader
            supports.


        """
        return _hou.ShopNode_supportedRenderers(self)

    def definingVopNetNode(self) -> "HOM_Node *":
        r"""

        definingVopNetNode(self) -> hou.VopNetNode or None

            If this SHOP is defined by a VOP network, return the hou.VopNetNode
            that defines it. Otherwise, return None.


        """
        return _hou.ShopNode_definingVopNetNode(self)

    def shaderType(self) -> "HOM_EnumValue &":
        r"""

        shaderType(self) -> hou.shaderType enum value

            Returns a hou.shaderType indicating the type of this shader.

            Note that this method is a shortcut for self.type().shaderType(),
            which calls hou.ShopNodeType.shaderType.


        """
        return _hou.ShopNode_shaderType(self)

    def coshaderNodes(
        self, parm_name: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        coshaderNodes(self, parm_name) -> tuple of hou.ShopNode

            If this SHOP has a co-shader parameter given by parm_name it may
            also have an input corresponding to that parameter. This function
            will return the tuple of hou.ShopNode assigned as co-shaders to this
            SHOP node either via connected input or the operator node path
            specified in that parameter.

            If the parameter represents a single co-shader, the array will
            contain at most one element, however if the parameter refers to a
            co-shader array then the tuple may contain more than one element.


            parm_name
                Co-shader parameter name specifying the co-shader shop to
                return.


        """
        return _hou.ShopNode_coshaderNodes(self, parm_name)


# Register ShopNode in _hou:
_hou.ShopNode_swigregister(ShopNode)


class ShopNodeType(NodeType):
    r"""

    hou.ShopNodeType

    This kind of NodeType contains extra attributes specific to SHOP nodes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ShopNodeType

    def __repr__(self) -> "std::string":
        return _hou.ShopNodeType___repr__(self)

    def shaderType(self) -> "HOM_EnumValue &":
        r"""

        shaderType(self) -> [Hom:hou.shaderType] enum value

            Return the type of shader for this SHOP type. For example, this shop
            type might be a surface shader or a displacement shader. See
            hou.shaderType for the possible shader types.

            See also hou.ShopNode.shaderType.


        """
        return _hou.ShopNodeType_shaderType(self)

    def renderMask(self) -> "std::string":
        r"""

        renderMask(self) -> string

            Return a string with space-separated names of the renderers that
            this SHOP type supports. Note that some SHOP types, like the switch
            SHOP, return \"*\" to indicate that they support all renderers.

            See hou.ShopNode.shaderString for an example.


        """
        return _hou.ShopNodeType_renderMask(self)


# Register ShopNodeType in _hou:
_hou.ShopNodeType_swigregister(ShopNodeType)


class SopNode(Node):
    r"""

    hou.SopNode

    Represents a surface node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_SopNode

    def __repr__(self) -> "std::string":
        return _hou.SopNode___repr__(self)

    def geometry(self, output_index: "int" = 0) -> "HOM_Geometry *":
        r"""

        geometry(self, output_index=0) -> hou.Geometry

            Return the geometry computed by this SOP node. If the SOP has not
            already cooked, this method will cook the SOP.

            The returned Geometry object is not frozen. See hou.Geometry.freeze
            for more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node. This only applies
            to SOP nodes with multiple outputs. If there is no geometry for the
            specified output index then None is returned.


        """
        return _hou.SopNode_geometry(self, output_index)

    def geometryNoDep(self, output_index: "int" = 0) -> "HOM_Geometry *":
        r"""

        geometryNoDep(self, output_index=0) -> hou.Geometry

            Return the geometry computed by this SOP node. If the SOP has not
            already cooked, this method will cook the SOP.

            The returned Geometry object is not frozen. See hou.Geometry.freeze
            for more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node. This only applies
            to SOP nodes with multiple outputs. If there is no geometry for the
            specified output index then None is returned.

            This method doesn't add a dependency on the node when called from a
            Python SOP.


        """
        return _hou.SopNode_geometryNoDep(self, output_index)

    def geometryDep(self, output_index: "int" = 0) -> "void":
        r"""

        geometryDep(self, output_index=0)

            Add a geometry dependency without cooking the geometry.

            This method works only when called from a Python SOP.


        """
        return _hou.SopNode_geometryDep(self, output_index)

    def geometryAtFrame(
        self, frame: "double", output_index: "int" = 0
    ) -> "HOM_Geometry *":
        r"""

        geometryAtFrame(self, frame, output_index=0) -> hou.Geometry

            Return the geometry computed by this SOP node cooked at the
            specified frame. If the SOP has not already cooked, this method will
            cook the SOP.

            The returned Geometry object is frozen. See hou.Geometry.freeze for
            more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node. This only applies
            to SOP nodes with multiple outputs. If there is no geometry for the
            specified output index then None is returned.


        """
        return _hou.SopNode_geometryAtFrame(self, frame, output_index)

    def inputGeometry(self, index: "int") -> "HOM_Geometry *":
        r"""

        inputGeometry(self, index) -> hou.Geometry

            Return the geometry that is connected to the node input specified by
            index. If there is no geometry connected to the node input specified
            by index, then None is returned.

            The returned Geometry object is not frozen. See hou.Geometry.freeze
            for more information on frozen Geometry objects.


        """
        return _hou.SopNode_inputGeometry(self, index)

    def inputGeometryAtFrame(self, frame: "double", index: "int") -> "HOM_Geometry *":
        r"""

        inputGeometryAtFrame(self, frame, index) -> hou.Geometry

            Return the geometry that is connected to the node input specified by
            index and at the specified frame. If there is no geometry connected
            to the node input specified by index, then None is returned.

            The returned Geometry object is frozen. See hou.Geometry.freeze for
            more information on frozen Geometry objects.


        """
        return _hou.SopNode_inputGeometryAtFrame(self, frame, index)

    def geometryDelta(self) -> "HOM_GeometryDelta *":
        r"""

        geometryDelta(self) -> hou.GeometryDelta

            Return the geometry delta stored in this SOP node. If the SOP has no
            deltas then None is returned.

            If the SOP recooks, the geometry delta objects will update to the
            SOP's new geometry delta object. If the SOP is deleted, accessing
            the geometry delta object will raise a hou.ObjectWasDeleted
            exception.


        """
        return _hou.SopNode_geometryDelta(self)

    def hasVerb(self) -> "bool":
        r"""

        hasVerb(self) -> bool

            Returns if the node has a verb representation.


        """
        return _hou.SopNode_hasVerb(self)

    def verb(self) -> "HOM_SopVerb *":
        r"""

        verb(self) -> hou.SopVerb

            Returns the verb associated with a specific node. This allows you to
            run the nodes operation on geometry independently of the node
            itself.


        """
        return _hou.SopNode_verb(self)

    def selection(self, selection_type: "EnumValue") -> "HOM_Selection *":
        r"""

        selection(self, selection_type) -> hou.Selection

            Return the current component selection of the specified component
            type.

            This method is deprecated now that component selections are once
            again managed at the viewer level. See
            hou.SceneViewer.currentGeometrySelection.


        """
        return _hou.SopNode_selection(self, selection_type)

    def setSelection(self, selection: "Selection") -> "void":
        r"""

        setSelection(self, selection)

            Sets the current component selection to the supplied value. A
            separate selection object is stored for each component type, so
            changing the selection this way may not update the viewport if it is
            not currently set to show this type of selection.

            This method is deprecated now that component selections are once
            again managed at the viewer level. See
            hou.SceneViewer.setCurrentGeometrySelection.


        """
        return _hou.SopNode_setSelection(self, selection)

    def _sendSelectionChangedEvent(self) -> "void":
        return _hou.SopNode__sendSelectionChangedEvent(self)

    def curPoint(self) -> "HOM_Point *":
        r"""

        curPoint(self) -> Point

            Return this node's current point. You would typically call this
            method from an expression on a node that iterates over a set of
            points and re-evaluates the parameter for each point.

            This method lets you implement the Python equivalent of Hscript's
            local variables. Many of Houdini's SOPs iterate over a set of
            points, and for each point they store the current point and then
            evaluate a parameter. If the parameter contains a local variable,
            Houdini looks up the SOP's current point when evaluating that
            variable. For example, the point SOP evaluates the t parameter for
            each point, and sets that point's position according to the value of
            the parameter. If that parameter contains, say, the local variable
            $TX, it will evaluate to the x position of the current point.

            This method gives you access to the hou.Point representation of
            Houdini's current point. Using this point you could evaluate the
            position, an attribute value, or do more complex operations like
            compute the distance from the point to the origin.

            Raises hou.OperationFailed if you call this method from outside a
            SOP parameter expression, or if the SOP does not support local
            variables.

            The following lists Python equivalents for some point-related
            Hscript expression local variables. Note that you can also access
            local variables from Python using hou.lvar.

          > # $PT (Hscript expression) or lvar('PT') (Python):
          > pwd().curPoint().number()
          >
          > # $NPT (Hscript expression) or lvar('NPT') (Python):
          > len(pwd().geometry().iterPoints())
          >
          > # $TX (Hscript expression) or lvar('TX') (Python):
          > pwd().curPoint().position()[0]
          >
          > # $WEIGHT (Hscript expression) or lvar('WEIGHT`) (Python):
          > pwd().curPoint().position()[3]
          >
          > # $CR (Hscript expression) or lvar('CR') (Python):
          > pwd().curPoint().attribValue(\"Cd\")[0]
          >
          > # $ID (Hscript expression) or lvar('ID') (Python):
          > pwd().curPoint().attribValue(\"id\")
          >
          > # $LIFE (Hscript expression) or lvar('LIFE') (Python):
          > pwd().curPoint().attribValue(\"life\")
          >
          > # $VX (Hscript expression) or lvar('VX') (Python):
          > pwd().curPoint().attribValue(\"v\")[0]

        """
        return _hou.SopNode_curPoint(self)

    def setCurPoint(self, point_or_none: "Point") -> "void":
        r"""

        setCurPoint(self, point_or_none)

            Set this node's current point. You can only call this method from a
            Python-defined SOP.

            See hou.SopNode.curPoint for an explanation of a SOP's current
            point. You would use this method to set the current point from
            inside a SOP written in Python, before you evaluate a parameter
            containing a local variable referring to the current point. See
            hou.Geometry.globPoints for an example.

            Note that you can set the current point to None. In this case,
            subsequent calls to hou.SopNode.curPoint will raise
            hou.OperationFailed. After a Python SOP is done cooking, Houdini
            will automatically set the current point back to None.

            Raises hou.OperationFailed if called from outside a Python-defined
            SOP.


        """
        return _hou.SopNode_setCurPoint(self, point_or_none)

    def curPrim(self) -> "HOM_Prim *":
        r"""

        curPrim(self) -> Prim

            Return this node's current primitive. You would typically call this
            method from an expression on a node that iterates over a set of
            primitives and re-evaluates the parameter for each primitive.

            See hou.SopNode.curPoint for more information.

            The following lists Python equivalents for some primitive-related
            Hscript expression local variables. Note that you can also access
            local variables from Python using hou.lvar.

          > # $PR (Hscript expression) or lvar('PR') (Python):
          > pwd().curPrim().number()
          >
          > # $NPR (Hscript expression) or lvar('NPR') (Python):
          > len(pwd().geometry().iterPrims())
          >
          > # $NX (Hscript expression) or lvar('NX') (Python):
          > pwd().curPrim().attribValue(\"N\")[0]
          > pwd().curPrim().normal()[0]
          >
          > # $CR (Hscript expression) or lvar('CR') (Python):
          > pwd().curPrim().attribValue(\"Cd\")[0]

        """
        return _hou.SopNode_curPrim(self)

    def setCurPrim(self, prim_or_none: "Prim") -> "void":
        r"""

        setCurPrim(self, prim_or_none)

            Set this node's current primitive. You can only call this method
            from a Python-defined SOP. See hou.SopNode.setCurPoint for more
            information.


        """
        return _hou.SopNode_setCurPrim(self, prim_or_none)

    def curVertex(self) -> "HOM_Vertex *":
        r"""

        curVertex(self) -> Vertex

            Return this node's current vertex. You would typically call this
            method from an expression on a node that iterates over a set of
            primitive vertices and re-evaluates the parameter for each vertex.

            See hou.SopNode.curPoint for more information.

            Note that hou.SopNode.curPrim returns the primitive containing this
            vertex returned by this method.

            The following lists Python equivalents for some vertex-related
            Hscript expression local variables. Note that you can also access
            local variables from Python using hou.lvar.

          > # $VTX (Hscript expression) or lvar('VTX') (Python):
          > pwd().curVertex().number()
          >
          > # $NVTX (Hscript expression) or lvar('NVTX') (Python):
          > pwd().curPrim().numVertices()

        """
        return _hou.SopNode_curVertex(self)

    def setCurVertex(self, vertex_or_none: "Vertex") -> "void":
        r"""

        setCurVertex(self, vertex_or_none)

            Set this node's current primitive. You can only call this method
            from a Python-defined SOP. See hou.SopNode.setCurPoint for more
            information.

            Note that setting the current vertex will also set the current
            primitive to the primitive containing the vertex.


        """
        return _hou.SopNode_setCurVertex(self, vertex_or_none)

    def managesAttribDataIds(self) -> "bool":
        r"""

        managesAttribDataIds(self) -> bool

            Returns whether this node manages attribute data ids. When true,
            then it is the responsibility of the cooking code to increment the
            appropriate data ids when changing any of the output geometry. This
            defaults to False.


        """
        return _hou.SopNode_managesAttribDataIds(self)

    def setManagesAttribDataIds(self, on: "bool") -> "void":
        r"""

        setManagesAttribDataIds(self, on)

            This method can only be called during the cook of the node itself.
            It declares responsibility for whether the cooking code for the node
            will increment the appropriate data ids when modifying its output
            geometry.

            When this property is False, all data ids on the output is
            automatically incremented after cooking. Setting this to True
            prevents this automatic incrementing from happening. The cooking
            code is then responsible for calling one of data id incrementing
            methods such as: hou.Geometry.incrementDataIdsForAddOrRemove,
            hou.Geometry.incrementPrimitiveIntrinsicsDataId,
            hou.Geometry.incrementTopologyDataId, hou.Attrib.incrementDataId,
            hou.PointGroup.incrementDataId, hou.PrimGroup.incrementDataId,
            hou.EdgeGroup.incrementDataId.

            When unsure, it is better to leave this to the default False or else
            there is a risk that users of the output geometry (eg. the viewport)
            will fail to update when the geometry has changed. When modifying
            geometry outside of cooking, then there is no automatic data id
            incrementing process. In that case, the most conservative action is
            to call hou.Geometry.incrementAllDataIds whenever modifying
            geometry.


            NOTE
                On the , the Maintain State parameter also needs to be enabled
                to perform these data id optimizations since one must record
                these values across different cooks of the node.


        """
        return _hou.SopNode_setManagesAttribDataIds(self, on)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Return whether this node's bypass flag is on.


        """
        return _hou.SopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turn this node's bypass flag on or off, making this node have no
            effect.


        """
        return _hou.SopNode_bypass(self, on)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Return whether this node's display flag is on.


        """
        return _hou.SopNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turn this node's display flag on or off.


        """
        return _hou.SopNode_setDisplayFlag(self, on)

    def isRenderFlagSet(self) -> "bool":
        r"""

        isRenderFlagSet(self) -> bool

            Return whether this node's render flag is on.


        """
        return _hou.SopNode_isRenderFlagSet(self)

    def setRenderFlag(self, on: "bool") -> "void":
        r"""

        setRenderFlag(self, on)

            Turns this node's render flag on or off.


        """
        return _hou.SopNode_setRenderFlag(self, on)

    def isTemplateFlagSet(self) -> "bool":
        r"""

        isTemplateFlagSet(self) -> bool

            Returns whether this node's template flag is on. Templated SOPs are
            display as wireframe in the viewport, and you cannot select geometry
            from them.


        """
        return _hou.SopNode_isTemplateFlagSet(self)

    def setTemplateFlag(self, on: "bool") -> "void":
        r"""

        setTemplateFlag(self, on)

            Turns this node's template flag on or off.


        """
        return _hou.SopNode_setTemplateFlag(self, on)

    def isSelectableTemplateFlagSet(self) -> "bool":
        r"""

        isSelectableTemplateFlagSet(self) -> bool

            Return whether this node's selectable template flag is on. A
            selectable template displays like the display SOP in the viewport,
            and you can select it when choosing points, primitives, etc. Note
            that only the display SOP will be included in the containing
            geometry object or SOP subnet, however, so selectable templates are
            only visible while working inside their SOP network.


        """
        return _hou.SopNode_isSelectableTemplateFlagSet(self)

    def setSelectableTemplateFlag(self, on: "bool") -> "void":
        r"""

        setSelectableTemplateFlag(self, on)

            Turn this node's selectable template flag on or off.


        """
        return _hou.SopNode_setSelectableTemplateFlag(self, on)

    def isHighlightFlagSet(self) -> "bool":
        r"""

        isHighlightFlagSet(self) -> bool

            Return whether this node's highlight flag is on. When this flag is
            turned on, Houdini displays portions of the geometry in yellow in
            the viewport, to indicate the operations performed by this SOP.


        """
        return _hou.SopNode_isHighlightFlagSet(self)

    def setHighlightFlag(self, on: "bool") -> "void":
        r"""

        setHighlightFlag(self, on)

            Turn this node's highlight flag on or off.


        """
        return _hou.SopNode_setHighlightFlag(self, on)

    def isSoftLocked(self) -> "bool":
        r"""

        isSoftLocked(self) -> bool

            Return whether this node is soft-locked. A soft-locked node stores
            position delta information , preventing all but a small set of
            manual modeling changes from being made.


        """
        return _hou.SopNode_isSoftLocked(self)

    def setSoftLocked(self, on: "bool") -> "void":
        r"""

        setSoftLocked(self, on)

            Turns this node's soft-lock flag on or off, allowing a subset of
            manual modeling changes to be made to the locked node.


        """
        return _hou.SopNode_setSoftLocked(self, on)

    def isHardLocked(self) -> "bool":
        r"""

        isHardLocked(self) -> bool

            Return whether this node is hard-locked. A hard-locked node stores
            its data inside the node, and no longer responds to parameter or
            input node changes.


        """
        return _hou.SopNode_isHardLocked(self)

    def setHardLocked(self, on: "bool") -> "void":
        r"""

        setHardLocked(self, on)

            Turn this node's hard-lock flag on or off. Locking a node saves its
            current cooked geometry into the node. If you unlock a hard-locked
            node, it will discard its locked geometry data and recook, computing
            its geometry from its inputs and parameters.


        """
        return _hou.SopNode_setHardLocked(self, on)

    def isUnloadFlagSet(self) -> "bool":
        r"""

        isUnloadFlagSet(self) -> bool

            Returns whether this node's unload flag is on.


        """
        return _hou.SopNode_isUnloadFlagSet(self)

    def setUnloadFlag(self, on: "bool") -> "void":
        r"""

        setUnloadFlag(self, on)

            Turns this node's unload flag on or off.


        """
        return _hou.SopNode_setUnloadFlag(self, on)

    def copyNodeSelectionToUserSelection(self, force_cook: "bool" = False) -> "void":
        return _hou.SopNode_copyNodeSelectionToUserSelection(self, force_cook)

    def displayNode(self) -> "HOM_Node *":
        r"""

        displayNode(self) -> Node

            If this is a subnet SOP, return the SOP inside the subnet with its
            display flag on. Otherwise, return None.


        """
        return _hou.SopNode_displayNode(self)

    def renderNode(self) -> "HOM_Node *":
        r"""

        renderNode(self) -> hou.Node

            If this is a subnet SOP, return the SOP inside the subnet with its
            render flag on. Otherwise, return None.


        """
        return _hou.SopNode_renderNode(self)

    def _setCurrentMicroNodeName(self, name: "char const *") -> "void":
        return _hou.SopNode__setCurrentMicroNodeName(self, name)

    def _getMicroNodesStates(
        self,
    ) -> "std::map< std::string,int,std::less< std::string >,std::allocator< std::pair< std::string const,int > > >":
        return _hou.SopNode__getMicroNodesStates(self)

    def _dirtyMicroNodesStates(self, names: "_StringTuple") -> "void":
        return _hou.SopNode__dirtyMicroNodesStates(self, names)


# Register SopNode in _hou:
_hou.SopNode_swigregister(SopNode)


class SopNodeType(NodeType):
    r"""

    hou.SopNodeType

    This kind of NodeType contains extra attributes specific to SOP nodes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_SopNodeType

    def __repr__(self) -> "std::string":
        return _hou.SopNodeType___repr__(self)

    def selectors(
        self, *args
    ) -> "std::vector< HOM_ElemPtr< HOM_Selector >,std::allocator< HOM_ElemPtr< HOM_Selector > > >":
        r"""

        selectors(self, selector_indices=()) -> tuple of hou.Selector

            Return all the selectors for this node type. See
            hou.SopNodeType.addSelector and hou.Selector for more information.

          > def sopSelectorTypes():
          >     '''Return a list of all the SOP selector type names.'''
          >     selector_types = []
          >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
          >         # Skip manager nodes, like shopnets, ropnets, etc.
          >         if not isinstance(node_type, hou.SopNodeType):
          >             continue
          >
          >         for selector in node_type.selectors():
          >             selector_type = selector.selectorType()
          >             if selector_type not in selector_types:
          >                 selector_types.append(selector_type)
          >     selector_types.sort()
          >     return selector_types
          > def sopTypeNamesUsingSelector(selector_type):
          >     '''Given the name of a selector type, return a list of all the SOP
          >        node types using that selector.'''
          >     node_types = []
          >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
          >         # Skip manager nodes, like shopnets, ropnets, etc.
          >         if not isinstance(node_type, hou.SopNodeType):
          >             continue
          >
          >         for selector in node_type.selectors():
          >             if selector.selectorType() == selector_type:
          >                 node_types.append(node_type)
          >
          >     result = [node_type.name() for node_type in node_types]
          >     result.sort()
          >     return result

        """
        return _hou.SopNodeType_selectors(self, *args)

    def addSelector(self, *args, **kwargs) -> "HOM_Selector *":
        r"""

        addSelector(self, name, selector_type, prompt='Select components',
        primitive_types=(), group_parm_name=None, group_type_parm_name=None,
        input_index=0, input_required=True, allow_dragging=False,
        empty_string_selects_all=True) -> hou.Selector

            Add a selector to this SOP node type. When the user creates a new
            instance of this SOP in the viewer, Houdini will invoke all the
            selectors, wait for the user to select geometry, and then connect
            input SOPs and fill in group parameters to match what was selected.


            name
                A name to give this selector. The name must be unique within
                this node type.

            selector_type
                The name of the type of selector to use. Different selectors
                have different behaviors. For example prims will select only
                primitives and is used, for example, by the cookie SOP. points
                will select only points, and is used by SOPs like the point SOP.
                everything will select any geometry, and is used for SOPs like
                xform and blast.

            prompt
                A string to display at the bottom of the viewer to instruct the
                user what to select.

            primitive_types
                A sequence of hou.primType enumeration values to specify what
                primitive types are allowed. This parameter has no effect if the
                selector does not select primitives. If this sequence is empty,
                all primitive types will be allowed.

            group_parm_name
                The name of the SOP node parameter containing the group field.
                The selector will set this parameter to the string representing
                the points, primitives, edges, etc. chosen by the user in the
                viewer. If None, the selector will look for a parameter named
                group.

            group_type_parm_name
                The name of the SOP node parameter containing the menu of
                geometry types. If the selector can select multiple geometry
                types (e.g. points or primitives), it will set this parameter to
                match the type of geometry the user chose. The transform SOP,
                for example, has a Group Type parameter that tells it how to
                interpret the string in the Group parameter. If None, the
                selector will look for a parameter named grouptype.

            input_index
                The index of the input connector on the SOP node where the
                selector should wire input SOPs. A cookie SOP, for example, has
                two input connectors. It has two selectors, one for each input
                connector.

            input_required
                Whether or not this input is required or optional. If the user
                does not select any geometry and the input is not required, the
                selector will not wire anything to its input connector.

            allow_dragging
                Whether the user is allowed to select the geometry and begin
                manipulating the handles with a single mouse drag. A transform
                SOP, for example, lets you select the geometry and drag it right
                away to transform it. Dragging the geometry forces the selector
                to finish immediately, the selector connects the input and sets
                the group parameter, and subsequent mouse movements are passed
                to the handle which translates the geometry by changing
                parameter values.

            empty_string_selects_all
                Whether or not to use an empty string in the group parameter if
                the user selects all the geometry. If False, Houdini will place
                an asterisk (*) in the group parameter when the user selects all
                the geometry. Most SOPs use an empty string.

            You would typically call this method from the shelf tool script of a
            digital asset. For example, you might put the following in the Tools
            script section of a Python sop that transforms points (having a
            parameter named group):

          > hou.sopNodeTypeCategory().nodeTypes()['$HDA_NAME'].addSelector(
          >     \"Points to Transform\",
          >     \"points\",
          >     prompt=\"Select the points to transform and press Enter to complete\",
          >     group_parm_name=\"group\")

            See also hou.Geometry.globPoints and hou.Geometry.globPrims for
            information on how to parse the strings the selector puts in the
            group field.

            See also hou.Selector.


        """
        return _hou.SopNodeType_addSelector(self, *args, **kwargs)


# Register SopNodeType in _hou:
_hou.SopNodeType_swigregister(SopNodeType)


class SopVerb(object):
    r"""

    hou.SopVerb

    Represents the code of a surface node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_SopVerb

    def __repr__(self) -> "std::string":
        return _hou.SopVerb___repr__(self)

    def execute(self, dest: "Geometry", inputs: "_GeometryTuple") -> "void":
        r"""

        execute(self, destgeo, inputgeolist)

            Applies the verb to the giving destination hou.Geometry. The input
            list is a list of hou.Geometry corresponding to the source node's
            inputs. The parameters used in execution are whatever was set with
            the setParms or loadParmsFromNode functions. The parameters are
            initialized with the node defaults.

            NOTE: Node defaults may change between versions.


        """
        return _hou.SopVerb_execute(self, dest, inputs)

    def executeAtTime(
        self,
        dest: "Geometry",
        inputs: "_GeometryTuple",
        time: "double",
        add_time_dep: "bool",
    ) -> "void":
        r"""

        executeAtTime(self, destgeo, inputgeolist, time, add_time_dep)

            Applies the verb to the giving destination hou.Geometry at a given
            cooking time. The input list is a list of hou.Geometry corresponding
            to the source node's inputs. The parameters used in execution are
            whatever was set with the setParms or loadParmsFromNode functions.
            The parameters are initialized with the node defaults.

            NOTE: Node defaults may change between versions.


        """
        return _hou.SopVerb_executeAtTime(self, dest, inputs, time, add_time_dep)

    def loadParmsFromNode(self, sopnode: "SopNode") -> "void":
        r"""

        loadParmsFromNodeAtTime(self, sopnode, time)

            Initializes all the parameters of this verb from the parameters of a
            specific hou.SopNode at a given time. Useful for cloning an existing
            node instance's behavior.


        """
        return _hou.SopVerb_loadParmsFromNode(self, sopnode)

    def loadParmsFromNodeAtTime(self, sopnode: "SopNode", time: "double") -> "void":
        return _hou.SopVerb_loadParmsFromNodeAtTime(self, sopnode, time)

    def parms(
        self,
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        parms(self) -> dictionary

            Returns a dictionary of parameter name / value pairs currently set
            on this verb. This will be the complete list understood, including
            defaults. Multiparms are represented as a sub list of dictionaries.

            This uses ParmTuple names, not channel names.


        """
        return _hou.SopVerb_parms(self)

    def setParms(
        self,
        p: "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > const &",
    ) -> "void":
        r"""

        setParms(self, parmdictionary)

            Updates a subset of parmeters on this verb with those specified in
            the dictionary. Exceptions are raised if attempts are made to set
            non-existent parameters or with incorrect types.

            This uses ParmTuple names, not channel names. So for a transform you
            would use xform.setParms({'t':(2,0,0)}) rather than tx.


        """
        return _hou.SopVerb_setParms(self, p)

    def minNumInputs(self) -> "int":
        r"""

        minNumInputs(self) -> integer

            Returns the minimum number of geometry inputs required for this verb
            to compute successfully.


        """
        return _hou.SopVerb_minNumInputs(self)


# Register SopVerb in _hou:
_hou.SopVerb_swigregister(SopVerb)


class StringKeyframe(BaseKeyframe):
    r"""

    hou.StringKeyframe

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        hou.StringKeyframe

        """
        _hou.StringKeyframe_swiginit(self, _hou.new_StringKeyframe(*args))

    __swig_destroy__ = _hou.delete_StringKeyframe

    def __repr__(self) -> "std::string":
        return _hou.StringKeyframe___repr__(self)

    def evaluatedType(self) -> "HOM_EnumValue &":
        r"""

        evaluatedType(self) -> hou.parmData enum value

            Return the data type of the keyframe's evaluated value. For string
            keyframes this method returns hou.parmData.String.


        """
        return _hou.StringKeyframe_evaluatedType(self)


# Register StringKeyframe in _hou:
_hou.StringKeyframe_swigregister(StringKeyframe)


class StringParmTemplate(ParmTemplate):
    r"""

    hou.StringParmTemplate

    Describes a parameter tuple containing string values. These values can
    be arbitrary strings or references to files or nodes

    Note that string parameters may also be menu parameters. String
    parameters with menus are different from hou.MenuParmTemplate objects
    because menu parm templates evaluate to integers.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, num_components, default_value=(),
        naming_scheme=hou.parmNamingScheme.Base1,
        string_type=hou.stringParmType.Regular, file_type=hou.fileType.Any,
        menu_items=(), menu_labels=(), icon_names=(),
        item_generator_script=None, item_generator_script_language=None,
        menu_type=hou.menuType.Normal, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new StringParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            default_value
                See the defaultValue method for more information.

            string_type
                See the stringType method for more information. This parameter
                determines whether the parm template is for arbitrary strings,
                node references, or file references.

            file_type
                See the fileType method for more information. This parameter
                determines the file type when string_type is
                hou.stringParmType.FileReference.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            menu_items
                See the menuItems method for more information. Note that
                num_components must be 1 if menu items are supplied.

            menu_labels
                See the menuLabels method for more information.

                If this parameter is not given, it defaults to the value of the
                menu_items parameter.

            icon_names
                See the iconNames method for more information.

                If this parameter is an empty tuple, the menu will not contain
                icons.

            item_generator_script
                See the itemGeneratorScript method for more information. for
                more information. Note that num_components must be 1 if a script
                is given.

            item_generator_script_language
                See the itemGeneratorScriptLanguage method for more information.
                If this parameter is None it defaults to
                hou.scriptLanguage.Python.

            menu_type
                See the menuType method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
        _hou.StringParmTemplate_swiginit(
            self, _hou.new_StringParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_StringParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.StringParmTemplate___repr__(self)

    def stringType(self) -> "HOM_EnumValue &":
        r"""

        stringType(self) -> hou.stringParmType enum value

            Return the type of this string parameter. This type determines
            whether the parameter has special selection controls to choose a
            file path or the paths to one or more nodes.

            See hou.stringParmType for more information.


        """
        return _hou.StringParmTemplate_stringType(self)

    def setStringType(self, string_type: "EnumValue") -> "void":
        r"""

        setStringType(self, string_type)

            Set the type of this string parameter to a hou.stringParmType enum
            value.

            See the stringType method for more information.


        """
        return _hou.StringParmTemplate_setStringType(self, string_type)

    def fileType(self) -> "HOM_EnumValue &":
        r"""

        fileType(self) -> hou.fileType enum value

            Return the file type of this string parameter. The file type applies
            only when stringType() == hou.stringParmType.FileReference. Only
            hou.fileType.Any, hou.fileType.Image, and hou.fileType.Geometry are
            supported by dialog scripts.

            See hou.fileType for more information.


        """
        return _hou.StringParmTemplate_fileType(self)

    def setFileType(self, file_type: "EnumValue") -> "void":
        r"""

        setFileType(self, file_type)

            Set the type of this string parameter to a hou.fileType enum value.

            See the fileType method for more information.


        """
        return _hou.StringParmTemplate_setFileType(self, file_type)

    def defaultValue(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        defaultValue(self) -> tuple of str

            Return the default value for new parameter instances.

            The number of strings in the return value is the same as the number
            of components in the parm template.


        """
        return _hou.StringParmTemplate_defaultValue(self)

    def setDefaultValue(self, default_value: "_StringTuple") -> "void":
        r"""

        setDefaultValue(self, tuple_of_default_values)

            Set the default value for new parameter instances to a sequence of
            strings.

            See the defaultValue method for more information. Note that if the
            number of strings in the sequence is different from the number of
            components in the parm template, any extra values will be discarded
            and any missing values will become the last value in the sequence or
            an empty string if the sequence is empty.


        """
        return _hou.StringParmTemplate_setDefaultValue(self, default_value)

    def defaultExpression(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
        return _hou.StringParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "_StringTuple") -> "void":
        r"""

        setDefaultExpression(self, tuple_of_default_expressions)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.StringParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
        return _hou.StringParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(
        self,
    ) -> "std::vector< HOM_EnumValue *,std::allocator< HOM_EnumValue * > >":
        r"""

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
        return _hou.StringParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "_EnumTuple"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """
        return _hou.StringParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )

    def menuItems(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuItems(self) -> tuple of str

            Return the tuple of internal menu names. If this string does not use
            a menu, returns an empty tuple.

            These internal menu names are not displayed in the UI, but they can
            be passed to hou.Parm.set and will be returned by
            hou.Parm.evalAsString for menu parameters.


        """
        return _hou.StringParmTemplate_menuItems(self)

    def setMenuItems(self, menu_items: "_StringTuple") -> "void":
        r"""

        setMenuItems(self, menu_items)

            Set the internal menu names to the given sequence of strings.

            See the menuItems method for more information.

            If the new number of menu items is less than the old number, the
            menu labels will be shortened and the default value will be modified
            if it is out of range.


        """
        return _hou.StringParmTemplate_setMenuItems(self, menu_items)

    def menuLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        menuLabels(self) -> tuple of str

            Return the tuple of menu labels displayed in the UI. These labels
            are used when this parm template uses a menu.


        """
        return _hou.StringParmTemplate_menuLabels(self)

    def setMenuLabels(self, menu_labels: "_StringTuple") -> "void":
        r"""

        setMenuLabels(self, menu_labels)

            Set the menu labels displayed in the UI to the given sequence of
            strings.

            If the number of menu labels is less than the number of menu items,
            Houdini uses the internal menu item names for the missing labels. If
            the number of labels is more than the number of menu items, Houdini
            discards the extra labels.

            If you want to change both the menu items and menu labels, be sure
            to change the menu items first.


        """
        return _hou.StringParmTemplate_setMenuLabels(self, menu_labels)

    def iconNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        iconNames(self) -> tuple of str

            Return the tuple of icons corresponding to the menu items. If there
            are no icons, returns a tuple of empty strings.

            These icons are used when this parm template uses a menu.


        """
        return _hou.StringParmTemplate_iconNames(self)

    def setIconNames(self, icon_names: "_StringTuple") -> "void":
        r"""

        setIconNames(self, icon_names)

            Set the icon names to the given sequence of strings.


        """
        return _hou.StringParmTemplate_setIconNames(self, icon_names)

    def itemGeneratorScript(self) -> "std::string":
        r"""

        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

            Return the script used to generate menu items, or an empty string if
            there is no such script.


        """
        return _hou.StringParmTemplate_itemGeneratorScript(self)

    def setItemGeneratorScript(self, item_generator_script: "char const *") -> "void":
        r"""

        setItemGeneratorScript(self, item_generator_script)

            Set the script used to generate menu items.

            See the itemGeneratorScript method for more information.


        """
        return _hou.StringParmTemplate_setItemGeneratorScript(
            self, item_generator_script
        )

    def itemGeneratorScriptLanguage(self) -> "HOM_EnumValue &":
        return _hou.StringParmTemplate_itemGeneratorScriptLanguage(self)

    def setItemGeneratorScriptLanguage(self, language: "EnumValue") -> "void":
        r"""

        setItemGeneratorScriptLanguage(self, language)

            Set the script language used to generate menu items to a
            hou.scriptLanguage enum value.

            See the itemGeneratorScriptLanguage method for more information.


        """
        return _hou.StringParmTemplate_setItemGeneratorScriptLanguage(self, language)

    def menuType(self) -> "HOM_EnumValue &":
        r"""

        menuType(self) -> hou.menuType enum value

            Return the type of menu. See hou.menuType for more information.


        """
        return _hou.StringParmTemplate_menuType(self)

    def setMenuType(self, menu_type: "EnumValue") -> "void":
        r"""

        setMenuType(self, menu_type)

            Set the type of menu to a hou.menuType enum value.

            See the menuType method for more information.


        """
        return _hou.StringParmTemplate_setMenuType(self, menu_type)


# Register StringParmTemplate in _hou:
_hou.StringParmTemplate_swigregister(StringParmTemplate)


class styles(object):
    r"""

    hou.styles

    A module for managing style sheets that are stored with the hip file.

    This module provides functions for accessing and managing style sheets
    that are stored in the hip file as text strings in JSON format. These
    style sheets can be saved into IFD files generated by the ROP.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_styles

    def __repr__(self) -> "std::string":
        return _hou.styles___repr__(self)

    def hasStyle(self, name: "char const *") -> "bool":
        r"""

        hasStyle(name) -> bool

            Returns true if there is a style with the specified name.


        """
        return _hou.styles_hasStyle(self, name)

    def styles(
        self, pattern: "char const *" = None
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        styles() -> tuple of str

            Return a tuple containing the names of all styles in the style
            manager.


        """
        return _hou.styles_styles(self, pattern)

    def description(self, style: "char const *") -> "std::string":
        r"""

        description(name) -> str

            Returns the description associated with the named style. If there is
            no style with the provided name, an empty string is returned.


        """
        return _hou.styles_description(self, style)

    def stylesheet(self, style: "char const *") -> "std::string":
        r"""

        stylesheet(name) -> str

            Returns the style sheet text associated with the named style. If
            there is no style with the provided name, an empty string is
            returned.


        """
        return _hou.styles_stylesheet(self, style)

    def errors(self, style: "char const *") -> "std::string":
        r"""

        errors(name) -> str

            Returns any error messages generated while parsing the named style.
            If there is no style with the provided name, an empty string is
            returned.


        """
        return _hou.styles_errors(self, style)

    def addStyle(
        self,
        name: "char const *",
        description: "char const *",
        stylesheet: "char const *",
    ) -> "void":
        r"""

        addStyle(name, description, stylesheet)

            Create a new named style. If a style sheet with the supplied name
            already exists, it will be overwritten with the new values.


            name
                A unique name that will be used to identify the style sheet.
                Follows the same naming limitations as node names (no spaces, no
                slashes, etc).

            description
                An arbitrary string that can optionally be used to identify the
                purpose of this style sheet.

            stylesheet
                The style sheet definition expressed as a string in JSON format.


        """
        return _hou.styles_addStyle(self, name, description, stylesheet)

    def renameStyle(self, old_name: "char const *", new_name: "char const *") -> "void":
        r"""

        renameStyle(old_name, new_name)

            Changes the name of an existing style sheet. If there is no style
            with the provided old_name, or there is already a style with the
            provided new_name, an exception will be generated. References to
            this style sheet in the hip file will be automatically updated to
            refer to the new name.


        """
        return _hou.styles_renameStyle(self, old_name, new_name)

    def reorderStyles(self, names: "_StringTuple") -> "void":
        r"""

        reorderStyles(names)

            Changes the order of the style sheets defined in the hip file. This
            order determines the order of the style names returned by the styles
            function. This in turn may affect the final material assignments in
            a mantra render, since priority is given to style sheets listed last
            in the Apply Style Sheets parameter of the ROP.


            names
                A tuple of strings which must contain exactly the same set of
                strings returned by the styles function, but in a different
                order. If the set of strings do not match, this function raises
                a ValueError.


        """
        return _hou.styles_reorderStyles(self, names)

    def removeStyle(self, name: "char const *") -> "void":
        r"""

        removeStyle(name)

            Deletes an existing style sheet.


        """
        return _hou.styles_removeStyle(self, name)

    def removeAll(self) -> "void":
        r"""

        removeAll()

            Deletes all existing style sheets.


        """
        return _hou.styles_removeAll(self)


# Register styles in _hou:
_hou.styles_swigregister(styles)


class StyleSheet(object):
    r"""

    hou.StyleSheet

    A class that represents a Houdini style sheet. It can be used to
    evaluate, test, and debug style sheet output.

    Unlike the hou.styles module, the style sheets represented by this class
    are not saved anywhere. They are parsed style sheets that can be
    evaluated for particular objects and geometry. This allows you to debug
    the operation of your style sheets outside of mantra. It also allows
    building SOPs which evaluate style information to apply it to a more
    specific target.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, json_text)

            Creates a new StyleSheet from the provided string in JSON format.


        """
        _hou.StyleSheet_swiginit(self, _hou.new_StyleSheet(*args))

    __swig_destroy__ = _hou.delete_StyleSheet

    def __eq__(self, stylesheet: "HOM_PtrOrNull< HOM_StyleSheet >") -> "bool":
        return _hou.StyleSheet___eq__(self, stylesheet)

    def __ne__(self, stylesheet: "HOM_PtrOrNull< HOM_StyleSheet >") -> "bool":
        return _hou.StyleSheet___ne__(self, stylesheet)

    def __hash__(self) -> "int":
        return _hou.StyleSheet___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.StyleSheet___repr__(self)

    def clone(self) -> "HOM_StyleSheet *":
        r"""

        clone(self) -> hou.StyleSheet

            Makes an identical copy of an existing style sheet object.


        """
        return _hou.StyleSheet_clone(self)

    def cloneWithObject(self, obj: "Node") -> "HOM_StyleSheet *":
        r"""

        cloneWithObject(self, object) -> hou.StyleSheet

            Makes a copy of an existing style sheet object which contains only
            the styling information that applies to the provided hou.ObjNode.


        """
        return _hou.StyleSheet_cloneWithObject(self, obj)

    def cloneWithPrim(self, prim: "Prim") -> "HOM_StyleSheet *":
        r"""

        cloneWithPrim(self, prim) -> hou.StyleSheet

            Makes a copy of an existing style sheet object which contains only
            the styling information that applies to the provided hou.Prim.


        """
        return _hou.StyleSheet_cloneWithPrim(self, prim)

    def cloneWithShape(
        self, shape_name: "char const *", agent_prim: "Prim"
    ) -> "HOM_StyleSheet *":
        r"""

        cloneWithShape(self, shape_name, prim) -> hou.StyleSheet

            Makes a copy of an existing style sheet object which contains only
            the styling information that applies to the named shape in the
            provided crowd agent hou.PackedPrim.


        """
        return _hou.StyleSheet_cloneWithShape(self, shape_name, agent_prim)

    def cloneWithAddedStyleSheet(self, *args, **kwargs) -> "HOM_StyleSheet *":
        r"""

        cloneWithAddedStyleSheet(self, stylesheet, target) -> hou.StyleSheet

            Makes a copy of an existing style sheet object combined with another
            style sheet object. The added styles are given a lower priority than
            the styles already in the style sheet. In addition, a target
            argument can be provided which is a JSON formatted string describing
            a target condition which must be satisfied in order for the added
            styles to be applied. This function can therefore be used to build
            an object level style sheet by combining per-primitive style sheets
            from the object's geometry.


        """
        return _hou.StyleSheet_cloneWithAddedStyleSheet(self, *args, **kwargs)

    def errors(self) -> "std::string":
        r"""

        errors(self) -> str

            Returns any errors generated while parsing the style sheet. If there
            are no errors, an empty string is returned. For style sheet objects
            returned from any of the cloneWith methods, the returned string will
            always be empty.


        """
        return _hou.StyleSheet_errors(self)

    def asJSON(self) -> "std::string":
        r"""

        asJSON(self) -> str

            Returns a string containing the JSON that represents the style
            sheet. If the style sheet was constructed from a string argument,
            the original string will be returned even if there were parsing
            errors. If this style sheet was cloned with a specific target, the
            JSON string is generated from the style information that applies to
            that target.


        """
        return _hou.StyleSheet_asJSON(self)


# Register StyleSheet in _hou:
_hou.StyleSheet_swigregister(StyleSheet)


class SubnetIndirectInput(IndirectInput):
    r"""

    hou.SubnetIndirectInput

    A node-like item that appears inside subnets and corresponds to the node
    wired into the subnet.

    For example, suppose you have a font SOP, polyextrude SOP, and facet SOP
    connected together in a chain. If you collapse the polyextrude and facet
    SOPs into a subnet, you're left with a font SOP connected to a subnet
    SOP. Inside the subnet SOP is subnet indirect input #1 connected to a
    polyextrude SOP, which is connected to the facet SOP.

    Each subnet indirect input is numbered starting from 0 and corresponds
    to an input connector on the subnet. (See hou.NodeConnection for more
    information on input connectors.)

    The names of the subnet indirect inputs in the network pane correspond
    to the contents of the Input #n Label parameters on the subnet node,
    where n is the number.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_SubnetIndirectInput

    def __repr__(self) -> "std::string":
        return _hou.SubnetIndirectInput___repr__(self)

    def __hash__(self) -> "int":
        return _hou.SubnetIndirectInput___hash__(self)

    def __eq__(self, input: "HOM_PtrOrNull< HOM_SubnetIndirectInput >") -> "bool":
        return _hou.SubnetIndirectInput___eq__(self, input)

    def __ne__(self, input: "HOM_PtrOrNull< HOM_SubnetIndirectInput >") -> "bool":
        return _hou.SubnetIndirectInput___ne__(self, input)

    def inputConnections(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > >":
        r"""

        inputConnections(self) -> tuple of hou.NodeConnection

            Returns an empty tuple. This method exists to mirror similar methods
            on hou.Node and hou.NetworkDot. This allows these network items to
            be treated in a more uniform way in Python code.


        """
        return _hou.SubnetIndirectInput_inputConnections(self)

    def number(self) -> "int":
        r"""

        number(self) -> int

            Return the number of the corresponding input connector on the
            subnet. Note that input numbers are zero based, so the first input
            will return 0.


        """
        return _hou.SubnetIndirectInput_number(self)


# Register SubnetIndirectInput in _hou:
_hou.SubnetIndirectInput_swigregister(SubnetIndirectInput)


class Surface(Prim):
    r"""

    hou.Surface

    A Surface is a kind of geometry primitive (Prim object) that contains a
    two dimensional grid of vertices (Vertex objects). How these vertices
    are used depends on the type of surface: meshes, for example, use the
    vertices to define a quadrilateral mesh, while NURBS surfaces use them
    as control points.

    A hou.Face, on the other hand, stores a sequence of vertices, and might
    be a polygon or NURBS curve.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Surface

    def __repr__(self) -> "std::string":
        return _hou.Surface___repr__(self)

    def numRows(self) -> "int":
        r"""

        numRows(self)

            Return the number of rows in the 2D array of vertices.


        """
        return _hou.Surface_numRows(self)

    def numCols(self) -> "int":
        r"""

        numCols(self)

            Return the number of columns in the 2D array of vertices.


        """
        return _hou.Surface_numCols(self)

    def vertex(self, u_index: "int", v_index: "int") -> "HOM_Vertex *":
        r"""

        vertex(self, u_index, v_index)

            Return an element in the 2D array of vertices, given the u (column)
            and v (row) indices into the array.

            Negative indices are allowed, in which case Houdini will index
            starting from the last vertex.

            For non-negative indices, this method is roughly equivalent to
            writing surf.vertices()[v_index * surf.numCols() + u_index].

            Raises hou.OperationFailed if the u or v indices are invalid.

          > # Use a grid SOP to create a NURBS grid with 3 rows and 2 columns.
          > geo = hou.node(\"/obj\").createNode(\"geo\").createNode(\"grid\").geometry()
          > grid_node = geo.sopNode()
          > grid_node.setDisplayFlag(True)
          > for name, value in (\"type\", \"nurbs\"), (\"rows\", 5), (\"cols\", 4):
          >     grid_node.parm(name).set(value)
          >
          > # Print out the x positions of all the vertices in the surface.
          > surf = geo.iterPrims()[0]
          > for v_index in surf.numRows():
          >     for u_index in surf.numCols():
          >         print surf.vertex(u_index, v_index).point().position()[0],
          >     print

            See also:

          * hou.Prim.vertices

          * hou.Surface.verticesInCol

          * hou.Surface.verticesInRow

          * hou.Geometry.iterPrims


        """
        return _hou.Surface_vertex(self, u_index, v_index)

    def verticesInRow(
        self, v_index: "int"
    ) -> "std::vector< HOM_ElemPtr< HOM_Vertex >,std::allocator< HOM_ElemPtr< HOM_Vertex > > >":
        r"""

        verticesInRow(self, v_index)

            Given a v (i.e. row) index, return a tuple containing all the
            vertices in that row.

            See also hou.Prim.vertices.


        """
        return _hou.Surface_verticesInRow(self, v_index)

    def verticesInCol(
        self, u_index: "int"
    ) -> "std::vector< HOM_ElemPtr< HOM_Vertex >,std::allocator< HOM_ElemPtr< HOM_Vertex > > >":
        return _hou.Surface_verticesInCol(self, u_index)

    def isClosedInU(self) -> "bool":
        r"""

        isClosedInU(self)

            Return whether the first and last columns of vertices are connected.

            A grid, for example, is open in both U and V. A tube is open in one
            of U or V and closed in the other. A torus is closed in both U and
            V.


        """
        return _hou.Surface_isClosedInU(self)

    def isClosedInV(self) -> "bool":
        r"""

        isClosedInV(self)

            Return whether the first and last rows of vertices are connected.

            See hou.Surface.isClosedInU for more information.


        """
        return _hou.Surface_isClosedInV(self)

    def positionAt(self, u: "double", v: "double") -> "HOM_Vector3 *":
        r"""

        positionAt(self, u, v) -> hou.Vector3

            Given normalized (i.e. from 0 to 1) u and v values, returns the
            position of the surface at that parametric location.

            See the surface_wires cookbook example for an example.


        """
        return _hou.Surface_positionAt(self, u, v)

    def normalAt(self, u: "double", v: "double") -> "HOM_Vector3 *":
        r"""

        normalAt(self, u, v) -> Vector3

            Given normalized (i.e. from 0 to 1) u and v values, returns the
            normal of the surface at that parametric location. The normal is a
            vector that is perpendicular to the surface at that location.

            The normal vector is normalized (i.e. it is a unit vector, so its
            length is 1).

            See the surface_wires cookbook example for an example.


        """
        return _hou.Surface_normalAt(self, u, v)

    def attribValueAt(self, *args) -> "InterpreterObject":
        r"""

        attribValueAt(self, attrib_or_name, u, v, du=0, dv=0) -> int, float, str
        or tuple

            Return an attribute value at a normalized (u, v) parametric position
            on the surface. If du and dv are both 0, returns the interpolated
            attribute value; otherwise, returns the (partial) derivative of the
            attribute value.

            Raises hou.OperationFailed if the attribute is not a point or vertex
            attribute. If you want a primitive attribute value, it doesn't vary
            across the surface, so use hou.Prim.attribValue.


        """
        return _hou.Surface_attribValueAt(self, *args)

    def addRow(self, after: "int" = -1) -> "void":
        r"""

        addRow(self, after=-1)

            Add a row of vertices after the given v (i.e. row) index. The new
            vertices are located at the origin until you move them. You would
            typically call this method from the code of a Python-defined SOP.

            See hou.Surface.addCol for more information.


        """
        return _hou.Surface_addRow(self, after)

    def addCol(self, after: "int" = -1) -> "void":
        r"""

        addCol(self, after=-1)

            Add a column of vertices after the given u (i.e. column) index. You
            would typically call this method from the code of a Python-defined
            SOP.

            This method also adds one point per vertex added. The new points are
            located at the origin until you move them.

            The u (i.e. column) index after may be negative, in which case the
            indexing starts from the end. By default, after is -1, meaning that
            the new column will go after the last column. Raises
            hou.OperationFailed if the after index is invalid.

          >
          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > def vertexPos(vertex):
          >     return hou.Vector3(vertex.point().position())
          >
          > # Build a NURBS surface.
          > geo = hou.pwd().geometry()
          > surf = geo.createNURBSSurface(10, 10)
          >
          > # Add a new column, and set the new point positions to the average of
          > # the adjacent point positions.
          > surf.addCol(after=7)
          > for v_index in range(surf.numRows()):
          >     vertex_before = surf.vertex(7, v_index)
          >     vertex_after = surf.vertex(9, v_index)
          >     surf.vertex(8, v_index).point().setPosition(
          >         (vertexPos(vertex_before) + vertexPos(vertex_after)) * 0.5)

        """
        return _hou.Surface_addCol(self, after)


# Register Surface in _hou:
_hou.Surface_swigregister(Surface)


class Take(object):
    r"""

    hou.Take

    RELATED

      * hou.takes


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Take

    def __eq__(self, take: "HOM_PtrOrNull< HOM_Take >") -> "bool":
        return _hou.Take___eq__(self, take)

    def __ne__(self, take: "HOM_PtrOrNull< HOM_Take >") -> "bool":
        return _hou.Take___ne__(self, take)

    def __repr__(self) -> "std::string":
        return _hou.Take___repr__(self)

    def isCurrent(self) -> "bool":
        r"""

        isCurrent(self) -> bool

            Return True if the take is the current take and False otherwise.


        """
        return _hou.Take_isCurrent(self)

    def name(self) -> "std::string":
        r"""

        name(self)

            Return the name of the take.


        """
        return _hou.Take_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Rename the take.


        """
        return _hou.Take_setName(self, name)

    def parent(self) -> "HOM_Take *":
        r"""

        parent(self) -> hou.Take

            Return the parent take or None if this take is the main (master)
            take.


        """
        return _hou.Take_parent(self)

    def path(self) -> "std::string":
        r"""

        path(self) -> str

            Return the path of the take. The take path consists of the name of
            this take as well as the names of its ancestor takes.


        """
        return _hou.Take_path(self)

    def addChildTake(self, name: "char const *" = None) -> "HOM_Take *":
        r"""

        addChildTake(self, name) -> hou.Take

            Create a new take with the given name and add it as a child to this
            take.

            If no name is specified then the take will have a generated name
            based on the default take name.


        """
        return _hou.Take_addChildTake(self, name)

    def insertTakeAbove(self, name: "char const *" = None) -> "HOM_Take *":
        r"""

        insertTakeAbove(self, name) -> hou.Take

            Create a new take with the given name and add it as a child of this
            take's parent. This take is reparented with the newly created take
            as the parent.

            Raise hou.OperationFailed if this take is the main (master) take.


        """
        return _hou.Take_insertTakeAbove(self, name)

    def addNodeDisplayFlag(self, node: "Node") -> "void":
        r"""

        removeNodeDisplayFlag(self, node)

            Exclude the given node's display flag from this take making it
            uneditable in this take.

            This method does nothing if the node's display flag is not included
            in the take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_addNodeDisplayFlag(self, node)

    def removeNodeDisplayFlag(self, node: "Node") -> "void":
        return _hou.Take_removeNodeDisplayFlag(self, node)

    def addNodeBypassFlag(self, node: "Node") -> "void":
        r"""

        removeNodeBypassFlag(self, node)

            Exclude the given node's bypass flag from this take making it
            uneditable in this take.

            This method does nothing if the node's bypass flag is not included
            in the take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_addNodeBypassFlag(self, node)

    def removeNodeBypassFlag(self, node: "Node") -> "void":
        return _hou.Take_removeNodeBypassFlag(self, node)

    def addNodeRenderFlag(self, node: "Node") -> "void":
        r"""

        removeNodeRenderFlag(self, node)

            Exclude the given node's render flag from this take making it
            uneditable in this take.

            This method does nothing if the node's render flag is not included
            in the take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_addNodeRenderFlag(self, node)

    def removeNodeRenderFlag(self, node: "Node") -> "void":
        return _hou.Take_removeNodeRenderFlag(self, node)

    def hasParmTuple(self, parm_tuple: "ParmTuple") -> "bool":
        r"""

        hasParmTuple(self, parm_tuple) -> bool

            Return True if the given parameter is included in this take and
            False otherwise.

            Raise hou.OperationFailed if the parm_tuple argument is None.


        """
        return _hou.Take_hasParmTuple(self, parm_tuple)

    def parmTuples(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ParmTuple >,std::allocator< HOM_ElemPtr< HOM_ParmTuple > > >":
        r"""

        parmTuples(self) -> tuple of hou.ParmTuple

            Return a tuple of node parameters that are included and editable in
            this take.


        """
        return _hou.Take_parmTuples(self)

    def addParmTuple(self, parm_tuple: "ParmTuple") -> "void":
        r"""

        addParmTuple(self, parm_tuple)

            Include the given parameter in this take making it editable in this
            take.

            This method does nothing if the parameter is already included in
            this take.

            Raise hou.OperationFailed if the parm_tuple argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_addParmTuple(self, parm_tuple)

    def removeParmTuple(self, parm_tuple: "ParmTuple") -> "void":
        r"""

        removeParmTuple(self, parm_tuple)

            Exclude the given parameter from this take making it uneditable in
            this take.

            This method does nothing if the parameter is not included in this
            take.

            Raise hou.OperationFailed if the parm_tuple argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_removeParmTuple(self, parm_tuple)

    def addParmTuplesFromTake(
        self, take: "Take", overwrite_existing: "bool" = True
    ) -> "void":
        r"""

        addParmTuplesFromTake(self, take, overwrite_existing=True)

            Include all the given take's parameters in this take making the
            parameters editable in this take.

            If overwrite_existing is True then parameters that are already
            included in this take will have their values overwritten by the same
            parameters found in the other take. Otherwise, parameters already
            included in this take will not be affected by the same parameters
            found in the other take.

            Raise hou.OperationFailed if the take argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_addParmTuplesFromTake(self, take, overwrite_existing)

    def addParmTuplesFromNode(self, node: "Node") -> "void":
        return _hou.Take_addParmTuplesFromNode(self, node)

    def removeParmTuplesFromNode(self, node: "Node") -> "void":
        r"""

        removeParmTuplesFromNode(self, node)

            Exclude all the given node's parameters from this take making them
            uneditable in this take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
        return _hou.Take_removeParmTuplesFromNode(self, node)

    def children(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Take >,std::allocator< HOM_ElemPtr< HOM_Take > > >":
        r"""

        children(self) -> tuple of hou.Take

            Return a tuple of the child takes.


        """
        return _hou.Take_children(self)

    def saveToFile(self, filename: "char const *", recurse: "bool" = False) -> "void":
        r"""

        saveToFile(self, filename, recurse=False)

            Save this take to a file on disk.

            If recurse is True then any child and descendent takes will also be
            saved to the file.

            Note that the saved file can only be loaded within the same .hip
            file session. If Houdini is restarted or if the .hip file is closed
            and re-opened then the saved file will fail to load.

            Raise hou.OperationFailed if the filename argument does not point to
            a valid location on disk.


        """
        return _hou.Take_saveToFile(self, filename, recurse)

    def loadChildTakeFromFile(self, filename: "char const *") -> "HOM_Take *":
        r"""

        loadChildTakeFromFile(self, filename) -> tuple of hou.Take

            Load a take from a file that is saved to disk and make it a child of
            this take. This will also load any child and descendent takes that
            are saved in the file.

            Return a tuple of takes that have been loaded from the file. The
            first take in the tuple is the direct child take of this take. All
            takes that follow are the children and descendents of the first
            take.

            Loaded takes will be renamed if there already exists takes with the
            same names.

            Note that you can only load files that have been saved from the same
            .hip file session. If Houdini is restarted or if the .hip file is
            closed and re-opened after the save then the file will fail to load.

            Raise hou.OperationFailed if the filename argument does not point to
            a valid file on disk.


        """
        return _hou.Take_loadChildTakeFromFile(self, filename)

    def moveUnderTake(self, take: "Take") -> "void":
        r"""

        moveUnderTake(self, take)

            Reparent this take to the specified take.

            Raise hou.OperationFailed if the take argument is None. Raise
            hou.OperationFailed if this take is the main (master) take.


        """
        return _hou.Take_moveUnderTake(self, take)

    def destroy(self, recurse: "bool" = False) -> "void":
        r"""

        destroy(self, recurse=False)

            Deletes the take.

            If recurse is True then all child and descendent takes will be
            deleted as well.


        """
        return _hou.Take_destroy(self, recurse)


# Register Take in _hou:
_hou.Take_swigregister(Take)


class takes(object):
    r"""

    hou.takes

    RELATED

      * hou.Take


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_takes

    def __repr__(self) -> "std::string":
        return _hou.takes___repr__(self)

    def takes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Take >,std::allocator< HOM_ElemPtr< HOM_Take > > >":
        r"""

        takes() -> tuple of hou.Take

            Return a tuple of all the takes in the scene.


        """
        return _hou.takes_takes(self)

    def currentTake(self) -> "HOM_Take *":
        r"""

        currentTake() -> hou.Take

            Return the current take.


        """
        return _hou.takes_currentTake(self)

    def setCurrentTake(self, take: "Take") -> "void":
        r"""

        setCurrentTake(take)

            Set the current take to the specified take.

            Raise hou.OperationFailed if the take argument is None.


        """
        return _hou.takes_setCurrentTake(self, take)

    def rootTake(self) -> "HOM_Take *":
        r"""

        rootTake() -> hou.Take

            Return the main (master) take.


        """
        return _hou.takes_rootTake(self)

    def findTake(self, take_name: "char const *") -> "HOM_Take *":
        r"""

        findTake(take_name) -> hou.Take or None

            Return the take with the specified name or None if no such take
            exists.


        """
        return _hou.takes_findTake(self, take_name)

    def defaultTakeName(self) -> "std::string":
        r"""

        defaultTakeName()

            Return the default take name used for new takes. The default name
            acts like a prefix since new takes will contain the default name
            plus a numerical suffix in their take names.


        """
        return _hou.takes_defaultTakeName(self)

    def setDefaultTakeName(self, default_name: "char const *") -> "void":
        r"""

        setDefaultTakeName()

            Sets the default take name. The default take name is used as a
            prefix for the names of new takes.


        """
        return _hou.takes_setDefaultTakeName(self, default_name)


# Register takes in _hou:
_hou.takes_swigregister(takes)


class text(object):
    r"""

    hou.text

    Module containing Houdini-specific string manipulation methods.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_text

    def __repr__(self) -> "std::string":
        return _hou.text___repr__(self)

    def expandString(self, str: "char const *") -> "std::string":
        r"""

        expandString(str) -> str

            Expands global variables in the expression. For example, when
            Houdini is at frame 10:

          > >>> hou.expandStringAtFrame('$F')
          > '10'

            Also expands HScript expressions in backticks, such as the channel
            reference in this example. This returns the value of the translate X
            parameter for geo1 at the current frame as a string:

          > hou.expandStringAtFrame('`ch(\"/obj/geo1/tx\")`')

            This function evaluates the string as if it were the contents of a
            non-animated text parameter. To evaluate a straight HScript
            expression (without needing backticks), use hou.hscriptExpression.

            Raises hou.OperationFailed exception if the first argument is None.

          > >>> hou.expandString(\"$HIP/file.geo\")
          > '/dir/containing/hip/file/file.geo'
          > >>> hou.expandString(\"file`$F+1`.pic\")
          > 'file2.pic'

        """
        return _hou.text_expandString(self, str)

    def expandStringAtFrame(
        self, str: "char const *", frame: "double"
    ) -> "std::string":
        r"""

        expandStringAtFrame(str, frame_number) -> str

            Expands global variables in the expression. For example:

          > >>> hou.expandStringAtFrame('$F', 10)
          > '10'

            Also expands HScript expressions in back-ticks, such as the channel
            reference in this example. This returns the value of the translate X
            parameter for geo1 at the current frame as a string:

          > hou.expandStringAtFrame('`ch(\"/obj/geo1/tx\")`', hou.frame())

            This function evaluates the string as if it were the contents of a
            non-animated text parameter. To evaluate a straight HScript
            expression (without needing back-ticks), use hou.hscriptExpression.

            Raises hou.OperationFailed exception if the first argument is None.


        """
        return _hou.text_expandStringAtFrame(self, str, frame)

    def incrementNumberedString(self, str: "char const *") -> "std::string":
        r"""

        incrementNumberedString(str) -> str

            If the string ends with a number, that number is incremented, and
            the resulting new string is returned. If the string does not end
            with a number, a number is appended to the string. This is the
            algorithm used by Houdini to generate uniquely named child nodes
            inside a network.

          > >>> hou.incrementNumberedString('name1')
          > 'name2'
          > >>> hou.incrementNumberedString('name199')
          > 'name200'
          > >>> hou.incrementNumberedString('name')
          > 'name2'
          > >>> hou.incrementNumberedString('')
          > '2'

        """
        return _hou.text_incrementNumberedString(self, str)

    def encode(self, varname: "char const *") -> "std::string":
        r"""

        encode(str) -> str

            Houdini VEX variable names are only allowed to contain letters,
            numbers, and underscores, and must not begin with a number. This
            method takes any string, and encodes it into a string that obeys
            these restrictions. The original string can be recovered using the
            decode method. A string that already obeys the rules is returned
            unmodified.

            One exception to this rule is that a string starting with xn__ will
            be encoded even if it is already a valid attribute name. This is
            because xn__ is the prefix used to identify an encoded string. In
            this case, an additional xn__ prefix will be added. This means a
            string can be encoded any number of times, then decoded the same
            number of times to always return to the original string, regardless
            of its contents.

          > >>> hou.text.encode('foo:bar')
          > 'xn__foobar_rla'
          > >>> hou.text.encode('safe_name')
          > 'safe_name'

        """
        return _hou.text_encode(self, varname)

    def decode(self, varname: "char const *") -> "std::string":
        r"""

        decode(str) -> str

            Houdini VEX variable names are only allowed to contain letters,
            numbers, and underscores, and must not begin with a number.
            Arbitrary strings can be passed through the encode method to
            generate a string that obeys these restriction. This method takes
            one of these encoded strings, and returns the original string. A
            string that has not been encoded will be returned unmodified.

          > >>> hou.text.decode('xn__foobar_rla')
          > 'foo:bar'
          > >>> hou.text.decode('safe_name')
          > 'safe_name'

        """
        return _hou.text_decode(self, varname)

    def encodeAttrib(self, attribname: "char const *") -> "std::string":
        r"""

        encodeAttrib(str) -> str

            Houdini geometry attributes and group names are only allowed to
            contain letters, numbers, and underscores, and must not begin with a
            number. This method takes any string, and encodes it into a string
            that obeys these restrictions. The original string can be recovered
            using the decodeAttrib method. A string that already obeys the rules
            is returned unmodified.

            One exception to this rule is that a string starting with xn__ will
            be encoded even if it is already a valid attribute name. This is
            because xn__ is the prefix used to identify an encoded string. In
            this case, an additional xn__ prefix will be added. This means a
            string can be encoded any number of times, then decoded the same
            number of times to always return to the original string, regardless
            of its contents.

          > >>> hou.text.encodeAttrib('foo:bar')
          > 'xn__foobar_rla'
          > >>> hou.text.encodeAttrib('safe_name')
          > 'safe_name'

        """
        return _hou.text_encodeAttrib(self, attribname)

    def decodeAttrib(self, attribname: "char const *") -> "std::string":
        r"""

        decodeAttrib(str) -> str

            Houdini geometry attributes and group names are only allowed to
            contain letters, numbers, and underscores, and must not begin with a
            number. Arbitrary strings can be passed through the encodeAttrib
            method to generate a string that obeys these restriction. This
            method takes one of these encoded strings, and returns the original
            string. A string that has not been encoded will be returned
            unmodified.

          > >>> hou.text.decodeAttrib('xn__foobar_rla')
          > 'foo:bar'
          > >>> hou.text.decodeAttrib('safe_name')
          > 'safe_name'

        """
        return _hou.text_decodeAttrib(self, attribname)

    def encodeParm(self, parmname: "char const *") -> "std::string":
        r"""

        encodeParm(str) -> str

            Houdini parameter names are only allowed to contain letters,
            numbers, hash characters (for multiparms), and underscores, and must
            not begin with a number. This method takes any string, and encodes
            it into a string that obeys these restrictions. The original string
            can be recovered using the decodeParm method. A string that already
            obeys the rules is returned unmodified.

            One exception to this rule is that a string starting with xn__ will
            be encoded even if it is already a valid attribute name. This is
            because xn__ is the prefix used to identify an encoded string. In
            this case, an additional xn__ prefix will be added. This means a
            string can be encoded any number of times, then decoded the same
            number of times to always return to the original string, regardless
            of its contents.

          > >>> hou.text.encodeParm('foo:bar')
          > 'xn__foobar_rla'
          > >>> hou.text.encodeParm('safe_name')
          > 'safe_name'

        """
        return _hou.text_encodeParm(self, parmname)

    def decodeParm(self, parmname: "char const *") -> "std::string":
        r"""

        decodeParm(str) -> str

            Houdini parameter names are only allowed to contain letters,
            numbers, hash characters (for multiparms), and underscores, and must
            not begin with a number. Arbitrary strings can be passed through the
            encodeParm method to generate a string that obeys these restriction.
            This method takes one of these encoded strings, and returns the
            original string. A string that has not been encoded will be returned
            unmodified.

          > >>> hou.text.decodeParm('xn__foobar_rla')
          > 'foo:bar'
          > >>> hou.text.decodeParm('safe_name')
          > 'safe_name'

        """
        return _hou.text_decodeParm(self, parmname)

    def alphaNumeric(self, str: "char const *") -> "std::string":
        r"""

        alphaNumeric(str) -> str

            Return a string that consists of only numbers, letters, and
            underscores. Any other character in the string is replaced with an
            underscore. This provides an easy way to create strings that are
            safe for use as file names, and almost safe to use as node or
            variable names (variable names usually have the additional condition
            that they are not allowed to start with a number).
            hou.text.variableName can be used to produce a valid variable name.

            Unlike the encode method, the original string cannot be recovered
            from the result of this method. However the results of this method
            are more easily human readable than the result of an encode
            operation.


        """
        return _hou.text_alphaNumeric(self, str)

    def variableName(
        self, str: "char const *", safe_chars: "char const *" = None
    ) -> "std::string":
        r"""

        variableName(str, safe_chars=\"\") -> str

            Returns a string that is valid to use as a variable or node name.
            This behaves the same as hou.text.alphaNumeric, but also adds an
            underscore at the beginning of strings that begin with a number. The
            optional safe_chars argument specifies a string with any extra
            characters that should not be converted to underscores.

          > >>> hou.text.variableName('foo:bar')
          > 'foo_bar'
          > >>> hou.text.variableName('123')
          > '_123'
          > >>> hou.text.variableName('foo:?bar', safe_chars=\":\")
          > 'foo:_bar'

        """
        return _hou.text_variableName(self, str, safe_chars)

    def abspath(
        self, path: "char const *", anchor_path: "char const *" = None
    ) -> "std::string":
        r"""

        abspath(path, base_path = None) -> str

            Returns the supplied path converted to an absolute path. Relative
            paths are treated as relative to the directory specified by
            base_path. If the supplied path is already absolute, the path is
            returned unchanged. If the base_path is not provided, Houdini's
            current working directory is used for this value. The file does not
            need to exist.


        """
        return _hou.text_abspath(self, path, anchor_path)

    def relpath(
        self, path: "char const *", anchor_path: "char const *" = None
    ) -> "std::string":
        r"""

        relpath(path, base_path = None) -> str

            Returns the supplied path converted to a relative path, expressed as
            relative to the directory specified by base_path. If the base_path
            is not provided, Houdini's current working directory is used for
            this value. The file does not need to exist.


        """
        return _hou.text_relpath(self, path, anchor_path)

    def normpath(self, path: "char const *") -> "std::string":
        r"""

        normpath(path) -> str

            Returns a normalized version of the supplied path. This means that
            all path separators are expressed as forward slashes (even on
            Windows). Any redundant slashes are replaced by a single slash. And
            any relative path components appearing in the middle of the path are
            collapsed.

          > >>> hou.text.normpath('http://foo/bar/..//something')
          > 'http://foo/something'
          > >>> hou.text.normpath('\foo\bar\something\')
          > '/foo/bar/something'
          > >>> hou.text.normpath('../../foo/../bar/../something')
          > '../../something'

        """
        return _hou.text_normpath(self, path)

    def collapseCommonVars(self, *args, **kwargs) -> "std::string":
        r"""

        collapseCommonVars(path, vars = ['$HIP', '$JOB']) -> str

            Tests if the path starts with the expanded form of any variable
            passed in through the provided vars list. If it does, that prefix is
            replaced with the corresponding unexpanded variable. For example, if
            $HIP is /home/user/hips, and path is /home/user/hips/file.hip, the
            returned string will be $HIP/file.hip.


        """
        return _hou.text_collapseCommonVars(self, *args, **kwargs)

    def patternRename(
        self, str: "char const *", find: "char const *", replace: "char const *"
    ) -> "std::string":
        r"""

        patternRename(input_string, pattern_find, pattern_replace) -> str

            This function finds the pattern given in pattern_find and replaces
            any occurrences with the pattern given in pattern_replace. For
            example:

          > >>> hou.patternRename(\"foo_bar_baz\", \"*bar*\", \"*blah*\")
          > foo_blah_baz
          > >>> hou.patternRename(\"left_hand_01\", \"left*\", \"right*\")
          > right_hand_01

        """
        return _hou.text_patternRename(self, str, find, replace)

    def patternMatch(
        self,
        pattern: "char const *",
        str: "char const *",
        ignore_case: "bool" = False,
        path_match: "bool" = False,
    ) -> "bool":
        r"""

        patternMatch(pattern_string, input_string, ignore_case = False,
        path_match = False) -> bool

            This function is case-sensitive. Set ignore_case to True for case-
            insensitive pattern matching.

            This function does not treat path separator characters specially.
            Set path_match to True for path-aware matching, where the multi-
            level wildcard () is required to cover multiple path components.

            Returns 1 if any patterns in the pattern string matches the input
            string, or 0 if no patterns match.

            In order to match, a pattern must match the input string from
            beginning to end. Use wildcards (*) to match substrings, e.g.

          > >>> hou.patternMatch(\"bar\", \"foobarbaz\")
          > False
          > >>> hou.patternMatch(\"*bar*\", \"foobarbaz\")
          > True

            pattern is a space-separated list of one or more patterns. This can
            cause unintuitive behavior of this function. For example:

          > >>> hou.patternMatch(\"foo bar\", \"foo bar\")
          > False

            ...will return 0, because the first argument consists of two
            patterns, foo and bar, and neither of those patterns match foo bar
            (since the pattern must match from beginning to end).

            Similarly,

          > >>> hou.patternMatch(\"foo bar\", \"foo\")
          > True

            ...will return 1, because the string matches the first of the two
            arguments in the pattern (foo and bar).

          > >>> hou.patternMatch(\"/foo/*\", \"/foo/bar/blah\", path_match = True)
          > False

            ...will return 0, because the wildcard only matches against the
            first path component (/bar), leaving the last path component (/blah)
            unmatched.

          > >>> hou.patternMatch(\"/foo/**\", \"/foo/bar/blah\", path_match = True)
          > True

            ...will return 1, because the multi-level wildcard will matches
            against any number of path components.


        """
        return _hou.text_patternMatch(self, pattern, str, ignore_case, path_match)


# Register text in _hou:
_hou.text_swigregister(text)


class TextDrawable(AdvancedDrawable):
    r"""

    hou.TextDrawable

    A drawable object to render text in the viewport.

    OVERVIEW

        A text drawable is designed for custom Python states and is used for
        drawing text elements in the viewport in viewport coordinates. For
        instance, you can use a text drawable to display directives for
        guiding the user or for displaying technical information.

        hou.TextDrawable lets you translate, rotate and scale the text in 2D
        space with viewport coordinates. The lower left corner of the
        viewport is the base point coordinate (0,0).

        Here's an example for displaying text in the upper left corner of
        the viewport.

      > import hou
      >
      > class State(object):
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      >
      >         # Create an empty text drawable
      >         self.text_drawable = hou.TextDrawable(self.scene_viewer, 'text_drawable_name')
      >
      >         # Display the text on the next viewport redraw
      >         self.text_drawable.show(True)
      >
      >     def onDraw( self, kwargs ):
      >         # draw the text in the viewport upper left
      >         handle = kwargs['draw_handle']
      >
      >         (x,y,width,height) = self.scene_viewer.curViewport().size()
      >         margin = 10
      >         params = {
      >             'text': 'First line<br>Second line<br>Third line',
      >             'multi_line' : True,
      >             'color1' : hou.Color(1.0,0.0,0.0),
      >             'translate' : hou.Vector3(0, height, 0),
      >             'origin' : hou.drawableTextOrigin.UpperLeft,
      >             'margins': hou.Vector2(margin, -margin) }
      >
      >         self.text_drawable.draw( handle, params )

        An example to display text at the cursor position.

      > import hou
      >
      > class State(object):
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      >
      >         # Create the text drawable
      >         self.text_cursor = hou.TextDrawable(self.scene_viewer, 'text_cursor')
      >
      >         # Display the text on the next viewport redraw
      >         self.text_cursor.show(True)
      >
      >     def onMouseEvent(self, kwargs):
      >         # Compute the mouse position in screen coordinates
      >         ui_event = kwargs[\"ui_event\"]
      >         (origin, dir) = ui_event.ray()
      >         self.mouse_screen = self.scene_viewer.curViewport().mapToScreen(origin)
      >
      >     def onDraw( self, kwargs ):
      >         # draw the text in the viewport upper left
      >         handle = kwargs['draw_handle']
      >
      >         params = {
      >             'text': '<font color=\"yellow\">x=%.2f, y=%.2f</font>' % (self.mouse_screen[0], self.mouse_screen[1]),
      >             'translate' : hou.Vector3(self.mouse_screen[0],self.mouse_screen[1], 0.0) }
      >
      >         self.text_cursor.draw( handle, params )

    RELATED

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, scene_viewer, name, label=None, params=None)

            Creates a text drawable object. The new drawable is hidden by
            default.


            scene_viewer
                A hou.SceneViewer reference to the viewer the text will appear
                in.

            name
                A string to identify this drawable object.

            label
                An optional string for the drawable label. Defaults to empty.

            params
                An optional parameter dictionary for setting the drawable
                parameters. These parameters are also be used with
                hou.AdvancedDrawable.draw or hou.AdvancedDrawable.setParams.

                Other drawable common parameters are documented here.

                color1
                hou.Color

                Default foreground color for drawing the text. This value can be
                overridden with the text <font> token. Defaults to hou.Color(1,
                1, 1).

                multi_line
                Bool

                Draws the text on multiple lines if formatted with line breaks
                <br>. Defaults to False.

                origin
                hou.drawableTextOrigin

                Origin point for placing the text within its bounding box.
                Defaults to hou.drawableTextOrigin.BottomLeft.

                text
                String

                The text to draw. A small subset of HTML 4.0 tokens is available
                for formatting the text:

              * <b> : Bold

              * <i> : Italic

              * <font [size] [color]> : Font change

              * <br> : Line break (equivalent to
        )

              * <sub> : Subscript

              * <sup> : Superscript

                margins
                hou.Vector2 or sequence of 2 double values

                Specifies the x and y margins of the text 2D bounding box, in
                viewport coordinates. Defaults to 0.0.


        """
        _hou.TextDrawable_swiginit(self, _hou.new_TextDrawable(*args, **kwargs))

    __swig_destroy__ = _hou.delete_TextDrawable

    def __repr__(self) -> "std::string":
        return _hou.TextDrawable___repr__(self)

    def size(
        self, text: "std::string const &"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        size(self, text) -> tuple of double

            Computes the width and height of a text string for the drawable font
            and returns the values in a tuple:

             1. Width (dimension in pixels).

             2. Height (dimension in pixels).


        """
        return _hou.TextDrawable_size(self, text)


# Register TextDrawable in _hou:
_hou.TextDrawable_swigregister(TextDrawable)


class ToggleParmTemplate(ParmTemplate):
    r"""

    hou.ToggleParmTemplate

    Describes a parameter tuple containing a checkbox.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, default_value=False, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=\"\",
        default_expression_language=hou.scriptLanguage.Hscript)

            Creates a new ToggleParmTemplate instance.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information. See the
                defaultValue method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.

            Note that ToggleParmTemplates have only one component. Unlike float,
            integer, and string parm templates, the default value is a single
            bool and not a tuple.


        """
        _hou.ToggleParmTemplate_swiginit(
            self, _hou.new_ToggleParmTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_ToggleParmTemplate

    def __repr__(self) -> "std::string":
        return _hou.ToggleParmTemplate___repr__(self)

    def defaultValue(self) -> "bool":
        r"""

        defaultValue(self) -> bool

            Returns the default value for new parameter instances.

            Note that ToggleParmTemplates have only one component. Unlike float,
            integer, and string parm templates, the default value is a single
            bool and not a tuple.


        """
        return _hou.ToggleParmTemplate_defaultValue(self)

    def setDefaultValue(self, default_value: "bool") -> "void":
        r"""

        setDefaultValue(self, default_value)

            Set the default value for new parameter instances. The default_value
            should be True or False.


        """
        return _hou.ToggleParmTemplate_setDefaultValue(self, default_value)

    def defaultExpression(self) -> "std::string":
        r"""

        defaultExpression(self) -> string

            Return the expression, which when evaluated, returns the initial
            value of the toggle.

            The default expression takes precedence over the default value. If
            the default expression is not set (i.e. an empty string), then the
            default value is used instead.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
        return _hou.ToggleParmTemplate_defaultExpression(self)

    def setDefaultExpression(self, default_expression: "std::string const &") -> "void":
        r"""

        setDefaultExpression(self, default_expression)

            Set the default expression, which when evaluated, returns the
            initial value of the toggle.

            If default_expression is the empty string, then the default
            expression is unset.


        """
        return _hou.ToggleParmTemplate_setDefaultExpression(self, default_expression)

    def defaultExpressionLanguage(self) -> "HOM_EnumValue &":
        r"""

        defaultExpressionLanguage(self) -> hou.scriptLanguage

            Return the default expression language.

            The default expression language only applies if the default
            expression is set. If the default expression is not set, then the
            expression language is set to hou.scriptLanguage.Hscript.


        """
        return _hou.ToggleParmTemplate_defaultExpressionLanguage(self)

    def setDefaultExpressionLanguage(
        self, default_expression_language: "EnumValue"
    ) -> "void":
        r"""

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language.

            See the defaultExpressionLanguage method for more information.


        """
        return _hou.ToggleParmTemplate_setDefaultExpressionLanguage(
            self, default_expression_language
        )


# Register ToggleParmTemplate in _hou:
_hou.ToggleParmTemplate_swigregister(ToggleParmTemplate)


class Tool(ShelfElement):
    r"""

    hou.Tool

    Represents a tool on the shelf, encapsulating a script as well as a
    label, help, and other information.

    You can't instantiate this object directly, call hou.shelves.newTool
    instead.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Tool

    def __repr__(self) -> "std::string":
        return _hou.Tool___repr__(self)

    def __lt__(self, other: "Tool") -> "bool":
        return _hou.Tool___lt__(self, other)

    def __hash__(self) -> "int":
        return _hou.Tool___hash__(self)

    def script(self) -> "std::string":
        r"""

        script(self) -> str

            Returns the text of the script that runs when the user clicks the
            tool.


        """
        return _hou.Tool_script(self)

    def setScript(self, script: "char const *") -> "void":
        r"""

        setScript(self, script)

            Sets the text of the script to run when the user clicks the tool in
            the shelf. See how to write a tool script for information on the
            global variables available to the script and tips for common tasks.


        """
        return _hou.Tool_setScript(self, script)

    def language(self) -> "HOM_EnumValue &":
        r"""

        language(self) -> hou.scriptLanguage enum value

            Returns a value representing the language in which the tool script
            is written.

          > >>> t = shelves.tool(\"geometry_sphere\")
          > >>> t.language() == hou.scriptLanguage.Python
          > True

        """
        return _hou.Tool_language(self)

    def setLanguage(self, language: "EnumValue") -> "void":
        r"""

        setLanguage(self, language)

            Sets a new language for the script, where <language> is a value from
            the hou.scriptLanguage module (usually hou.scriptLanguage.Python).

          > t = shelves.tool(\"tool_1\")
          > t.setLanguage(hou.scriptLanguage.Hscript)
          > t.setScript(\"message hello\")

            NOTE
                We highly recommend writing scripts in Python rather than
                Hscript.


        """
        return _hou.Tool_setLanguage(self, language)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> str

            Returns the tool's icon string.


        """
        return _hou.Tool_icon(self)

    def setIcon(self, icon: "char const *") -> "void":
        r"""

        setIcon(self, icon)

            Sets a new icon string for the tool. The string can contain a file
            path or URL pointing to an SVG file or an image file Houdini knows
            how to load. You can use an opdef: path to refer to an icon file
            inside an asset.


        """
        return _hou.Tool_setIcon(self, icon)

    def help(self) -> "std::string":
        r"""

        help(self) -> str

            Returns the tool's help text.


        """
        return _hou.Tool_help(self)

    def setHelp(self, help: "char const *") -> "void":
        r"""

        setHelp(self, help)

            Sets the tool's help text. Houdini will parse this as wiki text and
            display it in the help viewer when the user requests help for this
            tool. To have the help viewer go to a URL instead, use setHelpURL.


        """
        return _hou.Tool_setHelp(self, help)

    def helpURL(self) -> "std::string":
        r"""

        helpURL(self) -> str

            Returns the URL pointing to this tool's help.


        """
        return _hou.Tool_helpURL(self)

    def setHelpURL(self, help_url: "char const *") -> "void":
        r"""

        setHelpURL(self, help_url)

            Sets a URL the help viewer should go to when the user requests help
            for this tool. If this is not empty, Hoduini will open this URL in
            the help viewer instead of parsing and displaying the contents of
            Tool.help().


        """
        return _hou.Tool_setHelpURL(self, help_url)

    def toolMenuCategories(
        self, pane_type: "EnumValue"
    ) -> (
        "std::vector< HOM_NodeTypeCategory *,std::allocator< HOM_NodeTypeCategory * > >"
    ):
        r"""

        toolMenuCategories(self, pane_type) -> tuple of hou.NodeTypeCategory

            Returns the categories specified for the tool.


        """
        return _hou.Tool_toolMenuCategories(self, pane_type)

    def setToolMenuCategories(
        self,
        pane_type: "EnumValue",
        categories: "std::vector< HOM_NodeTypeCategory *,std::allocator< HOM_NodeTypeCategory * > > const &",
    ) -> "void":
        r"""

        setToolMenuCategories(self, pane_type, categories)

            Set the tool categories. The categories are used to further control
            the visibility of the tool. For example, some tools specify Mantra
            or RenderMan as keywords, and they show up in the TAB menu only if
            the specified renderer is configured as active in the preferences
            pane.


        """
        return _hou.Tool_setToolMenuCategories(self, pane_type, categories)

    def toolMenuOpType(self, pane_type: "EnumValue") -> "std::string":
        r"""

        toolMenuOpType(self, pane_type) -> str

            Returns the operator type associated with this tool.


        """
        return _hou.Tool_toolMenuOpType(self, pane_type)

    def setToolMenuOpType(
        self, pane_type: "EnumValue", op_type: "char const *"
    ) -> "void":
        r"""

        setToolMenuOpType(self, pane_type, op_type)

            Sets the operator type to be associated with the tool. The tool will
            show up in the TAB menu only if the operator can be created. For
            example, some operator types are scoped only to a particular parent,
            thus the tool that creates nodes of this type makes sense only
            inside that parent.


        """
        return _hou.Tool_setToolMenuOpType(self, pane_type, op_type)

    def toolMenuLocations(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        toolMenuLocations(self) -> tuple of str

            Returns the submenus of the TAB menu in which the tool is included.


        """
        return _hou.Tool_toolMenuLocations(self)

    def setToolLocations(self, locations: "_StringTuple") -> "void":
        r"""

        setToolLocations(self, locations)

            Sets the description of the places that the tool should show up in
            the UI. Eg, a tool could be configured to be included in the network
            pane's TAB menu but not in the viewport pane's TAB menu.


        """
        return _hou.Tool_setToolLocations(self, locations)

    def keywords(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.Tool_keywords(self)

    def setKeywords(self, keywords: "_StringTuple") -> "void":
        return _hou.Tool_setKeywords(self, keywords)

    def setData(self, *args, **kwargs) -> "void":
        r"""

        setData(self, script='', language=hou.scriptLanguage.Python, icon='',
        help='', help_url='', network_categories=(), viewer_categories=(),
        cop_viewer_categories=(), network_op_type='', viewer_op_type='',
        locations=())

            Convenience method for setting multiple options at once, rather than
            calling multiple set methods. Sets various options on the tool based
            on optional keyword arguments you pass.

          > # Get a tool
          > t = shelves.tool(\"geometry_sphere\")
          > # Set the tool's icon and help URL
          > t.setData(icon=\"SOP_sphere\", help_url=\"tool:sphere\")

        """
        return _hou.Tool_setData(self, *args, **kwargs)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Deletes the tool from Houdini session and removes its definition
            from the file it's stored in.


        """
        return _hou.Tool_destroy(self)


# Register Tool in _hou:
_hou.Tool_swigregister(Tool)


class TopNode(Node):
    r"""

    hou.TopNode

    Represents a task node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_TopNode

    def __repr__(self) -> "std::string":
        return _hou.TopNode___repr__(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns whether this node's bypass flag is on.


        """
        return _hou.TopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turns this node's bypass flag on or off, making this node have no
            effect.


        """
        return _hou.TopNode_bypass(self, on)

    def isDisplayFlagSet(self) -> "bool":
        r"""

        isDisplayFlagSet(self) -> bool

            Returns whether this node's display flag is on.


        """
        return _hou.TopNode_isDisplayFlagSet(self)

    def setDisplayFlag(self, on: "bool") -> "void":
        r"""

        setDisplayFlag(self, on)

            Turn this node's display flag on or off.


        """
        return _hou.TopNode_setDisplayFlag(self, on)

    def isRenderFlagSet(self) -> "bool":
        r"""

        isRenderFlagSet(self) -> bool

            Returns whether this node's render flag is on.


        """
        return _hou.TopNode_isRenderFlagSet(self)

    def setRenderFlag(self, on: "bool") -> "void":
        r"""

        setRenderFlag(self, on)

            Turns this node's render flag on or off.


        """
        return _hou.TopNode_setRenderFlag(self, on)

    def displayNode(self) -> "HOM_Node *":
        r"""

        displayNode(self) -> hou.Node

            If this is a subnet TOP, return the TOP node inside the subnet with
            its display flag on. Otherwise, return None.


        """
        return _hou.TopNode_displayNode(self)

    def renderNode(self) -> "HOM_Node *":
        r"""

        renderNode(self) -> hou.Node

            If this is a subnet TOP, return the TOP node inside the subnet with
            its render flag on. Otherwise, return None.


        """
        return _hou.TopNode_renderNode(self)

    def outputNode(self) -> "HOM_Node *":
        r"""

        outputNode(self) -> hou.Node

            If this is a subnet TOP, returns the first Output node in the
            network. Otherwise, if there are no Output nodes, the display node
            is returned instead.


        """
        return _hou.TopNode_outputNode(self)

    def topParent(self) -> "HOM_Node *":
        return _hou.TopNode_topParent(self)

    def cookWorkItems(self, *args, **kwargs) -> "void":
        r"""

        cookWorkItems(self, block=False, generate_only=False, tops_only=False,
        save_prompt=False, nodes=[])

            Generates and cook work items in the specified TOP nodes. All of the
            nodes must be from the same network. If the nodes list is empty,
            this method will cook the node this TOP node.


            block
                If the block argument is set to True the method will block the
                caller until the cook completes. Otherwise, the cook occurs in
                the background.

            generate_only
                If True work items in the specified nodes will only be generated
                and not cooked. If a node is dynamic, this means that the input
                nodes will be cooked.

            tops_only
                If True, TOP nodes will be cooked and schedulers will be
                initialized. This will create the underlying PDG Nodes and PDG
                Schedulers. No PDG cooking will occur, and no work items will be
                generated.

            save_prompt
                If True, TOPs will display a save prompt if the current scene
                has unsaved changes and any of the nodes in the network require
                access to the .hip file when cooking. If there are no
                modifications to the scene or none of the nodes create work item
                that use the scene file, then the dialog isn't displayed. If
                this method is called from a non-graphical Houdini session,
                passing save_prompt=True will silently save the scene if needed
                without displaying a confirmation dialog.


        """
        return _hou.TopNode_cookWorkItems(self, *args, **kwargs)

    def cookOutputWorkItems(
        self,
        block: "bool" = False,
        generate_only: "bool" = False,
        tops_only: "bool" = False,
        save_prompt: "bool" = False,
    ) -> "void":
        r"""

        cookAllOutputWorkItems(self, include_display_node, block=False,
        generate_only=False, tops_only=False)

            The same as hou.TopNode.cookWorkItems, except it cooks all Output
            nodes in the TOP Network. If include_display_node is True the
            Display node will also be included in the list of nodes that are
            cooked, even if it's not an Output node.


        """
        return _hou.TopNode_cookOutputWorkItems(
            self, block, generate_only, tops_only, save_prompt
        )

    def cookAllOutputWorkItems(
        self,
        include_display_node: "bool",
        block: "bool" = False,
        generate_only: "bool" = False,
        tops_only: "bool" = False,
        save_prompt: "bool" = False,
    ) -> "void":
        return _hou.TopNode_cookAllOutputWorkItems(
            self, include_display_node, block, generate_only, tops_only, save_prompt
        )

    def generateStaticWorkItems(self, block: "bool" = False) -> "void":
        r"""

        generateStaticWorkItems(self, block=False)

            Generates static work items on the PDG graph owned by the TOP
            Network.


            block
                If True, the call will not return until work item generation is
                complete.


        """
        return _hou.TopNode_generateStaticWorkItems(self, block)

    def dirtyAllWorkItems(self, remove_outputs: "bool") -> "void":
        r"""

        dirtyAllWorkItems(self, remove_outputs)

            Deletes all work items in the PDG graph owned by the TOP Network.


            remove_outputs
                If True, then it will also delete all generated file results
                from disk.


        """
        return _hou.TopNode_dirtyAllWorkItems(self, remove_outputs)

    def dirtyWorkItems(self, remove_outputs: "bool") -> "void":
        r"""

        dirtyWorkItems(self, remove_outputs)

            Deletes all work items in this node.


            remove_outputs
                If True, then it will also delete all generated file results
                from disk.


        """
        return _hou.TopNode_dirtyWorkItems(self, remove_outputs)

    def generateStaticItems(self, block: "bool" = False) -> "void":
        r"""

        generateStaticItems(self, block)

            This method is deprecated in favor of
            hou.TopNode.generateStaticWorkItems.


        """
        return _hou.TopNode_generateStaticItems(self, block)

    def dirtyAllTasks(self, remove_outputs: "bool") -> "void":
        r"""

        dirtyAllTasks(self, remove_outputs)

            This method is deprecated in favor of hou.TopNode.dirtyAllWorkItems.


        """
        return _hou.TopNode_dirtyAllTasks(self, remove_outputs)

    def dirtyTasks(self, remove_outputs: "bool") -> "void":
        r"""

        dirtyTasks(self, remove_outputs)

            This method is deprecated in favor of hou.TopNode.dirtyWorkItems.


        """
        return _hou.TopNode_dirtyTasks(self, remove_outputs)

    def executeGraph(
        self,
        filter_static: "bool" = False,
        block: "bool" = False,
        generate_only: "bool" = False,
        tops_only: "bool" = False,
    ) -> "void":
        r"""

        executeGraph(self, filter_static=False, block=False,
        generate_only=False, tops_only=False)

            This method is deprecated in favor of hou.TopNode.cookWorkItems and
            hou.TopNode.cookOutputWorkItems.


        """
        return _hou.TopNode_executeGraph(
            self, filter_static, block, generate_only, tops_only
        )

    def graphCommands(self) -> "std::string":
        r"""

        graphCommands(self) -> str

            Returns a string containing python commands require to construct the
            PDG graph owned by the parent network of this node.


        """
        return _hou.TopNode_graphCommands(self)

    def taskGraphCommands(self) -> "std::string":
        r"""

        taskGraphCommands(self) -> str

            Returns a string containing python commands require to construct the
            PDG task graph owned by the parent network of this node.


        """
        return _hou.TopNode_taskGraphCommands(self)

    def setSelectedWorkItem(self, idx: "int") -> "void":
        r"""

        setSelectedWorkItem(self, idx)

            Sets the selected work item in this TOP Network to be the work item
            with the given ID.


        """
        return _hou.TopNode_setSelectedWorkItem(self, idx)

    def getSelectedWorkItem(self) -> "int":
        r"""

        getSelectedWorkItem(self) -> int

            Returns the ID of the current selected work item in this TOP
            Network.


        """
        return _hou.TopNode_getSelectedWorkItem(self)

    def getWorkItemName(self, idx: "int") -> "std::string":
        r"""

        getWorkItemName(self, idx) -> str

            Returns the name of the work item with the given ID.


        """
        return _hou.TopNode_getWorkItemName(self, idx)

    def getPDGGraphContextName(self) -> "std::string":
        r"""

        getPDGGraphContextName(self) -> str

            Returns a string containing the name of the graph context owned by
            the parent network of this node.

            If the TOP node has not been cooked yet by cookWorkItems() (thus
            generating the underlying PDG), then this method returns None.


        """
        return _hou.TopNode_getPDGGraphContextName(self)

    def getPDGNodeName(self) -> "std::string":
        r"""

        getPDGNodeName(self) -> str

            Returns the name of the PDG node owned by this node.

            If the TOP node has not been cooked yet by cookWorkItems() (thus
            generating the underlying PDG), then this method returns None.


        """
        return _hou.TopNode_getPDGNodeName(self)

    def getPDGNodeId(self) -> "int":
        r"""

        getPDGNodeId(self) -> int

            Returns the id of the PDG node owned by this node.

            If the TOP node has not been cooked yet by cookWorkItems() (thus
            generating the underlying PDG), then this method returns None.


        """
        return _hou.TopNode_getPDGNodeId(self)

    def cancelCook(self) -> "void":
        r"""

        cancelCook(self)

            Cancels the current cook


        """
        return _hou.TopNode_cancelCook(self)

    def pauseCook(self) -> "void":
        r"""

        pauseCook(self)

            Pauses the current cook. This is the same as canceling the cook,
            except any work items that have already been scheduled are allowed
            to continue executing. No new work items will be run until the next
            cook is initiated, and work items that have not yet been scheduled
            will be canceled.


        """
        return _hou.TopNode_pauseCook(self)

    def addPDGFilter(self, idx: "int") -> "void":
        r"""

        isPDGFilter(self, idx) -> bool

            Returns true if the static work item with the given ID is part of
            the filter.


        """
        return _hou.TopNode_addPDGFilter(self, idx)

    def removePDGFilter(self, idx: "int") -> "void":
        return _hou.TopNode_removePDGFilter(self, idx)

    def isPDGFilter(self, idx: "int") -> "bool":
        return _hou.TopNode_isPDGFilter(self, idx)

    def enablePDGFilter(self, filter_on: "bool") -> "void":
        r"""

        enablePDGFilter(self, filter_on)

            Sets the node's TOP network to use the current static task filter.


        """
        return _hou.TopNode_enablePDGFilter(self, filter_on)

    def workItemStates(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        workItemStates(self) -> list of int

            Returns the number of work items in the node that are each of the
            work item states. The values are returned as in a sequence that
            matches the order of the entries in the pdg.workItemState enum. The
            final value in the resulting list is the total number of work items.


        """
        return _hou.TopNode_workItemStates(self)

    def isProcessor(self) -> "bool":
        r"""

        isProcessor(self) -> bool

            Returns true if the TOP node is a processor.


        """
        return _hou.TopNode_isProcessor(self)

    def isPartitioner(self) -> "bool":
        r"""

        isPartitioner(self) -> bool

            Returns true if the TOP node is a partitioner.


        """
        return _hou.TopNode_isPartitioner(self)

    def isMapper(self) -> "bool":
        r"""

        isMapper(self) - > bool

            Returns true if the TOP node is a mapper.


        """
        return _hou.TopNode_isMapper(self)

    def isScheduler(self) -> "bool":
        r"""

        isScheduler(self) - > bool

            Returns true if the TOP node is a scheduler.


        """
        return _hou.TopNode_isScheduler(self)

    def isServiceCompatible(self, service_name: "char const *") -> "bool":
        return _hou.TopNode_isServiceCompatible(self, service_name)

    def isFilterOn(self) -> "bool":
        r"""

        isFilterOn(self) -> bool

            Returns true is this node is currently affected by a work item
            filter set on another node in the network.


        """
        return _hou.TopNode_isFilterOn(self)

    def getFilterNodes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        r"""

        getFilterNodes(self) -> tuple of hou.Node

            Returns a tuple of all nodes whose filters affect the node.


        """
        return _hou.TopNode_getFilterNodes(self)

    def outputDataTypes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        outputDataTypes(self) -> tuple of str

            Returns a tuple of the data types for the output ports of this node.


        """
        return _hou.TopNode_outputDataTypes(self)

    def inputDataTypes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        inputDataTypes(self) -> tuple of str

            Returns a tuple of the data types for the input ports of this node.


        """
        return _hou.TopNode_inputDataTypes(self)

    def getCookState(self, force: "bool") -> "HOM_EnumValue &":
        return _hou.TopNode_getCookState(self, force)

    def getDataLayerInterfaceId(self) -> "int":
        return _hou.TopNode_getDataLayerInterfaceId(self)


# Register TopNode in _hou:
_hou.TopNode_swigregister(TopNode)


class Track(object):
    r"""

    hou.Track

    Each hou.ChopNode contains its data in one or more tracks. A track
    contains a sequence of floating point samples over time. Each track has
    a unique name in its containing CHOP.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Track

    def __repr__(self) -> "std::string":
        return _hou.Track___repr__(self)

    def chopNode(self) -> "HOM_ChopNode *":
        r"""

        chopNode(self) -> hou.ChopNode or None

            Returns the hou.ChopNode owner of this track. This may return None
            if the track belongs to a standalone hou.Clip.


        """
        return _hou.Track_chopNode(self)

    def clip(self) -> "HOM_Clip *":
        r"""

        clip(self) -> hou.Clip

            Returns the clip that this track belongs to.


        """
        return _hou.Track_clip(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of this track (each track in a CHOP has a unique
            name).


        """
        return _hou.Track_name(self)

    def eval(self) -> "double":
        r"""

        eval(self) -> double

            Returns the value of this track at the current time.


        """
        return _hou.Track_eval(self)

    def evalAtTime(self, time: "double") -> "double":
        r"""

        evalAtTime(self, time) -> double

            Returns the value of this track at a given time.


        """
        return _hou.Track_evalAtTime(self, time)

    def evalAtFrame(self, frame: "double") -> "double":
        r"""

        evalAtFrame(self, frame) -> double

            Returns the value of this track at a given frame.


        """
        return _hou.Track_evalAtFrame(self, frame)

    def evalAtSample(self, sample: "double") -> "double":
        r"""

        evalAtSample(self, sample) -> double

            Returns the value of the track at a given sample value.


        """
        return _hou.Track_evalAtSample(self, sample)

    def evalAtTimeRange(
        self, start: "double", end: "double"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        evalAtTimeRange(self, start, end) -> tuple of double

            Returns the sample values of this track between a given start and
            end time.


        """
        return _hou.Track_evalAtTimeRange(self, start, end)

    def evalAtFrameRange(
        self, start: "double", end: "double"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        evalAtFrameRange(self, start, end) -> tuple of double

            Returns the sample values of this track between a given start and
            end frame.


        """
        return _hou.Track_evalAtFrameRange(self, start, end)

    def evalAtSampleRange(
        self, start: "double", end: "double"
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        evalAtSampleRange(self, start, end) -> tuple of double

            Returns the sample values of this track between a given start and
            end sample index.


        """
        return _hou.Track_evalAtSampleRange(self, start, end)

    def numSamples(self) -> "int":
        r"""

        numSamples(self) -> int

            Return the number of samples in this track.


        """
        return _hou.Track_numSamples(self)

    def allSamples(self) -> "std::vector< double,std::allocator< double > >":
        r"""

        allSamples(self) -> tuple of double

            Returns all the sample values in this track.


        """
        return _hou.Track_allSamples(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.Track__asVoidPointer(self)

    def evalAtSampleIndex(self, index: "int") -> "double":
        r"""

        evalAtSampleIndex(self, index) -> double

            This method is deprecated in favor of evalAtSample.


        """
        return _hou.Track_evalAtSampleIndex(self, index)


# Register Track in _hou:
_hou.Track_swigregister(Track)


class ui(object):
    r"""

    hou.ui

    Module containing user interface related functions.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ui

    def __repr__(self) -> "std::string":
        return _hou.ui___repr__(self)

    def shellIO(self) -> "HOM_ShellIO &":
        r"""

        shellIO() -> hou.ShellIO

            Return the hou.ShellIO object used to implement Houdini's graphical
            Python shell. This function is used internally by Houdini, and you
            shouldn't need to access the ShellIO directly.


        """
        return _hou.ui_shellIO(self)

    def curDesktop(self) -> "HOM_Desktop *":
        r"""

        curDesktop() -> hou.Desktop

            Return the current desktop.


        """
        return _hou.ui_curDesktop(self)

    def desktop(self, name: "char const *") -> "HOM_Desktop *":
        r"""

        desktop(name) -> hou.Desktop

            Return the desktop with the specified name. Return None if no such
            desktop exists.


        """
        return _hou.ui_desktop(self, name)

    def desktops(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Desktop >,std::allocator< HOM_ElemPtr< HOM_Desktop > > >":
        r"""

        desktops() -> tuple of hou.Desktop

            Return all the desktops.

            See hou.Desktop.setAsCurrent for an example.


        """
        return _hou.ui_desktops(self)

    def radialMenu(self, name: "std::string const &") -> "HOM_RadialMenu *":
        r"""

        radialMenu(name) -> hou.RadialMenu

            Returns a hou.RadialMenu object representing the named menu, or None
            if the menu does not exist.


        """
        return _hou.ui_radialMenu(self, name)

    def radialMenus(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_RadialMenu >,std::allocator< HOM_ElemPtr< HOM_RadialMenu > > >":
        r"""

        radialMenus() -> tuple of hou.RadialMenu

            Returns a tuple of hou.RadialMenu objects representing existing
            menus.


        """
        return _hou.ui_radialMenus(self)

    def createRadialMenu(
        self, name: "std::string const &", label: "char const *"
    ) -> "HOM_RadialMenu *":
        r"""

        createRadialMenu(name, label) -> hou.RadialMenu

            Creates a new radial menu object with the given name and label.


        """
        return _hou.ui_createRadialMenu(self, name, label)

    def createRadialItem(
        self, submenu: "bool" = False, callback: "bool" = False
    ) -> "HOM_RadialScriptItem *":
        r"""

        createRadialItem(submenu=False, callback=false) -> hou.RadialScriptItem

            Creates a temporary radial menu item.


            submenu
                Whether this item is a submenu or action.

            callback
                Whether this item is uses python callback or script (text).


        """
        return _hou.ui_createRadialItem(self, submenu, callback)

    def injectRadialItem(self, location: "int", item: "RadialItem") -> "void":
        r"""

        injectRadialMenu(name)

            Injects a registered menu and override the current menu.


            name
                The name of the menu.


        """
        return _hou.ui_injectRadialItem(self, location, item)

    def injectRadialMenu(self, name: "std::string const &") -> "void":
        return _hou.ui_injectRadialMenu(self, name)

    def _getActiveRadialMenu(self) -> "std::string":
        return _hou.ui__getActiveRadialMenu(self)

    def _setActiveRadialMenu(self, name: "std::string const &") -> "void":
        return _hou.ui__setActiveRadialMenu(self, name)

    def updateMainMenuBar(self) -> "void":
        r"""

        updateMainMenuBar()

            Forces label expressions to be re-evaluated for the main Houdini
            menu bar. These top level menu items are never automatically
            refreshed, so it is up to the creator of these menus to also install
            handlers that detect when a condition has changed that might affect
            the menu, and call this method to force a refresh.


        """
        return _hou.ui_updateMainMenuBar(self)

    def panes(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Pane >,std::allocator< HOM_ElemPtr< HOM_Pane > > >":
        r"""

        panes(self) -> tuple of hou.Pane

            Return a tuple of all visible panes, including those in all floating
            windows.

            See also hou.Desktop.panes.


        """
        return _hou.ui_panes(self)

    def paneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        paneTabs(self) -> tuple of hou.PaneTab

            Return a tuple of all visible pane tabs, including those in all
            floating windows.

            See also hou.Desktop.paneTabs.


        """
        return _hou.ui_paneTabs(self)

    def currentPaneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        currentPaneTabs(self) -> tuple of hou.PaneTab

            Return a tuple of all visible pane tabs that are selected in their
            containing panes, including those in all floating windows.

            See also hou.Desktop.currentPaneTabs.


        """
        return _hou.ui_currentPaneTabs(self)

    def paneTabOfType(self, type: "EnumValue", index: "int" = 0) -> "HOM_PaneTab *":
        r"""

        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return the pane tab with the desired type. If no such tab
            exists, return None.


            type
                A hou.paneTabType enumerated variable.

            index
                If there are multiple tabs with the desired type, this parameter
                determines which one is returned. Use index=0 to return the
                first found tab, index=1 to return the second found tab, etc. By
                default, index is 0.

            See also hou.Desktop.paneTabOfType.


        """
        return _hou.ui_paneTabOfType(self, type, index)

    def findPane(self, pane_id: "int") -> "HOM_Pane *":
        r"""

        findPane(self, pane_id) -> hou.Pane or None

            Return the pane with the given unique id, or None if no such pane
            exists.

            See also hou.Desktop.findPane.


        """
        return _hou.ui_findPane(self, pane_id)

    def findPaneTab(self, name: "char const *") -> "HOM_PaneTab *":
        r"""

        findPaneTab(self, name) -> hou.PaneTab or None

            Return the pane tab with the given name, or None if no such tab
            exists.

            The name may optionally be prefixed by the desktop name and a
            period.

            See also hou.Desktop.findPaneTab.


        """
        return _hou.ui_findPaneTab(self, name)

    def floatingPaneTabs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_PaneTab >,std::allocator< HOM_ElemPtr< HOM_PaneTab > > >":
        r"""

        floatingPaneTabs(self) -> tuple of hou.PaneTab

            Return all the pane tabs in floating panels.

            See also hou.Desktop.floatingPaneTabs.


        """
        return _hou.ui_floatingPaneTabs(self)

    def floatingPanels(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_FloatingPanel >,std::allocator< HOM_ElemPtr< HOM_FloatingPanel > > >":
        r"""

        floatingPanels(self) -> tuple of hou.FloatingPanel

            Return all the visible floating panels.

            See also hou.Desktop.floatingPanels.


        """
        return _hou.ui_floatingPanels(self)

    def paneUnderCursor(self) -> "HOM_Pane *":
        r"""

        paneUnderCursor(self)

            Return the hou.Pane object located under the mouse cursor. Return
            None if no pane is located under the mouse cursor.

            This method searches all visible panes including panes not attached
            to the current desktop.


        """
        return _hou.ui_paneUnderCursor(self)

    def paneTabUnderCursor(self) -> "HOM_PaneTab *":
        r"""

        paneTabUnderCursor(self)

            Similar to hou.ui.paneUnderCursor but return the hou.PaneTab object
            instead located under the mouse cursor. Return None if no pane tab
            is located under the mouse cursor.

            This method searches all visible pane tabs including pane tabs not
            attached to the current desktop.


        """
        return _hou.ui_paneTabUnderCursor(self)

    def isUserInteracting(self) -> "bool":
        r"""

        isUserInteracting()

            Return True if the user is currently interacting with the UI in a
            way that is likely to cause a stream of node or parameter changes.
            This includes scrubbing the playbar, and dragging a handle in the
            viewport. Testing this value can be useful to avoid performing
            expensive updates to UI components that can wait until the user
            interaction is complete before performing their update.


        """
        return _hou.ui_isUserInteracting(self)

    def setUserInteracting(self, interacting: "bool") -> "void":
        r"""

        setUserInteracting()

            Sets a flag checked by isUserInteracting(). That function will
            return True after setUserInteracting(True) is called, until you call
            setUserInteracting(False) to reset that flag.

            This can be used in python viewer states, or python panels to stop
            certain UI updates during viewport interaction or when using UI
            widgets.

            Set this to True when the interaction starts and False when it
            finishes.


        """
        return _hou.ui_setUserInteracting(self, interacting)

    def orientationUpAxis(self) -> "HOM_EnumValue &":
        r"""

        orientationUpAxis(self) -> hou.orientUpAxis enum value

            Return a hou.orientUpAxis indicating the current orientation mode's
            up axis.


        """
        return _hou.ui_orientationUpAxis(self)

    def handleOrientToNormalAxis(self) -> "HOM_EnumValue &":
        r"""

        handleOrientToNormalAxis(self) -> hou.handleOrientToNormalAxis enum
        value

            Return a hou.handleOrientToNormalAxis indicating the handle axis
            that is to be aligned to component normals when orienting.


        """
        return _hou.ui_handleOrientToNormalAxis(self)

    def displayConfirmation(self, *args, **kwargs) -> "bool":
        return _hou.ui_displayConfirmation(self, *args, **kwargs)

    def displayCustomConfirmation(self, *args, **kwargs) -> "int":
        r"""

        displayCustomConfirmation(text, buttons=(),
        severity=hou.severityType.Message, default_choice=0, close_choice=-1,
        help=None, title=None, details=None, details_label=None,
        suppress=hou.confirmType.OverwriteFile) -> int

            This method is the same as displayConfirmation, except it also
            accepts a list of custom button labels and returns the selected
            button index instead of a boolean value. The button index
            corresponds to the entry in the label array that was selected in the
            pop up dialog. If fewer than two button labels are specified, the
            default labels OK and Cancel will be added as necessary to achieve
            the required length of at least two labels.


            text
                The message to display.

            buttons
                The labels for the buttons that appear in the dialog. If fewer
                than two labels are passed in, OK and Cancel will be added as
                needed. For example, if the method is called with
                buttons=(\"Continue\",) the dialog will display a Continue and
                Cancel button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                escape or closes the dialog.

            help
                Additional help information to display below the main message.

            title
                The window's title. If None, the title is Houdini.

            details
                A string containing extra messages that is not visible unless
                the user clicks Show Details.

            details_label
                A string containing the label for the expand/collapse button
                that controls whether or not the detail text is visible.

          > '''Before cooking the TOP network, prompts the user to either save the .hip
          > file, cook without saving the file, or cancel the cook operation completely.'''
          >
          > def save_and_cook(top_network):
          >     buttons = (\"Save and Continue\", \"Continue Without Saving\", \"Cancel\")
          >     selected_button = hou.ui.displayCustomConfirmation(\"Save before cooking?\", suppress=hou.confirmType.TopCookSave, buttons=buttons)
          >
          >     if selected_button == 0:
          >         hou.hipFile.save()
          >
          >     if selected_button != 2:
          >         top_network.cookWorkItems(block=True)

        """
        return _hou.ui_displayCustomConfirmation(self, *args, **kwargs)

    def displayMessage(self, *args, **kwargs) -> "int":
        r"""

        displayMessage(text, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=-1, help=None, title=None, details=None,
        details_label=None, details_expanded=False) -> int

            Pop up a small window with a message and one or more buttons and
            wait for the user to press a button. Return the index of the button
            the user pressed.


            text
                The message to display.

            buttons
                A sequence of strings containing the names of the buttons. By
                default the message window contains a single OK button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                Escape or closes the dialog.

            help
                Additional help information to display below the main message.

            title
                The window's title. If None, the title is Houdini.

            details
                A string containing extra messages that is not visible unless
                the user clicks Show Details.

            details_label
                A string containing the label for the expand/collapse button
                that controls whether or not the detail text is visible. If
                details_expanded is set to true this parameter has no effect.

            details_expanded
                A boolean, if true then the text area where the detail messages
                appear is always shown and cannot be collapsed. If false, the
                detail message area is initially folded when the message box is
                popped up and the user can expand to read the details.

          > def saveIfNeeded():
          >         '''Prompt the user if they want to save, and save the hip file if they choose Yes.'''
          >         if hou.ui.displayMessage(\"Save the current hip file?\", buttons=(\"Yes\", \"No\")) == 0:
          >             hou.hipFile.save()

        """
        return _hou.ui_displayMessage(self, *args, **kwargs)

    def readInput(self, *args, **kwargs) -> "std::pair< int,std::string >":
        r"""

        readInput(message, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=-1, help=None, title=None,
        initial_contents=None) -> (int, str)

            Pop up a small window with a textbox and wait for the user to enter
            a line of text. Return a tuple containing an integer and the text
            they entered. The integer is the index of the pressed button. If
            close_choice is not None and the user closed the dialog by clicking
            on its close button or by pressing Escape, then the returned integer
            is set to close_choice.


            message
                The message to display above the text field.

            buttons
                A sequence of strings containing the names of the buttons. By
                default the message window contains a single OK button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                Escape or clicks on the dialog's close button. If there is more
                than one button and close_choice is -1, then the user cannot
                close the dialog with Escape or the dialog's close button. If
                there is only one button and close_choice is -1, then the user
                can close the dialog with Escape or the dialog's close button,
                and the button's index is returned.

            help
                Additional help information to display below the main message.

            title
                The window's title. If None, the title is Houdini.

            initial_contents
                The initial contents of the text field. If None, the text field
                is initially empty.

            See also hou.ui.readMultiInput


        """
        return _hou.ui_readInput(self, *args, **kwargs)

    def readMultiInput(
        self, *args, **kwargs
    ) -> "std::pair< int,std::vector< std::string,std::allocator< std::string > > >":
        r"""

        readMultiInput(message, input_labels, password_input_indices=(),
        buttons=('OK',), severity=hou.severityType.Message, default_choice=0,
        close_choice=-1, help=None, title=None, initial_contents=(\"\",)) -> (int,
        tuple of str)

            Pop up a small window with a textbox and wait for the user to enter
            a text into several input fields. Return a tuple containing an
            integer and the tuple of strings they entered, one for each input
            field. The integer is the index of the pressed button. If
            close_choice is not -1 and the user closed the dialog by clicking on
            its close button or by pressing Escape, then the returned integer is
            set to close_choice.


            message
                The message to display above the text field.

            input_labels
                A sequence of labels to appear in front of each input field. The
                length of the sequence determines the number of input fields
                that will appear in the window.

            password_input_indices
                A sequence of indices of which input fields are password fields.
                Fields whose index is not in this sequence will not be password
                fields.

            buttons
                A sequence of strings containing the names of the buttons. By
                default the message window contains a single OK button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                Escape or clicks the dialog's close button. If there is more
                than one button and close_choice is -1, then the user cannot
                close the dialog with Escape or the dialog's close button. If
                there is only one button and close_choice is -1, then the user
                can close the dialog with Escape or the dialog's close button,
                and the button's index is returned.

            help
                Additional help information to display below the main message.

            title
                The window's title. If this is None, the title is \"Houdini\".

            initial_contents
                A sequence of strings specifying the initial value of each text
                box specified by the input_labels argument. If this sequence is
                shorter than input_labels, the rest of the fields are left
                blank. The default is to start with all fields blank.

            The initial_contents values must be strings. If you use another type
            (for example, integers), the function will raise a TypeError. If you
            want to prompt the user for integers, convert the initial values
            into strings, and convert the results back into integers. For
            example:

          > start_int, end_int = hou.playbar.frameRange()
          > button_idx, values = hou.ui.readMultiInput(
          >     \"Set the new frame range\", (\"Start Frame\", \"End Frame\"),
          >     initial_contents=(str(start_int), str(end_int)),
          >     title=\"Frame Range\",
          >     buttons=(\"OK\", \"Cancel\"),
          >     default_choice=0, close_choice=1,
          > )
          > new_start_int = int(values[0])
          > new_end_int = int(values[1])

            See also hou.ui.readInput


        """
        return _hou.ui_readMultiInput(self, *args, **kwargs)

    def selectFromList(
        self, *args, **kwargs
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        selectFromList(choices, default_choices=(), exclusive=False,
        message=None, title=None, column_header=\"Choices\", num_visible_rows=10,
        clear_on_cancel=False, width=0, height=0) -> tuple of int

            Pop up a window with a set of choices in a list box and prompt the
            user to choose zero or more of them. If selection is accepted then
            the list of selected row indices are returned. If selection is
            canceled then the initial selection (default choices) is returned.


            choices
                A sequence of strings containing the possible choices.

            default_choices
                A sequence of integers containing the indices of the choices
                that are initially selected.

            exclusive
                Whether or not the user must choose exactly one of the possible
                choices.

            message
                The message to display above the list box.

            title
                The window's title. If None, the title is Houdini.

            column_header
                The column header for the list of choices. Users can click this
                header label to sort the list. If None, then the header is
                removed. Note that the tuple of integers represents the original
                order of items, regardless of the displayed sort order.

            num_visible_rows
                The number of rows of entries that are visible at a time. If
                there are more possible choices than visible rows, Houdini will
                use a scrollbar.

            clear_on_cancel
                If set to True then an empty tuple is returned when selection is
                canceled. Otherwise the initial selection (default_choices) is
                returned when selection is canceled.

            width
                The chooser dialog's width. If 0, then the chooser dialog uses a
                default width.

            height
                The chooser dialog's height. If 0, then the chooser dialog uses
                a default height.


        """
        return _hou.ui_selectFromList(self, *args, **kwargs)

    def selectFromTree(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectFromTree(choices, picked=(), exclusive=False, message=None,
        title=None, clear_on_cancel=False, width=0, height=0) -> tuple of str

            Pop up a window with a set of choices in a tree chooser and prompt
            the user to choose zero or more of them. The choices are arranged
            into a tree using a forward slash as a path separator. If selection
            is accepted then the list of selected paths are returned. If
            selection is canceled then the initial selection (picked) is
            returned.


            choices
                A sequence of strings containing the possible choices.

            picked
                A sequence of strings containing the items that should be
                initially selected.

            exclusive
                Whether or not the user must choose exactly one of the possible
                choices.

            message
                The message to display above the list box.

            title
                The window's title. If None, the title is Make Selection.

            clear_on_cancel
                If set to True then an empty tuple is returned when selection is
                canceled. Otherwise the initial selection (picked) is returned
                when selection is canceled.

            width
                The chooser dialog's width. If 0, then the chooser dialog uses a
                default width.

            height
                The chooser dialog's height. If 0, then the chooser dialog uses
                a default height.


        """
        return _hou.ui_selectFromTree(self, *args, **kwargs)

    def _selectFile(self, *args, **kwargs) -> "std::string":
        return _hou.ui__selectFile(self, *args, **kwargs)

    def selectParmTag(
        self, width: "int" = 0, height: "int" = 0
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectParmTag(width=0, height=0) -> tuple of str

            Pop up a window with a tree view of recognized parameter tags and
            prompt the user to choose a tag. Parameter tags are metadata that
            can be attached to a parameter template with
            hou.ParmTemplate.setTags and queried with hou.ParmTemplate.tags.

            Tags listed in the window are recognized by Houdini. For example,
            choosing the GL Diffuse tag and assigning it to a parameter template
            causes the viewport to recognize the parameter as the diffuse color.

            This method returns a 2-tuple where the first element is the
            selected tag name and the second element is the selected tag value.
            If no tag is selected or if the selection operation is canceled,
            then a 2-tuple of empty strings is returned.


            width
                The chooser dialog's width. If 0, then the chooser dialog uses a
                default width.

            height
                The chooser dialog's height. If 0, then the chooser dialog uses
                a default height.


        """
        return _hou.ui_selectParmTag(self, width, height)

    def selectParm(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectParm(category=None, bound_parms_only=False, relative_to_node=None,
        message=None, title=None, initial_parms=(), multiple_select=True,
        width=0, height=0) -> tuple of str

            Pop up a window with a parameter tree view and prompts the user to
            select parameters, populated initially with initial_parms. If
            selection is accepted then a list of selected parameter paths are
            returned. If selection is canceled then the initial selection
            (initial parameters) is returned.

            category: A hou.NodeTypeCategory if filtering by node type,
            otherwise None if all parameters should be shown

            bound_parms_only: True if the dialog should only display parameters
            that are bound to a default handle. False is all parameters should
            be shown.

            relative_to_node: A hou.Node that you want the selected parameters
            paths to be relative to.

            message: The message to display in the dialog.

            title: The title of the dialog.

            multiple_select: Whether the user may select multiple parameters.

            width: The chooser dialog's width. If 0, then the chooser dialog
            uses a default width.

            height: The chooser dialog's height. If 0, then the chooser dialog
            uses a default height.


        """
        return _hou.ui_selectParm(self, *args, **kwargs)

    def selectParmTuple(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectParmTuple(category=None, bound_parms_only=False,
        relative_to_node=None, message=None, title=None, initial_parm_tuples=(),
        multiple_select=True, width=0, height=0) -> tuple of str

            Pop up a window with a parameter tree view and prompts the user to
            select parameter tuples, populated initially with
            initial_parm_tuples.

            See hou.ui.selectParm for documentation on the arguments.


        """
        return _hou.ui_selectParmTuple(self, *args, **kwargs)

    def selectColor(self, initial_color: "Color" = None) -> "HOM_Color *":
        r"""

        selectColor(initial_color=None) -> hou.Color or None

            Pop up a window with a color chooser, and waits for the user to
            choose a color and hit the OK or Cancel button. If the user hits the
            OK button, this method returns the color chosen in the dialog. If
            the user hits Cancel, this method returns None.

            The initial_color parameter specifies a hou.Color that will appear
            in the dialog when it first opens. If not set, the initial color
            will be white.


        """
        return _hou.ui_selectColor(self, initial_color)

    def _openColorEditor(
        self,
        color_changed_callback: "void *",
        include_alpha: "bool" = False,
        initial_color: "Color" = None,
        initial_alpha: "float" = 1.0,
    ) -> "void":
        return _hou.ui__openColorEditor(
            self, color_changed_callback, include_alpha, initial_color, initial_alpha
        )

    def loadPaletteFile(
        self, file: "char const *"
    ) -> "std::vector< HOM_Color,std::allocator< HOM_Color > >":
        r"""

        loadPaletteFile(self, file) -> tuple of hou.Color

            Load a palette file and return the colors listed in the palette. The
            file parameter can be a full path, or just a file name. In the
            latter case, the Houdini path is searched for the first instance of
            the named file under the config subdirectory.


        """
        return _hou.ui_loadPaletteFile(self, file)

    def savePaletteFile(
        self,
        file: "char const *",
        colors: "std::vector< HOM_Color,std::allocator< HOM_Color > > const &",
    ) -> "void":
        r"""

        savePaletteFile(self, file, colors)

            Save a palette file with the contents of the colors parameter, a
            tuple of hou.Color objects. The file parameter must be a full path
            to the file where the palette should be saved.

            Raises hou.OperationFailed if the file could not be written.


        """
        return _hou.ui_savePaletteFile(self, file, colors)

    def updateValueLadder(
        self, cursor_x: "int", cursor_y: "int", alt_key: "bool", shift_key: "bool"
    ) -> "void":
        r"""

        updateValueLadder(cursor_x, cursor_y, alt_key, shift_key)

            Updates the value in the currently opened ladder value window based
            on the given cursor position and boolean arguments.

            This function only works if hou.ui.openValueLadder was previously
            called. Raises hou.OperationFailed if no value ladder window is
            currently open.


            cursor_x
                The horizontal coordinate of the current mouse cursor position.

            cursor_y
                The vertical coordinate of the current mouse cursor position.

            alt_key
                Whether the [Alt] modifier key is currently held. This scales
                the ladder value.

            shift_key
                Whether the [Shift] modifier key is currently held. This changes
                the ladder's active level.

            See hou.ui.openValueLadder for more information.


        """
        return _hou.ui_updateValueLadder(self, cursor_x, cursor_y, alt_key, shift_key)

    def closeValueLadder(self) -> "void":
        r"""

        closeValueLadder()

            Closes the current value ladder window that was open by a previous
            call to hou.ui.openValueLadder.

            Raises hou.OperationFailed if no value ladder window is open.

            See hou.ui.openValueLadder for more information.


        """
        return _hou.ui_closeValueLadder(self)

    def displayFileDependencyDialog(
        self, *args, **kwargs
    ) -> "UT_Tuple< bool,std::vector< std::pair< HOM_ElemPtr< HOM_Parm >,std::string >,std::allocator< std::pair< HOM_ElemPtr< HOM_Parm >,std::string > > > >":
        r"""

        displayFileDependencyDialog(rop_node=None, uploaded_files=(),
        forced_unselected_patterns=(), project_dir_variable='HIP',
        is_standalone=true) -> (bool, tuple of Parm and string tuples)

            Open a dialog displaying the file dependencies in the current .hip
            file.

            Return a 2-tuple where the first element in the tuple is True if the
            dialog was closed with the OK button and False otherwise, and the
            second element is a tuple of the selected file patterns. Each
            selected file pattern is represented as a <hou.Parm, string> pair
            which stores the source parameter that contains the file pattern and
            the file pattern itself.


            NOTE
                If the source parameter is not None then it is recommended that
                file pattern expansion be performed by evaluating the
                parameter's value instead of calling hou.expandString.
                Evaluating the source parameter is far more accurate since it
                accounts for channel references and context-specific variables
                like $OS.


        """
        return _hou.ui_displayFileDependencyDialog(self, *args, **kwargs)

    def displayNodeHelp(self, node_type: "NodeType") -> "void":
        r"""

        displayNodeHelp(node_type)

            Display the help for the specified node type. If no help browser is
            open, this function will create a new one.

            If you want to display the help for a node instance, it is easy to
            access the hou.NodeType from the node, as illustrated in this
            example:

          > def displayHelpForNode(node):
          > '''Given a hou.Node, display its help.'''
          > hou.ui.displayNodeHelp(node.type())

        """
        return _hou.ui_displayNodeHelp(self, node_type)

    def _openTypePropertiesDialogForNode(
        self, node: "Node", promote_spare_parms: "bool", immediately_save: "bool"
    ) -> "void":
        return _hou.ui__openTypePropertiesDialogForNode(
            self, node, promote_spare_parms, immediately_save
        )

    def _openTypePropertiesDialogForNodeType(
        self,
        node_type: "NodeType",
        promote_spare_parms: "bool",
        immediately_save: "bool",
    ) -> "void":
        return _hou.ui__openTypePropertiesDialogForNodeType(
            self, node_type, promote_spare_parms, immediately_save
        )

    def openRenderDialog(self, rop: "RopNode") -> "void":
        r"""

        openRenderDialog(rop_node)

            Given a hou.RopNode instance, open the render control dialog for the
            node. This dialog can be used to override certain render parameters,
            and launch a render.


        """
        return _hou.ui_openRenderDialog(self, rop)

    def openRenameSelectedDialog(self, network: "Node") -> "void":
        r"""

        openRenameSelectedDialog(node)

            Given a hou.Node which contains other nodes, open a dialog for
            renaming all selected children of the node. The dialog uses pattern
            matching to rename all the selected nodes in one operation.


        """
        return _hou.ui_openRenameSelectedDialog(self, network)

    def openParameterInterfaceDialog(
        self,
        node: "Node",
        open_tab: "EnumValue" = None,
        open_tab_tree_path: "char const *" = None,
    ) -> "void":
        r"""

        openParameterInterfaceDialog(node, open_tab = None, open_tab_tree_path =
        '')

            Given a hou.Node, open the parameter interface editor dialog. This
            dialog is can be used to add or remove spare parameters, or
            rearrange the parameter layout for a node.


            open_tab
                A hou.parameterInterfaceTabType enum value that causes the
                dialog to appear with a particular parameter source tab
                displayed.

            open_tab_tree_path
                If an open_tab is specified, this parameter can further control
                the state of the dialog when it opens. This string can specify a
                full path to a branch in the tree of the open tab which will be
                expanded and set as current.


        """
        return _hou.ui_openParameterInterfaceDialog(
            self, node, open_tab, open_tab_tree_path
        )

    def updateMode(self) -> "HOM_EnumValue &":
        r"""

        updateMode() -> hou.updateMode enum value

            This method is deprecated in favor of hou.updateModeSetting.


        """
        return _hou.ui_updateMode(self)

    def setUpdateMode(self, mode: "EnumValue") -> "void":
        r"""

        setUpdateMode(mode)

            This method is deprecated in favor of hou.setUpdateMode.


        """
        return _hou.ui_setUpdateMode(self, mode)

    def triggerUpdate(self) -> "void":
        r"""

        reloadViewportColorSchemes()

            Reloads all 3DSceneColors configuration files (in
            $HFS/houdini/config). You must cause the viewport to redraw (for
            example, by tumbling) to see the new colors.

            This function may be useful if you are implementing a new color
            scheme: you can map to a hotkey or call it in the Python console so
            you can check your changes.


        """
        return _hou.ui_triggerUpdate(self)

    def reloadViewportColorSchemes(self) -> "void":
        return _hou.ui_reloadViewportColorSchemes(self)

    def isAutoKey(self) -> "bool":
        r"""

        isAutoKey() -> bool`

            Returns if auto-key is currently enabled (changing an animated
            parameter will create a key at the current frame if it doesn't
            exist).


        """
        return _hou.ui_isAutoKey(self)

    def _getTabMenuIconSize(self) -> "std::vector< int,std::allocator< int > >":
        return _hou.ui__getTabMenuIconSize(self)

    def removeAllSelectionCallbacks(self) -> "void":
        r"""

        removeAllSelectionCallbacks()

            Remove all Python callbacks previously registered with
            hou.ui.addSelectionCallback. See hou.ui.addSelectionCallback for
            more information.


        """
        return _hou.ui_removeAllSelectionCallbacks(self)

    def createDialog(self, ui_file_name: "char const *") -> "HOM_Dialog *":
        r"""

        createDialog(ui_file_name) -> hou.Dialog

            Parse the given .ui file and return the dialog defined in the file.

            The dialog must be written with Houdini's User Interface Script
            Language. An overview of the language can be found in the Houdini
            Development Kit (HDK) documentation, specifically in the Houdini
            User Interface -> The .ui Script Language section.

            ui_file_name is the basename of the .ui file. The file must be
            located in a directory registered with the HOUDINI_UI_APP_PATH
            search path. For a list of HOUDINI_UI_APP_PATH search directories,
            run hconfig -ap from a terminal.

            Raises hou.OperationFailed if the .ui file contains errors and the
            dialog could not be created. Raises TypeError if ui_file_name is
            None.


        """
        return _hou.ui_createDialog(self, ui_file_name)

    def findDialog(self, ui_file_name: "char const *") -> "HOM_Dialog *":
        r"""

        findDialog(ui_file_name) -> hou.Dialog

            Return the dialog defined by the given .ui file name and created by
            hou.ui.createDialog.

            Return None if no dialog has been created with hou.ui.createDialog
            for the specified .ui file.

            Raises TypeError if ui_file_name is None.


        """
        return _hou.ui_findDialog(self, ui_file_name)

    def dialogs(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Dialog >,std::allocator< HOM_ElemPtr< HOM_Dialog > > >":
        r"""

        dialogs() -> tuple of hou.Dialog

            Return all dialogs created by hou.ui.createDialog.


        """
        return _hou.ui_dialogs(self)

    def writePythonShellHistoryFile(self, filename: "char const *" = None) -> "void":
        r"""

        writePythonShellHistoryFile(filename=None)

            Save the command history from the current Python Shell to disk. If
            filename is None, then the history is written to
            $HOME/houdiniX.Y/pyshell.history. If this function is invoked
            outside of a Python Shell, then the history is taken from the last
            active shell (i.e. the last shell that was opened or accepted
            input).

            Raises hou.OperationFailed if no Python Shell has been opened.
            Raises hou.OperationFailed if filename cannot be created.


        """
        return _hou.ui_writePythonShellHistoryFile(self, filename)

    def readPythonShellHistoryFile(self, filename: "char const *" = None) -> "void":
        r"""

        readPythonShellHistoryFile(filename=None)

            Load the contents from the specified file into the command history
            of the Python Shell. If filename is None, then the history is read
            from $HOME/houdiniX.Y/pyshell.history. If this function is invoked
            outside of a Python Shell, then the history is loaded into the the
            last active shell (i.e. the last shell that was opened or accepted
            input).

            Raises hou.OperationFailed if no Python Shell has been opened.
            Raises hou.OperationFailed if filename does not exist or cannot be
            read.


        """
        return _hou.ui_readPythonShellHistoryFile(self, filename)

    def setStatusMessage(self, *args, **kwargs) -> "void":
        r"""

        setStatusMessage(message, severity=hou.severityType.Message)

            Display a message in Houdini's status bar.


            severity
                A hou.severityType enum value that determines the background
                color of the message.

            To clear the status bar, call hou.ui.setStatusMessage(\"\").


        """
        return _hou.ui_setStatusMessage(self, *args, **kwargs)

    def statusMessage(self) -> "std::pair< std::string,HOM_EnumValue * >":
        r"""

        statusMessage() -> (string, hou.severityType)

            Return the current message and severity from the status bar. This
            may not match the value most recently passed to setStatusMessage
            because Houdini itself often changes the message in the status bar.


        """
        return _hou.ui_statusMessage(self)

    def _processEvents(self) -> "bool":
        return _hou.ui__processEvents(self)

    def openAssetUploadDialog(
        self,
        uploading_node: "Node",
        session_key: "char const *",
        containing_node: "Node",
    ) -> "void":
        return _hou.ui_openAssetUploadDialog(
            self, uploading_node, session_key, containing_node
        )

    def openAssetDependenciesDialog(
        self,
        uploading_nodes: "_NodeTuple",
        uploaded_nodes: "_NodeTuple",
        session_key: "char const *",
        containing_node: "Node",
    ) -> "void":
        return _hou.ui_openAssetDependenciesDialog(
            self, uploading_nodes, uploaded_nodes, session_key, containing_node
        )

    def hasDragSourceData(self, label: "char const *") -> "bool":
        r"""

        getDragSourceData(label, index) -> data

            Query the current drag source to obtain the dragged data. Returns
            None when the specified data in unavailable (or unsupported by HOM).

            Raises hou.NotAvailable if no drag operation is currently active.


            label
                Specifies the type of the source event to query. See
                hou.ui.hasDragSourceData for the label types to use.

            index
                Index of the data in the source. Defaults to 0.


        """
        return _hou.ui_hasDragSourceData(self, label)

    def getDragSourceData(
        self, label: "char const *", index: "int" = 0
    ) -> "HOM_DDSourceAny":
        return _hou.ui_getDragSourceData(self, label, index)

    def resourceValueFromName(self, name: "char const *") -> "std::string":
        r"""

        resourceValueFromName(self, name) -> str

            Return a string value from a symbolic resource name. The resource
            name should correspond to one of the entries in the $HH/config/*.hcs
            file for the currently selected color scheme.

            Raises: hou.ValueError if the provided symbolic name doesn't exist.


        """
        return _hou.ui_resourceValueFromName(self, name)

    def colorFromName(self, name: "char const *") -> "HOM_Color":
        r"""

        colorFromName(self, name) -> hou.Color

            Return a color value from a symbolic color name. The color name
            should correspond to one of the entries in the $HH/config/*.hcs file
            for the currently selected color scheme.

            Raises: hou.ValueError if the provided symbolic name doesn't exist.

            For example:

          > >>> hou.ui.colorFromName(\"DisplayOnColor\")
          > <hou.Color r=0.3, g=0.5, b=1>

            TIP
                You can use hou.qt.getColor to get a Qt color object instead of
                a HOM color object.


        """
        return _hou.ui_colorFromName(self, name)

    def globalScaleFactor(self) -> "double":
        r"""

        globalScaleFactor(self) -> float

            Return the scale factor that is set by Houdini's Global UI Size
            preference. For example, this function returns 1.0 when Houdini is
            set to the Normal UI size.

            The scale factor can be used to scale components in a PySide or PyQt
            built UI where hou.ui.scaledSize cannot be called. For example, the
            scale factor can be used to set the zoom factor of a QWebEngineView
            object so that the web contents match the Global UI Size:

          > web_view = QWebEngineWidgets.QWebEngineView()
          > web_view.setZoomFactor(hou.ui.globalScaleFactor())

        """
        return _hou.ui_globalScaleFactor(self)

    def scaledSize(self, size: "int") -> "int":
        r"""

        scaledSize(self, size) -> int

            Scale the specified size by the global UI scale factor and return
            the scaled size. The scale factor is determined by Houdini's Global
            UI Size preference. For example, the factor is 1.0 when Houdini is
            set to the Normal UI size.

            This function is useful for scaling hard-coded sizes in PySide or
            PyQt code. Here is an example of using scaled sizes when setting a
            widget to a fixed size that is 640x480 with the Normal UI size:

          > widget = QtWidgets.QWidget()
          > widget.resize(hou.ui.scaledSize(640), hou.ui.scaledSize(480))

            Here is another example of creating a scaled icon using the
            hou.qt.createIcon function:

          > icon = hou.qt.createIcon(hou.ui.scaledSize(32), hou.ui.scaledSize(32))

        """
        return _hou.ui_scaledSize(self, size)

    def inchesToPixels(self, inches: "double") -> "double":
        r"""

        inchesToPixels(self, inches) -> float

            Return the supplied inches argument, expressing a distance on the
            screen, converted to a number of pixels. This calculation combines
            the number of dots per inch reported by the operating system, the
            Global UI Size setting accessible from Edit > Preferences > General
            User Interface, and the HOUDINI_UISCALE environment variable, if it
            has been set. As such, this value may not be accurate, but is
            consistent with the way the rest of Houdini converts distances from
            inches to pixels.


        """
        return _hou.ui_inchesToPixels(self, inches)

    def pixelsToInches(self, pixels: "double") -> "double":
        r"""

        pixelsToInches(self, pixels) -> float

            Return the supplied pixels argument, expressing a number of pixels
            on the screen, converted to a distance in inches. This calculation
            combines the number of dots per inch reported by the operating
            system, the Global UI Size setting accessible from Edit >
            Preferences > General User Interface, and the HOUDINI_UISCALE
            environment variable, if it has been set. As such, this value may
            not be accurate, but is consistent with the way the rest of Houdini
            converts distances from pixels to inches.


        """
        return _hou.ui_pixelsToInches(self, pixels)

    def copyTextToClipboard(self, text: "char const *") -> "void":
        r"""

        copyTextToClipboard(self, text)

            Sets the supplied text into the system clipboard.


        """
        return _hou.ui_copyTextToClipboard(self, text)

    def getTextFromClipboard(self) -> "std::string":
        r"""

        getTextFromClipboard(self) -> str

            Returns any text currently copied into the system clipboard. If the
            clipboard is empty or contains non-text data, an empty string is
            returned.


        """
        return _hou.ui_getTextFromClipboard(self)

    def hotkeys(
        self, hotkey_symbol: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        hotkeys(self, hotkey_symbol) -> tuple of str

            Return a tuple of strings that represent the hotkeys currently
            assigned to the action associated with the hotkey symbol. The hotkey
            symbols can be found in the $HH/config/Hotkeys directory.

            Raises: hou.ValueError if the provided hotkey symbol doesn't exist.

            For example:

          > >>> hou.ui.hotkeys(\"h.copy\")
          > ('Alt+C', 'Ctrl+C')
          > >>> hou.ui.hotkeys(\"h.pane.copytab\")
          > ('Ctrl+T',)

        """
        return _hou.ui_hotkeys(self, hotkey_symbol)

    def hotkeyDescription(self, hotkey_symbol: "char const *") -> "std::string":
        r"""

        hotkeyDescription(self, hotkey_symbol) -> str

            Return a string that contains a description of the action associated
            with the hotkey symbol. The hotkey symbols can be found in the
            $HH/config/Hotkeys directory.

            Raises: hou.ValueError if the provided hotkey symbol doesn't exist.

            For example:

          > >>> hou.ui.hotkeyDescription(\"h.pane.copytab\")
          > 'Copy Tab'

        """
        return _hou.ui_hotkeyDescription(self, hotkey_symbol)

    def isKeyMatch(self, key: "char const *", hotkey_symbol: "char const *") -> "bool":
        r"""

        isKeyMatch(self, key, hotkey_symbol) -> bool

            Return True if the key described by the string key matches one of
            the hotkeys assigned to the provided hotkey symbol. The hotkey
            symbols can be found in the $HH/config/Hotkeys directory.

            Raises: hou.ValueError if the provided hotkey symbol doesn't exist,
            or the key string doesn't represent a valid hotkey.

            For example:

          > >>> hou.ui.isKeyMatch(\"Ctrl+C\", \"h.copy\")
          > True
          > >>> hou.ui.isKeyMatch(\"Ctrl+C\", \"h.pane.copytab\")
          > False

        """
        return _hou.ui_isKeyMatch(self, key, hotkey_symbol)

    def _geoSpreadsheetCellText(
        self, sheet_id: "int", row: "int", col: "int"
    ) -> "std::string":
        return _hou.ui__geoSpreadsheetCellText(self, sheet_id, row, col)

    def openCaptureWeightSpreadsheet(
        self, node: "Node", pattern: "char const *" = None
    ) -> "void":
        r"""

        openCaptureWeightSpreadsheet(node, pattern=None)

            Given an instance of a hou.SopNode that is a captureoverride type,
            open the edit capture weight spreadsheet for the node. If a string
            is passed for pattern, then only the points specified by the pattern
            will be shown, otherwise all the points for the node will be
            displayed in the spreadsheet.


        """
        return _hou.ui_openCaptureWeightSpreadsheet(self, node, pattern)

    def _openCaptureWeightSpreadsheet2(self, node: "Node") -> "std::string":
        return _hou.ui__openCaptureWeightSpreadsheet2(self, node)

    def _closeCaptureWeightSpreadsheet(
        self, identifier: "std::string const &"
    ) -> "void":
        return _hou.ui__closeCaptureWeightSpreadsheet(self, identifier)

    def registerViewerState(self, vs_templ: "ViewerStateTemplate") -> "void":
        r"""

        registerViewerState(template)

            Registers a hou.ViewerStateTemplate object representing a custom
            viewer state. See installing viewer states for how to use this
            function.


            template
                The hou.ViewerStateTemplate object.

            Raises hou.NameConflict if the registration fails because a state
            with the same name is already registered. Raises hou.OperationFailed
            if the registration fails (for example, the state to register has no
            factory).


        """
        return _hou.ui_registerViewerState(self, vs_templ)

    def registerViewerStateFile(self, state_file: "std::string const &") -> "void":
        r"""

        registerViewerStateFile(file_path)

            Registers a viewer state type implemented in a given python file.
            Any viewer state previously registered by this file will be
            unregistered first.

            See installing viewer states for more details about python state
            files.


            file_path
                A full path to the python file containing the viewer state.

            Raises hou.OperationFailed if the registration fails (for example,
            the state to register has no factory).


        """
        return _hou.ui_registerViewerStateFile(self, state_file)

    def registerViewerStates(self) -> "void":
        r"""

        registerViewerStates()

            Scans the viewer state folders ($HH/viewer_states and
            $HOUDINI_USER_PREF_DIR/viewer_states) to register all viewer states
            they both contain. Viewer states already registered in Houdini are
            simply updated with the version on disk.


        """
        return _hou.ui_registerViewerStates(self)

    def unregisterViewerState(self, state_typename: "std::string const &") -> "void":
        r"""

        unregisterViewerState(state_name)

            Unregisters an existing viewer state type.

            See installing viewer states for how to use this function.


            state_name
                The name of the state to unregister.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no state with the given name is registered).


        """
        return _hou.ui_unregisterViewerState(self, state_typename)

    def unregisterViewerStateFile(self, state_file: "std::string const &") -> "void":
        r"""

        unregisterViewerStateFile(file_path)

            Unregisters a viewer state previously registered with a given python
            file. See installing viewer states for more details about python
            state files.


            file_path
                A full path to the python file referring to a viewer state.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no state was registered with this file).


        """
        return _hou.ui_unregisterViewerStateFile(self, state_file)

    def isRegisteredViewerState(self, state_name: "std::string const &") -> "bool":
        r"""

        isRegisteredViewerState(state_name) -> bool

            Returns True if state_name has previously been registered with
            hou.ui.registerViewerState. Returns False if not.


            state_name
                The name of the state to validate.


        """
        return _hou.ui_isRegisteredViewerState(self, state_name)

    def reloadViewerState(self, state_typename: "std::string const &") -> "void":
        r"""

        reloadViewerStates(state_names=None)

            Reload multiple viewer states as specified in the state_names array.
            If the array is empty, all registered self-installed states in
            Houdini are reloaded. See hou.ui.reloadViewerState for more details
            on reloading a state.


            state_names
                Array of state names to reload. Empty by default.

            Raises hou.OperationFailed if the reload fails (for example, if no
            state with a given name is registered).


        """
        return _hou.ui_reloadViewerState(self, state_typename)

    def reloadViewerStates(self, *args, **kwargs) -> "void":
        return _hou.ui_reloadViewerStates(self, *args, **kwargs)

    def viewerStateInfo(self, *args, **kwargs) -> "std::string":
        r"""

        viewerStateInfo(state_names) -> str

            Return a JSON dictionary string describing all registered viewer
            states keyed by state type.


            state_names
                Array of state names to process. If the array is empty
                (default), all viewer states currently registered are processed.

          > import json
          >
          > info_str = hou.ui.viewerStateInfo([\"sidefx_stroke\"])
          > info_dict = json.loads(info_str)
          > info = json.dumps(info_dict[\"sidefx_stroke\"], indent=3)
          > print(info)
          >
          > {
          >    \"Type\": \"sidefx_stroke\",
          >    \"Label\": \"Stroke\",
          >    \"Icon\": \"$HFS/houdini/pic/minimizedicon.pic\",
          >    \"Category\": \"Sop\",
          >    \"Source\": \"$HFS/houdini/viewer_states/sidefx_stroke.py\",
          >    \"Contexts\": [
          >       \"SOP\"
          >    ],
          >    \"Handles\": {},
          >    \"Gadgets\": {},
          >    \"Selectors\": {
          >       \"sidefx_default_selector\": {
          >          \"Name\": \"sidefx_default_selector\",
          >          \"Auto start\": false,
          >          \"Hotkey\": {
          >             \"Path\": \"\",
          >             \"Label\": \"\",
          >             \"Description\": \"\",
          >             \"Keys\": []
          >          },
          >          \"Secure selection\": \"obey\",
          >          \"Prompt\": \"default geometry selector\",
          >          \"Allow drag\": false,
          >          \"Quick select\": true,
          >          \"Use existing selection\": true,
          >          \"Initial selection\": \"\",
          >          \"Initial selection type\": \"\",
          >          \"Ordered\": false,
          >          \"Geometry types\": [],
          >          \"Allow other sops\": true
          >       }
          >    },
          >    \"Menus\": {
          >       \"Stroke\": {
          >          \"Type\": \"Menu\",
          >          \"Handle\": \"stroke_menu\",
          >          \"Draw realtime\": {
          >             \"Type\": \"Toggle\",
          >             \"Handle\": \"realtime_mode\",
          >             \"Hotkey\": {
          >                \"Path\": \"h.pane.gview.state.sop.sidefx_stroke.realtime_mode\",
          >                \"Label\": \"realtime\",
          >                \"Description\": \"Enable realtime mode\",
          >                \"Keys\": [
          >                   48
          >                ]
          >             }
          >          },
          >          \"Brush settings...\": {
          >             \"Type\": \"Menu\",
          >             \"Handle\": \"brush_menu\",
          >             \"Cycle brushes\": {
          >                \"Type\": \"Action\",
          >                \"Handle\": \"cycle_brushes\",
          >                \"Hotkey\": {
          >                   \"Path\": \"h.pane.gview.state.sop.sidefx_stroke.cycle_brushes\",
          >                   \"Label\": \"Cycle brushes\",
          >                   \"Description\": \"Cycle stroke tools\",
          >                   \"Keys\": [
          >                      49
          >                   ]
          >                }
          >             },
          >             \"Brush display mode\": {
          >                \"Type\": \"Radio strip\",
          >                \"Handle\": \"brush_display_mode\",
          >                \"Default\": \"brush_viewport_display\",
          >                \"Wireframe\": {
          >                   \"Type\": \"Radio strip item\",
          >                   \"Handle\": \"brush_wireframe_display\",
          >                   \"Hotkey\": {
          >                      \"Path\": \"h.pane.gview.state.sop.sidefx_stroke.set_wireframe_brush\",
          >                      \"Label\": \"Set wireframe brush\",
          >                      \"Description\": \"Set wireframe brush\",
          >                      \"Keys\": [
          >                         50
          >                      ]
          >                   }
          >                },
          >                \"Viewport\": {
          >                   \"Type\": \"Radio strip item\",
          >                   \"Handle\": \"brush_viewport_display\",
          >                   \"Hotkey\": {
          >                      \"Path\": \"h.pane.gview.state.sop.sidefx_stroke.set_viewport_brush\",
          >                      \"Label\": \"Set viewport brush\",
          >                      \"Description\": \"Set viewport brush\",
          >                      \"Keys\": [
          >                         51
          >                      ]
          >                   }
          >                }
          >             }
          >          }
          >       }
          >    }
          > }

        """
        return _hou.ui_viewerStateInfo(self, *args, **kwargs)

    def viewerStateInfoFromFile(
        self, state_file: "std::string const &"
    ) -> "UT_Tuple< std::string,std::string >":
        r"""

        viewerStateInfoFromFile(state_filepath) -> (str, str)

            Returns the viewer state information for a given python state file.
            The information is returned as a tuple containing the python state
            type name and a JSON dictionary string describing the registered
            viewer state information.


            state_filepath
                A python state file path. The method returns an empty tuple if
                the file path is not a python state file or the python state
                contained in the file is not registered.


            NOTE
                This method doesn't work with HDA python state files.

          > import json
          >
          > (state_type, info_str) = hou.ui.viewerStateInfoFromFile(
          >     \"$HFS/packages/viewer_state_demo/viewer_states/drawable_selector_sop.py\"
          > )
          > info_dict = json.loads(info_str)
          > info = json.dumps(info_dict[state_type], indent=3)
          > print(info)
          >
          > {
          >    \"Type\": \"drawable_selector_sop\",
          >    \"Label\": \"State Drawable Selector Demo\",
          >    \"Icon\": \"DESKTOP_application_mac\",
          >    \"Category\": \"Sop\",
          >    \"Source\": \"$HFS/packages/viewer_state_demo/viewer_states/drawable_selector_sop.py\",
          >    \"Contexts\": [
          >       \"SOP\"
          >    ],
          >    \"Handles\": {},
          >    \"Gadgets\": {},
          >    \"Selectors\": {
          >       \"drawable_selector\": {
          >          \"Name\": \"drawable_selector\",
          >          \"Auto start\": true,
          >          \"Hotkey\": {
          >             \"Path\": \"h.pane.gview.state.sop.drawable_selector_sop.drawable selector\",
          >             \"Label\": \"drawable selector\",
          >             \"Description\": \"drawable selector\",
          >             \"Keys\": [
          >                49
          >             ]
          >          },
          >          \"Secure selection\": \"ignore\",
          >          \"Prompt\": \"Select a drawable component\",
          >          \"Allow drag\": false,
          >          \"Quick select\": true,
          >          \"Use existing selection\": true,
          >          \"Initial selection\": \"\",
          >          \"Initial selection type\": \"\",
          >          \"Ordered\": false,
          >          \"Geometry types\": [
          >             \"point\",
          >             \"edge\",
          >             \"prim\"
          >          ],
          >          \"Allow other sops\": false
          >       },
          >       \"primitive_selector\": {
          >          \"Name\": \"primitive_selector\",
          >          \"Auto start\": false,
          >          \"Hotkey\": {
          >             \"Path\": \"h.pane.gview.state.sop.drawable_selector_sop.primitive selector\",
          >             \"Label\": \"primitive selector\",
          >             \"Description\": \"primitive selector\",
          >             \"Keys\": [
          >                50
          >             ]
          >          },
          >          \"Secure selection\": \"ignore\",
          >          \"Prompt\": \"Select a primitive component\",
          >          \"Allow drag\": true,
          >          \"Quick select\": true,
          >          \"Use existing selection\": true,
          >          \"Initial selection\": \"\",
          >          \"Initial selection type\": \"\",
          >          \"Ordered\": false,
          >          \"Geometry types\": [
          >             \"prim\"
          >          ],
          >          \"Allow other sops\": false
          >       },
          >       \"sidefx_default_selector\": {
          >          \"Name\": \"sidefx_default_selector\",
          >          \"Auto start\": false,
          >          \"Hotkey\": {
          >             \"Path\": \"\",
          >             \"Label\": \"\",
          >             \"Description\": \"\",
          >             \"Keys\": []
          >          },
          >          \"Secure selection\": \"obey\",
          >          \"Prompt\": \"default geometry selector\",
          >          \"Allow drag\": false,
          >          \"Quick select\": true,
          >          \"Use existing selection\": true,
          >          \"Initial selection\": \"\",
          >          \"Initial selection type\": \"\",
          >          \"Ordered\": false,
          >          \"Geometry types\": [],
          >          \"Allow other sops\": true
          >       }
          >    },
          >    \"Menus\": {
          >       \"Drawable Selector Demo\": {
          >          \"Type\": \"Menu\",
          >          \"Handle\": \"drawable_selector_menu\",
          >          \"Log Info\": {
          >             \"Type\": \"Toggle\",
          >             \"Handle\": \"log_info\",
          >             \"Hotkey\": {
          >                \"Path\": \"\",
          >                \"Label\": \"\",
          >                \"Description\": \"\",
          >                \"Keys\": []
          >             }
          >          },
          >          \"Clear Console\": {
          >             \"Type\": \"Action\",
          >             \"Handle\": \"clear_console\",
          >             \"Hotkey\": {
          >                \"Path\": \"\",
          >                \"Label\": \"\",
          >                \"Description\": \"\",
          >                \"Keys\": []
          >             }
          >          }
          >       }
          >    }
          > }

        """
        return _hou.ui_viewerStateInfoFromFile(self, state_file)

    def viewerHandleInfo(self, *args, **kwargs) -> "std::string":
        r"""

        viewerHandleInfo(handle_names) -> string

            Return a JSON dictionary string describing all registered viewer
            handles in Houdini. The viewer handles can be queried by type name.


            handle_names
                Array of handle type names. The function returns a dictionary
                containing all registered handles specified in the array. If the
                array is empty (default), all registered viewer handles are
                returned.

          >     >>> import ast
          >     >>> viewer_handles = ast.literal_eval(hou.ui.viewerHandleInfo())
          >     >>> viewer_handles[\"move_tool_handle\"]
          > {
          >    \"Gadgets\":{
          >       \"zdisc\":{
          >          \"Drawable\":\"Line\",
          >          \"Name\":\"zdisc\",
          >          \"Label\":\"Z\"
          >       },
          >       \"yscale\":{
          >          \"Drawable\":\"Face\",
          >          \"Name\":\"yscale\",
          >          \"Label\":\"Y\"
          >       },
          >       \"yaxis\":{
          >          \"Drawable\":\"Line\",
          >          \"Name\":\"yaxis\",
          >          \"Label\":\"Y\"
          >       },
          >       \"zscale\":{
          >          \"Drawable\":\"Face\",
          >          \"Name\":\"zscale\",
          >          \"Label\":\"Z\"
          >       },
          >       \"zaxis\":{
          >          \"Drawable\":\"Line\",
          >          \"Name\":\"zaxis\",
          >          \"Label\":\"Z\"
          >       },
          >       \"xaxis\":{
          >          \"Drawable\":\"Line\",
          >          \"Name\":\"xaxis\",
          >          \"Label\":\"X\"
          >       },
          >       \"xscale\":{
          >          \"Drawable\":\"Face\",
          >          \"Name\":\"xscale\",
          >          \"Label\":\"X\"
          >       },
          >       \"pivot\":{
          >          \"Drawable\":\"Face\",
          >          \"Name\":\"pivot\",
          >          \"Label\":\"XYZ\"
          >       },
          >       \"xdisc\":{
          >          \"Drawable\":\"Line\",
          >          \"Name\":\"xdisc\",
          >          \"Label\":\"X\"
          >       },
          >       \"ydisc\":{
          >          \"Drawable\":\"Line\",
          >          \"Name\":\"ydisc\",
          >          \"Label\":\"Y\"
          >       }
          >    },
          >    \"Parameters\":{
          >       \"Sz\":{
          >          \"Default\":1,
          >          \"Range\":\"(0.1, 10)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"sz\",
          >          \"Label\":\"Sz\"
          >       },
          >       \"Sy\":{
          >          \"Default\":1,
          >          \"Range\":\"(0.1, 10)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"sy\",
          >          \"Label\":\"Sy\"
          >       },
          >       \"Sx\":{
          >          \"Default\":1,
          >          \"Range\":\"(0.1, 10)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"sx\",
          >          \"Label\":\"Sx\"
          >       },
          >       \"Tz\":{
          >          \"Default\":0,
          >          \"Range\":\"(-10, 10)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"tz\",
          >          \"Label\":\"Tz\"
          >       },
          >       \"Tx\":{
          >          \"Default\":0,
          >          \"Range\":\"(-10, 10)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"tx\",
          >          \"Label\":\"Tx\"
          >       },
          >       \"Ty\":{
          >          \"Default\":0,
          >          \"Range\":\"(-10, 10)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"ty\",
          >          \"Label\":\"Ty\"
          >       },
          >       \"Rx\":{
          >          \"Default\":0,
          >          \"Range\":\"(0, 360)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"rx\",
          >          \"Label\":\"Rx\"
          >       },
          >       \"Ry\":{
          >          \"Default\":0,
          >          \"Range\":\"(0, 360)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"ry\",
          >          \"Label\":\"Ry\"
          >       },
          >       \"Rz\":{
          >          \"Default\":0,
          >          \"Range\":\"(0, 360)\",
          >          \"Type\":\"Float\",
          >          \"Name\":\"rz\",
          >          \"Label\":\"Rz\"
          >       }
          >    },
          >    \"Settings\":{
          >       \"\":{
          >          \"Type\":\"Separator\",
          >          \"Name\":\"separator0\",
          >          \"Label\":\"\"
          >       },
          >       \"Drag Along Plane\":{
          >          \"Default\":\"XZ\",
          >          \"Menu Items\":[
          >             \"(XZ, XZ)\",
          >             \"(XY, XY)\",
          >             \"(ZY, ZY)\",
          >             \"(XYZ, XYZ)\"
          >          ],
          >          \"Type\":\"Menu\",
          >          \"Name\":\"planes\",
          >          \"Label\":\"Drag Along Plane\"
          >       },
          >       \"Draw dimension lines\":{
          >          \"Default\":1,
          >          \"Type\":\"Toggle\",
          >          \"Name\":\"dimensions\",
          >          \"Label\":\"Draw dimension lines\"
          >       }
          >    },
          >    \"Menus\":{
          >       \"Move Tool Handle\":{
          >          \"Cycle Gadgets\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   89
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.cycle\",
          >                \"Description\":\"cycle\",
          >                \"Label\":\"cycle\"
          >             },
          >             \"Handle\":\"cycle\",
          >             \"Type\":\"Action\"
          >          },
          >          \"Handle\":\"move_tool_handle_menu\",
          >          \"Trace\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   51
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.trace_handle\",
          >                \"Description\":\"Enable handle trace\",
          >                \"Label\":\"Trace\"
          >             },
          >             \"Handle\":\"trace_handle\",
          >             \"Type\":\"Toggle\"
          >          },
          >          \"Edit\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   53
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.edit_handle\",
          >                \"Description\":\"Edit Handle\",
          >                \"Label\":\"Edit\"
          >             },
          >             \"Handle\":\"edit_handle\",
          >             \"Type\":\"Action\"
          >          },
          >          \"XYZ\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   65
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.XYZ\",
          >                \"Description\":\"XYZ\",
          >                \"Label\":\"XYZ\"
          >             },
          >             \"Handle\":\"XYZ\",
          >             \"Type\":\"Action\"
          >          },
          >          \"Inspect\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   50
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.inspect_handle\",
          >                \"Description\":\"Inspect Handle\",
          >                \"Label\":\"Inspect\"
          >             },
          >             \"Handle\":\"inspect_handle\",
          >             \"Type\":\"Action\"
          >          },
          >          \"XZ\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   70
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.XZ\",
          >                \"Description\":\"XZ\",
          >                \"Label\":\"XZ\"
          >             },
          >             \"Handle\":\"XZ\",
          >             \"Type\":\"Action\"
          >          },
          >          \"Reload\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   54
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.reload_handle\",
          >                \"Description\":\"Reload Handle\",
          >                \"Label\":\"Reload\"
          >             },
          >             \"Handle\":\"reload_handle\",
          >             \"Type\":\"Action\"
          >          },
          >          \"XY\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   71
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.XY\",
          >                \"Description\":\"XY\",
          >                \"Label\":\"XY\"
          >             },
          >             \"Handle\":\"XY\",
          >             \"Type\":\"Action\"
          >          },
          >          \"ZY\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   66
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.ZY\",
          >                \"Description\":\"ZY\",
          >                \"Label\":\"ZY\"
          >             },
          >             \"Handle\":\"ZY\",
          >             \"Type\":\"Action\"
          >          },
          >          \"Clear console\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   49
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.clear_console\",
          >                \"Description\":\"Clear console\",
          >                \"Label\":\"Clear\"
          >             },
          >             \"Handle\":\"clear_console\",
          >             \"Type\":\"Action\"
          >          },
          >          \"Marker\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   52
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.add_marker\",
          >                \"Description\":\"Add Marker\",
          >                \"Label\":\"Marker\"
          >             },
          >             \"Handle\":\"add_marker\",
          >             \"Type\":\"Action\"
          >          },
          >          \"Logging\":{
          >             \"Hotkey\":{
          >                \"Keys\":[
          >                   48
          >                ],
          >                \"Path\":\"h.pane.gview.handle.move_tool_handle.console_logging\",
          >                \"Description\":\"Enable or disable console logging\",
          >                \"Label\":\"Logging\"
          >             },
          >             \"Handle\":\"console_logging\",
          >             \"Type\":\"Toggle\"
          >          },
          >          \"Type\":\"Menu\"
          >       }
          >    },
          >    \"Label\":\"Move Tool Handle\",
          >    \"Exported Parameters\":[
          >       \"tx\",
          >       \"ty\",
          >       \"tz\",
          >       \"rx\",
          >       \"ry\",
          >       \"rz\",
          >       \"sx\",
          >       \"sy\",
          >       \"sz\"
          >    ],
          >    \"Source\":\"C:/Users/marcb/DEV/HOUDINI/dev/hfs/packages/viewer_handle_demo/viewer_handles/move_tool_handle.py\",
          >    \"Type\":\"move_tool_handle\",
          >    \"Categories\":[
          >       \"Sop\"
          >    ],
          >    \"Icon\":\"$HFS/houdini/pic/Mandril.pic\"
          > }

        """
        return _hou.ui_viewerHandleInfo(self, *args, **kwargs)

    def printResourceMessage(self, *args, **kwargs) -> "void":
        r"""

        printResourceMessage(resource_type, message,
        message_type=hou.severityType.Message)

            Print a user message in the message window of a Viewer State Browser
            or Viewer Handle Browser. The
            hou.resourceEventMessage.OnPrintMessage event is sent when calling
            this function.


            resource_type
                A resource type to choose the browser console. Use
                hou.resourceType.ViewerState to print messages in the Viewer
                State Browser or hou.resourceType.ViewerHandle for the Viewer
                Handle Browser.

            message
                String message to print.

            message_type
                Type of message to print. Fatal and Important types are ignored
                and default to Message.


        """
        return _hou.ui_printResourceMessage(self, *args, **kwargs)

    def fireResourceCustomEvent(
        self,
        resource_type: "EnumValue",
        user_data: "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > const &",
        queue: "bool" = True,
    ) -> "void":
        r"""

        fireResourceCustomEvent(resource_type, user_data, queue=True)

            This function triggers a custom resource event which can be used for
            implementing specific workflows. Client callbacks registered with
            hou.ui.addResourceEventCallback will get notified with the input
            user_data argument. The event can be processed immediately or later
            when Houdini is idle, see the queue argument for details.


            resource_type
                The event resource type.

            user_data
                A dictionary mapping user-defined entries to values of type int,
                double, bool and string. An exception is raised if user_data is
                empty or contains unsupported value types.


                fireResourceCustomEvent will add the following entries to the
                dictionary
                    resource_type: The resource_type argument value. event_type:
                    OnCustomEvent event type.

            queue
                If True (default), the event is put on a queue and processed
                when Houdini is idle. If False, the event is processed
                immediately.

            Here's how a custom event can be used.

          >
          > # Register a callback for viewer state events
          > hou.ui.addResourceEventCallback(myEventHandler)
          >
          > def myEventHandler(**kwargs):
          >     import json
          >     if kwargs['event_type'] == hou.resourceEventMessage.OnCustomEvent:
          >         if 'load_file' in kwargs:
          >             # load a json file and store results
          >             with open(kwargs['load_file']) as file:
          >                 json_values = json.load(file)
          >         elif 'save_file' in kwargs:
          >             # save json_values to a json file
          >             with open(kwargs['save_file'], 'w') as file:
          >                 json.dump(json_values, file, indent=3)
          >
          >     # process other non-custom viewer state events
          >     elif kwargs['event_type'] == hou.resourceEventMessage.OnEnter:
          >         pass
          >
          > ...
          > # load a json file via a custom event
          > hou.ui.fireResourceCustomEvent( hou.resourceType.ViewerState, { 'load_file': '/var/tmp/somefile.json'} )

        """
        return _hou.ui_fireResourceCustomEvent(self, resource_type, user_data, queue)

    def showInFileBrowser(self, file_path: "char const *") -> "void":
        r"""

        showInFileBrowser(file_path)

            Launch the system's file browser, navigating to the parent directory
            of the specified file and selecting it.


            file_path
                A string representing the full path to the file (or directory)
                to select.


                TIP
                    If you do not want any file selected, simply ensure the
                    filepath ends with a /.

                Examples:

              > # Launch the browser in /home/me/myDocs and select doc1.txt
              > hou.ui.showInFileBrowser('/home/me/myDocs/doc1.txt')
              >
              > # Launch the browser in /home/me/myDocs and select nothing
              > hou.ui.showInFileBrowser('/home/me/myDocs/')
              >
              > # Launch the browser in /home/me and select myDocs
              > hou.ui.showInFileBrowser('/home/me/myDocs')

        """
        return _hou.ui_showInFileBrowser(self, file_path)

    def showFloatingParameterEditor(
        self, node: "Node", reuse: "bool" = True
    ) -> "HOM_ParameterEditor *":
        return _hou.ui_showFloatingParameterEditor(self, node, reuse)

    def openParameterExpressionEditor(self, parm: "Parm") -> "void":
        r"""

        openParameterExpressionEditor(parm)

            Open the expression editor to edit the expression of the given
            parameter.


            parm
                hou.Parm The parm whose expression to edit.


        """
        return _hou.ui_openParameterExpressionEditor(self, parm)

    def openPreferences(self, page: "char const *", label: "char const *") -> "void":
        r"""

        openPreferences(page)

            Open the preferences dialog and show the given page.


            page
                A string that specifies the preference page to open. When there
                are tabs under the page, page:tab notation is used.

                The following values are supported:

                ui

                General User Interface

                network

                Network Editor

                viewport

                3D Viewports

                shelves

                Shelf Tools and Tab Menu

                takes

                Takes

                anim

                Animation

                lighting

                Lighting

                rendering

                Rendering

                handles

                Handles

                states

                Interactive Tools

                objsops

                Objects and Geometry

                objsops:preferences

                Objects and Geometry > Preferences

                objsops:sop_cache

                Objects and Geometry > SOP Cache

                objsops:obj_cache

                Objects and Geometry > OBJ Cache

                chops

                Motion and Audio

                composites

                Compositing

                composites:cache

                Compositing > Cache

                composites:cooking

                Compositing > Cooking

                composites:interactive

                Compositing > Interactive

                composites:selectors

                Compositing > Selectors

                composites:names

                Compositing > Names

                composites:colors

                Compositing > Colors

                composites:cineon

                Compositing > Cineon

                scripting

                Scripting

                resmgr

                Desktops and Toolbars

                persistence

                Save and Load Options

                hipoptions

                Hip File Options

                warnings

                Warning Dialogs

                notifications

                Notifications

                perfmon

                Performance Options

                exttools

                External Tools

                misc

                Miscellaneous


        """
        return _hou.ui_openPreferences(self, page, label)

    def hideAllMinimizedStowbars(self) -> "bool":
        r"""

        hideAllMinimizedStowbars(self) -> bool

            Return the value of a global flag that hides all the minimized
            stowbars and split panes.


        """
        return _hou.ui_hideAllMinimizedStowbars(self)

    def setHideAllMinimizedStowbars(self, hide: "bool") -> "void":
        r"""

        setHideAllMinimizedStowbars(self,on) -> bool

            Set the value of a global flag that hides all the minimized stowbars
            and split panes. When the flag is on, the minimized stowbars of all
            pane tabs ,menus , the shelf dock or toolbars will be hidden. It
            also affect the split bars of split panes, in which case, the split
            is rendered using a single pixel line.


        """
        return _hou.ui_setHideAllMinimizedStowbars(self, hide)

    def registerViewerHandle(self, tmpl: "ViewerHandleTemplate") -> "void":
        r"""

        registerViewerHandle(template)

            Registers a hou.ViewerHandleTemplate object representing a custom
            viewer handle. See installing viewer handle for how to use this
            function.


            template
                The hou.ViewerHandleTemplate object.

            Raises these exceptions if the registration fails:

          * hou.NameConflict if a handle with the same name is already
            registered.

          * hou.OperationFailed if the registration fails (for example, the
            handle to register has no factory).


        """
        return _hou.ui_registerViewerHandle(self, tmpl)

    def registerViewerHandles(self) -> "void":
        r"""

        registerViewerHandles()

            Scans the viewer handle folders (e.g. $HH/viewer_handles and
            $HOUDINI_USER_PREF_DIR/viewer_handles) to register all viewer
            handles they both contain. Viewer handles already registered in
            Houdini are simply updated with the version on disk.


        """
        return _hou.ui_registerViewerHandles(self)

    def registerViewerHandleFile(self, handle_file: "std::string const &") -> "void":
        r"""

        registerViewerHandleFile(handle_file)

            Registers a viewer handle type implemented in a given python file.
            Any viewer handle previously registered by this file will be
            unregistered first.

            See installing viewer handles for more details about python handle
            files.


            file_path
                A full path to the python file containing the viewer handle
                implementation.

            Raises hou.OperationFailed if the registration fails (for example,
            the handle to register has no factory).


        """
        return _hou.ui_registerViewerHandleFile(self, handle_file)

    def unregisterViewerHandle(self, handle_name: "std::string const &") -> "void":
        r"""

        unregisterViewerHandle(handle_name)

            Unregisters an existing viewer handle type.

            See installing viewer handles for how to use this function.


            handle_name
                The name of the handle to unregister.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no handle with the given name is registered).


        """
        return _hou.ui_unregisterViewerHandle(self, handle_name)

    def unregisterViewerHandleFile(self, handle_file: "std::string const &") -> "void":
        r"""

        unregisterViewerHandleFile(handle_file)

            Unregisters a viewer handle previously registered with a given
            python file. See installing viewer handles for more details about
            python handle files.


            file_path
                A full path to the python file referring to a viewer handle.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no handle was registered with this file).


        """
        return _hou.ui_unregisterViewerHandleFile(self, handle_file)

    def isRegisteredViewerHandle(self, handle_name: "std::string const &") -> "bool":
        r"""

        isRegisteredViewerHandle(handle_name) -> bool

            Returns True if handle_name has previously been registered with
            hou.ui.registerViewerHandle. Returns False if not.


            handle_name
                The type name of the viewer handle to validate.


        """
        return _hou.ui_isRegisteredViewerHandle(self, handle_name)

    def reloadViewerHandle(self, handle_name: "std::string const &") -> "void":
        r"""

        reloadViewerHandle(handle_name)

            Update a registered viewer handle by reloading its python module
            file from a viewer_handle folder. See installing handles in Houdini
            for more details.


            WARNING
                If you get an error message about a registration problem during
                a reload like the following,

                Error registering 'my_handle': factory not specified or invalid.

                Houdini will make its best to keep the broken viewer handle in
                the Viewer Handle Browser for editing the file. If not, the
                handle will be removed from Houdini and you will be forced to
                quit Houdini to fix the problem.


            handle_name
                The type name of the handle to reload.

            Raises hou.OperationFailed if the reload fails (for example, if no
            state with the given name is registered).


        """
        return _hou.ui_reloadViewerHandle(self, handle_name)

    def loadPackage(self, package_filepath: "std::string const &") -> "void":
        r"""

        loadPackage(file_path)

            Packages are normally loaded on startup by Houdini, this API loads
            packages at runtime. loadPackage is typically used for loading
            resource files installed in a plugin folder. A plugin package file
            would typically set HOUDINI_PATH with the folder path containing the
            resource files. loadPackage will load and install the resources
            found in HOUDINI_PATH.


            file_path
                A full file path pointing to the package file to load.

            The following resource types are supported. The resource files must
            be installed in a subfolder as specified in this table:

            Desktops
            desktop

            Contains .desk file(s).

            Digital assets
            otls

            Contains HDA files along with OPlibraries files.

            Python modules
            python2.7libs python3.7libs

            Contains .py files. You are responsible to provide the python
            modules in the right platform folder. The system python path will be
            updated with the folder path.

            Python panels
            python_panels

            Contains .pypanel file(s).

            Shelf tools
            toolbar

            Contains .shelf file(s). The shelf tools are loaded but not active
            in a shelf set.

            Viewer states
            viewer_states

            Contains python states implementation files.

            Viewer handles
            viewer_handles

            Contains python handles implementation files.

            The following shows how to setup a plugin package folder by using
            the viewer handle demo package as example.

            The package file adds the folder path to HOUDINI_PATH:

          > > cat $HFS/houdini/viewer_handles/viewer_handle_demo.json
          > {
          >     \"path\" : \"$HFS/packages/viewer_handle_demo\"
          > }

            The viewer handle demo folder layout:

          > $HFS/packages/viewer_handle_demo/
          >     python2.7libs/
          >         move_tool_demo/
          >             utils.py
          >     scenes/
          >         move_tool_demo.hip
          >         viewer_handle_demo.hip
          >     toolbar/
          >         viewer_handle_demo.shelf
          >     viewer_handles/
          >         move_tool_handle.py
          >         viewer_handle_intro1.py
          >         viewer_handle_intro2.py
          >         viewer_handle_intro3.py

        """
        return _hou.ui_loadPackage(self, package_filepath)

    def loadPackageArchive(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        loadPackageArchive(file_path, extract_path=None) -> list of string

            Extracts the content of a package archive file on disk and load the
            embedded packages. A package archive can be used to install multiple
            plugins in the user folder (default) or optionally in a folder of
            your choice. An exception is raised if the archive installation
            directory is read-only. The loaded package paths are returned in a
            list.


            NOTE
              * The package files must be added at the root level of the
                archive, do not put package files in a packages folder.

              * The resource files must be added in the archive subfolders as
                documented in hou.ui.loadPackage.

              * File or folder links are not permitted.

              * By default Houdini installs the archive in
                $HOUDINI_USER_PREF_DIR under a sub-folder with the name of the
                archive file. For instance, myarchive.zip would be installed in
                $HOUDINI_USER_PREF_DIR/myarchive.

              * The supported archive format is ZIP, other formats may be added
                in the future.


            file_path
                A file path pointing to a package archive file.

            extract_path
                Optional folder path to extract the files.


        """
        return _hou.ui_loadPackageArchive(self, *args, **kwargs)

    def unloadPackage(self, package_filepath: "std::string const &") -> "void":
        r"""

        unloadPackage(file_path)

            Unloads (or removes) the resources previously loaded.


            file_path
                A full file path pointing to the package file to unload.


        """
        return _hou.ui_unloadPackage(self, package_filepath)

    def reloadPackage(self, package_filepath: "std::string const &") -> "void":
        r"""

        reloadPackage(file_path)

            Update a package previously loaded. The package is first unloaded to
            uninstall the current resources and loaded back.


            file_path
                A full file path pointing to the package file to reload.


        """
        return _hou.ui_reloadPackage(self, package_filepath)

    def packageInfo(self, *args) -> "std::string":
        r"""

        packageInfo(file_paths) -> string

            Return a JSON dictionary string describing one or multiple package
            plugins previously loaded in Houdini.


            file_paths
                Array of package file paths. If the array is empty (default),
                all packages currently loaded are added to the dictionary.

            This shows the content of the viewer handle demo package.

          > >>> import json
          > >>> print( json.loads(hou.ui.packageInfo()) )
          > {
          >     'viewer_handle_demo': {
          >         'File path': '$HFS/houdini/viewer_handles/viewer_handle_demo.json',
          >         'Load only once': False,
          >         'Name': 'viewer_handle_demo',
          >         'Resources': {
          >             'Shelf': [
          >                 '$HFS/packages/viewer_handle_demo/toolbar/viewer_handle_demo.shelf'],
          >             'Viewer Handle': [
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/move_tool_handle.py',
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/viewer_handle_intro1.py',
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/viewer_handle_intro2.py',
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/viewer_handle_intro3.py']
          >         },
          >         'Variables': {
          >             'HOUDINI_PATH': [
          >                 '$HFS/packages/viewer_handle_demo']
          >          }
          >     }
          > }

        """
        return _hou.ui_packageInfo(self, *args)

    def sharedLayoutDataSource(self) -> "HOM_AssetGalleryDataSource *":
        r"""

        sharedLayoutDataSource(self) -> hou.AssetGalleryDataSource

            Return the hou.AssetGalleryDataSource object that is currently being
            used to populate the asset gallery browsers in all Layout LOP nodes.


        """
        return _hou.ui_sharedLayoutDataSource(self)

    def setSharedLayoutDataSource(
        self, data_source: "AssetGalleryDataSource"
    ) -> "void":
        r"""

        setSharedLayoutDataSource(self, datasource)

            Set the hou.AssetGalleryDataSource object that should be used to
            populate the asset gallery browsers in all Layout LOP nodes.


        """
        return _hou.ui_setSharedLayoutDataSource(self, data_source)

    def reloadSharedLayoutDataSource(self) -> "void":
        r"""

        reloadSharedLayoutDataSource(self)

            Forces all Layout LOP asset gallery browsers to reload from the
            underlying shared hou.AssetGalleryDataSource. Call this method after
            manipulating the data source returned by
            hou.ui.sharedLayoutDataSource() to refresh the layout asset
            browsers.


        """
        return _hou.ui_reloadSharedLayoutDataSource(self)

    def _selectNodeData(
        self, *args, **kwargs
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.ui__selectNodeData(self, *args, **kwargs)

    def _selectNode(
        self,
        relative_to_node: "Node" = None,
        initial_node: "Node" = None,
        node_type_filter: "EnumValue" = None,
        title: "char const *" = None,
        width: "int" = 0,
        height: "int" = 0,
        multiple_select: "bool" = False,
        custom_node_filter_callback: "InterpreterObject" = None,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.ui__selectNode(
            self,
            relative_to_node,
            initial_node,
            node_type_filter,
            title,
            width,
            height,
            multiple_select,
            custom_node_filter_callback,
        )

    def selectMultipleNodes(
        self,
        relative_to_node: "Node" = None,
        initial_node: "Node" = None,
        node_type_filter: "EnumValue" = None,
        title: "char const *" = None,
        width: "int" = 0,
        height: "int" = 0,
        custom_node_filter_callback: "InterpreterObject" = None,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        selectMultipleNodes(relative_to_node=None, initial_node=None,
        node_type_filter=None, title=None, width=0, height=0,
        custom_node_filter_callback=None) -> tuple of str or None

            This method is deprecated in favor of hou.ui.selectNode. Same
            behavior as selectNode however if the user holds 'Ctrl' they can
            select multiple nodes which are returned as a list of paths.


        """
        return _hou.ui_selectMultipleNodes(
            self,
            relative_to_node,
            initial_node,
            node_type_filter,
            title,
            width,
            height,
            custom_node_filter_callback,
        )

    def openColorEditor(
        self,
        color_changed_callback: "InterpreterObject",
        include_alpha: "bool" = False,
        initial_color: "Color" = None,
        initial_alpha: "float" = 1.0,
    ) -> "void":
        r"""

        openColorEditor( color_change_callback, include_alpha=False,
        initial_color=None, initial_alpha=1.0)

            Open the Houdini color editor and return immediately.

            When a change is made in the editor then the color_change_callback
            function is invoked and passed the editor's current color and alpha
            value.

            If include_alpha is True then the color editor shows controls for
            editing the color's alpha value.

            The initial_color parameter specifies a hou.Color that will appear
            in the editor when it first opens. If not set, the initial color
            will be white.

            The initial_alpha parameter specifies an alpha value to use when the
            editor first opens. If not set, the initial alpha will be 1.0. Note
            that the initial_alpha parameter only applies if include_alpha is
            set to True.

            The color_change_callback argument must be a function that accepts
            two parameters -- a hou.Color object and an alpha value.

            Here is an example:

          > def handleColorChange(color, alpha):
          >     print \"Current color in editor:\", color, \", alpha=\", alpha
          >
          > hou.ui.openColorEditor(handleColorChange)

        """
        return _hou.ui_openColorEditor(
            self, color_changed_callback, include_alpha, initial_color, initial_alpha
        )

    def openValueLadder(self, *args, **kwargs) -> "void":
        r"""

        openValueLadder(initial_value, value_changed_callback,
        type=hou.valueLadderType.Generic,
        data_type=hou.valueLadderDataType.Float)

            Displays a value ladder control, the UI that typically appears when
            you press [MMB] on a field in Houdini. This lets you display ladder
            controls on your own custom UI, such as Qt edit fields.

            The typical workflow is:

             1. You should listen for [MMB] press and release events on your
                field.

             2. When the user presses [MMB] on the field, call this function to
                show the ladder. The function returns immediately but the ladder
                stays visible.

             3. As the user moves the mouse with [MMB] pressed down, you must
                call hou.ui.updateValueLadder with the mouse pointer
                coordinates.

             4. The ladder calls the value_changed_callback function you
                supplied as the user changes the value.

             5. When the user releases [MMB], call hou.ui.closeValueLadder.

            Only one value ladder window can be open at a time. This function
            raises hou.OperationFailed if another ladder window is currently
            open.


            initial_value
                The initial numeric value the ladder is set to when it opens.

            value_changed_callback
                A function that takes a single argument. As the user edits the
                number with the ladder, the ladder calls this function with each
                new value.

            type
                One of the values in hou.valueLadderType. The available types
                are Generic and Angle. This affects the increments on the
                ladder.

            data_type
                One of the values in hou.valueLadderDataType. Integer and Float
                ladders have different increments.

            This examples demonstrates how to add value ladder window support to
            an input field class that derives from Qt's QLineEdit class:

          >
          > from PySide2 import QtWidgets
          > from PySide2.QtCore import Qt
          > import hou
          >
          >
          > class LineEditWithValueLadder(QtWidgets.QLineEdit):
          >     def __init__(self, parent=None):
          >         super(LineEditWithValueLadder, self).__init__(parent)
          >         self._pressed = False
          >
          >     def mousePressEvent(self, event):
          >         # Show the value ladder window if MMB was pressed.
          >         if event.button() == Qt.MiddleButton:
          >             try:
          >                 hou.ui.openValueLadder(
          >                     float(self.text()),
          >                     self._ladderchange,
          >                     data_type=hou.valueLadderDataType.Float
          >                 )
          >             except hou.OperationFailed:
          >                 # A ladder is already open somewhere
          >                 return
          >             else:
          >                 self._pressed = True
          >
          >     def mouseMoveEvent(self, event):
          >         if self._pressed:
          >             hou.ui.updateValueLadder(
          >                 event.globalX(),
          >                 event.globalY(),
          >                 bool(event.modifiers() & Qt.AltModifier),
          >                 bool(event.modifiers() & Qt.ShiftModifier)
          >             )
          >
          >     def mouseReleaseEvent(self, event):
          >         if event.button() == Qt.MiddleButton and self._pressed:
          >             hou.ui.closeValueLadder()
          >             self._pressed = False
          >
          >     def _ladderchange(self, new_value):
          >         self.setText(str(new_value))

        """
        return _hou.ui_openValueLadder(self, *args, **kwargs)

    def addEventLoopCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addEventLoopCallback(callback)

            Register a Python callback to be called whenever Houdini's event
            loop is idle. This callback is called approximately every 50ms,
            unless Houdini is busy processing events.


            callback
                Any callable Python object that expects no parameters. It could
                be a Python function, a bound method, or any object implementing
                __call__.

          > def checkForAndProcessEvents():
          >     # Here is where you would check for and process any events.
          >     pass
          >
          > hou.ui.addEventLoopCallback(checkForAndProcessEvents)

            You might use this function to integrate another user interface
            toolkit into Houdini's event loop. See the PyQt and wxPython
            cookbook examples for example usages.


        """
        return _hou.ui_addEventLoopCallback(self, callback)

    def removeEventLoopCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeEventLoopCallback(callback)

            Remove a Python callback that was previously registered with
            hou.ui.addEventLoopCallback. See hou.ui.addEventLoopCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
        return _hou.ui_removeEventLoopCallback(self, callback)

    def postEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        postEventCallback(callback)

            Register a Python callback to be called next in Houdini's event
            loop. This will be called only once.


            callback
                Any callable Python object that expects no parameters. It could
                be a Python function, a bound method, or any object implementing
                __call__.


        """
        return _hou.ui_postEventCallback(self, callback)

    def removePostedEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removePostedEventCallback(callback)

            Remove a posted event callback from the queue if it is still there.

            If the callback is not present, nothing is done.


        """
        return _hou.ui_removePostedEventCallback(self, callback)

    def eventLoopCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        eventLoopCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.ui.addEventLoopCallback.


        """
        return _hou.ui_eventLoopCallbacks(self)

    def waitUntil(self, callback: "InterpreterObject") -> "void":
        r"""

        waitUntil(condition_callback)

            Keep calling the supplied callback until it returns True. In the
            meantime, Houdini will continue to be responsive, allowing you to
            continue to interact with it.

            For example, start a blank Houdini session and put the following in
            a shelf tool. It will wait until you create an object node before
            finishing running the tool.

          > print \"waiting until you create an object...\"
          > hou.ui.waitUntil(lambda: len(hou.node(\"/obj\").children()) > 0)
          > print \"you created\", hou.node(\"/obj\").children()

            If you find that your callback function is too slow to be run
            frequently, you can try only making it do work every so often:

          > import time
          >
          > def throttle(callback, delay=2.0):
          >     # Returns a wrapper function around `callback`, which only calls
          >     # `callback` every `delay` seconds (default 2.0), no matter
          >     # how often the wrapper function is called.
          >
          >     # This can be useful if the condition function is expensive to run,
          >     # so you want to limit how often it is called.
          >
          >     # Store in a list, since Python 2.x doesn't have full nonlocal keyword
          >     last_check = [0.0]
          >
          >     def wrapper():
          >         now = time.time()
          >         if now < _last_check[0] + delay:
          >             # Since we return False when we're inside the delay, Houdini
          >             # will continue to call the condition function
          >             return False
          >         else:
          >             _last_check[0] = now
          >             return callback()
          >
          >
          > # Then you could use this with hou.waitUntil like this:
          >
          > def my_callback():
          >     return len(hou.node(\"/obj\").children()) > 0
          >
          > hou.waitUntil(throttle(my_callback, delay=0.5))

        """
        return _hou.ui_waitUntil(self, callback)

    def addTriggerUpdateCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeTriggerUpdateCallback(callback)

            Remove a callback previously added with the
            hou.ui.addTriggerUpdateCallback method.


        """
        return _hou.ui_addTriggerUpdateCallback(self, callback)

    def removeTriggerUpdateCallback(self, callback: "InterpreterObject") -> "void":
        return _hou.ui_removeTriggerUpdateCallback(self, callback)

    def addSelectionCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addSelectionCallback(callback)

            Register a Python callback to be called whenever Houdini's global
            network item selection changes.


            callback
                Any callable Python object that expects a single parameter. This
                parameter will be a list of all selection hou.NetworkMovableItem
                objects that are now selected. It could be a Python function, a
                bound method, or any object implementing __call__.

          > def selectionCallback(selection):
          >     # Here is where you would respond to the selection change.
          >     pass
          > hou.ui.addSelectionCallback(selectionCallback)

        """
        return _hou.ui_addSelectionCallback(self, callback)

    def removeSelectionCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeSelectionCallback(callback)

            Remove a Python callback that was previously registered with
            hou.ui.addSelectionCallback. See hou.ui.addSelectionCallback for
            more information.


        """
        return _hou.ui_removeSelectionCallback(self, callback)

    def selectionCallbacks(
        self,
    ) -> "std::vector< InterpreterObject,std::allocator< InterpreterObject > >":
        r"""

        selectionCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.ui.addSelectionCallback.


        """
        return _hou.ui_selectionCallbacks(self)

    def addResourceEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        addResourceEventCallback(self, callback)

            Register a Python callback to be called whenever a
            hou.resourceEventMessage event occurs.


            'callback'
                Any callable Python object that expects a keyworded argument.

                The keyworded argument contains the following:

              * event_type: hou.resourceEventMessage event.

          * resource_type: A resource type such as ViewerState and ViewerHandle.

              * type_name: The type name of the resource that triggered the
                event. If the resource is a ViewerState, the type name can be
                used for indexing the dictionary returned from
                hou.ui.viewerStateInfo.


        """
        return _hou.ui_addResourceEventCallback(self, callback)

    def removeResourceEventCallback(self, callback: "InterpreterObject") -> "void":
        r"""

        removeResourceEventCallback(self,callback)

            Remove a specific Python callback previously registered with
            hou.ui.addResourceEventCallback.


        """
        return _hou.ui_removeResourceEventCallback(self, callback)

    def openFileEditor(self, *args, **kwargs) -> "void":
        r"""

        openFileEditor(title, file_path, action_callback=None, params=None)

            Open a window for editing and saving a text file.

            The editor buttons:

          * Apply: Save the file only if the source has changed.

          * Accept: Save the file if the source has changed and close the
            window.

          * Cancel: Close the window without saving the file and prompting the
            user.


            NOTE
                When applying unsaved changes, the editor prompts the user if
                the file being edited is not in sync with the file on disk. At
                this point the user is asked to load the new file (overriding
                its current changes) or save its current changes (overriding the
                file on disk) or cancel the operation.

            An optional callback and a dictionary of user-defined parameters can
            be specified to customize the Apply and Accept operations.


            title
                Name of the window title.

            file_path
                A string set with a full path to the file to edit. Exception is
                raised if the string is empty.

                The file extension determines the language settings used by the
                editor. The following file types are supported:

                .py

                Python

                .cmd

                hscript

                .txt/no extension

                Text document

            action_callback
                An optional callback triggered by the editor when either the
                Apply or Accept button is clicked. The callback can be used to
                perform a custom operation. The editor saves the file being
                edited, if required, before calling the callback.

                The callback name is user-defined and takes a dictionary
                argument as input:

              > def myApplyAction( **kwargs )

            params
                A dictionary mapping user-defined entries to values of type int,
                double, bool and string. The dictionary is passed as argument to
                the callback specified with action_callback.

            Example:

          >
          > def myAction(**kwargs):
          >     hou.ui.printResourceMessage(kwargs['msg'] + ' saved.', kwargs['msg_type'])
          >
          > file_path = '/var/tmp/main.py'
          > hou.ui.openFileEditor( 'My Editor Title', file_path, action_callback=myAction,
          >     params={ 'msg' : file_path, 'msg_type' : hou.severityType.Message })

        """
        return _hou.ui_openFileEditor(self, *args, **kwargs)

    def openViewerStateCodeGenDialog(self, *args, **kwargs) -> "void":
        r"""

        openViewerStateCodeGenDialog(category, action_callback,
        operator_name=None)

            Open a modal dialog window for generating a template implementation
            and registration code for a python viewer state. The input name of
            the viewer state is mandatory for generating the code. Other fields
            such as the state label and icon name are optional.

            The dialog Sample options can be selected to generate the viewer
            state code with predefined handlers and bindings. The Handler
            options can also be selected to generate the viewer state code with
            empty handlers.

            The dialog buttons:

          * Accept: Generate the code template with the input fields and
            selected options.

          * Cancel: Close the dialog and abort the code template generation.

            This dialog is used by the Viewer State Browser panel and the
            Digital Asset Viewer State editor.


            category
                A hou.NodeTypeCategory object to specify the type of viewer
                state to register.

            action_callback
                A mandatory callback required for handling the result when the
                Accept button is clicked.

                The callback name is user-defined and takes a dictionary
                argument as input:

              > def myAcceptAction( **kwargs )

                The kwargs dictionary contains the results of the code
                generation:

              * valid: Returns True if the operation succeeded, False otherwise.

              * state_type: The name of the new state.

              * state_type_expr: Expression representing the name of the new
                state: either a python

                    function call to get the HDA node's default state or a
                    string literal.

              * state_label: The state label.

              * state_description: The state description which is only displayed
                in the code header.

              * state_category: The name of the state category type.

              * state_code: The generated python code.

              * state_icon_name: The name of the icon selected. The name can be
                either a single icon name, a

                    file path or an opdef path to refer to an icon embedded in a
                    Digital Asset.

              * state_icon_filename: The icon file path if any.

              * state_icon_section_name: The section name of the icon used by
                the Digital Asset viewer state editor.

            operator_name
                The name of the operator if the viewer state to generate is
                embedded in a Digital Asset. This argument is optional and
                mostly used by the Digital Asset viewer state editor.


        """
        return _hou.ui_openViewerStateCodeGenDialog(self, *args, **kwargs)

    def openViewerHandleCodeGenDialog(
        self, category: "NodeTypeCategory", action_callback: "InterpreterObject"
    ) -> "void":
        r"""

        openViewerHandleCodeGenDialog(categories, action_callback)

            Open a modal dialog window for generating a template implementation
            and registration code for a python viewer handle. The input name of
            the viewer handle is mandatory for generating the code. Other fields
            such as the handle label and icon name are optional.

            The dialog Sample options can be selected to generate the viewer
            handle code with predefined handlers and bindings. The Handler
            options can also be selected to generate the viewer handle code with
            empty handlers.

            The dialog buttons:

          * Accept: Generate the code template with the input fields and
            selected options.

          * Cancel: Close the dialog and abort the code template generation.

            This dialog is available from Viewer Handle Browser panel under the
            File|New... menu.


            category
                A hou.NodeTypeCategory object to specify the type of viewer
                handle to register.

            action_callback
                A mandatory callback required for handling the result when the
                Accept button is clicked.

                The callback name is user-defined and takes a dictionary
                argument as input:

              > def myAcceptAction( **kwargs )

                The kwargs dictionary contains the results of the code
                generation:

              * handle_valid: Returns True if the operation succeeded, False
                otherwise.

              * handle_type: The type name of the new handle.

              * handle_type_expr: Expression representing the name of the new
                handle.

              * handle_label: The handle label.

              * handle_description: The handle description which is only
                displayed in the code header.

              * handle_category: The name of the handle category type.

              * handle_code: The generated python code.

              * handle_icon_name: The name of the icon selected. The name can be
                either a single icon name or a file path.

              * handle_icon_filename: The icon file path if any.


        """
        return _hou.ui_openViewerHandleCodeGenDialog(self, category, action_callback)


# Register ui in _hou:
_hou.ui_swigregister(ui)


class UIEvent(object):
    r"""

    hou.UIEvent

    Represents a user interface event, such as a mouse press. You can access
    this object in an event handler to respond to user input.

    hou.UIEvent provides information to interact with user input and is used
    with Python states. You do not instantiate this type of object yourself.

    RELATED

        hou.ViewerEvent


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, val: "int64"):
        r"""

        hou.UIEvent

        Represents a user interface event, such as a mouse press. You can access
        this object in an event handler to respond to user input.

        hou.UIEvent provides information to interact with user input and is used
        with Python states. You do not instantiate this type of object yourself.

        RELATED

            hou.ViewerEvent


        """
        _hou.UIEvent_swiginit(self, _hou.new_UIEvent(val))

    __swig_destroy__ = _hou.delete_UIEvent

    def __repr__(self) -> "std::string":
        return _hou.UIEvent___repr__(self)

    def device(self) -> "HOM_UIEventDevice *":
        r"""

        device(self) -> hou.UIEventDevice

            Returns an object containing input-device-specific event data. For
            example, if this is a mouse click event, you can use
            event.device().mouseX() to get the X coordinate in screen space, and
            event.device().isLeftButton() to check whether the left mouse button
            was pressed.

          > if ui_event.device().isLeftButton():
          >     ...

        """
        return _hou.UIEvent_device(self)

    def hasQueuedEvents(self) -> "bool":
        r"""

        hasQueuedEvents(self) -> bool

            Returns true if this event contains queued device events.


        """
        return _hou.UIEvent_hasQueuedEvents(self)

    def queuedEvents(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_UIEventDevice >,std::allocator< HOM_ElemPtr< HOM_UIEventDevice > > >":
        r"""

        queuedEvents(self) -> list of hou.UIEventDevice

            If hou.UIEvent.hasQueuedEvents returns True, this method returns the
            list of queued input device events.


        """
        return _hou.UIEvent_queuedEvents(self)

    def value(self) -> "hboost::any":
        r"""

        value(self) -> obj

            Returns the value payload of this event. You can tell the type of
            this value by calling hou.UIEvent.valueType.


        """
        return _hou.UIEvent_value(self)

    def reason(self) -> "HOM_EnumValue &":
        r"""

        reason(self) -> hou.uiEventReason

            For events related to state changes, returns an enum value
            representing the type of state change that triggered the event.


        """
        return _hou.UIEvent_reason(self)

    def valueType(self) -> "HOM_EnumValue &":
        return _hou.UIEvent_valueType(self)


# Register UIEvent in _hou:
_hou.UIEvent_swigregister(UIEvent)


class UIEventDevice(object):
    r"""

    hou.UIEventDevice

    Object containing methods for testing input-device-specific information
    on a UI event, such as which mouse button was pressed.

    Do not instantiate this object yourself. You can get a UIEventDevice
    object from a hou.UIEvent using hou.UIEvent.device. For more information
    see Python state UI events.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, val: "int64", val2: "int64"):
        r"""

        hou.UIEventDevice

        Object containing methods for testing input-device-specific information
        on a UI event, such as which mouse button was pressed.

        Do not instantiate this object yourself. You can get a UIEventDevice
        object from a hou.UIEvent using hou.UIEvent.device. For more information
        see Python state UI events.


        """
        _hou.UIEventDevice_swiginit(self, _hou.new_UIEventDevice(val, val2))

    __swig_destroy__ = _hou.delete_UIEventDevice

    def __repr__(self) -> "std::string":
        return _hou.UIEventDevice___repr__(self)

    def isAltKey(self) -> "bool":
        r"""

        isAltKey(self) -> bool

            Returns True if an Alt/Option key was pressed.


        """
        return _hou.UIEventDevice_isAltKey(self)

    def isAutoRepeat(self) -> "bool":
        r"""

        isAutoRepeat(self) -> bool

            Returns True if the held key was auto-repeating.


        """
        return _hou.UIEventDevice_isAutoRepeat(self)

    def isCapsLock(self) -> "bool":
        r"""

        isCapsLock(self) -> bool

            Returns True if the Caps Lock key was pressed.


        """
        return _hou.UIEventDevice_isCapsLock(self)

    def isCtrlKey(self) -> "bool":
        r"""

        isCtrlKey(self) -> bool

            Returns True if the Control key was pressed.


        """
        return _hou.UIEventDevice_isCtrlKey(self)

    def isKeyPad(self) -> "bool":
        r"""

        isKeyPad(self) -> bool

            Returns True if the pressed key was on the number pad.


        """
        return _hou.UIEventDevice_isKeyPad(self)

    def isShiftKey(self) -> "bool":
        r"""

        isShiftKey(self) -> bool

            Returns True if the a Shift key was pressed.


        """
        return _hou.UIEventDevice_isShiftKey(self)

    def isArrowDown(self) -> "bool":
        r"""

        isArrowDown(self) -> bool

            Returns True if the Down arrow key was pressed.


        """
        return _hou.UIEventDevice_isArrowDown(self)

    def isArrowLeft(self) -> "bool":
        r"""

        isArrowLeft(self) -> bool

            Returns True if the Left arrow key was pressed.


        """
        return _hou.UIEventDevice_isArrowLeft(self)

    def isArrowRight(self) -> "bool":
        r"""

        isArrowRight(self) -> bool

            Returns True if the Right arrow key was pressed.


        """
        return _hou.UIEventDevice_isArrowRight(self)

    def isArrowUp(self) -> "bool":
        r"""

        isArrowUp(self) -> bool

            Returns True if the Up arrow key was pressed.


        """
        return _hou.UIEventDevice_isArrowUp(self)

    def isKeyPressed(self) -> "bool":
        r"""

        isKeyPressed(self) -> bool

            Returns True if any key was pressed.


        """
        return _hou.UIEventDevice_isKeyPressed(self)

    def isFunctionKey(self) -> "bool":
        r"""

        isFunctionKey(self) -> bool

            Returns True if a function key was pressed.


        """
        return _hou.UIEventDevice_isFunctionKey(self)

    def keyValue(self) -> "int":
        r"""

        keyValue(self) -> int

            Returns the ascii code for the key being pressed. If modifiers, such
            as shift and ctrl, are pressed with a key, keyValue returns only the
            ascii code of the key, unlike hou.UIEvent.value which returns the
            encoded value of the keys combination.


        """
        return _hou.UIEventDevice_keyValue(self)

    def keyString(self) -> "std::string":
        r"""

        keyString(self) -> string

            Returns the string representation of the key being pressed. The
            return value can also contain modifier symbols, joined with the plus
            character.

            Few examples:

            a

            a

            <carriage return>

            Enter

            <tab space>

            Tab

            <back space>

            Backspace

            <esc>

            Esc

            <Ctrl Space>

            Ctrl+Space

            <Shift a>

            Shift+a

            <Ctrl Shift a>

            Ctrl+Shift+a

            <Alt Ctrl a>

            Alt+Ctrl+a


        """
        return _hou.UIEventDevice_keyString(self)

    def modifierString(self) -> "std::string":
        r"""

        modifierString(self) -> string

            Returns the string representation of the modifier keys being
            pressed.

            The return value contains only modifier symbols. The key pressed, if
            not itself a modifier, is ignored.

            Few examples:

            <Shift>

            shift

            <Ctrl Shift>

            Ctrl+Shift

            <Alt Shift>

            Alt+Shift


        """
        return _hou.UIEventDevice_modifierString(self)

    def isKeyUp(self) -> "bool":
        r"""

        isKeyUp(self) -> bool

            Returns True if a pressed key was released. This method is used to
            detect a key up transition with a Python state's onKeyTransitEvent
            method.


        """
        return _hou.UIEventDevice_isKeyUp(self)

    def isKeyDown(self) -> "bool":
        r"""

        isKeyDown(self) -> bool

            Returns True if a key was pressed. This method is used to detect a
            key down transition with a with a Python state's onKeyTransitEvent
            method.


        """
        return _hou.UIEventDevice_isKeyDown(self)

    def isLeftButton(self) -> "bool":
        r"""

        isLeftButton(self) -> bool

            Returns True if the [LMB] left mouse button was pressed.


        """
        return _hou.UIEventDevice_isLeftButton(self)

    def isMiddleButton(self) -> "bool":
        r"""

        isMiddleButton(self) -> bool

            Returns True if the [MMB] middle mouse button was pressed.


        """
        return _hou.UIEventDevice_isMiddleButton(self)

    def isRightButton(self) -> "bool":
        r"""

        isRightButton(self) -> bool

            Returns True if the [RMB] right mouse button was pressed.


        """
        return _hou.UIEventDevice_isRightButton(self)

    def mouseWheel(self) -> "double":
        r"""

        mouseWheel(self) -> int

            The result is negative if the wheel was rotated up and positive if
            it was rotated down.

            Different mice will produce different outputs:

          * Mice with clicky wheels will generally output a -1 or +1 event for
            each click (at least that is the intention).

          * Mice with free spinning wheels, or touch sensitive surfaces (such as
            the Apple Magic Mouse), will produce a wider range of values.
            Small/slow scrolling might trigger a mouse wheel event but this
            method returns 0, whereas big/fast scrolling can produce higher
            numbers for each event, up to around 7, with the numbers increasing
            as the user throws the wheel and decreasing as it slows.


        """
        return _hou.UIEventDevice_mouseWheel(self)

    def mouseX(self) -> "double":
        r"""

        mouseX(self) -> int

            Returns the horizontal mouse position in screen coordinates,
            counting from the left edge of the view.


        """
        return _hou.UIEventDevice_mouseX(self)

    def mouseY(self) -> "double":
        r"""

        mouseY(self) -> int

            Returns the vertical mouse position in screen coordinates, counting
            from the bottom edge of the view.


        """
        return _hou.UIEventDevice_mouseY(self)

    def isTablet(self) -> "bool":
        r"""

        isTablet(self) -> bool

            Returns False, even if the event was generated by a tablet stylus.
            Future versions may be able to distinguish tablet and non-tablet
            events.


        """
        return _hou.UIEventDevice_isTablet(self)

    def tabletAngle(self) -> "double":
        r"""

        tabletAngle(self) -> double

            Returns tablet stylus angle value.


        """
        return _hou.UIEventDevice_tabletAngle(self)

    def tabletPressure(self) -> "double":
        r"""

        tabletPressure(self) -> double

            Returns the tablet pressure value.


        """
        return _hou.UIEventDevice_tabletPressure(self)

    def tabletRoll(self) -> "double":
        r"""

        tabletRoll(self) -> double

            Returns the tablet stylus roll value.


        """
        return _hou.UIEventDevice_tabletRoll(self)

    def tabletTilt(self) -> "double":
        r"""

        tabletTilt(self) -> double

            Returns the tablet stylus tilt value.


        """
        return _hou.UIEventDevice_tabletTilt(self)

    def time(self) -> "double":
        r"""

        time(self): -> double

            Returns the time in seconds relative to the event.


        """
        return _hou.UIEventDevice_time(self)


# Register UIEventDevice in _hou:
_hou.UIEventDevice_swigregister(UIEventDevice)


class undos(object):
    r"""

    hou.undos

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_undos

    def __repr__(self) -> "std::string":
        return _hou.undos___repr__(self)

    def areEnabled(self) -> "bool":
        r"""

        areEnabled() -> bool

            Returns True is undos are currently enabled.


        """
        return _hou.undos_areEnabled(self)

    def disabler(self) -> "HOM_UndosDisabler *":
        r"""

        disabler() -> hou.UndosDisabler

            Returns a context manager, within which changes to Houdini will not
            be added to the undo stack.

            For example:

          > with hou.undos.disabler():
          >     # Move all object nodes 1 unit to the left.
          >     # This cannot be undone!
          >     for n in hou.node(\"/obj\").children():
          >         n.move(hou.Vector2(-1, 0))

        """
        return _hou.undos_disabler(self)

    def group(self, label: "char const *") -> "HOM_UndosGroup *":
        r"""

        group(label) -> hou.UndosGroup

            Returns a context manager, within which all changes to Houdini are
            recorded as a single action on the undo stack.

            For example:

          > with hou.undos.group(\"Move all nodes to the left\"):
          >     # Move all object nodes 1 unit to the left.
          >     # This is
          >     for n in hou.node(\"/obj\").children():
          >         n.move(hou.Vector2(-1, 0))

            This has no effect when run inside parameter callback scripts
            because they are already executed within an undo group.


        """
        return _hou.undos_group(self, label)

    def removeUndos(self, tag: "char const *") -> "void":
        r"""

        removeUndos(tag)

            Invalidates and removes all undos that are tagged with tag.

          > # Removes all undos with the tag \"myTag\"
          > hou.undos.removeUndos(\"myTag\")

        """
        return _hou.undos_removeUndos(self, tag)

    def clear(self) -> "void":
        r"""

        clear()

            Clear all undo and redo information.


        """
        return _hou.undos_clear(self)

    def memoryUsage(self) -> "size_t":
        r"""

        memoryUsage() -> int

            The current memory used (in bytes) for undos.


        """
        return _hou.undos_memoryUsage(self)

    def memoryUsageLimit(self) -> "size_t":
        r"""

        memoryUsageLimit() -> int

            The maximum allowed memory usage size (in bytes) for undos.


        """
        return _hou.undos_memoryUsageLimit(self)

    def performUndo(self) -> "bool":
        r"""

        performUndo()

            Undo the last action.


        """
        return _hou.undos_performUndo(self)

    def performRedo(self) -> "bool":
        r"""

        performRedo()

            Redo the last undoed action.


        """
        return _hou.undos_performRedo(self)

    def undoLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        undoLabels() -> tuple of str

            Provides a tuple of the undo operations currently on the stack. Note
            that the first item (ie. undoLabels()) is the next operation that
            will be undone.


        """
        return _hou.undos_undoLabels(self)

    def redoLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        redoLabels() -> tuple of str

            Provides a tuple of the redo operations currently on the stack. Note
            that the first item (ie. redoLabels()) is the next operation that
            will be redone.


        """
        return _hou.undos_redoLabels(self)

    def add(
        self,
        undo: "InterpreterObject",
        label: "char const *",
        tag: "char const *" = None,
    ) -> "void":
        r"""

        add(undo, label, tag=None)

            Add an undo operation to the undo history. undo must be an object
            with undo() and redo() methods. The undo() method is executed when
            the operation is undone and the redo() method is executed when the
            operation is redone.

            label is a description of the undo operation as it appears in the
            undo history.

            A hou.OperationFailed is raised if the undo object passed in does
            not have an undo() method or a redo() method.

            For example, a valid python object passed to this function would
            look like:

          > class MyUndoClass():
          >
          >     def __init__(self):
          >         # ... Initialization ...
          >         pass
          >
          >     def undo(self):
          >         # Add in what needs to be done on undo
          >         pass
          >
          >     def redo(self):
          >         # Add in what needs to be done on redo
          >         pass

            Using the above class, a call to this function would look like:

          > foo = MyUndoClass()
          > hou.undos.add(foo, \"My Undo\")

            An optional string tag can also be set for this undo object, which
            will allow it to be removed from the undo stack using
            hou.undos.removeUndos.

          > foo = MyUndoClass()
          > hou.undos.add(foo, \"My Undo\", \"myTag\")

        """
        return _hou.undos_add(self, undo, label, tag)


# Register undos in _hou:
_hou.undos_swigregister(undos)


class UndosDisabler(object):
    r"""

    hou.UndosDisabler

    Use this class to disable undos within a Python code block.

    This object cannot be instantiated directly. See hou.undos.disabler.

    This object is a context manager. You can create one using
    hou.undos.disabler. Changes inside the with block will not add actions
    to the undo stack.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_UndosDisabler

    def __repr__(self) -> "std::string":
        return _hou.UndosDisabler___repr__(self)

    def __enter__(self) -> "HOM_UndosDisabler *":
        return _hou.UndosDisabler___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.UndosDisabler___exit__(self, type, value, traceback)


# Register UndosDisabler in _hou:
_hou.UndosDisabler_swigregister(UndosDisabler)


class UndosGroup(object):
    r"""

    hou.UndosGroup

    Used to group all undos within a Python code block into a single action.

    This object is a context manager. You can create one using
    hou.undos.group. Changes inside the with block appear as a single action
    in the undo stack.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_UndosGroup

    def __repr__(self) -> "std::string":
        return _hou.UndosGroup___repr__(self)

    def label(self) -> "std::string":
        r"""

        label(self)

            Returns the group label.


        """
        return _hou.UndosGroup_label(self)

    def __enter__(self) -> "HOM_UndosGroup *":
        return _hou.UndosGroup___enter__(self)

    def __exit__(
        self,
        type: "InterpreterObject",
        value: "InterpreterObject",
        traceback: "InterpreterObject",
    ) -> "void":
        return _hou.UndosGroup___exit__(self, type, value, traceback)


# Register UndosGroup in _hou:
_hou.UndosGroup_swigregister(UndosGroup)


class VDB(Prim):
    r"""

    hou.VDB

    A VDB is a kind geometry primitive (Prim object) that stores data in a
    three dimensional grid of voxels.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_VDB

    def __repr__(self) -> "std::string":
        return _hou.VDB___repr__(self)

    def sample(self, position: "_DoubleTuple") -> "double":
        r"""

        sample(self, position) -> float

            Given a sequence of three floats containing a 3D position, return
            the value of the volume at that position. If the position is not in
            the middle of a voxel, Houdini will interpolate using values from
            surrounding voxels.

            See also hou.VDB.voxel and hou.VDB.posToIndex.


        """
        return _hou.VDB_sample(self, position)

    def samplev(self, position: "_DoubleTuple") -> "HOM_Vector3 *":
        r"""

        samplev(self, position) -> hou.Vector3

            Given a sequence of three floats containing a 3D position, return
            the value of the vector valued volume at that position. If the
            position is not in the middle of a voxel, Houdini will interpolate
            using values from surrounding voxels.

            See also hou.VDB.voxel and hou.VDB.posToIndex.


        """
        return _hou.VDB_samplev(self, position)

    def gradient(self, position: "_DoubleTuple") -> "HOM_Vector3 *":
        r"""

        gradient(self, position) -> hou.Vector3

            Given a sequence of three floats containing a 3D position, return a
            vector which points in the direction of the greatest rate of
            increase of the volume's value.

            See Wikipedia's gradient page for more information.


        """
        return _hou.VDB_gradient(self, position)

    def voxel(self, index: "_IntTuple") -> "double":
        r"""

        voxel(self, index) -> float

            Given a sequence of three integers containing a voxel index, return
            the value of the corresponding voxel.


        """
        return _hou.VDB_voxel(self, index)

    def resolution(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        resolution(self) -> hou.Vector3

            Return the x, y, and z dimensions of hou.VDB.activeVoxelBoundingBox.
            Since VDB volumes are sparse, this represents the virtual resolution
            of all the voxels which have data (or are active).


        """
        return _hou.VDB_resolution(self)

    def indexToPos(self, index: "_IntTuple") -> "HOM_Vector3 *":
        r"""

        indexToPos(self, index) -> hou.Vector3

            Given a sequence of three ints containing an index into the voxel
            array, return the corresponding 3D position of the middle of that
            voxel.


        """
        return _hou.VDB_indexToPos(self, index)

    def posToIndex(
        self, position: "_DoubleTuple"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        posToIndex(self, position) -> tuple of int

            Given a sequence of three floats containing a 3D position, return a
            tuple of three ints containing the corresponding index into the
            voxel array.


        """
        return _hou.VDB_posToIndex(self, position)

    def isSDF(self) -> "bool":
        r"""

        isSDF(self) -> bool

            Return whether or not the volume should be semantically treated as a
            signed distance field. If true, the volume can be thought of as
            representing a closed surface, where the negative voxel values are
            inside, the positive voxel values are outside, and voxels on the
            surface are zero.

            For VDB volumes, there is typically only a 3 voxel radius around the
            surface where there exists data.


        """
        return _hou.VDB_isSDF(self)

    def isHeightField(self) -> "bool":
        r"""

        isHeightField(self) -> bool

            Return whether or not the volume is flagged as a heightfield. While
            VDBs are never heightfields, this allows for volumes and VDBs to be
            treated interchangeably.


        """
        return _hou.VDB_isHeightField(self)

    def volumeMax(self) -> "double":
        r"""

        volumeMax(self) -> float

            Return the maximum value of all active voxels.


        """
        return _hou.VDB_volumeMax(self)

    def volumeMin(self) -> "double":
        r"""

        volumeMin(self) -> float

            Return the minimum value of all active voxels.


        """
        return _hou.VDB_volumeMin(self)

    def volumeAverage(self) -> "double":
        r"""

        volumeAverage(self) -> float

            Return the average value of all active voxels.


        """
        return _hou.VDB_volumeAverage(self)

    def transform(self) -> "HOM_Matrix3 *":
        r"""

        transform(self) -> hou.Matrix3

            Return a 3x3 matrix containing the scale and rotation
            transformations for this volume.

            Note that the position information for the volume can be obtained by
            calling volume.vertex(0).point().position().

            The following function returns a 4x4 transformation matrix for the
            volume that includes the translation:

          > def fullTransform(volume):
          >     return (hou.Matrix4(volume.transform()) *
          >         hou.hmath.buildTranslate(volume.vertex(0).point().position()))

            NOTE
                You need to get the object node's transform to get to
                worldspace.


        """
        return _hou.VDB_transform(self)

    def taper(self) -> "double":
        r"""

        taper(self) -> int

            Returns the taper value of the volume's transform. For untapered
            transforms, this value will be 1.


        """
        return _hou.VDB_taper(self)

    def vertex(self, index: "int") -> "HOM_Vertex *":
        r"""

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
        return _hou.VDB_vertex(self, index)

    def isEmpty(self) -> "bool":
        r"""

        isEmpty(self) -> bool

            Returns whether the VDB volume has no data.


        """
        return _hou.VDB_isEmpty(self)

    def activeVoxelCount(self) -> "int":
        r"""

        activeVoxelCount(self) -> int

            Returns the number of active voxels in the volume.


        """
        return _hou.VDB_activeVoxelCount(self)

    def activeVoxelBoundingBox(self) -> "HOM_BoundingBox":
        r"""

        activeVoxelBoundingBox(self) -> hou.BoundingBox

            Returns the smallest exclusive bounding box within the VDB volume
            that has active voxels.


        """
        return _hou.VDB_activeVoxelBoundingBox(self)

    def voxelSize(self) -> "HOM_Vector3":
        r"""

        voxelSize(self) -> hou.Vector3

            Returns the size of voxels within the VDB volume. All voxels will be
            of this size for untapered volumes. For tapered volumes, this size
            represents the size of voxel at the origin of the frustum.


        """
        return _hou.VDB_voxelSize(self)

    def dataType(self) -> "HOM_EnumValue &":
        r"""

        dataType(self) -> hou.vdbData

            Returns the voxel data type within the VDB volume.


        """
        return _hou.VDB_dataType(self)

    def voxelRangeAsBool(
        self, range: "BoundingBox"
    ) -> "std::vector< bool,std::allocator< bool > >":
        return _hou.VDB_voxelRangeAsBool(self, range)

    def voxelRangeAsFloat(
        self, range: "BoundingBox"
    ) -> "std::vector< double,std::allocator< double > >":
        return _hou.VDB_voxelRangeAsFloat(self, range)

    def voxelRangeAsInt(
        self, range: "BoundingBox"
    ) -> "std::vector< int,std::allocator< int > >":
        return _hou.VDB_voxelRangeAsInt(self, range)

    def voxelRangeAsVector3(
        self, range: "BoundingBox"
    ) -> "std::vector< HOM_Vector3,std::allocator< HOM_Vector3 > >":
        return _hou.VDB_voxelRangeAsVector3(self, range)

    def voxelRange(self, range: "BoundingBox") -> "InterpreterObject":
        r"""

        voxelRangeAsVector3(self, range) -> tuple of hou.Vector3

            Return a tuple containing the values of all voxels withing a
            bounding box range. It is faster to call this method to retrieve all
            the voxels than it is to loop through the voxel array in Python.

            See help for hou.VDB.voxelRange for implementation details.


        """
        return _hou.VDB_voxelRange(self, range)


# Register VDB in _hou:
_hou.VDB_swigregister(VDB)


class Vector2(object):
    r"""

    hou.Vector2

    A sequence of 2 floating point values, with associated mathematical
    operations.

    A Vector2 might be used to represent a position in 2D space, a 2D
    direction and length, or the size of a rectangle. For example,
    hou.Node.position returns a position and hou.Node.size returns the size
    of a rectangle.

    See also hou.Vector3 and hou.Vector4.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values=(0.0, 0.0))

            Return a new Vector2 from a sequence of floats. If this method is
            called without parameters, the resulting vector contains the values
            (0.0, 0.0).

            Raises InvalidSize if values is not 2 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
        _hou.Vector2_swiginit(self, _hou.new_Vector2(*args))

    __swig_destroy__ = _hou.delete_Vector2

    def __eq__(self, vector2: "HOM_PtrOrNull< HOM_Vector2 >") -> "bool":
        return _hou.Vector2___eq__(self, vector2)

    def __ne__(self, vector2: "HOM_PtrOrNull< HOM_Vector2 >") -> "bool":
        return _hou.Vector2___ne__(self, vector2)

    def isAlmostEqual(
        self, vector2: "Vector2", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, vector2, tolerance=0.00001) -> bool

            Return whether this vector is equal to another, within a tolerance.
            Verifies that the difference between each component of this vector
            and the corresponding component of the other vector is within the
            tolerance.


        """
        return _hou.Vector2_isAlmostEqual(self, vector2, tolerance)

    def almostEqual(self, vector2: "Vector2", tolerance: "double" = 0.00001) -> "bool":
        r"""

        almostEqual(self, vector2, tolerance=0.00001) -> bool

            Deprecated. Use Vector2.isAlmostEqual instead.


        """
        return _hou.Vector2_almostEqual(self, vector2, tolerance)

    def __hash__(self) -> "int":
        return _hou.Vector2___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Vector2___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Vector2___repr__(self)

    def __getitem__(self, index: "int") -> "double":
        r"""

        __getitem__(self, index) -> float

            Return the float component at the specified index. This method makes
            vectors behave as sequences (so you can, for example, use a for loop
            on the elements of a vector, convert a vector to a tuple of floats,
            etc.) and lets you use square brackets to index into a vector.

          > >>> v = hou.Vector2((1.0, 2.0))
          > >>> v[-1]
          > 2.0

        """
        return _hou.Vector2___getitem__(self, index)

    def __setitem__(self, index: "int", value: "double") -> "void":
        r"""

        __setitem__(self, index, value)

            This method lets you use square brackets to set a value on a vector.

          > >>> v = hou.Vector2((1.5, 2.5))
          > >>> v[0] = 0.5
          > >>> print v
          > [0.5, 2.5]

        """
        return _hou.Vector2___setitem__(self, index, value)

    def __len__(self) -> "int":
        r"""

        __len__(self) -> int

            Returns 2. This method lets you call len() on a Vector2.


        """
        return _hou.Vector2___len__(self)

    def setTo(self, sequence: "_DoubleTuple") -> "void":
        r"""

        setTo(self, sequence)

            Set the contents of this vector to a sequence of floats.

            Raises InvalidSize if values is not 2 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
        return _hou.Vector2_setTo(self, sequence)

    def __add__(self, vector2: "Vector2") -> "HOM_Vector2":
        r"""

        __add__(self, vector2) -> hou.Vector2

            Add two vectors, returning a new vector with each component equal to
            the sum of the corresponding components in the two vectors. This
            method lets you write v1 + v2, where v1 and v2 are Vector2 objects.

            This method is equivalent to hou.Vector2(self[0] + vector2[0],
            self[1] + vector2[1]).


        """
        return _hou.Vector2___add__(self, vector2)

    def __sub__(self, vector2: "Vector2") -> "HOM_Vector2":
        r"""

        __sub__(self, vector2) -> hou.Vector2

            Subtract a vector from another, returning a new vector with each
            component equal to the first vector's corresponding component minus
            the second vector's. This method lets you write v1 - v2, where v1
            and v2 are Vector2 objects.

            This method is equivalent to hou.Vector2(self[0] - vector2[0],
            self[1] - vector2[1]).


        """
        return _hou.Vector2___sub__(self, vector2)

    def __neg__(self) -> "HOM_Vector2":
        r"""

        __neg__(self) -> hou.Vector2

            Return a vector whose components contain the negative values of this
            vector's components. This method lets you write -v, where v is a
            Vector2 object.

            This method is equivalent to hou.Vector2(-self[0], -self[1]).


        """
        return _hou.Vector2___neg__(self)

    def __rmul__(self, scalar: "double") -> "HOM_Vector2":
        r"""

        __rmul__(self, scalar) -> hou.Vector2

            Multiply a vector with a float scalar, returning a new vector. This
            method lets you write s * v where v is a vector and s is a float.

            This method is equivalent to hou.Vector2(self[0] * scalar, self[1] *
            scalar).


        """
        return _hou.Vector2___rmul__(self, scalar)

    def __mul__(self, *args) -> "HOM_Vector2":
        r"""

        __mul__(self, scalar_or_matrix2) -> hou.Vector2

            Multiply a vector with a float scalar or with a hou.Matrix2,
            returning a new vector. This method lets you write v * s where v is
            a vector and s is a float, or v * m where v is a vector and m is a
            hou.Matrix2.

            This method is equivalent to hou.Vector2(self[0] * scalar, self[1] *
            scalar).


        """
        return _hou.Vector2___mul__(self, *args)

    def __div__(self, scalar: "double") -> "HOM_Vector2":
        r"""

        __div__(self, scalar) -> hou.Vector2

            Divide a vector by a float scalar, returning a new vector. This
            method lets you write v / s where v is a vector and s is a float.

            This method is equivalent to hou.Vector2(self[0] / scalar, self[1] /
            scalar).


        """
        return _hou.Vector2___div__(self, scalar)

    def __truediv__(self, scalar: "double") -> "HOM_Vector2":
        return _hou.Vector2___truediv__(self, scalar)

    def normalized(self) -> "HOM_Vector2":
        r"""

        normalized(self) -> hou.Vector2

            Interpreting this vector as a direction, return a vector with the
            same direction but with a length of 1.

            If the vector's length is 0 (or close to it), the result is the
            original vector.

            For vector's with non-zero lengths, this method is equivalent to
            self * (1.0/self.length()).


        """
        return _hou.Vector2_normalized(self)

    def length(self) -> "double":
        r"""

        length(self) -> float

            Interpret this vector as a direction vector and return its length.
            The result is the same as math.sqrt(self[0]**2 + self[1]**2).


        """
        return _hou.Vector2_length(self)

    def lengthSquared(self) -> "double":
        r"""

        lengthSquared(self) -> float

            Interpret this vector as a direction vector and return the square of
            its length. The result is the same as self[0]**2 + self[1]**2.


        """
        return _hou.Vector2_lengthSquared(self)

    def distanceTo(self, vector2: "Vector2") -> "double":
        r"""

        distanceTo(self, vector2) -> float

            Interpret this vector and the argument as 2D positions, and return
            the distance between them. The return value is equivalent to (self -
            vector2).length().


        """
        return _hou.Vector2_distanceTo(self, vector2)

    def dot(self, vector2: "Vector2") -> "double":
        r"""

        dot(self, vector2) -> float

            Return the dot product between this vector and the one in the
            parameter.

            See Wikipedia's dot product page.


        """
        return _hou.Vector2_dot(self, vector2)

    def x(self) -> "double":
        r"""

        x(self) -> float

            Return the first component of the vector. Equivalent to v.


        """
        return _hou.Vector2_x(self)

    def y(self) -> "double":
        r"""

        y(self) -> float

            Return the second component of the vector. Equivalent to v.


        """
        return _hou.Vector2_y(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.Vector2__asVoidPointer(self)


# Register Vector2 in _hou:
_hou.Vector2_swigregister(Vector2)


class Vector3(object):
    r"""

    hou.Vector3

    A sequence of 3 floating point values, with associated mathematical
    operations.

    A Vector3 might be used to represent a position in 3D space, or a 3D
    direction with a length.

    See also hou.Vector2 and hou.Vector4.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values=(0.0, 0.0, 0.0))

            Return a new Vector3 from a sequence of floats. If this method is
            called without parameters, the resulting vector contains the values
            (0.0, 0.0, 0.0).

            You can also construct a Vector3 from a hou.Vector4. The result
            contains the first 3 values in the Vector4.

            Raises InvalidSize if values is not 3 elements long, or TypeError if
            values is not a sequence of floats.


        """
        _hou.Vector3_swiginit(self, _hou.new_Vector3(*args))

    __swig_destroy__ = _hou.delete_Vector3

    def __eq__(self, vector3: "HOM_PtrOrNull< HOM_Vector3 >") -> "bool":
        return _hou.Vector3___eq__(self, vector3)

    def __ne__(self, vector3: "HOM_PtrOrNull< HOM_Vector3 >") -> "bool":
        return _hou.Vector3___ne__(self, vector3)

    def isAlmostEqual(
        self, vector3: "Vector3", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, vector3, tolerance=0.00001) -> bool

            Return whether this vector is equal to another, within a tolerance.
            Verifies that the difference between each component of this vector
            and the corresponding component of the other vector is within the
            tolerance.


        """
        return _hou.Vector3_isAlmostEqual(self, vector3, tolerance)

    def almostEqual(self, vector3: "Vector3", tolerance: "double" = 0.00001) -> "bool":
        r"""

        almostEqual(self, vector3, tolerance=0.00001) -> bool

            Deprecated. Use Vector3.isAlmostEqual instead.


        """
        return _hou.Vector3_almostEqual(self, vector3, tolerance)

    def __hash__(self) -> "int":
        return _hou.Vector3___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Vector3___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Vector3___repr__(self)

    def __getitem__(self, index: "int") -> "double":
        r"""

        __getitem__(self, index) -> float

            Return the float component at the specified index. This method makes
            vectors behave as sequences (so you can, for example, use a for loop
            on the elements of a vector, convert a vector to a tuple of floats,
            etc.) and lets you use square brackets to index into a vector.

          > >>> v = hou.Vector3((1.0, 2.0, 3.0))
          > >>> v[-1]
          > 3.0

        """
        return _hou.Vector3___getitem__(self, index)

    def __setitem__(self, index: "int", value: "double") -> "void":
        r"""

        __setitem__(self, index, value)

            This method lets you use square brackets to set a value on a vector.

          > >>> v = hou.Vector3((1.5, 2.5, 3.5))
          > >>> v[1] = 0.5
          > >>> print v
          > [1.5, 0.5, 3.5]

        """
        return _hou.Vector3___setitem__(self, index, value)

    def __len__(self) -> "int":
        r"""

        __len__(self) -> int

            Returns 3. This method lets you call len() on a Vector3.


        """
        return _hou.Vector3___len__(self)

    def setTo(self, sequence: "_DoubleTuple") -> "void":
        r"""

        setTo(self, sequence)

            Set the contents of this vector to a sequence of floats.

            Raises InvalidSize if values is not 3 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
        return _hou.Vector3_setTo(self, sequence)

    def __add__(self, vector3: "Vector3") -> "HOM_Vector3":
        r"""

        __add__(self, vector3) -> hou.Vector3

            Add two vectors, returning a new vector with each component equal to
            the sum of the corresponding components in the two vectors. This
            method lets you write v1 + v2, where v1 and v2 are Vector3 objects.

            This method is equivalent to hou.Vector3(self[0] + vector3[0],
            self[1] + vector3[1], self[2] + vector3[2]).


        """
        return _hou.Vector3___add__(self, vector3)

    def __sub__(self, vector3: "Vector3") -> "HOM_Vector3":
        r"""

        __sub__(self, vector3) -> hou.Vector3

            Subtract a vector from another, returning a new vector with each
            component equal to the first vector's corresponding component minus
            the second vector's. This method lets you write v1 - v2, where v1
            and v2 are Vector3 objects.

            This method is equivalent to hou.Vector3(self[0] - vector3[0],
            self[1] - vector3[1], self[2] - vector3[2]).


        """
        return _hou.Vector3___sub__(self, vector3)

    def __neg__(self) -> "HOM_Vector3":
        r"""

        __neg__(self) -> hou.Vector3

            Return a vector whose components contain the negative values of this
            vector's components. This method lets you write -v, where v is a
            Vector3 object.

            This method is equivalent to hou.Vector3(-self[0], -self[1],
            -self[2]).


        """
        return _hou.Vector3___neg__(self)

    def __rmul__(self, scalar: "double") -> "HOM_Vector3":
        r"""

        __rmul__(self, scalar) -> hou.Vector3

            Multiply this vector with a scalar, returning a new vector. This
            method lets you write s * v, where v is a vector and s is a float
            scalar. See also hou.Vector3.__mul__, which lets you write v * s.

          > >>> v = hou.Vector3(1, 2, 3)
          > >>> v * 2
          > <hou.Vector3 [2, 4, 6]>
          > >>> 2 * v
          > <hou.Vector3 [2, 4, 6]>

        """
        return _hou.Vector3___rmul__(self, scalar)

    def __mul__(self, *args) -> "HOM_Vector3":
        r"""

        __mul__(self, scalar_or_matrix3_or_matrix4) -> hou.Vector3

            Multiply this vector with a scalar or with a matrix, returning a new
            vector. This method lets you write v * s or v * m where v is a
            vector, s is a float scalar, and m is a hou.Matrix3 or a
            hou.Matrix4.

            When the parameter is a float scalar s, this method is equivalent to
            hou.Vector3(self[0] * s, self[1] * s, self[2] * s).

            In order to multiply the Vector3 by a Matrix4, the Vector3 is
            converted to a Vector4 with the fourth component set to 1.0. The
            effect is that the vector is treated as a position, so if the
            transformation matrix contains a translation component, the return
            value will be translated. If you would like to transform a vector
            (so translations are ignored but rotations, for example, apply),
            you'll need to transform a corresponding hou.Vector4 with the fourth
            component set to zero:

          > # Build a transformation matrix that rotates 180 degrees about z and then translates by 1 in x.
          > >>> matrix = hou.hmath.buildRotateAboutAxis((0, 0, 1), 180) * hou.hmath.buildTranslate((1, 0, 0))
          > >>> position = hou.Vector3(0.0, 1.0, 0.0)
          >
          > # Rotate the point (0,1,0) to (0,-1,0), then translate to (1,-1,0).
          > >>> position * matrix
          > <hou.Vector3 [1, -1, 0]>
          >
          > # Rotate the vector (0,1,0) to (0,-1,0), ignoring the translation.
          > >>> vector = hou.Vector4(tuple(position) + (0.0,))
          > >>> vector
          > <hou.Vector4 [0, 1, 0, 0]>
          > >>> vector * matrix
          > <hou.Vector4 [0, -1, 0, 0]>
          > >>> hou.Vector3(vector * matrix)
          > <hou.Vector3 [0, -1, 0]>
          >
          > # We could have wrapped the above in a function:
          > >>> def transformAsVector(vector3):
          > ...     return hou.Vector3(hou.Vector4(tuple(vector3) + (0.0,)) * matrix)
          > >>> transformAsVector(position)
          > <hou.Vector3 [0, -1, 0]>
          >
          > # Change the Vector4's last component to 1 to illustrate that it's transformed as a point again.
          > >>> vector[-1] = 1.0
          > >>> vector
          > <hou.Vector4 [0, 1, 0, 1]>
          > >>> vector * matrix
          > <hou.Vector4 [1, -1, 0, 1]>

            See also hou.Matrix4.


        """
        return _hou.Vector3___mul__(self, *args)

    def __div__(self, scalar: "double") -> "HOM_Vector3":
        r"""

        __div__(self, scalar) -> hou.Vector3

            Divide a vector by a float scalar, returning a new vector. This
            method lets you write v / s where v is a vector and s is a float.

            This method is equivalent to hou.Vector3(self[0] / scalar, self[1] /
            scalar, self[2] / scalar).


        """
        return _hou.Vector3___div__(self, scalar)

    def __truediv__(self, scalar: "double") -> "HOM_Vector3":
        return _hou.Vector3___truediv__(self, scalar)

    def normalized(self) -> "HOM_Vector3":
        r"""

        normalized(self) -> hou.Vector3

            Interpret this vector as a direction and return a vector with the
            same direction but with a length of 1.

            If the vector's length is 0 (or close to it), the result is the
            original vector.

            For vectors with non-zero lengths, this method is equivalent to self
            * (1.0/self.length()).


        """
        return _hou.Vector3_normalized(self)

    def multiplyAsDir(self, matrix4: "Matrix4") -> "HOM_Vector3":
        r"""

        multiplyAsDir(self, matrix4) -> hou.Vector3

            Interpret this vector as a direction and returns a transformed
            direction that has been rotated and scaled (not translated) by the
            matrix4


        """
        return _hou.Vector3_multiplyAsDir(self, matrix4)

    def length(self) -> "double":
        r"""

        length(self) -> float

            Interpret this vector as a direction vector and return its length.
            The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
            self[2]**2).


        """
        return _hou.Vector3_length(self)

    def lengthSquared(self) -> "double":
        r"""

        lengthSquared(self) -> float

            Interpret this vector as a direction vector and return the square of
            its length. The result is the same as self[0]**2 + self[1]**2 +
            self[2]**2.


        """
        return _hou.Vector3_lengthSquared(self)

    def matrixToRotateTo(self, vector3: "Vector3") -> "HOM_Matrix4 *":
        r"""

        matrixToRotateTo(self, vector3) -> hou.Matrix4

            Return a matrix that rotates this vector onto vector3, rotating
            about the axis perpendicular to the two vectors. If the two vectors
            have the same direction, return the identity matrix.


        """
        return _hou.Vector3_matrixToRotateTo(self, vector3)

    def smoothRotation(self, *args, **kwargs) -> "HOM_Vector3":
        r"""

        smoothRotation(self, reference, rotate_order=\"xyz\") -> hou.Vector3

            Returns the Euler rotations (in degrees) that have the closest
            values to reference while still describing the same orientation as
            this vector.


            reference
                A hou.Vector3 of Euler angles, in degrees. Typically, this will
                be the rotations from the previous sample or frame.

            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.


        """
        return _hou.Vector3_smoothRotation(self, *args, **kwargs)

    def distanceTo(self, vector3: "Vector3") -> "double":
        r"""

        distanceTo(self, vector3) -> float

            Interpret this vector and the argument as 3D positions, and return
            the distance between them. The return value is equivalent to (self -
            vector3).length().


        """
        return _hou.Vector3_distanceTo(self, vector3)

    def angleTo(self, vector3: "Vector3") -> "double":
        r"""

        angleTo(self, vector3) -> float

            Interprets this Vector3 and the parameter as directions and returns
            the angle (in degrees) formed between the two vectors when you place
            the origins at the same location.


        """
        return _hou.Vector3_angleTo(self, vector3)

    def dot(self, vector3: "Vector3") -> "double":
        r"""

        dot(self, vector3) -> float

            Return the dot product between this vector and the one in the
            parameter. This value is equal to self[0]*vector3[0] +
            self[1]*vector3[1] + self[2]*vector3[2], which is also equal to
            self.length() * vector3.length() *
            math.cos(hou.hmath.degToRad(self.angleTo(vector3)))

            See Wikipedia's dot product page.


        """
        return _hou.Vector3_dot(self, vector3)

    def cross(self, vector3: "Vector3") -> "HOM_Vector3":
        r"""

        cross(self, vector3) -> hou.Vector3

            Return the cross product of this vector with another vector. The
            return value is a vector that is perpendicular to both vectors,
            pointing in the direction defined by the right-hand rule, with
            length self.length() * vector3.length() *
            math.sin(hou.hmath.degToRad(self.angleTo(vector3))).

            See Wikipedia's cross product page.


        """
        return _hou.Vector3_cross(self, vector3)

    def ocio_transform(
        self, src_space: "std::string const &", dest_space: "std::string const &"
    ) -> "HOM_Vector3":
        r"""

        ocio_transform(self, src_space, dest_space) -> hou.Vector3

            Use Open Color IO to transform the color from the source space to
            the destination space.


        """
        return _hou.Vector3_ocio_transform(self, src_space, dest_space)

    def x(self) -> "double":
        r"""

        x(self) -> float

            Return the first component of the vector. Equivalent to v.


        """
        return _hou.Vector3_x(self)

    def y(self) -> "double":
        r"""

        y(self) -> float

            Return the second component of the vector. Equivalent to v.


        """
        return _hou.Vector3_y(self)

    def z(self) -> "double":
        r"""

        z(self) -> float

            Return the third component of the vector. Equivalent to v.


        """
        return _hou.Vector3_z(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.Vector3__asVoidPointer(self)

    def distanceToSegment(self, point1: "Vector3", point2: "Vector3") -> "double":
        r"""

        pointOnSegment(self, point1, point2) -> hou.Vector3

            Project the underlying vector onto the line segment defined by
            point1 to point2. The returned point will lie on the line segment.


            `point1'
                The first hou.Vector3 of the line segment.

            `point2'
                The second hou.Vector3 of the line segment.


        """
        return _hou.Vector3_distanceToSegment(self, point1, point2)

    def distance2ToSegment(self, point1: "Vector3", point2: "Vector3") -> "double":
        return _hou.Vector3_distance2ToSegment(self, point1, point2)

    def pointOnSegment(self, point1: "Vector3", point2: "Vector3") -> "HOM_Vector3":
        return _hou.Vector3_pointOnSegment(self, point1, point2)


# Register Vector3 in _hou:
_hou.Vector3_swigregister(Vector3)


class Vector4(object):
    r"""

    hou.Vector4

    A sequence of 4 floating point values, with associated mathematical
    operations.

    A Vector4 could be used to represent a position or direction in 4D
    space. In 3D math, however, it is more commonly used to represent either
    a position or a vector, depending on the value of the fourth component.
    Positions have a fourth component of 1.0, and vectors have a fourth
    component of 0.0. Subtracting a position from another yields a vector,
    adding two vectors together yields a vector, and adding a point and a
    vector yields a point. Operations that yield a fourth component value
    other than 0 or 1, like adding two points together, are not valid.
    Similarly, is makes sense to speak about a vector's length but not a
    position's length. The fourth component also affects how the
    position/vector is transformed; see hou.Vector3.__mul__ for more
    information.

    See also hou.Vector2 and hou.Vector3.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args):
        r"""

        __init__(self, values=(0.0, 0.0, 0.0, 0.0))

            Return a new Vector4 from a sequence of floats. If this method is
            called without parameters, the resulting vector contains the values
            (0.0, 0.0, 0.0, 0.0).

            You can also construct a Vector4 from a hou.Vector3. The new vector
            has its fourth component set to 1.0.

            Raises InvalidSize if values is not 4 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
        _hou.Vector4_swiginit(self, _hou.new_Vector4(*args))

    __swig_destroy__ = _hou.delete_Vector4

    def __eq__(self, vector4: "HOM_PtrOrNull< HOM_Vector4 >") -> "bool":
        return _hou.Vector4___eq__(self, vector4)

    def __ne__(self, vector4: "HOM_PtrOrNull< HOM_Vector4 >") -> "bool":
        return _hou.Vector4___ne__(self, vector4)

    def isAlmostEqual(
        self, vector4: "Vector4", tolerance: "double" = 0.00001
    ) -> "bool":
        r"""

        isAlmostEqual(self, vector4, tolerance=0.00001) -> bool

            Return whether this vector is equal to another, within a tolerance.
            Verifies that the difference between each component of this vector
            and the corresponding component of the other vector is within the
            tolerance.


        """
        return _hou.Vector4_isAlmostEqual(self, vector4, tolerance)

    def almostEqual(self, vector4: "Vector4", tolerance: "double" = 0.00001) -> "bool":
        r"""

        almostEqual(self, vector4, tolerance=0.00001) -> bool

            Deprecated. Use Vector4.isAlmostEqual instead.


        """
        return _hou.Vector4_almostEqual(self, vector4, tolerance)

    def __hash__(self) -> "int":
        return _hou.Vector4___hash__(self)

    def __str__(self) -> "std::string":
        return _hou.Vector4___str__(self)

    def __repr__(self) -> "std::string":
        return _hou.Vector4___repr__(self)

    def __getitem__(self, index: "int") -> "double":
        r"""

        __getitem__(self, index) -> float

            Return the float component at the specified index. This method makes
            vectors behave as sequences (so you can, for example, use a for loop
            on the elements of a vector, convert a vector to a tuple of floats,
            etc.) and lets you use square brackets to index into a vector.


        """
        return _hou.Vector4___getitem__(self, index)

    def __setitem__(self, index: "int", value: "double") -> "void":
        r"""

        __setitem__(self, index, value)

            This method lets you use square brackets to set a value on a vector.


        """
        return _hou.Vector4___setitem__(self, index, value)

    def __len__(self) -> "int":
        r"""

        __len__(self) -> int

            Returns 4. This method lets you call len() on a Vector4.


        """
        return _hou.Vector4___len__(self)

    def setTo(self, sequence: "_DoubleTuple") -> "void":
        r"""

        setTo(self, sequence)

            Set the contents of this vector to a sequence of floats.

            Raises InvalidSize if values is not 4 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
        return _hou.Vector4_setTo(self, sequence)

    def __add__(self, vector4: "Vector4") -> "HOM_Vector4":
        r"""

        __add__(self, vector4) -> hou.Vector4

            Add two vectors, returning a new vector with each component
            (including the last one) equal to the sum of the corresponding
            components in the two vectors. This method lets you write v1 + v2,
            where v1 and v2 are Vector4 objects.

            This method is equivalent to hou.Vector4(self[0] + vector4[0],
            self[1] + vector4[1], self[2] + vector4[2], self[3] + vector4[3]).


        """
        return _hou.Vector4___add__(self, vector4)

    def __sub__(self, vector4: "Vector4") -> "HOM_Vector4":
        r"""

        __sub__(self, vector4) -> hou.Vector4

            Subtract a vector from another, returning a new vector with each
            component (including the last one) equal to the first vector's
            corresponding component minus the second vector's. This method lets
            you write v1 - v2, where v1 and v2 are Vector4 objects.

            This method is equivalent to hou.Vector4(self[0] - vector4[0],
            self[1] - vector4[1], self[2] - vector4[2], self[3] - vector4[3]).


        """
        return _hou.Vector4___sub__(self, vector4)

    def __rmul__(self, scalar: "double") -> "HOM_Vector4":
        r"""

        __rmul__(self, scalar) -> hou.Vector4

            Multiply this vector with a scalar, returning a new vector. This
            method lets you write s * v, where v is a vector and s is a float
            scalar. See also hou.Vector4.__mul__, which lets you write v * s.

          > >>> v = hou.Vector4(1, 2, 3, 4)
          > >>> v * 2
          > <hou.Vector4 [2, 4, 6, 8]>
          > >>> 2 * v
          > <hou.Vector4 [2, 4, 6, 8]>

        """
        return _hou.Vector4___rmul__(self, scalar)

    def __mul__(self, *args) -> "HOM_Vector4":
        r"""

        __mul__(self, scalar_or_matrix4) -> hou.Vector4

            Multiply a vector with a scalar or with a matrix, returning a new
            vector. This method lets you write v * s or v * m where v is a
            vector, s is a float scalar, and m is a hou.Matrix4.

            See hou.Vector3.__mul__ for more information.


        """
        return _hou.Vector4___mul__(self, *args)

    def __div__(self, scalar: "double") -> "HOM_Vector4":
        r"""

        __div__(self, scalar) -> hou.Vector4

            Divide a vector by a float scalar, returning a new vector. This
            method lets you write v / s where v is a vector and s is a float.

            This method is equivalent to hou.Vector4(self[0] / scalar, self[1] /
            scalar, self[2] / scalar, self[3] / scalar).


        """
        return _hou.Vector4___div__(self, scalar)

    def __truediv__(self, scalar: "double") -> "HOM_Vector4":
        return _hou.Vector4___truediv__(self, scalar)

    def normalized(self) -> "HOM_Vector4":
        r"""

        normalized(self) -> Vector4

            Interpret this vector as a 4D direction and return a vector with the
            same direction but with a length of 1. If this vector being used to
            represent a 3D direction (so the fourth component is 0), the result
            is still meaningful, and represents the corresponding 3D direction.

            If the vector's length is 0 (or close to it), the result is the
            original vector.

            For vectors with non-zero lengths, this method is equivalent to self
            * (1.0/self.length()).


        """
        return _hou.Vector4_normalized(self)

    def length(self) -> "double":
        r"""

        length(self) -> float

            Interpret this vector as a 4D direction vector and return its
            length. If this vector is representing a 3D direction (so the fourth
            component is 0), the result is the 3D length.

            The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
            self[2]**2 + self[3]**2).


        """
        return _hou.Vector4_length(self)

    def lengthSquared(self) -> "double":
        r"""

        lengthSquared(self) -> float

            Return the result of self.length()**2. The result is the same as
            self[0]**2 + self[1]**2 + self[2]**2 + self[3]**2.


        """
        return _hou.Vector4_lengthSquared(self)

    def dot(self, vector4: "Vector4") -> "double":
        r"""

        dot(self, vector4) -> float

            Return the dot product between this 4D vector and the one in the
            parameter. This value is equal to self[0]*vector4[0] +
            self[1]*vector4[1] + self[2]*vector4[2] + self[3]*vector4[3].


        """
        return _hou.Vector4_dot(self, vector4)

    def ocio_transform(
        self, src_space: "std::string const &", dest_space: "std::string const &"
    ) -> "HOM_Vector4":
        r"""

        ocio_transform(self, src_space, dest_space) -> hou.Vector4

            Use Open Color IO to transform the color from the source space to
            the destination space.


        """
        return _hou.Vector4_ocio_transform(self, src_space, dest_space)

    def x(self) -> "double":
        r"""

        x(self) -> float

            Return the first component of the vector. Equivalent to v.


        """
        return _hou.Vector4_x(self)

    def y(self) -> "double":
        r"""

        y(self) -> float

            Return the second component of the vector. Equivalent to v.


        """
        return _hou.Vector4_y(self)

    def z(self) -> "double":
        r"""

        z(self) -> float

            Return the third component of the vector. Equivalent to v.


        """
        return _hou.Vector4_z(self)

    def w(self) -> "double":
        r"""

        w(self) -> float

            Return the fourth component of the vector. Equivalent to v.


        """
        return _hou.Vector4_w(self)

    def _asVoidPointer(self) -> "void *":
        return _hou.Vector4__asVoidPointer(self)


# Register Vector4 in _hou:
_hou.Vector4_swigregister(Vector4)


class Vertex(object):
    r"""

    hou.Vertex

    Existing inside a Geometry object, a Vertex object is contained in
    exactly one Prim, and references exactly one Point.

    This setup allows points to be shared between primitives. For example, a
    polygon contains its own list of vertices that are not shared with other
    primitives, but vertices in different polygons may refer to the same
    point. When that point moves, the corresponding vertices on all adjacent
    polygons will also move, preventing polygon edges from separating.

    Note that you can use hou.Vertex.point to retrieve a point from a
    vertex, but there is no method to retrieve all the vertices referring to
    a point. Houdini does not store this information internally, but you can
    derive it. The best way to quickly retrieve this information is to build
    a dictionary mapping all points to sets of vertices, and then reuse this
    dictionary in your algorithm.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Vertex

    def __eq__(self, vertex: "HOM_PtrOrNull< HOM_Vertex >") -> "bool":
        return _hou.Vertex___eq__(self, vertex)

    def __ne__(self, vertex: "HOM_PtrOrNull< HOM_Vertex >") -> "bool":
        return _hou.Vertex___ne__(self, vertex)

    def __hash__(self) -> "int":
        return _hou.Vertex___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.Vertex___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> Geometry

            Return the hou.Geometry object containing this vertex.


        """
        return _hou.Vertex_geometry(self)

    def prim(self) -> "HOM_Prim *":
        r"""

        prim(self) -> hou.Prim

            Return the hou.Prim object containing this vertex.

            If the primitive is a face, use hou.Prim.vertices to access the
            other vertices in the primitive. If it is a surface, use
            hou.Surface.vertex, hou.Surface.numRows, and hou.Surface.numCols.


        """
        return _hou.Vertex_prim(self)

    def point(self) -> "HOM_Point *":
        r"""

        point(self) -> hou.Point

            Return the hou.Point object that this vertex refers to. Each vertex
            refers to exactly one point.


        """
        return _hou.Vertex_point(self)

    def number(self) -> "int":
        r"""

        number(self) -> int

            Return the number of this vertex within its primitive. Vertices in
            the same primitive are numbered sequentially starting from 0, and
            the vertices returned by hou.Prim.vertices are in order by their
            number.


        """
        return _hou.Vertex_number(self)

    def linearNumber(self) -> "int":
        r"""

        linearNumber(self) -> int

            Return the number of this vertex within its whole detail. Vertices
            in the detail are sometimes in the same order as they occur in
            primitives, but this is often not true. Linear vertex numbers in a
            detail are sequential, starting from 0, and ending with one less
            than the total number of vertices in the detail. This can be useful
            so that a function that can be applied to point, vertex, primitive,
            or detail attributes doesn't have to take two numbers just to handle
            the vertex case.


        """
        return _hou.Vertex_linearNumber(self)

    def attribType(self) -> "HOM_EnumValue &":
        r"""

        attribType(self) -> hou.attribType enum value

            Return the enumerated value hou.attribType.Vertex. Points,
            primitives, vertices, and geometry support the same set of methods
            for querying their attributes, and this method is one of them.

            See also:

          * hou.Point.attribType

          * hou.Prim.attribType

          * hou.Geometry.attribType

          * hou.attribType


        """
        return _hou.Vertex_attribType(self)

    def floatAttribValue(self, *args) -> "double":
        r"""

        floatAttribValue(self, name_or_attrib) -> float

            Return the vertex attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not float of size 1.

            In most cases, you'll just use hou.Vertex.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
        return _hou.Vertex_floatAttribValue(self, *args)

    def floatListAttribValue(
        self, *args
    ) -> "std::vector< double,std::allocator< double > >":
        r"""

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the vertex attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Vertex.attribValue.


        """
        return _hou.Vertex_floatListAttribValue(self, *args)

    def intAttribValue(self, *args) -> "int64":
        r"""

        intAttribValue(self, name_or_attrib) -> int

            Return the vertex attribute value for a particular integer attribute
            of size 1. The attribute may be specified by name or by hou.Attrib
            object. See hou.Vertex.floatAttribValue for more information.


        """
        return _hou.Vertex_intAttribValue(self, *args)

    def intListAttribValue(
        self, *args
    ) -> "std::vector< int64,std::allocator< int64 > >":
        r"""

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the vertex attribute value for a particular integer
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of ints. See
            hou.Vertex.floatListAttribValue for more information.


        """
        return _hou.Vertex_intListAttribValue(self, *args)

    def stringAttribValue(self, *args) -> "std::string":
        r"""

        stringAttribValue(self, name_or_attrib) -> str

            Return the vertex attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. See
            hou.Vertex.floatAttribValue for more information.


        """
        return _hou.Vertex_stringAttribValue(self, *args)

    def stringListAttribValue(
        self, *args
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the vertex attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. The
            return value is a tuple of strings.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Vertex.attribValue.


        """
        return _hou.Vertex_stringListAttribValue(self, *args)

    def dictAttribValue(
        self, *args
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        dictAttribValue(self, name_or_attrib) -> dict

            Return the vertex attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Vertex.floatAttribValue for more information.


        """
        return _hou.Vertex_dictAttribValue(self, *args)

    def dictListAttribValue(
        self, *args
    ) -> "std::vector< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >,std::allocator< std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > > > >":
        r"""

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the vertex attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Vertex.floatAttribValue for more information.


        """
        return _hou.Vertex_dictListAttribValue(self, *args)

    def setAttribValue(self, *args) -> "void":
        r"""

        setAttribValue(self, name_or_attrib, attrib_value)

            Store an attribute value in this vertex. The attribute may be
            specified by name or by hou.Attrib object, and must be an existing
            vertex attribute in the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute's data type does not match the value passed in. If
            the attribute's size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute's size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Vertex_setAttribValue(self, *args)

    def _attribInfo(
        self,
        name: "char const *",
        attr_data_type: "int &",
        attr_size: "int &",
        is_array_type: "bool &",
    ) -> "void":
        return _hou.Vertex__attribInfo(
            self, name, attr_data_type, attr_size, is_array_type
        )

    def attribValue(self, *args) -> "InterpreterObject":
        r"""

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return the value store in this vertex for a particular attribute.
            The attribute may be specified by name or by hou.Attrib object.

            Looking an attribute value using a hou.Attrib object is slightly
            faster than looking it up by name. When looking up attribute values
            inside a loop, look up the hou.Attrib object outside the loop, and
            pass it into this method.

            Raises hou.OperationFailed if no attribute exists with this name.


        """
        return _hou.Vertex_attribValue(self, *args)


# Register Vertex in _hou:
_hou.Vertex_swigregister(Vertex)


class VertexGroup(object):
    r"""

    hou.VertexGroup

    A named group of vertices inside a Geometry object.

    Vertex groups reside inside the geometry, and each vertex group has a
    unique name.

    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing vertex number). When creating a group using the group SOP,
    use the <Create Ordered> checkbox to create an ordered group. When
    creating one from Python, Use the is_ordered parameter of
    hou.Geometry.createVertexGroup to control whether a group is ordered.

    See hou.Vertex for more information about vertices. See also
    hou.PrimGroup, hou.PointGroup, and hou.EdgeGroup.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_VertexGroup

    def __eq__(self, vertex_group: "HOM_PtrOrNull< HOM_VertexGroup >") -> "bool":
        return _hou.VertexGroup___eq__(self, vertex_group)

    def __ne__(self, vertex_group: "HOM_PtrOrNull< HOM_VertexGroup >") -> "bool":
        return _hou.VertexGroup___ne__(self, vertex_group)

    def __hash__(self) -> "int":
        return _hou.VertexGroup___hash__(self)

    def __repr__(self) -> "std::string":
        return _hou.VertexGroup___repr__(self)

    def geometry(self) -> "HOM_Geometry *":
        r"""

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
        return _hou.VertexGroup_geometry(self)

    def name(self) -> "std::string":
        r"""

        name(self)

            Return the name of the group. Each vertex group has a unique name.


        """
        return _hou.VertexGroup_name(self)

    def iterVertices(self) -> "HOM_IterableList< HOM_Vertex > *":
        r"""

        iterVertices(self) -> generator of hou.Vertex

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.VertexGroup.vertices allocates and returns a tuple of
            all the vertices in the group, this method returns a generator
            object that will yield hou.Vertex objects on demand.


        """
        return _hou.VertexGroup_iterVertices(self)

    def vertices(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_Vertex >,std::allocator< HOM_ElemPtr< HOM_Vertex > > >":
        r"""

        vertices(self) -> tuple of hou.Vertex

            Return the contents of this group.

            See also hou.VertexGroup.iterVertices.


        """
        return _hou.VertexGroup_vertices(self)

    def contains(self, vertex: "Vertex") -> "bool":
        r"""

        contains(self, vertex) -> bool

            Return whether or not a vertex is in this group.

            Raises hou.OperationFailed if the vertex belongs to a different
            geometry object than this group.


        """
        return _hou.VertexGroup_contains(self, vertex)

    def isOrdered(self) -> "bool":
        r"""

        isOrdered(self) -> bool

            Returns whether or not this group is ordered.


        """
        return _hou.VertexGroup_isOrdered(self)

    def add(self, *args) -> "void":
        r"""

        add(self, vertex_or_list_or_vertex_group)

            If given a hou.Vertex or a list of hou.Vertex's, add the vertex
            (vertices) to the group. If given a hou.VertexGroup, merge the
            contents of the other vertex group with this group (the other group
            is unaffected). You would typically call this method from the code
            of a Python-defined SOP.

            It is ok to add vertices to the group that were already in the
            group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the vertex or vertex group belong to a
            different geometry object than this group.


        """
        return _hou.VertexGroup_add(self, *args)

    def remove(self, *args) -> "void":
        r"""

        remove(self, vertex_or_list_or_vertex_group)

            If given a hou.Vertex or a list of hou.Vertex's, remove the vertex
            from the group. If given a hou.VertexGroup, remove all vertices in
            the other group from this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is not an error to try to remove a vertex from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the vertex belongs to a different
            geometry object than this group.


        """
        return _hou.VertexGroup_remove(self, *args)

    def clear(self) -> "void":
        r"""

        clear(self)

            Remove all vertices from this group. You would typically call this
            method from the code of a Python-defined SOP.

            The vertices remain in the geometry; only the group is affected.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.VertexGroup_clear(self)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.VertexGroup_destroy(self)

    def vertexCount(self) -> "int64":
        r"""

        vertexCount(self) -> int

            Returns the number of vertices in this group.


        """
        return _hou.VertexGroup_vertexCount(self)

    def optionType(self, option_name: "char const *") -> "HOM_EnumValue &":
        r"""

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
        return _hou.VertexGroup_optionType(self, option_name)

    def setOption(self, *args) -> "void":
        r"""

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See
            hou.VertexGroup.options for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
        return _hou.VertexGroup_setOption(self, *args)

    def removeOption(self, name: "char const *") -> "void":
        r"""

        removeOption(self, name)

            Remove an entry in the dictionary of options. See
            hou.VertexGroup.options for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
        return _hou.VertexGroup_removeOption(self, name)

    def dataId(self) -> "HOM_AttribDataId *":
        r"""

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
        return _hou.VertexGroup_dataId(self)

    def incrementDataId(self) -> "void":
        r"""

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
        return _hou.VertexGroup_incrementDataId(self)

    def options(self) -> "InterpreterObject":
        r"""

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.VertexGroup.options, hou.VertexGroup.setOption and
            hou.VertexGroup.removeOption.


        """
        return _hou.VertexGroup_options(self)

    def option(self, option_name: "char const *") -> "InterpreterObject":
        return _hou.VertexGroup_option(self, option_name)


# Register VertexGroup in _hou:
_hou.VertexGroup_swigregister(VertexGroup)


class VexContext(object):
    r"""

    hou.VexContext

    Represents a VEX/VOP context. Different contexts allow the use of
    different functions/VOPs.


    NOTE
        This class is for internal use by Houdini and isn't usually
        necessary for scripting Houdini or creating tools.

    This object is returned by hou.vexContextForNodeTypeCategory and
    hou.vexContextForShaderType. You can get a list of all VEX context
    objects using hou.vexContexts.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_VexContext

    def __repr__(self) -> "std::string":
        return _hou.VexContext___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of this context as a string. For example, 'Sop' or
            'surface'.


        """
        return _hou.VexContext_name(self)

    def nodeTypeCategory(self) -> "HOM_NodeTypeCategory *":
        r"""

        nodeTypeCategory(self) -> hou.NodeTypeCategory

            Returns the hou.NodeTypeCategory object associated with this VEX
            context.

          > >>> # Get a reference to a SOP node
          > >>> n = hou.node(\"/obj/geo1/pointvop1\")
          > >>> # Get its type category (SOPs)
          > >>> sops = n.type().category()
          > >>> # Get the context associated with the SOPs category
          > >>> ctx = hou.vexContextForNodeTypeCategory(sops)
          > >>> # Get the node type category associated with the Sop context
          > >>> ctx.nodeTypeCategory()
          > <hou.NodeTypeCategory for Sop>

        """
        return _hou.VexContext_nodeTypeCategory(self)

    def shaderType(self) -> "HOM_EnumValue *":
        r"""

        shaderType(self) -> hou.shaderType enum value or None

            Returns a hou.shaderType value representing the shader type
            associated with this VEX context.


        """
        return _hou.VexContext_shaderType(self)

    def pathsToLoadedVexFunctions(
        self,
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        pathsToLoadedVexFunctions(self) -> dict mapping names to paths


        """
        return _hou.VexContext_pathsToLoadedVexFunctions(self)


# Register VexContext in _hou:
_hou.VexContext_swigregister(VexContext)


class ViewerDragger(object):
    r"""

    hou.ViewerDragger

    A mechanism to support interactive dragging operations.

    The hou.ViewerDragger class provides various methods to help
    implementing mouse dragging functionality without worrying about many
    details like constraining the mouse movement or making sure drag
    coordinates are computed relative to a specific origin.

    hou.ViewerDragger is an abstract base class for hou.ViewerHandleDragger
    and hou.ViewerStateDragger, these are the classes you must use to
    instantiate a dragger.

    A dragger operation can be divided in three parts:

     1. start: This step configures the dragger for a specific drag
        operation.

     2. drag: This actually executes the drag operation interactively as
        configured in step #1.

     3. end: Ends the operation and cleanup the dragger.

    Drag operations like translating a geometry along a plane, along a line
    or rotating a geometry around an axis can all be accomplished with a
    dragger.

    RELATED

        hou.ViewerHandleDragger hou.ViewerStateDragger


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _hou.delete_ViewerDragger

    def name(self) -> "std::string":
        r"""

        name(self) -> str

            Returns the name of the dragger.


        """
        return _hou.ViewerDragger_name(self)

    def valid(self) -> "bool":
        r"""

        valid(self) -> bool

            Returns True if the dragger is ready to use or False otherwise. One
            of the dragger start methods must be called first to make a dragger
            usable.


        """
        return _hou.ViewerDragger_valid(self)

    def startDrag(self, event: "ViewerEvent", start_pos: "Vector3") -> "void":
        r"""

        startDrag(self, ui_event, start_pos)

            Enables the dragger for moving the mouse anywhere in the viewport
            from a specific position.


            NOTE
                When invoking startDrag from onMouseIndirectEvent with [MMB],
                the dragger computes the handle position relative to the world-
                space position under the mouse.

            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                typically the object Houdini passes to a python handle or python
                state's onMouseEvent.

            start_pos
                A hou.Vector3 object describing the start position of the drag
                operation. For instance, this could be a python handle pivot.


        """
        return _hou.ViewerDragger_startDrag(self, event, start_pos)

    def startDragAcrossFloor(
        self, event: "ViewerEvent", start_pos: "Vector3"
    ) -> "void":
        r"""

        startDragAcrossFloor(self, ui_event, start_pos, mouse_offset)

            This method enables the dragger to move the mouse along the
            construction plane or the viewport reference plane grid.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            start_pos
                A hou.Vector3 object describing the start position of the drag
                operation.


        """
        return _hou.ViewerDragger_startDragAcrossFloor(self, event, start_pos)

    def startDragAlongLine(
        self, event: "ViewerEvent", line_start: "Vector3", line_dir: "Vector3"
    ) -> "void":
        r"""

        startDragAlongLine(self, ui_event, line_origin, line_dir)

            Configures the dragger to move the mouse along a line defined with a
            start point and a direction vector. When the line is picked and the
            mouse is moving, the dragger will constrain the mouse movement in
            the direction of the line.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            line_origin
                A hou.Vector3 object to define the start position of the line.

            line_dir
                A hou.Vector3 object to define the direction the line is
                pointing.


        """
        return _hou.ViewerDragger_startDragAlongLine(self, event, line_start, line_dir)

    def startDragAlongPlane(
        self, event: "ViewerEvent", plane_point: "Vector3", plane_normal: "Vector3"
    ) -> "void":
        r"""

        startDragAlongPlane(self, ui_event, plane_point, plane_normal)

            Configures the dragger to move the mouse along a plane defined with
            an origin point and a normal vector. When the LMB is down and the
            mouse is moving, the dragger will constrain the mouse position to
            the plane.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            plane_point
                A hou.Vector3 object defining a point on the plane.

            plane_normal
                A hou.Vector3 object to define the plane normal.


        """
        return _hou.ViewerDragger_startDragAlongPlane(
            self, event, plane_point, plane_normal
        )

    def startDragRotate(
        self,
        event: "ViewerEvent",
        center_pos: "Vector3",
        radius: "double",
        rotate_axis: "Vector3",
        orient: "Matrix3",
    ) -> "void":
        r"""

        startDragRotate(self, ui_event, center_pos, radius, rotate_axis, orient)

            Configures the dragger to drag a ring around an axis.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            center_pos
                A hou.Vector3 object representing the center of the rotation.

            radius
                The radius of the rotation ring.

            rotate_axis
                A hou.Vector3 vector representing the axis of rotation. This is
                typically a normalized vector used as the rotation plane normal.

            orient
                A hou.Matrix3 object representing the orientation matrix of the
                axis.


        """
        return _hou.ViewerDragger_startDragRotate(
            self, event, center_pos, radius, rotate_axis, orient
        )

    def drag(self, event: "ViewerEvent") -> "HOM_ViewerDragger::DragValueMap":
        r"""

        drag(self, ui_event) -> (dictionary)

            Performs a drag operation based on the start method previously
            called. Raises hou.OperationFailed if the dragger was not
            initialized with a start method.

            Call this method when the mouse is being dragged. All dragger
            operations are done in world space and can perform snapping (except
            for rotation) if the dialog has the option enabled.

            The method returns a dictionary containing the resulting values for
            these operations: XYZ Drag, Drag Across Floor, Drag Along Line, Drag
            Along Plane:

            delta_position

            A hou.Vector3 vector representing the delta mouse position related
            to the drag start position.

            position

            A hou.Vector3 vector representing the absolute mouse position in
            world coordinates.

            This dictionary is returned for the Drag Rotate operation:

            delta_angle

            A hou.Vector3 vector representing the delta angle in radians related
            to the rotation start position.

            angle

            A hou.Vector3 vector representing the total angle in radians related
            to the rotation start position.

            rotate_position

            A hou.Vector3 vector representing the rotation ring absolute
            position related to the rotation start position.

            delta_rotate_matrix

            A hou.Matrix3 matrix representing the delta rotation matrix related
            to the orient matrix.


        """
        return _hou.ViewerDragger_drag(self, event)

    def endDrag(self) -> "void":
        r"""

        endDrag(self)

            Ends the current drag operation by releasing any drag cache and
            other settings performed by the dragger.


        """
        return _hou.ViewerDragger_endDrag(self)

    def position(self) -> "HOM_Vector3":
        r"""

        position(self) -> hou.Vector3

            Returns the absolute mouse position of the current drag operation.
            The returned value is relevant for these operations: XYZ Drag, Drag
            Across Floor, Drag Along Line, Drag Along Plane.


        """
        return _hou.ViewerDragger_position(self)

    def startPosition(self) -> "HOM_Vector3":
        r"""

        startPosition(self) -> hou.Vector3

            Returns the start position used for configuring the current drag
            operation. For the Drag Rotate operation, the returned value refers
            to the center of rotation.


        """
        return _hou.ViewerDragger_startPosition(self)

    def startDirection(self) -> "HOM_Vector3":
        r"""

        startDirection(self) -> hou.Vector3

            Returns the start direction used for configuring the current drag
            operation.

            For the Drag Rotate operation, the returned value refers to the
            direction vector pointing ray corresponding to the hou.ViewerEvent's
            mouse coordinates in screen space.


        """
        return _hou.ViewerDragger_startDirection(self)

    def startRotatePosition(self) -> "HOM_Vector3":
        r"""

        startRotatePosition(self) -> hou.Vector3

            Returns the start position on the rotation ring for the Drag Rotate
            operation.


        """
        return _hou.ViewerDragger_startRotatePosition(self)

    def viewport(self) -> "HOM_GeometryViewport *":
        r"""

        viewport(self) -> hou.GeometryViewport

            Returns the current viewport.


        """
        return _hou.ViewerDragger_viewport(self)


# Register ViewerDragger in _hou:
_hou.ViewerDragger_swigregister(ViewerDragger)


class ViewerEvent(UIEvent):
    r"""

    hou.ViewerEvent

    Represents a user interface event specific to viewers.

    hou.ViewerEvent objects are used with Python states. Houdini will call
    event handlers with a dictionary containing various useful data,
    including a ui_event key containing a ViewerEvent object. You do not
    instantiate this type of object yourself. See Python states for more
    information.

    hou.ViewerEvent is a specialized hou.UIEvent class that you can used for
    accessing ray coordinates in a viewer.

    RELATED

        hou.ViewerHandleDragger hou.ViewerStateDragger


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, sceneViewer: "SceneViewer", val: "int64"):
        r"""

        hou.ViewerEvent

        Represents a user interface event specific to viewers.

        hou.ViewerEvent objects are used with Python states. Houdini will call
        event handlers with a dictionary containing various useful data,
        including a ui_event key containing a ViewerEvent object. You do not
        instantiate this type of object yourself. See Python states for more
        information.

        hou.ViewerEvent is a specialized hou.UIEvent class that you can used for
        accessing ray coordinates in a viewer.

        RELATED

            hou.ViewerHandleDragger hou.ViewerStateDragger


        """
        _hou.ViewerEvent_swiginit(self, _hou.new_ViewerEvent(sceneViewer, val))

    __swig_destroy__ = _hou.delete_ViewerEvent

    def __repr__(self) -> "std::string":
        return _hou.ViewerEvent___repr__(self)

    def ray(
        self,
    ) -> "UT_Tuple< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        ray(self) -> (origin_point, direction)

            Returns a tuple of two hou.Vector3 objects representing the origin
            point and a direction vector of a pointing ray in 3D world space
            corresponding to the underlying hou.UIEventDevice's mouse
            coordinates in screen space.

            The resulting ray can be used to shoot into the scene that passes
            through whatever is under the mouse. The method puts the ray origin
            at the mouse screen coordinates on the near plane and then maps the
            camera space position to world space. For a perspective projection,
            the near plane part of the frustum is usually small in world space,
            so the origin point will be pretty close to the camera position.


        """
        return _hou.ViewerEvent_ray(self)

    def snappingRay(
        self,
    ) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
        r"""

        snappingRay(self) -> dict

            Same as hou.ViewerEvent.ray, but the returned original point may be
            snapped with respect to scene geometry, the Houdini construction or
            the reference plane. Snapping is performed using the settings from
            the snapping options window available on the left side of the
            viewport. The dictionary contains the following key/value pairs:

            snapped
            Bool

            True if the user snapped to scene geometry, to the Houdini
            construction plane, or to the reference plane in the viewport.

            origin_point
            hou.Vector3

            The origin of a pointing ray in 3D world space corresponding to the
            mouse coordinates in screen space. If snapped is True, the
            origin_point is the position on the camera plane such that if you
            sent a pointing ray through that point, it would hit the component
            that was snapped to. This may not necessarily be the position
            directly under the mouse cursor.

            direction
            hou.Vector3

            The direction vector of a pointing ray in 3D world space
            corresponding to the mouse coordinates in screen space. It may be
            moved from the actual mouse position if snapped is True.

            geo_type
            hou.snappingPriority

            The type of geometry which was snapped to. This key is only included
            if snapped is True. Note that only geometry types that are set in
            the Snapping Options Window can be snapped to.

            node_id
            int

            The session node id of the node whose geometry has been snapped to.
            The node itself can be retrieved by calling hou.nodebySessionId().

            prim_index
            int

            The primitive number corresponding to the snapped geometry. This is
            only included in the dictionary if geo_type is one of GeoPrim,
            BreakPoint, PrimGuidePoint, or PrimGuideEdge.

            point_index
            int

            The point number corresponding to the snapped geometry. This is only
            included in the dictionary if geo_type is GeoPoint.

            edge_point_index1
            int

            The first endpoint of the snapped edge. This is only included in the
            dictionary if geo_type is one of GeoEdge or Midpoint.

            edge_point_index2
            int

            The second endpoint of the snapped edge. This is only included in
            the dictionary if geo_type is one of GeoEdge or Midpoint.

            breakpoint_u
            int

            The first coordinate of the snapped breakpoint. This is only
            included in the dictionary if geo_type is BreakPoint.

            breakpoint_v
            int

            The second coordinate of the snapped breakpoint. This is only
            included in the dictionary if geo_type is BreakPoint.

            guide_index
            int

            The index of the guide corresponding to the snapped geometry. This
            is only included in the dictionary if geo_type is one of
            PrimGuidePoint or PrimGuideEdge.

            grid_pos
            hou.Vector3

            The position on the grid of the snapped geometry. This is only
            included in the dictionary if geo_type is either GridPoint or
            GridEdge.

            start_pos
            hou.Vector3

            The position on the grid of the first endpoint of the snapped edge.
            This is only included in the dictionary if geo_type is GridEdge.

            end_pos
            hou.Vector3

            The position on the grid of the second endpoint of the snapped edge.
            This is only included in the dictionary if geo_type is GridEdge.


            Note
                snapped will always be False if snapping is not enabled in the
                viewport. See hou.SceneViewer.setSnappingMode to change the
                current snapping mode.


        """
        return _hou.ViewerEvent_snappingRay(self)

    def screenToRay(
        self, scrx: "double", scry: "double"
    ) -> "UT_Tuple< HOM_ElemPtr< HOM_Vector3 >,HOM_ElemPtr< HOM_Vector3 > >":
        r"""

        screenToRay(self, scrx, scry) -> (origin_point, direction)

            Returns a tuple of two hou.Vector3 objects representing the origin
            point and a direction vector of a pointing ray in 3D world space
            corresponding to the provided mouse coordinates in screen space.


        """
        return _hou.ViewerEvent_screenToRay(self, scrx, scry)

    def curViewport(self) -> "HOM_GeometryViewport *":
        r"""

        curViewport(self) -> hou.GeometryViewport

            Returns the viewport this event occurred within.


        """
        return _hou.ViewerEvent_curViewport(self)


# Register ViewerEvent in _hou:
_hou.ViewerEvent_swigregister(ViewerEvent)


class ViewerStateContext(GadgetContext):
    r"""

    hou.ViewerStateContext

    Represents the execution context of a Python viewer state.

    OVERVIEW

        A hou.ViewerStateContext holds the contextual information related to
        the running viewer state such as the gadget drawable bindings.

    RELATED

        hou.ViewerStateTemplate.bindGadget hou.ViewerHandleContext


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, val: "int64"):
        r"""

        hou.ViewerStateContext

        Represents the execution context of a Python viewer state.

        OVERVIEW

            A hou.ViewerStateContext holds the contextual information related to
            the running viewer state such as the gadget drawable bindings.

        RELATED

            hou.ViewerStateTemplate.bindGadget hou.ViewerHandleContext


        """
        _hou.ViewerStateContext_swiginit(self, _hou.new_ViewerStateContext(val))

    __swig_destroy__ = _hou.delete_ViewerStateContext

    def __repr__(self) -> "std::string":
        return _hou.ViewerStateContext___repr__(self)


# Register ViewerStateContext in _hou:
_hou.ViewerStateContext_swigregister(ViewerStateContext)


class ViewerHandleDragger(ViewerDragger):
    r"""

    hou.ViewerHandleDragger

    Represents a dragger usable with Python viewer handles.

    You will typically implement drag operations in the viewer handle
    onMouseEvent handler. The example below demonstrates how to translate
    the geometry bound to a viewer handle by dragging the handle's pivot.

    > import hou
    >
    > def __init__(self, **kwargs):
    >     self.__dict__.update(kwargs)
    >
    >     #creates the handle dragger
    >     self.handle_dragger = hou.ViewerHandleDragger(\"dragger\")
    >
    > def onMouseEvent( self, kwargs ):
    >     \"\"\" Called when a gadget is being picked and dragged.
    >     \"\"\"
    >
    >     # The handle context containing pick/locate info on the active gadget
    >     hcontext = self.handle_context
    >
    >     # The handle parameters
    >     hparms = kwargs[\"handle_parms\"]
    >
    >     # Tegular mouse event info
    >     ui_event = kwargs[\"ui_event\"]
    >     reason = ui_event.reason()
    >
    >     if hcontext.gadget() == Handle.GADGET_PIVOT:
    >         # The pivot is used by the user to move the handle.
    >         if reason == hou.uiEventReason.Start:
    >             # Get the current translation values from the handle
    >             # parameters
    >             handle_pos = hou.Vector3(hparms[\"tx\"][\"value\"], hparms[\"ty\"][\"value\"],
    >                 hparms[\"tz\"][\"value\"])
    >
    >             # Start the handle translate from the current handle pivot position.
    >             self.handle_dragger.startDrag(ui_event, handle_pos)
    >
    >         elif reason == hou.uiEventReason.Changed or reason == hou.uiEventReason.Active:
    >             # drag the bound geometry interactively (while the LMB is down).
    >             drag_values = self.handle_dragger.drag(ui_event)
    >
    >             # Update the handle parameters with the delta position returned by
    >             # the dragger.
    >             hparms[\"tx\"][\"value\"] += drag_values[\"delta_position\"][0]
    >             hparms[\"ty\"][\"value\"] += drag_values[\"delta_position\"][1]
    >             hparms[\"tz\"][\"value\"] += drag_values[\"delta_position\"][2]
    >
    >             # Set the handle transform matrix
    >             self.xform = hu.updateTransform(self.xform, t=[hparms[\"tx\"][\"value\"],
    >                 hparms[\"ty\"][\"value\"], hparms[\"tz\"][\"value\"]])
    >
    >             if reason == hou.uiEventReason.Changed:
    >                 # We are done, exit the drag.
    >                 self.handle_dragger.endDrag()
    >
    >         # Consume the event
    >         return True
    >
    >     return False

    RELATED

        hou.ViewerHandleContext hou.ViewerStateDragger


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, name: "std::string const &"):
        r"""

        __init__(self, name)

            Creates a viewer handle dragger object.


            name
                A name to identify the dragger.


        """
        _hou.ViewerHandleDragger_swiginit(self, _hou.new_ViewerHandleDragger(name))

    __swig_destroy__ = _hou.delete_ViewerHandleDragger

    def __repr__(self) -> "std::string":
        return _hou.ViewerHandleDragger___repr__(self)


# Register ViewerHandleDragger in _hou:
_hou.ViewerHandleDragger_swigregister(ViewerHandleDragger)


class ViewerHandleContext(GadgetContext):
    r"""

    hou.ViewerHandleContext

    Represents the execution context of a Python viewer handle.

    OVERVIEW

        A hou.ViewerHandleContext holds the state related to the running
        viewer handle. A Viewer handle context holds the information about
        the viewer handle gadgets (see hou.GadgetContext) and about the
        viewer handle itself, such as the parms states.

    RELATED

        hou.ViewerHandleTemplate


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, val: "int64"):
        r"""

        hou.ViewerHandleContext

        Represents the execution context of a Python viewer handle.

        OVERVIEW

            A hou.ViewerHandleContext holds the state related to the running
            viewer handle. A Viewer handle context holds the information about
            the viewer handle gadgets (see hou.GadgetContext) and about the
            viewer handle itself, such as the parms states.

        RELATED

            hou.ViewerHandleTemplate


        """
        _hou.ViewerHandleContext_swiginit(self, _hou.new_ViewerHandleContext(val))

    __swig_destroy__ = _hou.delete_ViewerHandleContext

    def __repr__(self) -> "std::string":
        return _hou.ViewerHandleContext___repr__(self)

    def isParameterEnabled(self, parm_name: "std::string const &") -> "bool":
        r"""

        isParameterEnabled(parm_name) -> bool


            parm_name
                Returns True if a given parm name is enabled. The returned value
                is typically used in the handle implementation for enabling or
                disabling (hide) the functionality that may depend on this parm.


        """
        return _hou.ViewerHandleContext_isParameterEnabled(self, parm_name)

    def scaleFactor(self, *args) -> "double":
        r"""

        scaleFactor(ref_position) -> double

            This method returns a scale factor that can be used to maintain a
            fixed scale size of the handle gadgets when zooming in or out.
            scaleFactor is normally used in onDrawSetup.


            ref_position
                A reference position (related to the handle) used for computing
                the scale factor. This could be the handle's pivot position (if
                one exists) or any other relevant position. If omitted, the
                reference position is (0,0,0).


        """
        return _hou.ViewerHandleContext_scaleFactor(self, *args)

    def scaleValue(self) -> "double":
        r"""

        scaleValue() -> double

            Returns the handle scale preference value. The handle scale is
            computed proportionally to the current viewport size and can be used
            to scale up handle gadgets to a preferred size. You would normally
            call scaleValue from onDrawSetup.


        """
        return _hou.ViewerHandleContext_scaleValue(self)

    def objectWorldTransform(self) -> "HOM_Matrix4":
        r"""

        objectWorldTransform() -> `hou.Matrix4

            Returns the world space transform of the handle's parent object.


        """
        return _hou.ViewerHandleContext_objectWorldTransform(self)

    def objectLocalTransform(self) -> "HOM_Matrix4":
        r"""

        objectLocalTransform() -> `hou.Matrix4

            Returns the local space transform of the handle's parent object.


        """
        return _hou.ViewerHandleContext_objectLocalTransform(self)


# Register ViewerHandleContext in _hou:
_hou.ViewerHandleContext_swigregister(ViewerHandleContext)


class ViewerHandleTemplate(object):
    r"""

    hou.ViewerHandleTemplate

    Class for registering a python viewer handle in Houdini.

    This class is used for defining a python viewer handle template. Use
    this class to set the configuration and create the handle bindings like
    gadgets, parameters and context menu in order to create the template.
    Houdini uses this template for registering the viewer handle and to
    create instances of the viewer handle.

    See Python handles for more details on how to create your python viewer
    handles.

    RELATED

        hou.ViewerHandleContext hou.ViewerHandleDragger


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, label, categories)

            Creates a new instance of ViewerHandleTemplate representing a viewer
            handle type.

            A viewer handle is identified by a name and a list of categories
            such as SOP and OBJ. The name is the custom type of the viewer
            handle and must be unique. The list of categories specifies in which
            context(s) the viewer handle can be used.


            name
                A unique name to define the handle type.

            label
                A string representing the handle descriptive name.

            categories
                A list of hou.NodeTypeCategory objects to describe the
                context(s) supported by the handle.

                Here's the list of the supported contexts:

              * hou.sopNodeTypeCategory

              * hou.objNodeTypeCategory

              * hou.lopNodeTypeCategory

              * hou.dopNodeTypeCategory

                Use the functions below for adding the contexts to the
                categories list.

                For SOP states use:

              > hou.sopNodeTypeCategory()

                For OBJ states use:

              > hou.objNodeTypeCategory()

                For LOP states use:

              > hou.lopNodeTypeCategory()

                For DOP states use:

              > hou.dopNodeTypeCategory()

        """
        _hou.ViewerHandleTemplate_swiginit(
            self, _hou.new_ViewerHandleTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_ViewerHandleTemplate

    def __repr__(self) -> "std::string":
        return _hou.ViewerHandleTemplate___repr__(self)

    def typeName(self) -> "std::string":
        r"""

        typeName(self) -> str

            Returns the handle type name.


        """
        return _hou.ViewerHandleTemplate_typeName(self)

    def categories(
        self,
    ) -> (
        "std::vector< HOM_NodeTypeCategory *,std::allocator< HOM_NodeTypeCategory * > >"
    ):
        r"""

        categories(self) -> list of hou.NodeTypeCategory

            Returns the list of supported contexts for this template.


        """
        return _hou.ViewerHandleTemplate_categories(self)

    def bindMenu(self, menu: "ViewerStateMenu") -> "void":
        r"""

        bindMenu(self, menu)

            Attaches a context menu to this viewer handle. You can only bind one
            single context menu per template.


            menu
                The hou.ViewerStateMenu object to add.


        """
        return _hou.ViewerHandleTemplate_bindMenu(self, menu)

    def bindIcon(self, name: "std::string const &") -> "void":
        r"""

        bindIcon(self, icon_name)

            Sets the icon image of this viewer handle.


            icon_name
                The name of the icon. Defaults to MISC_python. The icon name can
                be specified as follows:

              * As a single name.

              * As a path to the image icon file on disk. There is no convention
                for where to put icon files on disk.

                    eg.

                  > template.bindIcon(\"$HOUDINI_USER_PREF_DIR/config/Icons/myicon.pic\")

        """
        return _hou.ViewerHandleTemplate_bindIcon(self, name)

    def bindGadget(self, *args, **kwargs) -> "void":
        r"""

        bindGadget(self, drawable_type, gadget_name, gadget_label=None,
        parms=None)

            Binds a gadget drawable to a viewer handle. A gadget is a special
            geometry drawable which provides visual interaction support to
            viewer handles with picking and locating capabilities. Gadget
            drawable instances are created by Houdini, you don't create objects
            of this type by yourself. See hou.ViewerHandleTemplate.bindFactory
            for details on how to access the gadgets in a viewer handle class.


            geometry_drawable_type
                The gadget geometry type. The following types are supported:

              * hou.drawableGeometryType.Face

              * hou.drawableGeometryType.Line

              * hou.drawableGeometryType.Point

            gadget_name
                The gadget name string identifier.

            gadget_label
                An optional description name. Defaults to None.

            parms
                A list of handle parameter names the gadget requires for visual
                interaction. Houdini will make the gadget available to the
                python handle's handle_gadgets dictionary only when all its
                required parameters are bound to an asset. For instance, if the
                gadget requires parms X and Y and all of them are bound, the
                gadget will be made available when the handle is activated.
                However, if only parm X is bound, the gadget will not be
                available at all. This means the gadget will not be part of
                handle_gadgets. In this case, the python handle implementation
                should make sure to not access an unbound gadget.

                Defaults to None.


        """
        return _hou.ViewerHandleTemplate_bindGadget(self, *args, **kwargs)

    def bindParameter(self, *args, **kwargs) -> "void":
        r"""

        bindParameter(self, param_type, name, label=None, default_value=None,
        num_components=1, min_limit=0, max_limit=1, visible=True)

            Defines a viewer handle visual parameter. A viewer handle
            implementation can expose these parameters to Houdini so users can
            change them visually through its gadgets. You can also change these
            parameters from the Handle dialog (with the 'P' hotkey or from the
            viewport context menu). This workflow however is mostly used for
            debugging purposes.

            A viewer handle should implement the onParmChangeEvent handler to
            react to parameter changes. See viewer handle event handlers for
            details.


            name
                The parameter name identifier. The name cannot be empty and must
                be unique within the handle.

            default_value
                The default value of the parameter. This is the value Houdini
                uses to initialize the parameter. The value type should ideally
                match param_type but Houdini will do its best to convert the
                type appropriately. Defaults to None.

            label
                The parameter label. If sets to None (default), the label is set
                with the parameter name.

            min_limit
                Describes the minimum value the parameter can be set with.
                Defaults to 0. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            max_limit
                Describes the maximum value the parameter can be set with.
                Defaults to 1. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            num_components
                Specifies the number of components to create for the parameter
                template. A maximum of 3 components is allowed, the default
                number of component is 1. Exceptions are raised if the value is
                invalid.

                num_components > 1 is supported for the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            param_type
                The viewer handle parameter type. These types are supported:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

                An exception is raised for other types.

            visible
                Controls whether the parameter is visible or not in the Handle
                Parameter Dialog. Defaults to True.


                NOTE
                    If the parameter is not exported, Houdini will mark it as
                    invisible regardless of the visible argument setting.


        """
        return _hou.ViewerHandleTemplate_bindParameter(self, *args, **kwargs)

    def exportParameters(self, params: "_StringTuple") -> "void":
        r"""

        exportParameters(self, params)

            Exposes specific viewer handle parameters to Houdini. Exported
            parameters can be used by viewer states for binding dynamically or
            statically viewer handles.


            params
                List of parameters defined with
                hou.ViewerHandleTemplate.bindParameter.


        """
        return _hou.ViewerHandleTemplate_exportParameters(self, params)

    def bindSetting(self, *args, **kwargs) -> "void":
        r"""

        bindSetting(self, param_type, name, label=None,
        menu_as_button_strip=False, menu_items=None, num_components=1,
        default_value=None, min_limit=0, max_limit=1, align=False)

            Binds a setting parameter to a viewer handle. A setting is a non-
            visual parameter typically used for configuring or setting a viewer
            handle workflow. They are accessible from the Handle dialog.

            A viewer handle should implement the onParmChangeEvent handler to
            react to setting parameter changes. See viewer handle event handlers
            for details.


            align
                Specifies how the parameter is aligned in the Handle Dialog. If
                True, the parameter is aligned horizontally with the next bound
                parameter. If False, the parameter is displayed below the
                previous one. Defaults to False.

            default_value
                The default value of the parameter. This is the value Houdini
                uses to initialize the parameter. The value type should ideally
                match param_type but Houdini will do its best to convert the
                type appropriately. Defaults to None.

                Parameter type

                Value type

                hou.parmTemplateType.Button

                The value is ignored.

                hou.parmTemplateType.Menu

                Menu item identifier as defined with menu_items.

                hou.parmTemplateType.Toggle

                Toggle state as a bool or int.

            name
                The parameter string identifier. The name cannot be empty and
                must be unique in the handle template or an exception is raised.

            label
                The parameter label. If sets to None (default), the label is set
                with the parameter name.

            menu_as_button_strip
                If True, the hou.parmTemplateType.Menu parameter is set to use a
                button strip widget to display the menu items. Buttons are
                displayed with the menu item icons, if any, or with the menu
                item labels otherwise. menu_as_button_strip defaults to False
                and is ignored for other types.

            menu_items
                A list of string tuples for defining the items of a
                hou.parmTemplateType.Menu parameter. menu_items is ignored for
                other parameter types.

                The tuple can contain 2 or 3 elements:

              * Item 0: the menu item identifier.

              * Item 1: the menu item label.

              * Item 2: the menu item icon name (optional).

            min_limit
                Describes the minimum value the parameter can be set in the UI
                dialog. Defaults to 0. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            max_limit
                Describes the maximum value the parameter can be set in the UI
                dialog. Defaults to 1. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            num_components
                Specifies the number of components to create for the parameter
                template. Defaults to 1. Exceptions are raised if the value is
                invalid.

                num_components > 1 is supported for the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.String

            param_type
                The type of parameter to bind. The following types are
                supported:

              * hou.parmTemplateType.Button

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.Menu

              * hou.parmTemplateType.Separator

              * hou.parmTemplateType.String

              * hou.parmTemplateType.Toggle

                An exception is raised for other types.


        """
        return _hou.ViewerHandleTemplate_bindSetting(self, *args, **kwargs)

    def bindFactory(self, callback: "InterpreterObject") -> "void":
        r"""

        bindFactory(self, callable)

            Takes a callable object (such as a class or function) that returns
            the viewer handle class.


        """
        return _hou.ViewerHandleTemplate_bindFactory(self, callback)


# Register ViewerHandleTemplate in _hou:
_hou.ViewerHandleTemplate_swigregister(ViewerHandleTemplate)


class ViewerState(object):
    r"""

    hou.ViewerState

    Describes an interactive state for a viewer pane.

    Viewer panes such as a Scene Viewer or Compositor Viewer can enter
    specific states. A state controls the available handles, mouse
    interactions, and in some cases node creation or deletion based on user
    interaction with the viewer pane. This class does not represent a
    running state in a viewer, but instead describes a state that can be
    entered with methods such as hou.SceneViewer.setCurrentState or
    hou.CompositorViewer.setCurrentState.

    Each node type that can be displayed in a viewer pane will have an
    associated viewer state (though not all viewer states need to be
    associated with a node type). This node type specific viewer state is
    used to create new instances or edit existing instances of the node type
    in a viewer pane.

    The list of viewer states associated with a given node type category is
    returned from the hou.NodeTypeCategory.viewerStates method.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ViewerState

    def __repr__(self) -> "std::string":
        return _hou.ViewerState___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> string

            Return the internal name of this state, which is the string that
            must be passed to the setCurrentState() method of the viewer pane to
            enter this state.


        """
        return _hou.ViewerState_name(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> string

            Return the brief name of the state that appears in the upper left
            corner of the viewer pane when this state is active.


        """
        return _hou.ViewerState_description(self)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> string

            Return the icon for the state that appears in the upper left corner
            of the viewer pane when this state is active.


        """
        return _hou.ViewerState_icon(self)

    def categories(
        self,
    ) -> (
        "std::vector< HOM_NodeTypeCategory *,std::allocator< HOM_NodeTypeCategory * > >"
    ):
        r"""

        categories(self) -> tuple of hou.NodeTypeCategory

            Return the node type category for the nodes that are associated with
            this state.


        """
        return _hou.ViewerState_categories(self)

    def nodeType(self) -> "HOM_NodeType *":
        r"""

        nodeType(self) -> hou.NodeType or None

            Return the node type associated with this state. May return None if
            this state is not associated with a particular node type, such as
            the SOP or Object View states which are used for panning and
            tumbling in a scene viewer pane.


        """
        return _hou.ViewerState_nodeType(self)

    def isHidden(self) -> "bool":
        return _hou.ViewerState_isHidden(self)

    def hotkey(self) -> "std::string":
        r"""

        hotkey(self) -> string

            Return the hotkey associated with this state.


        """
        return _hou.ViewerState_hotkey(self)

    def parmTemplates(self) -> "HOM_ParmTemplateGroup *":
        r"""

        parmTemplates(self) -> hou.ParmTemplateGroup

            Return the parameter templates associated with this state.


        """
        return _hou.ViewerState_parmTemplates(self)


# Register ViewerState in _hou:
_hou.ViewerState_swigregister(ViewerState)


class ViewerStateDragger(ViewerDragger):
    r"""

    hou.ViewerStateDragger

    Represents a dragger usable with Python viewer states.

    RELATED

        hou.ViewerStateContext hou.ViewerHandleDragger


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, name, xform=hou.Matrix4(1.0), inv_xform=hou.Matrix4(1.0))

            Creates a python state dragger object. The dragger can be set with
            transforms to correctly deal with coordinate space changes. See
            hou.ViewerDragger for more details on viewer draggers.


            name
                A name to identify the dragger.

            xform
                An optional transform used by the dragger to convert local
                coordinates to world space. Defaults to identity matrix.

            inv_xform
                An optional inverse transform used by the dragger to convert
                world coordinates to local space. Defaults to identity matrix.


        """
        _hou.ViewerStateDragger_swiginit(
            self, _hou.new_ViewerStateDragger(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_ViewerStateDragger

    def __repr__(self) -> "std::string":
        return _hou.ViewerStateDragger___repr__(self)

    def setTransform(self, xform: "Matrix4") -> "void":
        r"""

        setTransform(self, xform)

            Sets the transform matrix for this dragger.


            xform
                A hou.Matrix4 transformation matrix.


        """
        return _hou.ViewerStateDragger_setTransform(self, xform)

    def setInverseTransform(self, inv_xform: "Matrix4") -> "void":
        r"""

        setInverseTransform(self, inv_xform)

            Sets the inverse transform matrix for this dragger.


            inv_xform
                A hou.Matrix4 transformation matrix.


        """
        return _hou.ViewerStateDragger_setInverseTransform(self, inv_xform)

    def transform(self) -> "HOM_Matrix4":
        r"""

        transform(self): -> hou.Matrix4

            Returns the transform matrix of the dragger.


        """
        return _hou.ViewerStateDragger_transform(self)

    def inverseTransform(self) -> "HOM_Matrix4":
        r"""

        inverseTransform(self): -> hou.Matrix4

            Returns the inverse transform matrix of the dragger.


        """
        return _hou.ViewerStateDragger_inverseTransform(self)


# Register ViewerStateDragger in _hou:
_hou.ViewerStateDragger_swigregister(ViewerStateDragger)


class ViewerStateMenu(object):
    r"""

    hou.ViewerStateMenu

    Builds a context menu for a viewer state.

    OVERVIEW

        The ViewerStateMenu class lets you build a context menu for a viewer
        state. This class is also represents sub-menus of the top-level
        context menu.

        Currently you can add the following items to the menu

      * Toggle (checkbox) item: represents a setting you can turn on or off

      * Radio strip: represents a choice of several mutually exclusive
        items.

      * Action item: represents an action to preform. You implement the
        action in the state's onMenuAction method.

      * Separator item: creates a visual separation between groups of items
        in the menu.

        Hotkeys created with hou.hotkeys.addCommand can be added to toggle,
        action and radio strip menu items.

        See setting up viewer state context menus for more information.

        The following example shows how to implement and bind a menu to a
        sop viewer state.

      > from __future__ import print_function
      > import hou
      >
      >
      > class ExampleState(object):
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      >
      >     # the menu callback
      >     def onMenuAction(self, kwargs):
      >         action = kwargs[\"menu_item\"]
      >         if action == 'toggle1':
      >             print(\"Set toggle 1 to\", kwargs[\"toggle1\"])
      >
      >         elif action == 'toggle2':
      >             print(\"Set toggle 2 to\", kwargs[\"toggle2\"])
      >
      >         elif action == 'action':
      >             print(\"Chose action 1\")
      >
      >         elif action == 'radio_strip':
      >             print(\"Set the radio strip to\", kwargs[\"radio_strip\"])
      >
      >         elif action == 'submenu_toggle1':
      >             print(\"Set the submenu toggle to\", kwargs[\"submenu_toggle1\"])
      >
      >
      > def createViewerStateTemplate(state_type, state_label):
      >     template = hou.ViewerStateTemplate(
      >         state_type, state_label, hou.sopNodeTypeCategory()
      >     )
      >     template.bindFactory(ExampleState)
      >
      >     # create some hotkeys
      >     example_context = \"h.pane.gview.state.sop.example\"
      >     hou.hotkeys.addContext(example_context, \"Example Operation\", \"These keys apply to the Example operations\")
      >
      >     h1 = example_context + 'h1'
      >     hou.hotkeys.addCommand(h1, 'example 1', 'example 1')
      >     hou.hotkeys.addAssignment(h1, '1')
      >
      >     h2 = example_context + 'h2'
      >     hou.hotkeys.addCommand(h2, 'example 2', 'example 2')
      >     hou.hotkeys.addAssignment(h2, '2')
      >
      >     h3 = example_context + 'h3'
      >     hou.hotkeys.addCommand(h3, 'example 3', 'example 3')
      >     hou.hotkeys.addAssignment(h3, '3')
      >
      >     h4 = example_context + 'h3'
      >     hou.hotkeys.addCommand(h4, 'example 4', 'example 4')
      >     hou.hotkeys.addAssignment(h4, '4')
      >
      >     # define the state popupmenu
      >     m = hou.ViewerStateMenu('menu', 'Example')
      >
      >     m.addSeparator()
      >     m.addToggleItem( 'toggle1', 'Toggle1', True, hotkey=h1 )
      >     m.addToggleItem( 'toggle2', 'Toggle2', False )
      >     m.addSeparator()
      >     m.addActionItem( 'action', 'Action1', hotkey=h2 )
      >     m.addSeparator()
      >     m.addRadioStrip( 'radio_strip', 'Radio', \"radio_item1\" )
      >     m.addRadioStripItem( 'radio_strip', 'radio_item1', 'Radio1', hotkey=h3 )
      >     m.addRadioStripItem( 'radio_strip', 'radio_item2', 'Radio2', hotkey=h4 )
      >     m.addSeparator()
      >     subm = hou.ViewerStateMenu('submenu', 'More Example...')
      >     subm.addToggleItem( 'submenu_toggle1', 'Sub toggle1', True )
      >     m.addMenu( subm )
      >     m.addSeparator()
      >
      >     # attach popupmenu to state
      >     template.bindMenu(m)
      >
      >     return t


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, handle: "std::string const &", label: "std::string const &"):
        r"""

        __init__(self, id, label)

            Creates a hou.ViewerStateMenu object.


            id
                A unique string ID for the menu. This is not currently used for
                the top level state context menu.

            label
                The menu name as it will appear in the interface. This is not
                currently used for the top level state context menu.

          > # The ID and label for the top menu are not used, but you should give
          > # them meaningful values anyway
          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")

        """
        _hou.ViewerStateMenu_swiginit(self, _hou.new_ViewerStateMenu(handle, label))

    __swig_destroy__ = _hou.delete_ViewerStateMenu

    def __repr__(self) -> "std::string":
        return _hou.ViewerStateMenu___repr__(self)

    def addToggleItem(self, *args, **kwargs) -> "void":
        r"""

        addToggleItem(self, id, label, default, hotkey='' )

            Adds a toggle menu item to this menu.


            id
                A unique string ID for this item.

            label
                The menu item text as it will appear in the menu.

            default
                Whether the item is on or off by default when the menu is
                created.

            hotkey
                An optional hotkey ID string to associate with this menu item.
                You can use hou.hotkeys.addCommand to create a custom hotkey.

          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")
          > menu.addToggleItem(\"show_points\", \"Show Points\", True)
          > menu.addToggleItem(\"show_point_nums\", \"Show Point Numbers\", False

        """
        return _hou.ViewerStateMenu_addToggleItem(self, *args, **kwargs)

    def addActionItem(self, *args, **kwargs) -> "void":
        r"""

        addActionItem(self, id, label, hotkey='')

            Adds an action item to this menu.


            id
                A unique name to identify the menu item. When this item is
                chosen by the user, this ID will be passed to the onMenuAction
                method in the arguments dictionary as kwargs[\"menu_item\"].

            label
                Menu item label displayed in the menu.

            hotkey
                An optional hotkey ID string to associate with this menu item.
                You can use hou.hotkeys.addCommand to create a custom hotkey.

          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")
          > menu.addActionItem(\"delete\", \"Delete\")

        """
        return _hou.ViewerStateMenu_addActionItem(self, *args, **kwargs)

    def addSeparator(self) -> "void":
        r"""

        addSeparator(self)

            Adds a separator menu item.

          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")
          > menu.addActionItem(\"delete\", \"Delete\")
          > menu.addSeparator()
          > menu.addToggleItem(\"show_points\", \"Show Points\", True)
          > menu.addToggleItem(\"show_point_nums\", \"Show Point Numbers\", False)

        """
        return _hou.ViewerStateMenu_addSeparator(self)

    def addRadioStrip(
        self,
        handle: "std::string const &",
        label: "std::string const &",
        default_value: "std::string const &",
    ) -> "void":
        r"""

        addRadioStrip(self, id, label, default)

            Prepares the menu to accept a group of mutually exclusive radio
            button items.


            id
                A unique string ID for the strip. All menu items added to the
                group with addRadioStripItem() will have this string as their
                first argument.

            label
                A title displayed above the group in the menu.

            default
                A radio item id as specified with
                hou.ViewerStateMenu.addRadioStripItem representing the default
                choice when the menu is created.

          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")
          > menu.addRadioStrip(\"deform_type\", \"Deformation\", \"bend\")
          > menu.addRadioStripItem(\"deform_type\", \"bend\", \"Bend\")
          > menu.addRadioStripItem(\"deform_type\", \"squash\", \"Squash\")

        """
        return _hou.ViewerStateMenu_addRadioStrip(self, handle, label, default_value)

    def addRadioStripItem(self, *args, **kwargs) -> "void":
        r"""

        addRadioStripItem(self, strip_id, id, label, hotkey='')

            Adds an menu item to a radio strip menu.


            strip_id
                The string ID of the radio strip (created with addRadioStrip()).
                All items that share the same strip_id are mutually exclusive.

            id
                A unique string ID for this item.

            label
                The menu item text as it will appear in the menu.

            hotkey
                An optional hotkey ID string to associate with this menu item.
                You can use hou.hotkeys.addCommand to create a custom hotkey.

          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")
          > menu.addRadioStrip(\"deform_type\", \"Deformation\", \"bend\")
          > menu.addRadioStripItem(\"deform_type\", \"bend\", \"Bend\")
          > menu.addRadioStripItem(\"deform_type\", \"squash\", \"Squash\")

        """
        return _hou.ViewerStateMenu_addRadioStripItem(self, *args, **kwargs)

    def addMenu(self, sub_menu: "ViewerStateMenu") -> "void":
        r"""

        addMenu(self, submenu)

            Adds a ViewerStateMenu object as a submenu.

          > menu = hou.ViewerStateMenu(\"menu\", \"State Menu\")
          > menu.addActionItem(\"delete\", \"Delete\")
          > menu.addSeparator()
          > submenu = hou.ViwerStateMenu(\"options\", \"Options\")
          > submenu.addToggleItem(\"show_points\", \"Show Points\", True)
          > submenu.addToggleItem(\"show_point_nums\", \"Show Point Numbers\", False)
          > menu.addMenu(submenu)

        """
        return _hou.ViewerStateMenu_addMenu(self, sub_menu)


# Register ViewerStateMenu in _hou:
_hou.ViewerStateMenu_swigregister(ViewerStateMenu)


class ViewerStateTemplate(object):
    r"""

    hou.ViewerStateTemplate

    Contains attributes describing a custom viewer state (tool).

    Viewer states control interaction in the viewport. For example, the
    Rotate tool is a view state. The Handles tool allows access to the state
    associated with the current node. Houdini lets you create and register
    your own custom view states in Python.

    This object describes a custom state, including its implementation class
    and bindings (e.g. menus, handles, hotkeys, selectors, etc...). You
    supply an instance of this object when registering a custom state, and
    Houdini uses it to create concrete instances of the state.

    > import hou
    >
    > # Create a class implementing the state callbacks
    > class MyState(object):
    >     def __init__(self, state_name, scene_viewer):
    >         self.state_name = state_name
    >         self.scene_viewer = scene_viewer
    >
    >
    > # Create a template to describe the state and its bindings
    > template = hou.ViewerStateTemplate(
    >     \"mystate\", \"My Custom State\",
    >     hou.sopNodeTypeCategory()
    > )
    > template.bindFactory(MyState)
    > template.bindHandleStatic(
    >     \"rotate\", \"rot\",
    >     [(\"rx\", \"x\"), (\"ry\", \"y\"), (\"rz\", \"z\")]
    > )
    >
    > # Register the template with Houdini
    > hou.ui.registerViewerState(my_template)

    For information on how to create your own custom view states, see Python
    states.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        r"""

        __init__(self, state_name, state_label, node_type_category,
        contexts=None)

            Creates a new instance of ViewerStateTemplate representing a unique
            custom state type.

            ViewerStateTemplate is identified by a name and a category type. The
            name is the custom type of the state. The category specifies the
            context-level that Houdini uses to run the state. If you want your
            state to run across multiple context-levels, additional contexts can
            be added with the contexts parameter. Therefore, when the state is
            active and the user switches to a new context, Houdini will reuse
            the current state instance, provided the new context matches one of
            the state contexts.

            This example demonstrates how to register an OBJ state which can run
            in the SOP and CHOP contexts as well:

          > import hou
          >
          > # Create a class implementing the state callbacks
          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >
          > # Create a template to describe the state and its bindings
          > state_name = \"mystate\"
          > state_label = \"My Custom State\"
          > node_type_category = hou.objNodeTypeCategory()
          > extra_contexts = [hou.sopNodeTypeCategory(), hou.chopNodeTypeCategory()]
          > template = hou.ViewerStateTemplate(
          >     state_name, state_label, node_type_category, contexts=extra_contexts )
          > template.bindFactory(MyState)
          >
          > # Register the template with Houdini
          > hou.ui.registerViewerState(my_template)

            state_name
                A unique string to identify the viewer state.

            state_label
                A human-readable name for the state, for display in the user
                interface.

            node_type_category
                An instance of hou.NodeTypeCategory. For SOPs use the result of:

              > hou.sopNodeTypeCategory()

                For OBJ states use:

              > hou.objNodeTypeCategory()

                For LOP states use:

              > hou.lopNodeTypeCategory()

                For DOP states use:

              > hou.dopNodeTypeCategory()

            contexts
                A list of hou.NodeTypeCategory objects to specify additional
                context-levels for the state.

                Choose any of the following types to add to contexts:

              * hou.chopNodeTypeCategory

              * hou.cop2NodeTypeCategory

              * hou.dopNodeTypeCategory

              * hou.objNodeTypeCategory

              * hou.sopNodeTypeCategory

              * hou.topNodeTypeCategory

                Note: An exception will be thrown if unsupported types are used.
                Note: hou.lopNodeTypeCategory doesn't support extra contexts and
                cannot be used as such.


        """
        _hou.ViewerStateTemplate_swiginit(
            self, _hou.new_ViewerStateTemplate(*args, **kwargs)
        )

    __swig_destroy__ = _hou.delete_ViewerStateTemplate

    def __repr__(self) -> "std::string":
        return _hou.ViewerStateTemplate___repr__(self)

    def typeName(self) -> "std::string":
        r"""

        typeName(self) -> str

            Returns a unique string used to identify the viewer state.


        """
        return _hou.ViewerStateTemplate_typeName(self)

    def categoryName(self) -> "std::string":
        r"""

        categoryName(self) -> str

            Returns the name of the node type category of the state which you
            can use for creating the proper category object.


        """
        return _hou.ViewerStateTemplate_categoryName(self)

    def contexts(
        self,
    ) -> (
        "std::vector< HOM_NodeTypeCategory *,std::allocator< HOM_NodeTypeCategory * > >"
    ):
        r"""

        contexts(self) -> list of hou.NodeTypeCategory

            Returns the list of contexts in which the state can be used.


        """
        return _hou.ViewerStateTemplate_contexts(self)

    def bindParameter(self, *args, **kwargs) -> "void":
        r"""

        bindParameter(self, param_type, name=None, label=None,
        menu_as_button_strip=False, menu_items=[], num_components=1,
        default_value=None, min_limit=0, max_limit=1, align=False, toolbox=True)

            Creates a parameter template for a viewer state. The template
            describes a parameter with settings such as the name or the data it
            holds. See state parameters for more details on how to use them.


            align
                Specifies how the parameter is aligned in the Parameter Dialog.
                If True, the parameter is aligned horizontally with the next
                bound parameter. if False, the parameter is displayed below the
                previous one. Defaults to False.

            default_value
                The default value of the parameter. This is the value Houdini
                uses to initialize the parameter. The value type should ideally
                match param_type but Houdini will do its best to convert the
                type appropriately. Defaults to None.

                Parameter type

                Value type

                hou.parmTemplateType.Button

                The value is ignored.

                hou.parmTemplateType.Menu

                Menu item identifier as defined with menu_items.

                hou.parmTemplateType.Toggle

                Toggle state as a bool or int.

            name
                The parameter string identifier. The name cannot be empty and
                must be unique within the state or an exception is raised.

            label
                The parameter label. If sets to None (default), the label is set
                with the parameter name.

            menu_as_button_strip
                If True, the hou.parmTemplateType.Menu parameter is set to use a
                button strip widget to display the menu items. Buttons are
                displayed with the menu item icons, if any, or with the menu
                item labels otherwise. menu_as_button_strip defaults to False
                and is ignored for other types.

            menu_items
                A list of string tuples for defining the items of a
                hou.parmTemplateType.Menu parameter. menu_items is ignored for
                other parameter types.

                The tuple can contain 2 or 3 elements:

              * Item 0: the menu item identifier.

              * Item 1: the menu item label.

              * Item 2: the menu item icon name (optional).

            min_limit
                Describes the minimum value the parameter can be set in the UI
                dialog. Defaults to 0. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            max_limit
                Describes the maximum value the parameter can be set in the UI
                dialog. Defaults to 1. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            num_components
                Specifies the number of components to create for the parameter
                template. Defaults to 1. Exceptions are raised if the value is
                invalid.

                num_components > 1 is supported for the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.String

            param_type
                The type of parameter to bind. The following types are
                supported:

              * hou.parmTemplateType.Button

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.Menu

              * hou.parmTemplateType.Separator

              * hou.parmTemplateType.String

              * hou.parmTemplateType.Toggle

                An exception is raised for other types.

            toolbox
                The parameter is always displayed in the Parameter Dialog but
                you can set this flag to display the parameter in the Operation
                Toolbox as well.


        """
        return _hou.ViewerStateTemplate_bindParameter(self, *args, **kwargs)

    def bindHandle(self, *args, **kwargs) -> "void":
        r"""

        bindHandleStatic(self, handle_type, name, bindings, settings=None)

            Binds a handle to the node parameters driven by the viewer state.
            Dragging the handle will automatically update the bound
            parameter(s). See also bindHandle().


            handle_type
                A string naming the type of handle.

            name
                A unique string to use to identify the handle. Each binding's
                name must be unique within this state. Trying to bind the same
                name more than once will raise an exception.

            bindings
                A list of (\"node_parm_name\", \"handle_parm_name\") tuples. This
                binds the parts of the handle to individual parameters on the
                node.

            settings
                A string containing specific settings of a handle. Multiple
                settings must be space separated.

          > t = hou.ViewerStateTemplate('my_state', 'my_state_label', hou.sopNodeTypeCategory())
          > ...
          > t.bindHandleStatic( 'vector', 'Up Direction',
          >     [
          >                     ('group', 'input'),
          >                     ('originx', 'tx'),
          >                     ('originy', 'ty'),
          >                     ('originz', 'tz'),
          >                     ('upx', 'vx'),
          >                     ('upy', 'vy'),
          >                     ('upz', 'vz')
          >     ]
          > )

        """
        return _hou.ViewerStateTemplate_bindHandle(self, *args, **kwargs)

    def bindHandleStatic(self, *args, **kwargs) -> "void":
        return _hou.ViewerStateTemplate_bindHandleStatic(self, *args, **kwargs)

    def bindGadget(self, *args, **kwargs) -> "void":
        r"""

        bindGadget(self, drawable_type, gadget_name, gadget_label=None)

            Lets you bind a gadget drawable to a viewer state. A gadget is a
            special geometry drawable which provides visual interaction support
            for picking and locating the underlying gadget's geometry.

            Houdini uses the binding info to create the gadget drawable
            instances, you don't create objects of this type by yourself. The
            gadget instances are stored in a dictionary, accessible with the
            state_gadgets class attribute. Use the gadget name to query
            self.state_gadgets for a specific gadget.


            NOTE
                self.state_gadgets cannot not be accessed from the class
                __init__ method, but you can use it however from any other class
                methods.

            Houdini provides the picking and locating support, you don't have to
            implement anything specific to locate or pick a gadget component.
            hou.ViewerStateContext is used by Houdini to store the active gadget
            picking and locating information, this context is created by Houdini
            and accessible with the state_context class attribute.

          > import viewerstate.utils as su
          >
          > def createViewerStateTemplate():
          >
          >     state_typename = \"state gadgets\"
          >     state_label = \"State gadgets\"
          >     state_cat = hou.sopNodeTypeCategory()
          >
          >     template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
          >     template.bindFactory(State)
          >     template.bindIcon(kwargs[\"type\"].icon())
          >
          >     template.bindGadget( hou.drawableGeometryType.Line, \"line_gadget\", label=\"Line\" )
          >     template.bindGadget( hou.drawableGeometryType.Face, \"face_gadget\", label=\"Face\" )
          >     template.bindGadget( hou.drawableGeometryType.Point, \"point_gadget\", label=\"Point\" )
          >
          >     return template
          >
          > class State(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >         self.cursor = su.CursorLabel(scene_viewer)
          >
          > def onEnter(self, kwargs):
          >     \"\"\" Initializes the gadget drawables and assign them to class
          >         attributes.
          >     \"\"\"
          >     node = kwargs[\"node\"]
          >     self.geometry = node.geometry()
          >
          >     self.line_gadget = self.state_gadgets[\"line_gadget\"]
          >     self.line_gadget.setGeometry(self.geometry)
          >     self.line_gadget.setParams({\"draw_color\":[.3,0,0,1], \"locate_color\":[1,0,0,1], \"pick_color\":[1,1,0,1],
          >         \"line_width\":2.0})
          >     self.line_gadget.show(True)
          >
          >     self.face_gadget = self.state_gadgets[\"face_gadget\"]
          >     self.face_gadget.setGeometry(self.geometry)
          >     self.face_gadget.setParams({\"draw_color\":[0,.3,0,1], \"locate_color\":[1,0,0,1],\"pick_color\":[1,1,0,1]})
          >     self.face_gadget.show(True)
          >
          >     self.point_gadget = self.state_gadgets[\"point_gadget\"]
          >     self.point_gadget.setGeometry(self.geometry)
          >     self.point_gadget.setParams({\"draw_color\":[0,0,.3,1], \"locate_color\":[0,0,1,1], \"pick_color\":[1,1,0,1],
          >         \"radius\":15.0})
          >     self.point_gadget.show(True)
          >
          > def onMouseEvent(self, kwargs):
          >     \"\"\" Computes the cursor text position and drawable geometry
          >     \"\"\"
          >     # init the cursor with the mouse kwargs
          >     self.cursor.setParams(kwargs)
          >
          >     # Use the active gadget information to set the cursor label.
          >     gadget_name = self.state_context.gadget()
          >     if gadget_name in [\"line_gadget\", \"face_gadget\", \"point_gadget\"]:
          >         gadget = self.state_gadgets[gadget_name]
          >
          >         label = self.state_context.gadgetLabel()
          >         c1 = self.state_context.component1()
          >         c2 = self.state_context.component2()
          >
          >         self.cursor.setLabel(\"{} : {} {}\".format(label, c1, c2 if c2 > -1 else \"\"))
          >         self.cursor.show(True)
          >     else:
          >         self.cursor.show(False)
          >
          >     return True
          >
          > def onDraw( self, kwargs ):
          >     handle = kwargs[\"draw_handle\"]
          >     self.line_gadget.draw(handle)
          >     self.face_gadget.draw(handle)
          >     self.point_gadget.draw(handle)

            geometry_drawable_type
                The gadget geometry type. The following types are supported:

              * hou.drawableGeometryType.Face

              * hou.drawableGeometryType.Line

              * hou.drawableGeometryType.Point

            gadget_name
                The gadget name string identifier.

            gadget_label
                An optional description name. Defaults to None.


        """
        return _hou.ViewerStateTemplate_bindGadget(self, *args, **kwargs)

    def bindGeometrySelector(self, *args, **kwargs) -> "void":
        r"""

        bindGeometrySelector(self, prompt, allow_drag=False, quick_select=True,
        auto_start=True, toolbox=True, use_existing_selection=True,
        consume_selection=True, secure_selection=hou.secureSelectionOption.Obey,
        initial_selection=\"\",
        initial_selection_type=hou.geometryType.Primitives, ordered=False,
        geometry_types=[], primitive_types=[], allow_other_sops=False,
        hotkey=\"\", name=\"\")

            Binds a geometry selector to a SOP viewer state. This selector is
            used for selecting geometry elements when the underlying viewer
            state is active. This selector can only be used in a scene viewer,
            exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple geometry selectors can be bound to a viewer state. However,
            other selector types cannot be mixed, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a
            hou.GeometrySelection stored in the selection entry of the input
            kwargs dictionary. The return value can be True to stop the
            selection tool or False to keep it running. Pressing [Enter] also
            terminates the selector.


            allow_drag
                Determines whether selecting a component with a single mouse
                click completes the selection. This is typically used to prevent
                a multiple component selection. Defaults to False.

            allow_other_sops
                Allow selecting components on geometry from other geometry nodes
                visible in the viewport. Defaults to False.

            auto_start
                If True (the default), starts the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            consume_selection
                If True (default), clears the current selection when the
                selector is deactivated.

            geometry_types
                An array of hou.geometryType values representing the component
                types the user can select. The default is an empty list, the
                selector follows the Geometry Select Mode.

            hotkey
                An optional hotkey which acts as a switch for starting or
                stopping the selector. The default is an empty string.

            initial_selection
                When use_existing_selection is False, this is a string of
                component group syntax representing what to set the selection to
                when the state is activated. The default is no selection.

            initial_selection_type
                A hou.geometryType value, representing the type of components
                specified by the initial_selection argument. The default is
                None, the selector follows the Geometry Select Mode.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            ordered
                If this is True, Houdini returns the components in the selection
                in the order the user selected them. The default is False,
                meaning the order of the components you get is unrelated to the
                order they were selected.

                Only set this to True if for some reason you need to
                distinguish, for example, the first primitive the user clicked,
                or the last, or that kind of thing.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            primitive_types
                A list of hou.primType values representing the primitive types
                the user can select. An empty list (default) allows selecting
                all types.

            quick_select
                If this is True, the state's selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer's secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.


        """
        return _hou.ViewerStateTemplate_bindGeometrySelector(self, *args, **kwargs)

    def bindObjectSelector(self, *args, **kwargs) -> "void":
        r"""

        bindObjectSelector(self, prompt, quick_select=True, auto_start=True,
        toolbox=True, use_existing_selection=True, allow_multisel=True,
        secure_selection=hou.secureSelectionOption.Obey, allowed_types=('*',),
        hotkey=\"\", name=\"\")

            Binds an object selector to a OBJ viewer state. This selector is
            used for selecting objects when the underlying viewer state is
            active. This selector can only be used in a scene viewer, exception
            is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple object selectors can be bound to a viewer state. However,
            other selector types cannot be mixed with OBJ selectors, exception
            is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of hou.Node objects stored in the selection entry of the input
            kwargs dictionary. The return value can be True to stop the
            selection tool or False to keep it running. Pressing [Enter] also
            terminates the selector.


            allowed_types
                A list of strings to specify one or multiple object types the
                user can select. For instance, add geo to allowed_types to
                select geometry objects only. Patterns such as * can be used to
                select any objects or more restrictive patterns such as *cam*
                for selecting any camera objects. All available object types can
                be obtained with hou.objNodeTypeCategory.nodeTypes. Defaults to
                *.

            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey which acts as a switch for starting or
                stopping the selector. The default is None.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state's selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection. Defaults to True.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer's secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection. Defaults to True.


        """
        return _hou.ViewerStateTemplate_bindObjectSelector(self, *args, **kwargs)

    def bindSceneGraphSelector(self, *args, **kwargs) -> "void":
        r"""

        bindSceneGraphSelector(self, prompt, allow_drag=True, quick_select=True,
        auto_start=True, toolbox=True, use_existing_selection=True,
        secure_selection=hou.secureSelectionOption.Obey,
        consume_selection=False, allow_multisel=True,
        prior_selection_paths=None, prim_mask=None, path_prefix_mask=None,
        prim_kind=None, hotkey=\"\", name=\"\")

            Binds a scene graph selector to a SOP viewer state. This selector is
            used for selecting scene graph elements when the underlying viewer
            state is active. This selector can only be bound used in a scene
            graph viewer, exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple scene graph selectors can be bound to a viewer state.
            However, other selector types cannot be mixed with scene graph
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of element paths stored in the selection entry of the input kwargs
            dictionary. The return value can be True to keep running the
            selection tool or False to stop it. Pressing [Enter] also terminates
            the selector.


            allow_drag
                Allows the selection to be completed with a single mouse click.
                Defaults to True.

            allow_multisel
                Allows the tool to select multiple elements. Defaults to True.

            auto_start
                Start the selector when the viewer state is activated. True by
                default.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            consume_selection
                If True, clears the current selection when the selector is
                deactivated. Defaults to False.

            hotkey
                An optional hotkey which acts as a toggle switch for starting or
                stopping the selector. No hotkey by default.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            path_prefix_mask
                Filter out selectable elements by a name prefix. Empty by
                default.

            prim_kind
                Primitive kind to highlight. Empty by default.

            prim_mask
                Filter mask for the selection (hou.scenePrimMask). Defaults to
                hou.scenePrimMask.ViewerSetting

            prior_selection_paths
                Array of element paths to pre-select.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                Configure the selector to use quick selections. When True the
                selection callback is called automatically for each selection,
                if False the user must hit 'enter' to complete the selection.
                Defaults to True.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer's secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If True, the selector uses the existing selection. Defaults to
                True.


        """
        return _hou.ViewerStateTemplate_bindSceneGraphSelector(self, *args, **kwargs)

    def bindDynamicsSelector(self, *args, **kwargs) -> "void":
        r"""

        bindDynamicsSelector(self, prompt, allow_objects=True,
        allow_modifiers=False, quick_select=True, auto_start=True, toolbox=True,
        use_existing_selection=True,
        secure_selection=hou.secureSelectionOption.Obey, allow_multisel=True,
        hotkey=\"\", name=\"\")

            Binds a dynamics selector to a DOP viewer state. This selector is
            used for selecting dynamics objects and modifiers when the
            underlying viewer state is active. This selector can only be used in
            a scene viewer, exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple dynamics, point and polygon selectors can be bound to a
            viewer state. However, other selector types cannot be mixed with DOP
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of hou.DopData objects stored in the selection entry of the input
            kwargs dictionary. The return value can be True to stop the
            selection tool or False to keep it running. Pressing [Enter] also
            terminates the selector.


            allow_modifiers
                Allows the tool to select simulation modifiers. Exception is
                thrown if allow_modifiers and allow_objects are both set to
                False. Default to False.

            allow_multisel
                Allows the tool to select multiple elements. Defaults to True.

            allow_objects
                Allows object selection. Exception is thrown if allow_modifiers
                and allow_objects are both set to False. Defaults to True.

            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey which acts as a switch for starting or
                stopping the selector. The default is None.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state's selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer's secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.


        """
        return _hou.ViewerStateTemplate_bindDynamicsSelector(self, *args, **kwargs)

    def bindDynamicsPointSelector(self, *args, **kwargs) -> "void":
        r"""

        bindDynamicsPointSelector(self, prompt, allow_objects=True,
        allow_modifiers=False, quick_select=True, auto_start=True, toolbox=True,
        use_existing_selection=True,
        secure_selection=hou.secureSelectionOption.Obey, allow_multisel=True,
        only_select_points=True, object_based_point_selection=False,
        use_last_selected_object=False, hotkey=\"\", name=\"\")

            Binds a dynamics point selector to a DOP viewer state. This selector
            is used for selecting point elements when the underlying viewer
            state is active. This selector can only be used in a scene viewer,
            exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple dynamics, polygon and point selectors can be bound to a
            viewer state. However, other selector types cannot be mixed with DOP
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of (hou.DopData,hou.GeometrySelection) tuples stored in the
            selection entry of the input kwargs dictionary. The return value can
            be True to stop the selection tool or False to keep it running.
            Pressing [Enter] also terminates the selector.


            allow_modifiers
                Allows the tool to select simulation modifiers. Default to
                False.

            allow_multisel
                Allows the tool to select multiple elements. Defaults to True.

            allow_objects
                Allows object selection. Defaults to True.

            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey which acts as a switch for starting or
                stopping the selector. The default is None.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            object_based_point_selection
                Force selection of points on the currently selected object
                instead of the default selection of points on the closest
                object. Default to False.

            only_select_points
                Default to True.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state's selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer's secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.

            use_last_selected_object
                Force point selection to only be possible on the specified
                object and do not allow selection of a different object. Default
                to False.


        """
        return _hou.ViewerStateTemplate_bindDynamicsPointSelector(self, *args, **kwargs)

    def bindDynamicsPolygonSelector(self, *args, **kwargs) -> "void":
        r"""

        bindDynamicsPolygonSelector(self, prompt, quick_select=True,
        auto_start=True, toolbox=True, use_existing_selection=True,
        object_based_point_selection=False,
        secure_selection=hou.secureSelectionOption.Obey,
        use_last_selected_object=False, hotkey=\"\", name=\"\")

            Binds a dynamics polygon selector to a DOP viewer state. This
            selector is used for selecting polygon elements when the underlying
            viewer state is active. This selector can only be used in a scene
            viewer, exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple dynamics, point and polygon selectors can be bound to a
            viewer state. However, other selector types cannot be mixed with DOP
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of (hou.DopData,hou.GeometrySelection) tuples stored in the
            selection entry of the input kwargs dictionary. The return value can
            be True to stop the selection tool or False to keep it running.
            Pressing [Enter] also terminates the selector.


            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey which acts as a switch for starting or
                stopping the selector. The default is None.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            object_based_point_selection
                Force selection of points on the currently selected object
                instead of the default selection of points on the closest
                object. Default to False.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state's selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer's secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.

            use_last_selected_object
                Force polygon selection to only be possible on the specified
                object and do not allow selection of a different object. Default
                to False.


        """
        return _hou.ViewerStateTemplate_bindDynamicsPolygonSelector(
            self, *args, **kwargs
        )

    def bindDrawableSelector(self, *args, **kwargs) -> "void":
        r"""

        bindDrawableSelector(self, prompt, auto_start=True, toolbox=True,
        drawable_mask=[], hotkey=\"\", name=\"\")

            Binds a drawable selector to a viewer state to select drawable
            components such as points, faces and lines. Drawable selectors are
            supported for the SOP, OBJ and LOP contexts. The selector selects
            components of drawables created by the viewer state, a mask can be
            used to make specific drawables selectable. Drawables created by the
            viewer state not in the mask are ignored by the selector.

            A selection event is triggered whenever the selection changes, the
            onSelection handler can be implemented by the viewer state plug-in
            to receive new selections. The locate information is sent to the
            viewer state whenever the mouse is positioned over drawable
            components, the onLocateSelection handler can be implemented by the
            viewer state plug-in to receive new drawable locate information. The
            viewer state typically uses these handlers for drawing the located
            and selected drawable components. See Binding a drawable selector
            for more details.


            auto_start
                If True (the default), starts the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey which acts as a switch for starting or
                stopping the selector. The default is an empty string.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            drawable_mask
                A list of drawable names representing selectable drawables. By
                default (empty list) all drawables created by a python state are
                selectable.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.


        """
        return _hou.ViewerStateTemplate_bindDrawableSelector(self, *args, **kwargs)

    def bindSelector(self, *args, **kwargs) -> "void":
        r"""

        bindSelector(self, name, selector_type, prompt, primitive_types=None,
        group_parm_name=None, input_index=0, input_required=True,
        allow_dragging=True)

            Binds a selector to the digital asset tied to this viewer state. You
            can bind multiple selectors to the same viewer state.

            These selectors are typically used by the shelf tool of the digital
            asset to create new instances of the SOP nodes. Houdini will invoke
            all bounded selectors, wait for the user to select geometries, and
            then connect the input SOPs and fill in group parameters to match
            what was selected.

            This kind of selector is different from the ones created with
            hou.ViewerStateTemplate.bindGeometrySelector or
            hou.ViewerStateTemplate.bindObjectSelector. They are strictly used
            by Houdini and cannot be triggered with
            hou.SceneViewer.triggerStateSelector.


            name
                A unique selector name identifier.

            selector_type
                The type of the selector to bind. The following types are
                supported:

                prims

                Select only primitives.

                points

                Select only points.

                edges

                Select only edges.

                everything

                Select any geometries.

            prompt
                Prompt displayed in the viewport to instruct the user what to
                select. The prompt is mandatory.

            primitive_types
                Specify the type of selectable primitives (hou.primType).
                Defaults to all types.

            group_parm_name
                The name of the SOP node parameter containing the group field.
                The selector will set this parameter to the string representing
                the points, primitives, edges, etc. chosen by the user in the
                viewer. If None, the selector will look for a parameter named
                group.

            input_index
                The index of the input connector on the SOP node where the
                selector should wire input SOPs. A cookie SOP, for example, has
                two input connectors. It has two selectors, one for each input
                connector. Defaults to 0.

            input_required
                Specify if an input is required or not. If the user does not
                select any geometry and the input is not required, the selector
                will not wire anything to its input connector. Defaults to True.

            allow_dragging
                Determines if click-and-drag operations are allowed. Click-and-
                drag operations select the geometry and begin manipulating the
                handles with a single mouse drag. Dragging the geometry forces
                the selector to finish immediately, the selector connects the
                input and sets the group parameter, and subsequent mouse
                movements are passed to the handle which translates the geometry
                by changing parameter values. Defaults to True.


        """
        return _hou.ViewerStateTemplate_bindSelector(self, *args, **kwargs)

    def bindMenu(self, menu: "ViewerStateMenu") -> "void":
        return _hou.ViewerStateTemplate_bindMenu(self, menu)

    def bindIcon(self, name: "std::string const &") -> "void":
        r"""

        bindIcon(self, icon_name)

            Sets the icon image of this viewer state.


            icon_name
                The name of the icon. Defaults to MISC_python. The icon name can
                be specified as follows:

              * As a single name.

              * As a path to the image icon file on disk. There is no convention
                for where to put icon files on disk.

                    eg.

                  > template.bindIcon(\"$HOUDINI_USER_PREF_DIR/config/Icons/myicon.pic\")

              * As an opdef path if the viewer state is implemented in a Digital
                Asset.

                    eg.

                  > template.bindIcon(\"opdef:/Object/myop?myicon.pic\")

        """
        return _hou.ViewerStateTemplate_bindIcon(self, name)

    def bindSupportsSelectionChange(self, supports_change: "bool") -> "void":
        r"""

        bindSupportsSelectionChange(self, supports_change)

            Indicates to the LOP Viewer pane that this state can handle USD
            primitive selection changes. The state for the Edit LOP is a good
            example of such a state. Changing the primitive selection in the
            scene graph tree causes this node to move the handle to the new
            selection's centroid and start manipulating the newly selected
            primitives.


        """
        return _hou.ViewerStateTemplate_bindSupportsSelectionChange(
            self, supports_change
        )

    def bindSupportsMoveTool(self, supports_movetool: "bool") -> "void":
        r"""

        bindSupportsMoveTool(self, supports_movetool)

            Indicates to the LOP Viewer pane that this state can provide a move
            tool for the currently selected primitives. The state for the Edit
            LOP is a good example of such a state.


        """
        return _hou.ViewerStateTemplate_bindSupportsMoveTool(self, supports_movetool)

    def bindPlaybackChangeEvent(self) -> "void":
        r"""

        bindPlaybackChangeEvent(self)

            Binds an event handler to the state for listening to playbar events
            such as hou.playbarEvent.Started and hou.playbarEvent.FrameChanged.
            The state must implement onPlaybackChangeEvent to respond to
            playback events. bindPlaybackChangeEvent is similar to
            hou.playbar.addEventCallback` but you don't need to provide a
            callback or to remove it when the state exits, Houdini takes care of
            it for you.


        """
        return _hou.ViewerStateTemplate_bindPlaybackChangeEvent(self)

    def bindNodeChangeEvent(self, event_types: "_EnumTuple") -> "void":
        r"""

        bindNodeChangeEvent(self, event_types)

            Binds an event handler to the state for listening to a particular
            event that occurs on the state's node instance. onNodeChangeEvent
            must be implemented by the state to respond to events.

            Binding a node event is similar to hou.Node.addEventCallback, but
            there is no need to provide a callback or to remove it by yourself
            when the state exits, Houdini takes care of it for you.


            event_types
                A list of hou.nodeEventType enumeration values describing the
                event types to listen to.

                An error is raised if the list is empty.


        """
        return _hou.ViewerStateTemplate_bindNodeChangeEvent(self, event_types)

    def bindNodeParmChangeEvent(self, parm_names: "_StringTuple") -> "void":
        r"""

        bindNodeParmChangeEvent(self, parm_names)

            Binds an event handler to the state for listening to parm changes
            occuring on the state's node. onNodeChangeEvent must be implemented
            by the state to respond to parm events. This method is similar to
            hou.Node.addParmCallback, it's considered more efficient than
            bindNodeChangeEvent as Houdini will trigger onNodeChangeEvent only
            for the changes that occurs for the parms you want to track.


            parm_names
                A list of node parm names used by Houdini for filtering out the
                parm changes that occur on the state's node. Only the changes
                that match the parms specified in parm_names are sent to
                onNodeChangeEvent.

                An error is raised if the list is empty.


        """
        return _hou.ViewerStateTemplate_bindNodeParmChangeEvent(self, parm_names)

    def bindFactory(self, callback: "InterpreterObject") -> "void":
        r"""

        bindFactory(self, callable)

            Takes a callable object (such as a class or function) that returns
            an implementation of the state interface. Usually this will be a
            class (a Python class is a callable object which returns an instance
            of the class). The callable should accept two arguments: a string
            containing the name of the state, and a hou.SceneViewer object
            representing the current viewer.

          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >
          >     def onMouseEvent(sefl, kwargs):
          >         ui_event = kwargs[\"ui_event\"]
          >
          >
          > def createViewerTemplate(*args):
          >     template = hou.ViewerStateTemplate(\"mystate\", \"My State\", hou.sopNodeTypeCategory())
          >     template.bindFactory(MyState)
          >     return template

        """
        return _hou.ViewerStateTemplate_bindFactory(self, callback)


# Register ViewerStateTemplate in _hou:
_hou.ViewerStateTemplate_swigregister(ViewerStateTemplate)


class ViewportVisualizer(object):
    r"""

    hou.ViewportVisualizer

    Represents a viewport visualizer.

    You can create a new visualizer by calling
    hou.viewportVisualizers.createVisualizer. You can get a list of
    registered visualizers by calling hou.viewportVisualizers.visualizers.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ViewportVisualizer

    def __eq__(self, visualizer: "HOM_PtrOrNull< HOM_ViewportVisualizer >") -> "bool":
        return _hou.ViewportVisualizer___eq__(self, visualizer)

    def __ne__(self, visualizer: "HOM_PtrOrNull< HOM_ViewportVisualizer >") -> "bool":
        return _hou.ViewportVisualizer___ne__(self, visualizer)

    def __repr__(self) -> "std::string":
        return _hou.ViewportVisualizer___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> string

            Return the visualizer's unique identifier.


        """
        return _hou.ViewportVisualizer_name(self)

    def setName(self, name: "char const *") -> "void":
        r"""

        setName(self, name)

            Set the visualizer's unique identifier.


        """
        return _hou.ViewportVisualizer_setName(self, name)

    def label(self) -> "std::string":
        r"""

        label(self) -> string

            Return the visualizer's user-friendly label.


        """
        return _hou.ViewportVisualizer_label(self)

    def setLabel(self, label: "char const *") -> "void":
        r"""

        setLabel(self, label)

            Set the visualizer's user-friendly label.


        """
        return _hou.ViewportVisualizer_setLabel(self, label)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> string

            Return the name of the visualizer's icon.


        """
        return _hou.ViewportVisualizer_icon(self)

    def setIcon(self, icon: "char const *") -> "void":
        r"""

        setIcon(self, icon)

            Set the visualizer's icon. icon must be the icon name.


        """
        return _hou.ViewportVisualizer_setIcon(self, icon)

    def isActive(self, viewport: "GeometryViewport" = None) -> "bool":
        r"""

        isActive(self, viewport=None) -> bool

            If this is a Common or Scene visualizer then return True if it is
            active for the specified viewport or False otherwise. The viewport
            argument must be a hou.GeometryViewport object.

            If this is a Node visualizer then return True if it is active for
            all viewports and False otherwise.

            Raise TypeError if this is a Node visualizer and the viewport
            argument is not None. Node visualizers are either active in all
            viewports or none of them. They cannot be activated for a specific
            viewport.

            Raise TypeError if this is either a Common or Scene visualizer and
            the viewport argument is None.


        """
        return _hou.ViewportVisualizer_isActive(self, viewport)

    def setIsActive(self, on: "bool", viewport: "GeometryViewport" = None) -> "void":
        r"""

        setIsActive(self, on, viewport=None)

            If this is a Common or Scene visualizer then set whether it is
            active or not for a specified viewport. The viewport argument must
            be a hou.GeometryViewport object.

            If this is a Node visualizer then set whether it is active or not
            for all viewports.

            Raise TypeError if this is a Node visualizer and the viewport
            argument is not None. Node visualizers are either active in all
            viewports or none of them. They cannot be activated for a specific
            viewport.

            Raise TypeError if this is either a Common or Scene visualizer and
            the viewport argument is None.


        """
        return _hou.ViewportVisualizer_setIsActive(self, on, viewport)

    def type(self) -> "HOM_ViewportVisualizerType *":
        r"""

        type(self) -> hou.ViewportVisualizerType

            Return the visualizer's type.


        """
        return _hou.ViewportVisualizer_type(self)

    def setType(self, type: "ViewportVisualizerType") -> "void":
        r"""

        setType(self, type)

            Sets the visualizer's type. This essentially recreates the
            visualizer and rebuilds its customizable parameters. Call
            hou.ViewportVisualizer.parmNames to get a list of the parameters.


        """
        return _hou.ViewportVisualizer_setType(self, type)

    def category(self) -> "HOM_EnumValue &":
        r"""

        category(self) -> hou.viewportVisualizerCategory

            Return the category that the visualizer belongs to.


        """
        return _hou.ViewportVisualizer_category(self)

    def categoryNode(self) -> "HOM_Node *":
        r"""

        categoryNode(self) -> hou.Node

            Return the node that the visualizer is installed on. This only
            applies if the visualizer belongs to the Node category.

            Return None if the visualizer belongs to either the Common or Scene
            category.


        """
        return _hou.ViewportVisualizer_categoryNode(self)

    def scope(self) -> "HOM_EnumValue &":
        r"""

        scope(self) -> hou.viewportVisualizerScope

            Return the scope of geometries that the visualizer affects.


        """
        return _hou.ViewportVisualizer_scope(self)

    def setScope(self, scope: "EnumValue") -> "void":
        r"""

        setScope(self, scope)

            Set the scope of geometries that the visualizer affects.

            This method does nothing if the visualizer belongs to the Common or
            Scene because the scope is always global.


        """
        return _hou.ViewportVisualizer_setScope(self, scope)

    def isShownInToolbar(self) -> "bool":
        r"""

        isShownInToolbar(self) -> bool

            Return True if the visualizer appears in the viewer pane's toolbar.
            Return False otherwise.


        """
        return _hou.ViewportVisualizer_isShownInToolbar(self)

    def showInToolbar(self, on: "bool") -> "void":
        r"""

        showInToolbar(self, on)

            Set whether the visualizer appears in the viewer pane's toolbar.


        """
        return _hou.ViewportVisualizer_showInToolbar(self, on)

    def isActiveWhenUnselected(self) -> "bool":
        r"""

        isActiveWhenUnselected(self) -> bool

            Return True if the visualizer is applied when the geometry is
            unselected. Return False otherwise.


        """
        return _hou.ViewportVisualizer_isActiveWhenUnselected(self)

    def setIsActiveWhenUnselected(self, on: "bool") -> "void":
        r"""

        setIsActiveWhenUnselected(self, on)

            Set whether the visualizer is applied when the geometry is
            unselected.


        """
        return _hou.ViewportVisualizer_setIsActiveWhenUnselected(self, on)

    def isActiveWhenSelected(self) -> "bool":
        r"""

        isActiveWhenSelected(self) -> bool

            Return True if the visualizer is applied when the geometry is
            selected. Return False otherwise.


        """
        return _hou.ViewportVisualizer_isActiveWhenSelected(self)

    def setIsActiveWhenSelected(self, on: "bool") -> "void":
        r"""

        setIsActiveWhenSelected(self, on)

            Set whether the visualizer is applied when the geometry is selected.


        """
        return _hou.ViewportVisualizer_setIsActiveWhenSelected(self, on)

    def isActiveWhenGhosted(self) -> "bool":
        r"""

        isActiveWhenGhosted(self) -> bool

            Return True if the visualizer is applied when the geometry is
            ghosted. Return False otherwise.


        """
        return _hou.ViewportVisualizer_isActiveWhenGhosted(self)

    def setIsActiveWhenGhosted(self, on: "bool") -> "void":
        r"""

        setIsActiveWhenGhosted(self, on)

            Set whether the visualizer is applied when the geometry is ghosted.


        """
        return _hou.ViewportVisualizer_setIsActiveWhenGhosted(self, on)

    def isActiveWhenDisplayed(self) -> "bool":
        r"""

        isActiveWhenDisplayed(self) -> bool

            Return True if the visualizer is applied when the geometry is
            displayed. Return False otherwise.


        """
        return _hou.ViewportVisualizer_isActiveWhenDisplayed(self)

    def setIsActiveWhenDisplayed(self, on: "bool") -> "void":
        r"""

        setIsActiveWhenDisplayed(self, on)

            Set whether the visualizer is applied when the geometry is
            displayed.


        """
        return _hou.ViewportVisualizer_setIsActiveWhenDisplayed(self, on)

    def isActiveWhenCurrent(self) -> "bool":
        r"""

        isActiveWhenCurrent(self) -> bool

            Return True if the visualizer is applied when the geometry is the
            current geometry. Return False otherwise.


        """
        return _hou.ViewportVisualizer_isActiveWhenCurrent(self)

    def setIsActiveWhenCurrent(self, on: "bool") -> "void":
        r"""

        setIsActiveWhenCurrent(self, on)

            Set whether the visualizer is applied when the geometry is the
            current geometry.


        """
        return _hou.ViewportVisualizer_setIsActiveWhenCurrent(self, on)

    def isActiveWhenTemplated(self) -> "bool":
        r"""

        isActiveWhenTemplated(self) -> bool

            Return True if the visualizer is applied when the geometry is
            templated.


        """
        return _hou.ViewportVisualizer_isActiveWhenTemplated(self)

    def setIsActiveWhenTemplated(self, on: "bool") -> "void":
        r"""

        setIsActiveWhenTemplated(self, on)

            Set whether the visualizer is applied when the geometry is
            templated.


        """
        return _hou.ViewportVisualizer_setIsActiveWhenTemplated(self, on)

    def parmNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        parmNames(self) -> tuple of string

            Return a tuple of the visualizer's customizable parameters. Note
            that the parameters can change when either the visualizer's type
            changes or one of the parameters changes (for example changing the
            Color Type parameter on a color visualizer).


        """
        return _hou.ViewportVisualizer_parmNames(self)

    def evalParmAsFloat(self, parm_name: "char const *") -> "double":
        r"""

        evalParmAsFloat(self, parm_name) -> float

            Evaluate the specified parameter and return the result as a float.

            Raise TypeError if the value cannot be converted to a float.


        """
        return _hou.ViewportVisualizer_evalParmAsFloat(self, parm_name)

    def evalParmAsInt(self, parm_name: "char const *") -> "int":
        r"""

        evalParmAsInt(self, parm_name) -> int

            Evaluate the specified parameter and return the result as an
            integer.

            Raise TypeError if the value cannot be converted to a integer.


        """
        return _hou.ViewportVisualizer_evalParmAsInt(self, parm_name)

    def evalParmAsString(self, parm_name: "char const *") -> "std::string":
        r"""

        evalParmAsString(self, parm_name) -> int

            Evaluate the specified parameter and return the result as a string.

            Raise TypeError if the value cannot be converted to a string.


        """
        return _hou.ViewportVisualizer_evalParmAsString(self, parm_name)

    def evalParmAsRamp(self, parm_name: "char const *") -> "HOM_Ramp *":
        r"""

        evalParmAsRamp(self) -> hou.Ramp

            Evalute the specified parameter and return the result as a ramp.

            Raises TypeError if the parameter is not a ramp.


        """
        return _hou.ViewportVisualizer_evalParmAsRamp(self, parm_name)

    def evalParm(self, parm_name: "char const *") -> "InterpreterObject":
        r"""

        evalParm(self, parm_name) -> int, float, or str

            Evaluate the specified parameter and return the result.


        """
        return _hou.ViewportVisualizer_evalParm(self, parm_name)

    def setParm(self, *args) -> "void":
        r"""

        setParm(self, parm_name, value)

            Set the specified parameter's value.

            Pass in a hou.Ramp object, as the parameter value, to set the value
            of a ramp parameter. The ramp object's type needs to match the
            target ramp's type.

            Raise TypeError if the type of value does not match the type of the
            specified parameter.


        """
        return _hou.ViewportVisualizer_setParm(self, *args)

    def destroy(self) -> "void":
        r"""

        destroy(self)

            Delete this viewport visualizer.

            If you call methods on a visualizer instance after it has been
            destroyed, Houdini will raise hou.ObjectWasDeleted.


        """
        return _hou.ViewportVisualizer_destroy(self)


# Register ViewportVisualizer in _hou:
_hou.ViewportVisualizer_swigregister(ViewportVisualizer)


class viewportVisualizers(object):
    r"""

    hou.viewportVisualizers

    Module containing viewport visualizer functionality.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_viewportVisualizers

    def __repr__(self) -> "std::string":
        return _hou.viewportVisualizers___repr__(self)

    def visualizers(
        self, *args, **kwargs
    ) -> "std::vector< HOM_ElemPtr< HOM_ViewportVisualizer >,std::allocator< HOM_ElemPtr< HOM_ViewportVisualizer > > >":
        r"""

        visualizers(category=hou.viewportVisualizerCategory.Common, node=None)
        -> tuple of hou.ViewportVisualizer

            Return a tuple of viewport visualizers registered with Houdini for
            the given category.

            The category argument must be a hou.viewportVisualizerCategory enum
            value. If the category is set to Node, then the node argument must
            be specified.

            Raise TypeError if the category is set to Common or Scene and the
            node argument is also set. Raise TypeError if the category is set to
            Node and the node argument is set to None.


        """
        return _hou.viewportVisualizers_visualizers(self, *args, **kwargs)

    def createVisualizer(self, *args, **kwargs) -> "HOM_ViewportVisualizer *":
        r"""

        createVisualizer(type, category=hou.viewportVisualizerCategory.Common,
        node=None) -> hou.ViewportVisualizer

            Create a new viewport visualizer for the specified type.

            The type argument must be a hou.ViewportVisualizerType. You can
            retrieve a visualizer type by calling hou.viewportVisualizers.types
            or hou.viewportVisualizers.type.

            The category argument must be a hou.viewportVisualizerCategory enum
            value. If the category is set to Node, then the node argument must
            be specified.

            Raise TypeError if the category is set to Common or Scene and the
            node argument is also set. Raise TypeError if the category is set to
            Node and the node argument is set to None.


        """
        return _hou.viewportVisualizers_createVisualizer(self, *args, **kwargs)

    def copyVisualizer(
        self, source: "ViewportVisualizer"
    ) -> "HOM_ViewportVisualizer *":
        r"""

        copyVisualizer(source) -> hou.ViewportVisualizer

            Create a duplicate of the specified source visualizer.


        """
        return _hou.viewportVisualizers_copyVisualizer(self, source)

    def types(
        self,
    ) -> "std::vector< HOM_ElemPtr< HOM_ViewportVisualizerType >,std::allocator< HOM_ElemPtr< HOM_ViewportVisualizerType > > >":
        r"""

        types() -> tuple of hou.ViewportVisualizerType

            Return a tuple of visualizer types registered with Houdini.


        """
        return _hou.viewportVisualizers_types(self)

    def type(self, name: "char const *") -> "HOM_ViewportVisualizerType *":
        r"""

        type(name) -> hou.ViewportVisualizerType

            Return the visualizer type registered with the specified name.
            Return None if no such type exists.


        """
        return _hou.viewportVisualizers_type(self, name)

    def isCategoryActive(
        self,
        category: "EnumValue",
        node: "Node" = None,
        viewport: "GeometryViewport" = None,
    ) -> "bool":
        r"""

        isCategoryActive(category, node=None, viewport=None) -> bool

            Return True if the visualizer category is active and False
            otherwise. For Common and Scene categories return True if it is
            active for the specified viewport. The viewport argument must be a
            hou.GeometryViewport.

            Raise TypeError if category is set to Common or Scene and the node
            argument is also set. Raise TypeError if category is set to Node and
            the node argument is set to None. Raise TypeError if both the node
            and viewport arguments are set. Node visualizers are either active
            in all viewports or none of them. They cannot be activated for a
            specific viewport.


        """
        return _hou.viewportVisualizers_isCategoryActive(self, category, node, viewport)

    def setIsCategoryActive(
        self,
        on: "bool",
        category: "EnumValue",
        node: "Node" = None,
        viewport: "GeometryViewport" = None,
    ) -> "void":
        r"""

        setIsCategoryActive(on, category, node=None, viewport=None) -> bool

            Set the activation state of the specified visualizer category. For
            Common and Scene categories the activation state must be set for a
            specific viewport. The viewport argument must be a
            hou.GeometryViewport.

            Raise TypeError if category is set to Common or Scene and the node
            argument is also set. Raise TypeError if category is set to Node and
            the node argument is set to None. Raise TypeError if both the node
            and viewport arguments are set. Node visualizers are either active
            in all viewports or none of them. They cannot be activated for a
            specific viewport.


        """
        return _hou.viewportVisualizers_setIsCategoryActive(
            self, on, category, node, viewport
        )


# Register viewportVisualizers in _hou:
_hou.viewportVisualizers_swigregister(viewportVisualizers)


class ViewportVisualizerType(object):
    r"""

    hou.ViewportVisualizerType

    Represents a viewport visualizer type.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_ViewportVisualizerType

    def __eq__(self, type: "HOM_PtrOrNull< HOM_ViewportVisualizerType >") -> "bool":
        return _hou.ViewportVisualizerType___eq__(self, type)

    def __ne__(self, type: "HOM_PtrOrNull< HOM_ViewportVisualizerType >") -> "bool":
        return _hou.ViewportVisualizerType___ne__(self, type)

    def __repr__(self) -> "std::string":
        return _hou.ViewportVisualizerType___repr__(self)

    def name(self) -> "std::string":
        r"""

        name(self) -> string

            Return the visualizer type's unique identifier.


        """
        return _hou.ViewportVisualizerType_name(self)

    def description(self) -> "std::string":
        r"""

        description(self) -> string

            Return a brief description of the visualizer type.


        """
        return _hou.ViewportVisualizerType_description(self)

    def icon(self) -> "std::string":
        r"""

        icon(self) -> string

            Return the name of the type's icon.


        """
        return _hou.ViewportVisualizerType_icon(self)


# Register ViewportVisualizerType in _hou:
_hou.ViewportVisualizerType_swigregister(ViewportVisualizerType)


class Volume(Prim):
    r"""

    hou.Volume

    A Volume is a kind geometry primitive (Prim object) storing a three
    dimensional array of voxels.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_Volume

    def __repr__(self) -> "std::string":
        return _hou.Volume___repr__(self)

    def sample(self, position: "_DoubleTuple") -> "double":
        r"""

        sample(self, position) -> float

            Given a sequence of three floats containing a 3D position, return
            the value of the volume at that position. If the position is not in
            the middle of a voxel, Houdini will interpolate using values from
            surrounding voxels.

            See also hou.Volume.voxel and hou.Volume.posToIndex.


        """
        return _hou.Volume_sample(self, position)

    def gradient(self, position: "_DoubleTuple") -> "HOM_Vector3 *":
        r"""

        gradient(self, position) -> hou.Vector3

            Given a sequence of three floats containing a 3D position, return a
            vector which points in the direction of the greatest rate of
            increase of the volume's value.

            See Wikipedia's gradient page for more information.


        """
        return _hou.Volume_gradient(self, position)

    def voxel(self, index: "_IntTuple") -> "double":
        r"""

        voxel(self, index) -> float

            Given a sequence of three integers containing a voxel index, return
            the value of the corresponding voxel.

          > >>> volume_sop = hou.node(\"/obj\").createNode(\"geo\").createNode(\"volume\")
          > >>> volume_sop.parm(\"initialval1\").set(0.3)
          > >>> volume = volume_sop.geometry().prims()[0]
          > >>> volume.resolution()
          > (10, 10, 10)
          > >>> volume.voxel((0, 0, 0))
          > 0.3

        """
        return _hou.Volume_voxel(self, index)

    def setVoxel(self, index: "_IntTuple", value: "double") -> "void":
        r"""

        setVoxel(self, index, value)

            Set the value of a voxel. You would typically call this method from
            the code of a Python-defined SOP.


            index
                A sequence of three integers containing a voxel index. Raises
                hou.OperationFailed if any of the values in index are out of
                range.

            value
                A float containing the voxel's new value.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
        return _hou.Volume_setVoxel(self, index, value)

    def allVoxels(self) -> "std::vector< float,std::allocator< float > >":
        r"""

        allVoxels(self) -> tuple of float

            Return a tuple of floats containing the values of all voxels. It is
            faster to call this method to retrieve all the voxels than it is to
            loop through the voxel array in Python.

            You can, for example, use Python's Numpy library to perform
            operations on the voxel data and then store the result back into the
            volume from a Python SOP using hou.Volume.setAllVoxels. Note that
            Numpy allows you to reshape the flat tuple of floats to behave like
            a 3D matrix of floats.

            This method can be approximately implemented as follows (though this
            Python implementation is much slower):

          > def allVoxels(self):
          >     result = []
          >     xres, yres, zres = self.resolution()
          >     for z in range(zres):
          >         for y in range(yres):
          >             for x in range(xres):
          >                 result.append(self.voxel((x, y, z)))
          >     return tuple(result)

            See also hou.Volume.allVoxelsAsString,
            hou.Geometry.pointFloatAttribValues, and
            hou.Geometry.primFloatAttribValues.


        """
        return _hou.Volume_allVoxels(self)

    def allVoxelsAsString(self) -> "HOM_BinaryString":
        r"""

        allVoxelsAsString(self) -> str for Python 2, bytes for Python 3

            Return a binary string representation of the floats containing all
            the values of all voxels. This method is faster than
            hou.Volume.allVoxels, and you can use the array module to convert
            the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            This method provides a faster implementation of the following:

          > import array
          > def allVoxelsAsString(self):
          >     return array.array(\"f\", self.allVoxels()).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def allVoxelsAsArray(volume):
          >     a = array.array(\"f\")
          >     a.fromstring(volume.allVoxelsAsString())
          >     return a

            See hou.Volume.allVoxels for more information.


        """
        return _hou.Volume_allVoxelsAsString(self)

    def setAllVoxels(self, values: "_FloatTuple") -> "void":
        r"""

        setAllVoxels(self, values)

            Set the value of all voxels in this volume. You would typically call
            this method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if the sequence of values is not exactly
            the same as self.resolution()[0] * self.resolution()[1] *
            self.resolution()[2].

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Volume.allVoxels.


        """
        return _hou.Volume_setAllVoxels(self, values)

    def setAllVoxelsFromString(self, values: "InterpreterObject") -> "void":
        r"""

        setAllVoxelsFromString(self, values)

            Set the value of all voxels in this volume from a string
            representation of a sequence of single precision float values. This
            method is faster than hou.Volume.setAllVoxels.

            Note that this method can accept more types that just a string: it
            can receive any Python object that supports the buffer interface. In
            particular, arrays from the array and numpy Python modules are
            supported, so there is no need to first construct strings from those
            arrays.

            Raises hou.OperationFailed if the length of the string is not
            exactly the same as self.resolution()[0] * self.resolution()[1] *
            self.resolution()[2] * 4.

            See hou.Volume.setAllVoxels and hou.Volume.allVoxelsAsString for
            more information.

            The following example function accepts an array.array(\"f\") and sets
            the voxels to its contents:

          > def setAllVoxelsFromArray(volume, arr):
          >     assert(arr.typecode == \"f\")
          >     volume.setAllVoxelsFromString(arr)

        """
        return _hou.Volume_setAllVoxelsFromString(self, values)

    def voxelSlice(
        self, plane: "char const *", index: "int"
    ) -> "std::vector< float,std::allocator< float > >":
        r"""

        voxelSlice(plane, index) -> tuple of float

            Return a tuple of floats containing the values of all voxels in a
            particular slice. It is faster to call this method to retrieve a
            slice than it is to loop through the voxel array in Python.


            plane
                The plane corresponding to this slice. This value must be either
                xy, xz, or yz.

            index
                The index of this slice in the array. For example, if the plane
                is xy, this index is the z value and the result will contain all
                values in the voxel with this particular z value.

            This method can be approximately implemented as follows (though this
            Python implementation is much slower):

          > def voxelSlice(self, plane, index):
          >     result = []
          >
          >     start = [0] * 3
          >     stop = list(self.resolution())
          >
          >     slice_axis = {\"xy\": 2, \"xz\": 1, \"yz\": 0}[plane]
          >     start[slice_axis] = index
          >     stop[slice_axis] = index + 1
          >
          >     for z in range(start[2], stop[2]):
          >         for y in range(start[1], stop[1]):
          >             for x in range(start[0], stop[0]):
          >                 result.append(self.voxel((x, y, z)))
          >     return tuple(result)

            See also hou.Volume.voxelSliceAsString and hou.Volume.allVoxels.


        """
        return _hou.Volume_voxelSlice(self, plane, index)

    def voxelSliceAsString(
        self, plane: "char const *", index: "int"
    ) -> "HOM_BinaryString":
        r"""

        voxelSliceAsString(plane, index) -> str

            Return a binary string representation of the floats containing all
            the values of voxels in a particular slice.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            See hou.Volume.voxelSlice and hou.Volume.allVoxelsAsString for more
            information.


        """
        return _hou.Volume_voxelSliceAsString(self, plane, index)

    def setVoxelSlice(
        self, values: "_FloatTuple", plane: "char const *", index: "int"
    ) -> "void":
        r"""

        setVoxelSliceFromString(self, values, plane, index)

            Set the value of the voxels in a particular slice of this volume.
            You would typically call this method from the code of a Python-
            defined SOP.


            values
                A binary string representing of a sequence of floats containing
                the new values for the slice.

                Note that this method can accept more types that just a string:
                it can receive any Python object that supports the buffer
                interface. In particular, arrays from the array and numpy Python
                modules are supported, so there is no need to first construct
                strings from those arrays.

            plane
                The plane corresponding to this slice. This value must be either
                xy, xz, or yz.

            index
                The index of this slice in the array.

            See hou.Volume.setVoxelSlice for more information.

            The following example builds a volume from an compositing network
            sequence:

          > def buildVolumeFromCopSequence(
          >         cop_node, geo, voxel_depth, plane=\"C\", component=\"r\"):
          >     zres = int(cop_node.sequenceFrameLength())
          >     volume_bbox = hou.BoundingBox(*(
          >         0, 0, 0,
          >         cop_node.xRes(), cop_node.yRes(), zres) * voxel_depth)
          >     volume = geo.createVolume(
          >         cop_node.xRes(), cop_node.yRes(), zres, volume_bbox)
          >
          >     for z in range(zres):
          >         pixels = cop_node.allPixelsAsString(
          >             plane, component,
          >             time=hou.frameToTime(z + cop_node.sequenceStartFrame()))
          >         volume.setVoxelSliceFromString(pixels, \"xy\", z)

        """
        return _hou.Volume_setVoxelSlice(self, values, plane, index)

    def setVoxelSliceFromString(
        self, values: "InterpreterObject", plane: "char const *", index: "int"
    ) -> "void":
        return _hou.Volume_setVoxelSliceFromString(self, values, plane, index)

    def resolution(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        resolution(self) -> hou.Vector3

            Return the x, y, and z dimensions of the volume. For example, a
            resolution of (10, 20, 30) means the volume is 10 voxels in x by 20
            voxels in y by 30 voxels in z.


        """
        return _hou.Volume_resolution(self)

    def indexToPos(self, index: "_IntTuple") -> "HOM_Vector3 *":
        r"""

        indexToPos(self, index) -> hou.Vector3

            Given a sequence of three ints containing an index into the voxel
            array, return the corresponding 3D position of the middle of that
            voxel.


        """
        return _hou.Volume_indexToPos(self, index)

    def posToIndex(
        self, position: "_DoubleTuple"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        posToIndex(self, position) -> tuple of int

            Given a sequence of three floats containing a 3D position, return a
            tuple of three ints containing the corresponding index into the
            voxel array.

            Note that the returned index will be invalid if the position is
            outside the volume. Use hou.Volume.isValidIndex to determine if the
            index is valid.


        """
        return _hou.Volume_posToIndex(self, position)

    def isValidIndex(self, index: "_IntTuple") -> "bool":
        r"""

        isValidIndex(self, index) -> bool

            Return whether or not a sequence of three ints containing an index
            into the voxel array is valid, ie, within the bounds of the array.

            This method can approximately be implemented as follows:

          > def isValidIndex(self, index):
          >     for i, maximum in zip(index, self.resolution()):
          >         if i < 0 or i >= maximum:
          >             return False
          >     return True

        """
        return _hou.Volume_isValidIndex(self, index)

    def isSDF(self) -> "bool":
        r"""

        isSDF(self) -> bool

            Return whether or not the volume is flagged as a signed distance
            field. Such volumes have a special border condition where out of
            bound reads will add the distance to the bounding box to the
            streaked boundary condition. They are also best to be semantically
            treated as signed distance fields.


        """
        return _hou.Volume_isSDF(self)

    def isHeightField(self) -> "bool":
        r"""

        isHeightField(self) -> bool

            Return whether or not the volume is flagged as a heightfield. Such
            volumes are two dimensional and have the heightfield visualization
            set.


        """
        return _hou.Volume_isHeightField(self)

    def volumeMax(self) -> "double":
        r"""

        volumeMax(self) -> float

            Return the maximum value of all voxels.


        """
        return _hou.Volume_volumeMax(self)

    def volumeMin(self) -> "double":
        r"""

        volumeMin(self) -> float

            Return the minimum value of all voxels.


        """
        return _hou.Volume_volumeMin(self)

    def volumeAverage(self) -> "double":
        r"""

        volumeAverage(self) -> float

            Return the average value of all voxels.


        """
        return _hou.Volume_volumeAverage(self)

    def transform(self) -> "HOM_Matrix3 *":
        r"""

        transform(self) -> hou.Matrix3

            Return a 3x3 matrix containing the scale and rotation
            transformations for this volume.

            Note that the position information for the volume can be obtained by
            calling volume.vertex(0).point().position().

            The following function returns a 4x4 transformation matrix for the
            volume that includes the translation:

          > def fullTransform(volume):
          >     return (hou.Matrix4(volume.transform()) *
          >         hou.hmath.buildTranslate(volume.vertex(0).point().position()))

            NOTE
                You need to get the node transform to get to worldspace.


        """
        return _hou.Volume_transform(self)

    def setTransform(self, transform: "Matrix4") -> "void":
        r"""

        setTransform(self, matrix4)

            Given a 4x4 matrix, set the position, rotation, and scale of this
            volume.

            Note that if you want to just set the translate portion of a volume
            to a hou.Vector3, you could just call
            volume.vertex(0).point().setPosition(position).


        """
        return _hou.Volume_setTransform(self, transform)

    def taperX(self) -> "double":
        return _hou.Volume_taperX(self)

    def taperY(self) -> "double":
        return _hou.Volume_taperY(self)

    def vertex(self, index: "int") -> "HOM_Vertex *":
        r"""

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
        return _hou.Volume_vertex(self, index)


# Register Volume in _hou:
_hou.Volume_swigregister(Volume)


class VopNetNode(Node):
    r"""

    hou.VopNetNode

    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_VopNetNode

    def __repr__(self) -> "std::string":
        return _hou.VopNetNode___repr__(self)

    def definedType(self) -> "HOM_NodeType *":
        r"""

        definedType(self) -> NodeType


        """
        return _hou.VopNetNode_definedType(self)

    def vexContext(self) -> "HOM_VexContext *":
        r"""

        vexContext(self) -> VexContext


        """
        return _hou.VopNetNode_vexContext(self)

    def shaderType(self) -> "HOM_EnumValue *":
        r"""

        shaderType(self) -> hou.shaderType enum value or None


        """
        return _hou.VopNetNode_shaderType(self)


# Register VopNetNode in _hou:
_hou.VopNetNode_swigregister(VopNetNode)


class VopNode(Node):
    r"""

    hou.VopNode

    Represents a VOP (VEX Operator) node.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_VopNode

    def __repr__(self) -> "std::string":
        return _hou.VopNode___repr__(self)

    def insertParmGenerator(
        self,
        input_name: "char const *",
        parm_gen_type: "EnumValue",
        reference_input_defaults: "bool",
    ) -> "HOM_VopNode *":
        r"""

        insertParmGenerator(self, input_name, parm_gen_type,
        reference_input_defaults) -> hou.VopNode

            Creates a parameter or a constant node and wires it into an input
            specified by input_name on this node. parm_gen_type must be a value
            of hou.vopParmGenType. If reference_input_defaults is True, this
            node will reference the defaults of the newly created node.

            A resultant parameter or constant node is returned.


        """
        return _hou.VopNode_insertParmGenerator(
            self, input_name, parm_gen_type, reference_input_defaults
        )

    def insertParmGeneratorsForAllInputs(
        self, parm_gen_type: "EnumValue", reference_input_defaults: "bool"
    ) -> "std::map< std::string,HOM_ElemPtr< HOM_Node >,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_ElemPtr< HOM_Node > > > >":
        r"""

        insertParmGeneratorsForAllInputs(self, parm_gen_type,
        reference_input_defaults) -> dict of str to hou.VopNode

            Creates parameter or constant nodes and wires them into unconnected
            inputs on this node. parm_gen_type must be a value of
            hou.vopParmGenType. If reference_input_defaults is True, then this
            node will reference the defaults of the newly created nodes.

            A dictionary is returned with input names for keys and hou.VopNode
            objects for values.


        """
        return _hou.VopNode_insertParmGeneratorsForAllInputs(
            self, parm_gen_type, reference_input_defaults
        )

    def parmDefinerNode(self) -> "HOM_VopNode *":
        r"""

        parmDefinerNode(self) -> hou.VopNode

            Return the Parameter VOP node that defines the parameter that this
            node is bound to. This method only applies to Parameter VOP nodes.

            Return None if this node is not a Parameter VOP or if this node is
            the definer node.


        """
        return _hou.VopNode_parmDefinerNode(self)

    def deleteIndependentInputNodes(self, input_index: "int") -> "bool":
        r"""

        deleteIndependentInputNodes(self, input_index):, make_parm_node,
        reference_input_defaults) -> bool

            Deletes a chain of nodes wired into a particular input if and only
            if they are wired only into the specified input on this node.
            Returns true if nodes were deleted, false otherwise.


        """
        return _hou.VopNode_deleteIndependentInputNodes(self, input_index)

    def dependsOnlyOn(
        self, other_node: "VopNode", max_connections: "int", recurse: "bool"
    ) -> "bool":
        return _hou.VopNode_dependsOnlyOn(self, other_node, max_connections, recurse)

    def setIsInputVisible(
        self, input_name: "char const *", is_visible: "bool"
    ) -> "void":
        r"""

        setIsInputVisible(self, input_name, is_visible)

            Shows or hides an input connector of this node. The input is
            specified by input_name. The connector is shown if is_visible is
            True, and hidden otherwise.


        """
        return _hou.VopNode_setIsInputVisible(self, input_name, is_visible)

    def isInputVisible(self, input_name: "char const *") -> "bool":
        r"""

        isInputVisible(self, input_name) -> bool

            Returns True if the input connector specified by input_name on this
            node is visible, False otherwise.


        """
        return _hou.VopNode_isInputVisible(self, input_name)

    def inputDataTypes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        inputDataTypes(self) -> tuple of str

            Returns a tuple of all input data types for this node. Data types
            for input connectors that are hidden are also included.

            The strings returned by this method can be used to set the Type
            parameter on a Parameter or Constant VOP.


        """
        return _hou.VopNode_inputDataTypes(self)

    def outputDataTypes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        outputDataTypes(self) -> tuple of str

            Returns a tuple of all output data types for this node. Data types
            for output connectors that are hidden are also included.

            The strings returned by this method can be used to set the Type
            parameter on a Parameter or Constant VOP.


        """
        return _hou.VopNode_outputDataTypes(self)

    def inputParmTypes(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.VopNode_inputParmTypes(self)

    def isInputCompatible(
        self,
        idx: "int",
        other: "VopNode",
        other_idx: "int",
        allow_conversions: "bool" = False,
    ) -> "bool":
        r"""

        isInputCompatible(self, idx, other, other_idx, allow_conversions =
        False) -> bool`

            Return True if input idx of this object can be connected to output
            other_idx of node other. Two inputs can be connected if they are of
            the same data type. If the allow_conversions parameter is set to
            True, a more permissive check is done which accepts an input
            connection if the output data type can be automatically converted to
            the input data type without an explicit conversion node (such as a
            float output to a vector input).


        """
        return _hou.VopNode_isInputCompatible(
            self, idx, other, other_idx, allow_conversions
        )

    def code(self) -> "std::string":
        r"""

        code(self) -> str

            Returns the VEX or RSL code that defines this node.


        """
        return _hou.VopNode_code(self)

    def outerCode(self) -> "std::string":
        r"""

        outerCode(self) -> str

            Returns the outer code associated with this node.


        """
        return _hou.VopNode_outerCode(self)

    def isBypassed(self) -> "bool":
        r"""

        isBypassed(self) -> bool

            Returns True if the node's bypass flag is turned on. Returns False
            otherwise.


        """
        return _hou.VopNode_isBypassed(self)

    def bypass(self, on: "bool") -> "void":
        r"""

        bypass(self, on)

            Turns the node's bypass flag on or off. When the bypass flag is on,
            the node will have no effect on the scene. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_bypass(self, on)

    def isDebugFlagSet(self) -> "bool":
        r"""

        isDebugFlagSet(self) -> bool

            Returns True if the node's debug flag is turned on. Returns False
            otherwise.


        """
        return _hou.VopNode_isDebugFlagSet(self)

    def setDebugFlag(self, on: "bool") -> "void":
        r"""

        setDebugFlag(self, on)

            Turns the node's debug flag on or off. The value of the on argument
            must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_setDebugFlag(self, on)

    def isDetailLowFlagSet(self) -> "bool":
        r"""

        isDetailLowFlagSet(self) -> bool

            Returns True if the node's low detail flag is turned on. Returns
            False otherwise.


        """
        return _hou.VopNode_isDetailLowFlagSet(self)

    def setDetailLowFlag(self, on: "bool") -> "void":
        r"""

        setDetailLowFlag(self, on)

            Turns on or off the low detail flag for this node's inputs and
            outputs. With this flag turned on, all inputs and outputs to this
            node will appear in the network view as connecting to a single
            location on the node. This flag does not affect the operation of
            this node, only its appearance in the network view. The value of the
            on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_setDetailLowFlag(self, on)

    def isDetailMediumFlagSet(self) -> "bool":
        r"""

        isDetailMediumFlagSet(self) -> bool

            Returns True if the node's medium detail flag is turned on. Returns
            False otherwise.


        """
        return _hou.VopNode_isDetailMediumFlagSet(self)

    def setDetailMediumFlag(self, on: "bool") -> "void":
        r"""

        setDetailMediumFlag(self, on)

            Turns on or off the medium detail flag for this node's inputs and
            outputs. With this flag turned on, only connected inputs and outputs
            to this node will be visible in the network view. This flag does not
            affect the operation of this node, only its appearance in the
            network view. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_setDetailMediumFlag(self, on)

    def isDetailHighFlagSet(self) -> "bool":
        r"""

        isDetailHighFlagSet(self) -> bool

            Returns True if the node's high detail flag is turned on. Returns
            False otherwise.


        """
        return _hou.VopNode_isDetailHighFlagSet(self)

    def setDetailHighFlag(self, on: "bool") -> "void":
        r"""

        setDetailHighFlag(self, on)

            Turns on or off the high detail flag for this node's inputs and
            outputs. With this flag turned on, all inputs and outputs to this
            node will appear in the network view, whether they are connected to
            another node or not. This flag does not affect the operation of this
            node, only its appearance in the network view. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_setDetailHighFlag(self, on)

    def isCompressFlagSet(self) -> "bool":
        r"""

        isCompressFlagSet(self) -> bool

            Returns True if the node's compress flag is turned on. Returns False
            otherwise. The compress flag controls whether or not a preview image
            is shown for this node in the Network View.


        """
        return _hou.VopNode_isCompressFlagSet(self)

    def setCompressFlag(self, on: "bool") -> "void":
        r"""

        setCompressFlag(self, on)

            Turns the node's compress flag on or off. If the compress flag is
            True, this node will not show a preview image in the Network View.
            If the compress flag is False, a preview image will be shown in the
            Network View. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_setCompressFlag(self, on)

    def isMaterialFlagSet(self) -> "bool":
        r"""

        isMaterialFlagSet(self) -> bool

            Returns True if the node's material flag is turned on. Returns False
            otherwise. The material flag indicates whether this node is intended
            for use as a material to be assigned to objects or geometry.


        """
        return _hou.VopNode_isMaterialFlagSet(self)

    def setMaterialFlag(self, on: "bool") -> "void":
        r"""

        setMaterialFlag(self, on)

            Turns the node's material flag on or off. If the material flag is
            True, it indicates that this node is meant to be used as a material
            to be assigned to objects or geometry. It will appear in material
            node choosers and be saved to IFDs generated with the option to save
            all materials turned on.

            Raises hou.PermissionError if the node is unwritable.


        """
        return _hou.VopNode_setMaterialFlag(self, on)

    def setInputGroupExpanded(self, group: "char const *", expanded: "bool") -> "void":
        r"""

        setInputGroupExpanded(self, group, expanded)

            Sets the expanded state of the input group with the name specified
            by the group parameter. This controls the appearance of this input
            group in the Network View. Pass a group value of None to expand or
            collapse all input groups.


        """
        return _hou.VopNode_setInputGroupExpanded(self, group, expanded)

    def isInputGroupExpanded(self, group: "char const *") -> "bool":
        r"""

        isInputGroupExpanded(self, group) -> bool

            Returns True if the group with the name specified by group is
            expanded in the Network View. The group parameter should be a value
            returned by the hou.VopNode.inputGroupName method. Returns the
            current expanded state of the group even if the group is not
            currently visible due to the setting of the input/output detail
            flags. Returns True if the group name is not valid.


        """
        return _hou.VopNode_isInputGroupExpanded(self, group)

    def inputsInGroup(
        self, group: "char const *"
    ) -> "std::vector< int,std::allocator< int > >":
        r"""

        inputsInGroup(self, group) -> tuple of int

            Returns the input index values of all inputs that appear in the
            group with the name specified in group. This parameter should be a
            value returned by the hou.VopNode.inputGroupName method. This method
            returns the same set of inputs whether the group is expanded or
            collapsed. Returns an empty tuple if the group name contains no
            inputs or is not a recognized group name.


        """
        return _hou.VopNode_inputsInGroup(self, group)

    def inputGroupNames(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        inputGroupNames(self) -> tuple of str

            Returns the names of the input groups on this VOP Node. Note that
            not all groups will contain any inputs, and so not all groups will
            be visible in the Network View. Use the hou.VopNode.inputsInGroup
            method to determine which inputs are part of a particular group.


        """
        return _hou.VopNode_inputGroupNames(self)

    def inputIndexOrder(self) -> "std::vector< int,std::allocator< int > >":
        r"""

        inputIndexOrder(self) -> tuple of int

            Return a tuple of integers which represent input index numbers that
            can be passed to hou.Node.setInput and related functions. The order
            of the index numbers represents the order in which those inputs
            appear in the network view tile for this object. This ordering is
            affected by the way inputs are grouped together on the parameter
            pane for this node.


        """
        return _hou.VopNode_inputIndexOrder(self)

    def renderMask(self) -> "std::string":
        r"""

        renderMask(self) -> str

            Returns the mask for renderers for which the node represents a valid
            shader.


        """
        return _hou.VopNode_renderMask(self)

    def shaderString(self, *args) -> "std::string":
        r"""

        shaderString(self, render_type=None, shader_type=hou.shaderType.Surface,
        as_encapsulated=False) -> str

            Returns the string that encodes the shader name and parameter values
            suitable for specifying as a shader assignment in an input stream
            acceptable by the renderer of a given type. If the VOP is material
            that provides a few shader contexts (eg, surface and displacement),
            it is necessary to provide the shader type explicitly. If
            as_encapsulated is true, the returned shader string will encode the
            shader as embedded in the parent shader with parameters referencing
            the parent, if needed.


        """
        return _hou.VopNode_shaderString(self, *args)

    def shaderCode(self, *args) -> "std::string":
        r"""

        shaderCode(self, shader_type=hou.shaderType.Surface) -> str

            Returns the generated VEX or RSL code for this VOP, using the given
            shader type to control output context. If the VOP is a subnet that
            can be packaged up as an encapsulated shader, then the specific code
            to define an encapsulated shader is output. Otherwise, the code
            generated for the entire VOP network is output.


        """
        return _hou.VopNode_shaderCode(self, *args)

    def shaderName(
        self, as_otl_path: "bool" = True, shader_type_name: "char const *" = None
    ) -> "std::string":
        r"""

        shaderName(self, as_otl_path=True, shader_type_name=None) -> str

            Returns the name of the shader defined by this VOP (if it is an
            embedded shader) or the shader name defined by the shop in which
            this VOP resides. If as_otl_path is True, returns an opdef: path to
            the SHOP type. The shader_type_name is a string indicating the
            shader context type to use; some nodes may provide several shader
            types, and each may have a different name. This is applicable only
            to multi-context shader nodes, such as a vopnet material shop.


        """
        return _hou.VopNode_shaderName(self, as_otl_path, shader_type_name)

    def shaderNameForSignature(self, signature: "char const *" = None) -> "std::string":
        r"""

        shaderNameForSignature(self, signature=None) -> str

            Returns the name of the shader given the node's signature.

            Different VOP signatures may have different shader function names,
            so this method will return the shader name for the signature given
            in the parameter. If the signature is not provided, the current
            signature of the node is used.


        """
        return _hou.VopNode_shaderNameForSignature(self, signature)

    def shaderType(self) -> "HOM_EnumValue &":
        return _hou.VopNode_shaderType(self)

    def shaderLanguageName(self) -> "std::string":
        r"""

        shaderLanguageName(self) -> str

            Returns the name of the language the shader is written in.


        """
        return _hou.VopNode_shaderLanguageName(self)

    def currentSignatureName(self) -> "std::string":
        r"""

        currentSignatureName(self) -> str

            Returns the current signature name of this node. The HDA nodes may
            provide several valid signatures, and this function returns the name
            of the currently used signature. A signature is defined by a set of
            input types and each set is assigned a name.


        """
        return _hou.VopNode_currentSignatureName(self)

    def coshaderNodes(
        self, parm_name: "char const *"
    ) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
        return _hou.VopNode_coshaderNodes(self, parm_name)

    def coshaderNodesOutputNames(
        self, parm_name: "char const *"
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        return _hou.VopNode_coshaderNodesOutputNames(self, parm_name)

    def subnetTerminalChild(
        self, subnet_output_name: "char const *"
    ) -> "std::pair< HOM_ElemPtr< HOM_Node >,std::string >":
        r"""

        subnetTerminalChild(self, output_name) -> tuple of houNode and str

            Returns a tuple of a node and its input name that corresponds to the
            subnet output connector by the given name.


        """
        return _hou.VopNode_subnetTerminalChild(self, subnet_output_name)

    def extraBindings(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        extraBindings(self) -> tuple of str

            Returns the list of extra bindings the VOP node would add to the
            generated code. Implemented specifically for Snippet VOPs, this
            allows one to determine what bindings will be created by any adhoc @
            references.


        """
        return _hou.VopNode_extraBindings(self)

    def usdShaderParms(
        self, force_parms_at_default: "bool" = False
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        usdShaderParms(self, force_parms_at_default=False) -> tuple of str

            Returns the list of shader parameter names whose values need to be
            authored on the USD shader primitive. This list includes node
            parameters that are designated as shader parameters and are active,
            but are not at default values (unless they have a tag forcing it to
            be translated).

            If force_parms_at_default is True, returns shader parameters that
            are at default values too; excludes them otherwise, which is a
            default behaviour.


        """
        return _hou.VopNode_usdShaderParms(self, force_parms_at_default)

    def usdPreviewShaderParms(
        self,
    ) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""

        usdPreviewShaderParms(self) -> tuple of str

            Returns the list of shader parameter names whose values are used to
            author a standard USD preview shader. Usually, these parameters are
            tagged with a special ogl_* spare data.


        """
        return _hou.VopNode_usdPreviewShaderParms(self)


# Register VopNode in _hou:
_hou.VopNode_swigregister(VopNode)


class VopNodeType(NodeType):
    r"""

    hou.VopNodeType

    This kind of NodeType contains extra attributes specific to VOP nodes.


    """

    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __swig_destroy__ = _hou.delete_VopNodeType

    def __repr__(self) -> "std::string":
        return _hou.VopNodeType___repr__(self)

    def shaderType(self) -> "HOM_EnumValue &":
        r"""

        shaderType(self) -> hou.shaderType enum value

            Returns the type of shader for this VOP type. For example, this vop
            type might be a surface shader or a displacement shader. See
            hou.shaderType for the possible shader types.

            See also hou.VopNode.shaderType.


        """
        return _hou.VopNodeType_shaderType(self)

    def renderMask(self) -> "std::string":
        r"""

        renderMask(self) -> str

            Returns a string with space-separated names of the renderers that
            this VOP type supports. Note that some VOP types, like the switch
            VOP, return \"*\" to indicate that they support all renderers, while
            others return an empty string to indicate they are not real shaders.

            See hou.VopNode.shaderString for an example.


        """
        return _hou.VopNodeType_renderMask(self)

    def vopnetMask(self) -> "std::string":
        r"""

        vopnetMask(self) -> str

            Returns a glob pattern that matches the network parents in which
            this VOP node can appear.

            See hou.VopNode.shaderString for an example.


        """
        return _hou.VopNodeType_vopnetMask(self)

    def inputTags(
        self, input_name: "char const *"
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        inputTags(self, input_name) -> dict of str to string

            Returns a dictionary of key-value pairs associated with the given
            input. This dictionary allows attaching arbitrary data to node
            inputs.


        """
        return _hou.VopNodeType_inputTags(self, input_name)

    def outputTags(
        self, output_name: "char const *"
    ) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""

        outputTags(self, output_name) -> dict of str to str

            Returns a dictionary of key-value pairs associated with the given
            output. This dictionary allows attaching arbitrary data to node
            outputs.


        """
        return _hou.VopNodeType_outputTags(self, output_name)


# Register VopNodeType in _hou:
_hou.VopNodeType_swigregister(VopNodeType)


def __doHoudiniInternalsExist() -> "bool":
    return _hou.__doHoudiniInternalsExist()


def __createHoudiniInternals() -> "void":
    return _hou.__createHoudiniInternals()


def __createHOMModule() -> "void":
    return _hou.__createHOMModule()


def __extendHOMWithDSOCode() -> "void":
    return _hou.__extendHOMWithDSOCode()


def __registerThread() -> "void":
    return _hou.__registerThread()


def _addPreloadIcon(name: "std::string", w: "int", h: "int") -> "void":
    return _hou._addPreloadIcon(name, w, h)


def _rasterizePreloadIcons() -> "void":
    return _hou._rasterizePreloadIcons()


def _getArgumentAutoComplete(
    method_name: "char const *",
    arguments: "char const *",
    meta_info_only: "bool" = False,
) -> "std::vector< std::string,std::allocator< std::string > >":
    return _hou._getArgumentAutoComplete(method_name, arguments, meta_info_only)


def isUIAvailable() -> "bool":
    r"""

    hou.isUIAvailable

    Return whether or not the hou.ui module is available.

    USAGE
      isUIAvailable() -> bool

    The hou.ui module is not available in the command-line interpreter or in
    MPlay, and this function helps you to write scripts that will run in
    Houdini and command-line and/or MPlay.

    RELATED

      * hou.ui


    """
    return _hou.isUIAvailable()


def _isExperimentalActive() -> "bool":
    return _hou._isExperimentalActive()


def _isCurrentThreadHoldingHOMLock() -> "bool":
    return _hou._isCurrentThreadHoldingHOMLock()


def _assertWrapper(
    file: "char const *",
    linenum: "int",
    function: "char const *",
    condition: "char const *",
    reason: "char const *",
) -> "bool":
    return _hou._assertWrapper(file, linenum, function, condition, reason)


def exit(exit_code: "int" = 0, suppress_save_prompt: "bool" = False) -> "void":
    r"""

    hou.exit

    Exits Houdini, returning the exit code to the operating system. If
    suppress_save_prompt is false, this function asks the user if he/she
    wants to save. If the user presses Cancel, the exit will be canceled and
    the next statement will execute.

    USAGE
      exit(exit_code=0, suppress_save_prompt=False)

    The exit confirmation prompt only appears if the session has unsaved
    changes. This function will not return until after the user has made a
    choice from the prompt. If this function is called from outside Houdini
    (e.g. MPlay or a non-graphical Python shell), the dialog is not
    displayed and suppress_save_prompt==True is implied.

    Note that if the user chose to exit, this function will raise a Python
    SystemExit exception to ensure the executing Python script terminates.
    This approach ensures that the next Python statement will not be
    executed, since Houdini may add events to its event queue that carry out
    the actual shutdown, or hou.exit() may be called from a different thread
    than the one executing the shutdown.

    Note that if you call sys.exit() from within the interactive Houdini
    Python shell, it will call hou.exit() with suppress_save_prompt=True.
    The Houdini Python shell does this by intercepting the SystemExit
    exception raised by sys.exit() and calling hou.exit(). Since both
    sys.exit() and hou.exit() both raise SystemExit exceptions, the shell
    calls hou._isExiting() to differentiate between the two.

    Avoid calling sys.exit() from any place other than the interactive
    Houdini Python shell, such as non-graphical Python shells, and instead
    call hou.exit(). Using hou.exit() ensures that Houdini shuts down
    cleanly.


    """
    return _hou.exit(exit_code, suppress_save_prompt)


def _isExiting() -> "bool":
    return _hou._isExiting()


def applicationName() -> "std::string":
    r"""

    hou.applicationName

    Returns the application name.

    USAGE
      applicationName() -> string

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationPlatformInfo

      * hou.licenseCategory

      * hou.isApprentice


    """
    return _hou.applicationName()


def applicationVersion(
    include_patch: "bool" = False,
) -> "std::vector< int,std::allocator< int > >":
    r"""

    hou.vdbVersionInfo

    Returns a dictionary about the version of VDB built into Houdini.

    USAGE
      vdbVersionInfo() -> dict of str to str

    Returns a dictionary holding information about the USD library built
    into Houdini.


    vdbversion
        The VDB version number converted to a string. This is usually of the
        form Major.Minor.Patch

    abiversion
        The VDB version number with the ABI it was built against. It is most
        important that the ABI match with external libraries to ensure VDBs
        can be passed between plugins.

    packageurl
        The URL of the git repository from which the VDB library was built.

    packagerevision
        The git commit hash code for the specific branch used to build the
        VDB library.

    RELATED

      * hou.lop.usdVersionInfo

      * hou.thirdPartyLibraryVersions


    """
    return _hou.applicationVersion(include_patch)


def applicationVersionString() -> "std::string":
    r"""

    hou.applicationVersionString

    Returns the application's version number as a string.

    USAGE
      applicationVersionString() -> string

    The format of the string is 'major_version.minor_version.build_version'.
    If this method is executed in python, then it returns the hou module's
    version number.

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationPlatformInfo

      * hou.licenseCategory

      * hou.isApprentice


    """
    return _hou.applicationVersionString()


def applicationCompilationDate() -> "std::string":
    r"""

    hou.applicationCompilationDate

    Returns the application's compilation date.

    USAGE
      applicationCompilationDate() -> string

    If this method is executed in python, then it returns the date which the
    hou module was compiled on.

    RELATED

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationPlatformInfo

      * hou.licenseCategory

      * hou.isApprentice


    """
    return _hou.applicationCompilationDate()


def applicationPlatformInfo() -> "std::string":
    r"""

    hou.applicationPlatformInfo

    Returns a string containing information about the system that compiled
    this version of Houdini.

    USAGE
      applicationPlatformInfo() -> string

    Most of the time you can use Python's platform module to get information
    about the current operating system, processor type, etc. However, this
    function can provide information not available through the platform
    module, such as the version of the compiler that compiled Houdini.

    > >>> hou.applicationPlatformInfo()
    > linux-x86_64-gcc4.4

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationName

      * hou.licenseCategory

      * hou.isApprentice


    """
    return _hou.applicationPlatformInfo()


def vdbVersionInfo() -> (
    "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >"
):
    return _hou.vdbVersionInfo()


def hdkAPIVersion() -> "int":
    r"""

    hou.hdkAPIVersion

    Returns the HDK API version number.

    USAGE
      hdkAPIVersion() -> int

    Returns the HDK API version number.

    This monotonically increasing value is updated to the last Houdini
    version with known ABI incompatibilities. Typically, this will be set on
    every major release and only occasionally on releases within a X.Y
    version. If this version number has changed, plugins should be
    recompiled.

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationPlatformInfo

      * hou.thirdPartyLibraryVersions


    """
    return _hou.hdkAPIVersion()


def licenseCategory() -> "HOM_EnumValue &":
    r"""

    hou.licenseCategory

    Return the category of license (Commercial, Apprentice, ApprenticeHD,
    etc.) in use.

    USAGE
      licenseCategory() -> hou.licenseCategoryType enum value

    RELATED

      * hou.licenseCategoryType

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.isApprentice


    """
    return _hou.licenseCategory()


def isApprentice() -> "bool":
    r"""

    hou.isApprentice

    Return whether the application is an apprentice (non-commercial)
    version.

    USAGE
      isApprentice() -> bool

    Return whether the hou module is using an Apprentice license. Note that
    this function returns True for both Apprentice and Apprentice HD.

    RELATED

      * hou.licenseCategory

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString


    """
    return _hou.isApprentice()


def releaseLicense() -> "void":
    r"""

    hou.releaseLicense

    Release the currently held Houdini license.

    USAGE
      releaseLicense()

    When you import the hou module into a Python shell, it will acquire a
    Houdini license. This function exists so you can release that license
    when you're done using the hou module. This way, you can have a long
    running Python script that periodically uses Houdini without having to
    hold a Houdini license for the entire duration of the script.

    After you release the license, it will automatically be reacquired when
    you access functions and objects from the hou module.


    """
    return _hou.releaseLicense()


def maxThreads() -> "int":
    r"""

    hou.maxThreads

    Returns the number of threads used for processing.

    USAGE
      maxThreads() -> int

    When Houdini/hython is started, it uses all available processors on the
    machine for multi-threaded processing, unless overridden by the -j
    command line option or the hou.setMaxThreads function.

    This function returns that maximum number of threads that Houdini/hython
    will use.

    RELATED

      * hou.setMaxThreads


    """
    return _hou.maxThreads()


def setMaxThreads(max_threads: "int") -> "void":
    r"""

    hou.setMaxThreads

    Sets the maximum number of threads to use for multi-processing.

    USAGE
      setMaxThreads(max_threads)

    When Houdini/hython is started, it uses all available processors on the
    machine for multi-threaded processing, unless overridden by the -j
    command line option.

    This function allows dynamically adjusting this setting at run-time.

    Note that this function may only be called from the main thread. If
    called from an expression that gets evaluated in a multi-threaded
    context, or during other processing, it will throw an exception.


    WARNING
        The effectiveness of this function differs on different platforms.
        Prefer using the -j command line option setting the
        HOUDINI_MAXTHREADS environment variable instead.

    WARNING
        This function currently has no effect on Linux if there are OpenCL
        nodes present in the scene.

    RELATED

      * hou.maxThreads


    """
    return _hou.setMaxThreads(max_threads)


def root() -> "HOM_Node *":
    r"""

    hou.root

    Return the root node (i.e. /).

    USAGE
      root() -> hou.Node

    This function is a shortcut for writing hou.node(\"/\").

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.node_


    """
    return _hou.root()


def pwd() -> "HOM_Node *":
    r"""

    hou.pwd

    If called from an evaluating parm, return the node containing the parm.
    Otherwise, return Houdini's global current node. You can change this
    current node with hou.cd

    USAGE
      pwd() -> hou.Node

    This function is a shortcut for writing hou.node(\".\").

    Note that Python and hscript both share the same global current node.
    So, if you change that node in hscript, the return value of pwd() will
    reflect that change, and vice versa.

    Note that if this function is called from an expression inside a node's
    parameter, Houdini will return the node containing the expression, not
    Houdini's current node. This behavior permits relative parameter and
    node references from both Hscript and Python parameter expressions,
    since functions like hou.ch, ch(), hou.evalParm, hou.parm_, and
    hou.node_ are relative to the result of hou.pwd().

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.cd

      * hou.parent


    """
    return _hou.pwd()


def parent() -> "HOM_Node *":
    r"""

    hou.parent

    Return the parent of the current node.

    USAGE
      parent() -> hou.Node or None

    This function is a shortcut for writing hou.node(\"..\"). It returns the
    parent of the current node (i.e. the node returned by hou.pwd).

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.node_


    """
    return _hou.parent()


def setPwd(node: "Node") -> "void":
    r"""

    hou.setPwd

    Make the given node Houdini's current node. This function is equivalent
    to hou.cd(node.path()).

    USAGE
      setPwd(node)

    This function will raise hou.ObjectWasDeleted if the parameter refers to
    a node that no longer exists in Houdini.

    This function will raise hou.NotAvailable if you call it from mplay.

    RELATED

      * hou.pwd

      * hou.cd

      * hou.ScriptEvalContext


    """
    return _hou.setPwd(node)


def cd(path: "char const *") -> "void":
    r"""

    hou.cd

    Change the current node. Houdini has one current node, analogous to a
    current directory in a file system. If a relative path is given, it is
    relative to the node returned by hou.pwd().

    USAGE
      cd(path)

    If no node exists at the path, this function raises hou.OperationFailed.

    Even though, when called from a parameter's expression, hou.pwd()
    returns the node containing the parameter and not Houdini's current
    node, hou.cd() will always change the current node.

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.pwd

      * hou.setPwd


    """
    return _hou.cd(path)


def phm() -> "HOM_HDAModule *":
    r"""

    hou.phm

    A shortcut for hou.pwd().hdaModule().

    USAGE
      phm() -> hou.HDAModule

    This shortcut lets you write hou.phm() instead of hou.pwd().hdaModule().
    You are most likely to use this shortcut from event handlers, button
    callbacks, and menu generation scripts in digital assets.

    See hou.pwd and hou.Node.hdaModule for more information.


    """
    return _hou.phm()


def currentDopNet() -> "HOM_Node *":
    r"""

    hou.currentDopNet

    Returns the DOP Network node set as the current simulation in the UI.

    USAGE
      currentDopNet() -> hou.Node

    The current DOP network is the network the shelf tools put new nodes
    into. The user can change this using the simulation menu in the bottom
    right corner of the main window.

    This is always a writeable dopnetwork, so not necessarily point to the
    network used for the blue cache line display. Instead, it will point to
    the last current dopnetwork that was also writeable.

    If you're building a shelf tool that creates simulation nodes, you
    should use this function to know where to put them.

    Call hou.setCurrentDopNet to set the current simulation network
    programmatically.

    RELATED

      * hou.setCurrentDopNet


    """
    return _hou.currentDopNet()


def setCurrentDopNet(dopnet: "Node") -> "void":
    r"""

    hou.setCurrentDopNet

    USAGE
      setCurrentDopNet(dopnet)

    The current DOP network is the network the shelf tools put new nodes
    into. The user can change this using the simulation menu in the bottom
    right corner of the main window. This method lets you programmatically
    set the current simulation network.

    Because the current dopentwork must always be writeable, setting this to
    a non-writeable dopnetwork will not cause hou.currentDopNet to change.
    However, it will update the current dopnetwork for the purpose of other
    UI, such as the blue cache bar, provided the node is a valid dopnetwork.

    Call hou.currentDopNet to get a hou.Node object representing the current
    DOP Network node.

    RELATED

      * hou.currentDopNet


    """
    return _hou.setCurrentDopNet(dopnet)


def simulationEnabled() -> "bool":
    r"""

    hou.simulationEnabled

    USAGE
      simulationEnabled() -> bool

    Returns True if Houdini is currently set to update simulations. The user
    can choose to disable simulation updates to improve interactivity using
    the simulation menu in the bottom right corner of the main window. Use
    hou.setSimulationEnabled to enable or disable simulation updates
    programmatically.

    RELATED

      * hou.setSimulationEnabled


    """
    return _hou.simulationEnabled()


def setSimulationEnabled(enabled: "bool") -> "void":
    r"""

    hou.setSimulationEnabled

    USAGE
      setSimulationEnabled(enabled)

    Call hou.setSimulationEnabled(True) to enable simulation updates or
    hou.setSimulationEnabled(False) to disable them. The user can choose to
    disable simulation updates to improve interactivity using the simulation
    menu in the bottom right corner of the main window. This function lets
    you set the state of that menu item programmatically. Use
    hou.simulationEnabled to check whether simulation updates are currently
    enabled.

    RELATED

      * hou.simulationEnabled


    """
    return _hou.setSimulationEnabled(enabled)


def node(path: "char const *") -> "HOM_Node *":
    r"""

    hou.node

    Given a path string, return a Node object. Return None if the path does
    not refer to a node.

    USAGE
      node(path) -> hou.Node or None

    If the path starts with a /, Houdini will look for a node with that
    exact path. Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini's current path. For
    each occurrence of .. in the path, Houdini will move up one node from
    the current location.

    Raises hou.NotAvailable if you call it from MPlay.

    Be careful not to confuse this function with the class hou.Node.

    > >>> hou.node(\"/obj\")
    > <hou.Node at /obj>
    > >>> hou.node(\"/obj\").createNode(\"geo\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.node(\"/obj\").createNode(\"geo\")
    > <hou.ObjNode of type geo at /obj/geo2>
    > >>> hou.node(\"/obj/geo1\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.cd(\"/obj\")
    > >>> hou.node(\"geo1\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.cd(\"/obj/geo2\")
    > >>> hou.node(\"../geo1\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> print hou.node(\"../geo3\")
    > None

    RELATED

      * hou.item

      * hou.items

      * hou.nodes

      * hou.pwd

      * hou.parent

      * hou.root


    """
    return _hou.node(path)


def item(path: "char const *") -> "HOM_NetworkMovableItem *":
    r"""

    hou.item

    Given a path string, return a NetworkMovableItem object. Return None if
    the path does not refer to an item.

    USAGE
      item(path) -> hou.NetworkMovableItem or None

    If the path starts with a /, Houdini will look for an item with that
    exact path. Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini's current path. For
    each occurrence of .. in the path, Houdini will move up one item from
    the current location.

    This method is a more general form of the hou.node_ method, which will
    only return hou.Node objects. But some network item types
    (hou.SubnetIndirectInput and hou.NetworkDot) do not have names, and so
    will never be returned by this method.

    Raises hou.NotAvailable if you call it from MPlay.

    > >>> hou.item(\"/obj\")
    > <hou.Node at /obj>
    > >>> hou.item(\"/obj\").createNetworkBox()
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> hou.item(\"/obj/__netbox1\")
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> hou.cd(\"/obj\")
    > >>> hou.item(\"__netbox1\")
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> print hou.item(\"__netbox2\")
    > None

    RELATED

      * hou.node_

      * hou.nodes

      * hou.items

      * hou.pwd

      * hou.parent

      * hou.root


    """
    return _hou.item(path)


def nodes(
    paths: "_StringTuple",
) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
    r"""

    hou.nodes

    Takes a sequence of node path strings and returns a tuple of Node
    objects.

    USAGE
      nodes(path_tuple) -> tuple of hou.Node

    This is like hou.node_ but takes multiple paths and returns multiple
    node objects. See hou.node_ for more information.

    > paths = [\"/obj/geo1\", \"/obj/geo2\", \"/obj/geo3\"]
    > nodes = hou.nodes(paths)

    This is the equivalent of:

    > nodes = [hou.node(path) for path in paths]

    RELATED

      * hou.item

      * hou.items

      * hou.node

      * hou.pwd

      * hou.parent

      * hou.root


    """
    return _hou.nodes(paths)


def items(
    paths: "_StringTuple",
) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
    r"""

    hou.items

    Takes a sequence of node path strings and returns a tuple of
    NetworkMovableItem objects.

    USAGE
      item(path_tuple) -> tuple of hou.NetworkMovableItem or None

    This is like hou.items but takes multiple paths and returns multiple
    item objects. See hou.item for more information.

    > paths = [\"/obj/geo1\", \"/obj/geo2\", \"/obj/geo3\"]
    > items = hou.items(paths)

    This is the equivalent of:

    > items = [hou.item(path) for path in paths]

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.node_

      * hou.nodes

      * hou.item

      * hou.pwd

      * hou.parent

      * hou.root


    """
    return _hou.items(paths)


def nodeBySessionId(session_id: "int") -> "HOM_Node *":
    r"""

    hou.nodeBySessionId

    Given a node's session id, return a Node object. Return None if the id
    does not correspond to a valid node (e.g. if the node was deleted).

    USAGE
      nodeBySessionId(session_id) -> hou.Node or None

    See hou.Node.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.node_

      * hou.Node.sessionId


    """
    return _hou.nodeBySessionId(session_id)


def networkBoxBySessionId(session_id: "int") -> "HOM_NetworkBox *":
    r"""

    hou.networkBoxBySessionId

    Given a network box's session id, return a NetworkBox object. Return
    None if the id does not correspond to a valid network box.

    USAGE
      networkBoxBySessionId(session_id) -> hou.NetworkBox or None

    See hou.NetworkBox.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.NetworkBox.sessionId


    """
    return _hou.networkBoxBySessionId(session_id)


def stickyNoteBySessionId(session_id: "int") -> "HOM_StickyNote *":
    r"""

    hou.stickyNoteBySessionId

    Given a sticky note's session id, return a StickyNote object. Return
    None if the id does not correspond to a valid sticky note.

    USAGE
      stickyNoteBySessionId(session_id) -> hou.StickyNote or None

    See hou.StickyNote.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.StickyNote.sessionId


    """
    return _hou.stickyNoteBySessionId(session_id)


def subnetIndirectInputBySessionId(session_id: "int64") -> "HOM_SubnetIndirectInput *":
    r"""

    hou.subnetIndirectInputBySessionId

    Given a subnet input's session id, return a SubnetIndirectInput object.
    Return None if the id does not correspond to a valid subnet input (e.g.
    if the subnet containing the input was deleted).

    USAGE
      subnetIndirectInputBySessionId(session_id) -> hou.SubnetIndirectInput
      or None

    See hou.SubnetIndirectInput.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.SubnetIndirectInput.sessionId


    """
    return _hou.subnetIndirectInputBySessionId(session_id)


def networkDotBySessionId(session_id: "int") -> "HOM_NetworkDot *":
    r"""

    hou.networkDotBySessionId

    Given a dot's session id, return a NetworkDot object. Return None if the
    id does not correspond to a valid dot (e.g. if the dot was deleted).

    USAGE
      networkDotBySessionId(session_id) -> hou.NetworkDot or None

    See hou.NetworkDot.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.NetworkDot.sessionId


    """
    return _hou.networkDotBySessionId(session_id)


def itemBySessionId(
    item_type: "EnumValue", session_id: "int64"
) -> "HOM_NetworkMovableItem *":
    r"""

    hou.itemBySessionId

    Given an item's session id and an item type, return a NetworkMovableItem
    object. Return None if the id does not correspond to a valid item.

    This function is equivalent to a series of if statements checking the
    item_type enum value, and calling the more specific session id functions
    such as hou.nodeBySessionId. It allows network items to be treated in a
    uniform manner by code that is expected to handle a variety of network
    item types.

    The item_type parameter should be one of the hou.networkItemType enum
    values, except hou.networkItemType.Connection, which doesn't support
    lookup using a single session id value.

    USAGE
      itemBySessionId(item_type, session_id) -> hou.NetworkMovableItem or
      None

    See hou.NetworkMovableItem.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.networkBoxBySessionId

      * hou.networkDotBySessionId

      * hou.nodeBySessionId

      * hou.stickyNoteBySessionId

      * hou.subnetIndirectInputBySessionId

      * hou.NetworkMovableItem.sessionId


    """
    return _hou.itemBySessionId(item_type, session_id)


def nodeConnectionBySessionId(
    session_id: "int", input_index: "int"
) -> "HOM_NodeConnection *":
    r"""

    hou.nodeConnectionBySessionId

    Given a node's session id and an input index, return a NodeConnection
    object. Return None if the id does not correspond to a valid node (e.g.
    if the node was deleted), or the specified input index is not connected.

    USAGE
      nodeConnectionBySessionId(session_id, input_index) ->
      hou.NodeConnection or None

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.nodeBySessionId

      * hou.Node.sessionId


    """
    return _hou.nodeConnectionBySessionId(session_id, input_index)


def defaultColor(color_item: "EnumValue") -> "HOM_Color":
    r"""

    hou.defaultColor

    Return the default color for a particular network element.

    USAGE
      defaultColor(color_item) -> hou.Color

    Returns the default color that will be used for new network elements
    such as network boxes and sticky notes. Node default colors are
    controlled with methods on the hou.NodeType.

    RELATED

      * hou.colorItemType

      * hou.NodeType.defaultColor

      * hou.setDefaultColor


    """
    return _hou.defaultColor(color_item)


def setDefaultColor(color_item: "EnumValue", color: "Color") -> "void":
    r"""

    hou.setDefaultColor

    Return the setDefault color for a particular network element.

    USAGE
      setDefaultColor(color_item, color)

    Sets the default color that will be used for new network elements such
    as network boxes and sticky notes. Node default colors are controlled
    with methods on the hou.NodeType for each node type.

    The color parameter can either be a hou.Color or None, in which case the
    default color is cleared, and the standard default colors are used.

    RELATED

      * hou.colorItemType

      * hou.defaultColor

      * hou.NodeType.setDefaultColor


    """
    return _hou.setDefaultColor(color_item, color)


def selectedNodes(
    include_hidden: "bool" = False,
) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
    r"""

    hou.selectedNodes

    Return a list of all selected nodes.

    USAGE
      selectedNodes(include_hidden=False) -> tuple of hou.Node

    Returns a sequence of hou.Node objects representing the nodes that are
    currently selected.

    > print(\"The following nodes are currently selected:\")
    > for node in hou.selectedNodes():
    >     print(node.path())

    The last selected item has special meaning in Houdini: it controls what
    network unpinned panes focus on.

    > selected = hou.selectedNodes()
    > # In Python, a negative index counts from the end
    > print(\"Following:\", selected[-1])

    include_hidden
        Normally, hidden nodes will not be included in the results, even if
        they are selected. Use include_hidden=True to get the selected
        hidden nodes as well. See hou.Node.isHidden for more information
        about hidden nodes.


    """
    return _hou.selectedNodes(include_hidden)


def selectedItems(
    include_hidden: "bool" = False,
) -> "std::vector< HOM_ElemPtr< HOM_NetworkMovableItem >,std::allocator< HOM_ElemPtr< HOM_NetworkMovableItem > > >":
    r"""

    hou.selectedItems

    Return a list of all selected nodes, network boxes, sticky notes, subnet
    indirect inputs, and network dots.


    selectedItems(include_hidden=False) -> tuple of hou.NetworkMovableItem

    If include_hidden is False, hidden nodes will not in the result, even if
    they are selected. See hou.Node.isHidden for more information about
    hidden nodes. Other item types do not support hiding and so are
    unaffected by the value of this parameter.

    The following example will print the positions of all selected items:

    > for n in hou.selectedItems():
    >     print n.position()

    """
    return _hou.selectedItems(include_hidden)


def selectedConnections() -> (
    "std::vector< HOM_ElemPtr< HOM_NodeConnection >,std::allocator< HOM_ElemPtr< HOM_NodeConnection > > >"
):
    r"""

    hou.selectedConnections

    Return a list of all selected node connections.


    selectedConnections() -> tuple of hou.NodeConnection

    The following example will print the name of the input node for all
    selected connections:

    > for conn in hou.selectedConnections():
    >     print conn.inputNode().name()

    """
    return _hou.selectedConnections()


def clearAllSelected() -> "void":
    r"""

    hou.clearAllSelected

    Clears the selected state for all nodes, network boxes, and other
    subclasses of hou.NetworkMovableItem in the Houdini session.

    USAGE
      clearAllSelected()

    This function is equivalent to traversing the node hierarchy and calling
    setSelected(False) on every hou.NetworkMovableItem in the scene, but
    operates much much faster.

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.NetworkBoxItem.isSelected

      * hou.NetworkBoxItem.setSelected


    """
    return _hou.clearAllSelected()


def copyNodesToClipboard(nodes: "_NodeTuple") -> "void":
    r"""

    hou.copyNodesToClipboard

    Copies a list of nodes to the clipboard.

    USAGE
      copyNodesToClipboard(nodes)

    The nodes argument should be a sequence of hou.Node objects that have
    the same parent. Copying nodes from different networks at the same time
    is currently not supported.


    TIP
        The copyItemsToClipboard() and pasteItemsFromClipboard() methods of
        hou.Node (called on the parent node) provide a more general way of
        copying and pasting. They work with all types of network items (for
        example, sticky notes and grouping boxes), not just nodes.

    RELATED

      * hou.pasteNodesFromClipboard

      * hou.Node.copyItemsToClipboard

      * hou.Node.pasteItemsFromClipboard


    """
    return _hou.copyNodesToClipboard(nodes)


def pasteNodesFromClipboard(destination_node: "Node") -> "void":
    r"""

    hou.pasteNodesFromClipboard

    Paste previously copied nodes to a given network.

    USAGE
      pasteNodesFromClipboard(destination_node)

    This function pastes nodes from clipboard into the destination network.

    RELATED

      * hou.copyNodesToClipboard

      * hou.Node.copyItemsToClipboard() and
        hou.Node.pasteItemsFromClipboard().


    """
    return _hou.pasteNodesFromClipboard(destination_node)


def parm(path: "char const *") -> "HOM_Parm *":
    r"""

    hou.parm

    Given a path string, return a Parm object. Return None if the path does
    not refer to a parameter.

    USAGE
      parm(path) -> hou.Parm or None

    If the path starts with a /, Houdini will look for a parameter with that
    exact path. Otherwise, the Houdini searches relative to the current node
    path. For each occurrence of .. in the path, Houdini will move up one
    node from the current node location.

    > >>> node = hou.node(\"/obj\").createNode(\"geo\")
    > >>> node.path()
    > '/obj/geo1'
    > >>> hou.parmTuple(\"/obj/geo1/t\")
    > <hou.ParmTuple t in /obj/geo1>
    > >>> hou.parmTuple(\"/obj/geo1/t\")[0]
    > <hou.Parm tx in /obj/geo1>
    > >>> hou.parm(\"/obj/geo1/tx\")
    > <hou.Parm tx in /obj/geo1>
    > >>> hou.setPwd(node)
    > >>> hou.parm(\"t\")
    > <hou.Parm tx in /obj/geo1>

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.Parm

      * hou.evalParm

      * hou.parmTuple_


    """
    return _hou.parm(path)


def parmTuple(path: "char const *") -> "HOM_ParmTuple *":
    r"""

    hou.parmTuple

    Given a path string, return a ParmTuple object. Return None if the path
    does not refer to a parameter tuple.

    USAGE
      parmTuple(path) -> hou.ParmTuple or None

    If the path starts with a /, Houdini will look for a parameter tuple
    with that exact path. Otherwise, the Houdini searches relative to the
    current node path. For each occurrence of .. in the path, Houdini will
    move up one node from the current node location.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.parmTuple() can be used inside expressions to perform
    relative parameter references.

    > >>> node = hou.node(\"/obj\").createNode(\"geo\")
    > >>> node.path()
    > '/obj/geo1'
    > >>> hou.parmTuple(\"/obj/geo1/t\")
    > <hou.ParmTuple t in /obj/geo1>
    > >>> hou.setPwd(node)
    > >>> hou.parmTuple(\"tx\")
    > <hou.ParmTuple t in /obj/geo1>

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.ParmTuple

      * hou.evalParmTuple

      * hou.parm_


    """
    return _hou.parmTuple(path)


def evaluatingParm() -> "HOM_Parm *":
    r"""

    hou.evaluatingParm

    Return the parameter that is currently evaluating.

    USAGE
      evaluatingParm() -> hou.Parm

    You can call this function from a parameter expression to determine
    which parameter is currently evaluating. This function provides the
    Python equivalent of Hscript's $CH variable.

    RELATED

      * hou.ScriptEvalContext


    """
    return _hou.evaluatingParm()


def parmClipboardContents() -> (
    "std::vector< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >,std::allocator< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > > >"
):
    r"""

    hou.parmClipboardContents

    Returns the contents of the parameter clipboard as a tuple of copied
    parameter dictionaries.

    USAGE
      parmClipboardContents() -> tuple of dictionaries

    Returns a tuple of dictionaries, one per copied hou.Parm. Each
    dictionary has the following keys.


    path
        The path of hou.Parm parameter when it was copied.

    value
        The evaluated value of the parameter when it was copied as a string.

    expression
        The expression of the parameter when it was copied as a string.

    expressionLanguage
        The expression language of the parameter when it was copied. This is
        a string. To convert to a hou.exprLanguage object, use
        getattr(hou.exprLanguage, expr_language_str).

    RELATED

      * hou.Parm.copyToParmClipboard

      * hou.ParmTuple.copyToParmClipboard


    """
    return _hou.parmClipboardContents()


def evalParm(path: "char const *") -> "InterpreterObject":
    r"""

    hou.evalParm

    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parm(path).eval().

    USAGE
      evalParm(path) -> int, float, or string

    The return type will depend on the type of the parameter.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParm() can be used inside expressions to perform
    relative parameter references.

    This function throws a hou.NotAvailable exception if you call it from
    MPlay.

    RELATED

      * hou.evalParmTuple

      * hou.Parm

      * hou.ParmTuple


    """
    return _hou.evalParm(path)


def evalParmTuple(path: "char const *") -> "InterpreterObject":
    r"""

    hou.evalParmTuple

    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parmTuple(path).eval().

    USAGE
      evalParmTuple(path) -> tuple of int, float, or str, or hou.Ramp

    The return type will depend on the type of the parameter.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParmTuple() can be used inside expressions to
    perform relative parameter references.

    This function throws a hou.NotAvailable exception if you call it from
    MPlay.

    RELATED

      * hou.evalParm

      * hou.Parm

      * hou.ParmTuple


    """
    return _hou.evalParmTuple(path)


def ch(path: "char const *") -> "InterpreterObject":
    r"""

    hou.ch

    The same as evalParm(). Provided for backward compatibility.

    USAGE
      ch(path) -> int, float, or string

    RELATED

      * hou.evalParm

      * hou.evalParmTuple

      * hou.chsop

      * hou.chsoplist

      * hou.parm

      * hou.parmTuple


    """
    return _hou.ch(path)


def hscriptExpression(expression: "char const *") -> "InterpreterObject":
    r"""

    hou.hscriptExpression

    Evaluate an Hscript expression.

    USAGE
      hscriptExpression(expression_string) -> float, str, or tuple

    Given an expression string, this function evaluates it as though it was
    an HScript expression on a parameter. The return type depends on the
    expression.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    > >>> hou.hscriptExpression(\"$HIP\")
    > '/path/to/hip/directory'
    > >>> hou.hscriptExpression(\"$F\")
    > 1.0
    > >>> hou.hscriptExpression('vector(\"[1, 2, 3]\")')
    > (1.0, 2.0, 3.0)
    > >>> hou.hscriptExpression('matrix(\"[[1, 2][3, 4]]\")')
    > ((1.0, 2.0), (3.0, 4.0))
    > >>> hou.hscriptExpression(\"hello\")
    > 'hello'
    > >>> hou.hscriptExpression(\"'hello'\")
    > 'hello'
    > >>> hou.hscriptExpression(\"'hello' + ' world'\")
    > 'hello world'
    > >>> hou.hscriptExpression('\"$F\"')
    > '1'
    > >>> hou.hscriptExpression(\"'$F'\")
    > '$F'

    This function is somewhat similar to hou.expandString, however,
    expandString will replace the portions of the string containing
    variables, leaving the rest of the string unchanged. If the variable is
    unknown, it will not do any expansion.

    > >>> hou.expandString(\"$HOME\")
    > '/home/me'
    > >>> hou.expandString(\"HOME is $HOME\")
    > 'HOME is /home/me'
    > >>> hou.hscriptExpression(\"HOME is $HOME\")
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Syntax error - extra tokens detected in expression
    > >>> hou.expandString(\"$F\")
    > '1'
    > >>> hou.expandString('\"$F\"')
    > '\"1\"'
    > >>> hou.hscriptExpression(\"$GARBAGE\")
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Undefined variable
    > >>> hou.expandString(\"$GARBAGE\")
    > '$GARBAGE'
    > >>> hou.hscript(\"echo -n $GARBAGE\")[0]
    > ''
    > >>> hou.expandString(\"\")
    > ''
    > >>> hou.hscriptExpression(\"\")
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Invalid expression

    RELATED

      * hou.hscriptFloatExpression

      * hou.hscriptStringExpression

      * hou.hscriptVectorExpression

      * hou.hscriptMatrixExpression

      * hou.expandString

      * hou.expandStringAtFrame


    """
    return _hou.hscriptExpression(expression)


def expressionGlobals() -> "InterpreterObject":
    r"""

    hou.expressionGlobals

    Return the globals dictionary used by the parameter expression
    evaluation namespace.

    USAGE
      expressionGlobals() -> dict

    When Houdini evaluates a Python expression inside a parameter, it uses a
    separate namespace. This way, Houdini can run from hou import * and from
    hou.session import * in that namespace, allowing you to drop the hou.
    and hou.session. prefixes in your expressions, and the global namespace
    does not get polluted.

    In Python, namespaces are stored as dictionaries. This function returns
    the dictionary for the Python parameter expression namespace. It is
    analogous to the builtin globals function, which returns you the
    dictionary for the current namespace.

    You might use this function from the pythonrc.py file to set up Python
    functions that can be called from any Python parameter expression. For
    example, if you put your functions in a module called expr, you might
    put the following in pythonrc.py:

    > import expr
    > hou.expressionGlobals()['expr'] = expr

    Then, from a Python expression, you could write expr.foo(), where foo is
    a function defined in your expr module.

    You can also use this dictionary with Python's exec statement. The
    following example also imports the expr module into the both the global
    and expression namespaces:

    > code = compile(\"import expr\", \"<generated_code>\", \"exec\")
    > exec code
    > exec code in hou.expressionGlobals()

    See Python Parameter Expressions for more information on using Python
    expressions in parameters. See startup scripts for more information
    about pythonrc.py.


    """
    return _hou.expressionGlobals()


def lvar(name: "char const *") -> "InterpreterObject":
    r"""

    hou.lvar

    Return the value of a node's local variable. Call this function from
    expressions inside node parameters.

    USAGE
      lvar(name) -> float or string

    Many node algorithms involve iterating over a series of points (or
    primitives or vertices, but we'll use points for the examples). These
    nodes evaluate their parameters for each point, setting a variable that
    you can access from an expression in that parameter to a value specific
    to that point. For example, the TX variable is set to evaluate to the X
    value of the position of the current point. These variables are called
    local variables because they are local to the expressions inside
    parameters in the node.

    In the Hscript expression language, you use $ to evaluate local
    variables, just like how you evaluate global variables. In Python, you
    use the lvar function. So, the Python equivalent of $TX is lvar(\"TX\").


    TIP
        Inside a parameter expression you can drop the hou. prefix from the
        call to lvar, since Houdini implicitly runs from hou import * when
        it evaluates expressions.

    If you call this function from outside a parameter expression it will
    raise hou.NotAvailable. If you call it with an invalid variable name, it
    will raise hou.OperationFailed. Note that you cannot use this function
    to evaluate Houdini global variables; instead use hou.expandString.

    Note that hou.SopNode.curPoint and similar methods on the hou.SopNode
    class return the current point that the node is iterating over. Using
    the point, you can evaluate attributes, etc, to perform the equivalent
    of a local variable. You can also access information that may not be
    accessible through local variables.

    RELATED

      * hou.SopNode.curPoint

      * hou.SopNode.curPoint2

      * hou.SopNode.curPrim

      * hou.SopNode.curPrim2

      * hou.SopNode.curVertex

      * hou.SopNode.curVertex2

      * hou.expandString


    """
    return _hou.lvar(name)


def contextOption(opt: "char const *") -> "InterpreterObject":
    r"""

    hou.contextOption

    Returns the value of a cook context option.

    USAGE
      contextOption(option) -> float or str

    The return type will depend on the type of data used to set the option
    value.

    Retrieves the current value of a cook context option. This may have been
    set by a node requesting data from another node, or from the global
    default context option values stored in the hip file. A number of
    context options are also set and maintained automatically by Houdini.
    See hou.isAutoContextOption for a list of these automatic options.

    RELATED

      * hou.contextOptionNames

      * hou.hasContextOption

      * hou.isAutoContextOption

      * hou.setContextOption


    """
    return _hou.contextOption(opt)


def loadCPIODataFromString(
    data: "InterpreterObject",
) -> "std::vector< std::pair< std::string,HOM_BinaryString >,std::allocator< std::pair< std::string,HOM_BinaryString > > >":
    r"""

    hou.loadCPIODataFromString

    Given a binary string containing data in CPIO data format, decode the
    data and return a sequence of (name, value) pairs representing the data.

    USAGE
      loadCPIODataFromString(data) -> tuple of (str, str)

    CPIO data format stores an ordered sequence of (name, value) pairs. The
    same name may occur multiple times. Is most commonly used to store hip
    files and contents sections inside assets. The other common file format
    used in Houdini is index file format.

    The data must be a bytes object in Python 3 and a str object in Python
    2. See HOM binary data for more information.

    If the data is not in CPIO data format, this function returns an empty
    tuple.

    The inverse of this function is hou.saveCPIODataToString.

    RELATED

      * hou.saveCPIODataToString

      * hou.loadIndexDataFromString

      * hou.saveIndexDataToString


    """
    return _hou.loadCPIODataFromString(data)


def loadIndexDataFromString(
    data: "InterpreterObject",
) -> "std::map< std::string,HOM_BinaryString,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_BinaryString > > >":
    r"""

    hou.loadIndexDataFromString

    Given a binary string containing data in index data format, decode the
    data and return a dictionary representing the data.

    USAGE
      loadIndexDataFromString(data) -> dict

    Index data format stores an unordered mapping of (key, value) pairs
    where keys are str objects and the values are str objects or binary
    strings. Binary strings are str objects in Python 2 and bytes objects in
    Python 3 (see HOM binary data for more information). Is used to store
    otl files and asset definition sections, preset files, icon archives,
    and other files in Houdini. The other common file format used in Houdini
    is CPIO.

    If the data is not in index data format, this function returns an empty
    dictionary.

    The inverse of this function is hou.saveIndexDataToString.

    RELATED

      * hou.saveIndexDataToString

      * hou.loadIndexDataFromFile

      * hou.saveIndexDataToFile

      * hou.loadCPIODataFromString

      * hou.saveCPIODataToString


    """
    return _hou.loadIndexDataFromString(data)


def addContextOptionChangeCallback(callback: "InterpreterObject") -> "void":
    r"""

    hou.addContextOptionChangeCallback

    Adds a callback to be executed when a default context option is changed.

    USAGE
      addContextOptionChangeCallback(callback)

    Adds a callback that is run every time a global context option is
    changed. This refers to context options set in the Edit -> Context
    Options window. The callback is not run when a context option value is
    modified by a node, such as the Edit Context Options LOP.

    The callback is run whenever the value a context option changes, when a
    new context option is added, the UI description of a context option is
    changed, or when a context option is removed. In all cases, the name of
    the modified context option is passed as a string to the callback
    function.

    RELATED

      * hou.contextOptionChangeCallbacks

      * hou.removeContextOptionChangeCallback

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
    return _hou.addContextOptionChangeCallback(callback)


def removeContextOptionChangeCallback(callback: "InterpreterObject") -> "void":
    r"""

    hou.removeContextOptionChangeCallback

    Stops a callback from being executed when a default context option is
    changed.

    USAGE
      removeContextOptionChangeCallback(callback)

    Removes a callback that was previously registered with
    hou.addContextOptionChangeCallback. If the supplied callback is not
    currently registered, a hou.OperationFaile exception is raised.

    RELATED

      * hou.addContextOptionChangeCallback

      * hou.contextOptionChangeCallbacks

      * hou.removeAllContextOptionChangeCallbacks

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
    return _hou.removeContextOptionChangeCallback(callback)


def contextOptionChangeCallbacks() -> (
    "std::vector< InterpreterObject,std::allocator< InterpreterObject > >"
):
    r"""

    hou.contextOptionChangeCallbacks

    Returns all callbacks registered to be called when a default context
    option is changed.

    USAGE
      contextOptionChangeCallbacks()

    Returns all callbacks that have been registered with
    hou.addContextOptionChangeCallback.

    RELATED

      * hou.addContextOptionChangeCallback

      * hou.removeAllContextOptionChangeCallbacks

      * hou.removeContextOptionChangeCallback

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
    return _hou.contextOptionChangeCallbacks()


def hscriptFloatExpression(expression: "char const *") -> "double":
    r"""

    hou.hscriptFloatExpression

    Evaluate an Hscript expression as a float.

    USAGE
      hscriptFloatExpression(expression) -> float

    This function will force the return type to be a float.

    Most of the time, you want to use hou.hscriptExpression over this
    function. See it for more examples.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    If the expression contains variables, Houdini will attempt to evaluate
    them as floats, and use the value 0.0 if they cannot be converted to
    floats. However, if the expression definitely evaluates to a string that
    does not start with a number, this function raises hou.OperationFailed.

    > >>> hou.hscriptFloatExpression(\"3\")
    > 3.0
    > >>> hou.hscriptFloatExpression(\"'3'\")
    > 3.0
    > >>> hou.hscriptFloatExpression(\"'3X'\")
    > 3.0
    > >>> hou.hscriptFloatExpression(\"'X3'\")
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    > >>> hou.hscriptFloatExpression(\"3X\")
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Syntax error - extra tokens detected in expression
    > >>> hou.hscriptFloatExpression(\"$F\")
    > 1.0
    > >>> hou.hscriptFloatExpression('\"$F\"')
    > 1.0
    > >>> hou.hscriptFloatExpression(\"$HOME\")
    > 0.0
    > >>> hou.hscriptFloatExpression('\"$HOME\"')
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    > >>> hou.hscriptFloatExpression(\"'$F'\")
    > Traceback (most recent call last):
    >   File \"<console>\", line 1, in <module>
    >   File \"/opt/hfs10.5/houdini/python2.5libs/hou.py\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation

    RELATED

      * hou.hscriptExpression

      * hou.hscriptStringExpression

      * hou.hscriptVectorExpression

      * hou.hscriptMatrixExpression


    """
    return _hou.hscriptFloatExpression(expression)


def hscriptStringExpression(expression: "char const *") -> "std::string":
    r"""

    hou.hscriptStringExpression

    Evaluate an Hscript expression as a string.

    USAGE
      hscriptStringExpression(expression) -> string

    This function will force the return type to be a string. If the
    expression does not evaluate to a string, this function returns its
    string representation.

    Most of the time, you want to use hou.hscriptExpression over this
    function. See it for more examples.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    > >>> hou.hscriptStringExpression(\"3\")
    > '3'
    > >>> hou.hscriptStringExpression('\"3\"')
    > '3'
    > >>> hou.hscriptStringExpression(\"$F\")
    > '1'
    > >>> hou.hscriptStringExpression('vector(\"[1, 2, 3]\")')
    > '[1,2,3]'

    RELATED

      * hou.hscriptExpression

      * hou.hscriptFloatExpression

      * hou.hscriptVectorExpression

      * hou.hscriptMatrixExpression


    """
    return _hou.hscriptStringExpression(expression)


def hscriptVectorExpression(
    expression: "char const *",
) -> "std::vector< double,std::allocator< double > >":
    r"""

    hou.hscriptVectorExpression

    Evaluate an Hscript expression as a vector.

    USAGE
      hscriptVectorExpression(expression) -> tuple of floats

    This function will force the return type to be an Hscript vector.
    Because Hscript vectors can be be of different lengths, the value is
    returned as a tuple of floats. If you know the vector is a particular
    length, you can construct a Vector2/Vector3/Vector4 out of the return
    value.

    Most of the time, you want to use hou.hscriptExpression over this
    function.

    > vector = hou.Vector3(hou.hscriptVectorExpression('vtorigin(\"/obj/geo1\", \"/obj/geo2\")'))
    > print vector.length()

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    RELATED

      * hou.hscriptExpression

      * hou.hscriptFloatExpression

      * hou.hscriptStringExpression

      * hou.hscriptMatrixExpression

      * hou.Vector2

      * hou.Vector3

      * hou.Vector4


    """
    return _hou.hscriptVectorExpression(expression)


def hscriptMatrixExpression(
    expression: "char const *",
) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
    r"""

    hou.hscriptMatrixExpression

    Evaluate an Hscript expression as a matrix.

    USAGE
      hscriptMatrixExpression(expression) -> tuple of tuple of floats

    This function will force the return type to be an Hscript matrix.
    Because Hscript matrices can be be of different sizes, the value is
    returned as a tuple of tuples of floats. If you know the matrix is a
    particular size, you can construct a Matrix3/Matrix4 out of the return
    value.

    Most of the time, you want to use hou.hscriptExpression over this
    function.

    > xform = hou.Matrix4(hou.hscriptMatrixExpression('doptransform(\"/obj/dopnet1\", \"obj0\", \"Geometry\")'))

    Raises hou.OperationFailed if the expression is invalid or generates an
    error during evaluation.

    RELATED

      * hou.hscriptExpression

      * hou.hscriptFloatExpression

      * hou.hscriptStringExpression

      * hou.hscriptVectorExpression

      * hou.Matrix3

      * hou.Matrix4


    """
    return _hou.hscriptMatrixExpression(expression)


def getenv(name: "char const *", default_value: "char const *" = None) -> "char *":
    r"""

    hou.getenv

    Return the value of the specified Houdini environment variable.

    USAGE
      getenv(name, default_value=None) -> str

    Return the value of the specified Houdini environment variable. Return
    default_value if the environment variable does not exist.

    RELATED

      * hou.putenv

      * hou.unsetenv


    """
    return _hou.getenv(name, default_value)


def putenv(name: "char const *", value: "char const *") -> "void":
    r"""

    hou.putenv

    Set the value of the specified Houdini environment variable.

    USAGE
      putenv(name, value)

    Set the value of the specified Houdini environment variable.

    RELATED

      * hou.getenv

      * hou.unsetenv


    """
    return _hou.putenv(name, value)


def unsetenv(name: "char const *") -> "void":
    r"""

    hou.unsetenv

    Unset the specified Houdini environment variable.

    USAGE
      unsetenv(name)

    Unset the specified Houdini environment variable.

    RELATED

      * hou.getenv

      * hou.putenv


    """
    return _hou.unsetenv(name)


def allowEnvironmentToOverwriteVariable(name: "char const *", onoff: "bool") -> "void":
    r"""

    hou.allowEnvironmentToOverwriteVariable

    Allow (or disallow) an environment variable to overwrite the value of a
    global variable saved in a hip file.

    USAGE
      allowEnvironmentToOverwriteVariable(name, onoff)

    Note that you need to allow the variable to be overwritten from within
    Houdini/hython before loading in the hip file.

    For example, suppose you set the JOB environment variable to
    /home/john/dyproject and created a hip file in
    /home/john/myproject/hip/scene.hip. Your hip file could then reference
    files using a $JOB prefix. If you then moved your project to
    /mnt/projects/myproject you cannot simply change the JOB environment
    variable because Houdini saved the old value of $JOB to the hip file.
    This function lets you override the value of $JOB before you load the
    hip file, as follows:

    > import os
    > os.environ[\"JOB\"] = \"/mnt/projects/myproject\"
    > hou.allowEnvironmentToOverwriteVariable(\"JOB\", True)
    > hou.hipFile.load(os.path.expandvars(\"$JOB/hip/scene.hip\"))

    """
    return _hou.allowEnvironmentToOverwriteVariable(name, onoff)


def updateProgressAndCheckForInterrupt(percentage: "int" = -1) -> "bool":
    r"""

    hou.updateProgressAndCheckForInterrupt

    Deprecated: Use InterruptableOperation.

    Check if the user pressed Escape to interrupt the current operation, and
    optionally update the completion progress.

    USAGE
      updateProgressAndCheckForInterrupt(percentage=-1) -> bool


    WARNING
        This is deprecated. Use hou.InterruptableOperation instead.

    Return True if the user pressed Escape and False otherwise.


    percentage
        An integer value containing the percentage complete to display in
        the taskbar. If the percentage is -1, the taskbar will not display
        the completion percentage.

    You would typically call this function from inside a Python SOP, to let
    the user of the SOP press escape to interrupt a long cook.

    See Define a new SOP type using Python for an example.


    """
    return _hou.updateProgressAndCheckForInterrupt(percentage)


def runVex(
    *args, **kwargs
) -> "std::map< std::string,hboost::any,std::less< std::string >,std::allocator< std::pair< std::string const,hboost::any > > >":
    r"""

    hou.runVex

    Invokes the main function in a compiled VEX file, returning the exported
    values.

    USAGE
      runVex(vex_file, inputs, precision=\"32\") -> dict of str to values

    ARGUMENTS


        vex_file
            A string containing the path to a compiled VEX object file
            (.vex) on disk. This function does not accept VEX source code
            (.vfl), you must compile the source code first.

            Currently this function only works with functions in the cvex
            context.

            runVex currently raises an exception if the file path does not
            end with .vex.


            NOTE
                runVex always calls the main function in the compiled file
                (the function whose return type is the context type, cvex).
                It is not currently possible to call another function in the
                compiled file by name.

        inputs
            A dictionary mapping VEX input names to values.

          * If a value is a single number, string, hou.Vector3, hou.Vector4,
            hou.Matrix3, or hou.Matrix4, it is treated as a static value.

          * If a value is a sequence of values, it is treated as varying
            data the function will iterate over (possibly in parallel)
            automatically. This is the same as when, for example, a VEX
            snippet runs over all the points in a geometry. It is more
            efficient to call the function once with varying data than to
            call it separately for each of a list of different values.

          * If you supply multiple varying inputs, they must all be the same
            length and all values must be the same type. Houdini iterates
            over the corresponding values at each index of the varying
            sequences.

                For example, you might have two arguments corresponding to a
                point's color (Cd) and position (P) attributes:

              > runVex(\"test.vex\", {
              >     \"Cd\": [hou.Vector3(1.0, 0, 0), hou.Vector3(0, 1.0, 0), hou.Vector3(0, 0, 1.0)],
              >     \"P\": [hou.Vector3(1.0, 1.0, 1.0), hou.Vector3(2.0, 2.0, 2.0), hou.Vector3(3.0, 3.0, 3.0)]
              > })

                Houdini would zip the two lists together and iterate using
                the following values:

                1
                Vector3(1.0, 0, 0)

                Vector3(1.0, 1.0, 1.0)

                2
                Vector3(0, 1.0, 0)

                Vector3(2.0, 2.0, 2.0)

                3
                Vector3(0, 0, 1.0)

                Vector3(3.0, 3.0, 3.0)


            NOTE
                Because this function interprets a sequence as varying data,
                it is not currently possible for this function to call VEX
                with array arguments.

        precision
            Either \"32\" or \"64\". If you specify \"64\" Houdini will run the
            VEX snippet in 64-bit mode.

    RETURNS

        runVex() returns a dictionary mapping VEX output names to values.

        The main VEX function does not directly return values, it can only
        write to arguments marked export. This dictionary contains the
        output value of the exported arguments.

        If the input to the argument was static, the output will be a single
        value. If the input to the argument was varying, the output will be
        a tuple of values. If multiple arguments were varying, the output
        tuples will all be the same length.

    EXAMPLE

        For example, if you have the following code.vfl file and compile it
        to code.vex using vcc:

      > cvex add(float x=0; float y=0; export float out=0)
      > {
      >     out = x + y;
      > }

        You can then invoke it from Python using the following:

      > >>> hou.runVex(\"code.vex\", {\"x\":(1.0, 2.0, 3.0), \"y\":(7.1, 8.1, 9.1)})
      > {\"out\": (8.1, 10.1, 12.1)}
      > >>> hou.runVex(\"code.vex\", {\"x\":(1.0, 2.0, 3.0), \"y\":0.5})
      > {\"out\": (1.5, 2.5, 3.5)}
      > >>> hou.runVex(\"code.vex\", {\"x\":1.0, \"y\":0.5})
      > {\"out\": 1.5}
      > >>> hou.runVex(\"code.vex\", {\"x\":1.0, \"y\":0.5}, precision=\"64\")
      > {\"out\": 1.5}

    USING A VOP NETWORK

        The following code shows how you can write the VEX code created by a
        VOP network node (such as a CVEX VOP) to a file, for use with
        runVex:

      > import os
      > import tempfile
      >
      > def runVexFromNode(vop_node, input_dict):
      >     handle, path = tempfile.mkstemp(prefix=vop_node.name(), suffix=\".vex\")
      >     vop_node.saveCompiledCookCodeToFile(path)
      >     os.close(handle)
      >     output_dict = hou.runVex(path, input_dict)
      >     os.remove(path)
      >     return output_dict


    """
    return _hou.runVex(*args, **kwargs)


def saveImageDataToFile(*args) -> "void":
    r"""

    hou.saveImageDataToFile

    Create an image file from color and alpha pixel data.

    USAGE
      saveImageDataToFile(color_and_alpha_data, width, height, file_name)


    color_and_alpha_data
        Either a sequence of floats or a binary string containing the image
        data. The data must be in interleaved format, meaning that the first
        4 values are the red, green, blue, and alpha (RGBA) values for the
        first pixel, the next 4 are for the second pixel, and so on. The
        first row of pixels in the data corresponds to the top scanline in
        the image.

        The length of this sequence must be width * height * 4.

        If you are writing a .pic file, the file will store 32-bit float
        data if you pass in a sequence of floats and 8-bit unsigned data if
        you pass in a string.

        The binary string data must be a bytes object in Python 3 and a str
        object in Python 2. See HOM binary data for more information.

    width, height
        The width and height of the image to be written.

    file_name
        The name of the output image file to create. Houdini will
        automatically determine which type of file to create based on this
        file's extension.

    This function provides two features not provided by other imaging
    libraries:

      * It lets you create files in Houdini's .pic format.

      * It lets you save images with 32-bit float data.

    Raises hou.OperationFailed if the data is not the correct size, the
    output file could not be created, or the output file format is not
    supported by Houdini.

    The following example uses the Python imaging library (PIL) to read in a
    file and calls this function to write it out. Using the convertImage
    function below, you can convert any image that can be read by PIL into
    Houdini's .pic format.

    > import Image
    >
    > def convertImage(input_image, output_image):
    >     im = Image.open(input_image)
    >     im.mode != \"RGBA\":
    >         raise ValueError(\"The image must contain alpha information\")
    >     hou.saveImageDataToFile(im.tostring(), im.size[0], im.size[1], output_image)
    >
    > convertImage(\"image.png\", \"image.pic\")

    See also Writing a COP in Python.


    """
    return _hou.saveImageDataToFile(*args)


def loadImageDataFromFile(*args, **kwargs) -> "HOM_BinaryString":
    return _hou.loadImageDataFromFile(*args, **kwargs)


def imageResolution(
    image_file_name: "char const *",
) -> "std::vector< int,std::allocator< int > >":
    r"""

    hou.imageResolution

    Return the resolution of an image in a file.

    USAGE
      imageResolution(image_file_name) -> tuple of int

    Returns the width and height of an image stored in a file.

    Another way to get the resolution of an image is to load it into a file
    cop and retrieve it. For example, this method could be approximately
    implemented as follows:

    > def imageResolution(image_file_name):
    >     file_cop = hou.node(\"/img/comp1\").createNode(\"file\")
    >     file_cop.setParm(\"filename1\", image_file_name)
    >     resolution = (file_cop.xRes(), file_cop.yRes())
    >     file_cop.destroy()
    >     return resolution

    Note, however, that this method is faster than loading the image into
    Houdini and retrieving the resolution because it is much less disk
    intensive. It does not load the image data from disk, and instead only
    loads as much as necessary to retrieve the resolution.

    Raises hou.OperationFailed if the image file does not exist or if it's
    not an image file type supported by Houdini.

    The following example retrieves the resolution of the default.pic file
    that ships with Houdini.

    > >>> hou.imageResolution(hou.findFile(\"pic/default.pic\"))
    > (512, 512)

    RELATED

      * hou.CopNode.xRes

      * hou.CopNode.yRes


    """
    return _hou.imageResolution(image_file_name)


def runCallbackAndCatchCrashes(callback: "PyObject *") -> "PyObject *":
    return _hou.runCallbackAndCatchCrashes(callback)


def updateModeSetting() -> "HOM_EnumValue &":
    r"""

    hou.updateModeSetting

    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.

    USAGE
      updateModeSetting() -> hou.updateMode enum value

    Houdini's update mode determines when it will recook its nodes after you
    make parameter changes. When it is Auto Update, it will recook whenever
    any parameter changes. When it is On Mouse Up, it will not recook while
    you are tuning a parameter with a viewport or ladder handle until you
    release the mouse. When it is Manual, it will only recook when you press
    the update button in the status bar.

    Note that this function is named updateModeSetting because
    hou.updateMode refers to the submodule containing enumeration values.
    This function used to be in the hou.ui submodule, but it was moved into
    the main hou module because it also applies to a non-graphical Houdini.

    > >>> # Prevent Houdini from cooking any nodes.
    > >>> hou.setUpdateMode(hou.updateMode.Manual)
    > >>> hou.updateModeSetting()
    > hou.updateMode.Manual

    RELATED

      * hou.setUpdateMode

      * hou.ui.triggerUpdate.


    """
    return _hou.updateModeSetting()


def setUpdateMode(mode: "EnumValue") -> "void":
    r"""

    hou.setUpdateMode

    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.

    USAGE
      updateModeSetting() -> hou.updateMode enum value

    Set Houdini's cook update mode to a hou.updateMode enumerated value. See
    hou.updateModeSetting for more information.


    """
    return _hou.setUpdateMode(mode)


def orboltURLHandler() -> "HOM_OrboltURLHandler *":
    return _hou.orboltURLHandler()


def _pushAccessPrivilege(key: "char const *") -> "void":
    return _hou._pushAccessPrivilege(key)


def _popAccessPrivilege(key: "char const *") -> "void":
    return _hou._popAccessPrivilege(key)


def _currentPythonModuleKey() -> "std::string":
    return _hou._currentPythonModuleKey()


def _registerAccessPrivilegeClient(py_object: "PyObject *") -> "void":
    return _hou._registerAccessPrivilegeClient(py_object)


def chsop(path: "char const *") -> "std::string":
    r"""

    hou.chsop

    Evaluate a parameter that references a node, and return the absolute
    path to the node.

    USAGE
      chsop(parameter_path) -> string

    RELATED

      * hou.evalParm

      * hou.chsoplist


    """
    return _hou.chsop(path)


def chsoplist(path: "char const *") -> "std::string":
    r"""

    hou.chsoplist

    Evaluate a parameter that references a node path list, and return a
    space separated list of absolute node paths.

    USAGE
      chsoplist(parameter_path) -> string

    RELATED

      * hou.evalParm

      * hou.chsop


    """
    return _hou.chsoplist(path)


def sortedNodePaths(
    paths: "_StringTuple",
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.sortedNodePaths

    Given a tuple of path strings, return a tuple of path strings sorted in
    input/outputs order. Invalid node paths won't be part of the sorted
    list.

    USAGE
      sortedNodePaths(path_tuple) -> tuple of string

    Sorts nodes following the network traversal order. Root nodes appear
    first and leaf nodes come last.

    > >>> hou.node('/obj').createNode('simplefemale')
    > <hou.ObjNode of type simplefemale at /obj/simplefemale1>
    > >>> paths = [\"/obj/simplefemale1/ctrl_master\",\"/obj/simplefemale1/ctrl_IK_wrist_right\",\"/obj/simplefemale1/ctrl_cog\",\"/obj/simplefemale1/ctrl_neck\",\"/obj/simplefemale1/ctrl_head\",\"/obj/simplefemale1/ctrl_FK_hand_right\"]
    > >>> hou.sortedNodePaths(paths)
    > ('/obj/simplefemale1/ctrl_master', '/obj/simplefemale1/ctrl_cog', '/obj/simplefemale1/ctrl_IK_wrist_right', '/obj/simplefemale1/ctrl_neck', '/obj/simplefemale1/ctrl
    > _head', '/obj/simplefemale1/ctrl_FK_hand_right')

    RELATED

      * hou.node

      * hou.nodes

      * hou.Node

      * hou.sortedNodes


    """
    return _hou.sortedNodePaths(paths)


def sortedNodes(
    nodes: "_NodeTuple",
) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
    r"""

    hou.sortedNodes

    Given a tuple of hou.Node, return a tuple of hou.Node sorted in
    input/outputs order.

    USAGE
      sortedNodePaths(node_tuple) -> tuple of hou.Node

    Sorts nodes following the network traversal order. Root nodes appear
    first and leaf nodes come last.

    > >>> hou.node('/obj').createNode('simplefemale')
    > <hou.ObjNode of type simplefemale at /obj/simplefemale1>
    > >>> nodes = hou.nodes( [\"/obj/simplefemale1/ctrl_master\",\"/obj/simplefemale1/ctrl_IK_wrist_right\",\"/obj/simplefemale1/ctrl_cog\",\"/obj/simplefemale1/ctrl_neck\",\"/obj/simplefemale1/ctrl_head\",\"/obj/simplefemale1/ctrl_FK_hand_right\"] )
    > >>> hou.sortedNodes(nodes)
    > ('/obj/simplefemale1/ctrl_master', '/obj/simplefemale1/ctrl_cog', '/obj/simplefemale1/ctrl_IK_wrist_right', '/obj/simplefemale1/ctrl_neck', '/obj/simplefemale1/ctrl
    > _head', '/obj/simplefemale1/ctrl_FK_hand_right')

    RELATED

      * hou.node

      * hou.nodes

      * hou.Node

      * hou.sortedNodePaths


    """
    return _hou.sortedNodes(nodes)


def patternMatch(
    pattern: "char const *",
    str: "char const *",
    ignore_case: "bool" = False,
    path_match: "bool" = False,
) -> "int":
    r"""

    hou.patternMatch

    Deprecated, please use hou.text.patternMatch.


    """
    return _hou.patternMatch(pattern, str, ignore_case, path_match)


def chopExportConflictResolutionPattern() -> "std::string":
    r"""

    hou.chopExportConflictResolutionPattern

    Returns a CHOP node path pattern to take precedence when exporting to
    the same channel.

    USAGE
      chopExportConflictResolutionPattern() -> str

    Returns a pattern for matching CHOP node paths that should take
    precedence when there are other CHOPs that override the same channels
    thus leading to conflicts.


    """
    return _hou.chopExportConflictResolutionPattern()


def setChopExportConflictResolutionPattern(pattern: "char const *") -> "void":
    r"""

    hou.setChopExportConflictResolutionPattern

    Sets a CHOP node path pattern to take precedence when exporting to the
    same channel.

    USAGE
      setChopExportConflictResolutionPattern(string pattern) -> None

    Sets a pattern for matching CHOP node paths that should take precedence
    when there are other CHOPs that override the same channels thus leading
    to conflicts.


    """
    return _hou.setChopExportConflictResolutionPattern(pattern)


def nodeType(*args) -> "HOM_NodeType *":
    r"""

    hou.nodeType

    Takes a category object and a name, or just a full name string, and
    returns the corresponding NodeType object.

    USAGES

        This function acts differently depending if you pass it one or two
        arguments.

        USAGES
          nodeType(category, internal_name) -> hou.NodeType or None
          Where category is a hou.NodeTypeCategory (not a string), and
          internal_name is a string containing the internal name of a node
          type, which may include a scope, namespace, and/or version.

          For example:

        > nodetype = hou.nodeType(hou.SopNodeTypeCategory(), \"acme::rocketboots::2.0\")
          nodeType(internal_name_with_category)
          Where internal_name_with_category is a string containing the
          internal name of a node type including the category, which may
          also include a scope, namespace, and/or version.

          For example:

        > nodetype = hou.nodeType(\"acme::Sop/rocketboots::2.0\")

    TIPS AND NOTES

      * Do not confuse hou.nodeType() (starts with a lower-case N, a
        function that returns a NodeType object) with NodeType (starts with
        an upper-case N, the class representing node types).

      * If you have a Node reference to a node in the network, you can get
        its type object by calling hou.Node.type.

      * Each node category has a corresponding function to returns its
        corresponding hou.NodeTypeCategory object. For example,
        hou.sopNodeTypeCategory, hou.objNodeTypeCategory,
        hou.lopNodeTypeCategory, and so on.

      * hou.nodeTypeCategories returns a dict mapping category names to
        NodeTypeCategory objects.

      * If you have a category object, hou.nodeTypeCategory.nodeType takes
        the internal name of a node type and returns the corresponding
        hou.NodeType object. hou.NodeTypeCategory.nodeTypes returns a dict
        mapping internal names to hou.NodeType objects.

      * To see the internal name of a node in the network editor, right
        click the node and choose Type Properties. The internal name
        (without the type category) is at the top of the window labelled
        Operator Type.

    EXAMPLES

      > # The following four ways of looking up the copy SOP's node type are equivalent:
      > >>> hou.nodeType(\"Sop/copy\")
      > <hou.SopNodeType for Sop copy>
      >
      > >>> hou.nodeType(hou.sopNodeTypeCategory(), \"copy\")
      > <hou.SopNodeType for Sop copy>
      >
      > >>> hou.nodeType(\"acme::Sop/rocketboots::2.0\")
      > <hou.SopNodeType for Sop acme::rocketboots::2.0>
      >
      > >>> hou.nodeType(hou.sopNodeTypeCategory(), \"acme::rocketboots::2.0\")
      > <hou.SopNodeType for Sop acme::rocketboots::2.0>

    RELATED

      * hou.NodeType

      * hou.NodeTypeCategory

      * hou.NodeTypeCategory.nodeType

      * hou.NodeTypeCategory.nodeTypes

      * hou.nodeTypeCategories

      * hou.preferredNodeType


    """
    return _hou.nodeType(*args)


def preferredNodeType(
    name: "char const *", parent_node: "Node" = None
) -> "HOM_NodeType *":
    r"""

    hou.preferredNodeType

    Given a node type name that includes the category and optionally a
    parent node, return the corresponding NodeType object after evaluating
    aliases. Return None if there is no such type with that name.

    USAGE
      preferredNodeType(name, parent_node=None) -> NodeType or None


    name
        The internal name of a node type including the category. To get the
        internal name of any node type in Houdini, right-click a node of
        that type and choose Type properties. The internal name is listed at
        the top of the type properties window beside Operator type. For
        example, the internal name of the Geometry object is geo.

    parent_node
        Optional. The node that will be the parent for this node type.

    EXAMPLES

      > >>> hou.preferredNodeType(\"Shop/pyro\")
      > <hou.ShopNodeType for Shop pyro::3.0>
      >
      > >>> hou.preferredNodeType(\"Shop/pyro\", hou.node(\"/shop\"))
      > <hou.ShopNodeType for Shop pyro::3.0>

    RELATED

      * hou.NodeType

      * hou.nodeType

      * hou.nodeTypeCategories


    """
    return _hou.preferredNodeType(name, parent_node)


def objNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.objNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini object nodes. For
    example, if /obj/model is an object then
    hou.node(/obj/model).type().category() is hou.objectNodeTypeCategory().

    USAGE
      objNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.objNodeTypeCategory()


def sopNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.sopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini geometry (sop) nodes.

    USAGE
      sopNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.sopNodeTypeCategory()


def dopNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.dopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini dynamic (DOP) nodes.

    USAGE
      dopNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.dopNodeTypeCategory()


def cop2NodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.cop2NodeTypeCategory

    Return the NodeTypeCategory instance for Houdini composite (cop) nodes.

    USAGE
      cop2NodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.cop2NodeTypeCategory()


def shopNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.shopNodeTypeCategory

    Return the NodeTypeCategory object corresponding to shader (SHOP) nodes.

    USAGE
      shopNodeTypeCategory() -> hou.NodeTypeCategory

    Be careful not to confuse this function with the class
    hou.ShopNodeTypeCategory.


    """
    return _hou.shopNodeTypeCategory()


def vopNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.vopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini vex builder (VOP)
    nodes.

    USAGE
      vopNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.vopNodeTypeCategory()


def ropNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.ropNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini output (rop) nodes.

    USAGE
      ropNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.ropNodeTypeCategory()


def chopNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.chopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini channel (chop) nodes.

    USAGE
      chopNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.chopNodeTypeCategory()


def cop2NetNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.cop2NetNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini composite container
    (copnet) nodes.

    USAGE
      cop2NetNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.cop2NetNodeTypeCategory()


def vopNetNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.vopNetNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini vex builder container
    (vopnet) nodes.

    USAGE
      vopNetNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.vopNetNodeTypeCategory()


def chopNetNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.chopNetNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini channel container
    (chopnet) nodes.

    USAGE
      chopNetNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.chopNetNodeTypeCategory()


def topNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.topNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini task (top) nodes.

    USAGE
      topNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.topNodeTypeCategory()


def lopNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.lopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini lighting (lop) nodes.

    USAGE
      lopNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.lopNodeTypeCategory()


def managerNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.managerNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini manager nodes. The
    manager nodes are /obj, /out, /part, /ch, /shop, /img, and /vex.

    USAGE
      managerNodeTypeCategory() -> NodeTypeCategory

    Note that some container node types, like the shop network node type,
    are called managers in Houdini. The node type category for an instance
    of those nodes will be the same as other nodes in that same network. For
    example, a shop network in objects will be in the objects node type
    category, while a shop network in a sop network will be in the geometry
    node type category.


    """
    return _hou.managerNodeTypeCategory()


def rootNodeTypeCategory() -> "HOM_NodeTypeCategory &":
    r"""

    hou.rootNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini root (/) node. There is
    only one instance of the root node, and it has its own node type
    category.

    USAGE
      rootNodeTypeCategory() -> NodeTypeCategory


    """
    return _hou.rootNodeTypeCategory()


def nodeTypeCategories() -> (
    "std::map< std::string,HOM_NodeTypeCategory *,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_NodeTypeCategory * > > >"
):
    r"""

    hou.nodeTypeCategories

    Return a dictionary where the keys are the category names (e.g. Object,
    Sop) and the values are hou.NodeTypeCategory objects.

    USAGE
      nodeTypeCategories() -> dict of str to hou.NodeTypeCategory


    """
    return _hou.nodeTypeCategories()


def copyNodesTo(
    nodes: "_NodeTuple", destination_node: "Node"
) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
    r"""

    hou.copyNodesTo

    Copy all given nodes to a new place in node hierarchy.

    USAGE
      copyNodesTo(nodes, destination_node) -> tuple of Nodes

    The nodes to be copied should be a sequence of hou.Node objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.

    This function returns a tuple of hou.Node objects corresponding to the
    copied nodes.

    Nodes will be copied to the destination in batches based on their
    parent. All the nodes in a batch will be copied at the same time. This
    way, any relative channel references between nodes with the same parent
    will be updated to reflect the copied node location. Batches themselves
    will be copied sequentially. Thus, channel references between nodes with
    different parents will not be updated in copies.

    For every copied node, if a node with the same name already exists at
    the destination, the copy will be renamed. Any relative channel
    references to the copy will be updated with the new copy name.

    This function will raise a hou.OperationFailed exception if any of the
    nodes to be copied are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node
    child type.

    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.

    All of the above issues with source and destination nodes will be
    reported before copying starts to avoid partial copy.

    After the function finishes execution, all the new nodes created by it
    will be selected.


    """
    return _hou.copyNodesTo(nodes, destination_node)


def moveNodesTo(
    nodes: "_NodeTuple", destination_node: "Node"
) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
    r"""

    hou.moveNodesTo

    Move all given nodes to a new place in node hierarchy.

    USAGE
      moveNodesTo(nodes, destination_node) -> tuple of Nodes

    The nodes to be moved should be a sequence of hou.Node objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.

    This function returns a tuple of hou.Node objects corresponding to the
    nodes at their new locations. If you attempt to access the original
    hou.Node objects in the sequence you passed into this function, you will
    receive hou.ObjectWasDeleted exceptions.

    For every moved node, if a node with the same name already exists at the
    destination, the node will be renamed to a unique name.

    This function will raise a hou.OperationFailed exception if any of the
    nodes to be moved are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node's
    child type.

    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.

    All of the above issues with source and destination nodes will be
    reported before moving starts to avoid a partial move.

    After the function finishes execution, all the moved nodes by it will be
    selected.


    """
    return _hou.moveNodesTo(nodes, destination_node)


def addNodeBundle(name: "char const *" = None) -> "HOM_NodeBundle *":
    r"""

    hou.addNodeBundle

    Create a new node bundle with the specified name.

    USAGE
      addNodeBundle(name = None) -> hou.NodeBundle

    See hou.NodeBundle for more information about node bundles.

    If name is None, a unique bundle name is generated automatically.

    Raises hou.OperationFailed if the name is not alphanumeric or a bundle
    with that name already exists.


    """
    return _hou.addNodeBundle(name)


def nodeBundles() -> (
    "std::vector< HOM_ElemPtr< HOM_NodeBundle >,std::allocator< HOM_ElemPtr< HOM_NodeBundle > > >"
):
    r"""

    hou.nodeBundles

    Return a tuple containing all the node bundles in the current session.

    USAGE
      nodeBundles() -> tuple of hou.NodeBundle

    See hou.NodeBundle for more information.


    """
    return _hou.nodeBundles()


def selectedNodeBundles() -> (
    "std::vector< HOM_ElemPtr< HOM_NodeBundle >,std::allocator< HOM_ElemPtr< HOM_NodeBundle > > >"
):
    r"""

    hou.selectedNodeBundles

    Return a tuple containing all the node bundles that are selected in the
    bundle list pane.

    USAGE
      selectedNodeBundles() -> tuple of hou.NodeBundle

    This function is a shortcut for [bundle for bundle in hou.nodeBundles()
    if bundle.isSelected].

    See hou.NodeBundle for more information about bundles.


    """
    return _hou.selectedNodeBundles()


def nodeBundle(name: "char const *") -> "HOM_NodeBundle *":
    r"""

    hou.nodeBundle

    Given a node bundle name, return the corresponding NodeBundle object, or
    None if there is not one with that name.

    USAGE
      nodeBundle(name) -> hou.NodeBundle or None

    See hou.NodeBundle for more information.


    """
    return _hou.nodeBundle(name)


def hdaDefinition(
    category: "NodeTypeCategory", name: "char const *", file_path: "char const *"
) -> "HOM_HDADefinition *":
    r"""

    hou.hdaDefinition

    Given a node type category, operator name and digital asset library
    path, return an HDADefinition object. Return None if no such installed
    digital asset definition matches the arguments.

    USAGE
      hdaDefinition(node_type_category, name, lib_path) -> hou.HDADefinition
      or None

    Be careful not to confuse this function with the class
    hou.HDADefinition.

    Example:

    > # Return the HDA definition for a SOP digital asset named 'foo'
    > # that is located in the '/tmp/bar.hda' library.
    > hou.hdaDefinition(hou.sopNodeTypeCategory(), 'foo', '/tmp/bar.hda')

    RELATED

      * hou.hda


    """
    return _hou.hdaDefinition(category, name, file_path)


def time() -> "double":
    r"""

    hou.time

    Return the playbar's current time, in seconds of playback.

    USAGE
      time() -> float

    Note that the time at frame 1 is 0s.

    RELATED

      * hou.setTime

      * hou.frame

      * hou.fps


    """
    return _hou.time()


def setTime(time: "double") -> "void":
    r"""

    hou.setTime

    Set the playbar's time.

    USAGE
      setTime(time)

    RELATED

      * hou.time

      * hou.setFrame


    """
    return _hou.setTime(time)


def frame() -> "double":
    r"""

    hou.frame

    Return the playbar's current frame. Note that Houdini can be on a
    fractional frame if fractional frames are enabled.

    USAGE
      frame() -> float

    Note that this function is equivalent to Hscript's $FF variable. If you
    want hscript's $F variable, use hou.intFrame, which rounds the frame to
    the nearest integer.

    To enable fractional frames, turn off the Integer Frame Values in the
    Global Animation Options dialog.

    This function rounds its output to 3 decimal places, just like Hscript's
    $FF variable does. Note, though, that because a Python float may not be
    able to precisely represent a floating point value, and because Python
    does not round numbers when it displays them, the frame number might end
    with 9999999999999 or 0000000000001 when you print it to the Python
    shell. When you convert the number to a string, though, Python will
    round the value, so it will contain at most 3 decimal places.

    > >>> 2.759
    > 2.7589999999999999
    > >>> 2.757
    > 2.7570000000000001
    > >>> str(2.759)
    > '2.759'

    If Houdini is on a fractional frame and you do not want the rounded
    value, use hou.timeToFrame(hou.time()).

    > >>> hou.setFrame(13.193)
    > >>> hou.frame()
    > 13.193
    > >>> hou.timeToFrame(hou.time())
    > 13.192999839782715
    > >>> hou.setFrame(2.759)
    > >>> hou.frame()
    > 2.7589999999999999
    > >>> int(hou.frame())
    > 2
    > >>> hou.intFrame()
    > 3

    RELATED

      * hou.intFrame

      * hou.setFrame

      * hou.time

      * hou.fps


    """
    return _hou.frame()


def intFrame() -> "int":
    r"""

    hou.intFrame

    Return the playbar's current frame, rounded to the nearest integer.

    USAGE
      intFrame() -> int

    Note that this function is equivalent to Hscript's $F variable. If you
    want Hscript's $FF variable, use hou.frame.


    NOTE
        Due to floating point rounding, values near the half way point
        between two integers may round differently (for example 10.5 or
        32.5).

    RELATED

      * hou.frame

      * hou.setFrame

      * hou.time

      * hou.fps


    """
    return _hou.intFrame()


def setFrame(frame: "double") -> "void":
    r"""

    hou.setFrame

    Set the playbar's current frame. Note that the frame may be a fractional
    value.

    USAGE
      setFrame(frame)

    RELATED

      * hou.time

      * hou.setFrame


    """
    return _hou.setFrame(frame)


def fps() -> "double":
    r"""

    hou.fps

    Return the number of frames per second.

    USAGE
      fps() -> float

    This value is used when converting between frames and time.

    RELATED

      * hou.setFps

      * hou.frame

      * hou.time


    """
    return _hou.fps()


def setFps(
    fps: "double",
    modify_frame_count: "bool" = True,
    preserve_keyframes: "bool" = False,
    preserve_frame_start: "bool" = False,
) -> "void":
    r"""

    hou.setFps

    Set the number of frames per second.

    USAGE
      setFps(fps, modify_frame_count = True, preserve_keyframes = False,
      preserve_frame_start = False)


    fps
        Number of frames per second

    modify_frame_count
        Whether or not to adjust the number of frames to preserve the total
        time duration of the playback range.

    preserve_keyframes
        If true, keeps all keys on their current frames. Note that this will
        modify the speed of the animation.

    preserve_frame_start
        If true, adjusts the starting time of the playback in order to
        preserve the starting frame. The ending frame will also be preserved
        if modify_frame_count is False.

    RELATED

      * hou.fps


    """
    return _hou.setFps(
        fps, modify_frame_count, preserve_keyframes, preserve_frame_start
    )


def timeToFrame(time: "double") -> "double":
    r"""

    hou.timeToFrame

    Convert from a given time value to a frame value, rounding the result to
    a integer if it is close to an integer.

    USAGE
      timeToFrame(time) -> float

    Calling this function is roughly equivalent to evaluating time *
    hou.fps() + 1.0, but the result is rounded to 6 digits of precision.

    RELATED

      * hou.fps

      * hou.frame

      * hou.time


    """
    return _hou.timeToFrame(time)


def frameToTime(frame: "double") -> "double":
    r"""

    hou.frameToTime

    Convert from a given frame value to a time value.

    USAGE
      frameToTime(frame) -> float

    Calling this function is the same as evaluating (frame - 1.0) /
    hou.fps(). Unlike hou.timeToFrame(), no rounding is performed.

    RELATED

      * hou.fps

      * hou.time

      * hou.frame


    """
    return _hou.frameToTime(frame)


def _syncFromMainContext() -> "void":
    return _hou._syncFromMainContext()


def _syncToMainContext() -> "void":
    return _hou._syncToMainContext()


def scaleToMKS(units: "char const *") -> "double":
    r"""

    hou.scaleToMKS

    Returns the scale factor from Meters-Kilograms-Seconds units into the
    Houdini session's current units.

    The provided dimensions specify the units and exponents of the units to
    convert from. These use the tokens kg, m, and s to provide the units of
    mass, distance, and time. Each unit should be suffixed by a floating
    point exponent.

    For example, area is m2 and acceleration is m1s-2, while volume density
    would be kg1m-3.

    USAGE
      scaleToMKS(dimensions) -> float


    """
    return _hou.scaleToMKS(units)


def scaleFromMKS(units: "char const *") -> "double":
    r"""

    hou.scaleFromMKS

    Returns the scale factor from Meters-Kilograms-Seconds units into the
    Houdini session's current units.

    The provided dimensions specify the units and exponents of the units to
    convert from. These use the tokens kg, m, and s to provide the units of
    mass, distance, and time. Each unit should be suffixed by a floating
    point exponent.

    For example, area is m2 and acceleration is m1s-2, while volume density
    would be kg1m-3.

    USAGE
      scaleFromMKS(dimensions) -> float


    """
    return _hou.scaleFromMKS(units)


def bezier() -> "double":
    r"""

    hou.bezier

    Evaluate a Bezier interpolation spline for an animated parameter using
    the left keyframe's outgoing value, tangent, and acceleration and the
    right keyframe's incoming value, tangent, and acceleration.

    USAGE
      bezier() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.bezier()


def constant() -> "double":
    r"""

    hou.constant

    Evaluate an animation function for an animated parameter. The return
    value is always the left keyframe's outgoing value.

    USAGE
      constant() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.constant()


def cubic() -> "double":
    r"""

    hou.cubic

    Smooth curve between the left keyframe's outgoing slope and the right's
    incoming slope.

    USAGE
      cubic() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.cubic()


def cycle(start_frame: "double", end_frame: "double") -> "double":
    r"""

    hou.cycle

    Repeats the motion between two times.

    USAGE
      cycle(start_frame, end_frame) -> float

    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffset() instead.

    This function is the same as hou.cyclet() except hou.cyclet() accepts
    times instead of frames.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cyclet

      * hou.cycleoffset

      * hou.cycleoffsett

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.cycle(start_frame, end_frame)


def cyclet(start_time: "double", end_time: "double") -> "double":
    r"""

    hou.cyclet

    Repeats the motion between two times.

    USAGE
      cyclet(start_time, end_time) -> float

    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffsett() instead.

    This function is the same as hou.cycle() except hou.cycle() it accepts
    frames instead of times.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cycleoffset

      * hou.cycleoffsett

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.cyclet(start_time, end_time)


def cycleoffset(start_time: "double", end_time: "double") -> "double":
    r"""

    hou.cycleoffset

    Repeats the motion between two frames, lining up the first repeated
    value with the left keyframe's value.

    USAGE
      cycleoffset(start_frame, end_frame) -> float

    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.

    This function is the same as hou.cycleoffsett() except
    hou.cycleoffsett() accepts times instead of frames. If you want to
    repeat motion exactly, use the hou.cycle() function instead.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.cycleoffsett

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.cycleoffset(start_time, end_time)


def cycleoffsett(start_time: "double", end_time: "double") -> "double":
    r"""

    hou.cycleoffsett

    Repeats the motion between two times, lining up the repeated values with
    the left keyframe's value.

    USAGE
      cycleoffsett(start_time, end_time) -> float

    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.

    This function is the same as hou.cycleoffset() except hou.cycleoffset()
    accepts frames instead of times. If you want to repeat motion exactly,
    use the hou.cyclet() function instead.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.cycleoffset

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.cycleoffsett(start_time, end_time)


def ease() -> "double":
    r"""

    hou.ease

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    USAGE
      ease() -> float

    The tangents will be flat at both ends of the function, so the curve
    will slowly ease from the left value and, near the end of the function,
    slowly reduce the speed until it is at rest at the right value.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.ease()


def easein() -> "double":
    r"""

    hou.easein

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    USAGE
      easein() -> float

    The tangent will be flat at the left end of the function, so it will
    slowly ease from the outgoing value of the left keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.easein()


def easeinp(ease_speed: "double") -> "double":
    r"""

    hou.easeinp

    Interpolates between the values of two keyframes.

    USAGE
      easeinp(ease_speed) -> float

    This function is like hou.easein, except it has an additional parameter
    to say how fast the curve should ease into the motion.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.easeinp(ease_speed)


def easeout() -> "double":
    r"""

    hou.easeout

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    USAGE
      easeout() -> float

    The tangent will be flat at the right end of the function, so it will
    slowly come to rest at the incoming value of the right keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.easeout()


def easeoutp(ease_speed: "double") -> "double":
    r"""

    hou.easeoutp

    Interpolates between the values of two keyframes.

    USAGE
      easeoutp(ease_speed) -> float

    This function is like hou.easeout, except it has an additional parameter
    to say how fast the curve should ease into the motion.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.easeoutp(ease_speed)


def easep(ease_bias: "double") -> "double":
    r"""

    hou.easep

    Interpolates between the values of two keyframes.

    USAGE
      easep(ease_bias) -> float

    An ease bias of less than one slow the animation near right keyframe,
    while an ease bias greater than one will slow it near the left keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.easep(ease_bias)


def linear() -> "double":
    r"""

    hou.linear

    Linearly interpolates between the left keyframe's outgoing value and the
    right keyframe's incoming value.

    USAGE
      linear() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.linear()


def match() -> "double":
    r"""

    hou.match

    Creates a smooth curve between the left keyframe's incoming slope and
    the right keyframe's outgoing slope.

    USAGE
      match() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.match()


def matchin() -> "double":
    r"""

    hou.matchin

    Creates a straight line from the left keyframe's incoming value,
    matching the left keyframe's incoming slope.

    USAGE
      matchin() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.matchin()


def matchout() -> "double":
    r"""

    hou.matchout

    Creates a straight line from the right keyframe's outgoing value,
    matching the right keyframe's outgoing slope.

    USAGE
      matchout() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.matchout()


def qlinear() -> "double":
    r"""

    hou.qlinear

    Linearly interpolates between keyframes using quaternions.

    USAGE
      qlinear() -> float

    The neighboring parameters must also be animated; for example, if rx
    uses qlinear(), ry and rz should also use qlinear().

    Because the interpolation is done in quaternion spaces, the orientations
    will blend smoothly with no gimbal lock or unexpected spins. The Euler
    rotation values may appear to jump suddenly, but that's simply because
    different rotation values can represent the same orientation.

    Note that the graph editor will display a qlinear() segment as a dashed
    straight line. This line does not represent the actual intermediate
    channel values, but it does give an accurate visual feel for the
    behavior of the interpolation.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.qlinear()


def quintic() -> "double":
    r"""

    hou.quintic

    Evaluate an interpolation function for an animated parameter that gives
    a smooth curve between the left keyframe's outgoing value and the right
    keyframe's incoming value, using the left's outgoing slope and
    acceleration and the right's incoming slope and acceleration.

    USAGE
      quintic() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.quintic()


def repeat(start_frame: "double", end_frame: "double") -> "double":
    r"""

    hou.repeat

    Repeats the motion between two times.

    USAGE
      repeat(start_frame, end_frame) -> float

    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cycle() instead.

    This function is the same as hou.repeatt() except hou.repeatt() accepts
    times instead of frames.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.repeat(start_frame, end_frame)


def repeatt(start_time: "double", end_time: "double") -> "double":
    r"""

    hou.repeatt

    Repeats the motion between two times.

    USAGE
      repeatt(start_time, end_time) -> float

    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cyclet()
    instead.

    This function is the same as hou.repeat() except hou.repeat() it accepts
    frames instead of times.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cycleoffset

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.repeatt(start_time, end_time)


def spline() -> "double":
    r"""

    hou.spline

    Fits a spline through consecutive keyframe values.

    USAGE
      spline() -> float

    The resulting spline interpolates the channel values at the keyframes,
    and slope values are not used.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.spline()


def vmatch() -> "double":
    r"""

    hou.vmatch

    Matches the incoming and outgoing values and slopes.

    USAGE
      vmatch() -> float

    Unlike hou.match, this function will use its left keyframe's outgoing
    value and the right keyframe's incoming value, so hou.vmatch() can
    produce curves that are discontinuous with the previous segment.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatchin

      * hou.vmatchout


    """
    return _hou.vmatch()


def vmatchin() -> "double":
    r"""

    hou.vmatchin

    Matches the left keyframe's incoming slope.

    USAGE
      vmatchin() -> float

    The curve will be a straight line from the left keyframe's outgoing
    value, and will not match the right keyframe's outgoing value. Unlike
    the hou.matchin() function, the left keyframe's outgoing value can
    differ from its incoming value, so so hou.vmatchin() can produce curves
    whose left tangent matches the left keyframe but whose left values do
    not line up.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchout


    """
    return _hou.vmatchin()


def vmatchout() -> "double":
    r"""

    hou.vmatchout

    Matches the right keyframe's outgoing slope.

    USAGE
      vmatchout() -> float

    The curve will be a straight line ending at the right keyframe's
    incoming value, and will not match the left keyframe's incoming value.
    Unlike the hou.matchout() function, the right keyframe's incoming value
    can differ from its outgoing value, so so hou.vmatchout() can produce
    curves whose right tangent matches the right keyframe but whose right
    values do not line up.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin


    """
    return _hou.vmatchout()


def helpServerUrl() -> "std::string":
    r"""

    hou.helpServerUrl

    Return the base URL for all Houdini help pages.

    USAGE
      helpServerUrl() -> string


    """
    return _hou.helpServerUrl()


def hscriptCommandHelp(command_name: "char const *") -> "std::string":
    r"""

    hou.hscriptCommandHelp

    Return the text help of an hscript command. This function is used to
    help re-implement hscript commands in Python.

    USAGE
      hscriptCommandHelp(command_name) -> string


    """
    return _hou.hscriptCommandHelp(command_name)


def hscript(
    command: "char const *",
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.hscript

    Executes an HScript command

    USAGE
      hscript(command) -> tuple of strings

    Returns a tuple of two strings: the regular output of the executed
    command, and the error output.

    You can specify multiple commands using ; or
     as the separator.


    """
    return _hou.hscript(command)


def almostEqual(x: "double", y: "double") -> "bool":
    r"""

    hou.almostEqual

    Compares two numbers and returns True if they are almost equal in terms
    of how far apart they are when represented as floating point numbers.

    USAGE
      almostEqual(x, y) -> bool


    """
    return _hou.almostEqual(x, y)


def fileReferences(
    *args, **kwargs
) -> "std::vector< std::pair< HOM_ElemPtr< HOM_Parm >,std::string >,std::allocator< std::pair< HOM_ElemPtr< HOM_Parm >,std::string > > >":
    r"""

    hou.fileReferences

    USAGE
      fileReferences(project_dir_variable='HIP', include_all_refs=true) ->
      tuple of hou.Parm and str tuples

    Returns a sequence of tuples representing all references to external
    files (such as textures, geometry files, and asset libraries) in the
    current scene.

    The first item in each tuple is a hou.Parm object representing the
    parameter containing the file reference, and the second item is the path
    string. (The second item is a convenience; you can get the same string
    by calling Parm.unexpandedString().)

    This can be useful when preflighting, to check that there are no
    references to files outside $HIP.

    > import os
    >
    > hipdir = os.environ[\"HIP\"]
    >
    > for parm, path in hou.fileReferences():
    >     # Assume you have a function to check if one path is the descendent
    >     # of another path
    >     if not is_inside(hipdir, path):
    >         print(\"Problem: path %s is not inside the project dir %s\" % (path, hipdir)

    (The sequence does not include default images and geometry files from
    inside Houdini's install location, for example default.bgeo in a File
    SOP.)


    project_dir_variable
        You can specify the name of an environment variable. If an asset
        path starts with the variable, it will be replaced with a variable
        reference in the path string returned by this function.

        For example, if $JOB is /mnt/projects/ and an asset is in
        /mnt/projects/tool.hda, if you call hou.fileReferences(\"JOB\"), it
        will return the path as $JOB/tool.hda.

    include_all_refs
        If this is True, then the function will return all the file
        references. If this is False, then the function will return only the
        selected file references.


    """
    return _hou.fileReferences(*args, **kwargs)


def findFile(file_name: "char const *") -> "std::string":
    r"""

    hou.findFile

    Search the Houdini path for a specified file, returning the first match
    found. The filename specified should be relative to the Houdini
    directory.

    USAGE
      findFile(file_name) -> string

    If the file cannot be found in the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use hou.findDirectory
    instead.


    """
    return _hou.findFile(file_name)


def findFiles(
    file_name: "char const *",
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.findFiles

    Search the Houdini path for the specified file, returning a tuple of all
    the matches. The filename specified should be relative to the Houdini
    directory.

    USAGE
      findFiles(file_name) -> tuple of strings

    If the file cannot be found on the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use
    hou.findDirectories instead.

    RELATED

      * hou.findFile

      * hou.findDirectory

      * hou.findDirectories

      * hou.houdiniPath


    """
    return _hou.findFiles(file_name)


def findFilesWithExtension(
    file_extension: "char const *", subdirectory: "char const *" = None
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.findFilesWithExtension

    Search the Houdini path for files with a particular extension, returning
    a tuple of all the matches. A subdirectory can also be optionally
    provided which is appended to each entry in the Houdini path before
    looking for files.

    USAGE
      findFilesWithExtension(file_extension, subdirectory = None) -> tuple
      of strings

    Directories are not returned by this method.

    RELATED

      * hou.findFile

      * hou.findDirectory

      * hou.findDirectories

      * hou.houdiniPath


    """
    return _hou.findFilesWithExtension(file_extension, subdirectory)


def findDirectory(directory_name: "char const *") -> "std::string":
    r"""

    hou.findDirectory

    Search the Houdini path for a specified directory, returning the first
    match found. The directory name specified should be relative to the
    Houdini directory.

    USAGE
      findDirectory(directory_name) -> string

    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.

    RELATED

      * hou.findDirectories

      * hou.findFile

      * hou.findFiles

      * hou.houdiniPath


    """
    return _hou.findDirectory(directory_name)


def findDirectories(
    directory_name: "char const *",
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.findDirectories

    Search the Houdini path for the specified directory, returning a tuple
    of all the matches. The directory name specified should be relative to
    the Houdini directory.

    USAGE
      findDirectories(directory_name) -> tuple of strings

    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.

    RELATED

      * hou.findDirectory

      * hou.findFile

      * hou.findFiles

      * hou.houdiniPath


    """
    return _hou.findDirectories(directory_name)


def houdiniPath(
    pathvar: "char const *" = None,
) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.houdiniPath

    Return the contents of the Houdini path as a tuple of strings.

    USAGE
      houdiniPath(path_variable = None) -> tuple of strings

    This method returns an ordered list of path components of the Houdini
    Path. The Houdini Path is used when searching for various files like
    otls, shelf tools, preferences, desktops, icons, etc. By adjusting the
    HOUDINI_PATH environment variable, you can add entries to the path that
    are specific to the current user, job, or studio.

    By default the components of the HOUDINI_PATH variable are returned. If
    the path_variable passed in refers to another well-known Houdini path,
    the components of that search path are returned instead. For example
    houdiniPath(\"HOUDINI_OTLSCAN_PATH\")

    See the output of hconfig -ap for more information on the current paths
    and their values.

    RELATED

      * hou.findFile

      * hou.findFiles

      * hou.findDirectory

      * hou.findDirectories


    """
    return _hou.houdiniPath(pathvar)


def homeHoudiniDirectory() -> "std::string":
    r"""

    hou.homeHoudiniDirectory

    Return the path to the Houdini directory in your $HOME directory.

    USAGE
      homeHoudiniDirectory() -> str

    Return the directory in your $HOME directory where Houdini stores user-
    specific settings. On many platforms, this directory is
    $HOME/houdiniX.Y, where X is the Houdini major version and Y is the
    minor version. Note that on the Mac, though, this directory might be in
    a different location.

    See hou.houdiniPath for more information about how Houdini searches for
    files.

    RELATED

      * hou.houdiniPath

      * hou.applicationVersion

      * hou.findFile

      * hou.findFiles

      * hou.findDirectory

      * hou.findDirectories


    """
    return _hou.homeHoudiniDirectory()


def readFile(file_path: "char const *") -> "std::string":
    r"""

    hou.readFile

    Read a file, returning the contents in a string. Supports regular files,
    opdef: and oplib: paths, and http URLs.

    USAGE
      readFile(file_path) -> str

    Opdef paths can be specified with the string opdef:/node?section (e.g.
    opdef:/Object/subnet1?my_section). Oplib paths can be specified with
    oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).

    If the file does not exist or an error occurs while reading, this
    function raises hou.OperationFailed.


    """
    return _hou.readFile(file_path)


def readBinaryFile(file_path: "char const *") -> "HOM_BinaryString":
    r"""

    hou.readBinaryFile

    Read a binary file, returning the contents in a bytes object. Supports
    regular files, opdef: and oplib: paths, and http URLs.

    USAGE
      readBinaryFile(file_path) -> bytes

    Only available in Python 3.

    Opdef paths can be specified with the string opdef:/node?section (e.g.
    opdef:/Object/subnet1?my_section). Oplib paths can be specified with
    oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).

    If the file does not exist or an error occurs while reading, this
    function raises hou.OperationFailed.


    """
    return _hou.readBinaryFile(file_path)


def saveCPIODataToString(
    data: "std::vector< std::pair< std::string,HOM_BinaryString >,std::allocator< std::pair< std::string,HOM_BinaryString > > > const &",
) -> "HOM_BinaryString":
    r"""

    hou.saveCPIODataToString

    Given a sequence of (name, value) string tuples, encode that data into a
    string in CPIO format.

    USAGE
      saveCPIODataToString(data_tuples) -> str

    The inverse of this function is hou.loadCPIODataFromString. See it for
    more information about CPIO data format.

    RELATED

      * hou.loadCPIODataFromString


    """
    return _hou.saveCPIODataToString(data)


def loadIndexDataFromFile(
    file_path: "char const *",
) -> "std::map< std::string,HOM_BinaryString,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_BinaryString > > >":
    r"""

    hou.loadIndexDataFromFile

    Given a file containing data in index data format, decode the data and
    return a dictionary representing the data.

    USAGE
      loadIndexDataFromFile(file_path) -> dict

    This function could be implemented as follows:

    > def loadIndexDataFromFile(file_path):
    >     hou.loadIndexDataFromString(hou.readFile(file_path))

    See hou.loadIndexDataFromString for more details.

    RELATED

      * hou.saveIndexDataToFile

      * hou.loadIndexDataFromString

      * hou.saveIndexDataToString


    """
    return _hou.loadIndexDataFromFile(file_path)


def saveIndexDataToString(
    index_data: "std::map< std::string,HOM_BinaryString,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_BinaryString > > > const &",
) -> "HOM_BinaryString":
    r"""

    hou.saveIndexDataToString

    Given a dictionary mapping strings to strings, encode that data into a
    string in index data format.

    USAGE
      saveIndexDataToString(data_dict) -> str

    The inverse of this function is hou.loadIndexDataFromString. See it for
    more information about index data format.

    RELATED

      * hou.loadIndexDataFromString

      * hou.loadIndexDataFromFile

      * hou.saveIndexDataToFile


    """
    return _hou.saveIndexDataToString(index_data)


def saveIndexDataToFile(
    file_path: "char const *",
    index_data: "std::map< std::string,HOM_BinaryString,std::less< std::string >,std::allocator< std::pair< std::string const,HOM_BinaryString > > > const &",
) -> "void":
    r"""

    hou.saveIndexDataToFile

    Given a dictionary mapping strings to strings, encode that data in index
    data format and save it into a file.

    USAGE
      saveIndexDataToFile(file_path, index_data)

    This function could be implemented as follows:

    > def saveIndexDataToFile(file_path, index_data):
    >     with open(file_path, \"wb\") as open_file:
    >         open_file.write(hou.saveIndexDataToString(index_data))

    See hou.loadIndexDataFromString for more details.

    RELATED

      * hou.loadIndexDataFromFile

      * hou.loadIndexDataFromString

      * hou.saveIndexDataToString


    """
    return _hou.saveIndexDataToFile(file_path, index_data)


def vexContexts() -> (
    "std::vector< HOM_ElemPtr< HOM_VexContext >,std::allocator< HOM_ElemPtr< HOM_VexContext > > >"
):
    r"""

    hou.vexContexts

    USAGE
      vexContexts() -> tuple of VexContexts


    """
    return _hou.vexContexts()


def vexContextForShaderType(shader_type: "EnumValue") -> "HOM_VexContext *":
    r"""

    hou.vexContextForShaderType

    NOTE
        This function is for internal use by Houdini and isn't usually
        necessary for scripting Houdini or creating tools.

    USAGE
      vexContextForShaderType(shader_type) -> hou.VexContext or None

    RELATED

      * VEX contexts

      * hou.vexContextForNodeTypeCategory


    """
    return _hou.vexContextForShaderType(shader_type)


def vexContextForNodeTypeCategory(
    node_type_category: "NodeTypeCategory",
) -> "HOM_VexContext *":
    r"""

    hou.vexContextForNodeTypeCategory

    Takes a NodeTypeCategory object and returns a VexContext object
    representing the context of VOP networks the node would contain.


    NOTE
        This function is for internal use by Houdini and isn't usually
        necessary for scripting Houdini or creating tools.

    USAGE
      vexContextForNodeTypeCategory(node_type_category) -> hou.VexContext or
      None

    > >>> # Get a reference to a SOP node
    > >>> n = hou.node(\"/obj/geo1/pointvop1\")
    > >>> # Get its type category (SOPs)
    > >>> sops = n.type().category()
    > >>> # If a SOP contains a VOP network, what is its context?
    > >>> hou.vexContextForNodeTypeCategory(sops)
    > <hou.VexContext Sop>
    > >>> hou.vexContextForNodeTypeCategory(sops).name()
    > 'Sop'
    See hou.VexContext.

    RELATED

      * VEX contexts

      * hou.vexContextForShaderType


    """
    return _hou.vexContextForNodeTypeCategory(node_type_category)


def convertClipData(
    data: "HOM_BinaryString",
    from_binary: "bool",
    from_blosc_compression: "bool",
    to_binary: "bool",
    to_blosc_compression: "bool",
) -> "HOM_BinaryString":
    r"""

    hou.convertClipData

    USAGE
      convertClipData(data, from_binary, from_blosc_compression, to_binary,
      to_blosc_compression) -> str for Python 2, bytes for Python 3

    Converts the given clip <data> from the given format into the specified
    format.

    <from_binary> and <from_blosc_compression> specify the format of the
    given <data>.

      * If <from_binary> is True, the given data is binary clip data
        otherwise it is plain text (ASCII) clip data.

      * If <from_blosc_compression> is True, the given data contains blosc
        compressed binary clip data. This cannot be used with ASCII clip
        data.

    <to_binary> and <to_blosc_compression> specify the format the data
    should be converted to.

      * If <to_binary> is True, convert to a binary clip data otherwise
        convert to ASCII clip data.

      * If <to_blosc_compression> is True, convert to blosc compressed
        binary clip data. This cannot be used with ASCII clip data.

    The data passed into this function must be a bytes object in Python 3
    and a str object in Python 2. Similarly, the data returned by this
    function is a bytes object in Python 3 and a str object in Python 2. See
    HOM binary data for more information.

    Raises a hou.InvalidInput exception if from_binary = False and
    from_blosc_compression = True, or if to_binary = False and
    to_blosc_compression = True.

    Raises a hou.OperationFailed exception if the given <data> is invalid.


    """
    return _hou.convertClipData(
        data, from_binary, from_blosc_compression, to_binary, to_blosc_compression
    )


def convertKeyframesToClipData(
    keyframe_map: "std::map< std::string,std::vector< HOM_Keyframe *,std::allocator< HOM_Keyframe * > >,std::less< std::string >,std::allocator< std::pair< std::string const,std::vector< HOM_Keyframe *,std::allocator< HOM_Keyframe * > > > > > const &",
    binary: "bool" = True,
    use_blosc_compression: "bool" = True,
) -> "HOM_BinaryString":
    r"""

    hou.convertKeyframesToClipData

    USAGE
      convertKeyframesToClipData(keyframe_map, binary=True,
      use_blosc_compression=True) -> str

    Converts the given keyframes into clip data.


    keyframe_map
        A dictionary mapping parameter names (str) to a list of keyframes
        for the parameter (hou.Keyframe).

    <binary> and <use_blosc_compression> specify the format of the returned
    clip data.

      * If <binary> is True, the returned data is binary clip data.
        Otherwise it is plain text (ASCII) clip data.

      * If <use_blosc_compression> is True, the returned data is blosc
        compressed binary clip data. This cannot be used with ASCII clip
        data.

    Raises a hou.InvalidInput exception if binary = False and
    use_blosc_compression = True.

    Raises a hou.OperationFailed exception if the given <keyframe_map> is
    empty.


    """
    return _hou.convertKeyframesToClipData(keyframe_map, binary, use_blosc_compression)


def _clipInfo(
    data: "HOM_BinaryString", binary: "bool" = True, blosc_compressed: "bool" = True
) -> "std::string":
    return _hou._clipInfo(data, binary, blosc_compressed)


def setSessionModuleSource(source: "char const *") -> "void":
    r"""

    hou.setSessionModuleSource

    Sets the contents of the hou.session module. The new contents is made
    available immediately. You do not have to re-import hou.session.

    USAGE
      setSessionModuleSource(source)

    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module. This can happen if the new contents has
    syntax errors.

    RELATED

      * hou.appendSessionModuleSource

      * hou.session

      * hou.setSessionModuleSource


    """
    return _hou.setSessionModuleSource(source)


def appendSessionModuleSource(source: "char const *") -> "void":
    r"""

    hou.appendSessionModuleSource

    Appends the given source code to the hou.session module. The appended
    code is made available immediately. You do not have to re-import
    hou.session.

    USAGE
      appendSessionModuleSource(source)

    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module. This can happen if the appended source
    has syntax errors or if it conflicts with the existing contents of the
    module.

    RELATED

      * hou.session

      * hou.sessionModuleSource

      * hou.setSessionModuleSource


    """
    return _hou.appendSessionModuleSource(source)


def sessionModuleSource() -> "std::string":
    r"""

    hou.sessionModuleSource

    Returns the contents of the hou.session module.

    USAGE
      sessionModuleSource() -> string

    RELATED

      * hou.appendSessionModuleSource

      * hou.session

      * hou.setSessionModuleSource


    """
    return _hou.sessionModuleSource()


def __galleries() -> "HOM_galleries &":
    return _hou.__galleries()


def __hda() -> "HOM_hda &":
    return _hou.__hda()


def __hipFile() -> "HOM_hipFile &":
    return _hou.__hipFile()


def __perfMon() -> "HOM_perfMon &":
    return _hou.__perfMon()


def __playbar() -> "HOM_playbar &":
    return _hou.__playbar()


def __pypanel() -> "HOM_pypanel &":
    return _hou.__pypanel()


def __hmath() -> "HOM_hmath &":
    return _hou.__hmath()


def __dop() -> "HOM_dop &":
    return _hou.__dop()


def __properties() -> "HOM_properties &":
    return _hou.__properties()


def __shelves() -> "HOM_shelves &":
    return _hou.__shelves()


def __styles() -> "HOM_styles &":
    return _hou.__styles()


def __takes() -> "HOM_takes &":
    return _hou.__takes()


def __ui() -> "HOM_ui &":
    return _hou.__ui()


def __qt() -> "HOM_qt &":
    return _hou.__qt()


def __hotkeys() -> "HOM_hotkeys &":
    return _hou.__hotkeys()


def __viewportVisualizers() -> "HOM_viewportVisualizers &":
    return _hou.__viewportVisualizers()


def __audio() -> "HOM_audio &":
    return _hou.__audio()


def __undos() -> "HOM_undos &":
    return _hou.__undos()


def __anonstats() -> "HOM_anonstats &":
    return _hou.__anonstats()


def __crowds() -> "HOM_crowds &":
    return _hou.__crowds()


def __ik() -> "HOM_ik &":
    return _hou.__ik()


def __logging() -> "HOM_logging &":
    return _hou.__logging()


def __lop() -> "HOM_lop &":
    return _hou.__lop()


def __text() -> "HOM_text &":
    return _hou.__text()


def compareNode(path: "char const *", dest: "char const *" = None) -> "bool":
    return _hou.compareNode(path, dest)


def compareNodeBackup(
    path: "char const *", index: "int", dest: "char const *" = None
) -> "bool":
    return _hou.compareNodeBackup(path, index, dest)


def compareHDA(
    path_left: "char const *", path_right: "char const *", dest: "char const *" = None
) -> "bool":
    return _hou.compareHDA(path_left, path_right, dest)


def compareHDABackup(
    path: "char const *", index: "int", dest: "char const *" = None
) -> "bool":
    return _hou.compareHDABackup(path, index, dest)


def compareHip(dest: "char const *" = None) -> "bool":
    return _hou.compareHip(dest)


def compareHipBackup(index: "int", dest: "char const *" = None) -> "bool":
    return _hou.compareHipBackup(index, dest)


def hasContextOption(opt: "char const *") -> "bool":
    r"""

    hou.hasContextOption

    Returns True if the specified option exists in the current cook context.

    USAGE
      hasContextOption(option) -> bool

    This method tests for options that may have been set by a node
    requesting data from another node, or that are set in the default cook
    context options stored with the hip file.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.setDefaultContextOption


    """
    return _hou.hasContextOption(opt)


def contextOptionNames() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.contextOptionNames

    Returns the names of all available cook context options.

    USAGE
      contextOptionNames() -> tuple of str

    Retrieves the names of all options available in the current cook
    context. If this method is invoked outside a cook context, it will
    return the names of all the default cook context options stored in the
    hip file.

    RELATED

      * hou.contextOption

      * hou.hasContextOption

      * hou.setDefaultContextOption


    """
    return _hou.contextOptionNames()


def setContextOption(*args) -> "void":
    r"""

    hou.setContextOption

    Sets the default value for a cook context option.

    USAGE
      setContextOption(option, value)

    If the named context option doesn't already exist, it is created as part
    of the set of default cook context options that are stored with the hip
    file. Passing a value of None will remove the named context option from
    the set of default options. The value may be either a string or a
    number.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.hasContextOption


    """
    return _hou.setContextOption(*args)


def removeContextOption(opt: "char const *") -> "void":
    r"""

    hou.removeContextOption

    Removes the default value for a cook context option.

    USAGE
      removeContextOption(option, value)

    Removes the named context option from the set of default options. The
    value may be either a string or a number.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.hasContextOption

      * hou.setContextOption


    """
    return _hou.removeContextOption(opt)


def contextOptionConfig(opt: "char const *") -> "std::string":
    r"""

    hou.contextOptionConfig

    Returns the string that holds the UI configuration for the default value
    of a context option.

    USAGE
      contextOptionConfig(option) -> str

    Returns a string associated with a context option that describes the
    appearance of the UI for controlling the option's default value in the
    Default Context Options dialog.

    RELATED

      * hou.setContextOptionConfig

      * hou.setContextOption


    """
    return _hou.contextOptionConfig(opt)


def setContextOptionConfig(opt: "char const *", config: "char const *") -> "void":
    r"""

    hou.setContextOptionConfig

    Sets a string to hold the UI configuration for the default value of a
    context option.

    USAGE
      setContextOptionConfig(option, config)

    Sets a string associated with a context option that describes the
    appearance of the UI for controlling the option's default value in the
    Default Context Options dialog. This value is saved to the hip file
    along with the default context option value.

    RELATED

      * hou.contextOptionConfig

      * hou.setContextOption


    """
    return _hou.setContextOptionConfig(opt, config)


def isAutoContextOption(opt: "char const *") -> "bool":
    r"""

    hou.isAutoContextOption

    Indicate whether the given context option is an automatic option.

    USAGE
      isAutoContextOption(option) -> bool

    Return True if the specified context option is an automatic option,
    whose value is normally controlled by Houdini rather than set by the
    user. This does not necessarily indicate that the current value has been
    set automatically, as any context option can be overridden by a script
    or a node in the network. But if an automatic option is not being set by
    any other source, it will still be set to a value determined by the
    following rules:


    fstart
        The first frame of the global Houdini frame range. Equivalent to
        theFSTART global variable.

    fend
        The last frame of the global Houdini frame range. Equivalent to
        theFEND global variable.

    rfstart
        The first frame of the current playback range. Equivalent to
        theRFSTART global variable.

    rfend
        The last frame of the current playback range. Equivalent to theRFEND
        global variable.

    finc
        The current playbar step size.

    ropcook
        An integer value that will be 1 while a ROP node is running,
        otherwise 0.

    ropname
        A string set to the name of the ROP node that is currently running,
        otherwise an empty string.

    roppath
        A string set to the full path of the ROP node that is currently
        running, otherwise an empty string.

    ropstart
        The first frame of the range being evaluated by the currently
        cooking ROP node. If no ROP node is cooking, it will be equal to the
        fstart automatic option.

    ropend
        The last frame of the range being evaluated by the currently cooking
        ROP node. If no ROP node is cooking, it will be equal to the fend
        automatic option.

    ropinc
        The increment value of the frame range being evaluated by the
        currently cooking ROP node. If no ROP node is cooking, it will be
        equal to the finc automatic option.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.isAutoContextOptionOverridden


    """
    return _hou.isAutoContextOption(opt)


def isAutoContextOptionOverridden(opt: "char const *") -> "bool":
    r"""

    hou.isAutoContextOptionOverridden

    Indicate whether the given context option is an automatic option that is
    currently overridden from its automatic value.

    USAGE
      isAutoContextOptionOverridden(option) -> bool

    Return True if the specified context option is an automatic option, and
    that option has been overridden to replace the automatic value. This
    will be the case if an automatic option value is overwritten by a
    script, a node, or as a result of cooking a ROP. For a list of automatic
    context options, see hou.isAutoContextOption.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.isAutoContextOption


    """
    return _hou.isAutoContextOptionOverridden(opt)


def removeAllContextOptionChangeCallbacks() -> "void":
    r"""

    hou.removeAllContextOptionChangeCallbacks

    Stops all callbacks from being executed when a default context option is
    changed.

    USAGE
      removeAllContextOptionChangeCallbacks()

    Removes all callbacks that were previously registered with
    hou.addContextOptionChangeCallback.

    RELATED

      * hou.addContextOptionChangeCallback

      * hou.contextOptionChangeCallbacks

      * hou.removeContextOptionChangeCallback

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
    return _hou.removeAllContextOptionChangeCallbacks()


def getPreferenceNames() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""

    hou.getPreferenceNames

    Return all the preference names.

    USAGE
      getPreferenceNames() -> tuple of strings

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.addPreference

      * hou.removePreference


    """
    return _hou.getPreferenceNames()


def getPreference(name: "char const *") -> "std::string":
    r"""

    hou.getPreference

    Return a preference value.

    USAGE
      getPreference(name) -> string

    RELATED

      * hou.addPreference

      * hou.removePreference

      * hou.getPreferenceNames

      * hou.setPreference


    """
    return _hou.getPreference(name)


def setPreference(name: "char const *", value: "char const *") -> "bool":
    r"""

    hou.setPreference

    Sets a preference given a name and returns true on success.

    USAGE
      setPreference(name, value) -> bool

    RELATED

      * hou.addPreference

      * hou.removePreference

      * hou.getPreference

      * hou.getPreferenceNames


    """
    return _hou.setPreference(name, value)


def addPreference(name: "char const *", value: "char const *") -> "bool":
    r"""

    hou.addPreference

    Add a user preference.

    Add a new user preference stored in the houdini.pref file.

    The preference won't appear in the Preferences user interface as this is
    meant for custom Python panels or scripts.

    Returns True if the preference was added successfully. Return False if
    the preference already existed or if it didn't start with custom..

    USAGE
      addPreference(name,value) -> bool


    name
        The preference name must start with 'custom.'.

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.removePreference

      * hou.getPreferenceNames


    """
    return _hou.addPreference(name, value)


def removePreference(name: "char const *") -> "bool":
    r"""

    hou.removePreference

    Remove a user preference.

    Remove a user preference stored in the houdini.pref file.

    Returns True if the preference was removed successfully. Return False if
    the preference didn't exist or if it didn't start with custom..

    USAGE
      removePreference(name) -> bool


    name
        The preference name to remove. It must start with 'custom.'.

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.addPreference

      * hou.getPreferenceNames


    """
    return _hou.removePreference(name)


def startHoudiniEngineDebugger(*args) -> "void":
    r"""

    hou.startHoudiniEngineDebugger

    Starts a Houdini Engine debugging session in Houdini if no session is
    currently active

    USAGE
      startHoudiniEngineDebugger(port) startHoudiniEngineDebugger(pipeName)


    port
        The port number that the debugging server should use

    pipeName
        The pipe name that the debugging server should use

    EXAMPLES

      > >hou.startHoudiniEngineDebugger(9090)
      > >hou.startHoudiniEngineDebugger(\"hapi_debug_session\")


    """
    return _hou.startHoudiniEngineDebugger(*args)


def __vector_Vector2(
    arg1: "std::vector< HOM_Vector2,std::allocator< HOM_Vector2 > > const &",
) -> "void":
    return _hou.__vector_Vector2(arg1)


def __vector_Vector3(
    arg1: "std::vector< HOM_Vector3,std::allocator< HOM_Vector3 > > const &",
) -> "void":
    return _hou.__vector_Vector3(arg1)


def __vector_Vector4(
    arg1: "std::vector< HOM_Vector4,std::allocator< HOM_Vector4 > > const &",
) -> "void":
    return _hou.__vector_Vector4(arg1)


def __vector_Matrix2(
    arg1: "std::vector< HOM_Matrix2,std::allocator< HOM_Matrix2 > > const &",
) -> "void":
    return _hou.__vector_Matrix2(arg1)


def __vector_Matrix3(
    arg1: "std::vector< HOM_Matrix3,std::allocator< HOM_Matrix3 > > const &",
) -> "void":
    return _hou.__vector_Matrix3(arg1)


def __vector_Matrix4(
    arg1: "std::vector< HOM_Matrix4,std::allocator< HOM_Matrix4 > > const &",
) -> "void":
    return _hou.__vector_Matrix4(arg1)


def __vector_Quaternion(
    arg1: "std::vector< HOM_Quaternion,std::allocator< HOM_Quaternion > > const &",
) -> "void":
    return _hou.__vector_Quaternion(arg1)


def _nodesFromOPNodeList(
    val: "int64",
) -> "std::vector< HOM_ElemPtr< HOM_Node >,std::allocator< HOM_ElemPtr< HOM_Node > > >":
    return _hou._nodesFromOPNodeList(val)


def _dopDataList(
    val: "int64",
) -> "std::vector< HOM_ElemPtr< HOM_DopData >,std::allocator< HOM_ElemPtr< HOM_DopData > > >":
    return _hou._dopDataList(val)


def _dopDataPointList(
    val: "int64",
) -> "std::vector< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > >,std::allocator< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > > > >":
    return _hou._dopDataPointList(val)


def _dopDataPolyList(
    val: "int64",
) -> "std::vector< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > >,std::allocator< std::pair< HOM_ElemPtr< HOM_DopData >,HOM_ElemPtr< HOM_GeometrySelection > > > >":
    return _hou._dopDataPolyList(val)


def userName(alpha: "bool" = True) -> "std::string":
    r"""

    hou.userName

    Returns the user name for the current Houdini session.

    USAGE
      userName( alpha=True ) -> string


    alpha
        If True (default) the function returns the user name with alpha
        characters only. Blank characters are replaced with underscores (_).
        If False, the function returns the user name as is.

    RELATED

      * hou.machineName


    """
    return _hou.userName(alpha)


def machineName(alpha: "bool" = True) -> "std::string":
    r"""

    hou.machineName

    Returns the name of the computer used with this Houdini session.

    USAGE
      machineName( alpha=True ) -> string


    alpha
        If True (default) the function returns the machine name with alpha
        characters only. Blank characters are replaced with underscores (_).
        If False, the function returns the machine name as is.

    RELATED

      * hou.userName


    """
    return _hou.machineName(alpha)


def _newGeometryDrawable(val: "int64") -> "HOM_GeometryDrawable *":
    return _hou._newGeometryDrawable(val)


def createAnimationLayers(*args) -> "HOM_Node *":
    r"""

    hou.createAnimationLayers

    Creates an Animation Layer Mixer from the parameters in the Channel
    List.

    USAGE
      createAnimationLayers( path=\"\" ) -> hou.Node

    Returns the created node of a the existing one if it already exists.


    path
        A full path to the location of the Layer CHOP node to create. The
        parent CHOPnet will be created automatically. If path empty, the
        default animation layers path will be used.

    RELATED

      * hou.addAnimationLayer

      * hou.removeAnimationLayer

      * hou.createAnimationClip


    """
    return _hou.createAnimationLayers(*args)


def addAnimationLayer(*args) -> "HOM_Node *":
    r"""

    hou.addAnimationLayer

    Adds an Animation Layer to an existing Animation Layer Mixer.

    USAGE
      addAnimationLayer( layermixer, layername=\"\" ) -> hou.Node

    Returns the created CHOP Channel node.


    layermixer
        A Layer CHOP on which to add the animation layer. A new multi
        instance will be added, its name set to layername.

    layername
        The layer name of the new layer.

    RELATED

      * hou.createAnimationLayers

      * hou.removeAnimationLayer

      * hou.createAnimationClip


    """
    return _hou.addAnimationLayer(*args)


def removeAnimationLayer(
    layermixer: "Node", layername: "std::string const &", merge_down: "bool" = False
) -> "bool":
    r"""

    hou.removeAnimationLayer

    Removes an Animation Layer from an existing Animation Layer Mixer.

    USAGE
      removeAnimationLayer( layermixer, layername, mergedown=False ) -> bool

    Returns True if the animation layer was removed.


    layermixer
        A Layer CHOP from which to remove the animation layer.

    layername
        The layer name to remove.

    RELATED

      * hou.createAnimationLayers

      * hou.addAnimationLayer

      * hou.createAnimationClip


    """
    return _hou.removeAnimationLayer(layermixer, layername, merge_down)


def createAnimationClip(*args) -> "HOM_Node *":
    r"""

    hou.createAnimationClip

    Creates an Animation Clip Mixer from the parameters in the Channel List.

    USAGE
      createAnimationClip( path=\"\",set_export=False ) -> hou.Node


    path
        A full path to the location of the Channel CHOP node to create. The
        parent CHOPnet will be created automatically. If path empty, the
        default animation clip path will be used. If a node already exists,
        a new node will still be created by with a numbered name.

    set_export
        Set the Export flag after creating the Channel CHOP.

    RELATED

      * hou.addAnimationLayer

      * hou.removeAnimationLayer

      * hou.createAnimationLayers


    """
    return _hou.createAnimationClip(*args)


def _sceneViewerWindow(val: "int64") -> "void *":
    return _hou._sceneViewerWindow(val)

    # Note that we do not run startup scripts just yet, since they may access
    # things like hou.hda.


def _hdaTrustedFunction(f):
    """_hdaTrustedFunction(f)

    A decorator for granting functions extra access privileges.

    This decorator grants a function defined in an HDA PythonModule
    section access privileges to the internals of that HDA.

    This function is only intended for internal Side Effects Software use.
    """
    skey = _currentPythonModuleKey()

    try:
        from functools import update_wrapper
    except ImportError:

        def update_wrapper(dest, src):
            dest.__name__ = src.__name__
            dest.__dict__.update(src.__dict__)
            dest.__doc__ = src.__doc__
            dest.__module__ = src.__module__
            return dest

    def wrapper_f(*args, **kw):
        _pushAccessPrivilege(skey)
        try:
            rval = f(*args, **kw)
        finally:
            _popAccessPrivilege(skey)
        return rval

    _registerAccessPrivilegeClient(wrapper_f)
    return update_wrapper(wrapper_f, f)


def __createTopLevelFunc(name):
    """Create and return a function that will be added as a top-level
    function to the hou module, and that wraps around a corresponding
    function in the houpythonportion module."""

    def new_func(*args, **kwargs):
        import houpythonportion

        src_func = getattr(houpythonportion, name)
        return src_func(*args, **kwargs)

    return new_func


# Top-level functions defined in houpythonportion.
assertTrue = __createTopLevelFunc("assertTrue")
clipInfo = __createTopLevelFunc("clipInfo")
expandString = __createTopLevelFunc("expandString")
hscriptExpandString = __createTopLevelFunc("hscriptExpandString")
expandStringAtFrame = __createTopLevelFunc("expandStringAtFrame")
incrementNumberedString = __createTopLevelFunc("incrementNumberedString")
encode = __createTopLevelFunc("encode")
decode = __createTopLevelFunc("decode")
thirdPartyLibraryVersions = __createTopLevelFunc("thirdPartyLibraryVersions")
selectedItemsAsData = __createTopLevelFunc("selectedItemsAsData")
itemsAsData = __createTopLevelFunc("itemsAsData")
createItemsFromData = __createTopLevelFunc("createItemsFromData")
parmTemplateFromData = __createTopLevelFunc("parmTemplateFromData")


# Wrap deprecated functions.
def __deprecated(func, replace=None):
    import warnings, functools

    def wrappedFunc(*args, **kwargs):
        if replace is not None:
            warnings.warn(
                "{} is deprecated. Use {} instead.".format(func.__name__, replace),
                DeprecationWarning,
                stacklevel=2,
            )
            warnings.warn(
                func.__name__ + " is deprecated. Use " + replace + " instead.",
                DeprecationWarning,
                stacklevel=2,
            )
        else:
            warnings.warn(
                func.__name__ + " is deprecated", DeprecationWarning, stacklevel=2
            )
        return func(*args, **kwargs)

    functools.update_wrapper(wrappedFunc, func)
    return wrappedFunc


__finishedImport = False


def __finishImport():
    """Completes the import of the hou module by setting its remaining
    attributes.
    """
    global __finishedImport
    global __ui, __qt, __audio, __hda, __hmath, __hipFile, __perfMon, __playbar, __properties, __pypanel, __shelves, __styles, __takes, __viewportVisualizers, __galleries, __dop, __undos, __anonstats, __crowds, __ik, __hotkeys, __logging, __lop, __text, ui, qt, undos, audio, hda, hmath, pypanel, hipFile, perfMon, playbar, properties, shelves, styles, takes, viewportVisualizers, galleries, dop, anonstats, crowds, ik, logging, lop, text, Vector2, Vector3, Vector4, hotkeys, BoundingBox, BoundingRect, Quaternion, HDADefinition, Node, NodeType, Face, Desktop, hscriptExpandString, expandString, expandStringAtFrame, incrementNumberedString, patternMatch, encode, decode, Quadric, ShellIO, ParmTemplate, PythonPanelInterface, FolderSetParmTemplate, InvalidNodeName, __deprecated, applicationVersion, applicationVersionString, selectedNodes, getenv, updateProgressAndCheckForInterrupt, saveImageDataToFile, nodeType, fileReferences, webServer, thirdPartyLibraryVersions, selectedItemsAsData, itemsAsData, createItemsFromData, parmTemplateFromData

    # Do not run this function again if it was already called.
    if __finishedImport:
        return

    # Add the parts of the hou module written in Python.
    import houpythonportion

    # Add hwebserver
    import hwebserver

    webServer = hwebserver

    # Create the submodules:
    if isUIAvailable():
        # Import the Pure python portion of the hou.qt module.
        import houpythonportion.qt

        # Import the Pure python portion of the hou.qt module.
        # This submodule must be imported last since it monkey patches
        # functionality in the hou module.
        import houpythonportion.ui

        ui = __ui()
        qt = __qt()
        hotkeys = __hotkeys()
        audio = __audio()
        viewportVisualizers = __viewportVisualizers()
    else:
        del ui
        del qt
        del hotkeys
        del audio
        del viewportVisualizers
    del __ui
    del __hotkeys
    del __qt
    del __audio
    del __viewportVisualizers

    try:
        hda = __hda()
    except NotAvailable:
        pass
    del __hda

    hmath = __hmath()
    del __hmath

    hipFile = __hipFile()
    del __hipFile

    perfMon = __perfMon()
    del __perfMon

    playbar = __playbar()
    del __playbar

    pypanel = __pypanel()
    del __pypanel

    properties = __properties()
    del __properties

    shelves = __shelves()
    del __shelves

    takes = __takes()
    del __takes

    galleries = __galleries()
    del __galleries

    styles = __styles()
    del __styles

    dop = __dop()
    del __dop

    undos = __undos()
    del __undos

    anonstats = __anonstats()
    del __anonstats

    crowds = __crowds()
    del __crowds

    ik = __ik()
    del __ik

    logging = __logging()
    del __logging

    lop = __lop()
    del __lop

    text = __text()
    del __text

    Vector2.almostEqual = __deprecated(Vector2.almostEqual, "hou.Vector2.isAlmostEqual")
    Vector3.almostEqual = __deprecated(Vector3.almostEqual, "hou.Vector3.isAlmostEqual")
    Vector4.almostEqual = __deprecated(Vector4.almostEqual, "hou.Vector4.isAlmostEqual")
    BoundingBox.almostEqual = __deprecated(
        BoundingBox.almostEqual, "hou.BoundingBox.isAlmostEqual"
    )
    Quaternion.almostEqual = __deprecated(
        Quaternion.almostEqual, "hou.Quaternion.isAlmostEqual"
    )
    HDADefinition.installed = __deprecated(
        HDADefinition.installed, "hou.HDADefinition.isInstalled"
    )
    HDADefinition.current = __deprecated(
        HDADefinition.current, "hou.HDADefinition.isCurrent"
    )
    HDADefinition.preferred = __deprecated(
        HDADefinition.preferred, "hou.HDADefinition.isPreferred"
    )
    HDADefinition.setPreferred = __deprecated(
        HDADefinition.setPreferred, "hou.HDADefinition.setIsPreferred"
    )
    Node.saveCodeToFile = __deprecated(
        Node.saveCodeToFile, "hou.Node.saveCookCodeToFile"
    )
    Node.saveToCompiledVexFile = __deprecated(
        Node.saveToCompiledVexFile, "hou.Node.saveCompiledCookCodeToFile"
    )
    NodeType.generatorFlag = __deprecated(
        NodeType.generatorFlag, "hou.NodeType.isGenerator"
    )
    NodeType.managerFlag = __deprecated(NodeType.managerFlag, "hou.NodeType.isManager")
    NodeType.unorderedInputsFlag = __deprecated(
        NodeType.unorderedInputsFlag, "hou.NodeType.hasUnorderedInputs"
    )
    Face.closed = __deprecated(Face.closed, "hou.Face.isClosed")
    Desktop.createFloatingPane = __deprecated(
        Desktop.createFloatingPane, "hou.Desktop.createFloatingPaneTab"
    )
    hscriptExpandString = __deprecated(hscriptExpandString, "hou.text.expandString")
    expandString = __deprecated(expandString, "hou.text.expandString")
    expandStringAtFrame = __deprecated(
        expandStringAtFrame, "hou.text.expandStringAtFrame"
    )
    incrementNumberedString = __deprecated(
        incrementNumberedString, "hou.text.incrementNumberedString"
    )
    patternMatch = __deprecated(patternMatch, "hou.text.patternMatch")
    encode = __deprecated(encode, "hou.text.encode")
    decode = __deprecated(decode, "hou.text.decode")
    Quadric.getTransform = __deprecated(Quadric.getTransform, "hou.Quadric.transform")
    ShellIO.addExitCallback = __deprecated(
        ShellIO.addExitCallback, "hou.ShellIO.addCloseCallback"
    )
    ShellIO.removeExitCallback = __deprecated(
        ShellIO.removeExitCallback, "hou.ShellIO.removeCloseCallback"
    )
    ShellIO.exitCallbacks = __deprecated(
        ShellIO.exitCallbacks, "hou.ShellIO.closeCallbacks"
    )
    ShellIO.CloseCallbacks = __deprecated(
        ShellIO.CloseCallbacks, "hou.ShellIO.closeCallbacks"
    )
    SopNode.copyNodeSelectionToUserSelection = __deprecated(
        SopNode.copyNodeSelectionToUserSelection
    )
    SopNode.selection = __deprecated(
        SopNode.selection, "hou.SceneViewer.currentGeometrySelection"
    )
    SopNode.setSelection = __deprecated(
        SopNode.setSelection, "hou.SceneViewer.setCurrentGeometrySelection"
    )
    ParmTemplate.joinWithNext = __deprecated(
        ParmTemplate.joinWithNext, "hou.ParmTemplate.joinsWithNext"
    )
    FolderSetParmTemplate.folderStyle = __deprecated(
        FolderSetParmTemplate.folderStyle, "hou.FolderSetParmTemplate.folderType"
    )
    Track.evalAtSampleIndex = __deprecated(
        Track.evalAtSampleIndex, "hou.Track.evalAtSample"
    )
    Agent.currentLayer = __deprecated(Agent.currentLayer, "hou.Agent.currentLayers")
    Agent.setCurrentLayer = __deprecated(
        Agent.setCurrentLayer, "hou.Agent.setCurrentLayers"
    )
    Agent.collisionLayer = __deprecated(
        Agent.collisionLayer, "hou.Agent.collisionLayers"
    )
    Agent.setCollisionLayer = __deprecated(
        Agent.setCollisionLayer, "hou.Agent.setCollisionLayers"
    )

    if isUIAvailable():
        ui.updateMode = __deprecated(ui.updateMode, "hou.updateModeSetting")
        ui.setUpdateMode = __deprecated(ui.setUpdateMode, "hou.setUpdateMode")
        ui.mainQtWindow = __deprecated(ui.mainQtWindow, "hou.qt.mainWindow")
        ui.createQtIcon = __deprecated(ui.createQtIcon, "hou.qt.createIcon")
        ui.qtStyleSheet = __deprecated(ui.qtStyleSheet, "hou.qt.styleSheet")
        RadialMenu.label = __deprecated(
            RadialMenu.label, "hou.RadialMenu.root().label()"
        )
        RadialMenu.setLabel = __deprecated(
            RadialMenu.setLabel, "hou.RadialMenu.root().setLabel()"
        )
        RadialMenu.shortcut = __deprecated(
            RadialMenu.shortcut, "hou.RadialMenu.root().shortcut()"
        )
        RadialMenu.setShortcut = __deprecated(
            RadialMenu.setShortcut, "hou.RadialMenu.root().setShortcut()"
        )
        RadialMenu.item = __deprecated(RadialMenu.item, "hou.RadialMenu.root().item()")
        RadialMenu.items = __deprecated(
            RadialMenu.items, "hou.RadialMenu.root().items()"
        )
        RadialMenu.createSubmenu = __deprecated(
            RadialMenu.createSubmenu, "hou.RadialMenu.root().createSubmenu()"
        )
        RadialMenu.createScriptItem = __deprecated(
            RadialMenu.createScriptItem, "hou.RadialMenu.root().createSubmenu()"
        )
        replace = "hou.GeometryViewportSettings depth of field settings"
        FlipbookSettings.useDepthOfField = __deprecated(
            FlipbookSettings.useDepthOfField, replace
        )
        FlipbookSettings.depthOfFieldFromCamera = __deprecated(
            FlipbookSettings.depthOfFieldFromCamera, replace
        )
        FlipbookSettings.depthOfFieldQuality = __deprecated(
            FlipbookSettings.depthOfFieldQuality, replace
        )
        FlipbookSettings.focusDistance = __deprecated(
            FlipbookSettings.focusDistance, replace
        )
        FlipbookSettings.aperture = __deprecated(FlipbookSettings.aperture, replace)
        FlipbookSettings.fStop = __deprecated(FlipbookSettings.fStop, replace)

    del __deprecated

    # Make sure Python undos are cleared before hython exits to prevent
    # seg faults
    import atexit

    atexit.register(undos.clear)

    # Create shortcuts for deprecated exceptions:
    InvalidNodeName = OperationFailed

    # When Python imports os, it will modify the C environ variable.
    # Similarly, when Houdini first gets/sets an environment variable, it
    # will also modify it.  So, first import os and then get a Houdini
    # environment variable to ensure that environ was allocated by Houdini.
    # Then, change os.putenv to use hou.putenv so that setting an
    # environment variable with os.environ will keep environ in the format
    # that Houdini expects.
    # import os
    # _hou.getenv("ENSURE_GETENV_IS_CALLED")
    # os.putenv = putenv
    # os.unsetenv = unsetenv

    # Monkey-patch the threading.Thread class so that the run()
    # method automatically calls the HOM registration function
    # which, on OSX, registers the thread with the objective-C
    # garbage collector.
    def __threadRun(self):
        __registerThread()
        self.__run()

    import threading

    threading.Thread.__run = threading.Thread.run
    threading.Thread.run = __threadRun

    # This is a hard-coded list of functions that SWIG outputs
    # at the end of hou.py after __runUserDefinedCode().
    # There is no reason for these functions to be outputted
    # at the end of hou.py
    # We suspect that there is a bug in SWIG since there is no reason
    # for these functions to be defined after __runUserDefinedCode().
    #
    # So we define the functions here so that they are made available
    # before __runUserDefinedCode() much like the rest of the HOM functions.
    applicationVersion = _hou.applicationVersion
    applicationVersionString = _hou.applicationVersionString
    selectedNodes = _hou.selectedNodes
    getenv = _hou.getenv
    updateProgressAndCheckForInterrupt = _hou.updateProgressAndCheckForInterrupt
    saveImageDataToFile = _hou.saveImageDataToFile
    nodeType = _hou.nodeType
    fileReferences = _hou.fileReferences

    # Load and run custom DSOs that extend the HOM library.
    __extendHOMWithDSOCode()

    __finishedImport = True


if not __doHoudiniInternalsExist():
    # The required Houdini internals do not exist yet so we cannot
    # import the hou module.  So we unimport and discard this instance of
    # the hou module.
    import sys

    _orig_hou = sys.modules["hou"]
    del sys.modules["hou"]

    # Create the required Houdini internals.
    # This will recursively import a new instance of the hou module
    # and will fully initialize the module.
    __createHoudiniInternals()

else:
    # The required Houdini internals exist so we can complete
    # the import and initialization of the hou module.

    __createHOMModule()

    __finishImport()

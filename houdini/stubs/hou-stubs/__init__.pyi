# Houdini stubs generated from Houdini 21.0.512

from houcppportion import *  # type: ignore[import-not-found]
from _typeshed import Incomplete

import datetime
import typing
from pathlib import Path
from types import TracebackType
from typing import Any, Callable, Dict, Iterator, Iterable, Mapping, Literal, Optional, Sequence, Self, Union, Tuple, TypeAlias

import pxr.Sdf  # type: ignore[import-not-found]
import pxr.Usd  # type: ignore[import-not-found]
from PySide6 import QtCore, QtGui, QtWidgets  # type: ignore[import-not-found]

AttribBasicType: TypeAlias = int | float | str
AttribArgType: TypeAlias = int | float | str | Sequence[int] | Sequence[float] | Sequence[str]
AttribDictArgType: TypeAlias = dict[str, int] | dict[str, float] | dict[str, str] | dict[str, Sequence[int]] | dict[str, Sequence[float]] | dict[str, Sequence[str]]
AttribReturnType: TypeAlias = int | float | str | Tuple[int, ...] | Tuple[float, ...] | Tuple[str, ...]
AttribDictReturnType: TypeAlias = dict[str, int] | dict[str, float] | dict[str, str] | dict[str, Tuple[int, ...]] | dict[str, Tuple[float, ...]] | dict[str, Tuple[str, ...]]
ParmArgType: TypeAlias = bool | int | float | str | dict[str, str] | 'Ramp' | 'Geometry' | 'Parm'
ParmReturnType: TypeAlias = bool | int | float | str | dict[str, str] | 'Ramp' | 'Geometry' | 'OpNode'
ParmTupleArgType: TypeAlias = Sequence[bool] | Sequence[int] | Sequence[float] | Sequence[str] | Sequence[dict[str, str]] | Sequence['Ramp'] | Sequence['Geometry'] | Sequence['Parm']
ParmTupleReturnType: TypeAlias = Tuple[bool, ...] | Tuple[int, ...] | Tuple[float, ...] | Tuple[str, ...] | Tuple[dict[str, str], ...] | Tuple['Ramp', ...] | Tuple['Geometry', ...] | Tuple['OpNode', ...]
OptionType: TypeAlias = bool | int | float | str | Vector2 | Vector3 | Vector4 | Quaternion | Matrix3 | Matrix4
OptionSequenceType: TypeAlias = Sequence[bool] | Sequence[int] | Sequence[float] | Sequence[str] | Sequence[Vector2] | Sequence[Vector3] | Sequence[Vector4] | Sequence[Quaternion] | Sequence[Matrix3] | Sequence[Matrix4]
OptionMultiArgType: TypeAlias = bool | int | float | str | Vector2 | Vector3 | Vector4 | Quaternion | Matrix3 | Matrix4 | Sequence[int] | Sequence[float]
OptionMultiReturnType: TypeAlias = bool | int | float | str | Vector2 | Vector3 | Vector4 | Quaternion | Matrix3 | Matrix4 | Tuple[int, ...] | Tuple[float, ...]


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__: Incomplete

class _NodeConnectionTupleOfTuplesGenerator:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __getitem__(self, key: int) -> Any: ...
    def __len__(self) -> int: ...

class EnumValue:
    """

    hou.EnumValue

    This class is the base class for an enumeration value. It cannot be
    instanced and is not meant to be used directly by the user.

    All the built-in HOM enumeration values are derived from this class such
    as hou.paneTabType.*, hou.severityType.*, and hou.connectivityType.*.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def name(self) -> str:
        """

        name(self) -> string

            Returns the name of the enumeration value.


        """
    def __lt__(self, other: object) -> bool: ...

class numericData:
    """

    hou.numericData

    Enumeration of numeric value types.

    VALUES


        Int8
        UInt8
        Int16
        Int32
        Int64
        Float16
        Float32
        Float64


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Float16: EnumValue = ...
    Float32: EnumValue = ...
    Float64: EnumValue = ...
    Int16: EnumValue = ...
    Int32: EnumValue = ...
    Int64: EnumValue = ...
    Int8: EnumValue = ...
    UInt8: EnumValue = ...

cvar: Incomplete

class attribData:
    """

    hou.attribData

    Enumeration of attribute data types.

    VALUES


        Int
        Float
        String
        Dict


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Dict: EnumValue = ...
    Float: EnumValue = ...
    Int: EnumValue = ...
    String: EnumValue = ...

class attribType:
    """

    hou.attribType

    Enumeration of geometry attribute types.

    Note that global attributes are also known as detail attributes.

    The type of data (e.g. int, float, string) is called the attribute data
    type, can correspond to hou.attribData.

    See hou.Geometry.addAttrib and hou.Attrib for more information.

    VALUES


        Point
        Prim
        Vertex
        Global


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Global: EnumValue = ...
    Point: EnumValue = ...
    Prim: EnumValue = ...
    Vertex: EnumValue = ...

class attribScope:
    """

    hou.attribScope

    Enumeration of geometry attribute scope.

    The scope of attribute data. All visible attributes have a public scope.
    Private attributes are hidden from the node info window and the geometry
    spreadsheet. Private attributes are often not transferred when geometry
    is copied or merged.

    VALUES


        Public
        Private


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Private: EnumValue = ...
    Public: EnumValue = ...

class groupScope:
    """

    hou.groupScope

    Enumeration of geometry group scope.

    The scope of group data. All visible groups have a public scope. Private
    groups are hidden from the node info window and the geometry
    spreadsheet. Private groups are not transferred when geometry is copied
    or merged.

    VALUES


        Public
        Private


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Private: EnumValue = ...
    Public: EnumValue = ...

class primType:
    """

    hou.primType

    Enumeration of primitive types.

    VALUES


        Agent
        AlembicRef
        BezierCurve
        BezierSurface
        Circle
        ChannelPrim
        Custom
            Catch-all for all HDK-defined primitives types.

        Hexahedron
            Eight points that deform a cubic volume.

        Mesh
        Metaball
        NURBSCurve
        NURBSSurface
        PackedFragment
        PackedGeometry
        PackedPrim
        ParticleSystem
            Obsolete type that represented particles, unconnected points are
            currently used for particles.

        PastedSurface
            Obsolete type to support NURBS that lie in the domain of other
            NURBS.

        Polygon
        PolySoup
        Sphere
        Tetrahedron
            Four points that define a pyramidal volume.

        TriangleBezier
        TriangleFan
            Defines a triangle between the first point and each consecutive
            pair of points.

        TriangleStrip
            Defines a triangle between each consecutive triple of points.

        Tube
        Unknown
        VDB
        Volume


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Agent: EnumValue = ...
    AlembicRef: EnumValue = ...
    BezierCurve: EnumValue = ...
    BezierSurface: EnumValue = ...
    ChannelPrim: EnumValue = ...
    Circle: EnumValue = ...
    Custom: EnumValue = ...
    Hexahedron: EnumValue = ...
    Mesh: EnumValue = ...
    Metaball: EnumValue = ...
    NURBSCurve: EnumValue = ...
    NURBSSurface: EnumValue = ...
    PackedFragment: EnumValue = ...
    PackedGeometry: EnumValue = ...
    PackedPrim: EnumValue = ...
    ParticleSystem: EnumValue = ...
    PastedSurface: EnumValue = ...
    PolySoup: EnumValue = ...
    Polygon: EnumValue = ...
    Sphere: EnumValue = ...
    Tetrahedron: EnumValue = ...
    TriangleBezier: EnumValue = ...
    TriangleFan: EnumValue = ...
    TriangleStrip: EnumValue = ...
    Tube: EnumValue = ...
    Unknown: EnumValue = ...
    VDB: EnumValue = ...
    Volume: EnumValue = ...

class parmData:
    """

    hou.parmData

    Enumeration of parameter data types.

    VALUES


        Int
        Float
        String
        Ramp


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Float: EnumValue = ...
    Int: EnumValue = ...
    Ramp: EnumValue = ...
    String: EnumValue = ...

class parmTemplateType:
    """

    hou.parmTemplateType

    Enumeration of parameter template types.

    VALUES


        Int
        Float
        String
        Toggle
        Menu
        Button
        FolderSet
        Folder
        Separator
        Label
        Ramp
        Data


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Button: EnumValue = ...
    Data: EnumValue = ...
    Float: EnumValue = ...
    Folder: EnumValue = ...
    FolderSet: EnumValue = ...
    Int: EnumValue = ...
    Label: EnumValue = ...
    Menu: EnumValue = ...
    Ramp: EnumValue = ...
    Separator: EnumValue = ...
    String: EnumValue = ...
    Toggle: EnumValue = ...

class parmLook:
    """

    hou.parmLook

    Enumeration of available looks for a parameter

    These looks are used by hou.ParmTemplate objects and control the user
    interface of the parameter in parameter editors.

    VALUES


        Regular
            The default parameter look.

        Logarithmic
            The parameter displays a slider that changes the value on a
            logarithmic scale.

        Angle
            The parameter has an arc control to enter an angle.

            If you use this look, set your parameter's naming scheme to
            hou.parmNamingScheme.Base1.

        Vector
            The parameter has a handle beside the label to edit the vector
            direction.

            If you use this look, set your parameter's naming scheme to
            hou.parmNamingScheme.XYZW.

        ColorSquare
            The parameter has a square button beside the label to display
            the current color. You can click on the square to edit the
            color.

            If you use this look, set your parameter's naming scheme to
            hou.parmNamingScheme.RGBA.

        HueCircle
            The parameter has a hue circle with a pie-shaped region, like
            the keying nodes in COPs have.

        CRGBAPlaneChooser
            The parameter has an RGBA mask, with buttons to toggle the red,
            green, blue, and alpha planes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Angle: EnumValue = ...
    CRGBAPlaneChooser: EnumValue = ...
    ColorSquare: EnumValue = ...
    HueCircle: EnumValue = ...
    Logarithmic: EnumValue = ...
    Regular: EnumValue = ...
    Vector: EnumValue = ...

class parmNamingScheme:
    '''

    hou.parmNamingScheme

    Enumeration of available naming schemes for a parameter.

    These naming schemes are stored inside hou.ParmTemplate objects and
    determine the names of hou.Parm objects inside hou.ParmTuple objects.

    The number of components in the parm template determines the number of
    parms inside the parm tuple. If this number is 1, the parm name is the
    same as the parm tuple name. If the naming scheme is Base1, the number
    of components may be more than 4. Otherwise, the component may have from
    2 components up to the maximum number allowed by the naming scheme.

    The following restrictions exist on naming schemes:

      * You cannot use the following naming schemes when editing the
        parameter interface on a node or a digital asset: MinMax, MaxMin,
        StartEnd, BeginEnd, XYWH. However, some built-in node types use
        parameters with these naming schemes, so asking these node types for
        their parm templates may return ones using these naming schemes.

      * String and toggle parameters only support the Base1 naming scheme.

      * Parameters with the hou.parmLook.Vector look must use the XYZW
        naming scheme.

      * Parameters with the hou.parmLook.Angle look must use the Base1
        naming scheme.

      * Parameters with the hou.parmLook.ColorSquare look must use an RGBA
        naming scheme.

    The example names below are for a parm template named \\"foo\\":

    VALUES


        Base1
            \\"foo1\\", \\"foo2\\", \\"foo3\\", ...

        XYZW
            \\"foox\\", \\"fooy\\", \\"fooz\\", \\"foow\\"

        XYWH
            \\"foox\\", \\"fooy\\", \\"foow\\", \\"fooh\\"

        UVW
            \\"foou\\", \\"foov\\", \\"foow\\"

        RGBA
            \\"foor\\", \\"foog\\", \\"foob\\", \\"fooa\\"

        MinMax
            \\"foomin\\", \\"foomax\\"

        MaxMin
            \\"foomax\\", \\"foomin\\"

        StartEnd
            \\"foostart\\", \\"fooend\\"

        BeginEnd
            \\"foobegin\\", \\"fooend\\"


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Base1: EnumValue = ...
    BeginEnd: EnumValue = ...
    MaxMin: EnumValue = ...
    MinMax: EnumValue = ...
    RGBA: EnumValue = ...
    StartEnd: EnumValue = ...
    UVW: EnumValue = ...
    XYWH: EnumValue = ...
    XYZW: EnumValue = ...

class parmCondType:
    """

    hou.parmCondType

    Enumeration of available parameter conditional types.

    VALUES


        DisableWhen
        HideWhen
        NoCookWhen


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    DisableWhen: EnumValue = ...
    HideWhen: EnumValue = ...
    NoCookWhen: EnumValue = ...

class parmExtrapolate:
    """

    hou.parmExtrapolate

    Enumeration of Extrapolation methods when evaluating value outside the
    keyframe range.

    VALUES


        Default
        Hold
        Cycle
        Extend
        Slope
        CycleOffset
        Oscillate


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Cycle: EnumValue = ...
    CycleOffset: EnumValue = ...
    Default: EnumValue = ...
    Extend: EnumValue = ...
    Hold: EnumValue = ...
    Oscillate: EnumValue = ...
    Slope: EnumValue = ...

class parmBakeChop:
    """

    hou.parmBakeChop

    Enumeration of Bake Chop modes.

    See hou.Parm.keyframesRefit.

    VALUES


        Off
        KeepExportFlag
        DisableExportFlag
        CreateDeleteChop


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CreateDeleteChop: EnumValue = ...
    DisableExportFlag: EnumValue = ...
    KeepExportFlag: EnumValue = ...
    Off: EnumValue = ...

class segmentType:
    """

    hou.segmentType

    Enumeration of values for segment types used by channel primitives.

    VALUES


        Bezier
        Constant
        Linear
        Cubic
        Ease
        EaseIn
        EaseOut
        Quintic


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Bezier: EnumValue = ...
    Constant: EnumValue = ...
    Cubic: EnumValue = ...
    Ease: EnumValue = ...
    EaseIn: EnumValue = ...
    EaseOut: EnumValue = ...
    Linear: EnumValue = ...
    Quintic: EnumValue = ...

class animBarToolSize:
    """

    hou.animBarToolSize

    Enumeration of values for the size options for Animation Toolbar tools.

    VALUES


        Compact
        Standard
        Wide
        ExtraWide


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Compact: EnumValue = ...
    ExtraWide: EnumValue = ...
    Standard: EnumValue = ...
    Wide: EnumValue = ...

class slopeMode:
    """

    hou.slopeMode

    Enumeration of values for default Slope Mode when inserting new keys
    into a channel.

    VALUES


        Manual
        Automatic


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Automatic: EnumValue = ...
    Manual: EnumValue = ...

class stringParmType:
    """

    hou.stringParmType

    Enumeration of string parameter types.

    A hou.StringParmTemplate is set to one of these types to specify whether
    a string parameter will hold an arbitrary string, a reference to a file,
    a reference to a node, or a reference to multiple nodes.

    VALUES


        Regular
        FileReference
        NodeReference
        NodeReferenceList


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    FileReference: EnumValue = ...
    NodeReference: EnumValue = ...
    NodeReferenceList: EnumValue = ...
    Regular: EnumValue = ...

class labelParmType:
    """

    hou.labelParmType

    Enumeration of label parameter types.

    A hou.LabelParmTemplate is set to one of these types to specify whether
    a label parameter will be a plain label, a heading, or a multi-line
    message block.

    VALUES


        Heading
        Label
        Message


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Heading: EnumValue = ...
    Label: EnumValue = ...
    Message: EnumValue = ...

class dataParmType:
    """

    hou.dataParmType

    Enumeration of data parameter types.

    A hou.DataParmTemplate is set to one of these types to specify whether a
    data parameter will hold geometry data or a key-value dictionary
    structure.

    VALUES


        Geometry
        KeyValueDictionary


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Geometry: EnumValue = ...
    KeyValueDictionary: EnumValue = ...

class exprLanguage:
    """

    hou.exprLanguage

    Enumeration of available expression languages.

    VALUES


        Python
        Hscript


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Hscript: EnumValue = ...
    Python: EnumValue = ...

class scriptLanguage:
    """

    hou.scriptLanguage

    Enumeration of available script languages.

    VALUES


        Python
        Hscript


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Hscript: EnumValue = ...
    Python: EnumValue = ...

class keyHalf:
    """

    hou.keyHalf

    Enumeration of the halves of a key, used when setting keyframe data in a
    Channel Primitive.

    See hou.ChannelPrim.setKeyValue.

    VALUES


        In
            Used to set only the in (left) side of a key.

        Out
            Used to set only the out (right) side of a key.

        InOut
            Used to set both sides of a key.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    In: EnumValue = ...
    InOut: EnumValue = ...
    Out: EnumValue = ...

class fileType:
    """

    hou.fileType

    Enumeration of file types.

    VALUES


        Any
        Image
        Geometry
        Ramp
        Capture
        Clip
        Lut
        Cmd
        Midi
        I3d
        Chan
        Sim
        SimData
        Hip
        Otl
        Dae
        Gallery
        Directory
        Icon
        Ds
        Alembic
        Psd
        LightRig
        Gltf
        Movie
        Fbx
        Usd
        Sqlite


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Alembic: EnumValue = ...
    Any: EnumValue = ...
    Capture: EnumValue = ...
    Chan: EnumValue = ...
    Clip: EnumValue = ...
    Cmd: EnumValue = ...
    Dae: EnumValue = ...
    Directory: EnumValue = ...
    Ds: EnumValue = ...
    Fbx: EnumValue = ...
    Gallery: EnumValue = ...
    Geometry: EnumValue = ...
    Gltf: EnumValue = ...
    Hip: EnumValue = ...
    I3d: EnumValue = ...
    Icon: EnumValue = ...
    Image: EnumValue = ...
    LightRig: EnumValue = ...
    Lut: EnumValue = ...
    Midi: EnumValue = ...
    Movie: EnumValue = ...
    Otl: EnumValue = ...
    Psd: EnumValue = ...
    Ramp: EnumValue = ...
    Sim: EnumValue = ...
    SimData: EnumValue = ...
    Sqlite: EnumValue = ...
    Usd: EnumValue = ...

class fileChooserMode:
    """

    hou.fileChooserMode

    Enumeration of possible read/write modes for the file chooser.

    See hou.ui.selectFile.

    VALUES


        Read
        Write
        ReadAndWrite


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Read: EnumValue = ...
    ReadAndWrite: EnumValue = ...
    Write: EnumValue = ...

class folderType:
    """

    hou.folderType

    Enumeration of folder types for FolderParmTemplates.

    See also hou.FolderParmTemplate.

    VALUES


        Collapsible
            A folder that expands and collapses to show and hide its
            contents respectively.

        Simple
            A simple folder for organizing parameters in the form of a group
            box.

        Tabs
            A normal folder represented by a tab.

        RadioButtons
            A folder with a radio button. The open folder is the selected
            radio button in the set of buttons.

        MultiparmBlock
            A block of multiparms. The user can add or remove instances of
            this parameter block.

        ScrollingMultiparmBlock
            A multiparm block inside a smaller region with scroll bars.

        TabbedMultiparmBlock
            A multiparm block where each instance of the parameters in the
            block appears in its own tab.

        ImportBlock
            A block containing parameters imported from another node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Collapsible: EnumValue = ...
    ImportBlock: EnumValue = ...
    MultiparmBlock: EnumValue = ...
    RadioButtons: EnumValue = ...
    ScrollingMultiparmBlock: EnumValue = ...
    Simple: EnumValue = ...
    TabbedMultiparmBlock: EnumValue = ...
    Tabs: EnumValue = ...

class menuType:
    """

    hou.menuType

    Enumeration of parameter menu types.

    See also hou.MenuParmTemplate and hou.StringParmTemplate.

    VALUES


        Normal
            A standard menu that displays the currently selected menu item.

        Mini
            A condensed menu that only displays a dropdown arrow. Houdini
            lets you choose a menu entry when you click on this arrow.

        ControlNextParameter
            A standard menu that displays the currently selected menu item.
            This menu always joins horizontally to the next parameter and is
            displayed without a label. However unlike simply turning off the
            label and joining to the next parameter, the layout of the next
            parameter is such that a series of parameters preceded by menus
            of this type will align in a much more appealing way.

        StringReplace
            A menu that also displays an input field. Selecting an entry
            from this menu will replace the contents of the field with the
            menu item. This type of menu only has meaning for string
            parameters.

        StringToggle
            A menu that also displays an input field. Selecting an entry
            from this menu will add the menu item to the field if it was not
            already there, and will remove it from the field it if was. This
            type of menu only has meaning for string parameters.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ControlNextParameter: EnumValue = ...
    Mini: EnumValue = ...
    Normal: EnumValue = ...
    StringReplace: EnumValue = ...
    StringToggle: EnumValue = ...

class paneTabType:
    """

    hou.paneTabType

    Enumeration of pane tab types.

    VALUES


        AssetBrowser
        ApexEditor
        BundleList
        ChannelEditor
        ChannelList
        ChannelViewer
        CompositorViewer
        ContextViewer
        DataTree
        DetailsView
        EngineSessionSync
        HandleList
        HelpBrowser
        IPRViewer
        LightLinker
        MaterialPalette
        NetworkEditor
        OutputViewer
        Parm
        ParmSpreadsheet
        PerformanceMonitor
        PythonPanel
        PythonShell
        RenderGallery
        SceneViewer
        ShaderViewer
        TakeList
        Textport
        TreeView


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ApexEditor: EnumValue = ...
    AssetBrowser: EnumValue = ...
    BundleList: EnumValue = ...
    ChannelEditor: EnumValue = ...
    ChannelList: EnumValue = ...
    ChannelViewer: EnumValue = ...
    CompositorViewer: EnumValue = ...
    ContextViewer: EnumValue = ...
    DataTree: EnumValue = ...
    DetailsView: EnumValue = ...
    EngineSessionSync: EnumValue = ...
    HandleList: EnumValue = ...
    HelpBrowser: EnumValue = ...
    IPRViewer: EnumValue = ...
    LightLinker: EnumValue = ...
    MaterialPalette: EnumValue = ...
    NetworkEditor: EnumValue = ...
    OutputViewer: EnumValue = ...
    Parm: EnumValue = ...
    ParmSpreadsheet: EnumValue = ...
    PerformanceMonitor: EnumValue = ...
    PythonPanel: EnumValue = ...
    PythonShell: EnumValue = ...
    RenderGallery: EnumValue = ...
    SceneViewer: EnumValue = ...
    ShaderViewer: EnumValue = ...
    TakeList: EnumValue = ...
    Textport: EnumValue = ...
    TreeView: EnumValue = ...

class stateViewerType:
    """

    hou.stateViewerType

    Enumeration of state viewer types.

    VALUES


        Scene
        Compositor


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Compositor: EnumValue = ...
    Scene: EnumValue = ...

class paneLinkType:
    """

    hou.paneLinkType

    Enumeration of possible pane link values.

    VALUES


        Pinned
        Group1
        Group2
        Group3
        Group4
        Group5
        Group6
        Group7
        Group8
        FollowSelection


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    FollowSelection: EnumValue = ...
    Group1: EnumValue = ...
    Group2: EnumValue = ...
    Group3: EnumValue = ...
    Group4: EnumValue = ...
    Group5: EnumValue = ...
    Group6: EnumValue = ...
    Group7: EnumValue = ...
    Group8: EnumValue = ...
    Pinned: EnumValue = ...

class networkItemType:
    """

    hou.networkItemType

    <Summary>

    <Description>

    VALUES


        Connection
        NetworkBox
        NetworkDot
        Node
        StickyNote
        SubnetIndirectInput


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Connection: EnumValue = ...
    NetworkBox: EnumValue = ...
    NetworkDot: EnumValue = ...
    Node: EnumValue = ...
    StickyNote: EnumValue = ...
    SubnetIndirectInput: EnumValue = ...

class colorItemType:
    """

    hou.colorItemType

    <Summary>

    <Description>

    VALUES


        NetworkBox
        StickyNote
        StickyNoteText


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NetworkBox: EnumValue = ...
    StickyNote: EnumValue = ...
    StickyNoteText: EnumValue = ...

class geometryViewportType:
    """

    hou.geometryViewportType

    Enumeration of scene viewer viewport types.

    VALUES


        Perspective
        Top
        Bottom
        Front
        Back
        Right
        Left
        UV


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Back: EnumValue = ...
    Bottom: EnumValue = ...
    Front: EnumValue = ...
    Left: EnumValue = ...
    Perspective: EnumValue = ...
    Right: EnumValue = ...
    Top: EnumValue = ...
    UV: EnumValue = ...

class glShadingType:
    """

    hou.glShadingType

    Enum for viewport shading modes

    VALUES


        hou.glShadingType.WireBoundingBox
            Objects displayed as wireframe bounding boxes.

        hou.glShadingType.ShadedBoundingBox
            Objects displayed as solid bounding boxes.

        hou.glShadingType.Wire
            Geometry displayed as regular wireframe.

        hou.glShadingType.WireGhost
            Geometry displayed as wireframe with occluded wires dimmed.

        hou.glShadingType.HiddenLineGhost
            Geometry displayed as wireframe with constant filled polygons.

        hou.glShadingType.HiddenLineInvisible
            Geometry displayed as wireframe hidden occluded wires.

        hou.glShadingType.MatCap
            Geometry displayed with a Material Capture texture (MatCap)
            which replaces the usual lighting and shading.

        hou.glShadingType.MatCapWire
            Geometry displayed with a Material Capture texture (MatCap)
            which replaces the usual lighting and shading, with outlined
            polygons.

        hou.glShadingType.Flat
            Geometry displayed as lit, but with flat shaded polygons.

        hou.glShadingType.FlatWire
            Geometry displayed as lit, but with flat shaded, outlined
            polygons.

        hou.glShadingType.Smooth
            Geometry displayed as shaded and lit.

        hou.glShadingType.SmoothWire
            Geometry displayed as shaded and lit with outlined polygons.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Flat: EnumValue = ...
    FlatWire: EnumValue = ...
    HiddenLineGhost: EnumValue = ...
    HiddenLineInvisible: EnumValue = ...
    MatCap: EnumValue = ...
    MatCapWire: EnumValue = ...
    ShadedBoundingBox: EnumValue = ...
    Smooth: EnumValue = ...
    SmoothWire: EnumValue = ...
    Wire: EnumValue = ...
    WireBoundingBox: EnumValue = ...
    WireGhost: EnumValue = ...

class viewportStereoMode:
    """

    hou.viewportStereoMode

    Stereoscopic viewport display modes

    The stereoscopic viewport display modes available when viewing through a
    stereo camera rig.

    VALUES


        hou.viewportStereoMode.Anaglyph
            Anaglyph display of left/right as red/cyan.

        hou.viewportStereoMode.HorizontalInterlace
            Interlace left and right on alternating scanlines. Only useful
            for 3D monitors which support this.

        hou.viewportStereoMode.HorizontalInterlaceReverse
            Interlace left and right on alternating scanlines, swapping
            which scanlines are used for left and right.

        hou.viewportStereoMode.QuadBufferGL
            Use OpenGL quad buffer stereo, generally only available on
            professional cards.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Anaglyph: EnumValue = ...
    HorizontalInterlace: EnumValue = ...
    HorizontalInterlaceReverse: EnumValue = ...
    QuadBufferGL: EnumValue = ...

class viewportHomeClipMode:
    """

    hou.viewportHomeClipMode

    Automatic viewport clip plane adjustment during homing

    Homing the viewport can adjust the viewport's near and far clip planes
    to adapt to what is being homed onto, so that geometry is fully visible
    in the viewport.

    VALUES


        hou.viewportHomeClipMode.Neither
            No clip planes are adjusted.

        hou.viewportHomeClipMode.NearOnly
            Only the near clip plane is adjusted. Far is left as is.

        hou.viewportHomeClipMode.FarOnly
            Only the far clip plane is adjusted. Near is left as is.

        hou.viewportHomeClipMode.NearAndFar
            Both clip planes are adjusted.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    FarOnly: EnumValue = ...
    NearAndFar: EnumValue = ...
    NearOnly: EnumValue = ...
    Neither: EnumValue = ...

class geometryViewportLayout:
    '''

    hou.geometryViewportLayout

    Enumeration of viewport layouts.

    > # Get a reference to the 3D viewer pane tab
    > desktop = hou.ui.curDesktop()
    > viewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer)
    > 
    > # Get the current layout
    > current_layout = viewer.viewportLayout()
    > # Change the layout to \\"quad view\\"
    > viewer.setViewportLayout(hou.geometryViewportLayout.)

    See the viewport methods on the SceneViewer object.

    VALUES


        DoubleSide

        DoubleStack

        Quad

        QuadBottomSplit

        QuadLeftSplit

        Single

        TripleBottomSplit

        TripleLeftSplit


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    DoubleSide: EnumValue = ...
    DoubleStack: EnumValue = ...
    Quad: EnumValue = ...
    QuadBottomSplit: EnumValue = ...
    QuadLeftSplit: EnumValue = ...
    Single: EnumValue = ...
    TripleBottomSplit: EnumValue = ...
    TripleLeftSplit: EnumValue = ...

class geometryViewportBackgroundImageFitMode:
    """

    hou.geometryViewportBackgroundImageFitMode

    Enumeration of image fit modes.

    VALUES


        Horizontal
        Vertical
        Fill
        Scale


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Fill: EnumValue = ...
    Horizontal: EnumValue = ...
    Scale: EnumValue = ...
    Vertical: EnumValue = ...

class snappingMode:
    """

    hou.snappingMode

    Enumeration of snapping modes.

    See hou.SceneViewer.snappingMode.

    VALUES


        Off
        Grid
        Prim
        Point
        Multi


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Grid: EnumValue = ...
    Multi: EnumValue = ...
    Off: EnumValue = ...
    Point: EnumValue = ...
    Prim: EnumValue = ...

class snapSelectionMode:
    """

    hou.snapSelectionMode

    Filter for primitive snapping in the LOPs viewer

    Restricts the primitives that can be snapped to by their selection
    status. This only affects the LOP viewer.

    VALUES


        hou.snapSelectionMode.SnapToAll
            Snapping is not restricted by selection; all primitives can be
            snapped.

        hou.snapSelectionMode.SnapToSelected
            Restrict snapping to only selected primitives. This can be
            useful to picking a pivot point on a primitive.

        hou.snapSelectionMode.SnapToNonSelected
            Restrict snapping to only non-selected primtives. This is
            normally used when transforming a selection, to avoid self-
            snapping.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    SnapToAll: EnumValue = ...
    SnapToNonSelected: EnumValue = ...
    SnapToSelected: EnumValue = ...

class selectionMode:
    """

    hou.selectionMode

    Enumeration of selection modes.

    See hou.SceneViewer.selectionMode.

    VALUES


        Object
        Geometry
        Dynamics


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Dynamics: EnumValue = ...
    Geometry: EnumValue = ...
    Object: EnumValue = ...

class pickStyle:
    """

    hou.pickStyle

    Enumeration of pick styles.

    VALUES


        Box
        Lasso
        Brush
        Laser


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Box: EnumValue = ...
    Brush: EnumValue = ...
    Laser: EnumValue = ...
    Lasso: EnumValue = ...

class pickModifier:
    """

    hou.pickModifier

    Enumeration of methods for modifying selections with new components.

    VALUES


        Add
        Toggle
        Remove
        Replace
        Intersect


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Add: EnumValue = ...
    Intersect: EnumValue = ...
    Remove: EnumValue = ...
    Replace: EnumValue = ...
    Toggle: EnumValue = ...

class pickFacing:
    """

    hou.pickFacing

    Enumeration for describing the facing direction of pickable components.

    VALUES


        Front
        Back
        FrontAndBack


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Back: EnumValue = ...
    Front: EnumValue = ...
    FrontAndBack: EnumValue = ...

class displaySetType:
    """

    hou.displaySetType

    Enum of viewport geometry contexts.

    There are several contexts for controlling shading and marker display
    which allow geometries from different operators to be distinguished from
    one another.

    VALUES


        hou.displaySetType.SceneObject
            Objects which are displayed but not selected, when the scene is
            viewing objects. In LOPs, this affects unselected primitives.

        hou.displaySetType.SelectedObject
            Objects which are displayed and selected, when the scene is
            viewing objects. In LOPs, this affects selected primitives.

        hou.displaySetType.GhostObject
            Objects which are not the currently edited object when Ghost
            other Objects display mode is active. Not used in LOPs.

        hou.displaySetType.DisplayModel
            The currently displayed surface operater when editing an object.
            Not used in LOPs.

        hou.displaySetType.CurrentModel
            The currently selected surface operater when editing an object.
            Not used in LOPs.

        hou.displaySetType.TemplateModel
            Surface operaters that have their template flag set when editing
            an object. Not used in LOPs.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CurrentModel: EnumValue = ...
    DisplayModel: EnumValue = ...
    GhostObject: EnumValue = ...
    SceneObject: EnumValue = ...
    SelectedObject: EnumValue = ...
    TemplateModel: EnumValue = ...

class topCookState:
    """

    hou.topCookState

    Enumeration of TOP Node cook states.

    VALUES


        Uncooked
            The node is uncooked. This occurs when it has no work items
            because it has never cooked before, or if it was dirtied.

        Cooking
            The node has work items that are currently cooking.

        Cooked
            All work items in the node are cooked.

        Failed
            One or more work items in the node has failed to cook.

        Warning
            One or more work items in the node have been canceled or issued
            a warning during the cook

        Waiting
            The node has no cooking work items, but may still generate new
            work from an input node.

        Incomplete
            The node has cooked work items, but one or more work items are
            in an uncooked state.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Cooked: EnumValue = ...
    Cooking: EnumValue = ...
    Failed: EnumValue = ...
    Incomplete: EnumValue = ...
    Uncooked: EnumValue = ...
    Waiting: EnumValue = ...
    Warning: EnumValue = ...

class markerVisibility:
    """

    hou.markerVisibility

    Enum of visibility options for marker visualizers.

    VALUES


        hou.markerVisibility.Always
            Display the markers without restriction.

        hou.markerVisibility.Selected
            Only display the marker if its component is selected.

        hou.markerVisibility.AroundPointer
            Display markers around the mouse pointer in 3D space.

        hou.markerVisibility.UnderPointer
            Display markers under the mouse pointer in screen space.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Always: EnumValue = ...
    AroundPointer: EnumValue = ...
    Selected: EnumValue = ...
    UnderPointer: EnumValue = ...

class viewportGuide:
    """

    hou.viewportGuide

    Viewport guides

    List of viewport guides that can be queried, enabled or disabled.

    VALUES


        hou.viewportGuide.CameraMask
            The mask which dims out areas outside the camera aspect ratio.

        hou.viewportGuide.CurrentGeometry
            Geometry from the current modelling operator (SOP)

        hou.viewportGuide.DisplayNodes
            Geometry from the currently displayed modelling operator (SOP)

        hou.viewportGuide.FieldGuide
        hou.viewportGuide.FillSelections
            Polygon selections are highlighted with a solid color rather
            than just an outline when in Wire-Over shading modes.

        hou.viewportGuide.FloatingGnomon
            Show the orientation axes in the lower left corner of the
            viewport.

        hou.viewportGuide.FollowSelection
            Show point or vertex markers when point or selection is active.

        hou.viewportGuide.GroupList
            Show the group list in the top right corner of the viewport.

        hou.viewportGuide.IKCriticalZone
            Show the critical zone for IK bones.

        hou.viewportGuide.NodeGuides
            Show any node guides that are available.

        hou.viewportGuide.NodeHandles
            Show any handles that are available.

        hou.viewportGuide.ObjectNames
            Show object names for visible objects.

        hou.viewportGuide.ObjectPaths
            Show full objects paths for visible objects. Object names must
            be displayed.

        hou.viewportGuide.ObjectSelection
            Show object selections.

        hou.viewportGuide.OriginGnomon
            Show the axes at the world origin.

        hou.viewportGuide.ParticleGnomon
            Show axes per particle.

        hou.viewportGuide.SafeArea
            Show the safe area overlay for broadcast.

        hou.viewportGuide.SelectableTemplates
            Show geometry from modelling operators with their selectable
            template flags set.

        hou.viewportGuide.ShowDrawTime
            Show the time to update and render the viewport.

        hou.viewportGuide.TemplateGeometry
            Show geometry from modelling operators with their template flags
            set.

        hou.viewportGuide.ViewPivot
            Show the camera pivot where tumbling will rotate about.

        hou.viewportGuide.XYPlane
            Show a grid along the XY plane.

        hou.viewportGuide.XZPlane
            Show a grid along the XZ plane.

        hou.viewportGuide.YZPlane
            Show a grid along the YZ plane.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CameraMask: EnumValue = ...
    CurrentGeometry: EnumValue = ...
    DisplayNodes: EnumValue = ...
    FieldGuide: EnumValue = ...
    FillSelections: EnumValue = ...
    FloatingGnomon: EnumValue = ...
    FollowSelection: EnumValue = ...
    GroupList: EnumValue = ...
    IKCriticalZone: EnumValue = ...
    NodeGuides: EnumValue = ...
    NodeHandles: EnumValue = ...
    ObjectNames: EnumValue = ...
    ObjectPaths: EnumValue = ...
    ObjectSelection: EnumValue = ...
    OriginGnomon: EnumValue = ...
    ParticleGnomon: EnumValue = ...
    SafeArea: EnumValue = ...
    SelectableTemplates: EnumValue = ...
    ShowDrawTime: EnumValue = ...
    TemplateGeometry: EnumValue = ...
    ViewPivot: EnumValue = ...
    XYPlane: EnumValue = ...
    XZPlane: EnumValue = ...
    YZPlane: EnumValue = ...

class viewportGeometryInfo:
    """

    hou.viewportGeometryInfo

    Geometry information display state

    The state of the geometry information displayed in the lower right
    corner of the viewport. This information takes additional time to
    generate.

    VALUES


        hou.viewportGeometryInfo.Off
            Do not show geometry information.

        hou.viewportGeometryInfo.SelectedOnly
            Only show information when a selection is present.

        hou.viewportGeometryInfo.AlwaysOn
            Always show information on the displayed geometry.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AlwaysOn: EnumValue = ...
    Off: EnumValue = ...
    SelectedOnly: EnumValue = ...

class viewportDefaultMaterial:
    """

    hou.viewportDefaultMaterial

    The default material shader for the 3D viewer

    This enum is used by GeometryViewportSettings.setDefaultMaterialType()
    to select the GLSL shader used when no materials are assigned to
    geometry.


    NOTE
        Custom GLSL shaders aren't supported for Vulkan. Instead, use
        MaterialX.

    VALUES


        hou.viewportDefaultMaterial.Simple
            An untextured material with variable roughness and color
            settings for diffuse, specular, emission, and ambient values.

        hou.viewportDefaultMaterial.MatCap
            A material that uses a MatCap texture (Material Capture) to
            define the lighting and shading of the surface rather than the
            lights in the scene.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    MatCap: EnumValue = ...
    Simple: EnumValue = ...

class viewportHandleHighlight:
    """

    hou.viewportHandleHighlight

    Handle highlight size

    Highlight size when moving the mouse over a handle.

    VALUES


        hou.viewportHandleHighlight.Off
            Don't display any highlights.

        hou.viewportHandleHighlight.Small
            Show a half-width highlight.

        hou.viewportHandleHighlight.Normal
            Show a full highlight.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Normal: EnumValue = ...
    Off: EnumValue = ...
    Small: EnumValue = ...

class viewportClosureSelection:
    """

    hou.viewportClosureSelection

    Viewport highlight of primitives with selected components

    When components of a primitive are selected (points, vertices, edges),
    the primitive can be highlighted as well to indicate which primitives
    will be affected by the current selection.

    VALUES


        hou.viewportClosureSelection.Hide
            Primitives are not highlighted.

        hou.viewportClosureSelection.HullPrimitives
            Only primitives whose points and edges reside on separate hull
            geometry will be highlighted when those are selected (NURBS
            surfaces, Bezier surfaces).

        hou.viewportClosureSelection.Show
            Highlight all primitives whose points, edges, or vertices belong
            to the current selection.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Hide: EnumValue = ...
    HullPrimitives: EnumValue = ...
    Show: EnumValue = ...

class viewportGuideFont:
    """

    hou.viewportGuideFont

    Viewport font sizes for visualizer text

    Font sizes for displaying text-based visualizers.

    VALUES


        hou.viewportGuideFont.Tiny
            Tiny font.

        hou.viewportGuideFont.Small
            Small font.

        hou.viewportGuideFont.Medium
            The just right font.

        hou.viewportGuideFont.Large
            Largest font.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Large: EnumValue = ...
    Medium: EnumValue = ...
    Small: EnumValue = ...
    Tiny: EnumValue = ...

class viewportVolumeQuality:
    """

    hou.viewportVolumeQuality

    Display options for viewport volume rendering quality

    Volume display in the viewport can be an expensive drawing operation.
    The volume quality can be adjusted to provide better viewport
    performance or better volume quality.

    VALUES


        VeryLow
            Quick volume preview.

        Low
            Minor quality loss for performance.

        Normal
            Balanced quality/performance setting.

        High
            Jittered, high quality volume with more passes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    High: EnumValue = ...
    Low: EnumValue = ...
    Normal: EnumValue = ...
    VeryLow: EnumValue = ...

class viewportVolumeBSplines:
    """

    hou.viewportVolumeBSplines

    Display options for viewport volume sampling quality

    When displaying fog volumes, the viewport can sample the underlying
    textures using either fast trilinear interpolation or slower (but
    smoother) b-spline interpolation. This enumeration contains the various
    sampling modes supported by the viewport.


    NOTE
        The equivalent setting in the viewport display options can be found
        in the Geometry tab and is labelled Volume Filtering.

    VALUES


        Off
            The viewport will never use higher-order volume interpolation.
            This is the fastest to draw, but low resolution volumes may
            appear blocky in the viewport.

        NonInteractive
            The viewport will use the higher-order interpolation when not
            interacting with the viewport. This mode falls back to linear
            interpolation while interacting with the viewport to speed up
            draws.

        On
            The viewport will always use higher-order volume interpolation.
            This is the slowest, highest quality option.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NonInteractive: EnumValue = ...
    Off: EnumValue = ...
    On: EnumValue = ...

class viewportBGImageView:
    """

    hou.viewportBGImageView

    Background image view target for the viewport display options

    Selects a view target when choosing which background image to edit in
    GeometryViewportSettings.

    VALUES


        hou.viewportBGImageView.Perspective
            The 3D view not attached to a camera (No cam).

        hou.viewportBGImageView.Camera
            The 3D view looking through a camera.

        hou.viewportBGImageView.Top
            The orthographic top view.

        hou.viewportBGImageView.Front
            The orthographic front view.

        hou.viewportBGImageView.Right
            The orthographic right view.

        hou.viewportBGImageView.Bottom
            The orthographic bottom view.

        hou.viewportBGImageView.Back
            The orthographic back view.

        hou.viewportBGImageView.Left
            The orthographic left view.

        hou.viewportBGImageView.UV
            The UV texture viewport.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Back: EnumValue = ...
    Bottom: EnumValue = ...
    Camera: EnumValue = ...
    Front: EnumValue = ...
    Left: EnumValue = ...
    Perspective: EnumValue = ...
    Right: EnumValue = ...
    Top: EnumValue = ...
    UV: EnumValue = ...

class viewportColorScheme:
    """

    hou.viewportColorScheme

    Viewport Color Schemes

    List of available color schemes for the viewport.

    VALUES


        hou.viewportColorScheme.Dark
            Solid black backaground.

        hou.viewportColorScheme.Grey
            Solid grey background.

        hou.viewportColorScheme.Light
            Light blue gradient background.

        hou.viewportColorScheme.DarkGrey
            Light blue gradient background.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Dark: EnumValue = ...
    DarkGrey: EnumValue = ...
    Grey: EnumValue = ...
    Light: EnumValue = ...

class viewportParticleDisplay:
    """

    hou.viewportParticleDisplay

    Viewport display option for particle display visualization.

    Specifies the visualization for particles and points in the viewport.

    VALUES


        Points
            Fixed size points in screen space.

        Lines
            Points with streaks indicating velocity.

        Pixels
            Single pixel particle (fixed size)

        Discs
            Circular disc, variable world size.

        Spheres
            Spheres which have material assignments and lighting, variable
            world size.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Discs: EnumValue = ...
    Lines: EnumValue = ...
    Pixels: EnumValue = ...
    Points: EnumValue = ...
    Spheres: EnumValue = ...

class viewportStandInGeometry:
    """

    hou.viewportStandInGeometry

    Replacement geometry for instances culled in the viewport.

    When using point instancing, instances can be culled because of the
    Point Instancing Percent, or the Instancing Limit display options.
    Culled instances can be replaced by a marker or bounding box, or
    completely hidden.

    VALUES


        DisplayOff
            Don't show anything for culled instances.

        LocationMarker
            Show a point marker at the local space origin of the instance.

        BoundingBox
            Show the bounding box of the culled instance.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    BoundingBox: EnumValue = ...
    DisplayOff: EnumValue = ...
    LocationMarker: EnumValue = ...

class viewportLighting:
    """

    hou.viewportLighting

    Lighting modes for the viewport

    The viewport renderer supports several global lighting modes, from no
    lighting whatsoever to full lighting with shadows.

    VALUES


        hou.viewportLighting.Off
            No lighting, constant shaded.

        hou.viewportLighting.Headlight
            Basic lighting from a single directional light defined in the
            display options.

        hou.viewportLighting.Normal
            Good quality lighting from up to 10 basic lights (area lights
            modeled as point lights, limited environment lights).

        hou.viewportLighting.HighQuality
            High quality lighting from an unlimited number of lights
            including area, geometry, environment and ambient occlusion.

        hou.viewportLighting.HighQualityWithShadows
            High quality lighting with shadows.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Headlight: EnumValue = ...
    HighQuality: EnumValue = ...
    HighQualityWithShadows: EnumValue = ...
    Normal: EnumValue = ...
    Off: EnumValue = ...

class viewportWorkLight:
    """

    hou.viewportWorkLight

    Work light type for the viewer

    Choices for work lights in the viewer, which override the user-defined
    lights for specific lighting conditions.

    VALUES


        hou.viewportWorkLight.Headlight
            The over-the-shoulder single distant light.

        hou.viewportWorkLight.Domelight
            Environment light with optional file map.

        hou.viewportWorkLight.PhysicalSky
            Sun and sky map lighting based on sun position and atmospheric
            parameters.

        hou.viewportWorkLight.ThreePoint
            Three distant lights arranged in a common three-point lighting
            setup.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Domelight: EnumValue = ...
    Headlight: EnumValue = ...
    PhysicalSky: EnumValue = ...
    ThreePoint: EnumValue = ...

class viewportTransparency:
    """

    hou.viewportTransparency

    Transparency rendering quality for the viewport

    Quality levels for rendering objects with transparency in the viewport.

    VALUES


        hou.viewportTransparency.Cutout
            Fast test to render the transparent pixel as opaque (>0) or to
            discard it (0). This can be used for texture cards such as
            leaves. This doesn't require an additional pass for
            transparency.

        hou.viewportTransparency.Low
            Render transparent pixels in a separate pass. Only the front-
            most transparent pixel is rendered.

        hou.viewportTransparency.Medium
            Render transparent pixels in an Order-Independent buffer of 8
            samples, which is then sorted and composited together to do
            multi-layer transparency for up to 8 layers of overlapping
            transparency.

        hou.viewportTransparency.High
            Render transparent pixels in an Order-Independent buffer of 16
            samples, which is then sorted and composited together to do
            multi-layer transparency for up to 16 layers of overlapping
            transparency.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Cutout: EnumValue = ...
    High: EnumValue = ...
    Low: EnumValue = ...
    Medium: EnumValue = ...

class viewportShadowQuality:
    """

    hou.viewportShadowQuality

    The quality of shadows produced in the viewport

    The viewport renderer can do various amounts of shadowmap sampling to
    produce a higher quality result.

    VALUES


        hou.viewportShadowQuality.Point
            Area lights are treated as point lights when generating and
            sampling shadow maps. This is the fastest option.

        hou.viewportShadowQuality.PointAA
            Do some antialiasing of shadow edges. Treat area lights as point
            lights when generating and sampling shadow maps.

        hou.viewportShadowQuality.Area
            Area lights generate multiple shadow maps which are sampled to
            generate an approximation of a blurred shadow from an area
            source.

        hou.viewportShadowQuality.AreaAA
            Area lights generate multiple maps and antialias the shadow
            lookups.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Area: EnumValue = ...
    AreaAA: EnumValue = ...
    Point: EnumValue = ...
    PointAA: EnumValue = ...

class viewportDOFBokeh:
    """

    hou.viewportDOFBokeh

    Viewport Depth of Field Bokeh Shape

    Defines the shape of the depth of field bokeh in the viewport.

    VALUES


        hou.viewportDOFBokeh.NoBokeh
            No extra bokeh effect.

        hou.viewportDOFBokeh.Circular
            Circular or oval bokeh.

        hou.viewportDOFBokeh.Texture
            Shape defined by a texture (image file or COP).


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Circular: EnumValue = ...
    NoBokeh: EnumValue = ...
    Texture: EnumValue = ...

class viewportFogHeightMode:
    """

    hou.viewportFogHeightMode

    Viewport fog layer modes

    Defines the types of fog layering available for viewport fog.

    VALUES


        hou.viewportFogHeightMode.Off
            No layering; fog is the same density regardless of height.

        hou.viewportFogHeightMode.Above
            Fog exists only above a given height.

        hou.viewportFogHeightMode.Below
            Fog exists only below a given height.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Above: EnumValue = ...
    Below: EnumValue = ...
    Off: EnumValue = ...

class viewportFogQuality:
    """

    hou.viewportFogQuality

    Viewport volume fog quality

    Defines the quality settings for volumetric fog in the viewport.

    VALUES


        hou.viewportFogQuality.Low
            Uses a small volume for fog lighting. Fast but low quality.

        hou.viewportFogQuality.Medium
            Uses a bigger volume for fog lighting. Balanced between quality
            and speed.

        hou.viewportFogQuality.High
            Uses a large volume for fog lighting. Slow but good quality.

        hou.viewportFogQuality.VeryHigh
            Uses a large volume for fog lighting. Slowest but best quality.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    High: EnumValue = ...
    Low: EnumValue = ...
    Medium: EnumValue = ...
    VeryHigh: EnumValue = ...

class viewportMaterialUpdate:
    """

    hou.viewportMaterialUpdate

    Enum for the update frequency of viewport material assignments

    When material assignments are re-evaluated for a displayed object.

    VALUES


        hou.viewportMaterialUpdate.Always
            Update assignments whenever needeed.

        hou.viewportMaterialUpdate.Manual
            Only update assignments when Update Materials is pressed.

        hou.viewportMaterialUpdate.OffForPlayback
            Update assignments whenever needed, but not during playback.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Always: EnumValue = ...
    Manual: EnumValue = ...
    OffForPlayback: EnumValue = ...

class viewportAgentBoneDeform:
    """

    hou.viewportAgentBoneDeform

    Enum for deforming agent quality

    Defines the quality vs. performance tradeoff for deforming agent
    geometry.

    VALUES


        hou.viewportAgentBoneDeform.Always
            Only use 1 bone to deform on all agent instances (the one with
            the most influence).

        hou.viewportAgentBoneDeform.Disabled
            Use up to 4 bones to deform the highest LOD agent instances, and
            1 bone on all the reduced LOD instances.

        hou.viewportAgentBoneDeform.ReducedLOD
            Use up to 4 bones to deform on all agent instances.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Always: EnumValue = ...
    Disabled: EnumValue = ...
    ReducedLOD: EnumValue = ...

class viewportAgentWireframe:
    """

    hou.viewportAgentWireframe

    Enum for agent wireframe mode display

    The look of agents in wireframe mode.

    VALUES


        hou.viewportAgentWireframe.Bone
            Agents are rendered as bone-based skeletons.

        hou.viewportAgentWireframe.Line
            Agents are rendered as line-based skeletons.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Bone: EnumValue = ...
    Line: EnumValue = ...

class viewportPackedBoxMode:
    """

    hou.viewportPackedBoxMode

    Enum for the culled packed geometry display mode.

    Defines how culled packed primitives are displayed in the viewport.

    VALUES


        hou.viewportPackedBoxMode.NoDisplay
            Culled packed primitives are not displayed at all.

        hou.viewportPackedBoxMode.Wireframe
            A wireframe bounding box replaces the packed primitive.

        hou.viewportPackedBoxMode.Shaded
            A shaded bounding box replaces the packed primitive.

        hou.viewportPackedBoxMode.CurrentShadingMode
            A bounding box replaces the packed primitive, drawn wireframe in
            wireframe shading modes and shaded otherwise.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CurrentShadingMode: EnumValue = ...
    NoDisplay: EnumValue = ...
    Shaded: EnumValue = ...
    Wireframe: EnumValue = ...

class viewportGridRuler:
    """

    hou.viewportGridRuler

    Enum for grid numbering on viewport grids.

    Specifies where the grid numbering occurs on viewport grids.

    VALUES


        hou.viewportGridRuler.Hide
            No grid numbers are displayed.

        hou.viewportGridRuler.MainAxis
            Numbers appear along the max axes at grid line intersections.

        hou.viewportGridRuler.GridPoints
            Numbers appear at grid line intersections.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    GridPoints: EnumValue = ...
    Hide: EnumValue = ...
    MainAxis: EnumValue = ...

class viewportTextureDepth:
    """

    hou.viewportTextureDepth

    Enum for the viewport texture bit depth limit

    Specifies the maximum bit depth that can be used for textures in the
    viewport.

    VALUES


        hou.viewportTextureDepth.Compressed8
            Compressed, 8b SDR texture format. Smallest memory use.

        hou.viewportTextureDepth.Fixed8
            8b SDR texture format. Good balance between memory and quality.

        hou.viewportTextureDepth.FullHDR
            16b HDR texture format. Excellent dynamic range, but more memory
            use and slower texturing performance.

        hou.viewportTextureDepth.HDR16
            32b HDR texture format. Extreme dynamic range, but very high
            memory use and slow texturing performance. Use with care.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Compressed8: EnumValue = ...
    Fixed8: EnumValue = ...
    FullHDR: EnumValue = ...
    HDR16: EnumValue = ...

class boundaryDisplay:
    """

    hou.boundaryDisplay

    Enum for viewport boundary overlay.

    Boundaries are used to show the edges of polygon mesh islands, for
    either position or UV coordinates.

    VALUES


        hou.boundaryDisplay.Off
            The boundary is disabled.

        hou.boundaryDisplay.View3D
            The boundary is shown in 3D viewports only.

        hou.boundaryDisplay.ViewUV
            The boundary is shown in UV viewports only.

        hou.boundaryDisplay.On
            The boundary is shown in all viewports.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Off: EnumValue = ...
    On: EnumValue = ...
    View3D: EnumValue = ...
    ViewUV: EnumValue = ...

class flipbookObjectType:
    """

    hou.flipbookObjectType

    Enum values for setting the flipbook's visible object types.

    Used by FlipbookSettings.visibleTypes() to set the visible object types
    when doing a flipbook.

    VALUES


        hou.flipbookObjectType.Visible
            All object types that are currently visible will be rendered.

        hou.flipbookObjectType.GeoOnly
            Only geometry objects will be rendered, which excludes bone,
            muscle, null, camera, light, and blend objects.

        hou.flipbookObjectType.GeoExcluded
            All object types other than Geometry that are currently visible
            will be rendered.

        hou.flipbookObjectType.AllObjects
            All object types will be rendered, even if their type is not
            currently visible.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AllObjects: EnumValue = ...
    GeoExcluded: EnumValue = ...
    GeoOnly: EnumValue = ...
    Visible: EnumValue = ...

class groupListType:
    """

    hou.groupListType

    Enumeration of group list types.

    VALUES


        Points
        Vertices
        Edges
        Breakpoints
        Primitives
        MatchPickType


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Breakpoints: EnumValue = ...
    Edges: EnumValue = ...
    MatchPickType: EnumValue = ...
    Points: EnumValue = ...
    Primitives: EnumValue = ...
    Vertices: EnumValue = ...

class geometryType:
    """

    hou.geometryType

    Enumeration of geometry component types.

    VALUES


        Points
        Vertices
        Edges
        Breakpoints
        Primitives


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Breakpoints: EnumValue = ...
    Edges: EnumValue = ...
    Points: EnumValue = ...
    Primitives: EnumValue = ...
    Vertices: EnumValue = ...

class connectivityType:
    """

    hou.connectivityType

    Enumeration of connectivity types.

    VALUES


        NoConnectivity
        Texture
        Position


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NoConnectivity: EnumValue = ...
    Position: EnumValue = ...
    Texture: EnumValue = ...

class severityType:
    """

    hou.severityType

    Enumeration of dialog message severities.

    VALUES


        Message
        ImportantMessage
        Warning
        Error
        Fatal


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Error: EnumValue = ...
    Fatal: EnumValue = ...
    ImportantMessage: EnumValue = ...
    Message: EnumValue = ...
    Warning: EnumValue = ...

class confirmType:
    """

    hou.confirmType

    Enumeration of confirmation dialog suppression options.

    VALUES


        NoConfirmType
        OverwriteFile
        UnlockNode
        DeleteSpareParameters
        DeleteWithoutReferences
        NestedChannelGroups
        SiblingChannelGroups
        DeleteShelfElement
        DeleteGalleryEntry
        InactiveSnapMode
        BackgroundSave
        LockMultiNode
        SaveEmbeddedDefinitions
        OCIOChangeReminder
        OCIOPackageExists
        OverwriteRecipe
        TopCookSave
        TopDeleteResults
        TopDeleteTempDir
        TopHotKeyCancelCook
        TopViewResults
        TopTerminateRemoteSession


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    BackgroundSave: EnumValue = ...
    DeleteGalleryEntry: EnumValue = ...
    DeleteShelfElement: EnumValue = ...
    DeleteSpareParameters: EnumValue = ...
    DeleteWithoutReferences: EnumValue = ...
    InactiveSnapMode: EnumValue = ...
    LockMultiNode: EnumValue = ...
    NestedChannelGroups: EnumValue = ...
    NoConfirmType: EnumValue = ...
    OCIOChangeReminder: EnumValue = ...
    OCIOPackageExists: EnumValue = ...
    OverwriteFile: EnumValue = ...
    OverwriteRecipe: EnumValue = ...
    SaveEmbeddedDefinitions: EnumValue = ...
    SiblingChannelGroups: EnumValue = ...
    TopCookSave: EnumValue = ...
    TopDeleteResults: EnumValue = ...
    TopDeleteTempDir: EnumValue = ...
    TopHotKeyCancelCook: EnumValue = ...
    TopTerminateRemoteSession: EnumValue = ...
    TopViewResults: EnumValue = ...
    UnlockNode: EnumValue = ...

class positionType:
    """

    hou.positionType

    Enumeration of spaces.

    VALUES


        WorldSpace
        ViewportXY
        ViewportUV


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ViewportUV: EnumValue = ...
    ViewportXY: EnumValue = ...
    WorldSpace: EnumValue = ...

class componentLoopType:
    """

    hou.componentLoopType

    Enumeration of component loop types.

    VALUES


        Partial
            A partial loop connects the components provided in a path with
            each input component acting as a way-point on the path. The loop
            will always start with the first provided component and end with
            the last.

        Extended
            An extended loop is always created from just two components (or
            possibly one edge component). It finds a path between these two
            components, then extends that path at both ends. It extends each
            direction until it either hits a boundary in the geometry, or
            finds its way back to the existing path. Often the resulting
            path will neither start with the start component or end with the
            end component.

        Closed
            A closed loop is always created from just two components (or
            possibly one edge component). It always tries to find a path the
            goes from the starting component, passes through the end
            component, and then continues on looking for a path back to the
            starting component. The paths returned will generally both start
            and end with the starting component.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Closed: EnumValue = ...
    Extended: EnumValue = ...
    Partial: EnumValue = ...

class flipbookAntialias:
    """

    hou.flipbookAntialias

    Enum values for flipbook antialiasing settings.

    See hou.FlipbookSettings.antialias.

    VALUES


        UseViewportSetting
            Use the current viewport's antialiasing setting.

        Off
            No antialiasing.

        Fast
            Fast 2-sample antialiasing.

        Good
            4-sample antialiasing.

        HighQuality
            High-quality 8-sample antialiasing.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Fast: EnumValue = ...
    Good: EnumValue = ...
    HighQuality: EnumValue = ...
    Off: EnumValue = ...
    UseViewportSetting: EnumValue = ...

class flipbookMotionBlurBias:
    """

    hou.flipbookMotionBlurBias

    Enum values used to specify the motion blur subframe range.

    See hou.FlipbookSettings.motionBlurFrameRange.

    VALUES


        Centered
            Subframe range is centered around the currently rendering frame.

        Forward
            Subframe range begins at the currently rendering frame.

        Previous
            Subframe range ends at the currently rendering frame.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Centered: EnumValue = ...
    Forward: EnumValue = ...
    Previous: EnumValue = ...

class parameterInterfaceTabType:
    """

    hou.parameterInterfaceTabType

    Enum values for selecting a specific parameter source tab in the
    parameter interface dialog.

    See hou.ui.openParameterInterfaceDialog.

    VALUES


        ParameterTypes
            The tab that provides a flat list of all available parameter
            types.

        RenderProperties
            The Render Properties tab, containing options parameters for
            controlling object rendering.

        NodeProperties
            The Node Properties tab, which contains definitions for spare
            parameters commonly used on specific node types.

        NodeParameters
            The Node Parameters tab, which displays a tree view of the
            current hip file, and all parameters on all existing nodes.

        UsdProperties
            The USD Properties tab which lists the current USD stage, all
            concrete USD schemas, and custom properties for every supported
            USD property data type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NodeParameters: EnumValue = ...
    NodeProperties: EnumValue = ...
    ParameterTypes: EnumValue = ...
    RenderProperties: EnumValue = ...
    UsdProperties: EnumValue = ...

class shaderType:
    """

    hou.shaderType

    Enumeration of SHOP shader types.

    Each SHOP type defines a particular type of shader. For example, it
    might be a surface shader or a displacement shader. This enumeration
    contains all the possible shader types.

    Use hou.ShopNodeType.shaderType to determine what type of shader a
    particular SHOP type is.

    VALUES


        Invalid
        Surface
        SurfaceShadow
        Displacement
        Geometry
        Interior
        Light
        LightShadow
        Atmosphere
        Lens
        Output
        Background
        Photon
        Image3D
        BSDF
        CVEX
        Mutable
        Properties
        Material
        VopMaterial
        ShaderClass


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Atmosphere: EnumValue = ...
    BSDF: EnumValue = ...
    Background: EnumValue = ...
    CVEX: EnumValue = ...
    Displacement: EnumValue = ...
    Geometry: EnumValue = ...
    Image3D: EnumValue = ...
    Interior: EnumValue = ...
    Invalid: EnumValue = ...
    Lens: EnumValue = ...
    Light: EnumValue = ...
    LightShadow: EnumValue = ...
    Material: EnumValue = ...
    Mutable: EnumValue = ...
    Output: EnumValue = ...
    Photon: EnumValue = ...
    Properties: EnumValue = ...
    ShaderClass: EnumValue = ...
    Surface: EnumValue = ...
    SurfaceShadow: EnumValue = ...
    VopMaterial: EnumValue = ...

class rampBasis:
    """

    hou.rampBasis

    Enumeration of ramp interpolation types.

    These interpolation types specify how Houdini interpolates between
    keyframed values in a hou.Ramp. See hou.Ramp.basis and hou.Ramp.__init__
    for more information about how to get and set ramp interpolation types.

    VALUES


        Linear
            Does a linear (straight line) interpolation between keys.

        Constant
            Holds the value constant until the next key.

        CatmullRom
            Interpolates smoothly between the keys. See Catmull-Rom_spline.

        MonotoneCubic
            Another smooth interpolation that ensures that there is no
            overshoot. For example, if a key's value is smaller than the
            values in the adjacent keys, this type ensures that the
            interpolated value is never less than the key's value.

        Bezier
            Cubic Bezier curve that interpolates every third control point
            and uses the other points to shape the curve. See Bezier curve.

        BSpline
            Cubic curve where the control points influence the shape of the
            curve locally (that is, they influence only a section of the
            curve). See B-Spline.

        Hermite
            Cubic Hermite curve that interpolates the odd control points,
            while even control points control the tangent at the previous
            interpolation point. See Hermite spline.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    BSpline: EnumValue = ...
    Bezier: EnumValue = ...
    CatmullRom: EnumValue = ...
    Constant: EnumValue = ...
    Hermite: EnumValue = ...
    Linear: EnumValue = ...
    MonotoneCubic: EnumValue = ...

class rampParmType:
    """

    hou.rampParmType

    Enumeration of ramp types.

    VALUES


        Color
        Float

    :

      * hou.RampParmTemplate


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Color: EnumValue = ...
    Float: EnumValue = ...

class colorType:
    """

    hou.colorType

    Enumeration of color spaces.

    VALUES


        RGB
            The red green blue color model.

        HSV
            The hue saturation value color model.

        HSL
            The hue saturation lightness color model.

        LAB
            The CIE L* a* b* color space model.

        XYZ
            The CIE XYZ color space model.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    HSL: EnumValue = ...
    HSV: EnumValue = ...
    LAB: EnumValue = ...
    RGB: EnumValue = ...
    XYZ: EnumValue = ...

class nodeTypeSource:
    """

    hou.nodeTypeSource

    Enumeration of node type sources.

    VALUES


        Internal
        CompiledCode
        VexCode
        RslCode
        Subnet


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CompiledCode: EnumValue = ...
    Internal: EnumValue = ...
    RslCode: EnumValue = ...
    Subnet: EnumValue = ...
    VexCode: EnumValue = ...

class fieldType:
    """

    hou.fieldType

    Enumeration of field types.

    VALUES


        NoSuchField
        Integer
        Boolean
        Float
        String
        Dict
        Vector2
        Vector3
        Vector4
        Quaternion
        Matrix3
        Matrix4
        UV
        UVW
        IntArray
        FloatArray
        DictArray


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Boolean: EnumValue = ...
    Dict: EnumValue = ...
    DictArray: EnumValue = ...
    Float: EnumValue = ...
    FloatArray: EnumValue = ...
    IntArray: EnumValue = ...
    Integer: EnumValue = ...
    Matrix3: EnumValue = ...
    Matrix4: EnumValue = ...
    NoSuchField: EnumValue = ...
    Quaternion: EnumValue = ...
    String: EnumValue = ...
    UV: EnumValue = ...
    UVW: EnumValue = ...
    Vector2: EnumValue = ...
    Vector3: EnumValue = ...
    Vector4: EnumValue = ...

class renderMethod:
    """

    hou.renderMethod

    Enumeration of dependency rendering methods.

    VALUES


        RopByRop
        FrameByFrame


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    FrameByFrame: EnumValue = ...
    RopByRop: EnumValue = ...

class updateMode:
    """

    hou.updateMode

    Enumeration of interface update modes.

    See hou.updateModeSetting.

    VALUES


        AutoUpdate
        OnMouseUp
        Manual


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AutoUpdate: EnumValue = ...
    Manual: EnumValue = ...
    OnMouseUp: EnumValue = ...

class licenseCategoryType:
    """

    hou.licenseCategoryType

    Enumeration of license category values.

    VALUES


        Commercial
        Indie
        Education
        ApprenticeHD
        Apprentice


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Apprentice: EnumValue = ...
    ApprenticeHD: EnumValue = ...
    Commercial: EnumValue = ...
    Education: EnumValue = ...
    Indie: EnumValue = ...

class hdaLicenseType:
    """

    hou.hdaLicenseType

    Enumeration of digital asset license permission levels.

    VALUES


        Execute
        Read
        Full


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Execute: EnumValue = ...
    Full: EnumValue = ...
    Read: EnumValue = ...

class orientUpAxis:
    """

    hou.orientUpAxis

    Enumeration of global orientation mode.

    See hou.ui.orientationUpAxis for more information.

    VALUES


        Y
        Z


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Y: EnumValue = ...
    Z: EnumValue = ...

class handleOrientToNormalAxis:
    """

    hou.handleOrientToNormalAxis

    Enumeration of handle axes that can be aligned to a geometry normal.

    See hou.ui.handleOrientToNormalAxis for more information.

    VALUES


        Y
        Z


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Y: EnumValue = ...
    Z: EnumValue = ...

class nodeEventType:
    """

    hou.nodeEventType

    Enumeration of types of events that can happen to nodes.

    Node event callbacks let you run code when events occur on an individual
    node instance. See hou.OpNode.addEventCallback.

    For all event types, the callback is called with a node keyword argument
    (containing a hou.OpNode reference to the node) and an event_type
    argument (containing one of the values below, indicating the type of
    event that occurred).

    Some event types pass additional keyword arguments to the callback
    function, as noted below.

    VALUES


        BeingDeleted
            Runs before a node is deleted. You cannot cancel the deletion.

        NameChanged
            Runs after a node was renamed. You can get the new name using
            hou.Node.name.

        FlagChanged
            Runs after one of the node's flags was turned on or off.

        AppearanceChanged
            Runs after the an event occurs that changes what the node looks
            like in the network editor. This includes but is not limited to:

          * Color or shape changed

          * Error triggered or cleared

          * Selected or deselected

          * Asset locked or unlocked

            Extra keyword argument: change_type (hou.appearanceChangeType)

        PositionChanged
            Runs after the node is moved in the network editor. You can get
            the node's new position using hou.Node.position.

        InputRewired
            Runs after one of the node's inputs are connected or
            disconnected.

            Extra keyword argument: input_index (int) -- the input number
            (starting at 0) that changed.

        InputDataChanged
            The data changed on an input node that this node depends on.
            Changes to an input node that is not used (due to a Switch node,
            for example) will not trigger this callback. Houdini also does
            not trigger this event when a node changes if that node's data
            or parameters are referenced through expressions. Only nodes
            connected to this node as an input will trigger this callback.

        ParmTupleChanged
            Runs after a parameter value changes. You can get the new value
            using hou.ParmTuple.eval.

            Extra keyword argument: parm_tuple (hou.ParmTuple).


            NOTE
                If many/all parameters on the node change at the same time,
                instead of calling the handler for each one, Houdini will
                call the handler once with a parm_tuple argument of None.
                Your callback code should handle this possibility.

        ParmTupleAnimated
            Runs after a parameter value changes from an undo/redo change or
            a major animation editor change. It isn't called during
            playback. You can get the new value using hou.ParmTuple.eval.

            Extra keyword argument: parm_tuple (hou.ParmTuple).


            NOTE
                If many/all parameters on the node change at the same time,
                instead of calling the handler for each one, Houdini will
                call the handler once with a parm_tuple argument of None.
                Your callback code should handle this possibility.

        ParmTupleChannelChanged
            Runs after a parameter value changes from a minor animation
            editor change. It isn't called during playback. You can get the
            new value using hou.ParmTuple.eval.

            Extra keyword argument: parm_tuple (hou.ParmTuple).


            NOTE
                If many/all parameters on the node change at the same time,
                instead of calling the handler for each one, Houdini will
                call the handler once with a parm_tuple argument of None.
                Your callback code should handle this possibility.

        ParmTupleLockChanged
            Runs after a parameter lock state has changed. You can get the
            new lock value using hou.Parm.isLocked.

            Extra keyword argument: parm_tuple (hou.ParmTuple).

        ParmTupleEnabledChanged
            Runs after a parameter enabled state has changed. You can get
            the new enabled state value using hou.Parm.isDisabled.

        ParmTupleVisibleChanged
            Runs after a parameter visible state has changed. You can get
            the new visibility value using hou.Parm.isHidden.

        ChildCreated
            For a subnet node (for example, a Geometry object), runs after a
            new node is created inside.

            Extra keyword argument: child_node (hou.OpNode)

        ChildDeleted
            For a subnet node (for example, a Geometry object), runs before
            a node is deleted inside. You cannot cancel the deletion.

            Extra keyword argument: child_node (hou.OpNode)

        ChildReordered
            For a subnet node (for example, a Geometry object), runs after
            the user-defined ordering changes for the nodes inside.

        ChildSwitched
            For a subnet node (for example, a Geometry object), runs after
            the current node, display flag, or render flag changes inside
            (meaning the 3D view will change).

            Extra keyword argument: child_node (hou.OpNode) -- the newly
            selected child node.

        ChildSelectionChanged
            For a subnet node (for example, a Geometry object), runs after
            the selection changes inside. The selection can consist of
            nodes, network boxes, sticky notes, indirect subnet inputs, or
            network dots. You can get the new selection with
            hou.Node.selectedItems.

        NetworkBoxCreated
            Runs after a new network box is created inside this node.

        NetworkBoxChanged
            Runs after an item is added to or removed from a network box
            inside this node. In some cases is may be possible to receive a
            NetworkBoxChanged callback for a new network box before
            receiving the NetworkBoxCreated callback.

        NetworkBoxDeleted
            Runs right before a network box is deleted from inside this
            node.

        StickyNoteCreated
            Runs after a new network box is created inside this node.

        StickyNoteChanged
            Runs after a new sticky note's text is changed inside this node.
            In some cases is may be possible to receive a StickyNoteChanged
            callback for a new network box before receiving the
            StickyNoteCreated callback.

        StickyNoteDeleted
            Runs right before a sticky note is deleted from inside this
            node.

        IndirectInputCreated
            Runs after a new indirect input is created inside this node.
            This will generally be a Network Dot, but may in some cases be a
            Subnet Indirect Input.

        IndirectInputRewired
            Runs after the input connection to an indirect input is changed.
            Since Subnet Indirect Inputs don't have input connections, this
            will only occur on a Network Dot.

        IndirectInputDeleted
            Runs before an indirect input is deleted from inside this node.
            This will generally be a Network Dot, but may in some cases be a
            Subnet Indirect Input.

        SpareParmTemplatesChanged
            Runs after a spare parameter is modified on, added to, or
            removed from the node.


            NOTE
                If the node has spare parameters, this event triggers when
                any parameter is modified, not just a spare parameter.

        SelectionChanged
            Runs after the selection associated with a node changes. This
            only applies to the geometry selected on a SOP node, or the
            scene graph primitives selected in a LOP Network.

        CustomDataChanged
            Runs after some custom data on a node is changed. The custom
            data available, and the methods for accessing it, will depend on
            the hou.NodeType of the node that is changing. One example of
            custom node data is the viewport scene overrides that can be
            applied to a LOP Network.

        WorkItemSelectionChanged
            For a TOP network, runs after the selected work item has a
            changed.

            Extra keyword argument: work_item_id - the ID of the selected
            work item

            Extra keyword argument: selected_node - the selected TOP node,
            if a selection exists


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AppearanceChanged: EnumValue = ...
    BeingDeleted: EnumValue = ...
    ChildCreated: EnumValue = ...
    ChildDeleted: EnumValue = ...
    ChildReordered: EnumValue = ...
    ChildSelectionChanged: EnumValue = ...
    ChildSwitched: EnumValue = ...
    CustomDataChanged: EnumValue = ...
    FlagChanged: EnumValue = ...
    IndirectInputCreated: EnumValue = ...
    IndirectInputDeleted: EnumValue = ...
    IndirectInputRewired: EnumValue = ...
    InputDataChanged: EnumValue = ...
    InputRewired: EnumValue = ...
    NameChanged: EnumValue = ...
    NetworkBoxChanged: EnumValue = ...
    NetworkBoxCreated: EnumValue = ...
    NetworkBoxDeleted: EnumValue = ...
    ParmTupleAnimated: EnumValue = ...
    ParmTupleChanged: EnumValue = ...
    ParmTupleChannelChanged: EnumValue = ...
    ParmTupleEnabledChanged: EnumValue = ...
    ParmTupleLockChanged: EnumValue = ...
    ParmTupleVisibleChanged: EnumValue = ...
    PositionChanged: EnumValue = ...
    SelectionChanged: EnumValue = ...
    SpareParmTemplatesChanged: EnumValue = ...
    StickyNoteChanged: EnumValue = ...
    StickyNoteCreated: EnumValue = ...
    StickyNoteDeleted: EnumValue = ...
    WorkItemSelectionChanged: EnumValue = ...

class hdaEventType:
    """

    hou.hdaEventType

    Enumeration of types of events that can happen for digital asset
    libraries.

    See hou.hda.addEventCallback.


    NOTE
        The AssetCreated and AssetDeleted events do not fire when a library
        file is installed or uninstalled.

    VALUES


        AssetCreated
            A new asset was created (using the Create Digital Asset context
            menu item in the network editor or through HOM).

            The callback function is called with this event type and the
            following additional argument:


            asset_definition
                An hou.HDADefinition object representing the newly created
                asset.

        AssetDeleted
            An asset was deleted (using the Asset Manager UI or through
            HOM). Note that the asset no longer exists when this event type
            occurs.

            The callback function is called with this event type and the
            following additional arguments:


            asset_name
                A string containing the name of the deleted asset.

            library_path
                A string containing the file path of the asset library
                (.hda) file that contained the asset.

            node_type_category
                A hou.NodeTypeCategory representing the type category (for
                example, Object, SOP, DOP) of the deleted asset.

        AssetSaved
            An asset was saved.

            The callback function is called with this event type and the
            following additional argument:


            asset_definition
                An hou.HDADefinition object representing the saved asset.

        BeforeAssetCreated
            A new asset is about to be created (using the Create Digital
            Asset context menu item in the network editor or through HOM).

            The callback function is called with this event type and the
            following additional argument:


            asset_name
                A string containing the name of the asset to be created.

            library_path
                A string containing the file path of the asset library
                (.hda) file that will contain the asset.

            node_type_category
                A hou.NodeTypeCategory representing the type category (for
                example, Object, SOP, DOP) of the asset to be created.

        BeforeAssetDeleted
            An asset is about to be deleted (using the Asset Manager UI or
            through HOM). Note that the asset still exists when this event
            occurs.

            The callback function is called with this event type and the
            following additional arguments:


            asset_definition
                An hou.HDADefinition object representing the asset to be
                deleted.

        BeforeAssetSaved
            An asset is about to be saved.

            The callback function is called with this event type and the
            following additional argument:


            asset_definition
                An hou.HDADefinition object representing the asset to be
                saved.

        LibraryInstalled
            A digital asset library has been installed into the current
            Houdini session.

            The callback function is called with this event type and the
            following additional argument:


            library_path
                The file path to the installed asset library (.hda) file.

        LibraryUninstalled
            A digital asset library has been uninstalled from the current
            Houdini session.

            The callback function is called with this event type and the
            following additional argument:


            library_path
                The file path to the uninstalled asset library (.hda) file.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AssetCreated: EnumValue = ...
    AssetDeleted: EnumValue = ...
    AssetSaved: EnumValue = ...
    BeforeAssetCreated: EnumValue = ...
    BeforeAssetDeleted: EnumValue = ...
    BeforeAssetSaved: EnumValue = ...
    LibraryInstalled: EnumValue = ...
    LibraryUninstalled: EnumValue = ...

class hipFileEventType:
    """

    hou.hipFileEventType

    Enumeration of the hip file event types that can be handled by callback
    functions.

    See hou.hipFile.addEventCallback.

    VALUES


        BeforeClear
            This event is triggered immediately before the current .hip file
            is cleared. For example, when selecting File -> New in the main
            menu bar.

        AfterClear
            This event is triggered immediately after the current .hip file
            is cleared. For example, when selecting File -> New in the main
            menu bar.

        BeforeLoad
            This event is triggered immediately before a .hip file is loaded
            into Houdini.

        AfterLoad
            This event is triggered immediately after a .hip file is loaded
            into Houdini.

        BeforeMerge
            This event is triggered immediately before a .hip file is merged
            into the current Houdini session.

        AfterMerge
            This event is triggered immediately after a .hip file is merged
            into the current Houdini session.

        BeforeSave
            This event is triggered immediately before the current .hip file
            is saved.

        AfterSave
            This event is triggered immediately after the current .hip file
            is saved.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AfterClear: EnumValue = ...
    AfterLoad: EnumValue = ...
    AfterMerge: EnumValue = ...
    AfterSave: EnumValue = ...
    BeforeClear: EnumValue = ...
    BeforeLoad: EnumValue = ...
    BeforeMerge: EnumValue = ...
    BeforeSave: EnumValue = ...

class appearanceChangeType:
    """

    hou.appearanceChangeType

    Enumeration of types of appearance change events that can happen to
    nodes.

    See hou.OpNode.addEventCallback.

    VALUES


        Any
        ErrorState
        Pick
        Color
        DeleteScript
        Comment
        LockFlag
        CompressFlag
        OTLMatchState
        ActiveInput
        Connections
        ExpressionLanguage
        NetworkBox
        PostIt
        Dot
        Preview


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ActiveInput: EnumValue = ...
    Any: EnumValue = ...
    Color: EnumValue = ...
    Comment: EnumValue = ...
    CompressFlag: EnumValue = ...
    Connections: EnumValue = ...
    DeleteScript: EnumValue = ...
    Dot: EnumValue = ...
    ErrorState: EnumValue = ...
    ExpressionLanguage: EnumValue = ...
    LockFlag: EnumValue = ...
    NetworkBox: EnumValue = ...
    OTLMatchState: EnumValue = ...
    Pick: EnumValue = ...
    PostIt: EnumValue = ...
    Preview: EnumValue = ...

class ropRenderEventType:
    """

    hou.ropRenderEventType

    Enumeration of types of events that can happen when a ROP node is
    rendering.

    ROP render event callbacks let you run code when a render events occur
    on an individual ROP node instance. See
    hou.RopNode.addRenderEventCallback.

    The event callback is called with the hou.RopNode that produced the
    event as the first argument, an enum value from this enum as the second
    argument, and the time value that event occured as the last argument.

    VALUES


        PreRender
            Runs exactly once, before the ROP node begins rendering.

        PreFrame
            Runs before each frame is rendered.

        PostFrame
            Runs after each frame finishes rendering.

        PostWrite
            Runs after output files for a frame have been written to disk.
            This is primarly used with nodes like the , which write output
            files in the background.

        PostRender
            Runs exactly once, after the ROP has finished rendering.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    PostFrame: EnumValue = ...
    PostRender: EnumValue = ...
    PostWrite: EnumValue = ...
    PreFrame: EnumValue = ...
    PreRender: EnumValue = ...

class imageDepth:
    """

    hou.imageDepth

    Enumeration of image depths (data formats) for representing the pixels
    in an image plane.

    See hou.Cop2Node.depth.

    VALUES


        Int8
        Int16
        Int32
        Float16
        Float32


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Float16: EnumValue = ...
    Float32: EnumValue = ...
    Int16: EnumValue = ...
    Int32: EnumValue = ...
    Int8: EnumValue = ...

class imageLayerTypeInfo:
    """

    hou.imageLayerTypeInfo

    Enumeration of ImageLayer TypeInfos

    These represent various semantic intepretations of the underlying layer
    data. A 3-tuple may represent things other than RGB.

    VALUES


        hou.imageLayerTypeInfo.Color
            The data is to be interpeted as RGB.

        hou.imageLayerTypeInfo.Height
            The data is to be interpeted as a height map. These are usually
            Mono.

        hou.imageLayerTypeInfo.ID
            The data is to be interpeted as an ID map. These are usually ID.

        hou.imageLayerTypeInfo.Mask
            The data is to be interpeted as 0-1 mask. These are usually
            Mono.

        hou.imageLayerTypeInfo.Normal
            The data is to be interpeted as signed normal. These are usually
            RGB. The data is usually -1 to 1 and normalized.

        hou.imageLayerTypeInfo.OffsetNormal
            The data is to be interpreted as an offset normal. These are
            usually RGB. The data is usually 0 to 1 and normalized around
            0.5.

        hou.imageLayerTypeInfo.Position
            The data is to be interpreted as an XYZ location. For 3-tuples
            this is a location in space, for 2-tuples it usually implies it
            is in Image space. These are usually UV or RGB.

        hou.imageLayerTypeInfo.Raw
            The data is not to be interpreted, no specific type hint is
            present.

        hou.imageLayerTypeInfo.SDF
            The data stores the signed distance to a curve. These are
            usually Mono.

        hou.imageLayerTypeInfo.Texture
            The data is to be interpreted as an UV location. For 2-tuples it
            usually implies it is in Texture space. These are usually UV.

        hou.imageLayerTypeInfo.Vector
            The data is to be interpreted as a direction whose length is the
            magnitude or stretngth. These are usually UV or RGB.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Color: EnumValue = ...
    Height: EnumValue = ...
    ID: EnumValue = ...
    Mask: EnumValue = ...
    Normal: EnumValue = ...
    OffsetNormal: EnumValue = ...
    Position: EnumValue = ...
    Raw: EnumValue = ...
    SDF: EnumValue = ...
    Texture: EnumValue = ...
    Vector: EnumValue = ...

class imageLayerBorder:
    """

    hou.imageLayerBorder

    Enumeration of ImageLayer Borders

    These control how a layer treates attempts to read outside of its
    defined buffer.

    VALUES


        hou.imageLayerBorder.Clamp
            The location is clamped to the nearest valid location in the
            buffer and that value used.

        hou.imageLayerBorder.Constant
            A constant value, usually 0, is used if out of bound values are
            read. Note this will cause interpolation to black near the
            borders.

        hou.imageLayerBorder.Mirror
            Attempts to read outside are reflected across the border to find
            a valid internal location.

        hou.imageLayerBorder.Wrap
            Attempts to read outside will wrap around to the far side.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Clamp: EnumValue = ...
    Constant: EnumValue = ...
    Mirror: EnumValue = ...
    Wrap: EnumValue = ...

class imageLayerStorageType:
    """

    hou.imageLayerStorageType

    Enumeration of ImageLayer StorageTypes

    These store how the pixel values are stored in memory.

    VALUES


        hou.imageLayerStorageType.Float16
            Values are stored in 16-bit floats.

        hou.imageLayerStorageType.Float32
            Values are stored in 32-bit floats.

        hou.imageLayerStorageType.Int16
            Values are stored in 16-bit integers.

        hou.imageLayerStorageType.Int32
            Values are stored in 32-bit integers.

        hou.imageLayerStorageType.Int8
            Values are stored in 8-bit integers.

        hou.imageLayerStorageType.Fixed8
            Stores fractional values between 0 and 1 using 8 bits of fixed
            precision.

        hou.imageLayerStorageType.Fixed16
            Stores fractional values between 0 and 1 using 16 bits of fixed
            precision.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Fixed16: EnumValue = ...
    Fixed8: EnumValue = ...
    Float16: EnumValue = ...
    Float32: EnumValue = ...
    Int16: EnumValue = ...
    Int32: EnumValue = ...
    Int8: EnumValue = ...

class imageLayerProjection:
    """

    hou.imageLayerProjection

    Enumeration of ImageLayer Projections>

    These define the type of projection the camera defined by a layer uses.

    VALUES


        hou.imageLayerProjection.Orthographic
            The projection is an orthographic collapse along the local Z
            direction.

        hou.imageLayerProjection.Perspective
            The projection is a perspective transform focusing to the camera
            position.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Orthographic: EnumValue = ...
    Perspective: EnumValue = ...

class vdbType:
    """

    hou.vdbType

    Enumeration of VDB types

    See hou.VDB and hou.NanoVDB.

    VALUES


        Bool
        Double
        Float
        Int32
        Int64
        Invalid
        PointData
        PointIndex
        Vec3d
        Vec3f
        Vec3i


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Bool: EnumValue = ...
    Double: EnumValue = ...
    Float: EnumValue = ...
    Int32: EnumValue = ...
    Int64: EnumValue = ...
    Invalid: EnumValue = ...
    PointData: EnumValue = ...
    PointIndex: EnumValue = ...
    Vec3d: EnumValue = ...
    Vec3f: EnumValue = ...
    Vec3i: EnumValue = ...

class volumeStorageType:
    """

    hou.volumeStorageType

    Enumeration of Volume StorageTypes

    These store how the voxel values are stored in memory.

    VALUES


        hou.volumeStorageType.Float
            Values are stored as floats.

        hou.volumeStorageType.Int
            Values are stored as integers.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Float: EnumValue = ...
    Int: EnumValue = ...

class volumeVisualization:
    """

    hou.volumeVisualization

    Enumeration of Volume Visualization

    These store how the volume should be displayed in the viewport.

    VALUES


        hou.volumeVisualization.Smoke
            The volume is displayed as fog or smoke.

        hou.volumeVisualization.Rainbow
            The volume is displayed as fog, but the colour is based on
            relative location in the volume. This is deprecated.

        hou.volumeVisualization.Iso
            The zero-crossing of the volume is displayed as an iso-surface.
            This is used for SDF visualization.

        hou.volumeVisualization.Invisible
            The volume is not to be drawn in the viewport.

        hou.volumeVisualization.HeightField
            The volume is drawn as a heightfield. Note it should be a 2d
            volume with 1 resolution in Z.

        hou.volumeVisualization.Image
            The volume is drawn as an image. Note it should be a 2d volume
            with 1 resolution in Z.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    HeightField: EnumValue = ...
    Image: EnumValue = ...
    Invisible: EnumValue = ...
    Iso: EnumValue = ...
    Rainbow: EnumValue = ...
    Smoke: EnumValue = ...

class playMode:
    """

    hou.playMode

    Enumeration of play modes for the main playbar in Houdini.

    VALUES


        Loop
            Play through the frame range and when reaching the end of the
            range loop back to the beginning and continue the playback.

        Once
            Play through the frame range and when reaching the end of the
            range stop the playback.

        Zigzag
            Play through the frame range and when reaching the end of the
            range reverse the playback. When the reverse playback reaches
            the beginning of the range, then continue playback in the
            forward direction, etc.

        Forever
            Play through the frame range and when reaching the end of the
            range keep playing.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Forever: EnumValue = ...
    Loop: EnumValue = ...
    Once: EnumValue = ...
    Zigzag: EnumValue = ...

class playbarEvent:
    """

    hou.playbarEvent

    Enumeration of the playbar events that can be handled by callback
    functions.

    See hou.playbar.addEventCallback.

    VALUES


        Started
            This event is triggered when the playbar has started playback
            either in the forward or reverse direction.

        Stopped
            This event is triggered when running playback has stopped.

        FrameChanged
            This event is triggered when the playbar has changed to another
            frame and after the scene has been cooked for the new frame.

        GlobalFrameRangeChanged
            This event is triggered when the global frame range changes.

        PlaybackFrameRangeChanged
            This event is triggered when the playback range changes.

        ChannelListChanged
            This event is triggered when channels are added or removed from
            the Channel List.

        ScrubStarted
            This event is triggered when a new scrub is started such as when
            pressing the mouse down on the playbar.

        ScrubStopped
            This event is triggered when a scrub is finished such as when
            releasing the mouse after dragging on the playbar.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ChannelListChanged: EnumValue = ...
    FrameChanged: EnumValue = ...
    GlobalFrameRangeChanged: EnumValue = ...
    PlaybackFrameRangeChanged: EnumValue = ...
    ScrubStarted: EnumValue = ...
    ScrubStopped: EnumValue = ...
    Started: EnumValue = ...
    Stopped: EnumValue = ...

class channelListChangedReason:
    """

    hou.channelListChangedReason

    Enumeration of the reasons the hou.playbarEvent.ChannelListChanged event
    can be triggered.

    See the onPlaybackChangeEvent viewer state method.

    VALUES


        Replaced
            Triggered when the channel list has been fully replaced.

        Filtered
            Triggered when the channel list has been filtered.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Filtered: EnumValue = ...
    Replaced: EnumValue = ...

class bookmarkEvent:
    """

    hou.bookmarkEvent

    Enumeration of the bookmark events that can be handled by callback
    functions.

    See hou.playbar.addBookmarksChangedCallback.

    VALUES


        Created
            This event is triggered when a new bookmark has been created.

        Modified
            This event is triggered when a bookmark has been modified.

        Deleted
            This event is triggered when a bookmark has been deleted.

        Reset
            This event is triggered when the list of bookmarks has been
            reset or cleared, such as when loading a new set of bookmarks
            from a file.

        InteractionStarted
            This event is triggered when a new user interaction begins on a
            bookmark, such as dragging it.

        InteractionFinished
            This event is triggered when releasing the bookmark after
            interacting with it.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Created: EnumValue = ...
    Deleted: EnumValue = ...
    InteractionFinished: EnumValue = ...
    InteractionStarted: EnumValue = ...
    Modified: EnumValue = ...
    Reset: EnumValue = ...

class perfMonTimeFormat:
    """

    hou.perfMonTimeFormat

    Enumeration of the different formats used when viewing times in the
    Performance Monitor panetab.

    VALUES


        Absolute
        Percent


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Absolute: EnumValue = ...
    Percent: EnumValue = ...

class perfMonTimeUnit:
    """

    hou.perfMonTimeUnit

    Enumeration of the different units used when viewing times in the
    Performance Monitor panetab.

    VALUES


        Seconds
            Display times in seconds.

        Milliseconds
            Display times in milliseconds.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Milliseconds: EnumValue = ...
    Seconds: EnumValue = ...

class perfMonObjectView:
    """

    hou.perfMonObjectView

    Enumeration of the different structures that are used to view objects in
    the Performance Monitor panetab.

    VALUES


        List
        Tree
        EventLog


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    EventLog: EnumValue = ...
    List: EnumValue = ...
    Tree: EnumValue = ...

class compressionType:
    """

    hou.compressionType

    Enumeration of compression types.

    VALUES


        Gzip
            Compress using Gzip.

        Blosc
            Compress using Blosc.

        NoCompression
            Do not compress.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Blosc: EnumValue = ...
    Gzip: EnumValue = ...
    NoCompression: EnumValue = ...

class nodeTypeFilter:
    """

    hou.nodeTypeFilter

    Enumeration of available node type filters.

    These filters are used by node bundles to limit the nodes in the bundle
    based on type.

    VALUES


        NoFilter
            Any node

        Sop
            Any SOP

        Dop
            Any DOP

        Chop
            Any CHOP

        Chopnet
            Any CHOP Network

        Cop2
            Any COP2

        Copnet
            Any COP2 Network

        Vop
            Any VOP

        Vopnet
            Any VOP Network

        Rop
            Any ROP

        Lop
            Any LOP

        Top
            Any TOP

        Shop
            Any SHOP

        Obj
            Any Object

        ObjBone
            Object: Bone Only

        ObjCamera
            Object: Camera Only

        ObjFog
            Object: Fog Only

        ObjGeometry
            Object: Geometry Only

        ObjGeometryOrFog
            Object: Geometry and Fog Only

        ObjLight
            Object: Light Only

        ObjMuscle
            Object: Muscle Only

        ObjSubnet
            Object: Muscle Only

        ShopAtmosphere
            Shop: Atmosphere Only

        ShopCVEX
            Shop: CVEX Only

        ShopDisplacement
            Shop: Displacement Only

        ShopImage3D
            Shop: Image3D Only

        ShopInterior
            Shop: Interior Only

        ShopLight
            Shop: Light Only

        ShopLightShadow
            Shop: Light Shadow Only

        ShopMaterial
            Shop: Material Only

        ShopPhoton
            Shop: Photon Only

        ShopProperties
            Shop: Properties Only

        ShopSurface
            Shop: Surface Only

        TopScheduler
            Top: Schedulers Only

        TopPartitioner
            Top: Partitioners Only

        TopProcessor
            Top: Processors Only


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Chop: EnumValue = ...
    Chopnet: EnumValue = ...
    Cop2: EnumValue = ...
    Copnet: EnumValue = ...
    Dop: EnumValue = ...
    Lop: EnumValue = ...
    NoFilter: EnumValue = ...
    Obj: EnumValue = ...
    ObjBone: EnumValue = ...
    ObjCamera: EnumValue = ...
    ObjFog: EnumValue = ...
    ObjGeometry: EnumValue = ...
    ObjGeometryOrFog: EnumValue = ...
    ObjLight: EnumValue = ...
    ObjMuscle: EnumValue = ...
    ObjSubnet: EnumValue = ...
    Rop: EnumValue = ...
    Shop: EnumValue = ...
    ShopAtmosphere: EnumValue = ...
    ShopCVEX: EnumValue = ...
    ShopDisplacement: EnumValue = ...
    ShopImage3D: EnumValue = ...
    ShopInterior: EnumValue = ...
    ShopLight: EnumValue = ...
    ShopLightShadow: EnumValue = ...
    ShopMaterial: EnumValue = ...
    ShopPhoton: EnumValue = ...
    ShopProperties: EnumValue = ...
    ShopSurface: EnumValue = ...
    Sop: EnumValue = ...
    Top: EnumValue = ...
    TopPartitioner: EnumValue = ...
    TopProcessor: EnumValue = ...
    TopScheduler: EnumValue = ...
    Vop: EnumValue = ...
    Vopnet: EnumValue = ...

class vdbData:
    """

    hou.vdbData

    Enumeration of voxel data types.

    See hou.VDB.

    VALUES


        Boolean
        Float
        Int
        Vector3


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Boolean: EnumValue = ...
    Float: EnumValue = ...
    Int: EnumValue = ...
    Vector3: EnumValue = ...

class lopViewportOverridesLayer:
    """

    hou.lopViewportOverridesLayer

    Specifies a choice between the various pxr.Sdf.Layer objects available
    in a hou.LopViewportOverrides object.

    VALUES


        Base
        Selectable
        SoloLights
        SoloGeometry
        Purpose
        Expansion
        Custom


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Base: EnumValue = ...
    Custom: EnumValue = ...
    Expansion: EnumValue = ...
    Purpose: EnumValue = ...
    Selectable: EnumValue = ...
    SoloGeometry: EnumValue = ...
    SoloLights: EnumValue = ...

class channelEditorMode:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete

class vopParmGenType:
    """

    hou.vopParmGenType

    Enumeration of the different node configurations that can be created for
    the inputs of a VOP node.

    See hou.VopNode.insertParmGenerator and
    hou.VopNode.insertParmGeneratorsForAllInputs.

    VALUES


        Constant
            Create a Constant VOP and connect it to the VOP node's input.

        Parameter
            Create a Parameter VOP and connect it to the VOP node's input.
            The input parameter is automatically promoted to the VOP
            network's parameter interface.

        SubnetInput
            Create a Parameter VOP and connect it to the VOP node's input.
            Additionally set the Parameter VOP's Scope parameter to Subnet.
            The input parameter is automatically promoted to the owning
            Subnet VOP's parameter interface.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Constant: EnumValue = ...
    Parameter: EnumValue = ...
    SubnetInput: EnumValue = ...

class stateGenerateMode:
    """

    hou.stateGenerateMode

    Enumeration of possible node generation modes by states.

    See hou.SceneViewer.setCurrentState for more information.

    VALUES


        Insert
        Branch
        Enter


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Branch: EnumValue = ...
    Enter: EnumValue = ...
    Insert: EnumValue = ...

class scenePrimMask:
    """

    hou.scenePrimMask

    Scene Graph Selection Mask

    Defines the primitive types that can be selected by
    SceneViewer.selectSceneGraph() if the caller wishes to override the
    current scene viewer selection mask.

    VALUES


        hou.scenePrimMask.All
            All primitive types can be selected.

        hou.scenePrimMask.Camera
            Only camera primitive types can be selected.

        hou.scenePrimMask.Geometry
            Only geometry primitive types can be selected.

        hou.scenePrimMask.Light
            Only light primitive types can be selected.

        hou.scenePrimMask.LightAndCamera
            Only light and camera primitive types can be selected.

        hou.scenePrimMask.ViewerSetting
            Use the viewer setting for the primitive selection mask
            (default).


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    All: EnumValue = ...
    Camera: EnumValue = ...
    Geometry: EnumValue = ...
    Light: EnumValue = ...
    LightAndCamera: EnumValue = ...
    ViewerSetting: EnumValue = ...

class viewportVisualizerCategory:
    """

    hou.viewportVisualizerCategory

    Enumeration of the different categories of viewport visualizers.

    VALUES


        Common
            Viewport visualizers in the common category are available across
            all scene files.

        Scene
            Viewport visualizers in the scene category are saved to the
            scene file and are only available in the specific scene file in
            which they are created or saved.

        Node
            Node visualizers are installed on individual nodes in Houdini
            and have a limited scope.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Common: EnumValue = ...
    Node: EnumValue = ...
    Scene: EnumValue = ...

class viewportVisualizerScope:
    """

    hou.viewportVisualizerScope

    Enumeration of the different scopes of viewport visualizers.

    VALUES


        NodeOnly
            The visualizer affects only the geometry produced by the node on
            which it is installed. This value only applies to visualizers in
            the hou.viewportVisualizerCategory.Node category.

        SameNetworkTypeDescendents
            The visualizer affects only the geometries produced by the node
            and its descendent nodes of the same network type. This value
            only applies to visualizers in the
            hou.viewportVisualizerCategory.Node category.

        AllDescendents
            The visualizer affects the geometries produced by the node and
            its descendent nodes regardless of the network type. This value
            only applies to visualizers in the
            hou.viewportVisualizerCategory.Node category.

        Global
            The visualizer affects any geometry that is displayed in the
            viewport. This value only applies to visualizers in the
            hou.viewportVisualizerCategory.Common and
            hou.viewportVisualizerCategory.Scene categories.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AllDescendents: EnumValue = ...
    Global: EnumValue = ...
    NodeOnly: EnumValue = ...
    SameNetworkTypeDescendents: EnumValue = ...

class viewportVisualizerEventType:
    """

    hou.viewportVisualizerEventType

    Enumeration of types of events that can happen to viewport visualizers.

    Viewport visualizer callbacks let you run code when events occur on
    visualizers in individual categories. See
    hou.viewportVisualizers.addEventCallback.

    For all event types, the callback is called with an event_type keyword
    argument (containing one of the values below, indicating the type of
    event that occurred).

    Some event types pass additional keyword arguments to the callback
    function, as noted below.

    VALUES


        VisualizerCreated
            Runs after a new visualizer is created.

            Extra keyword argument: visualizer (hou.ViewportVisualizer)

        VisualizerDeleted
            Runs after a visualizer has been removed from a category, but
            before it has been deleted. You cannot cancel the deletion.

            Extra keyword argument: visualizer (hou.ViewportVisualizer)

        VisualizerMountChanged
            Runs after a visualizer setting related to its mount, like the
            name or the scope, has changed.

            Extra keyword argument: visualizer (hou.ViewportVisualizer)

        VisualizerParmsChanged
            Runs after a visualizer's parameters have changed.

            Extra keyword argument: visualizer (hou.ViewportVisualizer)

        VisualizerFlagsChanged
            Runs after a visualizer's flags have changed.

            Extra keyword argument: visualizer (hou.ViewportVisualizer)

        VisualizerActiveChanged
            Runs after a visualizer's active state has changed.

            Extra keyword argument: visualizer (hou.ViewportVisualizer)

        CategoryActiveChanged
            Runs after a visualizer category's active state has changed.

            Extra keyword argument: category
            (hou.ViewportVisualizerCategory) Extra keyword argument:
            category_node (hou.OpNode)

        CategoryDeleted
            Runs after a visualizer category has been destroyed.

            Extra keyword argument: category
            (hou.ViewportVisualizerCategory) Extra keyword argument:
            category_node (hou.OpNode)


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CategoryActiveChanged: EnumValue = ...
    CategoryDeleted: EnumValue = ...
    VisualizerActiveChanged: EnumValue = ...
    VisualizerCreated: EnumValue = ...
    VisualizerDeleted: EnumValue = ...
    VisualizerFlagsChanged: EnumValue = ...
    VisualizerMountChanged: EnumValue = ...
    VisualizerParmsChanged: EnumValue = ...

class nodeFlag:
    """

    hou.nodeFlag

    Enumeration of the different node flags.

    VALUES


        Audio
        Bypass
        ColorDefault
        Compress
        Current
        Debug
        Display
        DisplayComment
        DisplayDescriptiveName
        Export
        Expose
        Footprint
        Highlight
        InOutDetailLow
        InOutDetailMedium
        InOutDetailHigh
        Material
        Lock
        SoftLock
        Origin
        OutputForDisplay
        Pick
        Render
        Selectable
        Template
        Unload
        Visible
        XRay


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Audio: EnumValue = ...
    Bypass: EnumValue = ...
    ColorDefault: EnumValue = ...
    Compress: EnumValue = ...
    Current: EnumValue = ...
    Debug: EnumValue = ...
    Display: EnumValue = ...
    DisplayComment: EnumValue = ...
    DisplayDescriptiveName: EnumValue = ...
    Export: EnumValue = ...
    Expose: EnumValue = ...
    Footprint: EnumValue = ...
    Highlight: EnumValue = ...
    InOutDetailHigh: EnumValue = ...
    InOutDetailLow: EnumValue = ...
    InOutDetailMedium: EnumValue = ...
    Lock: EnumValue = ...
    Material: EnumValue = ...
    Origin: EnumValue = ...
    OutputForDisplay: EnumValue = ...
    Pick: EnumValue = ...
    Render: EnumValue = ...
    Selectable: EnumValue = ...
    SoftLock: EnumValue = ...
    Template: EnumValue = ...
    Unload: EnumValue = ...
    Visible: EnumValue = ...
    XRay: EnumValue = ...

class nodeFootprint:
    """

    hou.nodeFootprint

    Enumeration of the specialized node footprints supported by the network
    editor.

    These values can be used to initialize a hou.NetworkFootprint object to
    be passed to a hou.NetworkEditor object specifying which nodes should be
    drawn with footprint circles around them.

    VALUES


        InsertionPoint
            Draw a footprint around the LOP node that is currently set as
            the insertion point on the containing LOP Network.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    InsertionPoint: EnumValue = ...

class fbxCompatibilityMode:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    FBXStandard: EnumValue = ...
    Maya: EnumValue = ...

class fbxMaterialMode:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    FBXShaderNodes: EnumValue = ...
    PrincipledShaders: EnumValue = ...
    VopNetworks: EnumValue = ...

class saveMode:
    """

    hou.saveMode

    Enumeration of hip file save modes.

    VALUES


        Text
            Save in an ASCII format that is friendly to version control and
            can be viewed and edited as plain text. This format is
            compatible with Houdini 16 and above only and is only available
            with a full commercial license.

        Binary
            Traditional binary hip file format. This is both smaller and
            more performant than the text format.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Binary: EnumValue = ...
    Text: EnumValue = ...

class radialItemType:
    """

    hou.radialItemType

    Enumeration of types for radial menu items in Houdini.

    VALUES


        Script
            Specifies a script radial menu item.

        Submenu
            Specifies a submenu radial menu item.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Script: EnumValue = ...
    Submenu: EnumValue = ...

class radialItemLocation:
    """

    hou.radialItemLocation

    Enumeration of locations for radial menu items in Houdini.

    VALUES


        Top
            Specifies top location of a radial menu item.

        TopLeft
            Specifies top left location of a radial menu item.

        Left
            Specifies left location of a radial menu item.

        BottomLeft
            Specifies bottom left location of a radial menu item.

        Bottom
            Specifies bottom location of a radial menu item.

        BottomRight
            Specifies bottom right location of a radial menu item.

        Right
            Specifies right location of a radial menu item.

        TopRight
            Specifies top right location of a radial menu item.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Bottom: EnumValue = ...
    BottomLeft: EnumValue = ...
    BottomRight: EnumValue = ...
    Left: EnumValue = ...
    Right: EnumValue = ...
    Top: EnumValue = ...
    TopLeft: EnumValue = ...
    TopRight: EnumValue = ...

class valueLadderType:
    """

    hou.valueLadderType

    Enumeration of the different value ladder types.

    See hou.ui.openValueLadder.

    VALUES


        Generic
            The ladder is being used to manipulate a generic numeric value.
            The step sizes for this ladder type range from 0.0001 to 100.0.

        Angle
            The ladder is being used to manipulate a value representing an
            angle. The step sizes for this ladder type range from 1.0 to
            45.0.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Angle: EnumValue = ...
    Generic: EnumValue = ...

class valueLadderDataType:
    """

    hou.valueLadderDataType

    Enumeration of the different data types that may be manipulated by a
    value ladder.

    See hou.ui.openValueLadder.

    VALUES


        Float
            The ladder is being used to manipulate a single floating point
            value.

        Int
            The ladder is being used to manipulate a single integer value.

        FloatArray
            The ladder is being used to manipulate an array of floating
            point values.

        IntArray
            The ladder is being used to manipulate an array of integer
            values.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Float: EnumValue = ...
    FloatArray: EnumValue = ...
    Int: EnumValue = ...
    IntArray: EnumValue = ...

class promptMessageType:
    """

    hou.promptMessageType

    Viewport Prompt Message Type

    Defines the type of messages that can be used with
    hou.SceneViewer.setPromptMessage.

    VALUES


        hou.promptMessageType.Error
            Specifies an error message displayed in bold red.

        hou.promptMessageType.Message
            Specifies a regular message displayed in black.

        hou.promptMessageType.Prompt
            Specifies a prompt message displayed in bold blue.

        hou.promptMessageType.Warning
            Specifies a warning message displayed in bold yellow.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Error: EnumValue = ...
    Message: EnumValue = ...
    Prompt: EnumValue = ...
    Warning: EnumValue = ...

class drawableDisplayMode:
    """

    hou.drawableDisplayMode

    Enumerator for the drawable display mode.

    VALUES


        hou.drawableDisplayMode.CurrentViewportMode
            Specifies the display mode currently active in the viewport.

        hou.drawableDisplayMode.WireframeMode
            Specifies the display mode as wireframe.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CurrentViewportMode: EnumValue = ...
    WireframeMode: EnumValue = ...

class scaleInheritanceMode:
    """

    hou.scaleInheritanceMode

    Enumeration of scale inheritance modes for transforms.

    VALUES


        Default
            Simple inheritance: world = local * parent_world

        OffsetOnly
            Child doesn't scale with the parent local scales, but local
            translation is scaled: world = local_scale_rotates *
            parent_local_scales.inverted() * local_translates * parent_world

        OffsetAndScale
            Local translation is scaled as before but parent local scaling
            is also reapplied by the child in local space: world =
            parent_local_scales * local_scale_rotates *
            parent_local_scales.inverted() * local_translates * parent_world

        ScaleOnly
            Local translation is not scaled, but parent local scaling is
            reapplied by the child in local space: world =
            parent_local_scales * local * parent_local_scales.inverted() *
            parent_world

        Ignore
            Child completely ignores any parent local scaling: world = local
            * parent_local_scales.inverted() * parent_world


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Default: EnumValue = ...
    Ignore: EnumValue = ...
    OffsetAndScale: EnumValue = ...
    OffsetOnly: EnumValue = ...
    ScaleOnly: EnumValue = ...

class uiEventValueType:
    """

    hou.uiEventValueType

    Enumerator for UI event value types.

    Represents the type of value stored in a hou.UIEvent object.

    VALUES


        hou.uiEventValueType.Float
            float value type.

        hou.uiEventValueType.FloatArray
            Array of float values.

        hou.uiEventValueType.IntArray
            Array of int values.

        hou.uiEventValueType.Integer
            int value type.

        hou.uiEventValueType.NoType
            invalid value type.

        hou.uiEventValueType.String
            string value type.

        hou.uiEventValueType.StringArray
            Array of string values.

    RELATED

        hou.UIEvent.valueType


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Float: EnumValue = ...
    FloatArray: EnumValue = ...
    IntArray: EnumValue = ...
    Integer: EnumValue = ...
    NoType: EnumValue = ...
    String: EnumValue = ...
    StringArray: EnumValue = ...

class uiEventReason:
    """

    hou.uiEventReason

    Values representing reasons Houdini generated a particular UI event.

    Calling hou.UIEvent.reason returns one of the following values.

    VALUES


        Picked
            Quick mouse click without dragging.

        Start
            Left mouse button pressed (mouse down)

        Active
            Mouse dragged with the left mouse button down.

        Changed
            Left mouse button released (mouse up).

        Located
            Mouse pointer hovered over something in the interface. In a
            viewer state, this is the reason associated with mouse moves.

        ItemsChanged
            Event generated as a change of values in hou.UIEvent

        New
            Event generated when a UI element was assigned a different
            value.

        RangeChanged
            Event generated when a slider or scrollbar has changed.

        NoReason
            Event was likely explicitly generated.

    RELATED

        hou.UIEvent.reason


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Active: EnumValue = ...
    Changed: EnumValue = ...
    ItemsChanged: EnumValue = ...
    Located: EnumValue = ...
    New: EnumValue = ...
    NoReason: EnumValue = ...
    Picked: EnumValue = ...
    RangeChanged: EnumValue = ...
    Start: EnumValue = ...

class drawablePrimitive:
    """

    hou.drawablePrimitive

    Enumerator for the drawable primitive types.

    VALUES


        hou.drawablePrimitive.Circle
        hou.drawablePrimitive.Sphere
        hou.drawablePrimitive.Tube


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Circle: EnumValue = ...
    Sphere: EnumValue = ...
    Tube: EnumValue = ...

class resourceEventMessage:
    """

    hou.resourceEventMessage

    Enumeration of the resource events that can be handled by callback
    functions.

    See hou.ui.addResourceEventCallback.

    VALUES


        OnActivate
            Event triggered after a viewer handle has been activated.

        OnCustomEvent
            Event triggered when hou.ui.fireResourceCustomEvent is called.

        OnDeactivate
            Event triggered after a viewer handle has been deactivated.

        OnExit
            Event triggered after a viewer state ends.

        OnEnter
            Event triggered after a viewer state begins.

        OnExit
            Event triggered after a viewer state ends.

        OnGenerate
            Event triggered after a nodeless viewer state begins.

        OnInterrupt
            Event triggered after a viewer state has been interrupted.

        OnLoad
            Event triggered after a package has been successsfully loaded.

        OnPreEnter
            Event triggered before a viewer state begins.

        OnPrintMessage
            Event triggered when hou.ui.printViewerStateMessage is called.

        OnReload
            Event triggered after a viewer state or package has been
            successsfully reloaded.

        OnResume
            Event triggered after a viewer state has resumed after an
            interruption.

        OnRegister
            Event triggered after a viewer state has been successfully
            registered.

        OnUnload
            Event triggered after a package has been successsfully unloaded.

        OnUnregister
            Event triggered after a viewer state has been successfully un-
            registered.

        OnRuntimeError
            Event triggered when a runtime error occurs during a viewer
            state operation.

        NoEventType
            An invalid viewer state event type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NoEventType: EnumValue = ...
    OnActivate: EnumValue = ...
    OnCustomEvent: EnumValue = ...
    OnDeactivate: EnumValue = ...
    OnEnter: EnumValue = ...
    OnExit: EnumValue = ...
    OnGenerate: EnumValue = ...
    OnInterrupt: EnumValue = ...
    OnLoad: EnumValue = ...
    OnPreEnter: EnumValue = ...
    OnPrintMessage: EnumValue = ...
    OnRegister: EnumValue = ...
    OnReload: EnumValue = ...
    OnResume: EnumValue = ...
    OnRuntimeError: EnumValue = ...
    OnUnload: EnumValue = ...
    OnUnregister: EnumValue = ...

class snappingPriority:
    """

    hou.snappingPriority

    Enumeration of snapping priority.

    See hou.SceneViewer.snappingPriority.

    VALUES


        GeoEdge
            Edge between two GeoPoints

        GeoPoint
            Point on a geometry

        Midpoint
            Midpoint of a GeoEdge

        GeoPrim
            Primitive on a geometry

        Breakpoint
            Control point on a NURBS curve or surface

        GridPoint
            Point on the construction plane, reference plane, or on the grid
            in the ortho/uv viewports

        GridEdge
            Edge of the construction plane, reference plane, or of the grid
            in the ortho/uv viewports

        PrimGuidePoint
            Point on the guide geometry for a primitive sphere/tube/etc.

        PrimGuideEdge
            Edge on the guide geometry for a primitive sphere/tube/etc.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Breakpoint: EnumValue = ...
    GeoEdge: EnumValue = ...
    GeoPoint: EnumValue = ...
    GeoPrim: EnumValue = ...
    GridEdge: EnumValue = ...
    GridPoint: EnumValue = ...
    Midpoint: EnumValue = ...
    PrimGuideEdge: EnumValue = ...
    PrimGuidePoint: EnumValue = ...

class triggerSelectorAction:
    """

    hou.triggerSelectorAction

    Enumerator representing the type of action a state selector can perform
    if triggered with hou.SceneViewer.triggerStateSelector.

    VALUES


        Start
            Activate a selector.

        Stop
            Deactivate a selector.

        Toggle
            Start or stop a selector depending of the current selector
            state. If currently stopped, the selector is started otherwise
            it is stopped.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Start: EnumValue = ...
    Stop: EnumValue = ...
    Toggle: EnumValue = ...

class drawableGeometryType:
    """

    hou.drawableGeometryType

    Enumeration of Geometry Drawable types.

    See hou.AdvancedDrawable See hou.GeometryDrawable

    VALUES


        Face
            Face drawable type. This drawable allows you to highlight the
            polygons of the attached geometry.

        Line
            Line drawable type. This drawable allows you to highlight the
            polygon edges of the attached geometry.

        Point
            Point drawable type. This drawable allows you to highlight the
            polygon vertices of the attached geometry.

        Vector
            Vector drawable type. This drawable works with point geometries
            and allows you to draw vectors at each point. Note that a point
            attribute N is required for the Vector drawable type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Face: EnumValue = ...
    Line: EnumValue = ...
    Point: EnumValue = ...
    Vector: EnumValue = ...

class drawableTextOrigin:
    """

    hou.drawableTextOrigin

    Enumeration used with hou.TextDrawable to specify the reference point of
    the text within its bounding box.

    VALUES


        BottomLeft
            Set the text reference point at the bottom left position of the
            bounding box.

        BottomCenter
            Set the text reference point at the bottom center position of
            the bounding box.

        BottomRight
            Set the text reference point at the bottom right position of the
            bounding box.

        LeftCenter
            Set the text reference point at the left center position of the
            bounding box.

        RightCenter
            Set the text reference point at the right center position of the
            bounding box.

        UpperLeft
            Set the text reference point at the upper left position of the
            bounding box.

        UpperCenter
            Set the text reference point at the upper center position of the
            bounding box.

        UpperRight
            Set the text reference point at the upper right position of the
            bounding box.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    BottomCenter: EnumValue = ...
    BottomLeft: EnumValue = ...
    BottomRight: EnumValue = ...
    LeftCenter: EnumValue = ...
    RightCenter: EnumValue = ...
    UpperCenter: EnumValue = ...
    UpperLeft: EnumValue = ...
    UpperRight: EnumValue = ...

class drawableGeometryFaceStyle:
    """

    hou.drawableGeometryFaceStyle

    Enumeration used with hou.GeometryDrawable to specify the style of faces
    to draw.

    VALUES


        Plain
            Regular face

        Checker
            Draws faces in a checker patterm.

        Circle
            Draws faces in a circle patterm.

        Columns
            Draws faces in columns.

        Rows
            Draws faces in rows.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Checker: EnumValue = ...
    Circle: EnumValue = ...
    Columns: EnumValue = ...
    Plain: EnumValue = ...
    Rows: EnumValue = ...

class drawableGeometryLineStyle:
    """

    hou.drawableGeometryLineStyle

    Enumeration used with hou.GeometryDrawable to specify the style of lines
    to draw.

    VALUES


        Plain
            Regular line.

        Dash1
            Draw half of the line.

        Dash2
            Draw one third of the line.

        Dash3
            Draw one quarter of the line.

        Dot1
            Draw a continuous line of dots.

        Dot2
            Draw every second dot.

        Dot3
            Draw every fourth dot.

        Dot4
            Draw every eighth dot.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Dash1: EnumValue = ...
    Dash2: EnumValue = ...
    Dash3: EnumValue = ...
    Dot1: EnumValue = ...
    Dot2: EnumValue = ...
    Dot3: EnumValue = ...
    Dot4: EnumValue = ...
    Plain: EnumValue = ...

class drawableGeometryPointStyle:
    """

    hou.drawableGeometryPointStyle

    Enumeration used with hou.GeometryDrawable to specify the style of
    points to draw.

    VALUES


        LinearCircle
            Linear circle

        LinearSquare
            Linear square

        LinearDiamond
            Linear Diamond

        RingsCircle
            Circular rings

        RingsSquare
            Square rings

        RingsDiamond
            Rings Diamond

        SmoothCircle
            Smooth circle

        SmoothSquare
            Smooth square

        SmoothDiamond
            Smooth Diamond

        ArrowUp
            Arrow pointing up.

        Cross
            Cross

        Cube
            3D cube

        Diamond
            Diamond shape

        Diamond2
            Diamond shape with dash lines.

        Diamond3
            Diamond-cross shape with dash lines.

        Flare
            Flare shape.

        Frame
            Simple frame.

        Frame2
            Frame with dash lines.

        Frame3
            Frame with dotted line.

        Locate
            Locate-arrow shape.

        Locate2
            Simple locate shape.

        Plus
            Plus sign.

        Ring
            Simple ring.

        Ring2
            Simple ring with dashed line.

        Ring3
            Two color ring.

        Ring4
            Ring with triple lines.

        Ring5
            Dotted ring.

        Target1
            Target shape 1.

        Target2
            Target shape 2.

        Target3
            Target shape 3.

        Target4
            Target shape 4.

        TriangleDown
            Triangle pointing down.

        TriangleUp
            Triangle pointing up.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ArrowUp: EnumValue = ...
    Cross: EnumValue = ...
    Cube: EnumValue = ...
    Diamond: EnumValue = ...
    Diamond2: EnumValue = ...
    Diamond3: EnumValue = ...
    Flare: EnumValue = ...
    Frame: EnumValue = ...
    Frame2: EnumValue = ...
    Frame3: EnumValue = ...
    LinearCircle: EnumValue = ...
    LinearDiamond: EnumValue = ...
    LinearSquare: EnumValue = ...
    Locate: EnumValue = ...
    Locate2: EnumValue = ...
    Plus: EnumValue = ...
    Ring: EnumValue = ...
    Ring2: EnumValue = ...
    Ring3: EnumValue = ...
    Ring4: EnumValue = ...
    Ring5: EnumValue = ...
    RingsCircle: EnumValue = ...
    RingsDiamond: EnumValue = ...
    RingsSquare: EnumValue = ...
    SmoothCircle: EnumValue = ...
    SmoothDiamond: EnumValue = ...
    SmoothSquare: EnumValue = ...
    Target1: EnumValue = ...
    Target2: EnumValue = ...
    Target3: EnumValue = ...
    Target4: EnumValue = ...
    TriangleDown: EnumValue = ...
    TriangleUp: EnumValue = ...

class drawableRampClamp:
    """

    hou.drawableRampClamp

    Enumeration used with hou.GeometryDrawable to specify how to wrap the
    texture generated when using a ramp color (similar to OpenGL texture
    settings).

    VALUES


        Border
            Border texture clamping.

        Edge
            Edge texture clamping.

        Mirror
            Mirror repeat texture clamping.

        Repeat
            Repeat texture clamping.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Border: EnumValue = ...
    Edge: EnumValue = ...
    Mirror: EnumValue = ...
    Repeat: EnumValue = ...

class drawableHighlightMode:
    """

    hou.drawableHighlightMode

    Enumeration used with hou.AdvancedDrawable to specify the highlight mode
    of a drawable matte.

    VALUES


        Glow
            Display the drawable with a glow by using the color2 parameter.

        Matte
            Display the drawable matte only by using the color1 parameter.

        GlowMinusMatte
            Display a glow around the drawable without drawing the matte,
            typically used to draw a silhouette.

        MatteOverGlow
            Display the matte over the glow.

        Transparent
            Make the drawable completely transparent. Useful to hide parts
            of other drawables.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Glow: EnumValue = ...
    GlowMinusMatte: EnumValue = ...
    Matte: EnumValue = ...
    MatteOverGlow: EnumValue = ...
    Transparent: EnumValue = ...

class secureSelectionOption:
    """

    hou.secureSelectionOption

    Enumeration of the secure selection options used by viewer state
    selectors.

    Used by:

      * hou.ViewerStateTemplate.bindGeometrySelector

      * hou.ViewerStateTemplate.bindObjectSelector

      * hou.ViewerStateTemplate.bindSceneGraphSelector

      * hou.ViewerStateTemplate.bindDynamicsSelector

      * hou.ViewerStateTemplate.bindDynamicsPointSelector

      * hou.ViewerStateTemplate.bindDynamicsPolygonSelector

    VALUES


        Ignore
            Selector ignores the viewer's secure selection setting.

        Obey
            Selector obeys the viewer's secure selection setting.

        On
            Selector sets the viewer's secure selection to On when it
            starts.

        Off
            Selector sets the viewer's secure selection to Off when it
            starts.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Ignore: EnumValue = ...
    Obey: EnumValue = ...
    Off: EnumValue = ...
    On: EnumValue = ...

class resourceType:
    """

    hou.resourceType

    Enumeration of resources such as viewer states and viewer handles.

    See hou.ui.addResourceEventCallback

    VALUES


        ViewerState
            Viewer State resource.

        ViewerHandle
            Viewer Handle resource.

        Package
            Package resource.

        NoType
            Not a valid type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NoType: EnumValue = ...
    Package: EnumValue = ...
    ViewerHandle: EnumValue = ...
    ViewerState: EnumValue = ...

class geometryViewportEvent:
    """

    hou.geometryViewportEvent

    Enumeration of the geometry viewport events that can be handled by
    callback functions.

    See hou.GeometryViewport.addEventCallback.

    VALUES


        CameraSwitched
            This event is triggered when the viewport camera has been
            switched to a different one.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    CameraSwitched: EnumValue = ...

class sceneViewerEvent:
    """

    hou.sceneViewerEvent

    Enumeration of the UI events a scene viewer can listen to via a
    callback.

    See hou.SceneViewer.addEventCallback.

    VALUES


        BeginResize
            Sent when the user has started resizing a viewer window when
            dragging the viewer frame.

        EndResize
            This event is sent when the user has ended resizing a viewer
            window when dragging the viewer frame.

        Resizing
            This event is sent whenever a viewer window is being resized
            interactively.

        SizeChanged
            This event is sent whenever a viewer window size has changed.

        LayoutChanged
            Sent when the viewport layout has been changed.

        ColorSchemeChanged
            Sent when the viewer color scheme has changed. The color scheme
            can be changed in the Display options.

        SelectedViewportChanged
            Sent when a viewport has been selected. Viewports can be
            selected by holding [Space] and pressing the [N] key.

        ViewerActivated
            Sent when a viewer panel tab is selected.

        ViewerDeactivated
            Sent when a viewer panel tab is deselected.

        ViewerTerminated
            Sent when a viewer is terminated as a result of a pane, pane tab
            or floating panel being closed.

        StateInterrupted
            Sent when a viewer state is interrupted. Moving the mouse
            outside a viewer will trigger this event.

        StateResumed
            Sent when a viewer state is resumed. Moving the mouse inside a
            viewer will trigger this event.

        StateEntered
            Sent when a viewer state has entered.

        StateExited
            Sent when a viewer state has exited.

        PrefChanged
            Sent when a preference has been changed.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    BeginResize: EnumValue = ...
    ColorSchemeChanged: EnumValue = ...
    EndResize: EnumValue = ...
    LayoutChanged: EnumValue = ...
    PrefChanged: EnumValue = ...
    Resizing: EnumValue = ...
    SelectedViewportChanged: EnumValue = ...
    SizeChanged: EnumValue = ...
    StateEntered: EnumValue = ...
    StateExited: EnumValue = ...
    StateInterrupted: EnumValue = ...
    StateResumed: EnumValue = ...
    ViewerActivated: EnumValue = ...
    ViewerDeactivated: EnumValue = ...
    ViewerTerminated: EnumValue = ...

class hudInfoState:
    """

    hou.hudInfoState

    Enumeration of states for controling the hou.hudPanel.ToolInfo panel.

    See hou.SceneViewer.hudInfo.

    VALUES


        Maximize
            Use this state to maximize the panel display.

        Minimize
            Use this state to minimize the panel display.

        Toggle
            Switch between the Minimize and Maximize state.

        NoState
            Not a valid state.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Maximize: EnumValue = ...
    Minimize: EnumValue = ...
    NoState: EnumValue = ...
    Toggle: EnumValue = ...

class hudPanel:
    """

    hou.hudPanel

    Enumeration to identify the HUD panel types.

    See hou.SceneViewer.hudInfo.

    VALUES


        ToolInfo
            Panel for displaying settings and usage hints for the running
            state. The HUD is located at the viewport top-left.

        User
            Displays user-defined information. The User HUD is located at
            the viewport bottom-left.

        NoPanel
            Not a valid panel.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    NoPanel: EnumValue = ...
    ToolInfo: EnumValue = ...
    User: EnumValue = ...

class drawable2DType:
    """

    hou.drawable2DType

    Enumerator for 2D drawable types.

    See hou.Drawable2D

    VALUES


        hou.drawable2DType.Arc
            Arc drawable type.

        hou.drawable2DType.Circle
            Circle drawable type.

        hou.drawable2DType.Marker
            Marker drawable type.

        hou.drawable2DType.Icon
            Icon drawable type.

        hou.drawable2DType.Line
            Line drawable type.

        hou.drawable2DType.Shape
            Drawable type for drawing an open or closed shape.

        hou.drawable2DType.Rect
            Rectangle drawable type.

        hou.drawable2DType.Text
            Drawable type for displaying text.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Arc: EnumValue = ...
    Circle: EnumValue = ...
    Icon: EnumValue = ...
    Line: EnumValue = ...
    Marker: EnumValue = ...
    Rect: EnumValue = ...
    Shape: EnumValue = ...
    Text: EnumValue = ...

class drawable2DCapStyle:
    """

    hou.drawable2DCapStyle

    Enumerator for 2D drawable cap styles.

    See hou.Drawable2D

    VALUES


        hou.drawable2DCapStyle.Arrow
            Filled arrow shape type.

        hou.drawable2DCapStyle.BackwardArrow
            Filled arrow shape type drawn backward.

        hou.drawable2DCapStyle.Bar
            Vertical bar shape type.

        hou.drawable2DCapStyle.Butt
            No shape attached to the drawable.

        hou.drawable2DCapStyle.Diamond
            Filled diamond shape type.

        hou.drawable2DCapStyle.Dot
            Filled circle shape type.

        hou.drawable2DCapStyle.HollowArrow
            Unfilled arrow shape type.

        hou.drawable2DCapStyle.HollowBackwardArrow
            Unfilled arrow shape type drawn backward.

        hou.drawable2DCapStyle.HollowDiamond
            Unfilled diamond shape type.

        hou.drawable2DCapStyle.HollowDot
            Unfilled circle shape type.

        hou.drawable2DCapStyle.HollowSquare
            Unfilled square shape type.

        hou.drawable2DCapStyle.Square
            Filled square shape type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Arrow: EnumValue = ...
    BackwardArrow: EnumValue = ...
    Bar: EnumValue = ...
    Butt: EnumValue = ...
    Diamond: EnumValue = ...
    Dot: EnumValue = ...
    HollowArrow: EnumValue = ...
    HollowBackwardArrow: EnumValue = ...
    HollowDiamond: EnumValue = ...
    HollowDot: EnumValue = ...
    HollowSquare: EnumValue = ...
    Square: EnumValue = ...

class drawable2DLineStyle:
    """

    hou.drawable2DLineStyle

    Enumerator for 2D drawable line styles.

    See hou.Drawable2D

    VALUES


        hou.drawable2DLineStyle.Dashed
            Draw lines with a dashed line style.

        hou.drawable2DLineStyle.Solid
            Draw lines with a solid line style.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Dashed: EnumValue = ...
    Solid: EnumValue = ...

class drawable2DMarkerSize:
    """

    hou.drawable2DMarkerSize

    Enumerator for 2D drawable marker size.

    See hou.Drawable2D

    VALUES


        hou.drawable2DMarkerSize.Large
            Large marker drawable size.

        hou.drawable2DMarkerSize.Medium
            Medium marker drawable size.

        hou.drawable2DMarkerSize.Tiny
            Tiny marker drawable size.

        hou.drawable2DMarkerSize.Small
            Small marker drawable size.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Large: EnumValue = ...
    Medium: EnumValue = ...
    Small: EnumValue = ...
    Tiny: EnumValue = ...

class drawable2DMarkerStyle:
    """

    hou.drawable2DMarkerStyle

    Enumerator for 2D drawable marker style.

    See hou.Drawable2D

    VALUES


        hou.drawable2DMarkerStyle.Cross
            Cross shape type.

        hou.drawable2DMarkerStyle.Diamond
            Filled diamond shape type.

        hou.drawable2DMarkerStyle.Dot
            Filled circle shape type.

        hou.drawable2DMarkerStyle.HollowDiamond
            Unfilled diamond shape type.

        hou.drawable2DMarkerStyle.HollowDot
            Unfilled circle shape type.

        hou.drawable2DMarkerStyle.HollowSquare
            Unfilled square shape type.

        hou.drawable2DMarkerStyle.Square
            Filled square shape type.

        hou.drawable2DMarkerStyle.SquareCross
            A hollow square marker with a cross shape inside.

        hou.drawable2DMarkerStyle.XShape
            X shape type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Cross: EnumValue = ...
    Diamond: EnumValue = ...
    Dot: EnumValue = ...
    HollowDiamond: EnumValue = ...
    HollowDot: EnumValue = ...
    HollowSquare: EnumValue = ...
    Square: EnumValue = ...
    SquareCross: EnumValue = ...
    XShape: EnumValue = ...

class scrollPosition:
    """

    hou.scrollPosition

    Enumeration of scrolling position modes.

    See hou.NetworkEditor.parmScrollTo. See hou.ParameterEditor.scrollTo.

    VALUES


        Auto
            Adjust the scroll only when the parameter bounding box is
            outside the current scroll window. Uses top alignment if the
            bounding box was above the scroll window or bottom alignment
            otherwise.

        Top
            Adjust the scroll aligning the top of the parameter bounding box
            to the top of the scroll window.

        Center
            Adjust the scroll aligning the center of the parameter bounding
            box to the center of the scroll window.

        Bottom
            Adjust the scroll aligning the bottom of the parameter bounding
            box to the bottom of the scroll window.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Auto: EnumValue = ...
    Bottom: EnumValue = ...
    Center: EnumValue = ...
    Top: EnumValue = ...

class parmFilterMode:
    """

    hou.parmFilterMode

    Enumeration of Parameter filter modes.

    See Searching and filtering parameters See
    hou.NetworkEditor.parmFilterMode. See
    hou.NetworkEditor.setParmFilterMode. See hou.ParameterEditor.filterMode.
    See hou.ParameterEditor.setFilterMode.

    VALUES


        AllParms
        AllParmsAndHeadings
        TimeDependentParms
        ScopedParms
        AutoScopedParms
        GraphSelectedParms
        NonDefaultParms
        ParmsWithExpressions
        ParmsWithOverrides
        InvisibleParms
        VisibleAndInvisibleParms
        SearchNoControlMenus


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    AllParms: EnumValue = ...
    AllParmsAndHeadings: EnumValue = ...
    AutoScopedParms: EnumValue = ...
    GraphSelectedParms: EnumValue = ...
    InvisibleParms: EnumValue = ...
    NonDefaultParms: EnumValue = ...
    ParmsWithExpressions: EnumValue = ...
    ParmsWithOverrides: EnumValue = ...
    ScopedParms: EnumValue = ...
    SearchNoControlMenus: EnumValue = ...
    TimeDependentParms: EnumValue = ...
    VisibleAndInvisibleParms: EnumValue = ...

class parmFilterCriteria:
    """

    hou.parmFilterCriteria

    Enumeration of Parameter filter criteria.

    See Searching and filtering parameters See
    hou.NetworkEditor.parmFilterCriteria. See
    hou.NetworkEditor.setParmFilterCriteria. See
    hou.ParameterEditor.filterCriteria. See
    hou.ParameterEditor.setFilterCriteria.

    VALUES


        NameOrLabel
        Name
        Label
        RawValue
        EvaluatedValue


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    EvaluatedValue: EnumValue = ...
    Label: EnumValue = ...
    Name: EnumValue = ...
    NameOrLabel: EnumValue = ...
    RawValue: EnumValue = ...

class _ik_targetType:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    All: EnumValue = ...
    Orientation: EnumValue = ...
    Position: EnumValue = ...

class agentShapeDeformerType:
    """

    hou.agentShapeDeformerType

    Enumeration of agent shape deformer types.

    Specifies the built-in shape deformer types, which can be used when
    creating a hou.AgentShapeDeformer.

    VALUES


        LinearSkinning
        DualQuatSkinning
        DualQuatBlendSkinning
        BlendShape
        BlendShapeAndLinearSkinning
        BlendShapeAndDualQuatSkinning
        BlendShapeAndDualQuatBlendSkinning


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    BlendShape: EnumValue = ...
    BlendShapeAndDualQuatBlendSkinning: EnumValue = ...
    BlendShapeAndDualQuatSkinning: EnumValue = ...
    BlendShapeAndLinearSkinning: EnumValue = ...
    DualQuatBlendSkinning: EnumValue = ...
    DualQuatSkinning: EnumValue = ...
    LinearSkinning: EnumValue = ...

class optionalBool:
    """

    hou.optionalBool

    Enumeration of a generic tri-state value.

    This enumeration is essentially a boolean value, but with the added
    possibility of expressing an explicit lack of opinion. As an example, a
    function may want to know the value of a toggle parameter. True or False
    values would turn the toggle on or off. A NoOpinion value would indicate
    that the parameter value should be left unchanged, because the caller
    has no opinion on what the value of the parameter should be.


    Yes
        Equivalent to a boolean True value.

    No
        Equivalent to a boolean False value.

    NoOpinion
        Indicates a lack of opinion.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    No: EnumValue = ...
    NoOpinion: EnumValue = ...
    Yes: EnumValue = ...

class videoDriver:
    """

    hou.videoDriver

    Enumeration of drivers that provide video functionality.

    Video functionality in Houdini is provided by different drivers. Some
    drivers are available on all platforms, while others are specific to a
    certain platform. This enumeration allows you to specify which driver
    should be used when interacting with the video subsystem.


    FFmpeg
        Use the FFmpeg driver.

    VFW
        Use the Video For Windows driver.

    RELATED

      * hou.videoEncoders


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete

class trackExtend:
    """

    hou.trackExtend

    Enumeration of Track Extend modes.

    VALUES


        Hold
        Slope
        Cycle
        Mirror
        Default
        CycleStep


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    Cycle: EnumValue = ...
    CycleStep: EnumValue = ...
    Default: EnumValue = ...
    Hold: EnumValue = ...
    Mirror: EnumValue = ...
    Slope: EnumValue = ...

class clipMode:
    """

    hou.clipMode

    Enumeration of Clip modes.

    VALUES


        CurrentFrame
        ConstantRange
        Range


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    ConstantRange: EnumValue = ...
    CurrentFrame: EnumValue = ...
    Range: EnumValue = ...

class SystemExit(Exception):
    """

    hou.SystemExit

    TIP
        Raising this exception yourself will have no effect. Call hou.exit
        to tell Houdini to quit.


    """
    thisown: Incomplete
    def __init__(self, exit_code: int) -> None:
        """

        hou.SystemExit

        TIP
            Raising this exception yourself will have no effect. Call hou.exit
            to tell Houdini to quit.


        """
    def code(self) -> int:
        """

        code(self) -> int

            The exit code Houdini will return to the OS when it exits.


        """
    __swig_destroy__: Incomplete

class Error(Exception):
    """

    hou.Error

    Base class for all exceptions in the hou module.

    You can check if an exception instance is a Houdini-specific exception
    using isinstance(ex, hou.Error).

    You can catch all Houdini-specific exceptions in an except statement
    using except hou.Error:.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.Error

        Base class for all exceptions in the hou module.

        You can check if an exception instance is a Houdini-specific exception
        using isinstance(ex, hou.Error).

        You can catch all Houdini-specific exceptions in an except statement
        using except hou.Error:.


        """
    __swig_destroy__: Incomplete
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    def instanceMessage(self) -> str:
        """

        instanceMessage(self) -> str

            Return a message specific to the exception instance.


        """

class NotAvailable(Error):
    """

    hou.NotAvailable

    Raised when you try to call an API function/method that is not
    available.

    A certain HOM function, class, or method may not be available due to
    Houdini running with a limited license.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.NotAvailable

        Raised when you try to call an API function/method that is not
        available.

        A certain HOM function, class, or method may not be available due to
        Houdini running with a limited license.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class ObjectWasDeleted(Error):
    '''

    hou.ObjectWasDeleted

    Raised when you try to access a reference to an object that has since
    been deleted.

    OVERVIEW

        For example, you might take a reference to a node:

      > >>> node = hou.node(\\"/obj/geo1/sphere1\\")

        If that node is later deleted, and then you try to use your
        reference to the deleted node, Houdini will raise this error:

      > >>> path = node.path()
      > hou.ObjectWasDeleted: ...

    TIPS AND TRICKS

      * There is no way to check if a reference is still valid, other than
        to try an operation and catch this error.

      * If you want to keep a long-ish term reference to a node, you might
        find it more convenient to instead keep a reference to the node\'s
        unique integer ID for the node in this session (hou.Node.sessionId).
        Then, when you want to use the node again, call hou.nodeBySessionId
        with the ID. It will return a reference to the node, or None if the
        node has since been deleted.


    '''
    thisown: Incomplete
    def __init__(self, *args) -> None:
        '''

        hou.ObjectWasDeleted

        Raised when you try to access a reference to an object that has since
        been deleted.

        OVERVIEW

            For example, you might take a reference to a node:

          > >>> node = hou.node(\\"/obj/geo1/sphere1\\")

            If that node is later deleted, and then you try to use your
            reference to the deleted node, Houdini will raise this error:

          > >>> path = node.path()
          > hou.ObjectWasDeleted: ...

        TIPS AND TRICKS

          * There is no way to check if a reference is still valid, other than
            to try an operation and catch this error.

          * If you want to keep a long-ish term reference to a node, you might
            find it more convenient to instead keep a reference to the node\'s
            unique integer ID for the node in this session (hou.Node.sessionId).
            Then, when you want to use the node again, call hou.nodeBySessionId
            with the ID. It will return a reference to the node, or None if the
            node has since been deleted.


        '''
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class InvalidInput(Error):
    """

    hou.InvalidInput

    Raised if you try to set a node's input to something invalid.

    The hou.Node API has various methods for wiring and un-wiring inputs and
    outputs in the network. If you try to wire an object into a node input
    that is not a node or is not allowed to be wired to that input, Houdini
    will raise this exception.

    Note that Houdini does allow certain wiring operations you might expect
    to fail (such as looping a node's output back into its own input) but
    then immediately flags them as errors in the network editor.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.InvalidInput

        Raised if you try to set a node's input to something invalid.

        The hou.Node API has various methods for wiring and un-wiring inputs and
        outputs in the network. If you try to wire an object into a node input
        that is not a node or is not allowed to be wired to that input, Houdini
        will raise this exception.

        Note that Houdini does allow certain wiring operations you might expect
        to fail (such as looping a node's output back into its own input) but
        then immediately flags them as errors in the network editor.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class InvalidOutput(Error):
    """

    hou.InvalidOutput

    Raised if you try to set a node's output to something invalid.

    The hou.Node API has various methods for wiring and un-wiring inputs and
    outputs in the network. If you try to wire an object into a node output
    that is not a node or is not allowed to be wired to that output, Houdini
    will raise this exception.

    Note that Houdini does allow certain wiring operations you might expect
    to fail (such as looping a node's output back into its own output) but
    then immediately flags them as errors in the network editor.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.InvalidOutput

        Raised if you try to set a node's output to something invalid.

        The hou.Node API has various methods for wiring and un-wiring inputs and
        outputs in the network. If you try to wire an object into a node output
        that is not a node or is not allowed to be wired to that output, Houdini
        will raise this exception.

        Note that Houdini does allow certain wiring operations you might expect
        to fail (such as looping a node's output back into its own output) but
        then immediately flags them as errors in the network editor.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class InvalidSize(Error):
    """

    hou.InvalidSize

    Raised when you pass a sequence of the wrong length to a function.

    There are occasionally methods in the HOM API where you must pass a
    sequence of values of an exact length... such as one value for each
    point in a geometry. If the sequence you pass to the method is the wrong
    size, Houdini raises this exception.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.InvalidSize

        Raised when you pass a sequence of the wrong length to a function.

        There are occasionally methods in the HOM API where you must pass a
        sequence of values of an exact length... such as one value for each
        point in a geometry. If the sequence you pass to the method is the wrong
        size, Houdini raises this exception.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class OperationFailed(Error):
    """

    hou.OperationFailed

    Generic catch-all exception for various errors in Houdini that don't
    have their own dedicated exception classes.

    There are many ways for things to go wrong in Houdini. In general, types
    of errors only have a dedicated exception class if we anticipate a
    script author might need to detect that particular type of error in an
    exception handler, and take appropriate action.


    """
    thisown: Incomplete
    def __init__(self, message: str|None = ...) -> None:
        """

        hou.OperationFailed

        Generic catch-all exception for various errors in Houdini that don't
        have their own dedicated exception classes.

        There are many ways for things to go wrong in Houdini. In general, types
        of errors only have a dedicated exception class if we anticipate a
        script author might need to detect that particular type of error in an
        exception handler, and take appropriate action.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class InvalidNodeType(Error):
    """

    hou.InvalidNodeType

    Raised if you try to call a method on a Node that doesn't support it.

    Even though subclassing generally makes it so methods only appear on
    objects that support them, there are node types that have optional
    features, or node types that might work differently from normal nodes
    (such as subnetworks and managers).


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.InvalidNodeType

        Raised if you try to call a method on a Node that doesn't support it.

        Even though subclassing generally makes it so methods only appear on
        objects that support them, there are node types that have optional
        features, or node types that might work differently from normal nodes
        (such as subnetworks and managers).


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class InitScriptFailed(Error):
    """

    hou.InitScriptFailed

    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.InitScriptFailed

        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class MatchDefinitionError(Error):
    """

    hou.MatchDefinitionError

    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.MatchDefinitionError

        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class PermissionError(Error):
    """

    hou.PermissionError

    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.PermissionError

        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    def instanceMessage(self) -> str:
        """

        instanceMessage(self) -> str

            Return a message specific to the exception instance.


        """
    __swig_destroy__: Incomplete

class GeometryPermissionError(Error):
    """

    hou.GeometryPermissionError

    Raised if you try to modify SOP geometry from outside of a Python SOP.

    OVERVIEW

      * Outside of the cook process, you can create your own hou.Geometry
        object and use methods and node verbs to manipulate the geometry.

      * When you get a Geometry object reference to the output of a geometry
        node (SOP), that reference is read-only (it represents the cached
        output of the node an so can't be changed). You can read/inspect the
        geometry. To modify the geometry, you must make a writable copy
        first.

      * If try to modify a Geometry object from SOPs outside of a Python
        SOP, Houdini will raise this error.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.GeometryPermissionError

        Raised if you try to modify SOP geometry from outside of a Python SOP.

        OVERVIEW

          * Outside of the cook process, you can create your own hou.Geometry
            object and use methods and node verbs to manipulate the geometry.

          * When you get a Geometry object reference to the output of a geometry
            node (SOP), that reference is read-only (it represents the cached
            output of the node an so can't be changed). You can read/inspect the
            geometry. To modify the geometry, you must make a writable copy
            first.

          * If try to modify a Geometry object from SOPs outside of a Python
            SOP, Houdini will raise this error.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class KeyframeValueNotSet(Error):
    """

    hou.KeyframeValueNotSet

    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.KeyframeValueNotSet

        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class OperationInterrupted(Error):
    """

    hou.OperationInterrupted

    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.OperationInterrupted

        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class LoadWarning(Error):
    """

    hou.LoadWarning

    Exception class for when loading a hip file in Houdini generates
    warnings.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.LoadWarning

        Exception class for when loading a hip file in Houdini generates
        warnings.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class NodeError(Error):
    '''

    hou.NodeError

    Raise this exception in a Python node to signal that the node is in
    error.

    OVERVIEW

        This is different from other exceptions that are typically raised by
        the system when something goes wrong, such as invalid inputs to a
        method call. This is an exception you, the author of a Python SOP,
        or Python Object, or Python LOP, etc., raise in the node\'s
        implementation script to set messages/warnings/errors on the node.

        Errors, warnings, and messages are part of a node\'s user interface.
        They show up in the network editor, parameter editor, and info
        window.

      * Errors signal to the node\'s user that the node has encountered an
        error. For example, invalid inputs or parameter values.

      * Warnings signal that the node was able to cook, but there was a
        problem the user might want to check. For example, a missing
        texture.

        See Writing Python SOPs for more information.


        TIP
            To mark the node with a warning instead of an error, raise
            hou.NodeWarning instead.

    EXAMPLE

        If you\'re writing a Python SOP, you might depend on information in
        an external file, specified by a parameter on the node:

      > thisnode = hou.pwd()
      > filepath = thisnode.parm(\\"file\\").evalAsString()
      > content = hou.readFile(filepath)
      > # ...

        If the file doesn\'t exist, you should raise this exception to signal
        to Houdini that the node could not cook, and specify an error
        message to help the user correct the problem:

      > import os.path
      > 
      > thisnode = hou.pwd()
      > filepath = thisnode.parm(\\"file\\").evalAsString()
      > 
      > if not os.path.exists(filepath):
      >     raise hou.NodeError(\\"File {} does not exist\\".format(filepath))
      > 
      > content = hou.readFile()
      > # ...

    RELATED

      * hou.NodeWarning


    '''
    thisown: Incomplete
    def __init__(self, *args) -> None:
        '''

        hou.NodeError

        Raise this exception in a Python node to signal that the node is in
        error.

        OVERVIEW

            This is different from other exceptions that are typically raised by
            the system when something goes wrong, such as invalid inputs to a
            method call. This is an exception you, the author of a Python SOP,
            or Python Object, or Python LOP, etc., raise in the node\'s
            implementation script to set messages/warnings/errors on the node.

            Errors, warnings, and messages are part of a node\'s user interface.
            They show up in the network editor, parameter editor, and info
            window.

          * Errors signal to the node\'s user that the node has encountered an
            error. For example, invalid inputs or parameter values.

          * Warnings signal that the node was able to cook, but there was a
            problem the user might want to check. For example, a missing
            texture.

            See Writing Python SOPs for more information.


            TIP
                To mark the node with a warning instead of an error, raise
                hou.NodeWarning instead.

        EXAMPLE

            If you\'re writing a Python SOP, you might depend on information in
            an external file, specified by a parameter on the node:

          > thisnode = hou.pwd()
          > filepath = thisnode.parm(\\"file\\").evalAsString()
          > content = hou.readFile(filepath)
          > # ...

            If the file doesn\'t exist, you should raise this exception to signal
            to Houdini that the node could not cook, and specify an error
            message to help the user correct the problem:

          > import os.path
          > 
          > thisnode = hou.pwd()
          > filepath = thisnode.parm(\\"file\\").evalAsString()
          > 
          > if not os.path.exists(filepath):
          >     raise hou.NodeError(\\"File {} does not exist\\".format(filepath))
          > 
          > content = hou.readFile()
          > # ...

        RELATED

          * hou.NodeWarning


        '''
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class NodeWarning(Error):
    '''

    hou.NodeWarning

    Raise this exception in a Python node to signal that the node has a
    warning.

    OVERVIEW

        This is different from other exceptions that are typically raised by
        the system when something goes wrong, such as invalid inputs to a
        method call. This is an exception you, the author of a Python SOP,
        or Python Object, or Python LOP, etc., raise in the node\'s
        implementation script to set messages/warnings/errors on the node.

        Errors, warnings, and messages are part of a node\'s user interface.
        They show up in the network editor, parameter editor, and info
        window.

      * Errors signal to the node\'s user that the node has encountered an
        error. For example, invalid inputs or parameter values.

      * Warnings signal that the node was able to cook, but there was a
        problem the user might want to check. For example, a missing
        texture.

        See Writing Python SOPs for more information.


        TIP
            To mark the node with an error instead of a warning, raise
            hou.NodeError instead.


        NOTE
            Raise a warning exception at the end of the script, so the node
            script otherwise completes cooking.

    EXAMPLE

        If you\'re writing a Python SOP, you might use the content of an
        external file (referenced in a parameter on the node), even though
        the node can work without the file:

      > import os.path
      > 
      > thisnode = hou.pwd()
      > filepath = thisnode.parm(\\"file\\").evalAsString()
      > content = hou.readFile()
      > if content:
      >     # Use the file contents
      >     # ...
      > 
      > # Continue script operation
      > # ...
      > 
      > # At the end of the script, raise any warning that might have
      > # come up during the script
      > if not content:
      >     raise NodeWarning(\\"The texture file is missing or empty\\")

    RELATED

      * hou.NodeWarning


    '''
    thisown: Incomplete
    def __init__(self, *args) -> None:
        '''

        hou.NodeWarning

        Raise this exception in a Python node to signal that the node has a
        warning.

        OVERVIEW

            This is different from other exceptions that are typically raised by
            the system when something goes wrong, such as invalid inputs to a
            method call. This is an exception you, the author of a Python SOP,
            or Python Object, or Python LOP, etc., raise in the node\'s
            implementation script to set messages/warnings/errors on the node.

            Errors, warnings, and messages are part of a node\'s user interface.
            They show up in the network editor, parameter editor, and info
            window.

          * Errors signal to the node\'s user that the node has encountered an
            error. For example, invalid inputs or parameter values.

          * Warnings signal that the node was able to cook, but there was a
            problem the user might want to check. For example, a missing
            texture.

            See Writing Python SOPs for more information.


            TIP
                To mark the node with an error instead of a warning, raise
                hou.NodeError instead.


            NOTE
                Raise a warning exception at the end of the script, so the node
                script otherwise completes cooking.

        EXAMPLE

            If you\'re writing a Python SOP, you might use the content of an
            external file (referenced in a parameter on the node), even though
            the node can work without the file:

          > import os.path
          > 
          > thisnode = hou.pwd()
          > filepath = thisnode.parm(\\"file\\").evalAsString()
          > content = hou.readFile()
          > if content:
          >     # Use the file contents
          >     # ...
          > 
          > # Continue script operation
          > # ...
          > 
          > # At the end of the script, raise any warning that might have
          > # come up during the script
          > if not content:
          >     raise NodeWarning(\\"The texture file is missing or empty\\")

        RELATED

          * hou.NodeWarning


        '''
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class NameConflict(Error):
    """

    hou.NameConflict

    Exception raised when a name conflict is detected during an operation.

    Often, Houdini can resolve name conflicts automatically (for example, if
    you try to create a node named sphere1 and a node with that name already
    exists, by default most API calls will create a node named sphere2
    instead). In cases where a naming conflict prevents an API call from
    working, and it can't be automatically resolved (or automatic resolution
    is an option you have disabled in an argument), Houdini will raise this
    exception.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.NameConflict

        Exception raised when a name conflict is detected during an operation.

        Often, Houdini can resolve name conflicts automatically (for example, if
        you try to create a node named sphere1 and a node with that name already
        exists, by default most API calls will create a node named sphere2
        instead). In cases where a naming conflict prevents an API call from
        working, and it can't be automatically resolved (or automatic resolution
        is an option you have disabled in an argument), Houdini will raise this
        exception.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class TypeConflict(Error):
    """

    hou.TypeConflict

    Raised if a type conflict occurs during an operation. For instance, type
    conflicts may occur during the registration of a python state or python
    handle.

    See Python States for more information.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.TypeConflict

        Raised if a type conflict occurs during an operation. For instance, type
        conflicts may occur during the registration of a python state or python
        handle.

        See Python States for more information.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class StateNotRegistered(Error):
    """

    hou.StateNotRegistered

    Raised if you try to unregister a Python state that was never
    registered.

    See Python States for more information.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.StateNotRegistered

        Raised if you try to unregister a Python state that was never
        registered.

        See Python States for more information.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class HandleNotRegistered(Error):
    """

    hou.HandleNotRegistered

    Raised if you try to use a custom handle that is not registered with the
    system.

    See Python handles for more information.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.HandleNotRegistered

        Raised if you try to use a custom handle that is not registered with the
        system.

        See Python handles for more information.


        """
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class LicenseError(Error):
    '''

    hou.LicenseError

    Raised when a licensing error occurs. For instance when trying to access
    a feature or component without the appropriate license.

    OVERVIEW

        For example, MPM tools are only available to be created with a
        Houdini FX license. Attempting to create a node of that type using
        Houdini Core will raise this error:

      > >>> node = hou.node(\\"/obj/geo1\\")
      > >>> newnode = node.createNode(\\"mpmcollider\\")
      > Traceback (most recent call last):
      > ...
      > hou.LicenseError: Not available in current session.


    '''
    thisown: Incomplete
    def __init__(self, *args) -> None:
        '''

        hou.LicenseError

        Raised when a licensing error occurs. For instance when trying to access
        a feature or component without the appropriate license.

        OVERVIEW

            For example, MPM tools are only available to be created with a
            Houdini FX license. Attempting to create a node of that type using
            Houdini Core will raise this error:

          > >>> node = hou.node(\\"/obj/geo1\\")
          > >>> newnode = node.createNode(\\"mpmcollider\\")
          > Traceback (most recent call last):
          > ...
          > hou.LicenseError: Not available in current session.


        '''
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class InvalidGeometry(OperationFailed):
    '''

    hou.InvalidGeometry

    Exception raised when you try to access a reference to SOP Geometry that
    has since failed to cook.

    OVERVIEW

        For example, you might take a reference to a geometry node\'s output:

      > >>> mygeo = hou.node(\\"/obj/geo1/sphere1\\").geometry()

        If after you take the reference something changes which causes the
        node to recook, and the recook fails, the geometry referred to by
        mygeo is now invalid. Trying to access it will raise this exception.

      > >>> points = mygeo.points()
      > hou.InvalidGeometry: ...

    TIPS AND NOTES

      * If you call .geometry() on a node that\'s currently in error, you
        will get None instead of an invalid hou.Geometry object.

      * You can check if a Geometry object is valid before you use it with
        hou.Geometry.isValid.

          > if mygeo.isValid():
          >     points = mygeo.points()
      * A Geometry reference turning invalid might happen if you grab
        geometry in code outside the cooking mechanism. If your code runs as
        part of the cook (for example, in a Python SOP), a valid Geometry
        reference should stay valid for the duration of your script.


    '''
    thisown: Incomplete
    def __init__(self, *args) -> None:
        '''

        hou.InvalidGeometry

        Exception raised when you try to access a reference to SOP Geometry that
        has since failed to cook.

        OVERVIEW

            For example, you might take a reference to a geometry node\'s output:

          > >>> mygeo = hou.node(\\"/obj/geo1/sphere1\\").geometry()

            If after you take the reference something changes which causes the
            node to recook, and the recook fails, the geometry referred to by
            mygeo is now invalid. Trying to access it will raise this exception.

          > >>> points = mygeo.points()
          > hou.InvalidGeometry: ...

        TIPS AND NOTES

          * If you call .geometry() on a node that\'s currently in error, you
            will get None instead of an invalid hou.Geometry object.

          * You can check if a Geometry object is valid before you use it with
            hou.Geometry.isValid.

              > if mygeo.isValid():
              >     points = mygeo.points()
          * A Geometry reference turning invalid might happen if you grab
            geometry in code outside the cooking mechanism. If your code runs as
            part of the cook (for example, in a Python SOP), a valid Geometry
            reference should stay valid for the duration of your script.


        '''
    def exceptionTypeName(self) -> str:
        '''

        exceptionTypeName(self) -> str

            Return the name of the exception type. Instances of different
            subclasses of hou.Error will return different names. Instances of
            the base class will return \\"Error\\".

            You can also use str(e.__class__) to get the name of the subclass.


        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return a description of the class of exception. The description is
            not related to the exception instance.


        """
    __swig_destroy__: Incomplete

class NetworkItem:
    """

    hou.NetworkItem

    The base class for all visible elements within a network.

    This class has no methods, and only exists as a base class for
    hou.NetworkMovableItem and hou.NodeConnection, both of which are visible
    in the network editor, but which have no real meaningful base class. By
    providing a common base class, items of these two types can be passed in
    or returned from hou.NetworkEditor functions.


    """
    thisown: Incomplete
    def __init__(self, *args) -> None:
        """

        hou.NetworkItem

        The base class for all visible elements within a network.

        This class has no methods, and only exists as a base class for
        hou.NetworkMovableItem and hou.NodeConnection, both of which are visible
        in the network editor, but which have no real meaningful base class. By
        providing a common base class, items of these two types can be passed in
        or returned from hou.NetworkEditor functions.


        """
    __swig_destroy__: Incomplete
    def networkItemType(self) -> EnumValue:
        """

        networkItemType(self) -> hou.networkItemType

            Return an enum value indicating what type of network item is
            represented by this object. This value is equivalent to using the
            isinstance built in Python function with the matching class (for
            example hou.networkItemType.Connection is equivalent to
            hou.NodeConnection).


        """

    # Missing methods added by stubgen
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class NetworkMovableItem(NetworkItem):
    """

    hou.NetworkMovableItem

    The base class for all visible elements within a network, such as Nodes,
    Network Boxes, and Sticky Notes.

    Each movable item has a position, color, and other attributes that allow
    for common interactions in the network editor. All movable items will
    have a parent network (except the node represented by hou.node('/')),
    and may be contained by a hou.NetworkBox. Not all movable items have a
    name, but all have a numeric session id, which is a unique number within
    a given Houdini session for a given subclass of NetworkMovableItem.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def name(self) -> str:
        """

        name(self) -> str

            Return this node's name. See also hou.NetworkMovableItem.path.


        """
    def setName(self, name: str, unique_name: bool = False) -> None:
        """

        setName(self, name, unique_name=False)

            Set the name of this node. Raises hou.OperationFailed if the new
            name contains characters other than letters, numbers, periods,
            dashes, or underscores. Raises hou.OperationFailed if the node could
            not be renamed (for example, another node already exists with the
            name, the node is the root node or top-level manager (e.g. /obj), or
            the node is inside a locked asset). If the unique_name parameter is
            set to True, the supplied name may be changed to ensure that it
            doesn't match the name of any existing node.


        """
    def digitsInName(self) -> int:
        """

        digitsInName(self) -> int

            Return the value of the last set of digits inside the node's name,
            or 0 if there are no digits.

            For example, the result is 102 for a node named geo102, and 34 for a
            node named light12to34.


        """
    def path(self) -> str:
        """

        path(self) -> str

            Return the full path (i.e. starting with /) of this node in the
            network.


        """
    def relativePathTo(self, base_item: NetworkMovableItem) -> str:
        '''

        relativePathTo(self, base_node) -> str

            Return a relative path to another node object from this node.

          > >>> box1 = hou.node(\\"/obj/box_object1/box1\\")
          > >>> sphere1 = hou.node(\\"/obj/sphere_object1/sphere1\\")
          > >>> box1.relativePathTo(sphere1)
          > \'../../sphere_object1/sphere1\'
          > >>> hou.node(\\"/obj\\").relativePathTo(box1)
          > \'box_object1/box1\'
          > >>> box1.relativePathTo(box1)
          > \'.\'

        '''
    def isSelected(self) -> bool:
        """

        isSelected(self) -> bool

            Return whether this item is selected.

            See also hou.selectedNodes.


        """
    def setSelected(self, on: bool, clear_all_selected: bool = False, show_asset_if_selected: bool = False) -> None:
        """

        setSelected(self, on, clear_all_selected=False,
        show_asset_if_selected=False)

            Select or deselect this item, optionally deselecting all other
            selected items in this network. If show_asset_if_selected is True,
            and this item is a Node, then the panes will show the top-level
            asset of the selected item instead.


        """
    def color(self) -> Color:
        """

        color(self) -> hou.Color

            Return the color of this item's tile in the network editor.


        """
    def setColor(self, color: Color) -> None:
        """

        setColor(self, color)

            Sets the color of this item's tile in the network editor to the
            given hou.Color.


        """
    def size(self) -> Vector2:
        """

        size(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph as a
            Vector2.


        """
    def position(self) -> Vector2:
        """

        position(self) -> hou.Vector2

            Return the position of this item's tile in the network editor graph
            as a Vector2. See also move() and setPosition().


        """
    def setPosition(self, position: Sequence[float]|Vector2) -> None:
        """

        setPosition(self, vector2)

            Sets the position of this item's tile in the network editor graph.
            Raises hou.InvalidInput if the item cannot have the given position.


        """
    def move(self, amount: Sequence[float]|Vector2) -> None:
        """

        move(self, vector2)

            Moves this item's tile in the network editor graph by the increments
            in the given hou.Vector2.

            To position a item absolutely, use setPosition().

            To get the item's current graph position, use position().

            Raises hou.InvalidInput if the item cannot move to the position
            specified.


        """
    def parent(self) -> Optional[Node]:
        '''

        parent(self) -> hou.Node

            Return the node that contains this item.

            Note that this method returns None if the item is the root node
            (i.e. /).

          > >>> hou.node(\\"/obj/box_object1\\").parent()
          > <hou.Node at /obj>
          > >>> print hou.node(\\"/\\").parent()
          > None

        '''
    def parentNetworkBox(self) -> Optional[NetworkBox]:
        """

        parentNetworkBox(self) -> hou.NetworkBox or None

            Returns the parent network box which contains this item, or None if
            it is not inside a network box.


        """
    def sessionId(self) -> int:
        """

        sessionId(self)

            Returns an integer value that uniquely identifies this item in a
            given Houdini session. This id is only guaranteed to be unique in a
            single Houdini process. It is useful as a quick and easy way to save
            a restore a reference to an item. It is also only unique for a
            specific item subclass. So there may be a Node with the same session
            id as a NetworkBox.

            See hou.nodeBySessionId to turn a session id back into a node, or
            hou.networkBoxBySessionId to turn a session id back into a network
            box, or more generally, hou.itemBySessionId to turn a session id
            combined with an enum value indicating the item subclass into an
            item of that type.


        """

class NetworkBox(NetworkMovableItem):
    """

    hou.NetworkBox

    Represents a network box.

    To create a network box, use the hou.Node.createNetworkBox method on the
    node inside which you want to create the box. To get an existing network
    box, use the hou.Node.findNetworkBox method on the node containing the
    network box. To get a list of all network boxes in a network, use the
    hou.Node.networkBoxes method on the containing node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def comment(self) -> str:
        """

        comment(self) -> str

            Returns the comment for this network box.


        """
    def setComment(self, comment: str) -> None:
        """

        setComment(self, comment)

            Set the comment string for this network box. This comment is visible
            in the network editor and can be used to describe the purpose of the
            box.


        """
    def autoFit(self) -> bool:
        """

        autoFit(self) -> bool

            Returns the value of the auto fit flag on this network box.


        """
    def setAutoFit(self, auto_fit: bool) -> None:
        """

        setAutoFit(self, auto_fit)

            Set the value of the auto fit flag on this network box. The default
            value is False which means the network box does not resize itself
            when nodes that belong to the network box are moved outside the
            bounds of the box. Setting this values to True enables this
            automatic resizing. The Network View will draw the network box
            around its contents in either case, even though the value returned
            by the size() method may return a smaller value that does not
            encompass all of the contained items.


        """
    def setBounds(self, bounds: BoundingRect) -> None:
        """

        setBounds(self, bounds)

            Sets the size and position of this sticky note to the given
            hou.BoundingRect bounds argument. Equivalent to calling setSize then
            setPosition.


        """
    def setSize(self, size: Sequence[float]) -> None:
        """

        setSize(self, size)

            Sets the size of this network box to the given hou.Vector2 size
            parameter. Use resize() to set the box's size relative to its
            current size.


        """
    def resize(self, amount: Sequence[float]) -> None:
        """

        resize(self, vector2)

            Resizes a network box by the increments in the given hou.Vector2.
            Use setSize() to set the box's absolute size.


        """
    def fitAroundContents(self) -> None:
        """

        fitAroundContents(self)

            Resizes the network box to fit its contents.


        """
    def minimizedSize(self) -> Vector2:
        """

        minimizedSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is minimized. Returned as a Vector2.


        """
    def restoredSize(self) -> Vector2:
        """

        restoredSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is not minimized. Returned as a Vector2.


        """
    def isMinimized(self) -> bool:
        """

        isMinimized(self) -> bool

            Returns whether the network box is minimized.


        """
    def setMinimized(self, on: bool) -> None:
        """

        setMinimized(self, on)

            Minimizes or restores the network box.


        """
    def alpha(self) -> float:
        """

        alpha(self) -> float

            Return the alpha value used for drawing this network box. A negative
            value indicates the network box should be drawn using the alpha
            value from the UI configuration.


        """
    def setAlpha(self, alpha: float) -> None:
        """

        setAlpha(self, alpha)

            Set the alpha of the network box. A negative value indicates the
            network box should be drawn using the alpha value from the UI
            configuration.


        """
    def nodes(self, recurse: bool = True) -> Tuple[Node, ...]:
        """

        nodes(self, recurse=True) -> tuple of hou.Node

            Returns the nodes inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
    def addNode(self, node: Node) -> None:
        """

        addNode(self, node)

            Adds a hou.Node to the network box. This method is deprecated. Use
            hou.NetworkBox.addItem instead.


        """
    def removeNode(self, node: Node) -> None:
        """

        removeNode(self, node)

            Removes the given node from the network box. This method if
            deprecated. Use hou.NetworkBox.removeItem instead.


        """
    def removeAllNodes(self) -> None:
        """

        removeAllNodes(self)

            Removes all nodes from the network box. This method if deprecated.
            Use hou.NetworkBox.removaAllItems or hou.NetworkBox.removeItems
            instead.


        """
    def networkBoxes(self, recurse: bool = True) -> Tuple[NetworkBox, ...]:
        """

        networkBoxes(self, recurse=True) -> tuple of hou.NetworkBox

            Returns the network boxes inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
    def addNetworkBox(self, networkbox: NetworkBox) -> None:
        """

        addNetworkBox(self, netbox)

            Adds a hou.NetworkDot to the network box. This method is deprecated.
            Use hou.NetworkBox.addItem instead.


        """
    def removeNetworkBox(self, networkbox: NetworkBox) -> None:
        """

        removeNetworkBox(self, netbox)

            Removes the given network box from the network box. This method if
            deprecated. Use hou.NetworkBox.removeItem instead.


        """
    def stickyNotes(self, recurse: bool = True) -> Tuple[StickyNote, ...]:
        """

        stickyNotes(self, recurse=True) -> tuple of hou.StickyNote

            Returns the sticky notes inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
    def addStickyNote(self, stickynote: StickyNote) -> None:
        """

        addStickyNote(self, stickynote)

            Adds a hou.StickyNote to the network box. This method is deprecated.
            Use hou.NetworkBox.addItem instead.


        """
    def removeStickyNote(self, stickynote: StickyNote) -> None:
        """

        removeStickyNote(self, stickynote)

            Removes the given sticky note from the network box. This method if
            deprecated. Use hou.NetworkBox.removeItem instead.


        """
    def subnetIndirectInputs(self, recurse: bool = True) -> Tuple[SubnetIndirectInput, ...]:
        """

        subnetIndirectInputs(self, recurse=True) -> tuple of
        hou.SubnetIndirectInput

            Returns the subnet indirect inputs inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
    def addSubnetIndirectInput(self, indirect: SubnetIndirectInput) -> None:
        """

        addSubnetIndirectInput(self, indirect)

            Adds a hou.SubnetIndirectInput to the network box. This method is
            deprecated. Use hou.NetworkBox.addItem instead.


        """
    def removeSubnetIndirectInput(self, indirect: SubnetIndirectInput) -> None:
        """

        removeSubnetIndirectInput(self, indirect)

            Removes the given indirect input from the network box. This method
            if deprecated. Use hou.NetworkBox.removeItem instead.


        """
    def items(self, recurse: bool = True) -> Tuple[NetworkMovableItem, ...]:
        """

        items(self, recurse=True) -> tuple of hou.NetworkMovableItem

            Returns the items of any type inside the network box.


            recurse
                If True, recurses down into nested network boxes.


        """
    def addItem(self, item: NetworkMovableItem) -> None:
        """

        addItem(self, item)

            Adds a hou.NetworkMovableItem of any kind to the network box.


        """
    def removeItem(self, item: NetworkMovableItem) -> None:
        """

        removeItem(self, item)

            Removes the given item from the network box.


        """
    def removeAllItems(self) -> None:
        """

        removeAllItems(self)

            Removes all items from the network box.


        """
    def destroy(self, destroy_contents: bool = False) -> None:
        """

        destroy(self, destroy_contents=False)

            Remove and delete the network box, optionally deleting the nodes it
            contains.


        """
    def asCode(self, brief: bool = False, recurse: bool = False, save_box_contents: bool = False, save_channels_only: bool = False, save_creation_commands: bool = True, save_keys_in_frames: bool = False, save_parm_values_only: bool = False, save_spare_parms: bool = False, save_netbox_membership: bool = True, function_name: Optional[str] = None) -> str:
        """

        asCode(self, brief=False, recurse=False, save_box_contents=False,
        save_channels_only=False, save_creation_commands=False,
        save_keys_in_frames=False, save_parm_values_only=False,
        save_spare_parms=False, save_box_membership=True, function_name=None) ->
        string

            Prints the Python code necessary to recreate a network box.

            See hou.Node.asCode for information on the keyword arguments.


        """

class OpNetworkBox(NetworkBox):
    """

    hou.OpNetworkBox

    Represents a network box in an OP network.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class StickyNote(NetworkMovableItem):
    """

    hou.StickyNote

    Represents a sticky note.

    To create a sticky note, use the hou.Node.createStickyNote method on the
    node inside which you want to create the note. To get an existing sticky
    note, use the hou.Node.findStickyNote method on the node containing the
    sticky note. To get a list of all notes in a network, use the
    hou.Node.stickyNotes method on the containing node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def text(self) -> str:
        """

        text(self) -> str

            Return the text displayed in the sticky note.


        """
    def setText(self, new_text: str) -> None:
        """

        setText(self, str)

            Sets the text of the sticky note.


        """
    def textSize(self) -> float:
        """

        textSize(self) -> float

            Return the size of the text displayed in the sticky note, expressed
            as the height of the font in network units.


        """
    def setTextSize(self, size: float) -> None:
        """

        setTextSize(self, size)

            Sets the size of the text of the sticky note. The size value
            specifies the height (in network units) of the font.


        """
    def textColor(self) -> Color:
        """

        textColor(self) -> hou.Color

            Return the color of the text displayed in the sticky note.


        """
    def setTextColor(self, color: Color) -> None:
        """

        setTextColor(self, color)

            Sets the color of the text of the sticky note. The color parameter
            should be a hou.Color object.


        """
    def drawBackground(self) -> bool:
        """

        drawBackground(self) -> bool

            Returns whether the sticky note will draw a colored background and
            title bar.


        """
    def setDrawBackground(self, on: bool) -> None:
        """

        setDrawBackground(self, on)

            Turns on or off the drawing of the colored background for the text
            and the title bar in the network editor. Turning this on makes the
            sticky note easier to see. Turning it off allows the text to be less
            obtrusive.


        """
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setSize(self, size: Sequence[float]|Vector2) -> None:
        """

        setSize(self, size)

            Sets the size of this sticky note to the given hou.Vector2 size
            parameter. Use resize() to set the note's size relative to its
            current size.


        """
    def resize(self, amount: Sequence[float]) -> None:
        """

        resize(self, vector2)

            Resizes a sticky note by the increments in the given hou.Vector2.
            Use setSize() to set the note's absolute size.


        """
    def minimizedSize(self) -> Vector2:
        """

        minimizedSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is minimized. Returned as a Vector2.


        """
    def restoredSize(self) -> Vector2:
        """

        restoredSize(self) -> hou.Vector2

            Return the size of this item's tile in the network editor graph if
            it is not minimized. Returned as a Vector2.


        """
    def isMinimized(self) -> bool:
        """

        isMinimized(self) -> bool

            Returns whether the sticky note is minimized.


        """
    def setMinimized(self, on: bool) -> None:
        """

        setMinimized(self, on)

            Minimizes or restores the sticky note.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Remove and delete the sticky note.


        """

class ApexStickyNote(StickyNote):
    """

    hou.ApexStickyNote

    Represents a sticky note in an APEX network.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class OpStickyNote(StickyNote):
    """

    hou.OpStickyNote

    Represents a sticky note in an OP network.


    asCode(self, brief=False, recurse=False, save_box_contents=False,
    save_channels_only=False, save_creation_commands=False,
    save_keys_in_frames=False, save_parm_values_only=False,
    save_spare_parms=False, save_box_membership=True, function_name=None) ->
    str
        Prints the Python code necessary to recreate a sticky note.

        See hou.Node.asCode for information on the keyword arguments.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def asCode(self, brief: bool = False, recurse: bool = False, save_box_contents: bool = False, save_channels_only: bool = False, save_creation_commands: bool = True, save_keys_in_frames: bool = False, save_parm_values_only: bool = False, save_spare_parms: bool = False, save_box_membership: bool = True, function_name: Optional[str] = None) -> str: ...

class Node(NetworkMovableItem):
    """

    hou.Node

    The base class for all abstract nodes in Houdini (OP, APEX, etc.)

    As of Houdini 20, this class no longer exclusively refers to Houdini OP
    nodes, but is instead an abstraction that allows the network editor to
    operate on a variety of node-like classes. The old hou.Node class is now
    hou.OpNode.

    The methods provided on this class are intended to be common to all
    node-like classes. Many of the methods that used to be defined on this
    class are now defined on hou.OpNode. Also note that the methods defined
    on this class will have different but analogous behaviors on other node-
    like classes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def isNetwork(self) -> bool:
        """

        isNetwork(self) -> bool

            Return True if this node is a network, in other words a node that
            may contain child nodes. Otherwise return False which indicates that
            several other methods such as hou.Node.createNode will raise
            hou.OperationFailed if they are called.


        """
    def isEditable(self) -> bool: ...
    def type(self) -> NodeType:
        """

        type(self) -> hou.NodeType

            Return the hou.NodeType object for this node.

            For example, all camera node instances share the same node type.


        """
    def childTypeCategory(self) -> NodeTypeCategory:
        """

        childTypeCategory(self) -> hou.NodeTypeCategory

            Return the hou.NodeTypeCategory corresponding to the children of
            this node. For example, if this node is a geometry object, the
            children are SOPs. If it is an object subnet, the children are
            objects.


        """
    def isFlagReadable(self, flag: EnumValue) -> bool:
        """

        isFlagReadable(self, flag) -> bool

            Return True if the specified flag is readable and False otherwise.

            flag must be a hou.nodeFlag value.


        """
    def isFlagWritable(self, flag: EnumValue) -> bool:
        """

        isFlagWritable(self, flag) -> bool

            Return True if the specified flag is writable and False otherwise.

            flag must be a hou.nodeFlag value.


        """
    def isGenericFlagSet(self, flag: EnumValue) -> bool:
        """

        isGenericFlagSet(self, flag) -> bool

            Returns the value of the specific flag.

            flag must be a hou.nodeFlag value.


        """
    def setGenericFlag(self, flag: EnumValue, value: bool) -> None:
        """

        setGenericFlag(self, flag, value)

            Sets the value of the specified flag based on the bool value
            argument.

            flag must be a hou.nodeFlag value.


        """
    def isDisplayDescriptiveNameFlagSet(self) -> bool:
        """

        isDisplayDescriptiveNameFlagSet(self) -> bool

            Return a boolean to indicate of the node should display its
            descriptive name in the network editor.


        """
    def setDisplayDescriptiveNameFlag(self, on: bool) -> None: ...
    def errors(self) -> Tuple[str, ...]:
        """

        errors(self) -> tuple of str

            Return the text of any errors from the last cook of this node, or an
            empty tuple if there were no errors.


        """
    def warnings(self) -> Tuple[str, ...]:
        """

        warnings(self) -> tuple of str

            Return the text of any warnings from the last cook of this node, or
            an empty tuple if there were no warnings.


        """
    def messages(self) -> Tuple[str, ...]:
        """

        messages(self) -> tuple of str

            Return the text of any messages from the last cook of this node, or
            an empty tuple if there were no messages.


        """
    def node(self, node_path: str) -> Optional[Node]:
        '''

        node(self, node_path) -> hou.Node or None

            Return the node at the given path, or None if no such node exists.
            If you pass in a relative path (i.e. the path does not start with
            /), searches are performed relative to this node.

            For example, to get the parent node of a node in the variable n, use
            n.node(\\"..\\"). To get a child node named geo5, use n.node(\\"geo5\\"). To
            get a sibling node named light3, use n.node(\\"../light3\\").

            Note that the return value may be an instance of a subclass of Node.
            For example, if the node being found is an object node, the return
            value will be a hou.ObjNode instance.

            If the path is an absolute path (i.e. it starts with /), this method
            is a shortcut for hou.node(node_path). Otherwise, it is a shortcut
            for hou.node(self.path() + \\"/\\" + node_path). See also hou.node_.


        '''
    def nodes(self, node_paths: Sequence[str]) -> Tuple[Node, ...]:
        """

        nodes(self, node_path_tuple) -> tuple of hou.Node or None

            This is like node() but takes multiple paths and returns multiple
            Node objects. This is the equivalent of:

          > nodes = [self.node(path) for path in paths]

        """
    def item(self, item_path: str) -> Optional[NetworkMovableItem]:
        '''

        item(self, item_path) -> hou.NetworkMovableItem or None

            Return the network item at the given path, or None if no such item
            exists. If you pass in a relative path (i.e. the path does not start
            with /), searches are performed relative to this node.

            If the path is an absolute path (i.e. it starts with /), this method
            is a shortcut for hou.item(node_path). Otherwise, it is a shortcut
            for hou.item(self.path() + \\"/\\" + item_path). See also hou.item.

            Note that the return value may be an instance of a subclass of
            NetworkMovableItem. For example, if the item being found is an
            object node, the return value will be a hou.ObjNode instance. If the
            item is a network box, the return value will be a hou.NetworkBox
            instance.


        '''
    def items(self, item_paths: Sequence[str]) -> Tuple[NetworkMovableItem, ...]:
        """

        items(self, item_path_tuple) -> tuple of hou.NetworkMovableItem or None

            This is like item() but takes multiple paths and returns multiple
            NetworkMovableItem objects. This is the equivalent of:

          > items = [self.item(path) for path in paths]

        """
    def glob(self, pattern: str, ignore_case: bool = False) -> Tuple[Node, ...]:
        '''

        glob(self, pattern, ignore_case=False) -> tuple of hou.Node

            Return a tuple of children nodes name matches the pattern.

            The pattern may contain multiple pieces, separated by spaces. An
            asterisk (*) in a pattern piece will match any character. By
            default, Houdini will add the nodes from each pattern piece to those
            already matched. However, if the pattern piece begins with a caret
            (^), Houdini will remove the matches for that piece from the result.

            By default the pattern match is case-sensitive. Set ignore_case to
            True for case-insensitive pattern matching. Note that case
            insensitivity only applies when matching node names. It does not
            apply when matching group, network box or bundle names.

            This method returns an empty tuple if you pass in an empty pattern.

          > >>> obj = hou.node(\\"/obj\\")
          > >>> obj.createNode(\\"geo\\", \\"geo1\\")
          > <hou.ObjNode of type geo at /obj/geo1>
          > >>> obj.createNode(\\"geo\\", \\"geo2\\")
          > <hou.ObjNode of type geo at /obj/geo2>
          > >>> obj.createNode(\\"geo\\", \\"grid\\")
          > <hou.ObjNode of type geo at /obj/grid>
          > >>> obj.createNode(\\"geo\\", \\"garbage\\")
          > <hou.ObjNode of type geo at /obj/garbage>
          > >>> obj.createNode(\\"geo\\", \\"box\\")
          > <hou.ObjNode of type geo at /obj/box>
          > 
          > >>> def names(nodes):
          > ... return [node.name() for node in nodes]
          > 
          > >>> names(obj.glob(\\"g*\\"))
          > [\'geo1\', \'geo2\', \'grid\', \'garbage\']
          > >>> names(obj.glob(\\"ge* ga*\\"))
          > [\'geo1\', \'geo2\', \'garbage\']
          > >>> names(obj.glob(\\"g* ^ga*\\"))
          > [\'geo1\', \'geo2\', \'grid\']

            See also hou.Node.recursiveGlob.


        '''
    def recursiveGlob(self, pattern: str, filter: EnumValue = ..., include_subnets: bool = ...) -> Tuple[Node,...]:
        """

        recursiveGlob(self, pattern, filter=hou.nodeTypeFilter.NoFilter,
        include_subnets=True) -> tuple of hou.Node

            Like hou.Node.glob, return a tuple of children nodes whose name
            matches the pattern. However, any matching child will have all its
            children added, recursively. As well, the result may be filtered by
            node type.

            Houdini first matches children nodes against the pattern, then
            recursively adds the subchildren of matching children, and then
            applies the filter.


            pattern
                Child node names will be matched against this string pattern.
                See hou.Node.glob and hou.NodeBundle for information about the
                pattern syntax. Note that if a child node matches the pattern
                and include_subnets is True, all of its subchildren will be
                added to the result (subject to filtering), regardless of the
                pattern.

            filter
                A hou.nodeTypeFilter enumeration value to limit matched nodes to
                a particular type (e.g. object nodes, geometry object nodes,
                surface shader SHOPs, etc.).

            include_subnets
                Specifies whether the children of a matching node will also be
                returned, regardless of the pattern.

            The pattern and filter behavior is very similar to that used by node
            bundles in Houdini. See hou.NodeBundle for more information.

            Raises hou.OperationFailed if the pattern is invalid.


        """
    def createNode(self, node_type_name: str, node_name: Optional[str] = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False, force_valid_node_name: bool = False) -> Node:
        '''

        createNode(self, node_type_name, node_name=None, run_init_scripts=True,
        load_contents=True, exact_type_name=False, force_valid_node_name=False)
        -> hou.Node

            Create a new node of type node_type_name as a child of this node.


            node_name
                The name of the new node. If not specified, Houdini appends a
                number to the node type name, incrementing that number until a
                unique node name is found. If you specify a name and a node
                already exists with that name, Houdini will append a number to
                create a unique name.

            run_init_scripts
                If True, the initialization script associated with the node type
                will be run on the new node.

            load_contents
                If True, any subnet contents will be loaded for custom subnet
                operators.

            exact_type_name
                If True, the node\'s type name will be exactly as specified in
                the node_type_name. Otherwise, a preferred operator type that
                matches the given node_type_name may be used. For example, the
                given hda may match a newer version hda::2.0, or if there are
                two available operators namespaceA::hda and namespaceB::hda, and
                the namespaceB has precedence, then the created node will be of
                type namespaceB::hda.

            force_valid_node_name
                If True, then create a new node with a valid name even if
                node_name is invalid. For example, if node_name is =foo bar=,
                then the new node name becomes =foo_bar=. If
                force_valid_node_name is False and node_name is invalid, then
                raise a hou.OperationFailed exception.

            Raises hou.OperationFailed if the given node name is invalid and
            force_valid_node_name is False. Raises hou.OperationFailed if this
            node cannot contain children. Raises hou.PermissionError if this
            node is inside a locked asset.

          > >>> obj = hou.node(\\"/obj\\")
          > 
          > # Let Houdini choose a name based on the node type name.
          > >>> obj.createNode(\\"geo\\")
          > <hou.ObjNode of type geo at /obj/geo1>
          > 
          > # Let Houdini choose a unique name.
          > >>> obj.createNode(\\"geo\\")
          > <hou.ObjNode of type geo at /obj/geo2>
          > 
          > # Give the node a specific name.
          > >>> obj.createNode(\\"geo\\", \\"foo\\")
          > <hou.ObjNode of type geo at /obj/foo>
          > 
          > # Let Houdini create a unique name from our suggested name.  Also, don\'t
          > # run the geometry object init scripts so the contents are empty.
          > >>> obj.createNode(\\"geo\\", \\"geo1\\", run_init_scripts=False)
          > <hou.ObjNode of type geo at /obj/geo3>
          > >>> obj.node(\\"geo1\\").children()
          > (<hou.SopNode of type file at /obj/geo1/file1>,)
          > >>> obj.node(\\"geo3\\").children()
          > ()

        '''
    def inputIndex(self, input_name: str) -> int:
        """

        inputIndex(self, input_name)

            Obtains an index of a node input that has the given name.

            For the node categories that use input names, it returns the index
            of the input with the given name. For VOP nodes, the name may also
            be a node parameter name that has a corresponding input.


        """
    def outputIndex(self, output_name: str) -> int:
        """

        outputIndex(self, output_name)

            Obtains an index of a node output that has the given name.

            For the node categories that use input names, it returns the index
            of the output with the given name.


        """
    def setInput(self, input_index: int, item_to_become_input: NetworkMovableItem|None, output_index: int = ...) -> None:
        """

        setInput(self, input_index, item_to_become_input, output_index=0)

            If item_to_become_input is not None, connect the output connector of
            another node to an input connector of this node. Otherwise,
            disconnect anything connected to the input connector.


            input_index
                The index of this node's input connector.

            item_to_become_input
                If None this method disconnects everything from the input
                connector. If a hou.Node or a hou.SubnetIndirectInput, this
                method connects its output to this node's input connector.

            output_index
                The index of the other node's output connector.

            Raises hou.InvalidInput if output_index is invalid. Raises
            hou.OperationFailed if item_to_become_input is not in the same
            network as this node. Raises hou.PermissionError if the node is
            inside a locked asset.


        """
    def setNamedInput(self, input_name: str, item_to_become_input: NetworkMovableItem, output_name_or_index: str|int) -> None:
        """

        setNamedInput(self, input_name, item_to_become_input,
        output_name_or_index)

            Connects an input on this node, specified by input_name, to an
            output on the item_to_become_input, specified by either an output
            name or an an output index.


        """
    def setFirstInput(self, item_to_become_input: NetworkMovableItem|None, output_index: int = ...) -> None:
        """

        setFirstInput(self, item_to_become_input, output_index=0)

            A shortcut for self.setInput(0, item_to_become_input). See
            hou.Node.setInput for more information.


        """
    def setNextInput(self, item_to_become_input: NetworkMovableItem, output_index: int = 0, unordered_only: bool = False) -> None:
        '''

        setNextInput(self, item_to_become_input, output_index=0,
        unordered_only=False)

            Connect the output connector from another node into the first
            unconnected input connector or a multi-input connector of this node.
            If a node has some ordered inputs followed by a multi-input
            connector, the unordered_only parameter can be used to force the
            input to connect to the unordered multi-input connection instead of
            any of the ordered input which may not be connected.

            This method is roughly equivalent to:

          > for input_index, connectors in enumerate(self.inputConnectors()):
          >     if len(connectors) == 0:
          >         self.setInput(input_index, item_to_become_input, output_index)
          >     raise hou.InvalidInput(\\"All inputs are connected\\")

            Raises hou.InvalidInput if all inputs are connected. See
            hou.Node.setInput for more information.


        '''
    def insertInput(self, input_index: int, item_to_become_input: NetworkMovableItem, output_index: int = 0) -> None:
        """

        insertInput(self, input_index, item_to_become_input, output_index=0)

            Insert an input wire. In other words, for each input connector after
            input_index, shift the contents of that input connector to the next
            one, and then call hou.Node.setInput. See hou.Node.setInput for the
            meanings of the parameters.


        """
    def numOrderedInputs(self) -> int:
        """

        numOrderedInputs(self) -> int

            Some nodes can have a small number of dedicated inputs with specific
            meanings, followed by an arbitrary number of additional inputs,
            where gaps are not permitted between the inputs (these are referred
            to as unordered inputs). This is common in DOP nodes such as the
            Multiple Solver DOP. This function returns the number of dedicated
            (or ordered) inputs that occur before the unordered inputs begin.
            This function will only return non-zero values if the
            hou.NodeType.hasUnorderedInputs function for this node's
            hou.Node.type object returns True.


        """
    def inputs(self) -> Tuple[Self,...]:
        """

        inputs(self) -> tuple of hou.Node

            Return a tuple of the nodes connected to this node's inputs. If an
            input is connected to a hou.SubnetIndirectInput, the node connected
            to the corresponding input on the parent subnet is returned. In
            other words the presence of the indirect input is hidden. This means
            the resulting nodes may not all be siblings of the calling node.

            If a particular input is not connected (or is connected to an
            indirect input and the corresponding subnet parent input is not
            connected), a None value is placed in the tuple at that location.


        """
    def inputsFollowingOutputs(self) -> Tuple[Node, ...]:
        """

        inputsFollowingOutputs(self) -> tuple of hou.Node

            Return a tuple of the nodes connected to this node's inputs.

            If an input is connected to a hou.SubnetIndirectInput, the node
            connected to the corresponding input on the parent subnet is
            returned. In other words the presence of the indirect input is
            hidden. This means the resulting nodes may not all be siblings of
            the calling node.

            In addition, if the input is connected to a non-primary output in
            SOPs, the returned node will be the node inside of the SOP network
            rather than the subnet itself. This can be used for code that
            doesn't understand multiple outputs as it will attempt to resolve
            the node whose first output matches the input of this node.

            If the input is not connected (or is connected to an indirect input
            and the corresponding subnet parent input is not connected), a None
            value is returned.

            If a particular input is not connected (or is connected to an
            indirect input and the corresponding subnet parent input is not
            connected), a None value is placed in the tuple at that location.


        """
    def input(self, input_index: int) -> Self|None:
        """

        input(self, inputidx) -> hou.Node

            Return the node connected to specified input of this node. If an
            input is connected to a hou.SubnetIndirectInput, the node connected
            to the corresponding input on the parent subnet is returned. In
            other words the presence of the indirect input is hidden. This means
            the resulting nodes may not all be siblings of the calling node.

            If the input is not connected (or is connected to an indirect input
            and the corresponding subnet parent input is not connected), a None
            value is returned.


        """
    def inputFollowingOutputs(self, input_index: int) -> Self|None:
        """

        inputFollowingOutputs(self, inputidx) -> hou.Node

            Return the node connected to specified input of this node. If an
            input is connected to a hou.SubnetIndirectInput, the node connected
            to the corresponding input on the parent subnet is returned. In
            other words the presence of the indirect input is hidden. This means
            the resulting nodes may not all be siblings of the calling node.

            In addition, if the input is connected to a non-primary output in
            SOPs, the returned node will be the node inside of the SOP network
            rather than the subnet itself. This can be used for code that
            doesn't understand multiple outputs as it will attempt to resolve
            the node whose first output matches the input of this node.

            If the input is not connected (or is connected to an indirect input
            and the corresponding subnet parent input is not connected), a None
            value is returned.


        """
    def inputConnections(self) -> Tuple[NodeConnection, ...]:
        '''

        inputConnections(self) -> tuple of hou.NodeConnection

            Returns a tuple of hou.NodeConnection objects for the connections
            coming into the top of this node. The tuple will have a length equal
            to the number of connections coming into the node. Returns an empty
            tuple if nothing is connected to this node.

            To get a list of the connected nodes themselves, use
            hou.Node.inputs. To get a list of all possible connection sites
            (whether or not anything is connected to them), use
            hou.Node.inputConnectors.

          > >>> cookie = hou.node(\\"/obj\\").createNode(\\"geo\\").createNode(\\"cookie\\")
          > >>> cookie.setInput(1, cookie.parent().createNode(\\"box\\"))
          > >>> cookie.inputConnections()
          > (<hou.NodeConnection from grid1 output 0 to cookie input 1>,)
          > >>> cookie.inputConnectors()
          > ((), (<hou.NodeConnection from grid1 output 0 to cookie input 1>,))

            See also hou.Node.inputConnectors.


        '''
    def inputConnectors(self) -> Iterator[Tuple[NodeConnection, ...]]:
        """

        inputConnectors(self) -> tuple of tuple of hou.NodeConnection

            Return a tuple of tuples of hou.NodeConnection objects. The length
            of the result tuple is equal to the maximum number of inputs that
            can be connected to this node. Each subtuple contains exactly one
            node connection if something is wired into the connector; otherwise
            it is the empty tuple.

            See also hou.NodeConnection and hou.Node.inputConnections.


        """
    def inputAncestors(self, include_ref_inputs: bool = True, follow_subnets: bool = False, only_used_inputs: bool = False) -> Tuple[Node, ...]:
        """

        inputAncestors(self, include_ref_inputs=True, follow_subnets=False,
        only_used_inputs=False) -> tuple of hou.Node

            Return a tuple of all input ancestors of this node. If
            include_ref_inputs is False, then reference inputs are not
            traversed. If follow_subnets is True, then instead of treating
            subnetwork nodes as a single node, we also traverse its children
            starting with its display node. If only_used_inputs is True, we only
            traverse nodes that were involved in the last cook.

            See also the inputs() method.


        """
    def inputNames(self) -> Tuple[str, ...]:
        """

        inputNames(self) -> tuple of str

            Returns a tuple of all input names for this node. Names for input
            connectors that are hidden are also included.


        """
    def inputLabels(self) -> Tuple[str, ...]:
        """

        inputLabels(self) -> tuple of str

            Returns a tuple of all input labels for this node. Labels for input
            connectors that are hidden are also included.


        """
    def editableInputStrings(self, input_index: int) -> dict[str, str]: ...
    def editableInputString(self, input_index: int, key: str) -> str: ...
    def setEditableInputString(self, input_index: int, key: str, value: str) -> None: ...
    def outputNames(self) -> Tuple[str, ...]:
        """

        outputNames(self) -> tuple of str

            Returns a tuple of all output names for this node.


        """
    def outputLabels(self) -> Tuple[str, ...]:
        """

        outputLabels(self) -> tuple of str

            Returns a tuple of all output labels for this node.


        """
    def outputs(self) -> Tuple[Self,...]:
        """

        outputs(self) -> tuple of hou.Node

            Return a tuple of the nodes connected to this node's outputs.

            This method is a shortcut for [connection.outputNode() for
            connection in self.outputConnections()].


        """
    def outputConnections(self) -> Tuple[NodeConnection, ...]:
        '''

        outputConnections(self) -> tuple of hou.NodeConnection

            Return a tuple of NodeConnection objects for the connections going
            out of the bottom of this node. If nothing is wired into the output
            of this node, return an empty tuple.

            To get a list of the connected nodes themselves, use
            hou.Node.outputs.

            Note that this method is a shortcut for: reduce(lambda a, b: a+b,
            self.outputConnectors(), ()). Since most nodes have only one output
            connector, though, this method is usually equivalent to
            self.outputConnectors()[0].

          > >>> box = hou.node(\\"/obj\\").createNode(\\"geo\\").createNode(\\"box\\")
          > >>> box.parent().createNode(\\"xform\\").setFirstInput(box)
          > >>> box.parent().createNode(\\"subdivide\\").setFirstInput(box)
          > >>> box.outputConnections()
          > (<hou.NodeConnection from box1 output 0 to xform1 output 0>, <hou.NodeConnection from box1 output 0 to subdivide1 input 0>)

            See also hou.node.outputConnectors.


        '''
    def outputConnectors(self) -> Iterator[Tuple[NodeConnection, ...]]:
        '''

        outputConnectors(self) -> tuple of tuple of hou.NodeConnection

            Return a tuple of tuples of hou.NodeConnection objects. The length
            of the result tuple is equal to the number of output connectors on
            this node. Each subtuple contains all the connections going out of
            that connector, and is empty if nothing is wired to that connector.

          > >>> split = hou.node(\\"/obj\\").createNode(\\"dopnet\\").createNode(\\"split\\")
          > >>> split.parent().createNode(\\"rbdsolver\\").setFirstInput(split)
          > >>> split.parent().createNode(\\"gravity\\").setFirstInput(split, 1)
          > >>> split.parent().createNode(\\"merge\\").setFirstInput(split, 1)
          > >>> split.outputConnectors()
          > ((<hou.NodeConnection from split1 output 0 to rbdsolver1 input 0>,), (<hou.NodeConnection from split1 output 1 to gravity2 input 0>, <hou.NodeConnection from split1 output 1 to merge1 input 0>), (), ())

            See also hou.NodeConnection and hou.Node.outputConnections.


        '''
    def children(self) -> Tuple[Node, ...]:
        """

        children(self) -> tuple of hou.Node

            Return a list of nodes that are children of this node. Using the
            file system analogy, a node's children are like the contents of a
            folder/directory.

            To find the number of children nodes, use len(node.children()).

            The order of the children in the result is the same as the user
            defined ordering in Houdini. To see this order, switch the network
            view pane into list mode, and ensure that the list order is set to
            user defined. To reorder nodes, drag and drop them in the list.

          > def pc(node):
          >     '''Print the names of the children of a particular node.  This function
          >        can be handy when working interactively in the Python shell.'''
          >     for child in node.children():
          >         print child.name()
          > 
          > def ls():
          >     '''Print the names of the nodes under the current node.'''
          >     pc(hou.pwd())

            The following expression evaluates to a list of children of a
            particular node type:

          > [c for c in node.children() if c.type() == node_type]

        """
    def allSubChildren(self, top_down: bool = True, recurse_in_locked_nodes: bool = True, sync_delayed_definition: bool = False) -> Tuple[Node, ...]:
        '''

        allSubChildren(self, top_down=True, recurse_in_locked_nodes=True,
        sync_delayed_definition=False) -> tuple of hou.Node

            Recursively return all sub children of this node. For example,
            hou.node(\\"/\\").allSubChildren() will return all the nodes in the hip
            file.


            top_down
                If True, this function will do a top-down traversal, placing a
                node in the returned tuple before its children. If False, it
                will do a bottom-up traversal, placing children before their
                parents.

            recurse_in_locked_nodes
                If True, the function will recurse inside locked child nodes
                (child nodes for which the isEditable() method returns False)
                and include children of the locked child nodes in the returned
                tuple.

                If False, the function will not recurse inside locked children
                nodes, and children of the locked child nodes will not be
                included in the returned tuple. (The locked child nodes,
                however, will be included.)

                For example if <recurse_in_locked_nodes> is True and
                hou.node(\\"/obj/geo1\\") contains a Platonic Solids node (a locked
                node), then the tuple returned by
                hou.node(\\"/obj\\").allSubChildren() will include the Platonic
                Solids node and its child nodes. If <recurse_in_locked_nodes> is
                False, the returned tuple will contain the Platonic Solids node,
                but not its child nodes.

            sync_delayed_definition
                The contents of nodes may some times not be loaded until the
                node is evaluated. To avoid expanding all nodes unnecessarily,
                by default these are left un-expanded so the contents will not
                be returned. Setting <sync_delayed_definition> to True will
                recursively sync all children, fully instantiating the entire
                network, and returning all the synced nodes.

            Note that a tuple is returned, not a generator. This means that it
            is safe to delete or create nodes while looping through the return
            value.

            The following function deletes all children of a particular type
            that appear anywhere inside a given node:

          > def removeSubChildrenOfType(node, node_type):
          >     \'\'\'Recursively delete all children of a particular type.\'\'\'
          >     for child in node.allSubChildren():
          >         if child.type() == node_type:
          >             child.destroy()

            This code, for example, removes all the visibility SOPs anywhere
            under /obj:

          > >>> removeSubChildrenOfType(hou.node(\\"/obj\\"), hou.sopNodeTypeCategory().nodeTypes()[\'visibility\'])

        '''
    def selectedChildren(self, include_hidden: bool = False, include_hidden_support_nodes: bool = False) -> Tuple[Node, ...]:
        '''

        selectedChildren(self, include_hidden=False,
        include_hidden_support_nodes=False) -> tuple of hou.Node

            Return a tuple containing the children of this node that are
            selected. Note that the last selected node has special meaning, and
            can also be retrieved with hou.Node.isCurrent.


            include_hidden
                If False, hidden nodes are not included in the result, even if
                they are selected.

            include_hidden_support_nodes
                If True, include in the returned tuple any hidden nodes that
                exist solely to support nodes that are actually selected. This
                specifically refers to VOP Parameter nodes, but may include
                other support nodes as well.

            The following example will print the names of all selected objects
            in /obj:

          > for n in hou.node(\\"/obj\\").selectedChildren():
          >     print n.name()

            To find the total number of selected children nodes, use
            len(node.selectedChildren()).


        '''
    def allItems(self) -> Tuple[NetworkMovableItem, ...]:
        """

        allItems(self) -> tuple of hou.NetworkMovableItem

            Return a tuple containing all the children of this node. Unlike
            children, this method will also return hou.NetworkBox,
            hou.SubnetIndirectInput, hou.StickyNote, and hou.NetworkDot objects.


        """
    def allSubItems(self, top_down: bool = True, recurse_in_locked_nodes: bool = True, sync_delayed_definition: bool = False) -> Tuple[NetworkMovableItem, ...]:
        '''

        allSubItems(self, top_down=True, recurse_in_locked_nodes=True,
        sync_delayed_definition=False) -> tuple of hou.NetworkMovableItem

            Recursively return all sub items (nodes, network boxes, sticky
            notes, etc.) in this node. For example, hou.node(\\"/\\").allSubItems()
            will return all the node network items in the hip file.

            Refer to hou.Node.allSubChildren for more information on the method
            parameters.


        '''
    def selectedItems(self, include_hidden: bool = False, include_hidden_support_nodes: bool = False) -> Tuple[NetworkMovableItem, ...]:
        '''

        selectedItems(self, include_hidden=False,
        include_hidden_support_nodes=False) -> tuple of hou.NetworkMovableItem

            Return a tuple containing the children of this node that are
            selected. Unlike selectedChildren, this method will also return any
            selected hou.NetworkBox, hou.SubnetIndirectInput, hou.StickyNote,
            and hou.NetworkDot objects.


            include_hidden
                If False, hidden nodes are not included in the result, even if
                they are selected. Other network item types cannot be hidden,
                and so are unaffected by the value of this parameter.

            include_hidden_support_nodes
                If True, include in the returned tuple any hidden nodes that
                exist solely to support nodes that are actually selected. This
                specifically refers to VOP Parameter nodes, but may include
                other support nodes as well.

            The following example will print the positions of all selected items
            in /obj:

          > for n in hou.node(\\"/obj\\").selectedItems():
          >     print n.position()

        '''
    def numItems(self, item_type: Optional[EnumValue] = None, selected_only: bool = False, include_hidden: bool = False) -> int: ...
    def deleteItems(self, items: Iterable[NetworkMovableItem], disable_safety_checks: bool = ...) -> None:
        """

        deleteItems(self, items, disable_safety_checks=False)

            Destroys all the items in the provided tuple of
            hou.NetworkMovableItem objects. This is significantly more efficient
            than looping over the items and calling destroy() on each one. It
            also safely handles cases where one object may not be allowed to be
            deleted unless another object is also deleted.

            Raises hou.OperationFailed if one or more of the provided items is
            not a child of this node. Raises hou.PermissionError if this node is
            or is inside a locked digital asset.

            When disable_safety_checks is True, this disables safety checks that
            might otherwise crash Houdini when this method is called while nodes
            are cooking.


        """
    def copyItemsToClipboard(self, items: Iterable[NetworkMovableItem]) -> None:
        """

        copyItemsToClipboard(self, items)

            Given a sequence of child items (nodes, network boxes, sticky notes,
            etc), save them to the clipboard so they can be pasted into this or
            another network.


            items
                A sequence of hou.NetworkMovableItems that are children of this
                node.

            Raises hou.OperationFailed if any of the nodes or network boxes are
            node children of this node. Raises hou.PermissionError if you do not
            have permission to read the contents of this node.


        """
    def pasteItemsFromClipboard(self, position: Optional[Vector2] = None) -> None:
        """

        pasteItemsFromClipboard(self, position = None)

            Load the contents of a file saved with hou.Node.copyItemsToClipboard
            into the contents of this node. If the position parameter is given
            as a tuple of two float values (or equivalent, like a hou.Vector2),
            the pasted items are moved such that they are centered around the
            provided position.

            Raises hou.OperationFailed if this node is not a network, or if
            there are errors loading the items from the clipboard. Raises
            hou.PermissionError if this node is a locked instance of a digital
            asset.


        """
    def copyItems(self, items: Sequence[NetworkMovableItem], channel_reference_originals: bool = False, relative_references: bool = True, connect_outputs_to_multi_inputs: bool = False) -> Tuple[NetworkMovableItem, ...]:
        """

        copyItems(self, items, channel_reference_originals = False,
        relative_references = True, connect_outputs_to_multi_inputs = True) ->
        tuple of hou.NetworkMovableItem

            Create copies of all specified items in this network. The items do
            not need to be children of this network, but all items must be
            contained in the same parent network.

            If channel_reference_originals is True, the parameters of all new
            nodes are set to channel reference the original nodes. If a copied
            node is a sub-network, only the top level node establishes channel
            references to the original. Child nodes inside the sub-network will
            be simple copies of the original child nodes. The
            relative_references parameter controls whether the channel
            references use relative or absolute paths to the source nodes.

            If connect_outputs_to_multi_inputs is True, and any items being
            copied have outputs connected to a multi-input node (like a Merge),
            then the new item copies will also be connected to the multi-input
            node. Normally copied nodes do not have any outputs to nodes outside
            the copied set.

            Returns a tuple of all the new network items.

            Raises hou.OperationFailed if this node cannot contain children.
            Raises hou.PermissionError if this node is inside a locked asset.


        """
    def creator(self) -> Node:
        """

        creator(self) -> Node

            Returns the first parent of different type from this node. For
            simple networks this will be the same as parent(), but if the parent
            is the same node type, eg, both are SOPs, the process is repeated
            until a different type is found. This is useful for finding the
            container node, for example, the Object that a SOP is in, without
            having to worry about nested SOP networks. Note that SOPs do not
            always have Objects as parents, however!


        """
    def network(self) -> Optional[Node]: ...
    def moveToGoodPosition(self, relative_to_inputs: bool = True, move_inputs: bool = True, move_outputs: bool = True, move_unconnected: bool = True) -> Vector2:
        """

        moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True,
        move_outputs=True, move_unconnected=True) -> hou.Vector2

            Moves a node to a well-spaced position near its inputs or outputs
            and returns the new position of the node.


        """
    def layoutChildren(self, items: Sequence[NetworkMovableItem] = ..., horizontal_spacing: float = ..., vertical_spacing: float = ...) -> None:
        """

        layoutChildren(self, items=(), horizontal_spacing=-1.0,
        vertical_spacing=-1.0)

            Automatically position all or some children of this node in the
            network editor.


            items
                A sequence of child hou.NetworkMovableItem objects to position.
                This may include nodes, dots, and/or subnet inputs. If this
                sequence is empty, this method will reposition all child items
                of this node.

            horizontal_spacing
                A fraction of the width and height of a tile that affects the
                space between nodes with common inputs. If this parameter is -1,
                Houdini uses the default spacing.

            vertical_spacing
                A fraction of the width and height of a tile that affects the
                space between a node and its output nodes. If this parameter is
                -1, Houdini uses the default spacing.


        """
    def isCurrent(self) -> bool:
        """

        isCurrent(self) -> bool

            Return a boolean to indicate of the node is the last selected node
            in its network.

            Each network (i.e. node containing children) stores its own list of
            selected nodes, and the last selected node has special meaning. For
            example, it is the node displayed in unpinned parameter panes.

            See also hou.selectedNodes to get a tuple of all the selected nodes
            in all networks in Houdini. The last node in this list also has
            special meaning in Houdini, and corresponds to the global current
            node.


        """
    def setCurrent(self, on: bool, clear_all_selected: bool = False) -> None:
        """

        setCurrent(self, on, clear_all_selected=False)

            Set or unset this node as the last selected one.

            Each network (i.e. node containing children) stores its own list of
            selected nodes, and the last selected node has special meaning. For
            example, it is the node displayed in unpinned parameter panes.

            If on is True, this node will become the last selected node. If it
            is False and this node was the last selected one, it will be
            unselected and the second-last selected node will become the last
            selected node.

            If clear_all_selected is true, Houdini will unselect every node in
            this network before performing the operation.

            See also hou.Node.setSelected and hou.selectedNodes.


        """
    def isHidden(self) -> bool:
        """

        isHidden(self)

            Return whether the node is hidden in the network editor. Note that
            Houdini also uses the term exposed to refer to nodes that are not
            hidden.

            If a visible node is connected to a hidden node, the network editor
            will display dashed lines for the wire going from the visible node
            to the hidden node.

            See also hou.Node.hide.


        """
    def hide(self, on: bool) -> None:
        """

        hide(self, on)

            Hide or show a node in the network editor. See hou.Node.isHidden for
            more information about hidden nodes.


        """
    def comment(self) -> str:
        """

        comment(self) -> str

            Return the node's comment string.


        """
    def setComment(self, comment: str) -> None:
        """

        setComment(self, comment)

            Sets the comment associated with this node. See also
            appendComment().


        """
    def appendComment(self, comment: str) -> None:
        """

        appendComment(self, comment)

            Appends the given text to the comment associated with this node.


        """
    def destroy(self, disable_safety_checks: bool = False) -> None:
        """

        destroy(self, disable_safety_checks=False)

            Delete this node.

            If you call methods on a Node instance after it has been destroyed,
            Houdini will raise hou.ObjectWasDeleted.

            Raises hou.OperationFailed if you try to delete a node inside a
            locked asset.

            When disable_safety_checks is True, this disables safety checks that
            might otherwise crash Houdini when this method is called while nodes
            are cooking.


        """
    def networkBoxes(self) -> Tuple[NetworkBox, ...]:
        """

        iterNetworkBoxes(self) -> generator of hou.NetworkBox

            Return a generator that iterates through all the network boxes
            inside this node.


        """
    def iterNetworkBoxes(self) -> Iterator[NetworkBox]: ...
    def createNetworkBox(self, name: Optional[str] = None) -> NetworkBox:
        """

        createNetworkBox(self, name=None) -> hou.NetworkBox

            Creates a network box inside this network. Raises
            hou.OperationFailed if this node is not a network.

            If you don't specify a name, Houdini gives the box a default name.

            Network box names are not displayed in the network editor pane.
            Instead, a comment can be specified with the
            hou.NetworkBox.setComment method, and this comment will appear in
            the title bar of the network box.


        """
    def copyNetworkBox(self, network_box_to_copy: NetworkBox, new_name: Optional[str] = None, channel_reference_original: bool = False) -> NetworkBox:
        """

        copyNetworkBox(self, network_box_to_copy, new_name=None,
        channel_reference_original=False) -> hou.NetworkBox

            Copies a network box and returns the copy.

            If new_name is given, the network box will be copied to a new
            network box named new_name (a different name will be generated if
            there is already a network box with that name).

            If channel_reference_original is True, all operators created by the
            copy will have their animatable parameters set to reference the
            original operators.

            Raises hou.OperationFailed if this node is not a network or if the
            node child type does not match the network box's node type.


        """
    def findNetworkBox(self, name: str) -> Optional[NetworkBox]:
        """

        findNetworkBox(self, name) -> hou.NetworkBox

            Return a network box with the given name inside this node, or None
            if no network box with the given name exists.


        """
    def findNetworkBoxes(self, pattern: str) -> Tuple[NetworkBox, ...]:
        """

        findNetworkBoxes(self, pattern) -> tuple of hou.NetworkBox

            Return a list of network boxes inside this node whose names match a
            pattern.


        """
    def networkDots(self) -> Tuple[NetworkDot, ...]:
        """

        networkDots(self) -> tuple of hou.NetworkDot

            Returns a tuple of all dots in this network.


        """
    def createNetworkDot(self) -> NetworkDot:
        """

        createNetworkDot(self) -> hou.NetworkDot

            Creates a network dot inside this network. Raises
            hou.OperationFailed if this node is not a network.


        """
    def canCreateDigitalAsset(self) -> bool:
        """

        canCreateDigitalAsset(self) -> bool

            Return True if a digital asset can be created from this node (for
            example, whether hou.OpNode.createDigitalAsset can succeed).


        """
    def collapseIntoSubnet(self, child_items: Sequence[NetworkMovableItem], subnet_name: Optional[str] = None, subnet_type: Optional[str] = None) -> Node:
        """

        collapseIntoSubnet(self, child_nodes, subnet_name=None,
        subnet_type=None) -> hou.Node

            Given a sequence of children nodes of this node, collapse them into
            a subnetwork. In other words, create a subnet inside this node's
            network and move the specified children of this network inside that
            subnet.


            child_nodes
                The children nodes of this node that will go in the new subnet.

            subnet_name
                The name for the new subnet node, or None if you want Houdini to
                automatically choose a name.

            subnet_type
                The type for the new subnet node, or None if you want Houdini to
                automatically choose a primary subnetwork type, which is
                recommended.

            Raises hou.OperationFailed if a node inside child_nodes is not a
            child of this network, or if child_nodes is an empty sequence.

            This example function takes a single node and replaces it with a
            subnet, moving the node into the subnet..

          > def collapseSingleNodeIntoSubnet(node, subnet_name=None):
          >     node.parent().collapseIntoSubnet((node,), subnet_name=None)

        """
    def extractAndDelete(self) -> Tuple[NetworkMovableItem, ...]:
        """

        extractAndDelete(self) -> tuple of hou.NetworkMovableItem

            Move the children of this subnet node to become siblings of this
            node, and then delete this node. The method is the opposite of
            collapseIntoSubnet(). Returns a tuple containing all extracted
            items.

            Raises hou.InvalidNodeType if this node is not a subnetwork.


        """
    def indirectInputs(self) -> Tuple[SubnetIndirectInput, ...]:
        """

        indirectInputs(self) -> tuple of hou.SubnetIndirectInput

            Return the hou.SubnetIndirectInput objects of a subnet.

            Raises hou.InvalidNodeType if this node is not a subnetwork.


        """
    def subnetOutputs(self) -> Tuple[Node, ...]:
        """

        subnetOutputs(self) -> tuple of hou.Node

            Return the child output nodes of a subnetwork.

            Certain networks, such as SOPs, have special Output nodes to
            override the canonical Display or Render nodes and allow multiple
            outputs. If any output nodes are present, this returns a list of
            those nodes. If no output nodes are present, either the display or
            render node is returned depending on if the target of cooking is the
            display or an output driver. If the node has no children, an empty
            list is returned.


        """
    def isSubNetwork(self) -> bool:
        """

        isSubNetwork(self) -> bool

            Return True if the node is a sub-network and False otherwise.


        """
    def setUserData(self, name: str, value: str) -> None:
        '''

        setUserData(self, name, value)

            Add/set a named string on this node instance.


            name
                A unique name (key) for the user-defined data. By using
                different names, you can attach multiple pieces of user-defined
                data to a node.

            value
                The string to store.

            This name/value pair is stored with the hip file and is included in
            the output from opscript and hou.Node.asCode.

            The following example illustrates how to set, access, and delete
            user-defined data:

          > >>> n = hou.node(\\"/obj\\").createNode(\\"geo\\")
          > >>> n.setUserData(\\"my data\\", \\"my data value\\")
          > >>> n.userData(\\"my data\\")
          > \'my data value\'
          > >>> n.userDataDict()
          > {\'my data\': \'my data value\'}
          > >>> n.destroyUserData(\\"my data\\")
          > >>> n.userDataDict()
          > {}
          > >>> print n.userData(\\"my data\\")
          > None

            See per-node user-defined data for more information and examples.


            TIP
                If you prefix a user data key with nodeinfo_, the key (without
                the prefix) and the value will be shown as a custom field in the
                node info popup window.


        '''
    def destroyUserData(self, name: str, must_exist: bool = True) -> None:
        """

        destroyUserData(self, name, must_exist=True)

            Remove the user-defined data with this name.

            See hou.Node.setUserData for more information.

            Raises hou.OperationFailed if no user data with this name exists and
            must_exist is True.


        """
    def clearUserDataDict(self) -> None:
        """

        clearUserDataDict(self)

            Remove all user-defined data.

            See hou.Node.setUserData for more information.


        """
    def userDataDict(self) -> dict[str, str]:
        """

        userDataDict(self) -> dict of str to str

            Return a dictionary containing all the user-defined name/string
            pairs for this node.

            See hou.Node.setUserData for more information.


        """
    def userData(self, name: str) -> str|None:
        """

        userData(self, name) -> str or None

            Return the user-defined data with this name, or None if no data with
            this name exists.

            See hou.Node.setUserData for more information.

            This method can be implemented as follows:

          > def userData(self, name):
          >     return self.userDataDict().get(name)

        """
    def createStickyNote(self, name: Optional[str] = None) -> StickyNote:
        """

        createStickyNote(self, name=None) -> hou.StickyNote

            Creates a sticky note inside this network. Raises
            hou.OperationFailed if this node is not a network.

            If you don't specify a name, Houdini gives the note a default name.


        """
    def stickyNotes(self) -> Tuple[StickyNote, ...]:
        """

        iterStickyNotes(self) -> generator of hou.StickyNote

            Return a generator that iterates through all the sticky notes inside
            this node.


        """
    def iterStickyNotes(self) -> Iterator[StickyNote]: ...
    def copyStickyNote(self, sticky_note_to_copy: StickyNote, new_name: Optional[str] = None) -> StickyNote:
        """

        copyStickyNote(self, network_box_to_copy, new_name=None) ->
        hou.StickyNote

            Copies a sticky note and returns the copy.

            If new_name is given, the sticky note will be copied to a new sticky
            note named new_name (a different name will be generated if there is
            already a sticky note with that name).

            Raises hou.OperationFailed if this node is not a network or if the
            node child type does not match the sticky note's node type.


        """
    def findStickyNote(self, name: str) -> Optional[StickyNote]:
        """

        findStickyNote(self, name) -> hou.StickyNote

            Return a sticky note with the given name inside this node, or None
            if no sticky note with the given name exists.


        """
    def findStickyNotes(self, pattern: str) -> Tuple[StickyNote, ...]:
        """

        findStickyNotes(self, pattern) -> tuple of hou.StickyNote

            Return a list of sticky notes inside this node whose names match a
            pattern.


        """

    # Missing methods added by stubgen
    def createOutputNode(self, node_type_name: str, node_name: str | None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False) -> Self: ...
    def createInputNode(self, input_index: int, node_type_name: str, node_name: str | None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False) -> Self: ...
    def creationTime(self) -> datetime.datetime: ...
    def modificationTime(self) -> datetime.datetime: ...
    def outputsWithIndices(self, ignore_network_dots: bool = False, use_names: bool = False) -> list[tuple[NetworkMovableItem, int | str, int | str]]: ...

class ApexNode(Node):
    """

    hou.ApexNode

    Represents an APEX node.

    This class represents an APEX node that lives in an APEX graph owned by
    the Houdini session. Each node has a unique session ID that can be used
    to obtain it from hou.apexNodeBySessionId().

    RELATED

      * hou.apexNodeBySessionId


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def inputName(self, input_index: int) -> str:
        """

        inputName(self, input_index) -> str

            Returns the node input port name.


        """
    def setInputName(self, input_index: int, name: str) -> None:
        """

        setInputName(self, input_index, name)

            Sets the node input port name.


        """
    def canRenameInput(self, input_index: int) -> bool:
        """

        canRenameInput(self, input_index) -> bool

            Only variadic and dynamic ports can be renamed on APEX nodes. Use
            this to determine if an input can be renamed.


        """
    def outputName(self, output_index: int) -> str:
        """

        outputName(self, output_index) -> str

            Returns the node output port name.


        """
    def setOutputName(self, output_index: int, name: str) -> None:
        """

        setOutputName(self, output_index, name)

            Sets the node output port name.


        """
    def canRenameOutput(self, output_index: int) -> bool:
        """

        canRenameOutput(self, output_index) -> bool

            Only variadic and dynamic ports can be renamed on APEX nodes. Use
            this to determine if an output can be renamed.


        """
    def convertSubgraphToSubnet(self) -> None:
        """

        convertSubgraphToSubnet(self)

            Converts a node representing a subgraph asset into a subnet,
            maintaining all connections and parameters.


        """
    def inputDataTypes(self) -> Tuple[str, ...]:
        """

        inputDataTypes(self) -> tuple of str

            Returns a tuple of all input data types for this node.


        """
    def outputDataTypes(self) -> Tuple[str, ...]:
        """

        outputDataTypes(self) -> tuple of str

            Returns a tuple of all output data types for this node.


        """
    def tags(self) -> Tuple[str, ...]:
        """

        tags(self) -> tuple of str

            Returns a list of string tags for this node.


        """
    def setTags(self, tags: Sequence[str]) -> None:
        """

        setTags(self, tags)

            Sets the given list of string tags for this node.


        """
    def isSubgraphAsset(self) -> bool:
        """

        isSubgraphAsset(self) -> bool

            Returns true if this node represents a subgraph asset. This is
            similar in concept to a locked HDA subnet. These nodes have children
            that can be queried but are not editable.


        """

class OpNode(Node):
    """

    hou.OpNode

    The base class for all nodes in Houdini (objects, SOPs, COPs, etc.) An
    instance of this class corresponds to exactly one instance of a node in
    Houdini.

    Each node has a unique path that defines its location in the tree of
    nodes. The node path hierarchy is similar to the hierarchy of folders
    and files in a file system. Some nodes, called networks, may contain
    other nodes inside them, much like a file folder would, while other
    nodes may not. For example, an object node instance and a SOP subnetwork
    node instance may contain SOP nodes, but a box SOP instance may not.


    TIP
        Be careful not to confuse nodes with node types. A node is an
        instance of a node type. For example suppose /obj/geo1/box1 is a box
        SOP. It has its own unique name (box1) and its own copies of
        parameter values. It is an instance of the box SOP node type. This
        node type defines what parameters are common to all box SOP node
        instances, as well as the algorithm that each BOX SOP performs. The
        class that represents a node type is hou.NodeType.

    You cannot create instances of hou.Node using hou.Node.__init__.
    Instead, you look up Node objects corresponding to existing Houdini
    nodes with hou.node(). To create a new Houdini node instance inside
    another node, use hou.Node.createNode. To delete a Houdini node, use
    hou.Node.destroy.

    Note that a Node object internally stores a reference to the
    corresponding Houdini node, and that their lifetimes are different. If a
    Python node object is deleted because its reference count in Python goes
    to zero, the Houdini node will be unaffected. On the other hand, if you
    have a Node object in a Python variable and the Houdini node is deleted,
    the Python variable will still exist, and Python will not crash.
    Instead, if you later call a method on that Python Node object, Houdini
    will raise a hou.ObjectWasDeleted exception.

    Be careful not to confuse this class with the function hou.node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def creatorState(self) -> str:
        """

        creatorState(self) -> str

            This returns the name of the viewport tool that was used to be
            created. This name is not set by default and is usually the empty
            string.


        """
    def setCreatorState(self, state: str) -> None:
        """

        setCreatorState(self, state)

            This sets the name of the tool that created this node. If you call
            this with a name that differs from the node type name, you should
            also call setBuiltExplicitly(False).


        """
    def isBuiltExplicitly(self) -> bool: ...
    def setBuiltExplicitly(self, built_explicitly: bool) -> None: ...
    def expressionLanguage(self) -> EnumValue:
        """

        expressionLanguage(self) -> hou.exprLanguage enum value

            Return the node's default expression language.

            When you enter an expression in a parameter that does not already
            contain an expression, the node's expression language is used to
            determine how that expression should be evaluated. You can change a
            node's expression language in the parameter dialog in the GUI.

            Changing the node's expression language will not change the language
            in parameters already containing expressions (i.e. parameters with
            keyframes).

            Note that if a parameter already contains an expression and you
            change that expression in the GUI, the expression language will not
            change, regardless of the value of the node's expression language.
            To change the language of an existing expression in a parameter from
            Python, use hou.Parm.setExpression, as in
            parm.setExpression(parm.expression(), language).


        """
    def setExpressionLanguage(self, language: EnumValue) -> None:
        """

        setExpressionLanguage(self, language)

            Set the node's default expression language. See expressionLanguage()
            for more information.


        """
    def parm(self, parm_path: str) -> Optional[Parm]:
        """

        parm(self, parm_path) -> hou.Parm or None

            Return the parameter at the given path, or None if the parameter
            doesn't exist.


        """
    def parmTuple(self, parm_path: str) -> Optional[ParmTuple]:
        """

        parmTuple(self, parm_path) -> hou.ParmTuple or None

            Return the parm tuple at the given path, or None if it doesn't
            exist.

            This method is similar to parm(), except it returns a hou.ParmTuple
            instead of a hou.Parm.


        """
    def globParms(self, pattern: str, ignore_case: bool = False, search_label: bool = False, single_pattern: bool = False) -> Tuple[Parm, ...]:
        """

        globParms(self, pattern, ignore_case=False, search_label=False,
        single_pattern=False) -> tuple of hou.Parm

            Return a tuple of parameters matching the pattern.

            The pattern may contain multiple pieces, separated by spaces. An
            asterisk (*) in a pattern piece will match any character. By
            default, Houdini will add the parameters from each pattern piece to
            those already matched. However, if the pattern piece begins with a
            caret (^), Houdini will remove the matches for that piece from the
            result.

            By default the pattern match is case-sensitive. Set ignore_case to
            True for case-insensitive pattern matching. Note that case
            insensitivity only applies when matching node and parameter names.
            It does not apply when matching group, network box or bundle names.

            By default, only parameters with names matching the pattern are
            returned. Set search_label to True to also return parameters with
            labels matching the pattern.

            If single_pattern is True, the pattern will be treated as one
            pattern even if there are spaces in the pattern.

            This method returns an empty tuple if you pass in an empty pattern.


        """
    def parms(self) -> Tuple[Parm, ...]:
        """

        parms(self) -> tuple of hou.Parm

            Return a list of the parameters on this node.


        """
    def parmsReferencingThis(self) -> Tuple[Parm, ...]:
        """

        parmsReferencingThis(self) -> tuple of hou.Parm

            Return a list of the parameters that reference this node.


        """
    def parmTuples(self) -> Tuple[ParmTuple, ...]:
        """

        parmTuples(self) -> tuple of hou.ParmTuple

            Return a list of all parameter tuples on this node.

            This method is similar to parms(), except it returns a list of
            hou.ParmTuple instead of hou.Parm.


        """
    def spareParms(self) -> Tuple[Parm, ...]:
        """

        spareParms(self) -> tuple of hou.Parm

            Return a list of the spare (user-defined) parameters on this node.


        """
    def removeSpareParms(self) -> None:
        """

        removeSpareParms(self)

            Removes all spare parameters from this node.


        """
    def syncNodeVersionIfNeeded(self, from_version: str) -> None:
        """

        syncNodeVersionIfNeeded(self, from_version)

            Synchronize the node from the specified version to the current
            version of its HDA definition. See also hou.HDADefinition.version.


        """
    def setParmTemplateGroup(self, parm_template_group: ParmTemplateGroup, rename_conflicting_parms: bool = False) -> None: ...
    def parmTuplesInFolder(self, folder_names: Sequence[str]) -> Tuple[ParmTuple, ...]:
        """

        parmTuplesInFolder(self, folder_names) -> tuple of hou.ParmTuple

            Return a list of the parameter tuples in a folder on this node. This
            method is similar to parmsInFolder(), except it returns a list of
            hou.ParmTuple instead of hou.Parm. See parmsInFolder() above for
            information about the arguments.

            See also hou.Parm.containingFolders and
            hou.Parm.containingFolderSetParmTuples


        """
    def parmsInFolder(self, folder_names: Sequence[str]) -> Tuple[Parm, ...]:
        '''

        parmsInFolder(self, folder_names) -> tuple of hou.Parm

            Return a list of parameters in a folder on this node. Returns all
            parameters in the folder and its subfolders (if any).


            folder_names
                A sequence of folder name strings. For example, to get a list of
                the parameters in the Shading folder of the Render folder, use
                (\\"Render\\", \\"Shading\\"). Note that by folder name, we mean the
                label used in the parameter dialog, not the internal parameter
                name.

                If this sequence is empty, the method returns all parameters on
                the node, the same as if you called parms().

            Raises hou.OperationFailed if the folder specified by folder_names
            does not exist.

            For example, suppose a node had a Render folder that contained a
            Shading subfolder. Then this line of code would return the
            parameters in the Render folder:

          > # Note the trailing comma after \\"Render\\" to tell Python that \\"Render\\" is
          > # contained in a tuple/sequence as opposed to just a single string with
          > # parentheses around it.
          > >>> node.parmsInFolder((\\"Render\\", ))

            And this line of code would return the parameters in the Shading
            subfolder.

          > >>> node.parmsInFolder((\\"Render\\", \\"Shading\\"))

            See also hou.Parm.containingFolders and
            hou.Parm.containingFolderSetParmTuples

            Note that this method does not work for multi-parameters, which
            behave similar to folder parameters. To get a list of parameters in
            a multi-parameter, call hou.Parm.multiParmInstances.


        '''
    def parmTemplateGroup(self) -> ParmTemplateGroup: ...
    def localVariables(self) -> Tuple[str, ...]:
        """

        localVariables(self)

            Return a list of local variables that can be referenced in parameter
            expressions on this node using the $ prefix.


        """
    def localAttributes(self) -> Tuple[str, ...]:
        """

        localAttributes(self)

            Return a list of local variables that can be referenced in parameter
            expressions on this node using the @ prefix. This includes local
            variables defined in this node as attributes and any context options
            that were available to this node the last time it was cooked.


        """
    def reorderChild(self, src: int, dest: int) -> None:
        """

        reorderChild(src, dest)

            If this node is a network, re-order the user-defined order of its
            children by taking the child at index src and moving it to index
            dest, shifting over the children in between. After the reorder, the
            moving child will be directly before the child formerly at index
            dest. To move a child to the very end of the list, set dest to be
            equal to the number of children.

            Raises hou.OperationFailed if this node is not a network. Raises
            hou.PermissionError if this node is or is inside a locked digital
            asset.


        """
    def references(self, include_children: bool = True) -> Tuple[Node, ...]:
        """

        references(self, include_children = True) -> tuple of hou.Node

            Return a tuple of nodes that are referenced by this node, either
            through parameter expressions, referring to the node by name, or
            using expressions which rely on the data generated by another node.
            These reflect all the other ways (besides connecting to an input) in
            which one node may affect another.

            Note that the result can differ depending last cook of the nodes.
            It's recommended that you first call cook() on the node first.


        """
    def dependents(self, include_children: bool = True) -> Tuple[Node, ...]:
        """

        dependents(self, include_children = True) -> tuple of hou.Node

            Return a tuple of nodes that are reference this node, either through
            parameter expressions, referring to the node by name, or using
            expressions which rely on the data generated by this node. These
            reflect all the other ways (besides connecting to an input) in which
            one node may affect another.

            Note that the result can differ depending last cook of the nodes.


        """
    def fileReferences(self, recurse: bool = ..., project_dir_variable: str = ..., include_all_refs: bool = ...) -> Sequence[Tuple[Parm, str]]:
        '''

        fileReferences(self, recurse = True, project_dir_variable = \\"HIP\\",
        include_all_refs = True) -> tuple of hou.Parm and str tuples

            Returns a sequence of tuples representing references to external
            files (such as textures, geometry files, and asset libraries) from
            this node. Applies to all sub children of this node if recurse is
            set to true.


            recurse
                Recursively apply to the entire operator hierarchy.

            project_dir_variable
                You can specify the name of an environment variable. If an asset
                path starts with the variable, it will be replaced with a
                variable reference in the path string returned by this function.

            include_all_refs
                If this is True, then the function will return all the file
                references. If this is False, then the function will return only
                the selected file references.

            See also hou.fileReferences


        '''
    def isTimeDependent(self, for_last_cook: bool = False) -> bool:
        """

        isTimeDependent(self, for_last_cook=False) -> bool

            Return whether the node is time dependent. A time dependent node is
            re-evaluated every time the frame changes.

            By default, this will cook out-of-date nodes first to get the latest
            time dependency status. Pass in for_last_cook=True to get the time
            dependency status of the last node cook to avoid this.


        """
    def allowEditingOfContents(self, propagate: bool = False) -> None:
        """

        allowEditingOfContents(self, propagate=False)

            Unlocks a digital asset so its contents can be edited.

            To use this function, you must have permission to modify the HDA.


        """
    def matchCurrentDefinition(self) -> None:
        """

        matchCurrentDefinition(self)

            If this node is an unlocked digital asset, change its contents to
            match what is stored in the definition and lock it. The parameter
            values are unchanged.

            If this node is locked or is not a digital asset, this method has no
            effect.

            See also hou.Node.matchesCurrentDefinition and hou.Node.isLocked.


        """
    def matchesCurrentDefinition(self) -> bool:
        """

        matchesCurrentDefinition(self) -> bool

            Return whether the contents of the node are locked to its type
            definition.


        """
    def syncDelayedDefinition(self) -> None:
        """

        syncDelayedDefinition(self)

            If this node is a digital assets whose contents are currently in a
            delay-sync condition, the contents will be synced. If it is already
            synced or not a syncable asset, no effect occurs.


        """
    def isDelayedDefinition(self) -> bool:
        """

        isDelayedDefinition(self) -> bool

            If this node is a digital assets whose contents are currently in a
            delay-sync condition, returns true. Otherwise returns false, which
            will include nodes that are not syncable.


        """
    def parmAliases(self, recurse: bool = False) -> dict[Parm, str]:
        """

        parmAliases(self, recurse=False) -> dict of hou.Parm to str

            Return a dictionary of parameter aliases on the node's parameters.
            The keys in the dictionary are the parameters that have aliases and
            the values are the alias names.


            recurse
                Return the parameter aliases for this node and its children.


        """
    def clearParmAliases(self) -> None:
        """

        clearParmAliases(self)

            Removes all alias names from parameters on the node.


        """
    def createCompiledDigitalAsset(self, name: Optional[str] = None, hda_file_name: Optional[str] = None, description: Optional[str] = None) -> None:
        """

        createCompiledDigitalAsset(self, name=None, hda_file_name=None,
        description=None)

            Create a compiled digital asset from this node. You would typically
            call this method on VOP network nodes, such as Material Shader
            Builder SHOP, Surface Shader Builder SHOP, or VEX Surface SHOP Type
            VOPNET. The digital asset does not have contents section, which
            means it does not have VOP network inside, but instead relies on the
            saved VEX code sections to provide the shader code.

            After the creation of a compiled HDA, if its VEX code section is
            ever changed manually, the corresponding vex object code section can
            be recompiled using hou.HDADefinition.compileCodeSection.


            name
                The name of the node type that the new digital asset will
                define.

            hda_file_name
                The name of the hda file where Houdini will save the digital
                asset. If None Houdini will use
                $HOME/houdiniX.Y/hda/OPcustom.hda.

            description
                The name that will appear in the tab menu. If None, Houdini will
                use the name for the description.


        """
    def isInsideLockedHDA(self) -> bool:
        """

        isInsideLockedHDA(self) -> bool

            Return whether this node is inside a locked digital asset. If this
            node is not inside a locked HDA, the node may deviate from the HDA
            definition.


        """
    def isEditableInsideLockedHDA(self) -> bool:
        """

        isEditableInsideLockedHDA(self) -> bool

            Return False if the node is contained inside a locked HDA node and,
            is not marked as editable within that locked HDA, and True
            otherwise. In particular this function will return True for a node
            that is not inside a locked HDA (or not inside an HDA at all).


        """
    def isLockedHDA(self) -> bool:
        """

        isLockedHDA(self) -> bool

            If this node is an instance of a digital asset, return whether or
            not it is locked. Otherwise, return False.

            To differentiate between unlocked digital assets and nodes that are
            not instances of digital assets, check if the node's type has a
            definition:

          > def isUnlockedAsset(node):
          >     return not node.isLockedHDA() and node.type().definition() is not None

            See hou.HDADefinition.updateFromNode for an example of how to save
            and lock all unlocked digital asset instances.


        """
    def isCompiled(self) -> bool: ...
    def isMaterialManager(self) -> bool: ...
    def outputLabel(self, output_index: int) -> str:
        """

        outputLabel(output_index) -> str

            Returns label of the specified output on this node. This function
            may return a generic label if the index refers to a non-existent
            output.


        """
    def outputForViewFlag(self) -> int:
        """

        outputForViewFlag(self) -> int

            Return an integer to indicate which output of the node should be
            used for display purposes.


            WARNING
                This method can return a negative number if a surface node asset
                uses an Output node with its index set to -1. Some nodes use
                this trick to show preview geometry in the viewer, so to be
                fully robust your code should deal with values less than 0
                (unfortunately it's not clear which output to actually use in
                the case).


        """
    def setOutputForViewFlag(self, output: int) -> None:
        """

        setOutputForViewFlag(self, output)

            Sets which output should be used for display purposes on this node.


        """
    def hdaModule(self) -> HDAModule:
        """

        hm(self) -> hou.HDAModule

            This method is a shortcut for self.hdaModule().

            See also hou.phm.


        """
    def hdaViewerStateModule(self) -> Optional[HDAViewerStateModule]:
        """

        hdaViewerStateModule(self) -> hou.HDAViewerStateModule

            This method creates an instance of hou.HDAViewerStateModule
            associated to the underlying Node.

            See also hou.NodeType.hdaViewerStateModule.


        """
    def hdaViewerHandleModule(self) -> Optional[HDAViewerHandleModule]:
        """

        hdaViewerHandleModule(self) -> hou.HDAViewerHandleModule

            This method creates an instance of hou.HDAViewerHandleModule
            associated to the underlying Node.

            See also hou.NodeType.hdaViewerHandleModule.


        """
    def hm(self) -> HDAModule: ...
    def createDigitalAsset(self, name: Optional[str] = None, hda_file_name: Optional[str] = None, description: Optional[str] = None, min_num_inputs: int = 0, max_num_inputs: int = 0, compress_contents: bool = False, comment: Optional[str] = None, version: Optional[str] = None, save_as_embedded: bool = False, ignore_external_references: bool = False, compile_asset: bool = False, change_node_type: bool = True, create_backup: bool = True, install_path: Optional[str] = None) -> OpNode:
        """

        createDigitalAsset(self, name=None, hda_file_name=None,
        description=None, min_num_inputs=0, max_num_inputs=0,
        compress_contents=False, comment=None, version=None,
        save_as_embedded=False, ignore_external_references=False,
        change_node_type=True, create_backup=True, install_path=None) -> Node

            Create a digital asset from this node. You would typically call this
            method on subnet nodes.


            name
                The name of the node type that the new digital asset will
                define.

            hda_file_name
                The name of the hda file where Houdini will save the digital
                asset. If None Houdini will use
                $HOME/houdiniX.Y/hda/OPcustom.hda.

            description
                The name that will appear in the tab menu. If None, Houdini will
                use the name for the description.

            min_num_inputs
                The minimum number of inputs that need to be wired into
                instances of the digital asset. See
                hou.HDADefinition.minNumInputs for more information.

            max_num_inputs
                The number of input connectors available on instances of the
                digital asset for input connections. See
                hou.HDADefinition.minNumInputs for more information.

            compress_contents
                Whether or not the contents of this digital asset are compressed
                inside the hda file. See hou.HDAOptions.compressContents for
                more information.

            comment
                A user-defined comment string. See hou.HDADefinition.comment for
                more information.

            version
                A user-defined version string. See hou.HDADefinition.version for
                more information.

            save_as_embedded
                Whether or not the digital asset's definition will be saved with
                the hip file instead of an hda file. When this parameter is
                True, Houdini ignores the hda_file_name parameter. Setting this
                parameter to True is equivalent to setting this parameter to
                False and setting the hda_file_name parameter to Embedded.

            ignore_external_references
                If True, Houdini will not generate warnings if the contents of
                this digital asset reference nodes outside the asset.

            change_node_type
                Normally, Houdini will change the node creating the digital
                asset into the new digital asset type. Setting this flag to
                false will cause the node to remain unchanged.

            create_backup
                Create a backup before modifying an existing hda file.

            install_path
                Where to install the new hda. When not specified, it will
                install to either Current HIP File or Scanned Asset Library
                Directories.


        """
    def changeNodeType(self, new_node_type: str, keep_name: bool = True, keep_parms: bool = True, keep_network_contents: bool = True, force_change_on_node_type_match: bool = False) -> ChopNode:
        """

        changeNodeType(self, new_node_type, keep_name=True, keep_parms=True,
        keep_network_contents=True, force_change_on_node_type_match=False) ->
        hou.Node

            Changes the node to a new type (within the same context).
            new_node_type is the internal string name of the type you want to
            change to.

            Keep_name, keep_parms, and keep_network_contents indicate that the
            node should keep the same name, parameter values, and contents,
            respectively, after its type has changed.
            force_change_on_node_type_match indicates whether to perform the
            change even when is already of the specified type.


        """
    def selectNextVisibleWorkItem(self) -> None:
        """

        selectNextVisibleWorkItem(self)

            If a work item is selected, selects the next visible work item


        """
    def selectPreviousVisibleWorkItem(self) -> None:
        """

        selectPreviousVisibleWorkItem(self)

            If a work item is selected, selects the previous work item


        """
    def deselectWorkItem(self) -> None:
        """

        deselectWorkItem(self)

            Deselects the active work item if this node is inside or contains
            the TOP network with the currently selected work item.


        """
    def setCurrentTOPPage(self, page: int) -> None:
        """

        setCurrentTOPPage(page_index)

            If a TOP node can't display all work items, sets which work item
            subset (page) will be displayed


        """
    def canGenerateCookCode(self, check_parent: bool = False, check_auto_shader: bool = True) -> bool:
        """

        canGenerateCookCode(self, check_parent=False, check_auto_shader=True) ->
        bool

            Return True if the node can generate compiled cook code and False
            otherwise.

            If check_parent is true, the parents in the ancestor hierarchy are
            tested if any of them can generate code.

            If the node cannot generate cook code explicitly, it might still be
            able to provide such code implicitly, if it can be wrapped in auto-
            shader. E.g., a building-block VOPs such as Anti-Aliased Noise don't
            generate a complete cook code; they provide code fragment that
            contributes to the full cook function. But sometimes they can be
            automatically wrapped in such a function, which which will act as
            cook code. If check_auto_shader is true, the node will be tested if
            it provides implicit cook code.


        """
    def cookCodeGeneratorNode(self, check_parent: bool = ...) -> Node:
        """

        cookCodeGeneratorNode(self, check_parent=False) -> hou.Node

            Return the node itself or a network node that contains this node and
            can generate compiled cook code. For example, the generator node for
            a VOP node could be the SHOP node or SOP node that contains it for
            example.

            Return None if this node cannot generate code and is not contained
            in a code generating node either either.


        """
    def cookCodeLanguage(self) -> str:
        """

        cookCodeLanguage(self) -> str

            Return the language of the generated cook code (i.e. VEX, RSL).

            Raises hou.OperationFailed if this node cannot generate compiled
            code.


        """
    def supportsMultiCookCodeContexts(self) -> bool:
        """

        supportsMultiCookCodeContexts(self) -> bool

            Return True if this node can generate compiled cook code for
            multiple contexts (i.e. surface context, displacement context, etc.)
            and False otherwise.

            Raises hou.OperationFailed if this node cannot generate compiled
            code.


        """
    def saveCookCodeToFile(self, file_name: str, skip_header: bool = False, context_name: Optional[str] = None) -> None:
        '''

        saveCookCodeToFile(self, file_name, skip_header=False,
        context_name=None)

            Saves VEX/RSL source code to a disk file (on nodes that support
            this).


            file_name
                The file path in which to save the generated code.

            skip_header
                If True, the method does not write a header comment at the
                beginning of the file containing the file name and node path
                from which the code was generated and a time stamp.

            context_name
                A string containing name of the shader context for the code.
                This option applies to nodes such as the Material Shader Builder
                which can generate code for multiple context types.

                For example, a Material network might contain both surface and
                displacement shaders, so you must specify which type of shader
                code to generate:

              > node(\\"/shop/vopmaterial1\\").saveCookCodeToFile(\\"myfile.vfl\\", context_name=\\"surface\\")

                On single-context nodes this argument is ignored.

                For VEX materials, possible values are surface, displacement,
                light, shadow, fog, image3d, photon, or cvex.

                For RSL materials, possible values are surface, displacement,
                light, volume, or imager.


        '''
    def saveCodeToFile(self, file_name: str, skip_header: bool = False, context_name: Optional[str] = None) -> None: ...
    def saveCompiledCookCodeToFile(self, file_name: str, context_name: Optional[str] = None) -> None:
        """

        saveCompiledCookCodeToFile(self, file_name, context_name=None)

            Saves compiled VEX code to a disk file (for nodes that support
            this). See hou.Node.saveCookCodeToFile for a description of the
            arguments.


        """
    def saveToCompiledVexFile(self, file_name: str, context_name: Optional[str] = None) -> None: ...
    def cook(self, force: bool = ..., frame_range: Sequence[float] = ...) -> None:
        """

        cook(self, force=False, frame_range=())

            Asks or forces the node to re-cook.


            frame_range
                The frames at which to cook the object. This should be a tuple
                of 2 or 3 ints giving the start frame, end frame, and optionally
                a frame increment, in that order. If you supply a two-tuple
                (start, end), the increment is 1.


        """
    def needsToCook(self, time: float = ...) -> bool:
        """

        needsToCook(self, time=hou.time()) -> bool

            Asks if the node needs to re-cook.


        """
    def invalidateOutput(self) -> None:
        """

        invalidateOutput(self)

            Invalidate this node's output data, dirtying the node and its
            dependents. If this node or any of its dependents are displayed in a
            UI pane (eg. a viewport), this will cause the panes the refresh and
            cook these nodes again.


            NOTE
                This method currently only invalidates the first output for
                nodes that have multiple outputs.


        """
    def cookCount(self) -> int:
        """

        cookCount(self) -> int

            Returns the number of times this node has cooked in the current
            session.


        """
    def cookPathNodes(self) -> Tuple[Node, ...]:
        """

        cookPathNodes(self) -> tuple of hou.Node

            Return a list of the nodes, including nodes in subnets, that were
            used in the last cook for the network this node belongs to.


        """
    def infoTree(self, verbose: bool = False, debug: bool = False, output_index: int = 0, force_cook: bool = False) -> NodeInfoTree:
        """

        infoTree(self, verbose=False, debug=False, output_index=0,
        force_cook=False) -> hou.NodeInfoTree

            Returns a tree structure containing information about the node and
            its most recently cooked data. The contents of the tree vary widely
            depending on the node type, and the nature of its cooked data. This
            tree of data is used to generate the node information window
            contents.


            verbose
                Setting verbose to True will cause some additional information
                to be generated. In particular data that is expensive to
                calculate, or which will generate a large amount of information
                tends to be generated only if this option is turned on.

            debug
                Setting debug to True will, in a few cases, cause additional
                information to be displayed which generally will be most useful
                when debugging the internal operation of Houdini. For example,
                geometry attributes will display their data ids, which can be
                helpful when tracking down errors in SOPs written with the HDK.

            output_index
                Specifies which of the node's outputs to return information for.

            force_cook
                If True, ensures that output has been cooked before building the
                info tree. Note that if the node already has errors, this will
                attempt to recook the node.


        """
    def infoData(self) -> dict[str, Any]:
        """

        infoData(self) -> dict of str to any python object

            Returns a dictionary of any node-type-specific information about the
            node's current status. This will consist of its last cooked status,
            so the node may need to be pre-cooked to update the data.

            While infoTree provides formatted data suitable for display,
            infoData returns raw data and is not meant to be directly displayed.
            It also consists only of data specific to the node that can't be
            queried through other HOM methods.


        """
    def updateParmStates(self) -> None:
        """

        updateParmStates(self)

            Update the UI states, such as hidden and disabled, for each
            parameter in the node.

            UI states can be expressed as conditionals (i.e. Disable When) which
            require evaluation. Typically in graphical Houdini the Parameter
            Pane performs the evaluation when the node is selected in order to
            determine how the node parameters should look in the pane. However
            in non-graphical Houdini or if the Parameter Pane has not yet loaded
            the node, then the evaluation does not occur and the UI states
            remain at their defaults causing methods such as hou.Parm.isDisabled
            and hou.Parm.isHidden to return incorrect values. In these cases, it
            is recommended that hou.Node.updateParmStates is called.


        """
    def runInitScripts(self) -> None:
        """

        runInitScripts(self)

            Runs the initialization script associated with this node's type.


        """
    def deleteScript(self) -> str:
        """

        deleteScript(self) -> str

            Return the script that will run when this node is deleted.


        """
    def setDeleteScript(self, script_text: str, language: EnumValue = ...) -> None:
        """

        setDeleteScript(self, script_text, language=hou.scriptLanguage.Python)

            Sets the script that will run when this node is deleted.


        """
    def addNodeGroup(self, name: Optional[str] = None) -> NodeGroup:
        """

        addNodeGroup(self, name=None) -> hou.NodeGroup

            Add a node group to the node and return the new group.

            If a group of the given name already exists then this function
            simply returns the existing group without adding a new one. If the
            name of the group is None or an empty string, then a unique default
            name is automatically chosen.

            This function can only be called on nodes that are networks. If it
            is called on a node that is not a network, then it raises
            hou.OperationFailed.

            To remove a node group, use hou.NodeGroup.destroy.


        """
    def nodeGroups(self) -> Tuple[NodeGroup, ...]:
        """

        nodeGroups(self) -> tuple of hou.NodeGroup

            Return the list of node groups in this node.


        """
    def nodeGroup(self, name: str) -> Optional[NodeGroup]:
        """

        nodeGroup(self, name) -> hou.NodeGroup

            Return a node group contained by the node with the given name, or
            None if the group does not exist.


        """
    def motionEffectsNetworkPath(self) -> str:
        """

        motionEffectsNetworkPath(self) -> str

            Return a node path representing the location for storing clips. This
            location may or may not exist. To find or create such a network, use
            hou.Node.findOrCreateMotionEffectsNetwork.


        """
    def findOrCreateMotionEffectsNetwork(self, create: bool = True) -> OpNode:
        """

        findOrCreateMotionEffectsNetwork(self, create=True) ->
        hou.chopNetNodeTypeCategory

            Return a CHOP network node suitable for storing Motion Effects. By
            default, if the node doesn't exist, it will be created.

            See also hou.Parm.storeAsClip and hou.Node.motionEffectsNetworkPath.


        """
    def createOrMoveVisualizer(self, output_index: int) -> None:
        """

        createOrMoveVisualizer(self, output_index)

            Creates a node for visualizing the data from a particular output of
            this node. If a visualizer node already exists in the current
            network, it is moved and connected to the specified output_index.
            This method is only implemented for SOP and VOP nodes. Other node
            types do nothing when this method is called.


        """
    def saveItemsToFile(self, items: Sequence[NetworkMovableItem], file_name: str, save_hda_fallbacks: bool = False) -> None:
        """

        saveItemsToFile(self, items, file_name, save_hda_fallbacks = False)

            Given a sequence of child items (nodes, network boxes, sticky notes,
            etc), save a file containing those items. You can load this file
            using hou.Node.loadItemsFromFile.


            items
                A sequence of hou.NetworkMovableItems that are children of this
                node.

            file_name
                The name of the file to write the contents to. You can use any
                extension for this file name.

            save_hda_fallbacks
                Set to True to save simplified definitions for HDAs into the
                file along with the child nodes. Doing this allows the generated
                file to be safely loaded into any houdini session, even if the
                assets used in the file are not already loaded into the houdini
                session. Depending on the use of the generated file, this
                information is often not required and makes the files
                unnecessarily large.

            Raises hou.OperationFailed if any of the nodes or network boxes are
            node children of this node, or if the file could not be written to.
            Raises hou.PermissionError if you do not have permission to read the
            contents of this node.


        """
    def loadItemsFromFile(self, file_name: str, ignore_load_warnings: bool = False) -> None:
        """

        loadItemsFromFile(self, file_name, ignore_load_warnings=False)

            Load the contents of a file (saved with hou.Node.saveItemsToFile)
            into the contents of this node.

            Raises hou.OperationFailed if the file does not exist or it is not
            the correct type of file. Raises hou.PermissionError if this node is
            a locked instance of a digital asset. Raises hou.LoadWarning if the
            load succeeds but with warnings and ignore_load_warnings is False.


        """
    def removeAllEventCallbacks(self) -> None:
        """

        removeAllEventCallbacks(self)

            Remove all event callbacks for all event types from this node.

            See hou.Node.addEventCallback for more information.


            WARNING
                removeAllEventCallbacks should be used carefully, especially
                with viewer states as it may cause functionality to silently
                stop working when entering a state.


        """
    def stampValue(self, parm_name: str, default_value: float|str) -> str:
        '''

        stampValue(self, parm_name, default_value)

            Return a copy stamping floating point or string value. This node
            must be a downstream stamping operator, such as a Copy SOP, Cache
            SOP, LSystem SOP, or Copy CHOP.


            parm_name
                The name of the stamping variable.

            default_value
                The value that this function returns if Houdini is not currently
                performing stamping, or if parm_name is not a valid variable
                name. This value may be a float or a string.

            You might put the following expression in a Python parameter:

          > node(\\"../copy1\\").stampValue(\\"sides\\", 5)

        '''
    def asCode(self, brief: bool = False, recurse: bool = False, save_channels_only: bool = False, save_creation_commands: bool = True, save_keys_in_frames: bool = False, save_outgoing_wires: bool = False, save_parm_values_only: bool = False, save_spare_parms: bool = True, save_box_membership: bool = True, function_name: Optional[str] = None) -> str:
        """

        asCode(self, brief=False, recurse=False, save_channels_only=False,
        save_creation_commands=True, save_keys_in_frames=False,
        save_outgoing_wires=False, save_parm_values_only=False,
        save_spare_parms=True, save_box_membership=True, function_name=None) ->
        str

            Prints the Python code necessary to recreate a node.


            brief
                Do not set values if they are the parameter's default. Applies
                to the contents of the node if either recurse or
                save_box_contents is True.

            recurse
                Recursively apply to the entire operator hierarchy.

            save_box_contents
                Script the contents of the node.

            save_channels_only
                Only output channels. Applies to the contents of the node if
                either recurse or save_box_contents is True.

            save_creation_commands
                Generate a creation script for the node. If set to False, the
                generated script assumes that the network box already exists.
                When set to True, the script will begin by creating the network
                box.

            save_keys_in_frames
                Output channel and key times in samples (frames) instead of
                seconds. Applies to the contents of the node if either recurse
                or save_box_contents is True.

            save_parm_values_only
                Evaluate parameters, saving their values instead of the
                expressions. Applies to the contents of the node if either
                recurse or save_box_contents is True.

            save_spare_parms
                Save spare parameters as well. When save_creation_commands is
                True, commands for creating spare parameters will also be
                output. Applies to the contents of the node if either recurse or
                save_box_contents is True.

            save_box_membership
                Output code to add the root item to its parent network box, if
                any.

            function_name
                If a function_name is specified, the output will be wrapped in a
                Python function.


        """
    def dataBlockKeys(self, blocktype: Optional[str] = None) -> Tuple[str, ...]:
        """

        dataBlockKeys(self, blocktype) -> tuple of str

            Return the names of all data blocks stored on this node that are of
            the data type specified by the blocktype parameter.

            Data blocks are similar to user data in that they can contain any
            extra data that may be useful to attach to a specific node. They
            differ from user data in that data blocks are designed to more
            efficiently handle large blocks of data. Data blocks can also
            contain binary data, and have a data type associated with each
            block.


        """
    def dataBlockType(self, key: str) -> str:
        """

        dataBlockType(self, key) -> str

            Return the data type of the block specified by the key parameter.

            Raises hou.ValueError if the provided key is not associated with any
            data block on this node.


        """
    def dataBlock(self, key: str) -> bytes:
        """

        dataBlock(self, key) -> str for Python 2, bytes for Python 3

            Returns the data block as a binary string stored under the given
            key. This method will only work if the specified data block is has a
            type that can be represented by a python object. Otherwise None is
            returned.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            Raises hou.ValueError if the provided key is not associated with any
            data block on this node.


            NOTE
                A binary data block can also be accessed within Houdini using
                the filesystem protocol opdatablock:. This works similarly to
                the opdef: and oplib: protocols used by HDAs. For example, a
                network editor background image could be set to load from the
                data block key image.pic by setting its filepath to
                opdatablock:/obj/geo1/image.pic.


        """
    def setDataBlock(self, key: str, data: bytes, block_type: Optional[str] = None) -> None:
        """

        setDataBlock(self, key, block, block_type=None)

            Stores the provided data block on the node under the provided key
            name, marking it with the provided data type.

            Passing an empty string as the block value will remove any data
            block with the specified key. Data blocks can also be removed with
            the removeDataBlock() method.

            The blocktype string argument requires a C++/HDK plugin to interpret
            data blocks and turn them into C++ objects. If you're using Python
            to get and set data blocks, leave the blocktype empty.


            NOTE
                It is also possible to store the data block from within Houdini
                by writing to a file using the opdatablock: file system
                protocol. For example, setting the Output File parameter of a to
                opdatablock:/obj/geo1/image.pic would store the image file to
                the geo1 node with the key image.pic.


        """
    def removeDataBlock(self, key: str) -> None:
        """

        removeDataBlock(self, key)

            Removes any existing data block on the node with the specified key.
            If there is no data block with this key, this method does nothing.


        """
    def destroyCachedUserData(self, name: str, must_exist: bool = True) -> None:
        """

        destroyCachedUserData(self, name, must_exist=True)

            Remove the user-defined cached data with this name.

            See hou.Node.setCachedUserData for more information.

            Raises hou.OperationFailed if no user data with this name exists and
            must_exist is True.


        """
    def clearCachedUserDataDict(self) -> None:
        """

        clearCachedUserDataDict(self)

            Remove all user-defined cached data.

            See hou.Node.setCachedUserData for more information.


        """
    def cachedUserDataDict(self) -> dict[str, Any]:
        """

        cachedUserDataDict(self) -> dict of str to any python object`

            Return a dictionary containing all the user-defined name/string
            pairs for this node.

            See hou.Node.setCachedUserData for more information.


        """
    def setCachedUserData(self, name: str, value: Any) -> None:
        '''

        setCachedUserData(self, name, value)

            Add/set a named value on this node instance. Unlike setUserData,
            values set using this method are not saved with the hip file.

            name: A unique name (key) for the user-defined data. By using
            different names, you can attach multiple pieces of user-defined data
            to a node. value: The value to store. Unlike setUserData, this value
            may be any Python object.

            This name/value pair is not stored with the hip file. It is useful
            for nodes implemented in Python that want to save temporary values
            between cooks, to avoid recomputing them on subsequent cooks.

            The following example illustrates how to set, access, and delete
            cached user-defined data:

          > >>> n = hou.node(\\"/obj\\").createNode(\\"geo\\")
          > >>> n.setCachedUserData(\\"my data\\", [1, 2, {\\"a\\": \\"b\\", \\"c\\": \\"d\\"}])
          > >>> n.cachedUserData(\\"my data\\")
          > [1, 2, {\'a\': \'b\', \'c\': \'d\'}]
          > >>> n.cachedUserDataDict()
          > {\'my data\': [1, 2, {\'a\': \'b\', \'c\': \'d\'}]}
          > >>> n.destroyCachedUserData(\\"my data\\")
          > >>> n.cachedUserDataDict()
          > {}
          > >>> print n.cachedUserData(\\"my data\\")
          > None

            See per-node user-defined data for more information and examples.


        '''
    def cachedUserData(self, name: str) -> Any:
        '''

        cachedUserData(self, name) -> any python obect or None

            Return the user-defined cached data with this name, or None if no
            data with this name exists.

            See hou.Node.setCachedUserData for more information.

            This method can be implemented as follows:

          > def cachedUserData(self, name):
          >     return self.cachedUserDataDict().get(name)

            Note that None is a valid value for a key, so the most reliable way
            to check if a key is valid is to check if it is in the result of
            cachedUserDataDict:

          > >>> n = hou.node(\\"/obj\\").createNode(\\"geo\\")
          > >>> n.cachedUserDataDict()
          > {}
          > >>> print n.cachedUserData(\\"foo\\")
          > None
          > >>> \\"foo\\" in n.cachedUserDataDict()
          > False
          > >>> n.setCachedUserData(\\"foo\\", None)
          > >>> n.cachedUserDataDict()
          > {\'foo\': None}
          > >>> print n.cachedUserData(\\"foo\\")
          > None
          > >>> \\"foo\\" in n.cachedUserDataDict()
          > True

        '''
    def simulation(self) -> DopSimulation: ...
    def findNodesThatProcessedObject(self, dop_object: DopObject) -> Tuple[Node, ...]: ...
    def addError(self, message: str, severity: EnumValue = ...) -> None:
        """

        addError(self, message, severity=Hom:hou.severityType.Error)

            Add an error badge to the node


            message
                A string containing the error message to show on the node.

            severity
                A hou.severityType object that specifies the severity level


            NOTE
                This should only be called on the currently cooking node within
                a cook.


        """
    def addWarning(self, message: Optional[str] = None) -> None:
        """

        addWarning(self, message)

            Add a warning badge to the node


            message
                A string containing the warning message to show on the node.


            NOTE
                This should only be called on the currently cooking node within
                a cook.


        """
    def addMessage(self, message: Optional[str] = None) -> None:
        """

        addMessage(self, message)

            Add an info message badge to the node


            message
                A string containing the info message to show on the node.


            NOTE
                This should only be called on the currently cooking node within
                a cook.


        """
    def lastCookTime(self) -> float:
        """

        lastCookTime(self) -> float

            Returns the duration of the node's last cook in milliseconds.


        """
    def lastCookContextOptions(self, only_used_options: bool = ...) -> dict[str, str|float]:
        """

        lastCookContextOptions(self, only_used_options=False) -> dict of str to
        str or float

            Returns a dictionary of context options that were set during the
            most recent cook of this node. Setting only_used_options to True
            restricts the returned context option values to those that were
            actually used while cooking the node (or its inputs).


        """
    def evalParm(self, parm_path: str) -> ParmArgType:
        """

        evalParm(self, parm_path) -> int, float, or str

            Evaluates the specified parameter and returns the result.


        """
    def evalParmTuple(self, parm_path: str) -> ParmTupleReturnType:
        """

        evalParmTuple(self, parm_path) -> tuple of int, float, or str

            Evaluates the specified parameter tuple and returns the result.


        """
    def addEventCallback(self, event_types: Sequence[EnumValue], callback: Callable) -> None:
        '''

        addEventCallback(self, event_types, callback)

            Registers a Python callback that Houdini will call whenever a
            particular action, or event, occurs on this particular node
            instance.

            Callbacks only persist for the current session. For example, they
            are not saved to the .hip file. If you want persistent callbacks in
            every session, you can add them in code in 456.py (runs when the
            user opens a .hip file). See where to add Python scripting for more
            information.


            event_types
                A sequence of hou.nodeEventType enumeration values describing
                the event types that will cause Houdini to call the callback
                function.

            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

                Houdini calls the function with an event_type keyword argument
                containing the hou.nodeEventType value corresponding to the
                event that triggered the callback.

                Houdini will pass additional keyword arguments depending on the
                event type. For example, in a callback for the ParmTupleChanged
                event, Houdini will pass a parm_tuple keyword argument
                containing a hou.ParmTuple reference to the parameter that
                changed. See hou.nodeEventType for the extra arguments (if any)
                passed for each event type.

                You can add **kwargs to the argument list to accept all keyword
                arguments, to allow the same callback to be used for different
                events, or to be safe from future changes:

              > def event_callback(event_type, **kwargs):
              >     ...

            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to an event. However, it may be useful to add the same
                function if you want to register it with different event_types.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            The following example shows to set up a function that\'s called
            whenever a certain node\'s name changes:

          > 
          > def name_changed(node, event_type, **kwargs):
          >     print(\\"The geometry object is now named\\", node.name())
          > 
          > hou.node(\\"/obj/geo1\\").addEventCallback((hou.nodeEventType.NameChanged, ), name_changed)

            See also hou.Node.removeEventCallback and
            hou.Node.removeAllEventCallbacks.


        '''
    def addParmCallback(self, callback: Callable[[OpNode, ParmTuple], None], names: Sequence[str]) -> None:
        """

        addParmCallback(self, callback, parm_names)

            Registers a Python callback that Houdini will call whenever a
            parameter in parm_names changes on this particular node instance.
            This is can be faster than filtering the parameter names in a
            callback installed with hou.Node.addEventCallback if you only care
            about some parameters or if the node has many parameters.


            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

            parm_names
                All list of parameter names.

            See hou.Node.addEventCallback for more information.


        """
    def removeEventCallback(self, event_types: Sequence[EnumValue], callback: Callable) -> None:
        """

        removeEventCallback(self, event_types, callback)

            Given a callback that was previously added on this node and a
            sequence of hou.nodeEventType enumerated values, remove those event
            types from the set of event types for the callback. If the remaining
            set of event types is empty, the callback will be removed entirely
            from this node.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.Node.addEventCallback for more information.


        """
    def eventCallbacks(self) -> Tuple[Tuple[Tuple[EnumValue,...], Callable],...]: ...

    # Missing methods added by stubgen
    def appendParmTemplatesFromData(self, data: dict[str, Any], rename_conflicts: bool = True) -> dict[str, ParmTuple]: ...
    def appendParmTemplatesToFolderFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, ParmTuple]: ...
    def asData(self, nodes_only: bool = False, children: bool = False, editables: bool = False, inputs: bool = False, position: bool = False, flags: bool = False, parms: Union[bool, Sequence[ParmTuple], Sequence[str]]=True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str=..., metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def children(self) -> Tuple[OpNode, ...]: ...
    def childrenAsData(self, nodes_only: bool = False, children: bool = True, editables: bool = True, inputs: bool = True, position: bool = True, flags: bool = True, parms: bool = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str=..., metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def createDecorationItemsFromData(self, items: Sequence[NetworkMovableItem], frame_nodes: Sequence[NetworkMovableItem] | None=None, selected_nodes: Sequence[NetworkMovableItem] | None=None, current_node: NetworkMovableItem | None=None, flags: bool = True, nodes_only: bool = False, target_children: bool = False, children: bool = True, target_editables: bool = False, editables: bool = True, target_parms: Union[bool, Sequence[ParmTuple], Sequence[str]]=True, parms: bool = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str=..., metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def createNode(self, node_type_name: str, node_name: str | None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False, force_valid_node_name: bool = False) -> OpNode: ...
    def editablesAsData(self, nodes_only: bool = False, children: bool = True, editables: bool = True, inputs: bool = True, position: bool = True, flags: bool = True, parms: bool = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str=..., metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def inputConnections(self) -> Tuple[OpNodeConnection, ...]: ...
    def inputsAsData(self, ignore_network_dots: bool = False, ignore_subnet_indirect_inputs: bool = False, use_names: bool = False) -> Sequence[dict[str, Any]]: ...
    def insertParmTemplatesAfterFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, ParmTuple]: ...
    def insertParmTemplatesBeforeFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, ParmTuple]: ...
    def node(self, node_path: str) -> OpNode | None: ...
    def outputConnections(self) -> Tuple[OpNodeConnection, ...]: ...
    def outputsAsData(self, ignore_network_dots: bool = False, ignore_subnet_indirect_inputs: bool = False, use_names: bool = False) -> Sequence[dict[str, Any]]: ...
    def parmTemplateChildrenAsData(self, name: str= '', parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def parmTemplatesAsData(self, name: str= '', children: bool = True, parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def parmsAsData(self, values: bool = True, parms: bool = True, default_values: bool = False, evaluate_values: bool = False, locked: bool = True, brief: bool = True, multiparm_instances: bool = True, metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def prependParmTemplatesToFolderFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, ParmTuple]: ...
    def replaceParmTemplatesFromData(self, data: dict[str, Any]) -> dict[str, ParmTuple]: ...
    def setChildrenFromData(self, clear_content: bool = True, force_item_creation: bool = True, offset_position: Vector2=..., external_connections: bool = True, parms: bool = True, parmtemplates: bool = True, children: bool = True, editables: bool = True, skip_notes: bool = False) -> None: ...
    def setEditablesFromData(self, clear_content: bool = True, force_item_creation: bool = True, offset_position: Vector2=..., external_connections: bool = True, parms: bool = True, parmtemplates: bool = True, children: bool = True, editables: bool = True, skip_notes: bool = False) -> None: ...
    def setFromData(self, data: dict[str, Any], clear_content: bool = False, force_item_creation: bool = True, parms: bool = True, parmtemplates: bool = True, children: bool = True, editables: bool = True, skip_notes: bool = False) -> None: ...
    def setInputsFromData(self, data: dict[str, Any]) -> None: ...
    def setOutputsFromData(self, data: dict[str, Any]) -> None: ...
    def setParmExpressions(self, parm_dict: Mapping[str, str | Sequence[str]], language: EnumValue | None = None, replace_expressions: bool = True) -> None: ...
    def setParms(self, parm_dict: Mapping[str, ParmArgType | ParmTupleArgType]) -> None: ...
    def setParmsFromData(self, data: dict[str, Any]) -> None: ...
    def type(self) -> OpNodeType: ...

class OpVerb:
    """

    hou.OpVerb

    Represents the code of a node.

    See using a verb for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def loadParmsFromNode(self, opnode: OpNode) -> None:
        """

        loadParmsFromNodeAtTime(self, sopnode, time)

            Initializes all the parameters of this verb from the parameters of a
            specific hou.OpNode at a given time. Useful for cloning an existing
            node instance's behavior.


        """
    def loadParmsFromNodeAtTime(self, opnode: OpNode, time: float) -> None: ...
    def parms(self) -> dict[str, OptionType]:
        """

        parms(self) -> dictionary

            Returns a dictionary of parameter name / value pairs currently set
            on this verb. This will be the complete list understood, including
            defaults. Multiparms are represented as a sub list of dictionaries.

            This uses ParmTuple names, not channel names.


        """
    def setParms(self, p: Mapping[str, OptionMultiArgType|Sequence[Mapping[str, OptionMultiArgType]]]) -> None:
        """

        setParms(self, parmdictionary)

            Updates a subset of parmeters on this verb with those specified in
            the dictionary. Exceptions are raised if attempts are made to set
            non-existent parameters or with incorrect types.

            This uses ParmTuple names, not channel names. So for a transform you
            would use xform.setParms({'t':(2,0,0)}) rather than tx.


        """
    def minNumInputs(self) -> int:
        """

        minNumInputs(self) -> integer

            Returns the minimum number of geometry inputs required for this verb
            to compute successfully.


        """

class NodeGroup:
    """

    hou.NodeGroup

    Represents a node group.

    In Houdini, a node group contains a set of nodes from the same network.
    Each group is named, and you can edit a group's contents from the
    network view pane by selecting Tools > Show Groups from its right-mouse
    menu.

    A node bundle, on the other hand, may contain nodes from multiple
    networks, and corresponds to a hou.NodeBundle object. You can edit a
    node bundle from the bundle list pane.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of this group.


        """
    def nodes(self) -> Tuple[Node, ...]:
        """

        nodes(self) -> tuple of hou.OpNode

            Return a tuple containing the nodes in this group.


        """
    def parent(self) -> Node:
        """

        parent(self) -> hou.OpNode

            Returns the network node containing this group.


        """
    def addNode(self, node: Node) -> None:
        """

        addNode(self, node)

            Add a hou.OpNode to this group.

            If the node is already in the group, this method does nothing. If
            the node is not in the correct network for this group, raises
            hou.OperationFailed.


        """
    def removeNode(self, node: Node) -> None:
        """

        removeNode(self, node)

            Remove a hou.OpNode from this group.

            Raises hou.OperationFailed if the node is not in the group.


        """
    def clear(self) -> None:
        """

        clear(self)

            Remove all nodes from this group.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Delete this group. Does not delete the nodes that were contained in
            it.


        """
    def asCode(self, save_creation_commands: bool = True, save_node_memberships: bool = True, function_name: Optional[str] = None) -> str:
        """

        asCode(self, save_creation_commands=False, function_name=None) -> str

            Returns the Python code necessary to recreate this group.


            save_creation_commands
                Generate a creation script for the node group. If set to False
                (the default), the generated script assumes that the node group
                already exists. When set to True, the script will begin by
                creating the node group.

            function_name
                If a function_name is specified, the output will be wrapped in a
                Python function.


        """

class ObjNode(OpNode):
    """

    hou.ObjNode

    An instance of an object node in the Houdini scene.

    Each object has a transformation (or transform) encapsulating its
    position (or translation), rotation, and scale. For a subnet object, the
    subnet's transform is applied to the objects inside the subnet. An
    object can have additional transforms from parent objects on top of the
    transform defined by its parameters, as well as a normally hidden
    pretransform that defines the object's rest or zero position (normally
    all zeros). An object's final position/rotation/scale in world space is
    defined by (object's transform) * (pretransform) * (parent transform).


    TIP
        You can set an object's position/rotation/scale to certain world
        space values regardless of parent/pre-transform values with the
        hou.ObjNode.setWorldTransform method.


    NOTE
        Houdini does not support shear parameters on objects. If you try to
        set an object's parameters to a transform containing shear, Houdini
        will automatically remove the shear.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def origin(self) -> Vector3:
        """

        origin(self) -> hou.Vector3

            Return the object's origin position, in world space.

            obj.origin() is equivalent to obj.Vector3(0, 0, 0) *
            obj.worldTransform().

          > # To compute the world space vector from obj1's origin to obj2's origin, you
          > # can write:
          > obj2.origin() - obj1.origin()
          > 
          > # To compute the distance, in world space, between the origins of two
          > # objects, simply take the length of this vector:
          > (obj2.origin() - obj1.origin()).length()
          > 
          > # If there are no rotations or scales, the vtorigin() hscript expression
          > # function will return the same result as obj2.origin() - obj1.origin().
          > # If there are rotations or scales, though, it won't.  A Python equivalent
          > # of vtorigin() is defined by:
          > def vtorigin(obj1, obj2):
          >     return (obj2.worldTransform() * obj1.worldTransform().inverted()).extractTranslates()

            See also the hou.ObjNode.worldTransform and
            hou.ObjNode.getTransformToNode methods.


        """
    def localTransform(self) -> Matrix4:
        """

        localTransform(self) -> hou.Matrix4

            Return the matrix that transforms this object's geometry into space
            of its input.

            The local transform matrix contains the cumulative transforms of:

          * The node's pre-transform

          * The transform defined by the node's transform parameters

          * The transform adjustment by the node's lookat and path parameters

            The local transform matrix, independent of the node's pre-transform,
            can be obtained as follows:

          > def localTransformIgnorePreTransform(self):
          > return (self.localTransform() * self.preTransform().inverted())

            See also hou.ObjNode.localTransformAtTime and
            hou.ObjNode.worldTransform.


        """
    def localTransformAtTime(self, time: float) -> Matrix4:
        """

        localTransformAtTime(self, time) -> hou.Matrix4

            Return, for the specified time, the matrix that transforms this
            object's geometry into the space of its input.

            If the object's local transform is animated, this method provides a
            way to get the transformation at a specific time.

            See hou.ObjNode.localTransform for more information.


        """
    def worldTransform(self) -> Matrix4:
        """

        worldTransform(self) -> hou.Matrix4

            Return the matrix that transforms this object's geometry into world
            space.

            The world transform matrix contains the cumulative transforms of:

          * The node's pre-transform

          * The transform defined by the node's parameters

          * The transforms of parent nodes or containing networks

            This method can approximately be implemented as follows:

          > def worldTransform(self):
          > return (self.localTransform() * self.parentAndSubnetTransform())

            See also hou.ObjNode.setWorldTransform and
            hou.ObjNode.worldTransformAtTime.


        """
    def worldTransformAtTime(self, time: float) -> Matrix4:
        """

        worldTransformAtTime(self, time) -> hou.Matrix4

            Return, for the specified time, the matrix that transforms this
            object's geometry into world space.

            If the object's world transform is animated, this method provides a
            way to get the transformation at a specific time.

            See hou.ObjNode.worldTransform for more information.


        """
    def setWorldTransform(self, matrix: Matrix4, fail_on_locked_parms: bool = False) -> None:
        """

        setWorldTransform(self, matrix, fail_on_locked_parms=False)

            Adjust this object's parameters to achieve the desired world
            transformation.

            This method will adjust the translate, rotate, and scale values of
            this object to achieve the desired final world transform. It
            accounts for the transforms of containing networks, parent
            transforms, and pre-transforms.

            If fail_on_locked_parms is True, and any of the translate, rotate,
            or scale parameters of the object are locked, this method raises
            hou.OperationFailed. If it is False and any of those parameters are
            locked, this method will change their values but leave them locked.

            Suppose:

          * W is the desired new world transform,

          * W' is the existing world transform,

          * L is the desired transform defined by the node's parameters,

          * L' is the existing parm transform,

          * P is the object's pre-transform,

          * O is the parent transform combined with the containing subnet's,
            transform

            Then, since W = L * P * O we have P = W * O^ * R^. So, this method
            could be implemented as follows:

          > def setWorldTransform(self):
          > self.setParmTransform(
          >     matrix * self.parentAndSubnetTransform().inverted() * self.preTransform().inverted(),
          >     fail_on_locked_parms)

            Alternately, we can derive L from W' and L' as follows:

          * W' = L' * P * O

          * so P * O = L^' * W'

          * and (P * O)^ = W^' * L' and

          * W = L * P * O

          * so L = W * (P * O)^

          * giving L = W * W'^ * L'

            Thus, this method could also be implemented using the current world
            and parm transforms as follows:

          > def setWorldTransform(self):
          > self.setParmTransform(
          >     matrix * self.worldTransform().inverted() * self.parmTransform(),
          >     fail_on_locked_parms)

            Note that, because parm transforms cannot contain shears, it is
            possible that the resulting world transform will not match the
            desired transform. If r is a function that removes shears from a
            transform then the new world transform will actually be L * P * O =
            r(W * O^ * P^) * P * O.

            See also hou.ObjNode.worldTransform and
            hou.ObjNode.setParmTransform.


        """
    def setCookTransform(self, matrix: Matrix4) -> None:
        """

        setCookTransform(self, matrix)

            Set the parameter transform for the Python object that's cooking.
            Call this method from objects implemented in Python to set the
            result of the cook.

            Note that an object implemented in Python controls the parameter
            transform (i.e. the result of hou.ObjNode.parmTransform). The world
            transform (i.e. the result of hou.ObjNode.worldTransform) is still
            affected by parent node's transforms, pre-transforms, etc.

            This method raises hou.OperationFailed if you call it on an object
            that is not implemented in Python or if you call it from outside
            that object's Python cook code.

            See the Transforms from Disk example.


        """
    def parmTransform(self) -> Matrix4:
        '''

        parmTransform(self) -> hou.Matrix4

            Return the transform defined by the parameters on this node.

            This method can approximately be implemented as follows:

          > def parmTransform(self):
          > pivot_transform = hou.hmath.buildTransform({
          >     \\"translate\\":self.evalParmTuple(\\"p\\"),
          >     \\"rotate\\":self.evalParmTuple(\\"pr\\")},
          >     transform_order=\\"srt\\",
          >     rotate_order=\\"xyz\\")
          > return (
          >     pivot_transform.inverted() *
          >     hou.hmath.buildTransform({
          >         \\"translate\\": self.evalParmTuple(\\"t\\"),
          >         \\"rotate\\": self.evalParmTuple(\\"r\\"),
          >         \\"scale\\": [self.evalParm(\\"scale\\") * s
          >         for s in self.evalParmTuple(\\"s\\")],
          >         \\"shear\\": (0.0, 0.0, 0.0)},
          >     transform_order=self.parm(\\"xOrd\\").evalAsString(),
          >     rotate_order=self.parm(\\"rOrd\\").evalAsString()) *
          >     pivot_transform)

            See the class documentation for the relation between this transform
            and the world space transform. See also hou.ObjNode.worldTransform.

            NOTE: For Python Objects, the python code sets the parm transform as
            well and won\'t necessarily have any visible parameters. To get the
            local transform of an object (ie. the transform without any
            parenting), use hou.ObjNode.localTransform.


        '''
    def setParmTransform(self, matrix: Matrix4, fail_on_locked_parms: bool = False) -> None:
        """

        setParmTransform(self, matrix, fail_on_locked_parms=False)

            Sets the transform controlled by this object's parameters.

            This method will adjust the translate, rotate, and scale values of
            this object to achieve the desired parameter, or local, transform.
            It will account for the existing pivot position, transformation
            order, and rotation order, and will leave them unchanged. It will
            also account for the existing orientation to set rotate values that
            produce a minimal rotation.

            Note that object nodes do not currently have shears parameters, so
            any shears in the matrix will be discarded.

            If fail_on_locked_parms is True, and any of the translate, rotate,
            or scale parameters of the object are locked, this method will raise
            hou.OperationFailed. If it is False and any of those parameters are
            locked, this method will change their values but leave them locked.

            See also hou.ObjNode.parmTransform and
            hou.ObjNode.setWorldTransform.

            This method can be approximately implemented as follows, ignoring
            locked parameters:

          > def setParmTransform(self, matrix):
          > parm_values = matrix.explode(
          >     transform_order=self.parm('xOrd').evalAsString(),
          >     rotate_order=self.parm('rOrd').evalAsString(),
          >     pivot=hou.Vector3(self.evalParmTuple('p')))
          > 
          > for parm_name, key in ('t', 'translate'), ('r', 'rotate'), ('s', 'scale'):
          >     self.parmTuple(parm_name).set(parm_values[key])

            See also hou.Matrix4.explode.


        """
    def parmPivotTransform(self) -> Matrix4:
        '''

        parmPivotTransform(self) -> hou.Matrix4

            Return the pivot transform defined by the parameters on this node.

            This method can approximately be implemented as follows:

          > def parmPivotTransform(self):
          > pivot_transform = hou.hmath.buildTranslate(self.evalParmTuple(\\"p\\"))
          > return (
          >     hou.hmath.buildTransform({
          >         \\"translate\\": self.evalParmTuple(\\"p\\"),
          >         \\"rotate\\": self.evalParmTuple(\\"pr\\")},
          >     transform_order=\\"srt\\",
          >     rotate_order=\\"xyz\\")

            See also hou.ObjNode.parmTransform.


        '''
    def setParmPivotTransform(self, matrix: Matrix4, fail_on_locked_parms: bool = False) -> None:
        """

        setParmPivotTransform(self, matrix, fail_on_locked_parms=False)

            Sets the pivot transform controlled by this object's parameters.

            This method will adjust the pivot translate and pivot rotate values
            of this object to achieve the desired transform. It will not
            compensate for any changes this causes to the world transform of
            this object.

            If fail_on_locked_parms is True, and any of the pivot translate or
            pivot rotate rotate parameters of the object are locked, this method
            will raise hou.OperationFailed. If it is False and any of those
            parameters are locked, this method will change their values but
            leave them locked.

            See also hou.ObjNode.parmPivotTransform and
            hou.ObjNode.setParmTransform.

            This method can be approximately implemented as follows, ignoring
            locked parameters:

          > def setParmPivotTransform(self, matrix):
          > parm_values = matrix.explode(
          >     transform_order=self.parm('xOrd').evalAsString(),
          >     rotate_order=self.parm('rOrd').evalAsString(),
          >     pivot=hou.Vector3())
          > 
          > for parm_name, key in ('p', 'translate'), ('pr', 'rotate'):
          >     self.parmTuple(parm_name).set(parm_values[key])

            See also hou.Matrix4.explode.


        """
    def preTransform(self) -> Matrix4:
        """

        preTransform(self) -> hou.Matrix4

            Return this object's pretransform.

            The pre-transform allows you to apply a transform after the
            parameter transform but before input and containing object
            transforms. See the class documentation for more details.

            Unlike the parameter transform, the pretransform is not stored using
            any parameters on the node. Instead, Houdini stores the pretransform
            as a matrix. Because it is directly as a matrix, the pretransform
            may contain shears.


        """
    def setPreTransform(self, matrix: Matrix4) -> None:
        """

        setPreTransform(self, matrix)

            Set this object's pretransform. See hou.ObjNode.preTransform for
            more information.


        """
    def movePreTransformIntoParmTransform(self) -> None:
        """

        movePreTransformIntoParmTransform(self)

            Set this object's pre-transform to the identity and adjust the parm
            transform so that the world transform does not change.

            This method is implemented approximately as follows:

          > def movePreTransformIntoParmTransform(self):
          > self.setParmTransform(self.parmTransform() * self.preTransform())
          > self.setPreTransform(hou.hmath.identityTransform())

            See also hou.ObjNode.movePreTransformIntoParmTransform.


        """
    def moveParmTransformIntoPreTransform(self) -> None:
        """

        moveParmTransformIntoPreTransform(self)

            Set this object's parm transform to the identity and adjust the pre-
            transform so that the world transform does not change.

            This method is implemented approximately as follows:

          > def moveParmTransformIntoPreTransform(self):
          > self.setPreTransform(self.parmTransform() * self.preTransform())
          > self.setParmTransform(hou.hmath.identityTransform())

            See also hou.ObjNode.moveParmRotateIntoPreTransform,
            hou.ObjNode.moveParmScaleIntoPreTransform, and
            hou.ObjNode.moveParmTranslateIntoPreTransform. Also see
            hou.ObjNode.movePreTransformIntoParmTransform.


        """
    def moveParmTranslateIntoPreTransform(self) -> None:
        """

        moveParmTranslateIntoPreTransform(self)

            Set this object's translate values to zero and adjust the pre-
            transform so that the world transform does not change.

            See hou.ObjNode.moveParmRotateIntoPreTransform for more information.


        """
    def moveParmRotateIntoPreTransform(self) -> None:
        '''

        moveParmRotateIntoPreTransform(self)

            Set this object\'s rotate values to zero and adjust the pre-transform
            so that the object\'s world transform does not change.

            Suppose:

          * W is the world transform,

          * L is the parameter transform without any rotate component,

          * L\' is the existing parm transform,

          * P is the desired new pre-transform,

          * P\' is the current pre-transform,

          * O is the parent transform combined with the containing subnet\'s,
            transform

            Then,

          * W = L * P * O and W = L\' * P\' * O

          * L * P = L\' * P\'

          * P = L^ * L\' * P\' So, this method is implemented approximately as
            follows:

          > def moveParmRotateIntoPreTransform(self):
          > old_parm_transform = self.parmTransform()
          > self.parmTuple(\\"r\\").set((0.0, 0.0, 0.0))
          > self.setPreTransform(
          >     self.parmTransform() * old_parm_transform * self.preTransform())
            See also hou.ObjNode.preTransform and the class documentation.


        '''
    def moveParmScaleIntoPreTransform(self) -> None:
        """

        moveParmScaleIntoPreTransform(self)

            Set this object's scale values to one and adjust the pre-transform
            so that the world transform does not change.

            See hou.ObjNode.moveParmRotateIntoPreTransform for more information.


        """
    def parentAndSubnetTransform(self) -> Matrix4:
        """

        parentAndSubnetTransform(self) -> hou.Matrix4

            Return the input node's world space transform (if there is an input
            connected), combined with the world space transform of the
            containing subnet object (if there is one). See the class
            documentation for more information.

            This method can approximately be implemented as follows:

          > def parentAndSubnetTransform(self):
          > if len(self.inputConnectors()[0]) != 0:
          >     return self.inputs()[0].worldTransform()
          > 
          > containing_subnet = self.parent()
          > if containing_subnet.type().category() == hou.objNodeTypeCategory():
          >     return containing_subnet.worldTransform()
          > 
          > return hou.hmath.identityMatrix()

        """
    def getTransformToNode(self, obj_node: ObjNode) -> Matrix4:
        """

        getTransformToNode(self, obj_node) -> hou.Matrix4

            Return a matrix that transforms this node to line up with the other
            node.

            The following invariant is true: node1.worldTransform() *
            node1.getTransformToNode(node2) == node2.worldTransform().

            This method can be implemented as follows:

          > def getTransformToNode(self, obj_node):
          > self.worldTransform().inverted() * obj_node.worldTransform()

            To align node1 (an ObjNode object) with node2 (another ObjNode
            object), you don't need to use getTransformToNode(). You can simply
            write: node1.setWorldTransform(node2.worldTransform()).

            See also hou.ObjNode.origin(), hou.ObjNode.worldTransform(), and
            hou.ObjNode.setWorldTransform().


        """
    def getTransformFromPointToPoint(self, pos3: Vector3, other_node: ObjNode, other_pos3: Vector3) -> Matrix4:
        """

        getTransformFromPointToPoint(self, pos3, other_node, other_pos3) ->
        hou.Matrix4

            Return the transform matrix that rotates the point pos3 (in this
            object node's transform space) to the point other_pos3 (in another
            object node's transform space).

          > obj1.getTransformFromPointToPoint(pos1, obj2, pos2)

            ...is equivalent to...

          > (obj1.worldTransform().inverted() *
          >     hou.hmath.buildTranslate(-pos1) *
          >     hou.hmath.buildTranslate(pos2) *
          >     obj2.worldTransform())

            See also the hou.ObjNode.getTransformToNode and
            hou.ObjNode.worldTransform methods, and the functions in the
            hou.hmath module.


        """
    def buildLookatRotation(self, to_node: ObjNode, up_vector: Optional[Vector3] = None) -> Matrix4:
        '''

        buildLookatRotation(self, to_node, up_vector=None) -> hou.Matrix4

            Return a matrix that will rotate this object to look at the
            specified object.

            The returned hou.Matrix4 object transforms this object from its
            current position in world space so that its negative z axis points
            at the origin of the to_node object.

            up_vector can either be a hou.Vector3 object or None. If it is None,
            this method uses an up vector of hou.Vector3(0, 1, 0).

            You can extract the rotation values from the return value with
            hou.Matrix4.extractRotates. You can set an object\'s transform with
            hou.ObjNode.setWorldTransform.

          > # Set the cam1 object\'s transform so it points at geo1.
          > cam1 = hou.node(\\"/obj/cam1\\")
          > lookat_obj = hou.node(\\"/obj/geo1\\")
          > cam1.setWorldTransform(cam1.buildLookatRotation(lookat_obj))

            See also hou.ObjNode.setWorldTransform.


        '''
    def isObjectDisplayed(self) -> bool:
        """

        isObjectDisplayed(self) -> bool

            Return whether or not this object is displayed. This method takes
            into account both the display flag and the display parameter. If the
            display parameter is enabled, because the tdisplay parameter is set,
            this parameter overrides the flag.

            See also hou.ObjNode.isDisplayFlagSet, which returns the current
            state of the flag.


        """
    def isObjectDisplayedAtFrame(self, frame: float) -> bool:
        """

        isObjectDisplayedAtFrame(self, frame) -> bool

            Return whether or not this object is displayed at the given frame.
            This method takes into account both the display flag and the display
            parameter. If the display parameter is enabled, because the tdisplay
            parameter is set, this parameter overrides the flag.

            See also hou.ObjNode.isDisplayFlagSet, which returns the current
            state of the flag.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Return whether or not this object's display flag is turned on. Note
            that the display flag and the display parameter both determine
            whether the object is actually displayed.

            Use hou.ObjNode.isObjectDisplayed to determine if the object is
            actually displayed.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turn the object's display flag on or off. See also
            hou.ObjNode.isDisplayFlagSet.


        """
    def isSelectableInViewport(self) -> bool:
        """

        isSelectableInViewport(self) -> bool

            Return whether or not the selectable flag is set. When it is not
            set, it is not possible to select this object or any of its geometry
            interactively in the viewport.


        """
    def setSelectableInViewport(self, on: bool) -> None:
        """

        setSelectableInViewport(self, on)

            Set the object's selectable flag. See
            hou.ObjNode.isSelectableInViewport for more information.


        """
    def isShowingOrigin(self) -> bool:
        """

        isShowingOrigin(self) -> bool

            Return whether or not this object displays its local origin gnomon
            in the viewport.

            Note that you can change this setting by right-clicking on the node.


        """
    def showOrigin(self, on: bool) -> None:
        """

        showOrigin(self, on)

            Show or hide this object's local origin gnomon in the viewport. See
            also hou.ObjNode.isShowingOrigin.


        """
    def isUsingXray(self) -> bool:
        """

        isUsingXray(self) -> bool

            Return whether or not this object displays its geometry in xray
            mode. Houdini displays xrayed geometry in wireframe and makes it
            visible even when it is hidden behind another surface.

            Note that you can change this setting by right-clicking on the node.


        """
    def useXray(self, on: bool) -> None:
        """

        useXray(self, on)

            Turn this object's xray mode on or off. See also
            hou.ObjNode.isUsingXray.


        """
    def displayNode(self) -> Optional[Node]:
        """

        displayNode(self) -> hou.OpNode or None

            If this object contains SOPs or DOPs, return the one that has its
            display flag on. Otherwise, return None.


        """
    def renderNode(self) -> Optional[Node]:
        """

        renderNode(self) -> hou.OpNode or None

            If this object contains SOPs or DOPs, return the one that has its
            render flag on. Otherwise, return None.


        """
    def combine(self, nodes: Sequence[Node]) -> None:
        """

        combine(self, nodes)

            Combine the geometry from the given list of hou.ObjNode's into this
            object. After this operation, the old objects will be deleted.

            Raises hou.ObjectWasDeleted if any of the nodes no longer exist in
            Houdini. Raises TypeError if any of the nodes are not of type
            hou.ObjNode. These exceptions are raised prior to performing the
            combine operation to avoid partial results.


        """
    def material(self, operation: Literal['override','select','remove','rmdefault','sync','revert','addlist'], parameter: Sequence[str]|None = ...) -> None:
        '''

        material(self, operation, parameter)

            Manages object-local overrides of material parameters. This is
            basically the scripting equivalent of the Material Override menu in
            the parameter editor for objects. It allows you to create parameters
            on an object that override the equivalent values on the object\'s
            material.

            The operation argument should be one of the following strings:


            \\"override\\"
                Create parameters on the object to override all material
                parameters.

            \\"select\\"
                Select and create object parameters to override material
                parameters.

            \\"remove\\"
                Removes all object parameter overrides.

            \\"rmdefault\\"
                Removes any unchanged object parameters (that is, that are
                currently set to their default value).

            \\"sync\\"
                Synchronize the object parameter overrides with the parameter
                definitions on the material.

            \\"revert\\"
                Revert any parameter overrides on the object to their values on
                the material.

            \\"addlist\\"
                (Followed by a second argument containing a list of parameter
                names strings.) Creates object parameters to override the named
                parameters on the material.

          > 
          > myobject = hou.node(\\"/obj/obj1\\")
          > 
          > # Add all material overrides
          > myobject.material(\\"override\\")
          > 
          > # Remove all material overrides
          > myobject.material(\\"remove\\")
          > 
          > # Add specific overrides for \\"baseColor\\" and \\"roughness\\" parameters
          > myobject.material(\\"addlist\\", [\\"baseColor\\", \\"roughness\\"])

        '''

class Prim:
    """

    hou.Prim

    Each Prim resides inside a Geometry object and stores some sort of 3D
    geometric primitive, like a polygon, a NURBS curve, or a volume. Each
    primitive usually contains a set of Vertex objects, each of which
    references a Point object.

    This class has a number of subclasses for the different primitive types,
    such as hou.Polygon and hou.Volume.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Return the hou.Geometry object containing this primitive.


        """
    def number(self) -> int:
        """

        number(self) -> int

            Return the number of this primitive. Primitives are numbered
            sequentially starting from 0, and the primitives returned by
            hou.Geometry.prims are in order by their number.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.primType enum value

            Return a hou.primType value containing the type of this primitive
            (e.g. polygon, NURBS curve, metaball, etc).


        """
    def attribType(self) -> EnumValue:
        """

        attribType(self) -> hou.attribType enum value

            Return the enumerated value hou.attribType.Prim. Points, primitives,
            vertices, and geometry support the same set of methods for querying
            their attributes, and this method is one of them.

            See also:

          * hou.Point.attribType

          * hou.Vertex.attribType

          * hou.Geometry.attribType

          * hou.attribType


        """
    def vertices(self) -> Iterator[Vertex]:
        """

        vertices(self) -> generator of hou.Vertex

            Return a sequence of the vertices contained in this primitive.

            If the primitive is a face (e.g. a polygon or NURBS curve), the
            result corresponds to the order of the vertices in that face. If it
            is a surface (e.g. a NURBS mesh), however, the primitive has a 2D
            array of vertices, and this method returns all vertices in the 2D
            array, ordered by the rows.

            See hou.Surface.vertex for more information about the relationship
            between the 2D vertex array and the sequential vertex index, and for
            more ways to access the vertices in a surface.


        """
    def numVertices(self) -> int:
        """

        numVertices(self) -> int

            A shortcut for len(self.vertices()). You probably don't need to call
            this method.


        """
    def edges(self) -> Tuple[Edge, ...]: ...
    def numEdges(self) -> int: ...
    def floatAttribValue(self, attrib: Attrib|str) -> float:
        """

        floatAttribValue(self, attrib) -> float

            Return the primitive attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not float of size 1.

            In most cases, you'll just use hou.Prim.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
    def floatListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[float,...]:
        """

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the primitive attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Prim.attribValue.


        """
    def intAttribValue(self, attrib: Attrib|str) -> int:
        """

        intAttribValue(self, name_or_attrib) -> int

            Return the primitive attribute value for a particular integer
            attribute of size 1. The attribute may be specified by name or by
            hou.Attrib object. See hou.Point.floatAttribValue for more
            information.


        """
    def intListAttribValue(self, name_or_attrib: Attrib|str) -> Tuple[int,...]:
        """

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the primitive attribute value for a particular integer
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of ints. See
            hou.Prim.floatListAttribValue for more information.


        """
    def stringAttribValue(self, attrib: Attrib|str) -> str:
        """

        stringAttribValue(self, name_or_attrib) -> str

            Return the primitive attribute value for a particular string
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Prim.floatAttribValue for more information.


        """
    def stringListAttribValue(self, name_or_attrib: Attrib|str) -> Tuple[str,...]:
        """

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the primitive attribute value for a particular string
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of strings.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Prim.attribValue.


        """
    def dictAttribValue(self, attrib: Attrib|str) -> AttribDictReturnType:
        """

        dictAttribValue(self, name_or_attrib) -> dict

            Return the primitive attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Prim.floatAttribValue for more information.


        """
    def dictListAttribValue(self, name_or_attrib: Attrib|str) -> Sequence[AttribDictReturnType]:
        """

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the primitive attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Prim.floatAttribValue for more information.


        """
    def setAttribValue(self, name_or_attrib: Attrib|str, attrib_value: AttribArgType|AttribDictArgType) -> None:
        '''

        setAttribValue(self, name_or_attrib, attrib_value)

            Store an attribute value in this primitive. The attribute may be
            specified by name or by hou.Attrib object, and must be an existing
            primitive attribute in the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute\'s data type does not match the value passed in. If
            the attribute\'s size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute\'s size.

            If the attribute is an array, the seqeunce must be a flat array, not
            an array of tuples. If the attribute is float, ensure the python
            objects are float, and not integer (1.0, not 1).

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # Create a float primitive attribute of size 3 named \\"Cd\\", and assign
          > # each primitive a unique color.  This code will work from inside a Python
          > # SOP, but not from the Python shell.
          > geo = hou.pwd().geometry()
          > color_attrib = geo.addAttrib(hou.attribType.Prim, \\"Cd\\", (1.0, 1.0, 1.0))
          > num_prims = len(geo.prims())
          > color = hou.Color()
          > for prim in geo.prims():
          >     fraction = float(prim.number()) / num_prims
          >     # Give each primitive a different hue, but full saturation and value.
          >     # Store the RGB value in the attribute.
          >     color.setHSV((fraction * 255, 1, 1))
          >     prim.setAttribValue(color_attrib, color.rgb())

        '''
    def intrinsicNames(self) -> Tuple[str, ...]:
        """

        intrinsicNames(self) -> tuple of str

            Returns a tuple of strings representing the intrinsic values
            available for this primitive. Different primitive types will have
            different intrinsic values available. You can then get or set the
            value using hou.Prim.intrinsicValue and/or
            hou.Prim.setIntrinsicValue.


        """
    def intrinsicValue(self, intrinsic_name: str) -> AttribReturnType:
        """

        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple

            Gets the value of an intrinsic, often computed, value of the
            primitive, such as bounds, measuredarea, vertexcount, and so on.

            Most intrinsic values are computed, such as measuredarea, however a
            few are writeable with hou.Prim.setIntrinsicValue. For example,
            sphere primitives have a transform matrix as part of their
            definition.

            You can also view these values in the user interface using the
            geometry spreadsheet.

            Raises hou.OperationFailed if the given intrinsic name does not
            exist. You can get a list of the available intrinsic value names
            with hou.Prim.intrinsicNames. Different primitive types will have
            different intrinsic values available.

            Bounding box intrinsic values like bounds or packedbounds are
            returned in (xmin, xmax, ymin, ymax, zmin, zmax) order.


        """
    def intrinsicSize(self, intrinsic_name: str) -> int:
        """

        intrinsicSize(self, intrinsic_name) -> int

            Returns the intrinsic value's tuple size.


        """
    def intrinsicReadOnly(self, intrinsic_name: str) -> bool:
        """

        intrinsicReadOnly(self, intrinsic_name) -> bool

            Returns whether the intrinsic is read-only or can be modified with
            hou.Prim.setIntrinsicValue.


        """
    def setIntrinsicValue(self, intrinsic_name: str, value: AttribArgType) -> None:
        """

        setIntrinsicValue(self, intrinsic_name, value)

            Some intrinsic values can be modified. For example, you change the
            internal size and rotation (transform) of a sphere primitive by
            passing a 9 float tuple representing the transform to
            hou.Prim.setIntrinsicValue. Raises hou.OperationFailed if the
            intrinsic is not writeable or does not accept the passed value, or
            if the given intrinsic name does not exist.


        """
    def attribValue(self, attrib: Attrib|str) -> AttribReturnType|AttribDictReturnType:
        """

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return the value stored in this primitive for a particular
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Looking an attribute value using a hou.Attrib object is slightly
            faster than looking it up by name. When looking up attribute values
            inside a loop, look up the hou.Attrib object outside the loop, and
            pass it into this method.

            When looking up the attribute values of all primitives, it is faster
            to call hou.Geometry.primFloatAttribValues or
            hou.Geometry.primFloatAttribValuesAsString than to call this method
            for each primitive in the geometry.

            Raises hou.OperationFailed if no attribute exists with this name.


        """
    def positionAtInterior(self, u: float, v: float, w: float = 0.0) -> Vector3:
        """

        positionAtInterior(self, u, v, w=0.0) -> hou.Vector3

            Given normalized (i.e. from 0 to 1) u, v, w values, return the
            interior position of the primitive at that parametric location.

            Use hou.Face.positionAt for querying positions along the perimeter.


        """
    def attribValueAtInterior(self, attrib: Attrib|str, u: float, v: float, w: float = ...) -> AttribReturnType:
        """

        attribValueAtInterior(self, attrib_or_name, u, v, w=0.0) -> int, float,
        str or tuple

            Return an attribute value at the normalized u, v, w parametric
            position in the interior of the primitive.

            Raises hou.OperationFailed if the attribute is not a point or vertex
            attribute. If you want a primitive attribute value, it doesn't vary
            across the surface, so use hou.Prim.attribValue.

            If the attribute name is N the primitive's intrinsic normal is
            evaluated, not the value from any point or primitive attributes.

            Use hou.Face.attribValueAt for querying attributes along the
            perimeter.


        """
    def boundingBox(self) -> BoundingBox:
        """

        boundingBox(self) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box that is sized and positioned
            to be large enough to hold this primitive.


        """
    def nearestToPosition(self, position: Sequence[float]) -> Tuple[float, float, float]:
        """

        nearestToPosition(self, pos3)

            Given a sequence of three floats containing a position, find the
            location on this primitive that is closest to that position. Returns
            a tuple containing the u value on this primitive, the v value on
            this primitive, and the distance to this primitive.

            NOTE: The returned UVs are in real coordinates, use the
            primuvConvert to switch to unit coordinates to match VEX's xyzdist.


        """
    def groups(self) -> Tuple[PrimGroup, ...]:
        """

        groups(self) -> tuple of hou.PrimGroup

            Return a tuple of the primitive groups that contain this primitive.


        """
    def primuvConvert(self, uv: Sequence[float]|Vector2, mode: int, tol: float|None = ...) -> Vector2:
        """

        primuConvert(self, u, mode, tol)

            Given a 1D u coordinate, compute the location in a different
            coordinate system. The tol argument is optional. See the
            primuvconvert VEX function for the different valid modes.


        """
    def primuConvert(self, u: float, mode: int, tol: float|None = ...) -> float: ...

    # Missing methods added by stubgen
    def voxelRangeAsBool(self, range: BoundingBox) -> Tuple[bool, ...]: ...
    def voxelRangeAsInt(self, range: BoundingBox) -> Tuple[int, ...]: ...
    def voxelRangeAsFloat(self, range: BoundingBox) -> Tuple[float, ...]: ...
    def voxelRangeAsVector3(self, range: BoundingBox) -> Sequence[Vector3]: ...

class Face(Prim):
    """

    hou.Face

    A Face is a kind of geometry primitive (Prim object) that contains a
    sequence of vertices (Vertex objects). How these vertices are used
    depends on the type of face; polygons, for example, use the vertices to
    define the edges of the polygon, while NURBS curves use them as control
    points.

    A hou.Surface, on the other hand, stores a two dimension grid of
    vertices, and might be a NURBS surface, Bezier surface, or quadrilateral
    mesh.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isClosed(self) -> bool:
        """

        isClosed(self) -> bool

            Return whether the first and last vertex are connected.

            An open face forms a multi-segment line or curve, since the first
            and last vertices are not connected. A closed face forms a very thin
            surface.


        """
    def closed(self) -> bool:
        """

        closed(self) -> bool

            This method is deprecated in favor of hou.isClosed.


        """
    def setIsClosed(self, on: bool) -> None:
        """

        setIsClosed(self, on)

            Set whether the face is open or closed. See hou.Face.isClosed for
            more information. You would typically call this method from the code
            of a Python-defined SOP.

            Note that this method will raise hou.OperationFailed on a Bezier
            curve. See hou.Geometry.createBezierCurve for more information.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def normal(self) -> Vector3:
        """

        normal(self) -> hou.Vector3

            Return the vector that's perpendicular to the face.


        """
    def positionAt(self, u: float) -> Vector3:
        """

        positionAt(self, u) -> hou.Vector3

            Given a normalized (i.e. from 0 to 1) u value, return the position
            of the curve at that parametric location.


        """
    def attribValueAt(self, attrib_or_name: Attrib|str, u: float, du: float = ...) -> int|float|str|Tuple[int,...]|Tuple[float,...]:
        """

        attribValueAt(self, attrib_or_name, u, du=0) -> int, float, str or tuple

            Return an attribute value at a normalized u parametric position on
            the curve. If du is 0, returns the interpolated attribute value;
            otherwise, returns the derivative of the attribute value.

            Raises hou.OperationFailed if the attribute is not a point or vertex
            attribute. If you want a primitive attribute value, it doesn't vary
            across the surface, so use hou.Prim.attribValue.


        """
    def vertex(self, index: int) -> Vertex:
        """

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
    def addVertex(self, point: Point) -> Vertex:
        """

        addVertex(self, point) -> hou.Vertex

            Create a new vertex inside this face, adding it to the end of the
            vertex list. You would typically call this method from the code of a
            Python-defined SOP.

            point is a hou.Point object that the new vertex will refer to. See
            hou.Vertex for information on the relationship between points and
            vertices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # These arrays define point positions and a set of polygons composed
          > # of those points.  Note that the point positions could also be floating
          > # point values.
          > point_positions = ((0,0,0), (1,0,0), (1,1,0), (0,1,0))
          > poly_point_indices = ((0,1,2), (2,3,0))
          > 
          > geo = hou.pwd().geometry()
          > 
          > # Create all the points.
          > points = []
          > for position in point_positions:
          >     points.append(geo.createPoint())
          >     points[-1].setPosition(position)
          > 
          > # Now create the polygons, adding vertices that refer to the points.
          > for point_indices in poly_point_indices:
          >     poly = geo.createPolygon()
          >     for point_index in point_indices:
          >         poly.addVertex(points[point_index])

            See also:

          * hou.Geometry.createPoint

          * hou.Geometry.createPolygon


        """
    def arcLength(self, u_start: float, u_stop: float, divs: int = 10) -> float:
        """

        arcLength(self, u_start, u_stop, divs=10) ->float

            Given normalized (i.e. from 0 to 1) u_start and u_stop values,
            return the length of the arc of curve. divs represents the number of
            divisions per spans. Increasing it increases the precision of the
            computation.


        """

class PackedPrim(Prim):
    '''

    hou.PackedPrim

    A packed primitive.

    See packed primitives for more information.

    To set contents of the packed primitive, use the
    hou.Prim.setIntrinsicValue method:

    > prim = myGeometry.createPacked(\\"PackedDisk\\")
    > prim.setIntrinsicValue(\\"unexpandedfilename\\", \\"defgeo.bgeo\\")

    To get the list of available intrinsic attributes you can set:

      * View a packed primitive of the type you want in the geometry
        spreadsheet and turn on display of intrinsic attributes.

        or

      * In a Houdini tools command line, type ginfo -IP to see a list of all
        intrinsic attributes on all packed primitive types.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def transform(self) -> Matrix3:
        """

        transform(self) -> hou.Matrix3

            Returns the local 3x3 transform associated with this primitive. The
            transform doesn't include the local point transform or any
            transforms inside the primitive (for example, transforms inside an
            Alembic file).


        """
    def fullTransform(self) -> Matrix4:
        """

        fullTransform(self) -> hou.Matrix4

            Returns the full 4x4 transform for this primitive's geometry. This
            includes translations due to points and any transforms inside the
            primitive (for example, transforms inside an Alembic file).


        """
    def setTransform(self, transform: Matrix4) -> None:
        """

        setTransform(self, m4)

            Sets this primitive's local transform. This sets the local 3x3
            transform and the translation of the point. This does not affect any
            transforms inside the primitive (for example, transforms inside an
            Alembic file).

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            m4
                A hou.Matrix4 object containing the full transform.


        """
    def vertex(self, index: int) -> Vertex:
        """

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """

class BaseKeyframe:
    """

    hou.BaseKeyframe

    Abstract base class for all keyframe class.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def evaluatedType(self) -> EnumValue:
        """

        evaluatedType(self) -> hou.parmData enum value

            Returns the type that the keyframe evaluates to.


        """
    def setExpression(self, expression: str, language: Optional[EnumValue] = None) -> None:
        """

        setExpression(self, expression, language=None)

            Sets the keyframe's expression and language.

            This function raises TypeError if language is not a value from
            hou.exprLanguage.

            See expression(), expressionLanguage(), isExpressionSet(),
            isExpressionLanguageSet().


        """
    def expression(self) -> str:
        """

        expression(self) -> str

            Returns the keyframe's expression. For example, in cases where the
            keyframe has had two values set the interpolating function is
            returned e.g. bezier(), spline() etc.

            This function raises hou.KeyframeValueNotSet if an expression has
            not been set.

            See setExpression() and isExpressionSet().


        """
    def isExpressionSet(self) -> bool:
        """

        isExpressionSet(self) -> bool

            Returns whether the keyframe's expression is set.

            See setExpression() and expression().


        """
    def expressionLanguage(self) -> EnumValue:
        """

        expressionLanguage(self) -> hou.exprLanguage enum value

            Returns the keyframe's expression's language.

            This function raises hou.KeyframeValueNotSet if an expression
            language has not ben set.

            See setExpression(), and isExpressionLanguageSet().


        """
    def isExpressionLanguageSet(self) -> bool:
        """

        isExpressionLanguageSet(self) -> bool

            Returns whether the keyframe expression's language is set.

            See setExpression() and expressionLanguage().


        """
    def setTime(self, time: float) -> None:
        """

        setTime(self, time)

            Sets the keyframe's time in seconds. Using the number of frames per
            second (hou.fps), setting the time also sets the frame number. For
            example, with an fps of 24, then setting the time to 2 seconds will
            set the frame number to 49.

            See time().


        """
    def isTimeSet(self) -> bool:
        """

        isTimeSet(self) -> bool

            Returns whether the keyframe's time is set.

            See setTime() and time().


        """
    def time(self) -> float:
        """

        time(self) -> double

            Returns the keyframe's time in seconds.

            This function raises hou.KeyframeValueNotSet if the time or frame
            has not been set.

            See setTime() and setFrame().


        """
    def setFrame(self, frame: float) -> None:
        """

        setFrame(self, frame)

            Sets the keyframe's frame number. Using the number of frames per
            second (hou.fps), setting the frame number also sets the time. For
            example, with an fps of 24, then setting the frame number to 49 will
            set the time to 2 seconds.

            See frame().


        """
    def frame(self) -> float:
        """

        frame(self) -> double

            Returns the keyframe's frame number.

            This function raises hou.KeyframeValueNotSet if the frame or time
            has not been set.

            See setFrame() and setTime().


        """
    def asCode(self, brief: bool = False, save_keys_in_frames: bool = False, function_name: Optional[str] = None) -> str:
        '''

        asCode(self, brief=False, save_keys_in_frames=False, function_name=None)
        -> str

            Returns a script of Python statements that can be executed to create
            the keyframe. To run the script, use either Python\'s exec or
            execfile functions.


            brief
                When <brief> is True, the output script omits commands for
                setting unused values, slopes and accelerations. This parameter
                only applies to non-string keyframes. The value of <brief> must
                be either True or False.

            save_keys_in_frames
                When <save_keys_in_frames> is True, asCode outputs commands for
                setting channel and key times in samples (frames) instead of
                seconds. The value of <save_keys_in_frames> must be either True
                or False.

            function_name
                If <function_name> is specified, then the output script is
                wrapped in a Python function definition with the given name.
                <function_name> must be a non-zero length string consisting of
                only alphanumeric and underscore characters. Any invalid
                characters are internally converted to underscores.

                The function returns a reference to the newly created keyframe
                object.

            Here is an example of saving the output to a file and then loading
            it back into Houdini:

          > # Get a reference to the target keyframe.
          > tx_parm = hou.parm(\\"/obj/geo1/tx\\")
          > key = tx_parm.keyframes()[0]
          > 
          > # Execute asCode and write the output script to file.
          > script = key.asCode()
          > f = open(\\"create_key.py\\", \\"w\\")
          > f.write(script)
          > f.close()
          > 
          > # Execute the script.  The new keyframe will be stored 
          > # in the \'hou_keyframe\' variable.
          > execfile(\\"create_key.py\\")
          > 
          > # Commit the keyframe back into the node parameter.
          > tx_parm.setKeyframe(hou_keyframe)

            Here is an example of saving the output into a function and then
            calling it in Houdini:

          > # Get a reference to the target keyframe.
          > tx_parm = hou.node(\\"/obj/geo1\\").Parm(\\"tx\\")
          > key = tx_parm.keyframes()[0]
          > 
          > # Execute asCode and write the function definition to file.
          > func = key.asCode(function_name=\\"createKeyframe\\")
          > f = open(\\"keylib.py\\", \\"w\\")
          > f.write(func)
          > f.close()
          > 
          > # Call the function definition.
          > import keylib
          > hou_keyframe = keylib.createKeyframe()
          > 
          > # Commit the keyframe back into the node parameter.
          > tx_parm.setKeyframe(hou_keyframe)

        '''

class ChannelGraphSelection:
    """

    hou.ChannelGraphSelection

    A copy of an Animation Editor Graph Selection.


    """
    thisown: Incomplete
    def __init__(self, path: str|None = ..., flags: Sequence[int] = ...) -> None:
        """

        hou.ChannelGraphSelection

        A copy of an Animation Editor Graph Selection.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def parm(self) -> Parm:
        """

        path(self) -> str

            Return the parameter path associated with the channel graph
            selection.


        """
    def path(self) -> str: ...
    def keyframes(self) -> Tuple[BaseKeyframe, ...]:
        """

        keyframes(self) -> tuple of hou.BaseKeyframe

            Return the keyframes on the parameter. The selection arrays match
            the order of the keyframes.


        """
    def flags(self) -> Tuple[int, ...]:
        """

        setFlags(self) -> tuple of int

            Set the raw selection flags for all keyframes of the parameter.


        """
    def setFlags(self, flags: Sequence[int]) -> None: ...
    def values(self) -> Tuple[int, ...]:
        """

        values(self) -> tuple of int

            Return the value selection flags for all keyframes of the parameter.


        """
    def timeMarks(self) -> Tuple[int, ...]:
        """

        timeMarks(self) -> tuple of int

            Return the time mark selection flags for all keyframes of the
            parameter.


        """
    def slopes(self) -> Tuple[int, ...]:
        """

        slopes(self) -> tuple of int

            Return the slope selection flags for all keyframes of the parameter.


        """
    def accelerations(self) -> Tuple[int, ...]:
        """

        accelerations(self) -> tuple of int

            Return the acceleration selection flags for all keyframes of the
            parameter.


        """
    def segments(self) -> Tuple[int, ...]:
        """

        segments(self) -> tuple of int

            Return the segment selection flags for all keyframes of the
            parameter.


        """
    def inValues(self) -> Tuple[int, ...]:
        """

        inValues(self) -> tuple of int

            Return the incoming value selection flags for all keyframes of the
            parameter.


        """
    def inSlopes(self) -> Tuple[int, ...]:
        """

        inSlopes(self) -> tuple of int

            Return the incoming slope selection flags for all keyframes of the
            parameter.


        """
    def inAccelerations(self) -> Tuple[int, ...]:
        """

        inAccelerations(self) -> tuple of int

            Return the incoming acceleration selection flags for all keyframes
            of the parameter.


        """
    def outValues(self) -> Tuple[int, ...]:
        """

        outValues(self) -> tuple of int

            Return the outgoing value selection flags for all keyframes of the
            parameter.


        """
    def outSlopes(self) -> Tuple[int, ...]:
        """

        outSlopes(self) -> tuple of int

            Return the outgoing slope selection flags for all keyframes of the
            parameter.


        """
    def outAccelerations(self) -> Tuple[int, ...]:
        """

        outAccelerations(self) -> tuple of int

            Return the outgoing acceleration selection flags for all keyframes
            of the parameter.


        """
    def selectValues(self, sel: Sequence[int], _in: bool = True, out: bool = True) -> None:
        """

        selectValues(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe value handles.


        """
    def selectTimeMarks(self, sel: Sequence[int]) -> None:
        """

        selectTimeMarks(self,selections)

            Select time mark handles.


        """
    def selectSlopes(self, sel: Sequence[int], _in: bool = True, out: bool = True) -> None:
        """

        selectSlopes(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe slope handles.


        """
    def selectAccelerations(self, sel: Sequence[int], _in: bool = True, out: bool = True) -> None:
        """

        selectAccelerations(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe acceleration handles.


        """
    def selectSegments(self, sel: Sequence[int]) -> None:
        """

        selectSegments(self,selections)

            Select segment handles.


        """
    def deselectValues(self, sel: Sequence[int], _in: bool = True, out: bool = True) -> None:
        """

        deselectValues(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe value handles.


        """
    def deselectTimeMarks(self, sel: Sequence[int]) -> None:
        """

        deselectTimeMarks(self,selections)

            Select time mark handles.


        """
    def deselectSlopes(self, sel: Sequence[int], _in: bool = True, out: bool = True) -> None:
        """

        deselectSlopes(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe slope handles.


        """
    def deselectAccelerations(self, sel: Sequence[int], _in: bool = True, out: bool = True) -> None:
        """

        deselectAccelerations(self,selections,sel_incoming,sel_outgoing)

            Select incoming or outgoing keyframe acceleration handles.


        """
    def deselectSegments(self, sel: Sequence[int]) -> None:
        """

        deselectSegments(self,selections)

            Select segment handles.


        """

class NodeType:
    '''

    hou.NodeType

    Information common to all instances of a type of node, such as the
    parameters.

    For example, the Geometry object and Subdivide SOP are node types.
    /obj/geo1 and /obj/geo2, on the other hand, are Node instances of the
    Geometry object node type.

    You can get a NodeType object from a Node object with hou.Node.type. For
    example, if /obj/geo1 is a geometry object, hou.node(\\"/obj/geo1\\").type()
    will return the NodeType corresponding to all geometry objects.

    All the node types in Houdini are organized into categories, and a node
    type is uniquely identified by its category and node type name. For
    example, objects, SOPs, POPs, etc. are node type categories. You can
    also access a NodeType object from a category with
    hou.NodeTypeCategory.nodeTypes. Similarly, you can call hou.nodeType_
    with the category and node type name.

    See also hou.Node and hou.NodeTypeCategory.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def category(self) -> NodeTypeCategory:
        """

        category(self) -> hou.NodeTypeCategory

            Return the node type category for this node type. For example, for
            the geometry object, the result is the object returned by
            hou.objNodeTypeCategory.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of this node type. For example, for the geometry
            object type, the name is geo. The name and the node type category
            together uniquely identify a node type.


        """
    def nameComponents(self) -> Tuple[str, ...]:
        """

        nameComponents(self) -> tuple of str

            Returns a tuple of node type name components that constitute the
            full node type name. The components in the tuple appear in the
            following order: scope network type, node type namespace, node type
            core name, and version.

          > # parse the full name into components
          > >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver::2.0')
          > >>> node_type.nameComponents()
          > ('', '', 'pyrosolver', '2.0')

        """
    def description(self) -> str:
        '''

        description(self) -> str

            Return the description of this node type that appears in the tab
            menu. For example, for the geometry object, the description is
            \\"Geometry\\". This description is also called the operator label in
            Houdini.


        '''
    def nameWithCategory(self) -> str:
        '''

        nameWithCategory(self) -> str

            Return the name of the node type, prefixed with the name of the node
            type category. For example, for the geometry object, this function
            returns \\"Object/geo\\". The category name and type name together
            uniquely identify a node type.

          > >>> hou.nodeType(hou.objNodeTypeCategory(), \\"geo\\").nameWithCategory()
          > \'Object/geo\'

        '''
    def namespaceOrder(self) -> Tuple[str, ...]:
        """

        namespaceOrder(self) -> tuple of str

            Returns a node type name list sorted in the descending namespace
            precedence order. The node types in the list have the same base type
            as this node type. They have different namespace and/or version.

            Houdini uses this list when resolving an unqualified type name in
            hou.Node.createNode() when the Edit > Preferences > Shelf Tools and
            Tab Menu > TAB Menu Operator Namespace Filtering preference is set
            to Show single Operator from the Preferred Namespace; it will use
            the first entry in that list that matches the name specified in the
            function.

          > # parse the full name into components
          > >>> node_type = hou.nodeType(hou.dopNodeTypeCategory(), 'pyrosolver')
          > >>> node_type.namespaceOrder()
          > ('pyrosolver::2.0', 'pyrosolver')

            NOTE
                The hou.Node.createNode() behavior may differ if the
                HOUDINI_OPNAMESPACE_HIERARCHY environment variable is set.


        """
    def versionNamespaceOrder(self) -> Tuple[str, ...]:
        """

        versionNamespaceOrder(self) -> tuple of str

            Returns a node type name list sorted in the descending version
            precedence order. The node types in the list have the same namespace
            and base type as this node type, but have different versions.

            Houdini uses this list when resolving an unqualified type name in
            hou.Node.createNode() when the Edit > Preferences > Shelf Tools and
            Tab Menu > TAB Menu Operator Namespace Filtering preference is set
            to Show Only Operators with Preferred Versions; it will use the
            first entry in that list that matches the name specified in the
            function.


            NOTE
                The hou.Node.createNode() behavior may differ if the
                HOUDINI_OPNAMESPACE_HIERARCHY environment variable is set.


        """
    def icon(self) -> str:
        """

        icon(self) -> str

            Return the name or path of the icon for this node type. Note that
            node types that ship with Houdini use a name instead of a full path,
            and Houdini uses its search path to locate the icon with that name.


        """
    def resolvedIcon(self) -> str:
        """

        resolvedIcon(self) -> str

            Same as icon() except that this is intended for use with UI elements
            which may not know how to resolve certain syntaxes particular to
            specific hou.NodeType subclasses.


        """
    def minNumInputs(self) -> int:
        """

        minNumInputs(self) -> int

            Return the minimum number of inputs that nodes of this type can
            have. If these inputs are not connected, the node will generate an
            error.


        """
    def maxNumInputs(self) -> int:
        """

        maxNumInputs(self) -> int

            Return the maximum number of inputs that nodes of this type can
            have. Return 9999 if this node type can accept an unlimited number
            of inputs (e.g. the merge SOP).


        """
    def maxNumOutputs(self) -> int:
        """

        maxNumOutputs(self) -> int

            Return the maximum number of outputs that nodes of this type can
            have. Most node types have only one output, but some, like the split
            dop, can have multiple.


        """
    def isGenerator(self) -> bool:
        """

        isGenerator(self) -> bool

            Return if this node type has been flagged as a generator. For
            example, a grid SOP generates new geometry, while a subdivide SOP
            does not, and instead processes the geometry passed into it. See
            also hou.NodeType.minNumInputs.


        """
    def isManager(self, include_management_types: bool = True) -> bool:
        """

        isManager(self, include_management_types=True) -> bool

            Return whether this NodeType is a manager. The manager node
            instances are /obj, /out, /part, /ch, /shop, /img, and /vex.

            If include_management_types is set to True then this method will
            additionally return True if this node type is a management node type
            such as a SHOP network, or VOP network, etc.


        """
    def hasUnorderedInputs(self) -> bool:
        """

        hasUnorderedInputs(self) -> bool

            Return whether it is impossible for this node type to have gaps in
            its connected inputs. For example, the cookie SOP has two inputs,
            and it's possible for only the second input to be connected, so this
            method would return False. However, the merge SOP cannot have any
            gaps in its inputs, so this method would return True.

            See also hou.Node.inputs, hou.Node.inputConnections, and
            hou.Node.inputConnectors.


        """
    def hasEditableInputData(self) -> bool:
        """

        hasEditableInputData(self) -> bool

            Return True if nodes of this node type allow the user to associate
            data with each input to the node. The purpose of this data may vary
            from one node type to another. This data can be accessed with
            methods such as hou.Node.editableInputName and
            hou.Node.setEditableInputName.


        """
    def parmTemplates(self) -> Tuple[ParmTemplate, ...]:
        """

        parmTemplates(self) -> tuple of hou.ParmTemplate

            Return a tuple of parm templates for the parameters on this node
            type. Note that spare parameters on individual node instances are
            not included in this tuple, since they are independent from the node
            type.


        """
    def parmTemplateGroup(self) -> ParmTemplateGroup:
        """

        parmTemplateGroup(self) -> hou.ParmTemplateGroup

            Return the group of parm templates corresponding to this node type's
            parameter interface.

            See hou.ParmTemplateGroup for more information on parm template
            groups. To change the parameter interface for a node type defined by
            a digital asset, see hou.HDADefinition.setParmTemplateGroup.


        """
    def hasPermanentUserDefaults(self) -> bool:
        """

        hasPermanentUserDefaults(self) -> bool

            Returns whether a user has set permanent defaults for this node
            type.

            See also hou.Parm.hasTemporaryDefaults


        """
    def isReadable(self) -> bool:
        """

        isReadable(self) -> bool

            Return True if this node type is readable and False otherwise. A
            readable node type is one that you can create node instances from.


        """
    def isWritable(self) -> bool:
        """

        areContentsViewable(self) -> bool

            Return True if the node network contained in the node type is
            viewable and False otherwise.


        """
    def areContentsViewable(self) -> bool: ...
    def containedNodeTypes(self) -> Tuple[str, ...]:
        """

        containedNodeTypes(self) -> tuple of str

            Return a tuple of all NodeType names of the contents of an HDA.


        """
    def childTypeCategory(self) -> Optional[NodeTypeCategory]: ...
    def helpUrl(self) -> str:
        """

        helpUrl(self) -> str

            Return the URL where the node type stores the documentation, e.g., a
            file name or an HDA section path. May return an empty string if node
            type does not know where the documentation is.


        """
    def defaultHelpUrl(self) -> str:
        """

        defaultHelpUrl(self) -> str

            Return a generic URL that the help system will try to resolve to the
            actual location that stores the node type documentation. The generic
            URL is in the form operator:table/optypename and may include
            additional information such as a namespace or a version.


        """
    def embeddedHelp(self) -> str:
        """

        embeddedHelp(self) -> str

            Return the help text embedded in this node type. Return an empty
            string if no embedded help exists.

            The embedded help is searched for in two different places in the
            following order:

          * If an HDK node, the text given by its OP_Operator::getHDKHelp()
            override

          * If an HDA node, the corresponding result of
            hou.HDADefinition.embeddedHelp()


        """
    def defaultShape(self) -> str:
        """

        defaultShape(self) -> str

            Return the name of the shape used to display a node of this type in
            the network view if no shape is explicitly assigned to the node.


        """
    def setDefaultShape(self, shape: str) -> None:
        """

        setDefaultShape(self, shape)

            Set the name of the shape used to display a node of this type in the
            network view if no shape is explicitly assigned to the node. Pass
            None as the shape parameter to remove the type-specific default.


        """
    def defaultColor(self) -> Color:
        """

        defaultColor(self) -> hou.Color

            Return the color used to display a node of this type in the network
            view if the node's hou.nodeFlag.ColorDefault flag is set.


        """
    def setDefaultColor(self, color: Color) -> None:
        """

        setDefaultColor(self, color)

            Set the color used to display a node of this type in the network
            view if the node's hou.nodeFlag.ColorDefault flag is set. Pass None
            as the color parameter to remove the type-specific default.


        """

class ApexNodeType(NodeType):
    """

    hou.ApexNodeType

    Information common to all instances of a type of APEX node.

    This class specializes the generic hou.NodeType class for APEX node
    types.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def hidden(self) -> bool:
        """

        hidden(self) -> bool

            Return whether or not this node type appears in the tab menu.


        """
    def deprecated(self) -> bool:
        """

        deprecated(self) -> bool

            Return whether or not this node type has been marked deprecated.


        """
    def definition(self) -> Optional[HDADefinition]:
        """

        definition(self) -> hou.HDADefinition

            This method is only provided for duck typing with hou.OpNodeType. It
            always returns None.


        """

class OpNodeType(NodeType):
    """

    hou.OpNodeType

    Information common to all instances of a type of OP node.

    This class specializes the generic hou.NodeType class for Houdini OP
    node types. This subclass adds information about digital assets,
    instances, and registration information that is specific to Houdini's OP
    node types.

    A digital asset can define a node type. In this case the nodes contained
    inside the asset's definition implement the node type's algorithm, and
    you can customize the parameters in the node type using the Type
    Properties dialog,


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def sectionData(self, name: str) -> str:
        """

        sectionData(self, section_name) -> str

            Return the data stored in the specified section of the HDA
            definition corresponding to this node type. If the HDA definition
            doesn't contain the specified section or this node type doesn't
            correspond to a digital asset, return an empty string.


        """
    def binarySectionData(self, name: str) -> bytes:
        """

        binarySectionData(self, section_name) -> bytes

            Only available in Python 3.

            Return a bytes object containing the data stored in the specified
            section of the HDA definition corresponding to this node type. Ideal
            for sections containing binary data. If the HDA definition doesn't
            contain the specified section or this node type doesn't correspond
            to a digital asset, return an empty bytes object.


        """
    def hasSectionData(self, name: str) -> bool:
        """

        hasSectionData(self, section_name) -> bool

            Return True if this node type corresponds to a digital asset whose
            definition contains the section. Otherwise, return False.


        """
    def source(self) -> EnumValue:
        '''

        source(self) -> hou.nodeTypeSource enum value

            Return a hou.nodeTypeSource enumerated value to indicate if this
            node type is implemented in VEX, RSL, or the HDK (in C++), or if it
            is a built-in node type that ships with Houdini.

          > >>> obj_cat = hou.objNodeTypeCategory()
          > >>> sop_cat = hou.sopNodeTypeCategory()
          > >>> hou.nodeType(obj_cat, \\"biped_auto_rig\\").source()
          > nodeTypeSource.Subnet
          > >>> hou.nodeType(sop_cat, \\"mountain\\").source()
          > nodeTypeSource.VexCode

        '''
    def sourcePath(self) -> str:
        '''

        sourcePath(self) -> str

            Return the path to the source for this node type, or \\"Internal\\" if
            it is a built-in node type. If the node was created using the HDK,
            return the path to the shared object/dll for the node type.

          > >>> obj_cat = hou.objNodeTypeCategory()
          > >>> hou.nodeType(obj_cat, \\"biped_auto_rig\\").sourcePath()
          > \'oplib:/Object/biped_auto_rig?Object/biped_auto_rig\'
          > >>> hou.nodeType(obj_cat, \\"geo\\").sourcePath()
          > \'Internal\'

        '''
    def sourceNetwork(self) -> Optional[Node]:
        """

        sourceNetwork(self) -> hou.Node or None

            If this node type is a digital asset, return the Node instance whose
            contents define the digital asset. Otherwise, return None.


        """
    def definition(self) -> Optional[HDADefinition]:
        """

        definition(self) -> hou.HDADefinition

            If this node type corresponds to a digital asset, return the
            hou.HDADefinition. Otherwise, return None.


        """
    def allInstalledDefinitions(self) -> Tuple[HDADefinition, ...]:
        """

        allInstalledDefinitions(self) -> tuple of hou.HDADefinition

            Search all installed operator type libraries and return a tuple of
            available hou.HDADefinition objects providing definitions for this
            node type.

            Houdini allows multiple otl files to be loaded at the same time that
            each contain definitions for the same node type. The definition in
            use is called the current definition. See also
            hou.HDADefinition.isCurrent.


        """
    def uninstallFromPath(self, path: str) -> None: ...
    def hdaModule(self) -> Optional[HDAModule]:
        """

        hdaModule(self) -> hou.HDAModule

            Return the HDAModule object for this node type. If the type is not
            for a digital asset, the module is empty. Otherwise, the module
            contains the functions, constants, classes, etc. in the user-defined
            PythonModule section of the digital asset.

            You can use hou.Node.hdaModule as a shortcut to access the HDAModule
            from a node instance.

            See hou.HDAModule for more information.


        """
    def hdaViewerStateModule(self) -> Optional[HDAViewerStateModule]:
        """

        hdaViewerStateModule(self) -> hou.HDAViewerStateModule

            This method creates an instance of hou.HDAViewerStateModule for this
            node type. Returns an empty object if the type is not for a digital
            asset.

            See also hou.Node.hdaViewerStateModule.


        """
    def hdaViewerHandleModule(self) -> Optional[HDAViewerHandleModule]:
        """

        hdaViewerHandleModule(self) -> hou.HDAViewerHandleModule

            This method creates an instance of hou.HDAViewerHandleModule for
            this node type. Returns an empty object if the type is not for a
            digital asset.

            See also hou.Node.hdaViewerHandleModule.


        """
    def aliases(self) -> Tuple[str, ...]:
        """

        aliases(self) -> tuple of str

            Return all current aliases for this node type. See
            hou.NodeType.addAlias for an example.


        """
    def addAlias(self, alias: str) -> None:
        '''

        addAlias(self, alias)

            Add an alias for this node type. You can use this alias when
            creating new nodes.

          > >>> geo_type = hou.nodeType(hou.objNodeTypeCategory(), \\"geo\\")
          > >>> geo_type.addAlias(\\"transformable\\")
          > >>> geo_type.aliases()
          > (\'transformable\',)
          > >>> hou.node(\\"/obj\\").createNode(\\"transformable\\")
          > <hou.ObjNode of type geo at /obj/geo1>

        '''
    def removeAlias(self, alias: str) -> None:
        """

        removeAlias(self, alias)

            Remove an alias for this node type.


        """
    def hidden(self) -> bool:
        """

        hidden(self) -> bool

            Return whether or not this node type appears in the tab menu. See
            also hou.NodeType.setHidden.


        """
    def setHidden(self, hidden: bool) -> None:
        """

        setHidden(self, hidden)

            Set whether or not this node type appears in the tab menu. See also
            hou.NodeType.hidden.


        """
    def deprecated(self) -> bool:
        """

        deprecated(self) -> bool

            Return whether or not this node type has been marked deprecated. See
            also hou.NodeType.deprecationInfo.


        """
    def deprecationInfo(self) -> dict[str, str|Self]:
        """

        deprecationInfo(self) -> dict of str to str or hou.NodeType

            If the node type has been marked deprecated, this call will return
            the deprecation information as a dictionary.

            The currently supported keys are:


            'version'
                The version of Houdini where this operator got deprecated. The
                form is either major.minor, or major.minor.build (e.g. 14.0 or
                14.5.122). This item is always present.

            'new_type'
                The new node type this node was replaced with. This can be used
                to create a system of automatic node replacement.

            'reason'
                This lists the reason given for the deprecation, in case there
                is no new node to replace with.


        """
    def instances(self) -> Tuple[OpNode, ...]:
        """

        instances(self) -> tuple of hou.Node

            Return a tuple of all the nodes of this type in the current scene.


        """
    def defaultState(self) -> str:
        """

        defaultState(self) -> str

            Return a string with the name of the default viewer state for
            controlling nodes of this type. Returns an empty string if the node
            type doesn't have an associated viewer state registered.


        """
    def boundHandles(self) -> dict[str, str]:
        """

        boundHandles(self) -> dict of str to str

            Return a dictionary of unique handle binding descriptions to the
            type of bound handle. Along with the handleBindings method, this
            provides the same information as the ombindinfo hscript function.


        """
    def handleBindings(self, bound_handle: str) -> dict[str, str]:
        """

        handleBindings(self, bound_handle) -> dict of str to str

            Given a bound handle description (returned as a key in the dict
            returned by boundHandles), return a dictionary of handle parameters
            to the node parameter bound to that handle parameter. Along with the
            boundHandles method, this provides the same information as the
            ombindinfo hscript function.


        """
    def generatorFlag(self) -> bool: ...
    def managerFlag(self) -> bool: ...
    def unorderedInputsFlag(self) -> bool: ...

    # Missing methods added by stubgen
    def category(self) -> OpNodeTypeCategory: ...

class NodeTypeCategory:
    """

    hou.NodeTypeCategory

    Represents a category of node types, such as surface nodes (SOPs) or
    dynamics nodes (DOPs).

    Use hou.nodeTypeCategories to get a dict of node type category names to
    NodeTypeCategory objects. You can use hou.objNodeTypeCategory,
    hou.sopNodeTypeCategory, etc. to directly access a particular node type
    category.

    See also hou.NodeType and hou.Node.

    > # Get the names of all the node type categories.
    > >>> hou.nodeTypeCategories().keys()
    > ['Shop', 'Cop2', 'CopNet', 'ChopNet', 'Object', 'Driver',
    > 'Chop', 'Sop', 'Manager', 'Vop', 'Director', 'Dop', 'VopNet']

    RELATED

      * hou.nodeTypeCategories

      * hou.objNodeTypeCategory

      * hou.sopNodeTypeCategory

      * hou.dopNodeTypeCategory

      * hou.copNodeTypeCategory

      * hou.cop2NodeTypeCategory

      * hou.shopNodeTypeCategory_

      * hou.vopNodeTypeCategory

      * hou.ropNodeTypeCategory

      * hou.chopNodeTypeCategory

      * hou.cop2NetNodeTypeCategory

      * hou.vopNetNodeTypeCategory

      * hou.chopNetNodeTypeCategory

      * hou.managerNodeTypeCategory

      * hou.rootNodeTypeCategory


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of this node type category.


        """
    def typeName(self) -> str: ...
    def label(self) -> str:
        """

        label(self) -> str

            Returns the descriptive of this node type category that appears in
            network editor panes.


        """
    def nodeTypes(self) -> dict[str, NodeType]:
        """

        nodeTypes(self) -> dict of str to hou.NodeType

            Return a dict mapping node type names to node types in this
            category.

            For example, if this node type category is SOPs, the keys in the
            dictionary would be box, sphere, polyextrude, subdivide, etc.

            Note that the node types in this category may not all be instances
            of the same class. For example, most node types in the SOP node type
            category are instances of hou.SopNodeType, but some, like SHOP
            networks, CHOP networks, etc. are not.

          > # Access the box SOP's node type.
          > hou.sopNodeTypeCategory().nodeTypes()['box']
          > def findNodeTypes(node_type_category, pattern):
          >     '''Return a list of node types in a particular node type category
          >        whose names match a pattern.'''
          >     import fnmatch
          > 
          >     return [node_type
          >         for node_type_name, node_type in node_type_category.nodeTypes().items()
          >         if fnmatch.fnmatch(node_type_name, pattern)]

            See also hou.nodeType_.


        """
    def nodeType(self, type_name: str) -> Optional[NodeType]:
        """

        nodeType(self, type_name) -> hou.NodeType or None

            Returns a single node type that matched the provided type name.
            Returns None if the type name doesn't match a node type in this
            category.


        """
    def hasSubNetworkType(self) -> bool:
        """

        hasSubNetworkType(self) -> bool

            Return True if the category has a primary sub-network node type and
            False otherwise. For example, this method returns True for the Sop
            node type category that has the subnet node type as its primary sub-
            network node type. The method returns False for the VopNet node type
            category that does not have a primary sub-network node type but has
            multiple sub-network node types such as displace, surface and fog.


        """
    def subNetworkType(self) -> Optional[NodeType]:
        """

        subNetworkType(self) -> hou.NodeType or None

            Return the category's primary sub-network node type or None if the
            category has no primary sub-network node type.


        """
    def defaultShape(self) -> str: ...
    def clearDefaultShapes(self) -> None: ...
    def setDefaultShape(self, shape: str) -> None: ...
    def defaultColor(self) -> Color: ...
    def clearDefaultColors(self) -> None: ...
    def setDefaultColor(self, color: Color) -> None: ...
    def defaultWireStyle(self) -> str: ...
    def setDefaultWireStyle(self, wirestyle: str) -> None: ...

class ApexNodeTypeCategory(NodeTypeCategory):
    """

    hou.ApexNodeTypeCategory

    Represents the node type category for APEX node types.

    This class specializes the generic hou.NodeTypeCategory class for APEX
    node types. There is only one APEX node type category, which is
    accessible by calling hou.apexNodeTypeCategory. Note that this node type
    category does not appear in the list returned by hou.nodeTypeCategories,
    as that method only returns OP node type categories.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class OpNodeTypeCategory(NodeTypeCategory):
    """

    hou.OpNodeTypeCategory

    Represents a category of OP node types, such as surface nodes (SOPs) or
    dynamics nodes (DOPs).

    Use hou.nodeTypeCategories to get a dict of node type category names to
    NodeTypeCategory objects. You can use hou.objNodeTypeCategory,
    hou.sopNodeTypeCategory, etc. to directly access a particular node type
    category.

    See also hou.OpNodeType and hou.OpNode.

    RELATED

      * hou.nodeTypeCategories

      * hou.objNodeTypeCategory

      * hou.sopNodeTypeCategory

      * hou.dopNodeTypeCategory

      * hou.copNodeTypeCategory

      * hou.cop2NodeTypeCategory

      * hou.shopNodeTypeCategory_

      * hou.vopNodeTypeCategory

      * hou.ropNodeTypeCategory

      * hou.chopNodeTypeCategory

      * hou.cop2NetNodeTypeCategory

      * hou.vopNetNodeTypeCategory

      * hou.chopNetNodeTypeCategory

      * hou.managerNodeTypeCategory

      * hou.rootNodeTypeCategory


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def createDigitalAsset(self, name: Optional[str] = None, hda_file_name: Optional[str] = None, description: Optional[str] = None) -> NodeType:
        """

        createDigitalAsset(self, name=None, hda_file_name=None,
        description=None) -> NodeType

            Create a digital asset in this category. Use
            hou.Node.createDigitalAsset instead as the representative node will
            setup the metadata properly.


            name
                The name of the node type that the new digital asset will
                define. If None, nothing is done.

            hda_file_name
                The name of the hda file where Houdini will save the digital
                asset. If None Houdini will use
                $HOME/houdiniX.Y/hda/OPcustom.hda.

            description
                The name that will appear in the tab menu. If None, Houdini will
                use the name for the description.


        """
    def nodeVerbs(self) -> dict[str, OpVerb]:
        """

        nodeVerbs(self) -> dict of str to hou.SopVerb

            Return a dict mapping verb names to node verbs in this category.

            Most verbs are named after their corresponding node type.
            Alternatively, given a hou.SopNode, one can use hou.SopNode.verb to
            extract the verb.


        """
    def nodeVerb(self, verb_name: str) -> Optional[OpVerb]:
        """

        nodeVerb(self, name) -> hou.SopVerb or None

            Return a specific verb from the provided verb name. Returns None if
            no matching verb is found.


        """
    def viewerStates(self, viewer_type: EnumValue) -> Tuple[ViewerState, ...]:
        """

        viewerStates(self, viewer_type) -> tuple of hou.ViewerState


        """
    def loadDSO(self, dso_path: str) -> None:
        """

        loadDSO(self, dso_path)

            Loads the HDK custom operator identified by the given file path for
            this node type category. It will use the HOUDINI_DSO_PATH
            environment variable to find it if necessary.


        """

    # Missing methods added by stubgen
    def nodeTypes(self) -> dict[str, OpNodeType]: ...  # type: ignore[override]

class ParmTemplate:
    '''

    hou.ParmTemplate

    Describes a parameter tuple (its name, type, etc.). This is base class
    for all parameter templates.

    ParmTemplates are most often used when describing a parameter in a
    digital asset definition\'s parameter interface or when describing an
    individual node\'s parameter layout (including its spare parameters). A
    ParmTemplate describes a parameter and the type of data it holds, but it
    does not store the current value of a parameter; only hou.Parm objects
    inside hou.ParmTuple objects actually store parameter values. You can
    think of a hou.ParmTuple as an instance of a ParmTemplate. For example,
    the \\"t\\" parm tuple on geometry objects can be described by a
    hou.FloatParmTemplate -- it has a label of \\"Transform\\", a data type of
    hou.parmData.Float, 3 components, a naming scheme of
    hou.parmNamingScheme.XYZW, etc. Each geometry object node has a
    hou.ParmTuple named \\"t\\" that uses this ParmTemplate.

    Note that ParmTemplate objects are just data containers, and they have
    no live relationship with objects in Houdini. For example, a hou.OpNode
    object corresponds directly to a node in Houdini, and if the node is
    renamed in Houdini hou.Node.name will return the new name.
    ParmTemplates, on the other hand, do not have a live relationship.
    Creating a ParmTemplate based on a spare parameter or asset definition
    parameter will simply copy the information into the ParmTemplate object,
    and modifying the object will not affect the spare parameter/asset
    parameter.

    Note also that ParmTemplate objects are always instances of a subclass
    of this class, so you cannot construct an instance of this class
    directly.

    To manipulate the parameters of a digital asset, you can retrieve the
    asset\'s current set of ParmTemplates into a hou.ParmTemplateGroup using
    hou.HDADefinition.parmTemplateGroup. You can then modify the group,
    adding parameters to it and replacing parameters in it, and save the
    group back to the asset definition with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can change a
    node\'s parameter layout with hou.OpNode.parmTemplateGroup and
    hou.OpNode.setParmTemplateGroup.

    You can also ask a hou.ParmTuple for its ParmTemplate in order to find
    out information about the parameter, such as allowed ranges of values,
    the label displayed to the user in the parameter pane, the parameter\'s
    popup help, etc.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def clone(self) -> ParmTemplate:
        """

        clone(self) -> hou.ParmTemplate

            Return a copy of this parm template.

            This method can be called on an instance of a ParmTemplate subclass
            and an instance of the subclass is properly returned.


        """
    def name(self) -> str:
        """

        name(self) -> string

            Return the internal name of the parm template. This is the name that
            hou.ParmTuple objects created from this parm template will have.

            Tha names of hou.ParmTemplate objects inside a multiparm block will
            have a # at the end of their name which will be replaced by the
            multiparm instance number when an the hou.ParmTuple object is
            instantiated.

            Note that the names of hou.Parm objects inside ParmTuples based off
            this ParmTemplate are determined by this name, the number of
            components in this parm template, and the naming scheme. See the
            namingScheme method for more information.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Change the internal name of this parm template. Remember that
            ParmTemplates just store data, so the name change will not have any
            effect unless this parm template is later used to modify a parameter
            layout in Houdini.

            Parameters inside a multiparm block must have a # at the end of
            their name which will be replaced by the multiparm's instance
            number.


        """
    def label(self) -> str:
        """

        label(self) -> string

            Return the name of the parameter tuple that is displayed in the
            parameter pane.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self, label)

            Change the name of the label that is displayed in the parameter
            pane.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.parmTemplateType enum value

            Return the enumerated value identifying the type of this parameter.

            Remember that ParmTemplate objects are always instances of a
            subclass of this class. The following table shows the mapping
            between hou.parmTemplateType enumeration values and ParmTemplate
            subclasses:


            Enumerated Value
                ParmTemplate Subclass

            hou.parmTemplateType.Int
                hou.IntParmTemplate

            hou.parmTemplateType.Float
                hou.FloatParmTemplate

            hou.parmTemplateType.String
                hou.StringParmTemplate

            hou.parmTemplateType.Toggle
                hou.ToggleParmTemplate

            hou.parmTemplateType.Menu
                hou.MenuParmTemplate

            hou.parmTemplateType.Button
                hou.ButtonParmTemplate

            hou.parmTemplateType.FolderSet
                hou.FolderSetParmTemplate

            hou.parmTemplateType.Folder
                hou.FolderParmTemplate

            hou.parmTemplateType.Separator
                hou.SeparatorParmTemplate

            hou.parmTemplateType.Label
                hou.LabelParmTemplate

            hou.parmTemplateType.Ramp
                hou.RampParmTemplate


        """
    def dataType(self) -> EnumValue:
        """

        dataType(self) -> hou.parmData enum value

            Return the data type stored in hou.Parm instances inside
            hou.ParmTuple instances corresponding to this ParmTemplate.

            For example, suppose this parm tuple is a hou.FloatParmTemplate with
            3 components. The corresponding hou.ParmTuple will have 3 hou.Parm
            objects inside it, and each will store a floating point value. In
            this example, this method would return hou.parmData.Float.


        """
    def look(self) -> EnumValue:
        """

        look(self) -> hou.parmLook enum value

            Return the look of this parameter in the parameter pane. For
            example, a tuple of 3 floats can be displayed as a 3D vector or as
            an RGB color.

            See hou.parmLook for more information.


        """
    def setLook(self, look: EnumValue) -> None:
        """

        setLook(self, look)

            Set the look of this parameter to a hou.parmLook enum value.

            See the look method for more information.


        """
    def namingScheme(self) -> EnumValue:
        '''

        namingScheme(self) -> hou.parmNamingScheme enum value

            Return the naming scheme used to name parameters inside the parm
            tuple for this ParmTemplate.

            For example, if the naming scheme is hou.parmNamingScheme.XYZW and
            the parm template is named \\"foo\\" and has 3 components, the
            parameters will be named \\"foox\\", \\"fooy\\", and \\"fooz\\". On the other
            hand, if the naming scheme was hou.parmNamingScheme.Base1, the
            parameters would be named \\"foo1\\", \\"foo2\\", and \\"foo3\\".

            Note that when the parm template only has 1 component, the parm name
            is the same as the parm tuple name.

            See hou.parmNamingScheme for more information.


        '''
    def setNamingScheme(self, naming_scheme: EnumValue) -> None:
        """

        setNamingScheme(self, naming_scheme)

            Set the naming scheme used to name parameters inside the parm tuple
            for this ParmTemplate to a hou.parmNamingScheme enum value.

            See the namingScheme method for more information.


        """
    def numComponents(self) -> int:
        """

        numComponents(self) -> int

            Return the number of values stored inside hou.ParmTuple instances of
            this ParmTemplate.

            For example, if this parm template has 3 components, there will be 3
            parameter fields displayed in the parameter pane and there will be 3
            hou.Parm objects inside a hou.ParmTuple based off this parm
            template.


        """
    def setNumComponents(self, num_components: int) -> None:
        """

        setNumComponents(self, num_components) -> int

            Set the number of values stored inside hou.ParmTuple instances of
            this ParmTemplate.

            Note that some ParmTemplate subclasses only support one component,
            so calling this method with a value other than 1 may raise a
            hou.OperationFailed exception. Also, changing the number of
            components may automatically change the size of the tuple of default
            values for some ParmTemplate subclasses.


        """
    def disableWhen(self) -> str:
        """

        disableWhen(self) -> str

            This method is deprecated in favor of the conditionals method.


        """
    def setDisableWhen(self, disable_when: str) -> None:
        """

        setDisableWhen(self, disable_when)

            This method is deprecated in favor of the setConditional method.


        """
    def conditionals(self) -> dict[EnumValue, str]:
        """

        conditionals(self) -> dict of hou.parmCondType enum value to str

            Returns the set of conditionals currently affecting this parameter.

            See the Conditionals section of the Operator Type Properties window
            help for more information on this string.


        """
    def setConditional(self, cond_type: EnumValue, conditional: str) -> None:
        """

        setConditional(self, type, conditional)

            Set a conditional string of the given hou.parmCondType type for this
            parameter. This string consists of rules on how this parameter's
            display behaves when other parameters change.

            See the Conditionals section of the Operator Type Properties window
            help for more information on this string.


        """
    def isHidden(self) -> bool:
        """

        isHidden(self) -> bool

            Return whether this parameter is hidden in the parameter pane.


        """
    def hide(self, on: bool) -> None:
        """

        hide(self, on)

            Marks this parameter as visible or invisible in the parameter pane.

            Note that hidden parameters still exist, and can be evaluated,
            channel-referenced, etc. They simply will not be displayed in the
            parameter pane.


        """
    def isLabelHidden(self) -> bool:
        """

        isLabelHidden(self) -> bool

            Return whether the label for this parameter is hidden in the
            parameter pane.


        """
    def hideLabel(self, on: bool) -> None:
        """

        hideLabel(self, on)

            Hide or show the label for this parameter in the parameter pane.


        """
    def joinsWithNext(self) -> bool:
        """

        joinsWithNext(self) -> bool

            Return whether this parameter is displayed on the same line as the
            next parameter in the parameter pane.


        """
    def setJoinWithNext(self, on: bool) -> None:
        """

        setJoinWithNext(self, on)

            Sets whether this parameter is displayed on the same line as the
            next parameter in the parameter pane.


        """
    def joinWithNext(self) -> bool:
        """

        joinWithNext(self) -> bool

            This method is deprecated in favor of the joinsWithNext method.


        """
    def help(self) -> str:
        """

        help(self) -> str

            Return the help that Houdini displays when you hover over the
            parameter label in the parameter pane.


        """
    def setHelp(self, help: str) -> None:
        """

        setHelp(self, help)

            Set the help that Houdini displays when you hover over the parameter
            label in the parameter pane.


        """
    def scriptCallback(self) -> str:
        """

        scriptCallback(self) -> str

            Return the contents of the script that Houdini runs when this
            parameter changes. This script is most commonly used in
            hou.ButtonParmTemplate objects to respond to the button being
            pressed.

            Note that Houdini uses the tags dictionary to store the script
            callback information.


        """
    def setScriptCallback(self, script_callback: str) -> None:
        """

        setScriptCallback(self, script_callback)

            Set the callback script to the given string. This script runs in
            response to a parameter change.

            See the scriptCallback method for more information.


        """
    def scriptCallbackLanguage(self) -> EnumValue:
        """

        scriptCallbackLanguage(self) -> hou.scriptLanguage enum value

            Return the language of the script that Houdini runs when this
            parameter changes.

            Note that Houdini uses the tags dictionary to store the script
            callback information.

            See also the scriptCallback method.


        """
    def setScriptCallbackLanguage(self, script_callback_language: EnumValue) -> None:
        """

        setScriptCallbackLanguage(self, script_callback_language)

            Set the script callback language to a hou.scriptLanguage enum value.

            See the scriptCallbackLanguage method for more information.


        """
    def tags(self) -> dict[str, str]:
        """

        tags(self) -> dict of string to string

            Return a dictionary of extra data stored in the parm template.

            Houdini uses this dictionary to attach arbitrary data to parm
            templates. The keys in this dictionary vary depending on the
            ParmTemplate type and its use.


        """
    def setTags(self, tags: Mapping[str, str]) -> None:
        """

        setTags(self, tags)

            Set the dictionary of extra data stored in this parm template.

            See the tags method for more information.


        """
    def asCode(self, function_name: Optional[str] = None, variable_name: Optional[str] = None) -> str:
        '''

        asCode(self, function_name=None, variable_name=None) -> str

            Return a string containing Python statements that can be executed to
            recreate the parameter template. To run the string, use Python\'s
            compile, or execfile functions or the exec statement.


            function_name
                If <function_name> is specified, then the code returned creates
                a Python function with the given name. <function_name> must be a
                non-zero length string consisting of only alphanumeric and
                underscore characters. Any invalid characters are internally
                converted to underscores.

                The function returns a reference to the newly created parameter
                template object.

            variable_name
                The name of a Python variable that the result code will assign
                to. If None, Houdini uses the variable name \\"hou_parm_template\\".

            Here is an example of saving the output to a file and then loading
            it back into Houdini:

          > # Get a reference to the target parameter template.
          > node = hou.node(\\"/obj/geo1\\")
          > parm_template = node.parm(\\"tx\\").parmTemplate()
          > 
          > # Execute asCode and write the output script to a file.
          > code = parm_template.asCode()
          > source_file = open(\\"create_parm_template.py\\", \\"w\\")
          > source_file.write(code)
          > source_file.close()
          > 
          > # Execute the script.  The new parameter template will be stored 
          > # in the \'hou_parm_template\' variable.
          > execfile(\\"create_parm_template.py\\")
          > 
          > # Add a spare parameter to the node using the saved parameter
          > # template.
          > node.addSpareParmTuple(hou_parm_template)

            Here is an example of saving the output into a function in a file
            and then calling it from Houdini:

          > # Get a reference to the target parameter template.
          > node = hou.node(\\"/obj/geo1\\")
          > parm_template = node.parm(\\"tx\\").parmTemplate()
          > 
          > # Execute asCode and write the function definition to a file.
          > code = parm_template.asCode(function_name=\\"createParmTemplate\\")
          > source_file = open(\\"parmtemplatelib.py\\", \\"w\\")
          > source_file.write(code)
          > source_file.close()
          > 
          > # Call the function definition.
          > import parmtemplatelib
          > hou_parm_template = parmtemplatelib.createParmTemplate()
          > 
          > # Add a spare parameter to the node using the saved parameter
          > # template.
          > node.addSpareParmTuple(hou_parm_template)

        '''

class ParmTemplateGroup:
    """

    hou.ParmTemplateGroup

    A group of parameter templates used to represent the parameter layout of
    a node or the parameters in a digital asset definition.

    This class stores a group of hou.ParmTemplate objects. You can create an
    empty group, create a group from a sequence of parm templates, or create
    a group from the parameter definitions of a digital asset or from a
    particular node's current parameter layout. Similarly, you can set an
    asset's parameters or a node's parameter interface to the contents of a
    parameter group.

    You can get an asset's parm templates with
    hou.HDADefinition.parmTemplateGroup and set them with
    hou.HDADefinition.setParmTemplateGroup. Similarly, you can get an
    individual node's parameter definition with hou.OpNode.parmTemplateGroup
    and set it with hou.OpNode.setParmTemplateGroup. When setting a node's
    parameter interface, any parms that are not in the node's type's set of
    parms will be added as spare parameters. Similarly, if parameters in the
    node's type are not present in the group, they will be automatically
    added at the end and made invisible. Also, if they exist but the types,
    labels, looks, naming schemes, etc are different, Houdini will discard
    all changes you attempt to make to these reserved parameters except for
    visibility settings.

    It is important to understand the difference between folder parm
    templates and folder set parm templates when using ParmTemplateGroups.
    Folder sets correspond directly to hou.ParmTuple objects -- there is one
    parm tuple (that contains one parm) for each set of folders, and
    changing the value of that parm changes which folder is displayed.
    Individual Folders, on the other hand, do not directly correspond to
    hou.ParmTuple objects, but they are used in Houdini's <Type Properties>
    dialog and they make it easy to add individual folders and control which
    parameters are inside a folder. Unlike a hou.FolderSetParmTemplate, a
    hou.FolderParmTemplate stores the set of parm templates inside that
    folder. When a node or definition's parameters are set to the contents
    of a parm template group, the folder sets are determined and the parm
    tuple name for the set is the name of the first folder in that set. The
    names of the other folders in the set are not used.

    ParmTemplateGroups use folder parm templates instead of folder set parm
    templates. Attempting to add a FolderSetParmTemplate to a group will
    raise hou.OperationFailed. Asking a parm tuple for its parm template, on
    the other hand, may return a folder set but will never return a folder.
    Previously, folder parameter templates and parm template groups did not
    exist, so the only way to add folders were with special methods like
    hou.HDADefinition.addParmFolder and hou.OpNode.addSpareParmFolder. Now
    that that they exist, you may create folders by passing folder parm
    templates to hou.HDADefinition.addParmTuple and
    hou.OpNode.addSpareParmTuple. However, using parm template groups is
    preferred over calling these methods.

    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does. The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block. Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.


    NOTE
        ParmTemplateGroups store their own copy of the parm templates.
        Asking for the parm templates in a group will return a copy of the
        parm templates; modifying those copies will not change the contents
        of the group. For example, to change a parameter in a group you
        cannot simply call find and modify the hou.ParmTemplate it returned.
        Instead, you must call replace after making modifications to the
        parameter.

        Parm template copies returned by the ParmTemplateGroup can be used
        as arguments to methods that accept parm templates as layout
        placeholders (i.e. insertBefore, insertAfter, appendToFolder, etc.).
        However, changes made to the ParmTemplateGroup will invalidate any
        previously returned parm template copies as layout placeholders. In
        that case, you need to obtain new parm template copies from the
        group.


    """
    thisown: Incomplete
    def __init__(self, parm_templates: Sequence[ParmTemplate] = ...) -> None:
        '''

        __init__(self, parm_templates=())

            Create a new group from an optional sequence of parm templates. If
            none are passed in, the new group will be empty.

            Because groups and folder parm templates can both be constructed
            using a sequence of contained parm templates, it is possible to
            construct a parm template group with parameters inside folders using
            a single expression. The following example creates a group with two
            folders and with parameters inside each of those folders:

          > >>> group = hou.ParmTemplateGroup((
          > ... hou.FolderParmTemplate(\\"folder\\", \\"Physical\\", (
          > ...     hou.FloatParmTemplate(\\"mass\\", \\"Mass\\", 1),
          > ...     hou.FloatParmTemplate(\\"density\\", \\"Density\\", 1),
          > ... )),
          > ... hou.FolderParmTemplate(\\"folder\\", \\"Divisions\\", (
          > ...     hou.FloatParmTemplate(\\"divisions\\", \\"Divisions\\", 3),
          > ...     hou.ToggleParmTemplate(\\"laser\\", \\"Laser Scan\\", default_value=True),
          > ... )),
          > ... ))
          > >>> group.entries()
          > (<hou.FolderParmTemplate name=\'folder\' label=\'Physical\' folder_style=Tabs>,
          > <hou.FolderParmTemplate name= \'folder\' label=\'Divisions\' folder_style=Tabs>)
          > >>> group.entries()[0].parmTemplates()[0]
          > <hou.FloatParmTemplate name=\'mass\' label=\'Mass\' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>
          > >>> group.entriesWithoutFolders()
          > (<hou.FloatParmTemplate name=\'mass\' label=\'Mass\' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>,
          >  <hou.FloatParmTemplate name=\'density\' label=\'Density\' length=1 naming_scheme=XYZW look=Regular default_value=(0,)>,
          >   <hou.FloatParmTemplate name=\'divisions\' label=\'Divisions\' length=3 naming_scheme=XYZW look=Regular default_value=(0,0,0)>,
          >    <hou.ToggleParmTemplate name=\'laser\' label=\'Laser Scan\' default_value=True>)

            Raises hou.OperationFailed if any of the parm templates in the
            sequence are hou.FolderSetParmTemplate objects.


        '''
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def find(self, name: str) -> Optional[ParmTemplate]:
        '''

        find(self, name) -> hou.ParmTemplate or None

            Search in this group for a parm template whose name matches the
            specified one. Return a copy of the parm template or None if no
            match was found.

            Note that this function returns a copy of the parm template stored
            in this group. Modifying the copy will not affect the parameters in
            this group. The following example shows how to use the find and
            replace methods to modify the \\"pos\\" parm template in the group:

          > >>> parm_template = group.find(\\"pos\\")
          > >>> parm_template.setLabel(\\"Position\\")
          > >>> group.replace(\\"pos\\", parm_template)

            If you created the group from existing parameters, folder parm
            templates in the same folder set will share the same name, so
            searching for a folder using this method may return the first folder
            in the folder set. To instead search for a folder by its folder
            label, use findFolder.

            Note that, in general, the group does not prevent you from adding
            two parameters with the same name. In this case, searching for a
            parameter with this name will return the first one. Note, though,
            that when when setting this group to a node or asset definition\'s
            parms, either the duplicate parameters will be renamed on an
            exception will be raised. See the rename_conflicting_parms parameter
            to hou.HDADefinition.setParmTemplateGroup for more information.


        '''
    def findIndices(self, name_or_parm_template: ParmTemplate|str) -> Tuple[int,...]:
        """

        findIndices(self, name_or_parm_template) -> tuple of int

            Search in this group for a parm template and return a tuple of
            integers corresponding to the indices of the parm in the group.
            Return an empty tuple if no match was found.


            name_or_parm_template
                Either the name of the parm template or another hou.ParmTemplate
                object to compare against when searching for a match.

            If the parm template was found and it is not inside any folders, the
            result tuple will contain a single integer with the index of the
            parm template. Otherwise, the first entry will be the index of a
            folder inside the group, the next will be an index of a folder
            inside that folder, and so on until the last index is an index of a
            parm template inside a folder.

            See also findIndicesForFolder.


        """
    def findFolder(self, label_or_labels: str|Sequence[str]) -> ParmTemplate|None:
        """

        findFolder(self, label_or_labels) -> hou.FolderParmTemplate or None

            Search in this group for a folder parm template with the given
            label. Return a copy of the hou.FolderParmTemplate or None if the
            folder wasn't found.


            label_or_labels
                Either a string containing the folder's label or a tuple of
                strings containing the labels of containing folders as well as
                the folder's label.

            Note that a folder parm template's label is what appears in the
            interface in the parameter dialog. The folder parm template's name
            is used to determine the name of the parm tuple for the folder set,
            if the folder is the first in the folder set. See the documentation
            for this class for more information.


        """
    def findIndicesForFolder(self, name_or_parm_template: ParmTemplate|str) -> Tuple[int,...]:
        """

        findIndicesForFolder(self, label_or_labels) -> tuple of int

            Search in this group for a folder parm template with the given
            label. Return an empty tuple if no match was found.

            See findFolder for a description of the parameter and findIndices
            for a description of the return value.

            Note that this method does not accept a parm template. However, if
            you have a folder parm template and want to find its indices, simply
            call findIndices on the folder parm template.


        """
    def entryAtIndices(self, indices: Sequence[int]) -> ParmTemplate:
        '''

        entryAtIndices(self, indices) -> hou.ParmTemplate

            Given a sequence of integer indices return a copy of the
            hou.ParmTemplate object at that location. The indices are of the
            format returned by findIndices.

            Like the hou.ParmTemplate.find and hou.ParmTemplate.entries methods,
            this method returns a copy of the parm template stored inside this
            group. Modifying the copied parm template will not affect the
            contents of this group. Use replace to change a parm template.

            Raises hou.OperationFailed if the indices are invalid, including
            when the indices sequence is empty.

            This method could be implemented as follows:

          > def entryAtIndices(self, indices):
          >     if len(indices) == 0:
          >         raise hou.OperationFailed(\\"Invalid indices\\")
          >     parm_template = self.entries()[indices[0]]
          > 
          >     # If there are multiple indices then we should have just looked up
          >     # a folder parm template.
          >     for index in indices[1:]:
          >         parm_template = parm_template.parmTemplates()[index]
          >     return parm_template

        '''
    def containingFolderIndices(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int]) -> Tuple[int,...]:
        """

        containingFolderIndices(self, name_or_parm_template_or_indices) -> tuple
        of int

            Return the indices of the folder in this group containing a given
            parm template. Return an empty tuple if no match was found.

            See replace for a description of the parameter and findIndices for a
            description of the return value.

            Raises hou.OperationFailed if the parameter is not inside the group
            or is not inside a folder.


        """
    def containingFolder(self, name_or_parm_template: str|ParmTemplate) -> FolderParmTemplate:
        """

        containingFolder(self, name_or_parm_template) -> hou.FolderParmTemplate

            Return a copy of the hou.FolderParmTemplate in this group containing
            a parm template.


            name_or_parm_template
                Either the name of the parm template or another hou.ParmTemplate
                object to compare against when searching for a match.

            Raises hou.OperationFailed if the parameter is not inside the group
            or is not inside a folder.


        """
    def entries(self) -> Tuple[ParmTemplate, ...]:
        """

        entries(self) -> tuple of hou.ParmTemplate

            Return a tuple containing copies of the parm templates inside this
            group.

            Note that folders are returned as hou.FolderParmTemplate objects,
            and each folder parm template contains the parm templates inside it.
            Use hou.FolderParmTemplate.parmTemplates to access the elements in a
            folder.

            The following example creates a function named allParmTemplates that
            returns a single sequence of parm templates, including folders, for
            all parm templates in the group:

          > def allParmTemplates(group_or_folder):
          >     for parm_template in group_or_folder.parmTemplates():
          >         yield parm_template
          > 
          >     # Note that we don't want to return parm templates inside multiparm
          >     # blocks, so we verify that the folder parm template is actually
          >     # for a folder.
          >         if (parm_template.type() == hou.parmTemplateType.Folder and
          >         parm_template.isActualFolder()):
          >             for sub_parm_template in allParmTemplates(parm_template):
          >                 yield sub_parm_template

            See also the parmTemplates method.


        """
    def parmTemplates(self) -> Tuple[ParmTemplate, ...]:
        """

        parmTemplates(self) -> tuple of hou.ParmTemplate

            This method is simply an alias for the entries method.

            It makes it easier to search down through a parm template group for
            items nested in folders, since the hou.FolderParmTemplate class also
            has a method named parmTemplates. The following example shows how to
            look up the labels for a folder parameter given its indices:

          > def folderLabels(parm_template_group, indices):
          >     container = parm_template_group
          >     result = []
          >     for index in indices:
          >         container = container.parmTemplates()[index]
          >         result.append(container.label())
          >     return result

        """
    def entriesWithoutFolders(self) -> Tuple[ParmTemplate, ...]:
        """

        entriesWithoutFolders(self) -> tuple of hou.ParmTemplate

            Return a tuple containing all the non-folder parm templates inside
            this group. The output is the flattened set of parm templates in the
            group, and includes the non-folder parms inside folders.

            Like entries, this method returns a copy of the parm templates
            inside this group.

            Note that this function does not return parm templates for entries
            inside multiparm blocks.

            Also see the entries method for the example function
            allParmTemplates.


        """
    def replace(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int], parm_template: ParmTemplate) -> None:
        """

        replace(self, name_or_parm_template_or_indices, parm_template)

            Replace a parm template inside this group with another parm
            template.


            name_or_parm_template_or_indices
                Either the name of the parm template being replaced, a copy of
                the parm template, or a tuple of integer indices that identify
                the parm template and any containing folders.

            This method changes the contents of this group. Note that it stores
            a copy of the parm template in the group, so future changes to the
            parm template passed in will not affect the group.

            See the find method for a simple example of how to use this method.

            Note that parm templates for reserved parameters (for example, the
            transform parameters in object-level digital assets) can be replaced
            in the parm template group, but all aspects of reserved parameters
            except for their visibility and join settings will be restored to
            their defaults when you save this group to a node or asset
            definition.

            Raises hou.OperationFailed if the parm template doesn't exist.


        """
    def insertBefore(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int], parm_template: ParmTemplate) -> None:
        """

        insertBefore(self, name_or_parm_template_or_indices, parm_template)

            Insert a parm template inside this group before an existing one. The
            new parm template will be in the same folder as the existing one.

            See replace for a description of the name/parm template/indices
            parameter.

            Use appendToFolder to add an entry to a empty folder. Use append to
            add an entry to an empty parm template group.


        """
    def insertAfter(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int], parm_template: ParmTemplate) -> None:
        """

        insertAfter(self, name_or_parm_template_or_indices, parm_template)

            Insert a parm template inside this group after an existing one. The
            new parm template will be in the same folder as the existing one.

            See replace for a description of the name/ parm template/indices
            parameter.

            Use appendToFolder to add an entry to a empty folder. Use append to
            add an entry to an empty parm template group.


        """
    def append(self, parm_template: ParmTemplate) -> None:
        """

        append(self, parm_template)

            Add a parm template after all existing parm templates, outside of
            any folder.

            See also appendToFolder.


        """
    def appendToFolder(self, label_or_labels_or_parm_template_or_indices: str|Sequence[str]|ParmTemplate|Sequence[int], parm_template: ParmTemplate) -> None:
        '''

        appendToFolder(self, label_or_labels_or_parm_template_or_indices,
        parm_template)

            Add a parm template to the bottom of an existing folder.

            Note that you cannot add to a folder by simply looking up the folder
            parm template and calling hou.FolderParmTemplate.addParmTemplate on
            it, because asking for a folder will return a deep copy. The parm
            templates inside the copied folder will be separate from those
            inside this group, and modifying the folder will not affect the
            group. Consider the following example:

          > >>> folder = group.findFolder(\\"Transform\\")
          > # \\"folder\\" now has its own copy of the parms inside it.
          > >>> folder.addParmTemplate(new_parm_template)
          > # \\"folder\\"\'s parm templates are updated, but the group\'s parm templates are
          > # unchanged.
          > 
          > >>> group.appendToFolder(folder, new_parm_template)
          > # The group is modified.  \\"folder\\"\'s contents are unchanged.

        '''
    def addParmTemplate(self, parm_template: ParmTemplate) -> None:
        """

        addParmTemplate(self, parm_template)

            This method is simply an alias for the append method.

            It makes it easier to treat parm template groups and
            hou.FolderParmTemplate objects uniformly, since
            hou.FolderParmTemplate has an addParmTemplate method.


        """
    def remove(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int]) -> None:
        """

        remove(self, name_or_parm_template_or_indices)

            Remove a parm template from the group. Note that if you remove a
            folder, all of the parm templates in the folder are also removed.

            See replace for a description of the name/parm template/indices
            parameter.

            Raises hou.OperationFailed if the parm template could not be found.


        """
    def hide(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int], on: bool) -> None:
        """

        hide(self, name_or_parm_template_or_indices, on)

            Hide a parameter by making it invisible. The parameter still exists
            in the group, but parameter dialogs will not display it.

            See replace for a description of the name/parm template/indices
            parameter.

            This method could be implemented as follows:

          > def hide(self, name_or_parm_template_or_indices, on):
          >     parm_template = self.find(name_or_parm_template_or_indices)
          >     parm_template.hide(on)
          >     self.replace(name_or_parm_template_or_indices, parm_template)

            See also hideFolder and hou.ParmTemplate.hide.


        """
    def hideFolder(self, label_or_labels: str|Sequence[str], on: bool) -> None:
        '''

        hideFolder(self, label_or_labels, on)

            Hide a folder and all the parameters in it.

            You may pass in either a string containing a single folder name or a
            sequence of strings to identify a nested folder. For example, the
            sequence (\\"Render\\", \\"Dicing\\") identifies the Dicing folder inside
            the Render folder. The folder is hidden if on is True and unhidden
            if it is False.

            The following example hides the Transform parameter in a geometry
            object:

          > >>> group = geo_node.parmTemplateGroup()
          > >>> group.hideFolder(\\"Transform\\", True)
          > >>> geo_node.setParmTemplateGroup(group)

            The following example hides the Dicing folder inside the Render
            folder on a geometry object:

          > >>> group = geo_node.parmTemplateGroup()
          > >>> group.hideFolder((\\"Render\\", \\"Dicing\\"), True)
          > >>> geo_node.setParmTemplateGroup(group)

            This method could be implemented as follows:

          > def hideFolder(self, label_or_labels, on):
          >     self.hide(self.findFolder(label_or_labels), on)

            See also hide.


        '''
    def isHidden(self, name_or_parm_template_or_indices: str|ParmTemplate|Sequence[int]) -> bool:
        """

        isHidden(self, name_or_parm_template_or_indices) -> bool

            Return whether the given parameter is itself hidden or lies inside a
            hidden folder.

            See replace for a description of the name/parm template/indices
            parameter.

            Note that if the parameter is inside a hidden folder but the
            parameter is not marked as hidden, calling hou.ParmTemplate.isHidden
            on the parm template will return False, while this method will
            return True.


        """
    def isFolderHidden(self, label_or_labels: str|Sequence[str]) -> bool:
        '''

        isFolderHidden(self, label_or_labels) -> bool

            Return whether a folder or one of its containing folders is hidden.

            Note that if a folder is inside a hidden folder but this folder is
            not marked as hidden, calling hou.ParmTemplate.isHidden on the
            folder parm template will return False, while this method will
            return True.

            You may pass in either a string containing a single folder name or a
            sequence of strings to identify a nested folder. For example, the
            sequence (\\"Render\\", \\"Dicing\\") identifies the Dicing folder inside
            the Render folder. The folder is hidden if on is True and unhidden
            if it is False.


        '''
    def clear(self) -> None:
        """

        clear(self)

            Remove all parm templates from this group.


        """
    def asDialogScript(self, rename_conflicting_parms: bool = ..., full_info: bool = ..., script_name: str|None = ..., script_label: str|None = ..., script_tags: Mapping[str, str] = ...) -> str:
        """

        asDialogScript(rename_conflicting_parms=False, full_info=False,
        script_name=None, script_label=None, script_tags={}) -> str

            Return a string containing the dialog script file contents
            corresponding to this parm template group.

            Houdini saves parameter definitions in this format when saving
            digital asset definitions (in the DialogScript section of the
            digital asset) and when saving parameter layouts of nodes.

            The default behavior for reserved parameters is to output baseparm
            tokens for reserved parameters so that it is resistant to changes in
            their definition. To change this, use full_info=True.

            The script_name, script_label and script_tags parameters specify
            additional data that is saved to the dialog script header as the
            name, label, and parmtag options respectively. The script_tags
            dictionary should map strings to strings. Each entry is saved to the
            dialog script as a separate parmtag. The interpretation of these
            additional header elements depends on where this dialog script is
            being used. When used to provide the parameter definitions for an
            HDA, these elements are ignored. But when using the dialog script as
            a source of render properties, these additional elements will be
            used to filter and categorize the properties in the Edit Parameter
            Interface window.


        """
    def setToDialogScript(self, dialog_script: str) -> None:
        """

        setToDialogScript(dialog_script)

            Set the contents of this group to match the parameters defined by
            the given dialog script string.

            Raises hou.OperationFailed if there is an error in the dialog script
            contents.


        """
    def asCode(self, function_name: Optional[str] = None, variable_name: Optional[str] = None) -> str:
        """

        asCode(self, function_name=None, variable_name=None) -> str

            Return Python code that will recreate this group.


            function_name
                If not None, the returned code will create a Python function.

            variable_name
                The name of the variable that will be assigned the newly-created
                parm template group.


        """
    def sourceNode(self) -> Optional[Node]:
        """

        sourceNode(self) -> hou.OpNode or None

            Return the node that the parameter template group was generated
            from. If the group was not generated from a node, then return None.

            Raises hou.ObjectWasDeleted if the source node has been destroyed.


        """
    def sourceNodeType(self) -> Optional[NodeType]:
        """

        sourceNodeType(self) -> hou.NodeType or None

            Return the node type that the parameter template group was generated
            from. If the group was not generated from a node type, then return
            None.

            Raises hou.ObjectWasDeleted if the source node type has been
            destroyed.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the internal name recorded to this object, either through a
            call to setName, or loaded from a dialog script using the
            setToDialogScript method.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Set the internal name for this parameter group. This information is
            written to the output of asDialogScript if the script_name parameter
            is left at the default value of None.


        """
    def label(self) -> str:
        """

        label(self) -> str

            Return the label recorded to this object, either through a call to
            setLabel, or loaded from a dialog script using the setToDialogScript
            method.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self, label)

            Set the label for this parameter group. This information is written
            to the output of asDialogScript if the script_label parameter is
            left at the default value of None.


        """
    __swig_destroy__: Incomplete

class Pane:
    """

    hou.Pane

    A rectangular area of the desktop that contains one or more pane tabs.

    Desktops (and floating panels) are composed of one or more panes.
    Initially a desktop contains one pane, and more panes are added to it by
    splitting existing panes in two, either horizontally or vertically.

    See hou.Desktop for more information about panes and pane tabs. See
    hou.FloatingPanel for more information about floating panels.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def desktop(self) -> Optional[Desktop]:
        """

        desktop(self) -> hou.Desktop or None

            Return the desktop in which this pane exists, or None if it is in a
            floating panel that's not attached to the desktop.


        """
    def id(self) -> int: ...
    def isMaximized(self) -> bool:
        """

        isMaximized(self) -> bool

            Return True if this pane is maximized.


        """
    def floatingPanel(self) -> Optional[FloatingPanel]: ...
    def setIsMaximized(self, on: bool) -> None:
        """

        setIsMaximized(self, on)

            Set the maximized state of this pane.


        """
    def tabs(self) -> Tuple[PaneTab, ...]:
        """

        tabs(self) -> tuple of hou.PaneTab

            Return the pane tabs in this pane.


        """
    def createTab(self, type: EnumValue, python_panel_interface: Optional[str] = None) -> PaneTab:
        """

        createTab(self, type, python_panel_interface=None) -> hou.PaneTab

            Create a new pane tab with the desired type and return it. The new
            pane tab will be current (i.e. it will be the pane tab that's open).


            type
                A hou.paneTabType enumerated variable.

            python_panel_interface
                The name of the Python Panel interface to be displayed in the
                new pane tab. Specifying the interface name additionally hides
                the Python Panel toolbar. If python_panel_interface is None or
                points to an interface that does not exist then the default
                Python Panel pane tab is displayed along with the toolbar.

                This argument is ignored if pane_tab_type is not set to
                hou.paneTabType.PythonPanel.


        """
    def currentTab(self) -> PaneTab:
        """

        currentTab(self) -> hou.PaneTab

            Return the currently focused pane tab.

            See also hou.PaneTab.setIsCurrentTab.


        """
    def tabOfType(self, type: EnumValue, index: int = 0) -> Optional[PaneTab]:
        """

        tabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return a pane tab with the desired type, or None if no such
            tab exists in the pane.

            If there are multiple tabs in the pane with the desired type, then
            the first found tab is returned. Use index to return the other tabs.
            For example, use index=0 to return the first found tab, use index=1
            to return the second found tab, etc.

            See also hou.ui.paneTabOfType.


        """
    def splitHorizontally(self) -> Pane:
        """

        splitHorizontally(self) -> hou.Pane

            Split the pane, adding a new pane to the right, and return the new
            pane. The new pane will have a single tab whose type is the same as
            the type of this pane's current tab.

            See also hou.Pane.splitVertically.


        """
    def splitVertically(self) -> Pane:
        """

        splitVertically(self) -> hou.Pane

            Split the pane, adding a new pane to the bottom, and return the new
            pane. The new pane will have a single tab whose type is the same as
            the type of this pane's current tab.

            See also hou.Pane.splitHorizontally.


        """
    def getSplitParent(self) -> Optional[Pane]:
        """

        getSplitParent(self) -> hou.Pane or None

            Return the parent split pane if the Pane is nested under a split.


        """
    def getSplitChild(self, child: int) -> Optional[Pane]:
        """

        getSplitChild(self,index) -> hou.Pane or None

            Return the split child Pane at index if the Pane is a split.


        """
    def splitSwap(self) -> None:
        """

        splitSwap(self)

            Swap the left and right panes of an horizontal split Pane. Swap the
            top and bottom panes of a vertical split Pane.


        """
    def splitRotate(self) -> None:
        """

        splitRotate(self)

            Turn an horizontal split Pane into a vertical split Pane.


        """
    def isSplitMaximized(self) -> bool:
        """

        isSplitMaximized(self) -> bool

            Return True if the Pane is maximized on the split. A split can't be
            minimized and maximized at the same time. In its default state, a
            split is not minimized and not maximized.


        """
    def isSplitMinimized(self) -> bool:
        """

        isSplitMinimized(self) -> bool

            Return True if the Pane is minimized on the split. A split can't be
            minimized and maximized at the same time. In its default state, a
            split is not minimized and not maximized.


        """
    def setIsSplitMaximized(self, on: bool) -> None:
        """

        setIsSplitMaximized(self, on) -> bool

            Set the maximized state of a split.


        """
    def isSplit(self) -> bool:
        """

        isSplit(self) -> bool

            Return True if the pane is a split.


        """
    def setSplitFraction(self, value: float) -> None:
        """

        setSplitFraction(self,fraction)

            Set the split fraction of the parent split.


        """
    def getSplitFraction(self) -> float:
        """

        getSplitFraction(self,fraction) -> double

            Return the split fraction of the parent split.


        """
    def setSplitDirection(self, dir: int) -> None:
        """

        setSplitDirection(self,dir)

            Set the split direction of the parent split.


        """
    def getSplitDirection(self) -> int:
        """

        getSplitDirection(self,dir) -> double

            Return the split direction of the parent split.


        """
    def setShowPaneTabs(self, value: bool) -> None:
        """

        setShowPaneTabs(self,on)

            Show or Hide the pane tabs bar.

            This method is deprecated in favor of showPaneTabs.


        """
    def showPaneTabs(self, value: bool) -> None:
        """

        showPaneTabs(self,on)

            Show or Hide the pane tabs bar.


        """
    def isShowingPaneTabs(self) -> bool:
        """

        isShowingPaneTabs(self) -> bool

            Return True if the Pane is showing pane tabs.


        """
    def showPaneTabsStow(self, value: bool) -> None:
        """

        showPaneTabsStow(self,on)

            Show or Hide the pane tabs stow bar button when pane tabs are
            hidden.


        """
    def isShowingPaneTabsStow(self) -> bool:
        """

        isShowingPaneTabsStow(self) -> bool

            Return True if the Pane is showing the pane tabs stow bar when pane
            tabs are hidden.


        """

class PaneTab:
    """

    hou.PaneTab

    One of the tabs inside a desktop pane.

    Each pane type is of a particular type (e.g. scene viewer, network view,
    parameters, etc.). A pane may contain multiple tabs and displays the
    contents of one tab at a time.

    See hou.Desktop for more information about panes and pane tabs.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def pane(self) -> Optional[Pane]:
        """

        pane(self) -> hou.Pane or None

            Return the pane in the desktop that contains this pane tab. Note
            that pane tabs in regular floating panels are always in a pane,
            since regular floating panels contain one or more panes.

            However, some floating panels have their content stripped down to
            only contain one particular pane tab type, and do not display the
            user interface to add more pane tabs, split the pane, etc. This
            method returns None for these stripped down floating panels.


        """
    def floatingPanel(self) -> Optional[FloatingPanel]:
        """

        floatingPanel(self) -> hou.FloatingPanel or None

            Return the floating panel that contains this pane tab or None if the
            pane tab is not in a floating panel.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of this tab.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Set the name of this pane tab. A pane tab name may contain spaces.

            Note that this name is the internal name of the tab, and is
            different from the label displayed in the interface.


        """
    def isCurrentTab(self) -> bool:
        """

        isCurrentTab(self) -> bool

            Return whether this tab is the selected tab in the containing pane.


        """
    def setIsCurrentTab(self) -> None:
        """

        setIsCurrentTab(self)

            Set this tab as the selected tab in the containing pane.


        """
    def isFloating(self) -> bool:
        """

        isFloating(self) -> bool

            Return whether this pane tab is in a floating panel.

            This method can be approximately implemented as follows:

          > def isFloating(self):
          >     return self.pane() is None or self.pane().floatingPanel() is not None

        """
    def clone(self) -> PaneTab:
        """

        clone(self) -> hou.PaneTab

            Create a floating copy of the pane tab and return the cloned pane
            tab. The new pane tab is in a new floating panel.


        """
    def close(self) -> None:
        """

        close(self)

            Close the pane tab.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.paneTabType enum value

            Return the type of this tab (i.e. whether it is a scene viewer,
            parameter editor, network editor, etc.).


        """
    def setType(self, type: EnumValue) -> PaneTab:
        """

        setType(self, type) -> hou.PaneTab

            Create a new pane tab of the given type, replace this tab with it,
            and return the new pane tab. Use the returned pane tab afterward;
            references to this tab become invalid.


        """
    def linkGroup(self) -> EnumValue:
        """

        linkGroup(self) -> hou.paneLinkType enum value

            Return the link group that this pane tab belongs to.

            See also hou.PaneTab.isPin.


        """
    def setLinkGroup(self, group: EnumValue) -> None:
        """

        setLinkGroup(self, group)

            Set the link group membership of this pane tab.


        """
    def isPin(self) -> bool:
        """

        isPin(self) -> bool

            Return whether this pane tab is pinned. This method is equivalent to
            (self.linkGroup() == hou.paneLinkType.Pinned)

            See also hou.PaneTab.linkGroup.


        """
    def setPin(self, pin: bool) -> None:
        """

        setPin(self, pin)

            If pin is True, set the link group membership to
            hou.paneLinkType.Pinned. Otherwise, set it to
            hou.paneLinkType.FollowSelection. This method can be implemented
            using hou.PaneTab.setLinkGroup as follows:

          > def setPin(self, pin):
          >     if pin:
          >         self.setLinkGroup(hou.paneLinkType.Pinned)
          >     else:
          >         self.setLinkGroup(hou.paneLinkType.FollowSelection)

            See also hou.PaneTab.setLinkGroup.


        """
    def tools(self) -> Tuple[Tool, ...]:
        """

        tools(self) -> tuple of hou.Tool

            Return a tuple of hou.Tool objects that are valid in the current
            pane tab.


        """
    def size(self) -> Tuple[int, ...]:
        """

        contentSize() -> tuple of int

            Return a 2-tuple containing the pane tab's content area width and
            height.

            The width and height do not include the network navigation control
            area (if any), pane tab borders or tab area.


        """
    def contentSize(self) -> Tuple[int, ...]: ...
    def hasNetworkControls(self) -> bool:
        """

        hasNetworkControls(self) -> bool

            Return True if this pane tab type supports network controls.


        """
    def isShowingNetworkControls(self) -> bool:
        """

        isShowingNetworkControls(self) -> bool

            Return whether this pane tab is showing its network control bar.
            Return False if the pane tab doesn't have network controls. See also
            hou.PaneTab.hasNetworkControls.


        """
    def setShowNetworkControls(self, value: bool) -> None:
        """

        setShowNetworkControls(self, pin)

            Show or Hide the network control bar. Has no effect if the pane tab
            doesn't have network controls. See also
            hou.PaneTab.hasNetworkControls.

            This method is deprecated in favor of showNetworkControls.


        """
    def showNetworkControls(self, value: bool) -> None:
        """

        showNetworkControls(self, pin)

            Show or Hide the network control bar. Has no effect if the pane tab
            doesn't have network controls. See also
            hou.PaneTab.hasNetworkControls.


        """
    def displayRadialMenu(self, menu: str|RadialScriptItem) -> None:
        """

        displayRadialMenu(self, menu)

            Launch the specified radial menu in the pane tab.


            menu
                The name of the registered radial menu. Alternatively, a
                temporary radial submenu (or script menu) can be passed. See
                also hou.ui.createRadialItem.


        """

class PathBasedPaneTab(PaneTab):
    """

    hou.PathBasedPaneTab

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def pwd(self) -> Node:
        """

        pwd(self) -> Node


        """
    def setPwd(self, node: Node) -> None:
        """

        setPwd(self, node)


        """
    def cd(self, path: str) -> None:
        """

        cd(self, path)


        """
    def currentNode(self) -> Node:
        """

        currentNode(self) -> Node


        """
    def setCurrentNode(self, node: Node, pick_node: bool = True) -> None:
        """

        setCurrentNode(self, node, pick_node = True)


        """

class DopData:
    """

    hou.DopData

    A piece of data stored inside a DOP network's simulation.

    Each DOP network builds a tree of data, and then Houdini examines and
    updates this tree when it runs the simulation. DOP data elements can be
    DOP objects, geometry, volumes, forces, solvers, etc. The data is
    arranged in a tree structure, where child nodes are called subdata and
    are said to be attached to their parent nodes. Under the root of the
    tree are usually the DOP objects and data describing their
    relationships.

    Note that the same piece of data can appear in the tree in multiple
    locations, with different names. DopData objects thus do not store their
    name, and the name of a piece of data in the tree is instead stored with
    its parent data(s).

    By default, DopData objects store the path within the tree to the data.
    As a consequence, if the time changes and the solvers within the
    simulation change the contents of the tree of data, the Python DopData
    object will update to refer to the simulation's new state. If the data
    path no longer refers to valid data, Houdini raises hou.ObjectWasDeleted
    when you try to access the DopData object from Python.

    If you do not want the DopData to update with changes to the simulation,
    you can call hou.DopData.freeze. freeze returns another DopData object
    that refers the simulation's state at the current time, and will not
    change when the simulation time changes.

    Each piece of data can contain records, and each record stores a list of
    name and value pairs called fields. Each record has a name, but it's
    possible for multiple records with the same name to exist in the same
    piece of data. In this case, the record also has an index, and you can
    think of the records as rows of a spreadsheet.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def freeze(self) -> DopData:
        """

        freeze(self) -> hou.DopData

            Return a frozen version of this DopData. Frozen versions of the data
            will not update when the simulation updates. Instead, they will
            refer to the state of the simulation at the time they were frozen.

            It is ok to call this method on a DopData object that is already
            frozen.


        """
    def isFrozen(self) -> bool:
        """

        isFrozen(self) -> bool

            Return whether or not this data is frozen.

            See hou.DopData.freeze for more information.


        """
    def path(self) -> str:
        """

        path(self) -> str

            Return the path to this object within the tree of DOP data. This
            path includes the DOP object or relationship as the first part of
            the path.

            Note that the same piece of DOP data can exist in multiple places of
            the tree. The path returned is the path stored inside this Python
            DopData object, since the Python object uses the path to look up the
            underlying data each time you call a method on it.

            Note that the path is only available for unfrozen objects. If you
            call this method on a frozen DopData object it raises
            hou.OperationFailed.


        """
    def selectionPath(self) -> str:
        """

        selectionPath(self) -> str

            For DopData objects returned from a hou.SceneViewer.selectDynamics
            function call, this will return the a string that contains both the
            path to the DOP Network that created the data, and the path within
            the DOP data tree which uniquely identifies this DopData. This
            string is specifically intended to be passed in the
            prior_selection_paths argument of the hou.SceneViewer selection
            methods.


        """
    def __hash__(self) -> int: ...
    def dopNetNode(self) -> OpNode:
        """

        dopNetNode(self) -> hou.OpNode

            Return the DOP network node containing this DOP data.


        """
    def simulation(self) -> DopSimulation:
        """

        simulation(self) -> hou.DopSimulation

            Return the DOP simulation containing this DOP data. This method is a
            shortcut for self.dopNetNode().simulation().


        """
    def creator(self) -> OpNode:
        """

        creator(self) -> hou.DopNode

            Return the DOP node that created this DOP data inside the DOP
            network.


        """
    def id(self) -> str:
        '''

        id(self) -> str

            Return the globally unique identifier (GUID) for this DOP data. This
            method is a shortcut for self.record(\\"Basic\\").field(\\"uniqueid\\").

            If you want an object\'s index, hou.DopObject.objid.

          > >>> obj = hou.node(\\"/obj/AutoDopNetwork\\").simulation().objects()[0]
          > >>> obj.id()
          > \'0xD011E41C-0x000034AE-0x494C12E4-0x000018B9\'
          > >>> obj.objid()
          > 0

        '''
    def dataType(self) -> str:
        '''

        dataType(self) -> str

            Return a string describing the type of data this object contains.

          > >>> obj = hou.node(\\"/obj/AutoDopNetwork\\").simulation().objects()[0]
          > >>> obj.dataType()
          > \'SIM_Object\'

            See also hou.DopData.dataTypeObject.


        '''
    def recordTypes(self) -> Tuple[str, ...]:
        """

        recordTypes(self) -> tuple of str

            Return a tuple of strings containing the record types stored inside
            this DOP data. Each DOP data contains records named Basic and
            Options, and some types of DOP data contain additional records.


        """
    def record(self, record_type: str, record_index: int = 0) -> Optional[DopRecord]:
        """

        record(self, record_type, record_index=0) -> hou.DopRecord

            Given a record type name return that record, or None if no record
            exists with that name. If this DOP data contains multiple records
            with this record type name you can think of each record as a row in
            a spreadsheet, and record_index determines which one is returned.
            Use len(self.records(record_type)) to determine how many records of
            this type are in this DOP data.

            Use hou.DopData.recordTypes to get a tuple of record types in a DOP
            data. See also hou.DopData.records for an example, and see
            hou.DopData.options for a way to easily access the Options record.


        """
    def records(self, record_type: str) -> Iterator[DopRecord]:
        '''

        records(self, record_type) -> tuple of hou.DopRecord

            Return a tuple of all the records of this record type. See also
            hou.DopData.record.

            This example lists the input affectors for a rigid body box that
            collides with a ground plane:

          > >>> obj = hou.node(\\"/obj/AutoDopNetwork\\").simulation().objects()[-1]
          > >>> obj.records(\\"RelInAffectors\\")
          > (<hou.DopRecord of type RelInAffectors index 0>, <hou.DopRecord of type RelInAffectors index 1>)
          > >>> [record.field(\\"relname\\") for record in obj.records(\\"RelInAffectors\\")]
          > [\'merge1\', \'staticsolver1_staticsolver1\']
          > >>> obj.record(\\"RelInAffectors\\", 1).field(\\"relname\\")
          > \'staticsolver1_staticsolver1\'

        '''
    def options(self) -> DopRecord:
        '''

        options(self) -> hou.DopRecord

            Return the Options record. This method is a shortcut for
            self.record(\\"Options\\").


        '''
    def subData(self) -> dict[str, DopData]:
        '''

        subData(self) -> dict of str to hou.DopData

            Return a dictionary mapping names to DOP data instances for the
            subdata attached to this data.

          > # The following code assumes you have created a box from the shelf and used
          > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          > >>> obj = hou.node(\\"/obj/AutoDopNetwork\\").simulation().objects()[0]
          > >>> obj
          > <hou.DopObject box_object1 id 0>
          > >>> obj.recordTypes()
          > (\'Basic\', \'Options\', \'RelInGroup\', \'RelInAffectors\')
          > >>> record = obj.record(\\"Options\\")
          > >>> record.fieldNames()
          > (\'name\', \'groups\', \'affectors\', \'affectorids\', \'objid\')
          > >>> record.field(\\"name\\")
          > \'box_object1\'
          > 
          > >>> obj.subData().keys()
          > [\'PhysicalParms\', \'ODE_Body\', \'Solver\', \'Geometry\', \'SolverParms\', \'ODE_Geometry\', \'Forces\', \'Position\', \'Colliders\']
          > >>> obj.findSubData(\\"Forces/Gravity_gravity1\\")
          > <hou.DopData of type SIM_ForceGravity>
          > >>> obj.findSubData(\\"Forces/Gravity_gravity1\\").options().field(\\"force\\")
          > <hou.Vector3 [0, -9.80665, 0]>

        '''
    def findSubData(self, data_spec: str) -> Optional[DopData]:
        '''

        findSubData(self, data_spec) -> hou.DopData or None

            Return the DOP data with the given name that is attached to this DOP
            data, or None if no such data exists. Note that the name may also be
            a slash-separated path to nested subdata.

            See hou.DopData.subData for an example.

            This method can be approximately implemented as follows:

          > def findSubData(self, data_spec):
          >     data = self
          >     for name in data_spec.split(\\"/\\"):
          >         if name not in data.subData():
          >             return None
          >         data = data.subData()[name]
          >     return data

        '''
    def findAllSubData(self, data_spec: str, recurse: bool = False) -> dict[str, DopData]:
        '''

        findAllSubData(self, data_spec, recurse=False) -> dict of str to
        hou.DopData

            Given a pattern, return a dictionary mapping subdata paths to DOP
            data instances for all the subdatas whose name matches the pattern.
            If recurse is True, all grandchildren subdata will be added to the
            result.

          > # The following code assumes you have created a box from the shelf and used
          > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          > >>> obj = hou.node(\\"/obj/AutoDopNetwork\\").simulation().objects()[0]
          > >>> obj.findAllSubData(\\"S*\\").keys()
          > [\'SolverParms\', \'Solver\']
          > >>> obj.findAllSubData(\\"S*\\", recurse=True).keys()
          > [\'SolverParms\', \'Solver/Random\', \'SolverParms/ActiveValue\', \'Solver\']
          > >>> obj.findAllSubData(\\"S*/*\\", recurse=True).keys()
          > [\'SolverParms/ActiveValue\', \'Solver/Random\']

        '''
    def createSubData(self, data_name: str, data_type: str = ..., avoid_name_collisions: bool = ...) -> DopData:
        '''

        createSubData(self, data_name, data_type=\\"SIM_EmptyData\\",
        avoid_name_collisions=False) -> hou.DopData

            Create subdata under this data with the specified name and type. You
            would call this method from a script solver DOP.


            data_name
                The name of the new data. Note that this name may contain
                slashes to create subdata on existing data.

            data_type
                Either the name of the data type to create or a hou.DopDataType
                instance. If you simply want something containing an empty
                options record, use SIM_EmptyData.

            avoid_name_collisions
                If True and data with the specified name exists, Houdini will
                create a unique name that does not conflict with any existing
                data.

            Raises hou.OperationFailed if data with this name already exists. If
            you want to replace existing data it is up to you to first call
            hou.DopData.removeData.

            Raises hou.PermissionError if called from outside a script solver
            DOP.

            Use hou.DopData.attachSubData to create a reference to existing
            data. See hou.DopData.copyContentsFrom for an example of how to
            create a copy of existing data.


        '''
    def attachSubData(self, hom_new_subdata: DopData, new_data_name: str, avoid_name_collisions: bool = False) -> None:
        """

        attachSubData(self, data, new_data_name, avoid_name_collisions=False)

            Make existing data become subdata of this data. Houdini does not
            create a duplicate of the data. Instead, the data's parent(s) and
            this data will both refer to the same instance of subdata. You would
            call this method from a script solver DOP.


            data
                The DopData that will become subdata of this data.

            new_data_name
                The name of the new subdata.

            avoid_name_collisions
                If True and data with the specified name exists, Houdini will
                create a unique name that does not conflict with any existing
                data.

            Raises hou.OperationFailed if data with this name already exists. If
            you want to replace existing data it is up to you to first call
            hou.DopData.removeData.

            Raises hou.PermissionError if called from outside a script solver
            DOP.

            See hou.DopData.copyContentsFrom for an example of how to create a
            copy of existing data.


        """
    def removeSubData(self, data_spec: str) -> None:
        """

        removeSubData(self, data_spec)

            Remove subdata with the given name. Raises hou.PermissionError if
            called from outside a script solver DOP.

            Raises hou.OperationFailed if data with that name already exists.


        """
    def copyContentsFrom(self, hom_data: DopData) -> None:
        """

        copyContentsFrom(self, data)

            Copy the contents of the given DopData into this one, adapting the
            data if it is of a different type. You would call this method from a
            script solver DOP.

            Raises hou.PermissionError if called from outside a script solver
            DOP.

            Use this method along with hou.DopData.createSubData to copy
            existing subdata:

          > def copySubData(new_parent_data, data_to_copy, new_data_name, avoid_name_collisions=False):
          >     '''Create a copy of data and attach it to other data.'''
          >     new_data = new_parent_data.createSubData(new_data_name, data_to_copy.dataType(), avoid_name_collisions)
          >     new_data.copyContentsFrom(data_to_copy)
          >     return new_data

        """
    def fieldGeometry(self, data_name: str) -> Optional[Geometry]: ...
    def geometry(self, data_name: Optional[str] = None) -> Optional[Geometry]: ...
    def editableGeometry(self, data_name: Optional[str] = None) -> Optional[EditableDopGeometryGuard]: ...

class ShelfElement:
    """

    hou.ShelfElement

    Superclass of shelf tools, shelf tabs, and shelf sets.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def filePath(self) -> str:
        """

        filePath(self) -> str

            Returns the file that contains the definition of this object.


        """
    def setFilePath(self, file_path: str|None) -> None:
        """

        setFilePath(self, file_path)

            Sets the path string for where this object's definition is stored.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the internal name of this object.

            Multiple objects may have the same name (for example, two different
            assets might both provide a hammer tool), but only one will be
            active at a time in a Houdini session.


        """
    def setName(self, name: str) -> None:
        '''

        setName(self, name)

            Sets this object\'s internal name. This is how you refer to the
            object in scripts.

            The name has similar rules to naming Houdini nodes: it must not
            start with a number, and can only contain letters, numbers, an
            underscores.

            For example, if a Tool objects name is foo, you can get a reference
            to it using:

          > footool = shelves.tool(\\"foo\\")

        '''
    def label(self) -> str:
        """

        label(self) -> str

            Returns the object's human-readable label.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self, label)

            Sets the object's human-readable label. This is what's displayed in
            the UI.


        """
    def fileLocation(self) -> str:
        """

        fileLocation(self) -> str

            Returns the file location description in a human readable format.
            For example, it is a file path for disk files, and information about
            an HDA if the element is stored in an HDA tool section.


        """
    def isReadOnly(self) -> bool:
        """

        isReadOnly(self) -> bool

            Returns True if the element is read-only (can't be edited).


        """
    def setReadOnly(self, on: bool) -> None:
        '''

        setReadOnly(self, on)

          > # Get a reference to a tool
          > t = hou.shelves.tool(\\"geometry_sphere\\")
          > # Prevent the tool from being modified
          > t.setReadOnly(True)
          > # Allow the tool to be modified
          > t.setReadOnly(False)

        '''

class _logging_Sink:
    """

    hou.logging.Sink

    Represents a logging destination.

    This is an abstract base class for all logging sink classes. It provides
    the common methods for connecting and disconnecting sources to the sink.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def connectedSources(self) -> Tuple[str, ...]:
        """

        connectedSources() -> tuple of str

            Returns the names of sources connected to this sink.


        """
    def connect(self, source_name: str) -> None:
        """

        connect(source_name)

            Connect a source to this sink object. The source_name should be one
            of the values return by a call to hou.logging.sources.


        """
    def disconnect(self, source_name: str) -> None:
        """

        disconnect(source_name)

            Disconnect a source from this sink object. The source_name should be
            one of the values returned by the connectedSources method.


        """
    def setFilterCallback(self, callback: Callable[[_logging_LogEntry], None]) -> None:
        """

        setFilterCallback(callback)

            Associates a callable object with this log sink which is called
            every time a log entry is generated by a source connected to this
            sink. The callback should take one argument, which is a
            hou.logging.LogEntry object. If this callback returns False, the log
            entry will not be stored or otherwise processed by this sink object.


        """

class Agent(PackedPrim):
    """

    hou.Agent

    An agent primitive.

    See Crowd Agents for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def definition(self) -> AgentDefinition:
        """

        definition(self) -> hou.AgentDefinition

            Returns the shared agent definition.


        """
    def setDefinition(self, definition: AgentDefinition) -> None:
        """

        setDefinition(definition)

            Changes the agent's definition. If the new definition's rig has a
            different number of transforms, the agent's current transforms will
            be reset. The agent's current clips will be reset if the new
            definition does not contain clips with the same names.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            definition
                A hou.AgentDefinition.


        """
    def currentLayer(self) -> AgentLayer:
        """

        currentLayer(self) -> hou.AgentLayer

            This method is deprecated in favor of hou.Agent.currentLayers.

            Returns the current display layer of the agent. If there are
            multiple current display layers, only the first layer will be
            returned.


        """
    def setCurrentLayer(self, layer: AgentLayer) -> None:
        """

        setCurrentLayer(layer)

            This method is deprecated in favor of hou.Agent.setCurrentLayers.

            Sets the agent's current display layer.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layer
                A hou.AgentLayer.


        """
    def collisionLayer(self) -> AgentLayer:
        """

        collisionLayer(self) -> hou.AgentLayer

            This method is deprecated in favor of hou.Agent.collisionLayers.

            Returns the current collision layer of the agent. If there are
            multiple current collision layers, only the first layer will be
            returned.


        """
    def setCollisionLayer(self, layer: AgentLayer) -> None:
        """

        setCollisionLayer(layer)

            This method is deprecated in favor of hou.Agent.setCollisionLayers.

            Sets the agent's current collision layer.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layer
                A hou.AgentLayer.


        """
    def currentLayers(self) -> Tuple[AgentLayer, ...]:
        """

        currentLayers(self) -> tuple of hou.AgentLayer

            Returns the agent's current display layers.


        """
    def setCurrentLayers(self, layers: Sequence[AgentLayer]) -> None:
        """

        setCurrentLayers(layers)

            Sets the agent's current display layers.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layers
                A hou.AgentLayer sequence.


        """
    def collisionLayers(self) -> Tuple[AgentLayer, ...]:
        """

        collisionLayers(self) -> tuple of hou.AgentLayer

            Returns the agent's current collision layers.


        """
    def setCollisionLayers(self, layers: Sequence[AgentLayer]) -> None:
        """

        setCollisionLayers(layers)

            Sets the agent's current collision layers.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            layers
                A hou.AgentLayer sequence.


        """
    def clips(self) -> Tuple[AgentClip, ...]:
        """

        clips(self) -> tuple of hou.AgentClip

            Returns the agent's current animation clips.


        """
    def setClips(self, clips: Sequence[AgentClip]) -> None:
        """

        setClips(clips)

            Sets the agent's current animation clips.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            clips
                A hou.AgentClip sequence.


        """
    def clipTimes(self) -> Tuple[float, ...]:
        """

        clipWeights(self) -> tuple of float

            Returns the blend weights for the agent's animation clips.


        """
    def setClipTimes(self, times: Sequence[float]) -> None:
        """

        setClipTimes(times)

            Sets the current times for the agent's animation clips.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            times
                A float sequence.


        """
    def clipWeights(self) -> Tuple[float, ...]: ...
    def setClipWeights(self, weights: Sequence[float]) -> None:
        """

        setClipWeights(weights)

            Sets the blend weights for the agent's animation clips.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            weights
                A float sequence.


        """
    def localTransform(self, i: int) -> Matrix4:
        """

        localTransform(self, transform) -> hou.Matrix4

            Returns the current local space transform of an agent primitive's
            bone.


            transform
                Index of a transform in the agent's rig.


        """
    def setLocalTransform(self, xform: Matrix4, i: int) -> None:
        """

        setLocalTransform(xform, index)

            Sets the current local space transform of an agent primitive's bone.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            xform
                A hou.Matrix4.

            index
                Index of a transform in the agent's rig.


        """
    def worldTransform(self, i: int) -> Matrix4:
        """

        worldTransform(self, transform) -> hou.Matrix4

            Returns the current world space transform of an agent primitive's
            bone.


            transform
                Index of a transform in the agent's rig.


        """
    def setWorldTransform(self, xform: Matrix4, i: int) -> None:
        """

        setWorldTransform(xform, index)

            Sets the current world space transform of an agent primitive's bone.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


            xform
                A hou.Matrix4.

            index
                Index of a transform in the agent's rig.


        """
    def channelValue(self, i: int) -> float:
        """

        channelValue(self, channel_index) -> float

            Returns the current value of an agent primitive's channel.


            channel_index
                Index of a channel in the agent's rig.


        """
    def setChannelValue(self, value: float, i: int) -> None:
        """

        setChannelValue(self, value, channel_index)

            Set the current value of an agent primitive's channel.


            value
                A float value for the channel.

            channel_index
                Index of a channel in the agent's rig.


        """

class AgentClip:
    """

    hou.AgentClip

    An agent's animation clip.

    See Crowd Animation Clips for more information.


    """
    thisown: Incomplete
    def __init__(self, name: str, stage: pxr.Usd.Stage, prim_path: str, rig: AgentRig) -> None:
        """

        __init__(name, stage, prim_path, rig)

            Creates a new agent clip from a USD primitive. Raises
            hou.OperationFailed if the clip could not be loaded.


            name
                A name for the new clip, such as walk.

            stage
                The USD stage to load the clip from. For example, this could be
                the output stage from a LOP node.

            prim_path
                A path to a Skeleton or SkelRoot primitive in the stage to load
                the clip from.

            rig
                The hou.AgentRig that the clip will be associated with. The rig
                is used, for example, when converting transforms from local
                space to world space.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def freeze(self) -> AgentClip:
        """

        freeze(self) -> hou.AgentClip

            Creates a modifiable copy of the clip. The copy will not be marked
            as an external reference.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of the clip.


        """
    def fileName(self, expanded: bool = False) -> str:
        """

        fileName(self, expanded = False) -> str

            If the clip is an external reference, returns the path to the file
            on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
    def isLoaded(self) -> bool:
        """

        isLoaded(self) -> bool

            If the clip is an external reference, returns whether the clip's
            data has been loaded from disk.


        """
    def loadFromFile(self) -> None:
        """

        loadFromFile(self)

            Explicitly loads the clip's data from disk if it is an external
            reference that is delay loaded. Raises hou.OperationFailed if the
            file does not exist or otherwise cannot be loaded.

            Calling any methods that require access to the clip's data will also
            cause the clip to be loaded, but this method can be used to report
            errors immediately.


        """
    def length(self) -> float:
        """

        length(self) -> float

            Returns the length (in seconds) of the clip.


        """
    def startTime(self) -> float:
        """

        startTime(self) -> float

            Returns the start time of the clip (in seconds).


        """
    def sampleCount(self) -> int:
        """

        sampleCount(self) -> int

            Returns the number of samples in the clip.


        """
    def sampleRate(self) -> float:
        """

        sampleRate(self) -> float

            Returns the sample rate of the clip.


        """
    def addChannel(self, name: str, samples: Sequence[float]) -> None:
        """

        addChannel(self, name, samples)

            Creates an additional channel in the clip. If a channel already
            exists with the same name, the previous samples will be overwritten.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            name
                The name of the channel.

            `samples
                A float sequence containing the channel's data. Raises
                hou.InvalidSize if the length does not match
                hou.AgentClip.sampleCount.


        """
    def sampleLocal(self, time: float, transform: int) -> Matrix4:
        """

        sampleLocal(self, time, transform) -> hou.Matrix4


            time
                The time (in seconds) to evaluate the clip at.

            transform
                Index of a transform in the agent's rig.

            Evaluates the clip at the given time and returns the local
            transform.


        """
    def sampleWorld(self, time: float, transform: int) -> Matrix4:
        """

        sampleWorld(self, time, transform) -> hou.Matrix4


            time
                The time (in seconds) to evaluate the clip at.

            transform
                Index of a transform in the agent's rig.

            Evaluates the clip at the given time and returns the world
            transform.


        """
    def localTransforms(self, sample: int) -> Tuple[Matrix4, ...]:
        """

        localTransforms(self, sample) -> tuple of hou.Matrix4

            Returns the local space transforms for the specified sample. The
            number of entries matches hou.AgentRig.transformCount.


            sample
                Index of a sample in the clip.


        """
    def worldTransforms(self, sample: int) -> Tuple[Matrix4, ...]:
        """

        worldTransforms(self, sample) -> tuple of hou.Matrix4

            Returns the world space transforms for the specified sample. The
            number of entries matches hou.AgentRig.transformCount.


            sample
                Index of a sample in the clip.


        """
    def allLocalTransformValues(self) -> Tuple[float, ...]:
        """

        allLocalTransformValues(self) -> tuple of float

            Returns a flat tuple of floats containing the local transforms for
            all samples. This data layout can be convenient for manipulating the
            transforms with other Python libraries. The number of entries is 16
            * rig.transformCount() * clip.sampleCount().


        """
    def setAllLocalTransformValues(self, values: Sequence[float]) -> None:
        """

        setAllLocalTransformValues(self, values)

            Edits the local transforms for all samples in the clip from a flat
            sequence of floats.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            values
                A flat tuple of floats containing the local transforms for each
                sample. The length and data layout is expected to match
                hou.AgentClip.allLocalTransformValues. Raises hou.InvalidSize if
                the length is invalid.


        """
    def setLocalTransforms(self, sample: int, xforms: typing.Iterable[Matrix4]) -> None:
        """

        setLocalTransforms(self, sample, xforms)

            Edits the local transforms for a sample in the clip.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            sample
                Index of a sample in the clip.

            xforms
                A sequence of hou.Matrix4, with a local space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
    def sample(self, time: float, channel: str) -> float:
        """

        sample(self, time, channel_name) -> float


            time
                The time (in seconds) to evaluate the clip at.

            channel_name
                Name of a channel in the clip. See hou.AgentClip.channelNames.

            Evaluates the clip at the given time and returns the value of the
            specified channel. For sampling the clip's transforms, use
            hou.AgentClip.sampleLocal or hou.AgentClip.sampleWorld.


        """
    def channelNames(self) -> Tuple[str, ...]:
        """

        channelNames(self) -> tuple of str

            Returns the names of the additional (non-transform) channels in the
            clip. These channels can be sampled with hou.AgentClip.sample.


        """
    def data(self, binary: bool, worldspace: bool = False) -> bytes:
        """

        data(self, binary, worldspace = False) -> str for Python 2, bytes for
        Python 3

            Returns the clip data in ASCII or binary.

            The returned clip data is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            binary
                Specifies whether the clip data should be saved in ASCII (.clip)
                or binary (.bclip) format.

            worldspace
                Specifies whether the transform channels should be saved in
                local or world space.


        """
    def extractLocomotion(self, cog_transform: int, cog_lookat_transform: int = -1, convert_inplace: bool = True, project_on_dominant_axis: bool = False) -> None:
        """

        extractLocomotion(self, cog_transform, cog_lookat_transform=-1,
        convert_inplace=True, project_on_dominant_axis=False)

            Converts the animation to in-place and records the locomotion
            transform in the __locomotion__:[srt][xyz] channels.

            Raises hou.GeometryPermissionError if the clip is not modifiable.


            cog_transform
                Index of a transform in the agent's rig that controls the
                locomotion of the character (i.e. has the translation that moves
                it forward in space).

            cog_lookat_transform
                Optional index of a transform in the agent's rig, which is used
                to extract an overall rotation using the vector from the
                cog_transform to this transform.

            convert_inplace
                Specifies whether to convert the animation to an in-place clip
                in addition to recording the locomotion transform.

            project_on_dominant_axis
                Projects the locomotion translation along the dominant axis of
                motion in the XZ plane. If the clip will be used as an in-place
                clip in the crowd solver, this can help to maintain hip swaying
                in the motion.


        """

class AgentDefinition:
    """

    hou.AgentDefinition

    The shared data for an agent primitive.

    An agent definition includes a rig, shape library, layers, and clips,
    and can be shared between agent primitives. See Agent Primitives for
    more information.

    Since an agent definition is shared between copies of an agent primitive
    (such as agents in an upstream SOP's geometry), the definition returned
    by hou.Agent.definition is read-only. The hou.AgentDefinition.freeze
    method can be used to create a modifiable copy of an agent definition.

    RELATED

      * hou.crowds.findAgentDefinitions


    """
    thisown: Incomplete
    def __init__(self, rig: AgentRig, shapelib: AgentShapeLibrary) -> None:
        """

        __init__(rig, shapelib)

            Creates a new (and modifiable) agent definition.


            rig
                The hou.AgentRig that the definition should reference.

            shapelib
                The hou.AgentShapeLibrary that the definition should reference.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def freeze(self, new_shapelib: Optional[AgentShapeLibrary] = None, new_rig: Optional[AgentRig] = None) -> AgentDefinition:
        """

        freeze(self, new_shapelib = None, new_rig = None) -> hou.AgentDefinition

            Creates a modifiable copy of the agent definition. Use
            hou.Agent.setDefinition to change one or more agents to use the new
            agent definition.


            new_shapelib
                If specified, the copied agent definition and its layers will
                reference the new shape library.

            new_rig
                If specified, the copied agent definition (and its clips,
                layers, and transform groups) will reference the new rig.


        """
    def rig(self) -> AgentRig:
        """

        rig(self) -> hou.AgentRig

            Returns the agent definition's rig.


        """
    def shapeLibrary(self) -> AgentShapeLibrary:
        """

        shapeLibrary(self) -> hou.AgentShapeLibrary

            Returns the agent definition's shape library.


        """
    def layers(self) -> Iterator[AgentLayer]:
        """

        layers(self) -> tuple of hou.AgentLayer

            Returns a list of the layers in the agent definition.


        """
    def findLayer(self, name: str) -> Optional[AgentLayer]:
        """

        findLayer(self, name) -> hou.AgentLayer

            Finds the layer with the specified name, or None if no such layer
            exists.


        """
    def clips(self) -> Iterator[AgentClip]:
        """

        clips(self) -> tuple of hou.AgentClip

            Returns a list of the clips in the agent definition.


        """
    def findClip(self, name: str) -> Optional[AgentClip]:
        """

        findClip(self, name) -> hou.AgentClip

            Finds the clip with the specified name, or None if no such clip
            exists.


        """
    def transformGroups(self) -> Iterator[AgentTransformGroup]:
        """

        transformGroups(self) -> tuple of hou.AgentTransformGroup

            Returns a list of the transform groups in the agent definition.


        """
    def findTransformGroup(self, name: str) -> Optional[AgentTransformGroup]:
        """

        findTransformGroup(self, name) -> hou.AgentTransformGroup

            Finds the transform group with the specified name, or None if no
            such group exists.


        """
    def addClip(self, clip: AgentClip) -> None:
        """

        addClip(self, clip)

            Adds a clip to the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.

            Raises hou.OperationFailed if the clip is associated with a
            different rig.


            clip
                A hou.AgentClip.


        """
    def removeClip(self, name: str) -> None:
        """

        removeClip(self, name)

            Removes a clip from the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.


            name
                The name of the clip to remove.


        """
    def addLayer(self, layer: AgentLayer) -> None:
        """

        addLayer(self, layer)

            Adds a layer to the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.

            Raises hou.OperationFailed if the layer is associated with a
            different rig or shape library.


            layer
                A hou.AgentLayer.


        """
    def removeLayer(self, name: str) -> None:
        """

        removeLayer(self, name)

            Removes a layer from the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.


            name
                The name of the layer to remove.


        """
    def addTransformGroup(self, group: AgentTransformGroup) -> None:
        """

        addTransformGroup(self, group)

            Adds a transform group to the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.

            Raises hou.OperationFailed if the group is associated with a
            different rig.


            group
                A hou.AgentTransformGroup.


        """
    def removeTransformGroup(self, name: str) -> None:
        """

        removeTransformGroup(self, name)

            Removes a transform group from the agent definition.

            Raises hou.GeometryPermissionError if the agent definition is not
            modifiable.


            name
                The name of the transform group to remove.


        """
    def metadata(self) -> AgentMetadata:
        """

        setMetadata(self, metadata)

            Replaces the agent definition's metadata. Raises
            hou.GeometryPermissionError if the agent definition is not
            modifiable.


            metadata
                A hou.AgentMetadata.


        """
    def setMetadata(self, metadata: AgentMetadata) -> None: ...

class AgentLayer:
    """

    hou.AgentLayer

    An agent's layer.

    See Agent Layers for more information.


    """
    thisown: Incomplete
    def __init__(self, name: str, rig: AgentRig, shapelib: AgentShapeLibrary, shape_bindings: Sequence[AgentShapeBinding], source_layer: AgentLayer|None = ...) -> None:
        """

        __init__(name, rig, shapelib, shape_bindings, source_layer = None)

            Creates a new agent layer with the specified shape bindings.


            name
                The name of the new layer.

            rig
                The hou.AgentRig that the layer will be associated with.

            shapelib
                The hou.AgentShapeLibrary that the layer will be associated
                with.

            shape_bindings
                A list of shape bindings to add to the layer.

            source_layer
                Specifies an optional hou.AgentLayer to copy shape bindings
                from.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def asJSON(self) -> str:
        """

        asJSON(self) -> str

            Returns a string containing the JSON that represents the layer.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of the layer.


        """
    def fileName(self, expanded: bool = False) -> str:
        """

        fileName(self, expanded = False) -> str

            If the layer is an external reference, returns the path to the file
            on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
    def bindings(self, transform: int|None = ...) -> Tuple[AgentShapeBinding,...]:
        """

        bindings(self, transform = None) -> tuple of hou.AgentShapeBinding

            Returns the list of shape bindings in the layer.


            transform
                Index of a transform in the agent's rig. If specified, only the
                shape bindings attached to the specified transform will be
                returned.


        """
    def staticBindings(self) -> Tuple[AgentShapeBinding, ...]:
        """

        staticBindings(self) -> tuple of hou.AgentShapeBinding

            Returns the shape bindings in the layer which reference static
            shapes.


        """
    def deformingBindings(self) -> Tuple[AgentShapeBinding, ...]:
        """

        deformingBindings(self) -> tuple of hou.AgentShapeBinding

            Returns the shape bindings in the layer which reference deforming
            shapes.


        """

class AgentMetadata:
    """

    hou.AgentMetadata

    Stores metadata in an agent definition.

    The metadata contains a dictionary mapping strings to values, and can be
    used to store additional custom data in the agent definition.

    RELATED

      * hou.AgentDefinition


    """
    thisown: Incomplete
    def __init__(self, data: Mapping[str, Any]) -> None:
        """

        __init__(data)

            Creates new metadata from the provided dictionary.


            data
                A dict mapping strings to values.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def freeze(self) -> AgentMetadata:
        """

        freeze(self) -> hou.AgentMetadata

            Creates a modifiable copy of the metadata. The copy will not be
            marked as an external reference.


        """
    def isReadOnly(self) -> bool:
        """

        isReadOnly(self) -> bool

            Return a bool indicating whether the metadata is read-only.


        """
    def asJSON(self) -> str:
        """

        asJSON(self) -> str

            Returns a string containing the JSON representation of the metadata.


        """
    def fileName(self, expanded: bool = False) -> str:
        """

        fileName(self, expanded = False) -> str

            If the metadata is an external reference, returns the path to the
            file on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
    def data(self) -> dict[str, Any]:
        """

        data(self) -> dict of str to value

            Returns the metadata dictionary.


        """
    def setData(self, data: Mapping[str, Any]) -> None:
        """

        setData(self, data)

            Replaces the metadata dictionary. Raises hou.GeometryPermissionError
            if the metadata is not modifiable.


            data
                A dict mapping strings to values.


        """

class AgentRig:
    """

    hou.AgentRig

    The rig of an agent primitive.

    See Crowd Agents for more information.


    """
    thisown: Incomplete
    def __init__(self, name: str, transform_names: Sequence[str], hierarchy: Sequence[int]) -> None:
        '''

        __init__(name, transform_names, hierarchy)

            Creates a new agent rig from the given transform hierarchy.


            name
                The name of the new rig.

            transform_names
                A sequence of transform names.

            hierarchy
                A sequence of int sequences that specifies, for each transform
                in transform_names, the indices of its children in
                transform_names. See hou.AgentRig.transformHierarchy.

            The following example shows how to create a simple rig where
            transforms b and c are children of transform a.

          > transforms = [\\"a\\", \\"b\\", \\"c\\"]
          > hierarchy = [ [1, 2], [], [] ]
          > rig = hou.AgentRig(\\"my_rig\\", transforms, hierarchy)

        '''
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def freeze(self) -> AgentRig:
        """

        freeze(self) -> hou.AgentRig

            Creates a modifiable copy of the rig. The copy will not be marked as
            an external reference.


        """
    def asJSON(self) -> str:
        """

        asJSON(self) -> str

            Returns a string containing the JSON that represents the rig.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name or filename of the rig.


        """
    def fileName(self, expanded: bool = False) -> str:
        """

        fileName(self, expanded = False) -> str

            If the rig is an external reference, returns the path to the file on
            disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
    def transformCount(self) -> int:
        """

        transformCount(self) -> int

            Returns the number of transforms in the rig.


        """
    def transformName(self, i: int) -> str:
        """

        transformName(self, transform) -> str

            Returns the name of the specified transform.


            transform
                Index of a transform in the rig.


        """
    def findTransform(self, transform_name: str) -> int:
        """

        findTransform(self, transform_name) -> int

            Returns the index of the transform with the given name, or -1 if the
            transform name is invalid.


            transform_name
                Name of a transform in the rig.


        """
    def parentIndex(self, transform: int) -> int:
        """

        parentIndex(self, transform) -> int

            Returns the parent of the specified transform, or -1 if the
            transform is a root of the transform hierarchy.


            transform
                Index of a transform in the rig.


        """
    def childIndices(self, transform: int) -> Tuple[int, ...]:
        """

        childIndices(self, transform) -> tuple of int

            Returns the children of the specified transform.


            transform
                Index of a transform in the rig.


        """
    def setRestLocalTransforms(self, xforms: typing.Iterable[Matrix4]) -> None:
        """

        setRestLocalTransforms(self, xforms)

            Sets the local space rest transforms for the rig.

            Raises hou.GeometryPermissionError if the rig is not modifiable.


            xforms
                A sequence of hou.Matrix4, with a local space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
    def restLocalTransform(self, i: int) -> Matrix4:
        """

        restLocalTransform(self, transform) -> hou.Matrix4

            Returns the local space rest transform for the specified index in
            the hierarchy.


            transform
                Index of a transform in the rig.


        """
    def restWorldTransform(self, i: int) -> Matrix4:
        """

        restWorldTransform(self, transform) -> hou.Matrix4

            Returns the world space rest transform for the specified index in
            the hierarchy.


            transform
                Index of a transform in the rig.


        """
    def channelCount(self) -> int:
        """

        channelCount(self) -> int

            Returns the number of channels in the rig.


        """
    def channelName(self, i: int) -> str:
        """

        channelName(self, channel_index) -> str

            Returns the name of the specified channel.


            channel_index
                Index of a channel in the rig.


        """
    def channelDefaultValue(self, i: int) -> float:
        """

        channelDefaultValue(self, channel_index) -> float

            Returns the default value of the specified channel.


            channel_index
                Index of a channel in the rig.


        """
    def channelTransform(self, i: int) -> int:
        """

        channelTransform(self, channel_index) -> int

            Returns the transform index that the specified channel is associated
            with, or -1.


            channel_index
                Index of a channel in the rig.


        """
    def findChannel(self, channel_name: str) -> int:
        """

        findChannel(self, channel_name) -> int

            Returns the index of the channel with the given name, or -1 if the
            channel name is invalid.


            channel_name
                Name of a channel in the rig.


        """
    def addChannel(self, name: str, default_value: float = 0.0, transform: int = -1) -> None:
        """

        addChannel(self, name, default_value=0.0, transform=-1)

            Adds a new channel to the rig. If a channel already exists with the
            same name, properties such as the default value will be overwritten.

            Raises hou.GeometryPermissionError if the rig is not modifiable.


            name
                The name of the channel.

            `default_value
                A float containing the channel's default value.

            `transform
                Optional index of a transform that the channel is associated
                with.


        """

class AgentShape:
    """

    hou.AgentShape

    An agent's shape.

    See Crowd Agents for more information.

    RELATED

      * hou.AgentShapeBinding

      * hou.AgentShapeLibrary

      * hou.crowds.addBlendshapeInputs

      * hou.crowds.addInBetweenShapes

      * hou.crowds.setBlendshapeDeformerParms


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def name(self) -> str:
        """

        name(self) -> str

            Returns the shape's name, which is unique within a shape library.


        """
    def uniqueId(self) -> int:
        """

        uniqueId(self) -> int

            Returns the shape's globally unique id.


        """
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Returns the shape's geometry.


        """
    def freeze(self) -> AgentShape:
        """

        freeze(self) -> hou.AgentShape

            Creates a new modifiable copy of the shape. Raises
            hou.GeometryPermissionError if the shape library is not modifiable.


        """
    def setGeometry(self, geometry: Geometry) -> None:
        """

        setGeometry(self, geometry)

            Replaces the shape's geometry. Raises hou.GeometryPermissionError if
            the shape is not modifiable.


            geometry
                A hou.Geometry containing the shape's new geometry.


        """

class AgentShapeBinding:
    """

    hou.AgentShapeBinding

    A shape binding in an agent's layer.

    A shape binding attaches a shape from the agent's shape library to a
    transform in the agent's rig. See Agent Layers for more information.


    """
    thisown: Incomplete
    def __init__(self, shape: AgentShape, deformer: AgentShapeDeformer, bounds_scale: float = ...) -> None:
        """

        __init__(shape, deformer, bounds_scale = 1.0)

            Creates a new shape binding, where the shape is not attached to a
            transform in the agent's rig. This can be useful for deforming
            shapes, which are deformed based on their capture attributes and the
            agent's current pose.


            shape
                A shape in the agent's shape library.

            deformer
                Specifies the hou.AgentShapeDeformer that should be used to
                deform the shape. A value of None will produce a static shape
                binding.

            bounds_scale
                Scale factor for the shape's bounding box. This can be a single
                float (for a uniform scale) or a hou.Vector3.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def shapeName(self) -> str:
        """

        shapeName(self) -> str

            Returns the name of the shape. This is equivalent to shape().name().


        """
    def shapeId(self) -> int:
        """

        shapeId(self) -> int

            Returns the unique id of the shape. This is equivalent to
            shape().uniqueId().


        """
    def transformId(self) -> int:
        """

        transformId(self) -> int

            Returns the index of the transform in the agent's rig that the shape
            is attached to.


        """
    def isDeforming(self) -> bool:
        """

        isDeforming(self) -> bool

            Returns whether the shape is static or deforming.


        """
    def boundsScale(self) -> Vector3:
        """

        boundsScale(self) -> hou.Vector3

            Returns the scale factor for the shape's bounding box.


        """
    def shape(self) -> AgentShape:
        """

        shape(self) -> hou.AgentShape

            Returns the referenced shape.


        """
    def deformer(self) -> AgentShapeDeformer:
        """

        deformer(self) -> hou.AgentShapeDeformer

            Returns the deformer used for the shape, or None if the shape
            binding is static.


        """

class AgentShapeDeformer:
    """

    hou.AgentShapeDeformer

    A deformer for agent shapes.

    Agent shape deformers are used to provide different deformation methods
    for shapes, such as linear skinning or dual quaternion skinning. Each
    shape binding can specify the deformer that should be used. The
    hou.crowds.shapeDeformers method provides a list of the available
    deformers.


    """
    thisown: Incomplete
    def __init__(self, name: str|EnumValue) -> None:
        """

        __init__(name)

            Creates a new deformer instance from the specified unique name.
            Raises hou.OperationFailed if there is not a registered deformer
            with this name.

            When using the built-in shape deformers, it is preferable to use the
            constructor that accepts a hou.agentShapeDeformerType. However, this
            constructor can be used with custom shape deformers that were
            registered via the HDK.

            hou.crowds.shapeDeformers provides a list of the registered
            deformers.


            name
                The unique name of the deformer (e.g. linearskinning).


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def name(self) -> str:
        """

        name(self) -> str

            Returns the unique name for the deformer.


        """

class AgentShapeLibrary:
    """

    hou.AgentShapeLibrary

    The shape library of an agent primitive.

    See Crowd Agents for more information.


    """
    thisown: Incomplete
    def __init__(self, filename: str, keep_external_ref: bool = ...) -> None:
        """

        __init__(filename, keep_external_ref = True)

            Creates a new agent shape library by loading it from the specified
            geometry file.

            Raises hou.OperationFailed if the file does not exist or otherwise
            cannot be loaded.


            filename
                A path to a geometry file.

            keep_external_ref
                A bool indicating whether the external reference should be
                maintained when the agent is saved to a geometry file. If the
                reference is maintained, then the shape library file needs to be
                available when the saved geometry is used (only the path to the
                shape library is saved in the geometry file). Otherwise, a copy
                of the shape library will be inlined when saving out the
                geometry so that the original shape library file is no longer
                needed.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def freeze(self, keep_external_ref: bool = False) -> AgentShapeLibrary:
        """

        freeze(self, keep_external_ref = False) -> hou.AgentShapeLibrary

            Creates a modifiable copy of the shape library.


            keep_external_ref
                If the original shape library referenced a file on disk,
                specifies whether the new shape library should be marked as
                including the original library. In this situation, saving out
                the new shape library will only write out shapes that were not
                included from the original library, along with the path to the
                included shape library. Otherwise, saving out the new shape
                library will produce a standalone library containing all of the
                shapes.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name or filename of the shape library.


        """
    def fileName(self, expanded: bool = False) -> str:
        """

        fileName(self, expanded = False) -> str

            If the shape library is an external reference, returns the path to
            the file on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
    def findShape(self, name: str) -> Optional[AgentShape]:
        """

        findShape(self, shape_name) -> hou.AgentShape

            Finds the shape with the specified name, or None if no such shape
            exists.


        """
    def shapes(self) -> Tuple[AgentShape, ...]:
        """

        shapes(self) -> tuple of hou.AgentShape

            Returns a list of all shapes in the shape library.


        """
    def data(self) -> Geometry:
        """

        data(self) -> hou.Geometry

            Returns the geometry representation of the shape library, which can
            be saved to disk.


        """
    def addShape(self, name: str, geometry: Geometry) -> AgentShape:
        """

        addShape(self, name, geometry) -> hou.AgentShape

            Adds a new shape to the shape library.

            Raises hou.GeometryPermissionError if the shape library is not
            modifiable.


            name
                The name for the new shape.

            geometry
                A hou.Geometry containing the shape's geometry.


        """

class AgentTransformGroup:
    """

    hou.AgentTransformGroup

    A group of transforms and channels in an agent's rig.

    See Crowd Agents for more information.


    """
    thisown: Incomplete
    def __init__(self, name: str, transforms: Sequence[int], rig: AgentRig, weights: Sequence[float], channels: Sequence[int]) -> None:
        """

        __init__(name, transforms, rig, weights, channels)

            Creates a new transform group containing the specified transforms
            and channels.


            name
                The name of the new transform group.

            transforms
                An int sequence containing the index of each transform in the
                group.

            rig
                The hou.AgentRig that the group will be associated with.

            weights
                A float sequence specifying the weight (between 0 and 1) of each
                transform in the group.

            channels
                An int sequence containing the index of each channel in the
                group.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def asJSON(self) -> str:
        """

        asJSON(self) -> str

            Returns a string containing the JSON representation of the group.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of the transform group.


        """
    def fileName(self, expanded: bool = False) -> str:
        """

        fileName(self, expanded = False) -> str

            If the transform group is an external reference, returns the path to
            the file on disk.


            expanded
                Specifies whether to expand any variables in the path, such as
                $HIP.


        """
    def transformIndices(self) -> Tuple[int, ...]:
        """

        transformIndices(self) -> tuple of int

            Returns a list containing the index of each transform in the group.


        """
    def weights(self) -> Tuple[float, ...]:
        """

        weights(self) -> tuple of float

            Returns a list containing the weight of each transform in the group.


        """
    def channelIndices(self) -> Tuple[int, ...]:
        """

        channelIndices(self) -> tuple of int

            Returns a list containing the index of each channel in the group.


        """

class anim:
    """

    hou.anim

    Module which contains functions for working with animation utilities.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def bookmarks() -> Tuple[Bookmark, ...]:
        """

        bookmarks() -> tuple of hou.Bookmarks

            Returns a tuple of current hou.Bookmarks, sorted by start time.


        """
    @staticmethod
    def saveBookmarks(filename: str, bookmarks: Sequence[Bookmark]|None = ..., include_temporary: bool = ...) -> bool:
        """

        saveBookmarks(filename, bookmarks=None, include_temporary=False) -> bool

            Saves a provided list of hou.Bookmark objects to the given json
            file. If the second argument is left empty, the list of current
            bookmarks will be saved instead. Returns True on success, or False
            otherwise.


            filename
                Name of the file to export the bookmarks to. It should have
                either a .json or .otio extension.

            bookmarks
                If provided, only the given bookmarks will be saved instead of
                saving all bookmarks.

            include_temporary
                Whether or not bookmarks marked as temporary should be included
                in the saved file. False by default. See
                hou.Bookmark.setTemporary.


        """
    @staticmethod
    def loadBookmarks(filename: str, remove_existing: bool = True) -> bool:
        """

        loadBookmarks(filename, remove_existing=True) -> bool

            Loads the list of bookmarks from the given file, returning True on
            success or False otherwise. Note that any existing hou.Bookmark
            objects will be invalid.


            filename
                Name of the file to load the bookmarks from. It should have
                either a .json or .otio extension.

            remove_existing
                Whether or not to remove existing bookmarks before loading the
                new ones.


        """
    @staticmethod
    def saveBookmarksToString(bookmarks: Sequence[Bookmark]|None = ..., include_temporary: bool = ..., binary: bool = ...) -> bytes:
        """

        saveBookmarksToString(bookmarks=None, include_temporary=False,
        binary=True) -> bytes

            Returns the data for the bookmarks as ASCII or binary, depending on
            the binary argument.


            bookmarks
                If provided, only the given bookmarks will be saved instead of
                saving all bookmarks.

            include_temporary
                Whether or not bookmarks marked as temporary should be included
                in the saved file. False by default. See
                hou.Bookmark.setTemporary.

            binary
                Whether to return the data string in ASCII or binary.


        """
    @staticmethod
    def loadBookmarksFromString(data: bytes, remove_existing: bool = True) -> bool:
        """

        loadBookmarksFromString(data, remove_existing=True)

            Loads the given bookmarks from the provided string.


            data
                ASCII or binary string returned by saveBookmarksToString.

            remove_existing
                Whether or not to remove existing bookmarks before loading the
                new ones.


        """
    @staticmethod
    def clearBookmarks() -> None:
        """

        clearBookmarks()

            Clears out all bookmarks. Note that any existing hou.Bookmark
            objects will be invalid.


        """
    @staticmethod
    def newBookmark(name: str, start: float, end: float) -> Bookmark:
        """

        newBookmark(name, start_frame, end_frame) -> hou.Bookmark

            Creates and returns a new hou.Bookmark object using the provided
            options. You must use this function to create new bookmarks; you
            cannot instantiate the Bookmark class directly.


        """
    @staticmethod
    def bookmark(bookmark_id: int) -> Optional[Bookmark]:
        """

        bookmark(session_id) -> hou.Bookmark

            Returns the hou.Bookmark with the matching session id, or returns
            None if there is no such bookmark.


        """
    @staticmethod
    def getBookmark(bookmark_id: int) -> Optional[Bookmark]:
        """

        getBookmark(session_id) -> hou.Bookmark

            This method is deprecated in favor of hou.anim.bookmark.

            Returns the hou.Bookmark with the matching session id, or returns
            None if there is no such bookmark.


        """
    @staticmethod
    def removeBookmarks(bm: Sequence[Bookmark]) -> None:
        """

        removeBookmarks(bookmarks)

            Deletes the given bookmarks and removes them from the list of active
            bookmarks. The bookmarks parameter should be a list of hou.Bookmark
            objects.


        """
    @staticmethod
    def mergeGeometryChannels(collection_name: str, geometry: Geometry, channel_names: Sequence[str]|None = ...) -> None:
        """

        mergeGeometryChannels(collection_name, geometry, channel_names=None)

            Writes geometry channels which were previously added to the channel
            list back into the provided geometry as channel primitives.


            collection_name
                Name of the collection from which to fetch the geometry
                channels.

            geometry
                Writeable geometry which the channel primitives will be written
                to.

            channel_names
                List of names of channels in the given collection to fetch. If
                not specified, all channels in the collection will be fetched.

            See also:

          * hou.ChannelList.addGeometryChannels

          * hou.ChannelList.addNodeGeometryChannels

          * hou.playbar.setChannelList


        """
    @staticmethod
    def getGeometryChannels(collection_name: str, geometry: Geometry, channel_names: Sequence[str]|None = ...) -> None:
        """

        getGeometryChannels(collection_name, geometry, channel_names=None)

            This method is deprecated in favor of
            hou.anim.mergeGeometryChannels.

            Writes geometry channels which were previously added to the channel
            list back into the provided geometry as channel primitives.


            collection_name
                Name of the collection from which to fetch the geometry
                channels.

            geometry
                Writeable geometry which the channel primitives will be written
                to.

            channel_names
                List of names of channels in the given collection to fetch. If
                not specified, all channels in the collection will be fetched.

            See also:

          * hou.ChannelList.addGeometryChannels

          * hou.ChannelList.addNodeGeometryChannels

          * hou.playbar.setChannelList


        """
    @staticmethod
    def setGeometryChannels(collection_name: str, geometry: Geometry, channel_names: Sequence[str]) -> None:
        """

        setGeometryChannels(collection_name, geometry, channel_names)

            Updates an existing scoped geometry channels collection with
            channels from the specified geometry. If channels with conflicting
            names already exist in the geometry, they will be overwritten.


            collection_name
                Name of the collection which the given channels will be added
                to.

            geometry
                Geometry from which to fetch the new channel primitives from.

            channel_names
                List of names of channels to add to the collection. If empty,
                all channels in the geometry will be added.


        """
    @staticmethod
    def setGeometryChannelsFromPattern(collection_name: str, geometry: Geometry, pattern: str) -> None:
        """

        setGeometryChannelsFromPattern(collection_name, geometry, pattern)

            Updates an existing scoped geometry channels collection with
            channels from the specified geometry. If channels with conflicting
            names already exist in the geometry, they will be overwritten.


            collection_name
                Name of the collection which the given channels will be added
                to.

            geometry
                Geometry from which to fetch the new channel primitives from.

            pattern
                Pattern string, of channel primitives to add to the collection.


        """
    @staticmethod
    def setGeometryChannelPending(collection_name: str, channel_name: str, value: Optional[float]) -> None:
        """

        setGeometryChannelPending(collection_name, channel_name, value)

            Sets the value of the scoped geometry channel at the current frame
            and marks it as pending.


            collection_name
                Name of the collection which the channel belongs to.

            channel_name
                Name of the channel to modify.

            value
                Pending value to set at the current frame. If None, any pending
                keys for the channel will be cleared.


        """
    @staticmethod
    def isGeometryChannelPending(collection_name: str, channel_name: str) -> bool:
        """

        isGeometryChannelPending(collection_name, channel_name)

            Returns whether or not a channel has a pending value.


            collection_name
                Name of the collection which the channel belongs to.

            channel_name
                Name of the channel.


        """
    @staticmethod
    def isGeometryChannelPinned(collection_name: str, channel_names: str|None = ...) -> bool:
        """

        isGeometryChannelPinned(collection_name, channel_name=None) -> bool

            Returns whether or not a geometry channel is pinned. If the second
            argument is left empty, returns whether or not all channels in the
            collection are pinned.


            collection_name
                Name of the collection which the channel belongs to.

            channel_name
                Name of the channel.


        """
    @staticmethod
    def pinnedGeometryChannels(collection_name: str) -> Tuple[str, ...]:
        """

        pinnedGeometryChannels(collection_name)

            Returns a list of all pinned geometry channels in the provided
            collection.


            collection_name
                Name of the collection.


        """
    @staticmethod
    def getPinnedGeometryChannels(collection_name: str) -> Tuple[str, ...]:
        """

        getPinnedGeometryChannels(collection_name)

            This method is deprecated in favor of
            hou.anim.pinnedGeometryChannels.

            Returns a list of all pinned geometry channels in the provided
            collection.


            collection_name
                Name of the collection.


        """
    @staticmethod
    def lockGeometryChannelCollection(collection_name: str, lock: bool) -> None:
        """

        lockGeometryChannelCollection(collection_name, lock)

            Locks or unlocks a geometry channel collection, by preventing
            editing of its channels.


            collection_name
                Name of the collection to modify

            lock
                Whether to lock or unlock the collection.


        """
    @staticmethod
    def addBookmarksChangedCallback(callback: Callable) -> None:
        """

        addBookmarksChangedCallback(callback)

            Registers a callback function to be executed whenever the current
            bookmarks are modified.


        """
    @staticmethod
    def removeBookmarksChangedCallback(callback: Callable) -> None:
        """

        removeBookmarksChangedCallback(callback)

            Removes an existing callback.


        """
    @staticmethod
    def addGeometryChannelsChangedCallback(collection_name: str, callback: Callable, on_mouse_up: bool = ...) -> bool:
        """

        addGeometryChannelsChangedCallback(collection_name, callback,
        on_mouse_up=True)

            Registers a callback function to be executed whenever geometry
            channels in the given collection are modified. The collection must
            have already been added to the channel list with
            hou.playbar.setChannelList.


            collection_name
                Name of the collection from which to listen for changes.

            callback
                Callback function, accepting two parameters, a tuple of the
                names of geometry channels that have been changed, and the
                collection name.

            on_mouse_up
                When modifying geometry channels in the Channel Editor, whether
                this callback should be triggered only on mouse up, or
                continuously as channels are modified. Defaults to True, for
                only on mouse up.

            See also:

          * hou.ChannelList.addGeometryChannels

          * hou.ChannelList.addNodeGeometryChannels

          * hou.playbar.setChannelList


        """
    @staticmethod
    def removeGeometryChannelsChangedCallback(collection_name: str, callback: Callable, on_mouse_up: bool = ...) -> bool:
        """

        removeGeometryChannelsChangedCallback(collection_name, callback,
        on_mouse_up=True)

            Removes an existing callback from the given geometry channels
            collection.


            collection_name
                Name of the collection from which to remove a callback.

            callback
                Callback function to remove.

            on_mouse_up
                Whether the callback to remove was registered for mouse up
                events or not. Must match the same value passed in when
                originally registering the callback with
                addGeometryChannelsChangedCallback.


        """
    @staticmethod
    def slopeMode() -> EnumValue:
        """

        slopeMode(self) -> hou.slopeMode

            Returns the current slope mode for inserting new keys, auto or
            manual.


        """
    @staticmethod
    def setSlopeMode(mode: EnumValue) -> None:
        """

        setSlopeMode(self, mode)

            Set the default slope mode to one of the following:

          * hou.slopeMode.Manual: Newly inserted keys will be set to manual
            slope mode.

          * hou.slopeMode.Automatic: Newly inserted keys will be set to
            automatic slope mode.


        """

class AnimBar:
    """

    hou.AnimBar

    The animation toolbar lives above the playbar or at the bottom of the
    animation editor, and consists of simple slider tools for easily
    manipulating animation curves.

    You cannot instantiate this object directly. Call hou.playbar.animBar or
    hou.ChannelEditorPane.animBar instead.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def tools(self, shown_only: bool = True) -> Tuple[str, ...]:
        """

        tools(self, shown_only: bool=True) -> tuple

            Returns a tuple of strings consisting of the ids of the tools
            currently present on the animation toolbar. If shown_only is set to
            False, will instead return the ids of all tools, including those
            that have been removed from the toolbar.


        """
    def hiddenTools(self) -> Tuple[str, ...]:
        """

        hiddenTools(self) -> tuple

            Returns a tuple of strings consisting of the ids of the tools that
            have been removed from the animation toolbar.


        """
    def setTools(self, tool_ids: Sequence[str]) -> None:
        """

        setTools(self, tool_ids: tuple)

            Sets the active tools on the animation toolbar, replacing the
            previously active tools.

            tool_ids is a tuple of strings consisting of the ids of the tools to
            be set.


        """
    def removeTool(self, id: str) -> None:
        """

        removeTool(self, id: str)

            Removes a tool with the given id from the animation toolbar.


        """
    def addTool(self, id: str, index: int = -1) -> None:
        """

        addTool(self, id: str, index: int=-1)

            Adds the tool with the given id to the animation toolbar, if it is
            not already present.

            id is the id of the tool to add.

            index is an optional argument specifying the position at which to
            add the tool. If not provided, the tool is added at the end of the
            toolbar.


        """
    def reset(self) -> None:
        """

        reset(self)

            Resets the animation toolbar, adding back all removed tools and
            placing them back in their original order.


        """
    def showLabels(self, show: bool) -> None:
        """

        showLabels(self, show: bool)

            Shows or hides the labels that are displayed below each tool.


        """
    def labelsShown(self) -> bool:
        """

        labelsShown(self) -> bool

            Returns whether or not full labels are currently displayed for each
            tool.


        """
    def setToolSize(self, tool_size: EnumValue) -> None:
        """

        setToolSize(self, size)

            Sets the size of the tools on the animation toolbar.

            size is a hou.animBarToolSize


        """
    def toolSize(self) -> EnumValue:
        """

        toolSize(self) -> hou.animBarToolSize

            Returns the current size of the tools on the animation toolbar.


        """

class anonstats:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def recordOccurrence(key: str) -> None: ...
    @staticmethod
    def recordString(key: str, value: str) -> None: ...
    @staticmethod
    def hasString(key: str) -> bool: ...
    @staticmethod
    def getString(key: str) -> str: ...
    @staticmethod
    def incrementCount(key: str, count: int = 1) -> None: ...
    @staticmethod
    def logEvent(key: str, message: str) -> None: ...
    @staticmethod
    def addSum(key: str, stat_value: float, count: int = 1) -> None: ...

class AssetBrowser(PathBasedPaneTab):
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def reload(self) -> None: ...
    def installRequiredDefinitionsForNodeTypeName(self, node_type_name: str) -> None: ...
    def storeUpdateSessionKey(self, session_key: str) -> None: ...
    def updateAssetDownloadFraction(self, node_type_name: str, downloaded_bytes: int, total_bytes: int) -> None: ...
    def storeSyncSessionKey(self, session_key: str) -> None: ...

class AssetGalleryDataSource:
    """

    hou.AssetGalleryDataSource

    Provides an interface to any data source that can be used in association
    with an asset or snapshot gallery UI.

    Houdini's various asset catalog panels (the snapshot gallery attached to
    the LOP Scene Viewer, the Working Set in the Layout LOP's brush panel,
    and the Asset Catalog pane) are all populated by pulling data from this
    class. This object is created by providing a source identifier, and an
    optional additional string argument. The source identifier is used to
    find or create a shared underlying data source implementation object
    (which may be a C++ or python object). These implementation objects are
    responsible for responding to the methods called on this object.

    Houdini ships with three data source implementations. One uses an SQL
    database with read and write capabilities. This data source
    implementation type is used when the source identifier is a file path
    with a .db, .sqlite, or .sqlite3 extension. Another supports any file on
    disk with a USD file extension. This data source is read only, and
    accepts an additional argument specifying the primitive pattern
    indicating which primitives in the USD file should be presented as
    assets. Finally, if the source identifier beings with an op: prefix
    followed by a path to a LOP node, the stage for that LOP node is used as
    a read only data source, and again the additional argument specifies a
    primitive pattern to indicate which primitives on the source stage
    represent assets.

    To create a new data source implementation in C++, you must create a
    subclass of UT_GalleryDataSourceImpl (see UT_GalleryDataSource.h), and
    register it by calling
    UT_GalleryDataSource::registerDataSourceImplementation. To create a new
    data source implementation in python, create a subclass of the
    DataSource object defined in the husd.datasource module, and place it in
    the $HFS/houdini/husdplugins/datasources directory. See the usdfile.py
    module for an example.

    The methods on this class almost always simply forward the call to the
    underlying data source implementation object. So the decription of each
    method here also serves to document the action an that should be
    undertaken in each correspondingly named method on an implementation
    class.


    """
    thisown: Incomplete
    def __init__(self, source_identifier: str, args: Optional[str] = None) -> None:
        """

        __init__(self, source_identifier, args=None) -> AssetGalleryDataSource

            Constructs or finds a matching existing data source implementation
            object based on the source_identifier and optional implementation-
            specific args parameter.


        """
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def isValid(self) -> bool:
        """

        isValid(self) -> bool

            Return True if this data source has a valid implementation,
            otherwise return False. Returning False usually indicates that the
            source identifier does not represent an existing file or LOP node,
            or that the file type is not supported by any data source
            implementation classes.


        """
    def isReadOnly(self) -> bool:
        """

        isReadOnly(self) -> bool

            Return True if this data source only supports read operations,
            otherwise return False. A data source implementation that returns
            False for this method will never have any of its set methods called,
            and any attempts to call these methods on this object will
            immediately return False.


        """
    def sourceIdentifier(self) -> str:
        """

        sourceIdentifier(self) -> str

            Return the source identifier string used to create this data source
            object.


        """
    def sourceArgs(self) -> str:
        """

        sourceArgs(self) -> str

            Return the args string used to create this data source object.


        """
    def infoHtml(self) -> str:
        """

        infoHtml(self) -> str

            Return a string in HTML format that will be displayed at the top of
            the asset catalog window. Provides custom information about the data
            source. Can return an empty string to indicate that the HTML info
            window at the top of the gallery should be hidden.


        """
    def startTransaction(self) -> None:
        """

        startTransaction(self)

            For writable data sources, this method can be used to group multiple
            calls to edit the data source. Once this method is called, requests
            to edit the data source do not actually need to edit the underlying
            data source until the endTransaction method is called.


        """
    def endTransaction(self, commit: bool = True) -> None:
        """

        endTransaction(self, commit=True)

            This method is always called after a call to startTransaction, and
            indicates that the group of data source edits has been completed.
            When this method returns, all edits since the call to
            startTransaction should be committed to the data source. If the
            commit parameter is False, all edits since the call to
            startTransaction should be discarded, and none of them should be
            recorded to the data source.


        """
    def itemIds(self) -> Tuple[str, ...]:
        """

        itemIds(self) -> tuple of str

            Return a unique identifier for each asset available in the data
            source. The ids returned by this method will be used to identify
            individual assets in every other method that gets or sets
            information associated with a specific asset.


        """
    def updatedItemIds(self) -> Tuple[str, ...]: ...
    def childItemIds(self, parent: str) -> Tuple[str, ...]:
        """

        childItemIds(self, item_id) -> tuple of str

            Return a list of unique identifier for all assets that have this
            item set as its parent. Passing an empty string as the item_id will
            return a list of items that have the 'root' as their parent.


        """
    def sourceTypeName(self, item_id: Optional[str] = None) -> str:
        """

        sourceTypeName(self, item_id=None) -> str

            Return the data source type of the asset identified by the id. The
            source type controls how the asset is instantiated in a Houdini LOP
            Network. Generally all the assets from a data source will return the
            same sourceTypeName, which is why the item_id parameter here is
            optional. Only data sources that aggregate data from multiple other
            sources would return per-asset values from this method.


        """
    def typeName(self, item_id: str) -> str:
        """

        typeName(self, item_id) -> str

            Return the type of asset identied by the id. This will either be
            snapshot (for a snapshot in a snapshot gallery) or asset (for an
            asset in an asset catalog).


        """
    def label(self, item_id: str) -> str:
        """

        label(self, item_id) -> str

            Return the user-facing string that identifies and describes the
            item. This value need not be unique, and is normally displayed under
            the item's thumbnail image.


        """
    def thumbnail(self, item_id: str) -> bytes:
        """

        thumbnail(self, item_id) -> bytes

            Return the raw data for a thumbnail image that represents the item.


        """
    def creationDate(self, item_id: str) -> int:
        """

        creationDate(self, item_id) -> int

            Return a long integer representing the unix timestamp at which the
            item was created.


        """
    def modificationDate(self, item_id: str) -> int:
        """

        modificationDate(self, item_id) -> int

            Return a long integer representing the unix timestamp at which the
            item was last modified.


        """
    def isStarred(self, item_id: str) -> bool:
        """

        isStarred(self, item_id) -> bool

            Return True if this item has been marked as a favorite by the user.


        """
    def colorTag(self, item_id: str) -> str:
        """

        colorTag(self, item_id) -> str

            Return a string indicating a special color tag value that has been
            assigned by the user. These color strings are displayed as colored
            bars in the gallery browser UI. Supported values are blue, green,
            purple, yellow, teal, and red.


        """
    def tags(self, item_id: str) -> Tuple[str, ...]:
        """

        tags(self, item_id) -> tuple of str

            Return a tuple of user defined tag strings that have been assigned
            to this item.


        """
    def filePath(self, item_id: str) -> str:
        """

        filePath(self, item_id) -> str

            Return a string that can be used to access the raw data assocaited
            with this item. In the case of a snapshot, this will be path to the
            snapshot image file on disk. In the case of an asset, this will be
            the path to a USD file on disk or a string representing a path to
            the LOP node which defines this asset.


        """
    def ownsFile(self, item_id: str) -> bool:
        """

        ownsFile(self, item_id) -> bool

            Return True if the filePath for this item is a file on disk that
            should be deleted if the item is deleted. This is generally True for
            a snapshot image, but False for a USD asset file (though in a custom
            data source implementation, it may also be True for a USD asset).


        """
    def blindData(self, item_id: str) -> bytes:
        """

        blindData(self, item_id) -> bytes

            Return a block of data source implementation specific binary data
            associated with the item. For a snapshot item, this will be the
            binary representation of the contents of the LOP Network when the
            snapshot was taken. For a USD asset, this may be a string
            representing information needed to pull a specific primitive out of
            a USD file (such as the root primitive path and variant selections).
            This blind data on an asset can be used by the data source specific
            code for instantiating an asset in a LOP network.


        """
    def status(self, item_id: str) -> str:
        """

        status(self, item_id) -> str

            Return a string describing the current status of this item. This
            field is used for render gallery background renders to track when
            the render is running (render_active), has completed
            (render_complete), or there was an error while rendering (error).


        """
    def parentId(self, item_id: str) -> str:
        """

        parentId(self, item_id) -> str

            Return the unique identifier for this item's parent item. If this
            item has no parent then an empty string is returned. This also
            indicates that the item is at thr 'root' of the tree.


        """
    def prepareItemForUse(self, item_id: str) -> str:
        """

        prepareItemForUse(self, item_id) -> str

            Make sure that the item is ready to be used. For data sources that
            point to remote databases, this method may involve downloading the
            item's data. Return an empty string if the item is ready for use,
            otherwise return an error string describing why the item could not
            be prepared.


        """
    def setLabel(self, item_id: str, label: str) -> bool:
        """

        setLabel(self, item_id, label) -> bool

            Set the value of the label for this item. Return True if this call
            resulted in a change to this value.


        """
    def setThumbnail(self, item_id: str, thumbnail: bytes) -> bool:
        """

        setThumbnail(self, item_id, thumbnail) -> bool

            Set the value of the thumbnail for this item. Return True if this
            call resulted in a change to this value.


        """
    def setModificationDate(self, item_id: str, timestamp: int) -> bool:
        """

        setModificationDate(self, item_id, timestamp) -> bool

            Set the value of the modificationDate for this item. Return True if
            this call resulted in a change to this value.


        """
    def setIsStarred(self, item_id: str, isstarred: bool) -> bool:
        """

        setIsStarred(self, item_id, isstarred) -> bool

            Set the value of the isStarred flag for this item. Return True if
            this call resulted in a change to this value.


        """
    def setColorTag(self, item_id: str, color_tag: str) -> bool:
        """

        setColorTag(self, item_id, color_tag) -> bool

            Set the value of the colorTag for this item. Return True if this
            call resulted in a change to this value.


        """
    def setMetadata(self, item_id: str, metadata: dict[str, Any]) -> bool:
        """

        setMetadata(self, item_id, metadata) -> bool

            Set the value of the metadata dictionary for this item. Return True
            if this call resulted in a change to this value.


        """
    def setFilePath(self, item_id: str, file_path: str) -> bool:
        """

        setFilePath(self, item_id, file_path) -> bool

            Set the value of the filePath for this item. Return True if this
            call resulted in a change to this value.


        """
    def setOwnsFile(self, item_id: str, owns_file: bool) -> bool:
        """

        setOwnsFile(self, item_id, owns_file) -> bool

            Set the value of the ownsFile flag for this item. Return True if
            this call resulted in a change to this value.


        """
    def setBlindData(self, item_id: str, data: bytes) -> bool:
        """

        setBlindData(self, item_id, data) -> bool

            Set the value of the blindData for this item. Return True if this
            call resulted in a change to this value.


        """
    def setParentId(self, item_id: str, parent_item_id: str) -> bool:
        """

        setParentId(self, item_id, parent_item_id) -> bool

            Set the value of the parent of this item to be parent_item_id.
            Setting to an empty string indicates this item has no parent and is
            therefore at the root of the tree.


        """
    def createTag(self, tag: str) -> bool:
        """

        createTag(self, tag) -> bool

            Create a tag in the data source, but do not assign it to any items.
            Return True if the tag did not already exist and was created.


        """
    def deleteTag(self, tag: str, delete_if_assigned: bool) -> bool:
        """

        deleteTag(self, tag, delete_if_assigned) -> bool

            Delete a tag from the data source. Return True if the tag existed
            and was removed. If delete_if_assigned is False, and the tag is
            assigned to any item, this function will do nothing and return
            False. If delete_if_assigned is True and the tag is assigned to any
            items, the tag is first unassigned from those items, then the tag is
            deleted.


        """
    def addTag(self, item_id: str, tag: str) -> bool:
        """

        addTag(self, item_id, tag) -> bool

            Adds a tag to a specific item. Creates the tag if it does not
            already exist. Return True if the tag was added to the item. Return
            False if the tag was already assigned to the item.


        """
    def removeTag(self, item_id: str, tag: str) -> bool:
        """

        removeTag(self, item_id, tag) -> bool

            Removes a tag from a specific item. Return True if the tag was
            removed from the item. Return False if the tag was not assigned to
            the item.


        """
    def generateItemFilePath(self, item_id: str, file_ext: str) -> str:
        """

        generateItemFilePath(self, item_id, file_ext) -> str

            Return a unique file path with an extension provided in file_ext.
            This helpful is useful for creating external files such as snapshot
            images on disk, as it automatically puts the image in the same
            location as the database file.


        """
    def addItem(self, label: str, file_path: str|None = ..., thumbnail: bytes = ..., type_name: str = ..., blind_data: bytes = ..., creation_date: int = ...) -> str:
        """

        addItem(self, label, file_path=None, thumbnail=b'', type_name='asset',
        blind_data=b'', creation_date=0) -> str

            Adds a new item to the data source. Sets the label, filePath,
            thumbnail, typeName, blindData, and creationDate values for the
            item. Return the item_id of the newly created item, or an empty
            string if the item could not be added.


        """
    def markItemsForDeletion(self, item_ids: Sequence[str]) -> bool:
        """

        markItemsForDeletion(self, item_ids) -> bool

            Marks one or more items to be deleted. Ideally this deletion does
            not happen until the data source is destroyed, indicating that the
            user has switched data sources or shut down Houdini. By only marking
            the item for future deletion instead of deleting the items, it is
            possible to undo the deletion using the unmarkItemsForDeletion
            method. But while an item is marked for deletion, it should not be
            returned by the itemIds method, or return any values when queried by
            other methods. Return True if the items were successfully marked for
            deletion. If a data source cannot support undoing the deletion of an
            item, this method should delete the item and return True.


        """
    def unmarkItemsForDeletion(self, item_ids: Sequence[str]) -> bool:
        """

        unmarkItemsForDeletion(self, item_ids) -> bool

            Remove the indicator in the data source that the supplied items
            should be deleted. This is used to undo the requested deletion of an
            item. Return True if the specified items were successfully
            undeleted. If a data source doesn't support undoing the deletion of
            an item, return False.


        """
    def saveAs(self, source_identifier: str) -> bool:
        """

        saveAs(self, source_identifier) -> bool

            Create a copy of the data source, if supported. This will also
            create copies of the item files, if the ownsFile flag is True.


        """
    def metadata(self, item_id: str) -> Any:
        """

        metadata(self, item_id) -> dict of str to str or float

            Return a dictionary of metadata that has been associated with this
            item. This metadata may be user created, or automatically (such as
            by a renderer used to create an image in the snapshot gallery).


        """

class Attrib:
    """

    hou.Attrib

    This class stores information about a Geometry attribute.

    An attribute describes extra data you can attach to different elements
    of geometry. The attribute values are the individual instances of that
    data, and for each attribute there is exactly one attribute value per
    geometry element. For example, if you look at the points in Houdini's
    geometry spreadsheet, the point numbers are listed down the side, the
    point attributes are listed across the top, and the point attribute
    values are contained in the table.

    The attribute specifies which elements store the attribute values:
    points, primitives, or vertices. An attribute can also be global (also
    known as a detail attribute), in which case there is one instance of the
    attribute value in the geometry.

    The attribute also specifies the data type of the attribute values.

    To look up existing attributes, use hou.Geometry.findPointAttrib,
    hou.Geometry.findPrimAttrib, hou.Geometry.findVertexAttrib, and
    hou.Geometry.findGlobalAttrib. To add a new attribute, use
    hou.Geometry.addAttrib.


    NOTE
        Point positions are stored in a point attribute named P and point
        weights are stored in Pw. See hou.Point.position and
        hou.Point.weight for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this attribute from the geometry. You would typically call
            this method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if you try to destroy the P or Pw point
            attributes.


        """
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Return the Geometry object containing this attribute.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the attribute's name. Each attribute in the geometry has a
            unique name.


        """
    def dataType(self) -> EnumValue:
        """

        dataType(self) -> hou.attribData enum value

            Return the attribute's data type (int, float or string).

            The size of the attribute also determines the format of the
            attribute values. For example, if the data type is int and the size
            is 3, the attribute value will be a tuple of 3 ints. If the size was
            1, the attribute value would simply be an int.

            Note that a string attribute's size must be 1.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.attribType enum value

            Return the type of attribute (point, primitive, vertex, or global).


        """
    def isArrayType(self) -> bool:
        """

        isArrayType(self) -> bool

            Return True if the attribute is a type that contains array data
            (i.e. Float Array, Integer Array, String Array) and False otherwise.


        """
    def numericDataType(self) -> EnumValue:
        """

        numericDataType(self) -> hou.numericData enum value

            Return the numeric (int, float) attribute's precision.


        """
    def qualifier(self) -> str:
        """

        qualifier(self) -> str

            Return the attribute's type qualifier. The qualifier is a
            description of the data contained in the attribute. An empty string
            is returned if the attribute has no numeric representation or if the
            attribute is the pseudo Pw point attribute.


        """
    def size(self) -> int:
        """

        size(self) -> int

            Return the number of data components in the attribute value. See
            hou.Attrib.dataType for more information.


        """
    def setSize(self, size: int) -> None:
        """

        setSize(self)

            Sets the number of data components in the attribute value. See
            hou.Attrib.dataType for more information.


        """
    def isTransformedAsVector(self) -> bool: ...
    def isTransformedAsNormal(self) -> bool:
        """

        isTransformedAsNormal(self) -> bool

            Return whether attribute values in the geometry are automatically
            transformed as a normal when Houdini transforms (e.g. rotates) the
            geometry.

            For more information, see the hou.Geometry.addAttrib, in the
            transform_as_normal parameter documentation.


        """
    def boostAnyDefaultValue(self) -> Any: ...
    def stringCount(self) -> int:
        """

        stringCount(self) -> int

            Returns the number of entries in the attribute's string table. If
            the attribute is not a string, 0 is returned.


        """
    def strings(self) -> Tuple[str, ...]:
        '''

        strings(self) -> tuple of str

            Return the string table for this attribute. If the attribute is not
            a string, returns an empty tuple.

            A string attribute does not store each string value inside the
            attribute element (i.e. point, primitive, etc.). Instead, the unique
            string attribute values are stored in a table inside the attribute,
            and each attribute value stores an index to that string.

            For example, suppose this attribute stores strings on points. If all
            points have the attribute value \\"foo\\" then the string table will be
            just (\\"foo\\",) and each point will store the index 0. When you set
            some points\' values to \\"bar\\", Houdini adds sets the string table to
            (\\"foo\\", \\"bar\\") and sets stores the index 1 in those points. When you
            set one of those points back to \\"foo\\", Houdini leaves the string
            table unchanged and stores the index 0 in that point.

            When using string attribute values, this implementation is hidden
            from you, and you get and set those attributes as strings. This
            method is provided only in case you need access to the string table.


        '''
    def replaceString(self, before: str, after: str) -> bool: ...
    def dictCount(self) -> int:
        """

        dictCount(self) -> int

            Returns the number of entries in the attribute's dictionary table.
            If the attribute is not a dictionary, 0 is returned.


        """
    def dicts(self) -> Tuple[dict[str, Any], ...]:
        '''

        dicts(self) -> tuple of dict

            Return the dictionary table for this attribute. If the attribute is
            not a dictionary, returns an empty tuple.

            A dictionary attribute does not store each dictionary value inside
            the attribute element (i.e. point, primitive, etc.). Instead, the
            unique dictionary attribute values are stored in a table inside the
            attribute, and each attribute value stores an index to that
            dictionary.

            For example, suppose this attribute stores dictionaries on points.
            If all points have the attribute value { \\"foo\\" : 1 } then the
            dictionary table will be just ({ \\"foo\\" : 1 },) and each point will
            store the index 0. When you set some points\' values to { \\"bar\\" : 2},
            Houdini adds sets the dictionary table to ({\\"foo\\":1}, {\\"bar\\":2}) and
            sets stores the index 1 in those points. When you set one of those
            points back to {\\"foo\\":1}, Houdini leaves the dictionary table
            unchanged and stores the index 0 in that point.

            When using dictionary attribute values, this implementation is
            hidden from you, and you get and set those attributes as
            dictionaries. This method is provided only in case you need access
            to the dictionary table.


        '''
    def indexPairPropertyTables(self) -> Tuple[IndexPairPropertyTable, ...]:
        """

        indexPairPropertyTables(self) -> tuple of hou.IndexPairPropertyTable

            Return the property tables for this attribute. If the attribute is
            not an index pair, returns an empty tuple.


        """
    def optionType(self, option_name: str) -> EnumValue:
        """

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
    def setOption(self, name: str, value: OptionMultiArgType, type_hint: EnumValue = ...) -> None:
        """

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See hou.Attrib.options
            for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
    def removeOption(self, name: str) -> None:
        """

        removeOption(self, name)

            Remove an entry in the dictionary of options. See hou.Attrib.options
            for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
    def dataId(self) -> AttribDataId:
        """

        dataId(self)

            Returns the data id that represents the contents of this attribute.


        """
    def incrementDataId(self) -> None:
        """

        incrementDataId(self)

            Increment the data id to indicate that the contents of this
            attribute has changed.


        """
    def defaultValue(self) -> AttribReturnType:
        """

        defaultValue(self) -> int or float or str or tuple

            Return the attribute's default value. Returns a single
            int/float/string for attributes of size 1 and a tuple of values for
            attributes with more than one component.

            This method is useful when duplicating an attribute. See
            hou.Geometry.addAttrib for an example.


        """
    def options(self) -> dict[str, OptionMultiReturnType]:
        """

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.Attrib.options, hou.Attrib.setOption and
            hou.Attrib.removeOption.


        """
    def option(self, option_name: str) -> OptionMultiReturnType: ...

class AttribDataId:
    """

    hou.AttribDataId

    Used for detecting when contents of geometry have changed

    Every geometry attribute contains a data id that is incremented whenever
    it is modified (by at least 1). To perform optimizations that depend on
    whether an attribute has changed, these data ids can be cached and then
    compared again to see if they match at some future point in time. If
    they do not match, then one should assume that the contents of the
    attribute is no longer the same as before.

    If two attributes have matching data id values, then you can assume that
    their contents are the same. To preserve data id values across geometry
    copies, set the clone_data_ids parameter on such methods to True.

    This is typically used in a SOP to optimize operations in conjunction
    with setting hou.SopNode.setManagesAttribDataIds to True.


    Note
        The values of data ids are only valid within the same session. They
        cannot be compared across sessions or different running Houdini
        processes.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Constructs an invalid data id. This can be used as a placeholder in
            a list of data id's for attributes that don't exist.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def isValid(self) -> bool:
        """

        isValid(self) -> bool

            Return True if this is a valid data id.


        """
    def vexAttribDataId(self) -> Tuple[int, ...]:
        """

        vexAttribDataId(self) -> tuple of int

            Return the same list of integers that the attribdataid() VEX
            function returns for this data id. This is provided for
            interoperability with VEX.


        """

class audio:
    """

    hou.audio

    Functions related to playing audio using Houdini's playbar.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def turnOffAudio() -> None:
        """

        turnOffAudio()

            Turn off the audio playback.


        """
    @staticmethod
    def useTimeLineMode() -> None:
        """

        useTimeLineMode()

            Put the Audio Panel into a scrub mode.

            When the Audio Panel is in the scrub (a.k.a. timeline) mode, Houdini
            will play the audio during the animation or when scrubbing the thumb
            in the playbar.


        """
    @staticmethod
    def useTimeSliceMode() -> None:
        """

        useTimeSliceMode()

            Put the Audio Panel into realtime (a.k.a. timeslice) mode.


        """
    @staticmethod
    def useTestMode() -> None:
        """

        useTestMode()

            Put the Audio Panel into a mode that tests the audio playback.

            When the Audio Panel is in the test mode, it will play the entire
            audio soundtrack. The test can be stopped and resumed with stop()
            and play() functions.

            The sound will not play when scrubbing the thumb in the playbar or
            when playing the animation in the playbar. The audio must be in
            either scrub or realtime mode for playing the sound during animation
            or scrubbing.


        """
    @staticmethod
    def setMono(on: bool) -> None:
        """

        setMono(on)

            Set whether the audio will play in mono or stereo mode.


        """
    @staticmethod
    def setVolumeTied(on: bool) -> None:
        """

        setVolumeTied(self, on)

            Set whether changing the volume of one channel affects the volume of
            the other channel. If so, both channels will have the same volume
            set.


        """
    @staticmethod
    def setMeter(on: bool) -> None:
        """

        setMeter(on)

            Ses whether the meter will show the volume levels during the audio
            playback.


        """
    @staticmethod
    def setLeftVolume(volume: float) -> None:
        """

        setLeftVolume(value)

            Set the volume for the left audio channel.


        """
    @staticmethod
    def setRightVolume(volume: float) -> None:
        """

        setRightVolume(value)

            Set the volume for the right channel.


        """
    @staticmethod
    def useChops() -> None:
        """

        useChops()

            Set the Audio Panel to use a CHOP node for the audio.


        """
    @staticmethod
    def useAudioFile() -> None:
        """

        useAudioFile()

            Set the Audio Panel to use a disk file for the audio.


        """
    @staticmethod
    def setChopPath(node_path: str) -> None:
        """

        setChopPath(path)

            Set the Audio Panel to play the sound inside a CHOP node. Houdini
            plays this sound during testing, animation or scrubbing. See also
            hou.audio.useChops.


            path
                A string containing the path to the CHOP node.


        """
    @staticmethod
    def setAudioFileName(file_name: str) -> None:
        """

        setAudioFileName(path)

            Set the Audio Panel to play the sound inside an audio file. Houdini
            plays this sound during testing, animation or scrubbing. See also
            hou.audio.useAudioFile.


        """
    @staticmethod
    def setAudioOffset(time_offset: float) -> None:
        """

        setAudioOffset(offset)

            Set the time offset of the sound to sync the audio. This offset,
            specified in seconds, will coincide with the audio frame. See also
            hou.audio.setAudioFrame.


        """
    @staticmethod
    def setAudioFrame(frame: float) -> None:
        """

        setAudioFrame(frame)

            Set the frame to sync the audio. The audio offset (in seconds) will
            coincide with this frame. See also hou.audio.setAudioOffset.


        """
    @staticmethod
    def setScrubRepeat(on: bool) -> None:
        """

        setScrubRepeat(on)

            Set whether the sound chunk is repeated during scrubbing. See also
            hou.audio.useTimeSliceMode.


        """
    @staticmethod
    def setScrubSustain(sustain: float) -> None:
        """

        setScrubSustain(value)

            Set the length of time the that the sound chunk is repeatedly played
            when scrubbing comes to a standstill on a particular single frame.
            In practice, when the value is zero, no sound will be played when
            scrubbing keeps hovering over one frame. But, when the value is non-
            zero, a small sound chunk will keep playing repeatedly with a
            specified frequency. See also hou.audio.useTimeSliceMode.


        """
    @staticmethod
    def setScrubRate(scrub_rate: float) -> None:
        """

        setScrubRate(value)

            This method is deprecated in favor of hou.audio.setScrubLength.

            When the sustain period is non-zero, the small chunk of the sound
            will be repeated with this frequency when the scrubbing comes to a
            standstill at a single frame. See also hou.audio.useTimeSliceMode.


        """
    @staticmethod
    def setScrubLength(scrub_length: float) -> None:
        """

        setScrubLength(value)

            When the sustain period is non-zero, the audio from this many frames
            will be repeated when the scrubbing comes to a standstill at a
            single frame. See also hou.audio.useTimeSliceMode.


        """
    @staticmethod
    def reverse() -> None:
        """

        reverse()

            When the Audio Panel is in the test mode, start playing the sound in
            reverse.


        """
    @staticmethod
    def stop() -> None:
        """

        stop()

            When the Audio Panel is in the test mode, stop the test playback if
            any audio is currently playing.


        """
    @staticmethod
    def play() -> None:
        """

        play()

            When the Audio Panel is in the test mode, start playing the Audio
            Panel's specified audio file or CHOP. See also
            hou.audio.setAudioFileName and hou.audio.setChopPath.


        """
    @staticmethod
    def setLooping(on: bool) -> None:
        """

        setLooping(on)

            When the Audio Panel is in the test mode, set whether the test
            should start playing from the beginning once the end is reached. See
            also hou.audio.setRewind.


        """
    @staticmethod
    def setRewind(on: bool) -> None:
        """

        setRewind(on)

            When the Audio Panel is in the test mode, set whether the sound
            should rewind to the beginning when the test is stopped. If not, on
            subsequent start, the sound will resume from the point at which it
            was previously stopped. See also hou.audio.setLooping.


        """

class Bookmark:
    """

    hou.Bookmark

    Represents a bookmark.

    You cannot instantiate this object directly. Call hou.anim.newBookmark
    instead.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of this bookmark.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Updates the name of the bookmark.


        """
    def startFrame(self) -> int:
        """

        startFrame(self) -> int

            Returns the start frame of this bookmark.


        """
    def setStartFrame(self, start: float) -> None:
        """

        setStartFrame(self, start_frame)

            Updates the start frame of the bookmark.


        """
    def endFrame(self) -> int:
        """

        endFrame(self) -> int

            Returns the end frame of this bookmark.


        """
    def setEndFrame(self, end: float) -> None:
        """

        setEndFrame(self, end_frame)

            Updates the end frame of the bookmark.


        """
    def comment(self) -> str:
        """

        comment(self) -> str

            Returns the comment of this bookmark.


        """
    def setComment(self, comment: str) -> None:
        """

        setComment(self, comment)

            Updates the comment of the bookmark.


        """
    def color(self) -> Color:
        """

        color(self) -> hou.Color

            Returns the color of this bookmark.


        """
    def setColor(self, color: Color) -> None:
        """

        setColor(self, color)

            Updates the color of the bookmark.

            The color parameter should be a hou.Color.


        """
    def visible(self) -> bool:
        """

        visible(self) -> bool

            Returns whether or not this bookmark is visible.


        """
    def setVisible(self, visible: bool) -> None:
        """

        setVisible(self, visible)

            Updates the visibility of the bookmark.


        """
    def sessionId(self) -> int:
        """

        sessionId(self) - int

            Returns the ID of the bookmark. Note that this is a per-session ID
            that is not guaranteed to be the same between different sessions.


        """
    def isTemporary(self) -> bool:
        """

        isTemporary(self) -> bool

            Returns whether or not this bookmark is marked as temporary.


        """
    def setTemporary(self, temporary: bool) -> None:
        """

        setTemporary(self, temporary)

            Marks this bookmark as temporary or not. Temporary bookmarks are not
            saved when exporting bookmarks, nor are they saved in the .hip file
            by default.

            See hou.anim.saveBookmarks.


        """
    def isEnabled(self) -> bool:
        """

        isEnabled(self) -> bool

            Returns whether or not this bookmark is enabled.


        """
    def enable(self, enabled: bool) -> None:
        """

        enable(self, enabled)

            Enable or disable this bookmark. Disabled bookmarks are greyed out
            on the playbar.


        """
    def setMetadata(self, key: str, value: Any, type_hint: EnumValue = ...) -> None:
        """

        setMetadata(self, key, value, type_hint = hou.fieldType.NoSuchField)

            Adds a metadata property to this bookmark.


            key
                The name of the metadata property to add.

            value
                The value to store as metadata.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value is too ambiguous to determine the type.


        """
    def metadata(self, key: str, default_value: Any = ...) -> Any:
        """

        metadata(self, key, default_value=None) -> Any

            Returns the metadata associated with the given key, or default_value
            if no such key exists in the metadata.


            key
                The name of the metadata property to return.

            default_value
                Value to return if no property with the given key exists in the
                metadata.


        """

class BoundingBox:
    """

    hou.BoundingBox

    An axis-aligned 3D rectangular region.

    For example, a bounding box might describe a piece of geometry's minimum
    and maximum values on each of the coordinate axes. See
    hou.Geometry.boundingBox for an example of a function that returns a
    bounding box.


    """
    thisown: Incomplete
    def __init__(self, bbox_or_xmin: float|BoundingBox = ..., ymin: float = ..., zmin: float = ..., xmax: float = ..., ymax: float = ..., zmax: float = ...) -> None:
        """

        __init__(self, xmin=0.0, ymin=0.0, zmin=0.0, xmax=0.0, ymax=0.0,
        zmax=0.0)

            Construct a new bounding box with the specified minimum and maximum
            bounds. Use hou.BoundingBox.setTo to change the position of an
            existing bounding box.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, bbox: BoundingBox, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, bbox, tolerance=0.00001) -> bool

            Returns whether this bounding box is equal to another, subject to
            numerical tolerances.


        """
    def almostEqual(self, bbox: BoundingBox, tolerance: float = 1e-05) -> bool: ...
    def __hash__(self) -> int: ...
    def __mul__(self, matrix4: Matrix4) -> BoundingBox:
        """

        __mul__(self, matrix4) -> BoundingBox

            Take this bounding box, transform it by the given matrix, compute
            the axis-aligned bounding box around this transformed box, and
            return it.


        """
    def isValid(self) -> bool:
        """

        isValid(self) -> bool

            Returns whether this bounding box is valid.


        """
    def setTo(self, tuple: Sequence[float]) -> None:
        """

        setTo(self, bounds_sequence)

            Given a sequence of (xmin, ymin, zmin, xmax, ymax, zmax) values, set
            the position of the bounding box.

            Raises hou.InvalidSize if the tuple does not contain six elements.


        """
    def minvec(self) -> Vector3:
        """

        minvec(self) -> hou.Vector3

            Return a vector describing the corner of the box with the smallest
            x, y, and z values.


        """
    def maxvec(self) -> Vector3:
        """

        maxvec(self) -> hou.Vector3

            Return a vector describing the corner of the box with the largest x,
            y, and z values.


        """
    def sizevec(self) -> Vector3:
        """

        sizevec(self) -> hou.Vector3

            Return a vector describing the size of the box in each of the x, y,
            and z axes.

            This method can be implemented as follows:

          > def sizevec(self):
          >     return self.maxvec() - self.minvec()

        """
    def center(self) -> Vector3:
        """

        center(self) -> hou.Vector3

            Return the position of the center of the bounding box.

            This method can be implemented as follows:

          > def sizevec(self):
          >     return (self.minvec() + self.maxvec()) * 0.5

        """
    def enlargeToContain(self, point_or_bbox: Sequence[float]|Vector3, BoundingBox) -> None:
        """

        enlargeToContain(self, point_or_bbox)

            Enlarge the bounding box to contain the given element. The element
            may be a sequence of 3 floats (such as a hou.Vector3) describing a
            position or another bounding box. If this box does not need to grow
            because it already completely contains the element, it won't be
            modified.


        """
    def contains(self, point: Sequence[float]) -> bool:
        """

        contains(self, point)

            Given a sequence of 3 floats (such as a hou.Vector3) describing a
            position, return whether the position is inside the box.


        """

class BoundingRect:
    """

    hou.BoundingRect

    An axis-aligned 2D rectangular region.

    A bounding rectangle can describe the size and location of a node in a
    network, or the visible area or a network editor pane.


    """
    thisown: Incomplete
    def __init__(self, brect_or_p1_or_xmin: BoundingRect|Vector2|float, p2_or_ymin: Vector2|float, xmax: float = ..., ymax: float = ...) -> None:
        """

        __init__(self, p1, p2)

            Construct a new bounding rectangle with the specified bounds
            expressed as two hou.Vector2s.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, rect: BoundingRect, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, rect, tolerance=0.00001) -> bool

            Returns whether this bounding rectangle is equal to another, subject
            to numerical tolerances.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> subrect = hou.BoundingRect(0.001, 0.001, 0.999, 1.001)
          > >>> unitrect.isAlmostEqual(subrect)
          > False
          > >>> unitrect.isAlmostEqual(subrect, 0.01)
          > True

        """
    def __hash__(self) -> int: ...
    def isValid(self) -> bool:
        """

        isValid(self) -> bool

            Returns whether this bounding rectangle is valid, indicating it has
            been initialized in any way.

          > >>> hou.BoundingRect().isValid()
          > False
          > >>> hou.BoundingRect(0, 0, 0, 0).isValid()
          > True
          > >>> hou.BoundingRect(0, 0, 0, 0).isValid()
          > True

        """
    def setTo(self, tuple: Sequence[float]) -> None:
        """

        setTo(self, bounds_sequence)

            Given a sequence of (xmin, ymin, xmax, ymax) values, set the
            position of the bounding rectangle.

            Raises hou.InvalidSize if the tuple does not contain four elements.


        """
    def translate(self, tuple: Sequence[float]) -> None:
        """

        translate(self, offset)

            Moves this rectangle by the amount specified in the two float tuple
            or hou.Vector2 passed as the offset parameter.

          > >>> rect = hou.BoundingRect(1, 1, 2, 2)
          > >>> rect.translate(hou.Vector2(1, -1))
          > >>> rect
          > <hou.BoundingRect [2, 0, 3, 1]>

        """
    def scale(self, tuple: Sequence[float]) -> None:
        """

        scale(self, scale)

            Scales this rectangle by the amount specified in the two float tuple
            or hou.Vector2 passed as the scale parameter. Note that scaling the
            rectangle by a negative value will result in an invlalid rectangle
            where the lower left corner is above or to the right of the upper
            right corner.

          > >>> rect = hou.BoundingRect(1, 1, 2, 2)
          > >>> rect.scale(hou.Vector2(2, 3))
          > >>> rect
          > <hou.BoundingRect [2, 3, 4, 6]>
          > >>> rect.scale((-1, -1))
          > >>> rect
          > <hou.BoundingRect [-2, -3, -4, -6]>
          > >>> rect.isValid()
          > False

        """
    def expand(self, tuple: Sequence[float]) -> None:
        """

        expand(self, offset)

            Moves the edges of the rectangle away from its center by the
            distances specified in the two float tuple or hou.Vector2 passed as
            the offset parameter. The offset is applied to both sides of the
            rectangle so actually changes the width and height of the rectangle
            by twice the passed in values.

            Negative values can be passed into the offset to shrink the
            rectangle, but shrinking the rectangle by more than its current size
            will result in an invliad rectangle.

          > >>> rect = hou.BoundingRect(1, 1, 2, 2)
          > >>> rect.expand((1, 1))
          > >>> rect
          > <hou.BoundingRect [0, 0, 3, 3]>
          > >>> rect.expand((0, -2))
          > >>> rect
          > <hou.BoundingRect [0, 2, 3, 1]>
          > >>> rect.isValid()
          > False

        """
    def min(self) -> Vector2:
        """

        min(self) -> hou.Vector2

            Return a vector describing the corner of the rectangle with the
            smallest x and y values.


        """
    def max(self) -> Vector2:
        """

        max(self) -> hou.Vector2

            Return a vector describing the corner of the rectangle with the
            largest x and y values.


        """
    def size(self) -> Vector2:
        """

        size(self) -> hou.Vector2

            Return a vector describing the size of the rectangle in each of the
            x and y axes.

            This method can be implemented as follows:

          > def size(self):
          >     return self.max() - self.min()

        """
    def center(self) -> Vector2:
        """

        center(self) -> hou.Vector2

            Return the position of the center of the bounding rectangle.

            This method can be implemented as follows:

          > def center(self):
          >     return (self.min() + self.max()) * 0.5

        """
    def getOffsetToAvoid(self, bounds: BoundingRect, direction: Optional[Vector2] = None) -> Vector2:
        """

        getOffsetToAvoid(self, bounds, direction = None) -> hou.Vector2

            Return a vector describing the minimum distance this rectangle must
            be translated to avoid any overlap with the bounds rectangle. If
            direction is provided as a hou.Vector2, it indicates the specific
            direction the returned offset should be. If the rectangles do not
            overlap, the result will be hou.Vector2(0.0, 0.0).

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> subrect = hou.BoundingRect(0.2, 0.4, 0.8, 0.6)
          > >>> unitrect.getOffsetToAvoid(subrect)
          > <hou.Vector2 [0, 0.6]>
          > >>> unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 0.0))
          > <hou.Vector2 [0.8, 0]>
          > >>> unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 1.0))
          > <hou.Vector2 [0.6, 0.6]>

        """
    def enlargeToContain(self, point_or_rect: Sequence[float]|Vector2|BoundingRect) -> None:
        """

        enlargeToContain(self, point_or_rect)

            Enlarge the bounding rectangle to contain the given element. The
            element may be a sequence of 2 floats (such as a hou.Vector2)
            describing a position or another bounding rectangle. If this
            rectangle does not need to grow because it already completely
            contains the element, it won't be modified.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.enlargeToContain((2, 0.5))
          > >>> unitrect
          > <hou.BoundingRect [0, 0, 2, 1]>
          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.enlargeToContain(hou.BoundingRect(0.5, 0.5, 2, 1.5))
          > >>> unitrect
          > <hou.BoundingRect [0, 0, 2, 1.5]>

        """
    def intersect(self, rect: BoundingRect) -> None:
        """

        intersect(self, rect)

            Given a hou.BoundingRect object, updates the rectangle in this
            object to be the region where the two rectangles overlap.

          > >>> rect = hou.BoundingRect(0, 0, 1, 1)
          > >>> rect.intersect(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
          > >>> rect
          > <hou.BoundingRect [0.5, 0.5, 1, 1]>

        """
    def intersects(self, rect: BoundingRect) -> bool:
        """

        intersects(self, rect) -> bool

            Given a hou.BoundingRect object, return whether that rectangle
            partially or fully overlaps the one described by this object.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
          > True
          > >>> unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
          > True
          > >>> unitrect.intersects(hou.BoundingRect(1.5, 1.5, 2.5, 2.5))
          > False

        """
    def contains(self, rect: BoundingRect) -> bool:
        """

        contains(self, rect) -> bool

            Given a hou.BoundingRect object, return whether that rectangle is
            inside the one described by this object.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
          > True
          > >>> unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
          > False

        """
    def closestPoint(self, point: Sequence[float]) -> Vector2:
        """

        closestPoint(self, point) -> hou.Vector2

            Given a sequence of 2 floats (such as a hou.Vector2) describing a
            position, return the position inside the rectangle that is closest
            to the provided point.

          > >>> unitrect = hou.BoundingRect(0, 0, 1, 1)
          > >>> unitrect.closestPoint((0.5, 0.5))
          > <hou.Vector2 [0.5, 0.5]>
          > >>> unitrect.closestPoint((100, 0.5))
          > <hou.Vector2 [1.0, 0.5]>
          > >>> unitrect.closestPoint((-10, -5))
          > <hou.Vector2 [0, 0]>

        """

class ButtonParmTemplate(ParmTemplate):
    """

    hou.ButtonParmTemplate

    Describes a parameter tuple containing a button.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, disable_when: str|None = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ...) -> None:
        """

        __init__(self, name, label, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={})

            Creates a new ButtonParmTemplate instance.

            Construct a new ButtonParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.


        """
    __swig_destroy__: Incomplete

class ChannelEditorPane(PaneTab):
    """

    hou.ChannelEditorPane

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def graph(self) -> Optional[ChannelGraph]:
        """

        graph(self) -> hou.ChannelGraph

            Return the channel graph for this pane.


        """
    def channelListSplitFraction(self) -> float:
        """

        channelListSplitFraction(self) -> double

            Return the width of the embedded channel list as fraction (0-1
            value) of the pane's width.


        """
    def setChannelListSplitFraction(self, split_fraction: float) -> None:
        """

        setChannelListSplitFraction(self, value)

            Set the width of the embedded channel list as fraction (0-1 value)
            of the pane's width.


        """
    def displayFilter(self) -> str:
        """

        displayFilter(self) -> string

            Return the filter pattern for which channels are displayed.


        """
    def setDisplayFilter(self, filter: str) -> None:
        """

        setDisplayFilter(self, filter)

            Set the filter pattern for which channels are displayed. The channel
            name is used to match against the pattern.


        """
    def editorMode(self) -> EnumValue:
        """

        editorMode(self) -> hou.channelEditorMode enum value

            Return the animation editor mode.


        """
    def setEditorMode(self, mode: EnumValue) -> None:
        """

        setEditorMode(self, mode)

            Set the animation editor mode.


        """
    def templateFilter(self) -> str:
        """

        templateFilter(self) -> string

            Return the filter pattern for which channels are templated.


        """
    def setTemplateFilter(self, filter: str) -> None:
        """

        setTemplateFilter(self, filter)

            Set the filter pattern for which channels are templated. The channel
            name is used to match against the pattern.


        """
    def colorsCallback(self) -> str:
        """

        colorsCallback(self) -> string

            Return the active channel colors callback name.


        """
    def setColorsCallback(self, cb: str) -> bool:
        """

        setColorsCallback(self, callback_name) -> bool

            Set the active channel colors callback name. If the callback name is
            invalid, the active callback will be reset to default. Return True
            if the callback was successfully changed. Return False if the
            callback name was invalid.


        """
    def unregisterColorsCallback(self, cb_class: str) -> bool:
        """

        unregisterColorsCallback(self, callback_name) -> bool

            Unregister a callback by name. It also resets the active callback if
            the callback to remove was the active one. Return True if the
            callback was successfully removed. Return False if the callback name
            was invalid.


        """
    def colorsCallbacks(self) -> Tuple[str, ...]:
        """

        colorsCallbacks(self) -> tuple of string

            Return the list of registered channel colors callback.


        """
    def registerColorsCallback(self, cb_class: str, callback: Any) -> bool:
        '''

        registerColorsCallback(self, callback_name, callback_object ) -> bool

            Registers a callback to generate custom channel colors based on the
            node and parameter names.


            callback_name
                A name for the custom color scheme. You can use this to remove
                the callback with the unregisterColorsCallback method.

            callback_object
                A Python object with a getChannelColor method. For example:

              > 
              > class MyChannelColors(object):
              >     def getChannelColor(self, node_path, channel_name):
              >         return 0, 0, 0

                The node argument is the path to the node (for example,
                /obj/table). The parm argument is the internal name of the
                channel (for example, tx). The method must return a 3-tuple
                representing normalized (0-1, not 0-255) red, green, and blue
                values. If the method returns (0, 0, 0) Houdini uses the default
                channel color.

            You should register the callback in a session-independent startup
            script. When you register the callback, Houdini will call it once
            with empty string arguments to make sure it returns a triple. Your
            getChannelColor() method needs to handle this case.

            The following example object uses the custom color tint of a node to
            color its channels:

          > 
          > import hou
          > 
          > class NodeColors:
          >     \'\'\'
          >     Use hue variants of a node\'s color for parameter names 
          >     ending in x, y or z.
          >     \'\'\'
          > 
          >     def getChannelColor(self, node_path, channel_name):
          >         # Handle the empty string case
          >         if not node_path:
          >             return 0, 0, 0
          > 
          >         # Get a Node object from the path
          >         n = hou.node(node_path)
          >         # Get the node\'s color as a hou.Color object
          >         color = n.color()
          >         # Get the color\'s HSV values as a triple
          >         hue, sat, val = n.color().hsv()
          > 
          >         # If the color is gray, use the default
          >         if not sat:
          >             return 0, 0, 0
          > 
          >         # Hue-shift the node color for X, Y, and Z channels:
          >         if channel_name.endswith(\\"x\\"):
          >             color.setHSV(hue - 50, sat * 2, val * 1.2)
          >         elif channel_name.endswith(\\"y\\"):
          >             color.setHSV(hue, sat * 2, val * 1.2)
          >         elif channel_name.endswith(\\"z\\"):
          >             color.setHSV(hue + 50, sat * 2, val * 1.2)
          > 
          >         # Return the color as normalized (r, g, b)
          >         return color.rgb()

        '''
    def channelList(self) -> Optional[ChannelList]: ...
    def setChannelList(self, l: ChannelList) -> None: ...
    def channelListPinned(self) -> bool: ...
    def setChannelListPinned(self, pinned: bool) -> None: ...
    def isAnimBarShown(self) -> bool:
        """

        isAnimBarShown(self) -> bool

            Return whether or not the Animation Toolbar is currently displayed.


        """
    def showAnimBar(self, show: bool) -> None:
        """

        showAnimBar(self, show: bool)

            Shows or hides the Animation Toolbar.


        """
    def animBar(self) -> Optional[AnimBar]:
        """

        animBar(self): -> hou.AnimBar

            Return a hou.AnimBar, which provides control over this Channel
            Editor's Animation Toolbar.


        """

class ChannelGraph:
    """

    hou.ChannelGraph

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def selectedKeyframes(self) -> dict[Parm, Tuple[BaseKeyframe,...]]:
        """

        selectedKeyframes(self) -> dictionary of (, tuple of hou.BaseKeyframe)
        pairs

            Returns a dictionary of (hou.Parm, keyframes) which are currently
            selected in the playbar. TIP: Here is an example of how to scale the
            selected key values by 2:

          > keyframes = hou.playbar.selectedKeyframes()
          > for parm in keyframes.keys():
          >     for key in keyframes[parm]:
          >         key.setValue(2 * key.value())
          >         parm.setKeyframe(key)

        """
    def selection(self) -> Tuple[ChannelGraphSelection, ...]:
        """

        selection(self) -> tuple of hou.ChannelGraphSelection

            Return a copy of the current channel graph selection.


        """
    def setSelection(self, s: Sequence[ChannelGraphSelection]) -> None:
        """

        setSelection(self, chan_graph_selections)

            Set the current channel graph selection to the given sequence of
            hou.ChannelGraphSelection objects.


        """

class ChannelList:
    """

    hou.ChannelList

    A copy of a list of channels from Channel List or Animation Editor.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        hou.ChannelList

        A copy of a list of channels from Channel List or Animation Editor.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def clear(self) -> None:
        """

        clear(self)

            Clears the channel list.


        """
    def parms(self) -> Tuple[Parm, ...]:
        """

        parms(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels in the channel
            list.


        """
    def selected(self) -> Tuple[Parm, ...]:
        """

        selected(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels selected in the
            channel list.


        """
    def deselected(self) -> Tuple[Parm, ...]:
        """

        deselected(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels deselected in the
            channel list.


        """
    def pinned(self) -> Tuple[Parm, ...]:
        """

        pinned(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels pinned in the
            channel list.


        """
    def unpinned(self) -> Tuple[Parm, ...]:
        """

        unpinned(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels unpinned in the
            channel list.


        """
    def selectedValue(self) -> Tuple[Parm, ...]:
        """

        selectedValue(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels with their value
            column selected in the channel list.


        """
    def deselectedValue(self) -> Tuple[Parm, ...]:
        """

        deselectedValue(self) -> tuple of hou.Parm

            Returns a tuple of hou.Parm with all the channels with their value
            column deselected in the channel list.


        """
    def addParm(self, parm: Parm, selected: bool = True, pinned: bool = False, valueselected: bool = False) -> None:
        """

        addParms(self, parms, selected, pinned, valueselected)

            Adds a list of parameters to the channel list setting selected,
            pinned and value selected flags.


            parms
                A tuple of hou.Parm.

            selected
                Select the channel, True by default.

            pinned
                Pin the channel, False by default.

            valueselected
                Select the value column of the channel, False by default.


        """
    def addPath(self, path: str, selected: bool = True, pinned: bool = False, valueselected: bool = False) -> None:
        """

        addPath(self, path, selected, pinned, valueselected)

            Adds a parameter to the channel list setting selected, pinned and
            value selected flags.


            path
                A full path string to a parameter.

            selected
                Select the channel, True by default.

            pinned
                Pin the channel, False by default.

            valueselected
                Select the value column of the channel, False by default.


        """
    def addParms(self, parms: Sequence[Parm], selected: bool = True, pinned: bool = False, valueselected: bool = False) -> None: ...
    def addPaths(self, paths: Sequence[str], selected: bool = True, pinned: bool = False, valueselected: bool = False) -> None:
        """

        addPaths(self, paths, selected, pinned, valueselected)

            Adds a list of parameters using full paths to the channel list
            setting selected, pinned and value selected flags.


            path
                A full path string to a parameter.

            selected
                Select the channel, True by default.

            pinned
                Pin the channel, False by default.

            valueselected
                Select the value column of the channel, False by default.


        """
    def remove(self, parm: Parm|Sequence[Parm]) -> None:
        """

        remove(self, parm)

            Remove a parameter or a list of parameters from the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def select(self, parm: Parm|Sequence[Parm]) -> None:
        """

        select(self, parm)

            Select a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def deselect(self, parm: Parm|Sequence[Parm]) -> None:
        """

        deselect(self, parm)

            Deselect a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def pin(self, parm: Parm|Sequence[Parm]) -> None:
        """

        pin(self, parm)

            Pin a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def unpin(self, parm: Parm|Sequence[Parm]) -> None:
        """

        unpin(self, parm)

            Unpin a parameter or a list of parameters in the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def selectValue(self, parm: Parm|Sequence[Parm]) -> None:
        """

        selectValue(self, parm)

            Select the value column of a parameter or a list of parameters in
            the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def deselectValue(self, parm: Parm|Sequence[Parm]) -> None:
        """

        deselectValue(self, parm)

            Deselect the value column of a parameter or a list of parameters in
            the channel list.


            parm
                A hou.Parm or tuple of hou.Parm.


        """
    def contains(self, parm: Parm) -> bool:
        """

        contains(self, parm) -> bool

            Returns True if the parameter is in the Channel List.


            parm
                A hou.Parm.


        """
    def isSelected(self, parm: Parm) -> bool:
        """

        isSelected(self, parm) -> bool

            Returns True if the parameter is selected in the Channel List.


            parm
                A hou.Parm.


        """
    def isPinned(self, parm: Parm) -> bool:
        """

        isPinned(self, parm) -> bool

            Returns True if the parameter is pinned in the Channel List.


            parm
                A hou.Parm.


        """
    def isValueSelected(self, parm: Parm) -> bool:
        """

        isValueSelected(self, parm) -> bool

            Returns True if the parameter has its value column selected in the
            Channel List.


            parm
                A hou.Parm.


        """
    def addNodeGeometryChannels(self, node: SopNode, pattern: str|None = ..., selected: bool = ..., pinned: bool = ..., valueselected: bool = ...) -> str:
        """

        addNodeGeometryChannels(self, node, pattern=None, selected=True,
        pinned=False, valueselected=False) -> str

            Adds a collection of geometry channels to the channel list,
            constructed from the channel primitives present in the provided
            node's geometry. Returns the name of the geometry channels
            collection, which will be the same as the node's path.


            node
                A hou.SopNode.

            pattern
                A pattern string, None by default. If provided, only channel
                primitives matching the pattern will be added to the collection.

            selected
                Select all channels in the collection, True by default.

            pinned
                Pin all channels in the collection, False by default.

            valueselected
                Select the value column of all channels in the collection, False
                by default.


        """
    def addGeometryChannels(self, geometry: Geometry, collection_name: str|None = ..., pattern: str|None = ..., selected: bool = ..., pinned: bool = ..., valueselected: bool = ...) -> str:
        '''

        addGeometryChannels(self, geometry, collection_name=None, pattern=None,
        selected=True, pinned=False, valueselected=False) -> str

            Adds a collection of geometry channels to the channel list,
            constructed from the channel primitives present in the provided
            geometry. Returns the name of the geometry channels collection. If
            no name is provided, a unique name will be created. Note that any
            modifications to the scoped channels are not immediately reflected
            in the channel primitives, but must be manually updated using
            hou.anim.mergeGeometryChannels.

            The following shows an example workflow of adding geometry channels
            to the channel list, listening for updates, and setting modified
            channels back in to channel primitives:

          > channel_list = hou.ChannelList()
          > collection_name = \\"test_collection\\"
          > # g is any hou.Geometry with channel primitives.
          > channel_list.addGeometryChannels(g, collection_name)
          > hou.playbar.setChannelList(channel_list)
          > 
          > # Mutable geometry in which to write modified channel primitives.
          > output_geometry = hou.Geometry()
          > 
          > def channels_changed(channel_names, collection_name):
          >     print(f\\"Channels in {collection_name} were modified: \\", channel_names)
          > 
          >     # Write the changed channels back in to channel primitives.
          >     hou.anim.mergeGeometryChannels(collection_name, output_geometry, channel_names)
          > 
          > # Called whenever geometry channels added to the channel list are modified,
          > # such as when they are edited in the Animation Editor.
          > hou.anim.addGeometryChannelsChangedCallback(collection_name, channels_changed)

            geometry
                A hou.Geometry

            collection_name
                An optional name for the geometry channels collection. If not
                provided, a unique name will be created. If a collection with
                the same name already exists, it will be overwritten.

            pattern
                A pattern string, None by default. If provided, only channel
                primitives matching the pattern will be added to the collection.

            selected
                Select all channels in the collection, True by default.

            pinned
                Pin all channels in the collection, False by default.

            valueselected
                Select the value column of all channels in the collection, False
                by default.

            See also:

          * hou.ChannelPrim

          * hou.anim.setGeometryChannels

          * hou.anim.mergeGeometryChannels

          * hou.anim.addGeometryChannelsChangedCallback

          * hou.anim.removeGeometryChannelsChangedCallback


        '''
    def geometryChannels(self, collection_name: str) -> Tuple[ChannelPrim, ...]:
        """

        geometryChannels(self, collection_name) -> tuple of hou.ChannelPrim

            Returns a tuple of channel primitives in a given geometry channels
            collection.


        """
    def geometryChannelCollectionNames(self) -> Tuple[str, ...]:
        """

        geometryChannelCollectionNames(self) -> tuple of str

            Returns a tuple of the names of geometry collections added to the
            channel list.


        """
    def removeGeometryChannels(self, collection_name: str) -> None:
        """

        removeGeometryChannels(self, collection_name=None)

            Removes the geometry channels collection with the provided name from
            the channel list.


            collection_name
                Name of the geometry channels collection to remove.


        """
    def selectGeometryChannel(self, collection_name: str, channel: str|None = ...) -> str:
        """

        selectGeometryChannel(self, collection_name, channel=None)

            Selects a geometry channel. If no channel is provided, selects all
            channels within the collection.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel to select. None by default.


        """
    def deselectGeometryChannel(self, collection_name: str, channel: str|None = ...) -> str:
        """

        deselectGeometryChannel(self, collection_name, channel=None)

            Deselects a geometry channel. If no channel is provided, deselects
            all channels within the collection.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel to deselect. None by default.


        """
    def pinGeometryChannel(self, collection_name: str, channel: str|None = ...) -> str:
        """

        pinGeometryChannel(self, collection_name, channel=None)

            Pins a geometry channel. If no channel is provided, pins all
            channels within the collection.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel to pin. None by default.


        """
    def unpinGeometryChannel(self, collection_name: str, channel: str|None = ...) -> str:
        """

        unpinGeometryChannel(self, collection_name, channel=None)

            Unpins a geometry channel. If no channel is provided, unpins all
            channels within the collection.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel to unpin. None by default.


        """
    def selectGeometryChannelValue(self, collection_name: str, channel: str|None = ...) -> str:
        """

        selectGeometryChannelValue(self, collection_name, channel=None)

            Selects the value column of a geometry channel. If no channel is
            provided, selects the values of all channels within the collection.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel to select. None by default.


        """
    def deselectGeometryChannelValue(self, collection_name: str, channel: str|None = ...) -> str: ...
    def containsGeometryChannel(self, collection_name: str, channel: str|None = ...) -> bool:
        """

        containsGeometryChannel(self, collection_name, channel=None) -> bool

            Returns whether or not a geometry channel is present in the channel
            list. If a channel name is not provided, returns whether or not the
            collection is present.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel. None by default.


        """
    def isGeometryChannelSelected(self, collection_name: str, channel: str) -> bool:
        """

        isGeometryChannelSelected(self, collection_name, channel) -> bool

            Returns whether or not a geometry channel is selected.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel.


        """
    def isGeometryChannelPinned(self, collection_name: str, channel: str) -> bool:
        """

        isGeometryChannelPinned(self, collection_name, channel) -> bool

            Returns whether or not a geometry channel is pinned.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel.


        """
    def isGeometryChannelValueSelected(self, collection_name: str, channel: str) -> bool:
        """

        isGeometryChannelValueSelected(self, collection_name, channel) -> bool

            Returns whether or not the value column of a geometry channel is
            selected.


            collection_name
                Name of the geometry channels collection.

            channel
                Name of the channel.


        """
    def filter(self) -> str:
        """

        filter(self) -> str

            Returns the channel list filter string.


        """
    def keepSelection(self) -> bool:
        """

        keepSelection(self) -> bool

            Returns the channel list Keep Selection flag.


        """
    def enableFilter(self) -> bool:
        """

        enableFilter(self) -> bool

            Returns True if the channel list filtering is active.


        """
    def filterTranslates(self) -> bool:
        """

        filterTranslates(self) -> bool

            Returns True if the channel list translations filtering is active.


        """
    def filterRotates(self) -> bool:
        """

        filterRotates(self) -> bool

            Returns True if the channel list rotations filtering is active.


        """
    def filterScales(self) -> bool:
        """

        filterScales(self) -> bool

            Returns True if the channel list scales filtering is active.


        """
    def setFilter(self, pattern: str) -> None:
        """

        setFilter(self,pattern)`

            Set the channel list filter string.


            pattern
                A pattern string.


        """
    def setKeepSelection(self, value: bool) -> None:
        """

        setKeepSelection(self,on)

            Set the channel list Keep Selection flag.


        """
    def setEnableFilter(self, value: bool) -> None:
        """

        setEnableFilter(self,on)

            Enable/Disable the channel list filtering.


        """
    def setFilterTranslates(self, value: bool) -> None:
        """

        setFilterTranslates(self,on)

            Enable/Disable channel list translations filtering.


        """
    def setFilterRotates(self, value: bool) -> None:
        """

        setFilterRotates(self,on)

            Enable/Disable channel list rotations filtering.


        """
    def setFilterScales(self, value: bool) -> None:
        """

        setFilterScales(self,on)

            Enable/Disable channel list scales filtering.


        """
    def asCode(self, var_name: str = ...) -> str:
        """

        asCode(self,var_name) -> str

            Returns a python code string that be run to recreate a ChannelList
            with the same content as the current object.


            var_name
                The variable name used in the generated code for the channel
                list. It defaults to chanlist.


        """

class ChannelPrim(Prim):
    """

    hou.ChannelPrim

    A ChannelPrim is a geometry primitive (Prim object) which stores channel
    data.

    Channel primitives are lightweight, standalone channels optimized for
    quick evaluation. The following example demonstrates how to construct,
    insert keys into, and evaluate a channel primitive:

    > # Create a mutable geometry
    > g = hou.Geometry()
    > # Add a new channel primitive to the geometry
    > chan = g.createChannelPrim()
    > 
    > keys = [24, 48, 72, 96]
    > values = [0.5, 1.0, 1.5, 2.0]
    > 
    > # Insert keys at the specified frames and set their values
    > for i in range(len(keys)):
    >     chan.insertKey(keys[i])
    >     chan.setKeyValue(keys[i], values[i])
    > 
    > # Smooth the slopes of all keys
    > chan.smoothAutoSlopes()
    > 
    > # Evaluate the channel at frame 36
    > value = chan.eval(36)

    Channel primitives can also be added to the global channel list in order
    to visualize and edit them on the playbar or animation editor. For an
    example of this, see hou.ChannelList.addGeometryChannels.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def vertex(self, index: int) -> Vertex:
        """

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
    def addVertex(self, point: Point) -> Vertex:
        """

        addVertex(self, point) -> hou.Vertex

            Creates a new vertex inside this channel primitive, adding it to the
            end of the vertex list. You would typically call this method from
            the code of a Python-defined SOP.

            point is a hou.Point object that the new vertex will refer to. See
            hou.Vertex for information on the relationship between points and
            vertices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also:

          * hou.Geometry.createPoint


        """
    def start(self) -> float:
        """

        start(self) -> float

            Returns the start frame of this channel primitive.


        """
    def end(self) -> float:
        """

        end(self) -> float

            Returns the end frame of this channel primitive.


        """
    def length(self) -> float:
        """

        length(self) -> float

            Returns the length in frames of this channel primitive.


        """
    def setStart(self, frame: float) -> None:
        """

        setStart(frame: float)

            Sets the start frame of this channel primitive.


        """
    def defaultValue(self) -> float:
        """

        defaultValue(self) -> float

            Returns the default value for this channel primitive, which is used
            when the channel is empty.


        """
    def setDefaultValue(self, value: float) -> None:
        """

        setDefaultValue(self, value: float)

            Sets the default value for this channel primitive.


        """
    def eval(self, frame: float) -> float:
        """

        eval(self, frame: float) -> float

            Evaluates the channel at the given frame, returning the result.


        """
    def hasKeyAtFrame(self, frame: float) -> bool:
        """

        hasKeyAtFrame(self, frame: float) -> bool

            Returns whether or not the channel has a key at the given frame.


        """
    def insertKey(self, frame: float, auto_slope: bool = True) -> None:
        """

        insertKey(self, frame: float, auto_slope = True)

            Inserts a key at the given frame, if there isn't one already. If the
            frame is outside the channel's current range, it will be extended
            accordingly.

            auto_slope determines whether slopes for this key are set
            automatically or manually.


        """
    def destroyKey(self, frame: float) -> None:
        """

        destroyKey(self, frame: float)

            Destroys a key at the given frame, if one exists.


        """
    def destroyKeys(self, frame_start: float, frame_end: float) -> None:
        """

        destroyKeys(self, frame_start: float, frame_end: float)

            Destroys all keys in the given time range, inclusive.


        """
    def clear(self) -> None:
        """

        clear(self)

            Clears the channel primitive, removing all keys and segments.


        """
    def keyIndex(self, frame: float) -> int:
        """

        keyIndex(self, frame: float) -> int

            Returns the index of the key at the given frame, or -1 if there is
            no key at that frame.


        """
    def setKeyValue(self, frame: float, value: float, key_half: Optional[EnumValue] = None) -> bool:
        """

        setKeyValue(self, frame: float, value: float, key_half =
        hou.keyHalf.InOut) -> bool

            Sets the value of the key at the given frame, if one exists. Returns
            False if no key exists at the given frame.

            key_half is a hou.keyHalf which defines the side of the key to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out will create a discontinuity at this key.


        """
    def setKeySlope(self, frame: float, slope: float, key_half: Optional[EnumValue] = None) -> bool:
        """

        setKeySlope(self, frame: float, slope: float, key_half =
        hou.keyHalf.InOut) -> bool

            Sets the slope of the key at the given frame. Returns False if no
            key exists at the given frame.

            key_half is a hou.keyHalf which defines the side of the key to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out will create a discontinuity in the slope at this
            key.


        """
    def setKeyAccel(self, frame: float, accel: float, key_half: Optional[EnumValue] = None) -> bool:
        """

        setKeyAccel(self, frame: float, accel: float, key_half =
        hou.keyHalf.InOut) -> bool

            Sets the acceleration of the key at the given frame, if one exists.
            Returns False if no key exists at the given frame.

            key_half is a hou.keyHalf which defines the side of the key to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out will create a discontinuity in the acceleration at
            this key.


        """
    def keyValue(self, frame: float, key_half: Optional[EnumValue] = None) -> float:
        """

        keyValue(self, frame: float, value: float, key_half = hou.keyHalf.Out)
        -> float

            Returns the value of the key at the given frame, if one exists.

            key_half is a hou.keyHalf which defines the side of the key to get.


        """
    def keySlope(self, frame: float, key_half: Optional[EnumValue] = None) -> float:
        """

        keySlope(self, frame: float, value: float, key_half = hou.keyHalf.Out)
        -> float

            Returns the slope of the key at the given frame, if one exists.

            key_half is a hou.keyHalf which defines the side of the key to get.


        """
    def keyAccel(self, frame: float, key_half: Optional[EnumValue] = None) -> float:
        """

        keyAccel(self, frame: float, value: float, key_half = hou.keyHalf.Out)
        -> float

            Returns the acceleration of the key at the given frame, if one
            exists.

            key_half is a hou.keyHalf which defines the side of the key to get.


        """
    def setKeyAutoSlope(self, frame: float, auto_slope: bool, key_half: Optional[EnumValue] = None) -> bool:
        """

        setKeyAutoSlope(self, frame: float, auto_slope: bool, key_half =
        hou.keyHalf.InOut) -> bool

            Sets the auto slope property of the key at the given frame, if one
            exists. Returns False if no key exists at the given frame.

            key_half is a hou.keyHalf which defines the side of the key to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out results in only the respective half of the key's
            slope being affected when hou.ChannelPrim.smoothAutoSlopes is
            called, which will create a discontinuity in the slope at this key.


        """
    def segmentType(self, frame: float) -> EnumValue:
        """

        segmentType(self, frame: float) -> hou.segmentType

            Returns the type of the segment at the given frame.


        """
    def setSegmentType(self, frame: float, type: EnumValue) -> None:
        """

        setSegmentType(self, frame: float, type)

            Sets the type of the segment at the given frame, where type is a
            hou.segmentType.


        """
    def keyFrames(self) -> Tuple[float, ...]:
        """

        keyFrames(self) -> tuple

            Returns an ordered list of frames at which keys exist in this
            channel.


        """
    def keyValues(self, key_half: Optional[EnumValue] = None) -> Tuple[float, ...]:
        """

        keyValues(self, key_half = hou.keyHalf.Out) -> tuple

            Returns a list of the values of each key (ordered by frame) in this
            channel.

            key_half is a hou.keyHalf which defines the side of the key to get.


        """
    def keySlopes(self, key_half: Optional[EnumValue] = None) -> Tuple[float, ...]:
        """

        keySlopes(self, key_half = hou.keyHalf.Out) -> tuple

            Returns a list of the slopes of each key (ordered by frame) in this
            channel.

            key_half is a hou.keyHalf which defines whether to get the out-slope
            or in-slope.


        """
    def keyAccels(self, key_half: Optional[EnumValue] = None) -> Tuple[float, ...]:
        """

        keyAccels(self, key_half = hou.keyHalf.Out) -> tuple

            Returns a list of the accelerations of each key (ordered by frame)
            in this channel.

            key_half is a hou.keyHalf which defines whether to get the out-
            acceleration or in-acceleration.


        """
    def setKeyValues(self, values: Sequence[float], key_half: Optional[EnumValue] = None) -> None:
        """

        setKeyValues(self, values: list[float], key_half = hou.keyHalf.InOut)

            Sets the values of each key in the channel.

            values is a list of floats which contains the values to set. Its
            length must match the channel's length as given by channel.length().

            key_half is a hou.keyHalf which defines the side of the keys to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out will create discontinuities at each key.


        """
    def setKeySlopes(self, slopes: Sequence[float], key_half: Optional[EnumValue] = None) -> None:
        """

        setKeySlopes(self, slopes: list[float], key_half = hou.keyHalf.InOut)

            Sets the slopes of each key in the channel.

            slopes is a list of floats which contains the slope values to set.
            Its length must match the channel's length as given by
            channel.length().

            key_half is a hou.keyHalf which defines the side of the keys to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out will create discontinuities in the slopes at each
            key.


        """
    def setKeyAccels(self, accels: Sequence[float], key_half: Optional[EnumValue] = None) -> None:
        """

        setKeyAccels(self, accels: list[float], key_half = hou.keyHalf.InOut)

            Sets the accelerations of each key in the channel.

            accels is a list of floats which contains the acceleration values to
            set. Its length must match the channel's length as given by
            channel.length().

            key_half is a hou.keyHalf which defines the side of the keys to set
            (in, out, or both). Setting this to hou.keyHalf.In or
            hou.keyHalf.Out will create discontinuities in the accelerations at
            each key.


        """
    def moveKeyframes(self, key_indices: Sequence[int], frame_offsets: Sequence[float]) -> None:
        """

        moveKeyframes(self, key_indices, frame_offsets)

            Shifts the keys at the given indices by the offsets, specified in
            frames.

            key_indices is a tuple of integers, each specifying an index of a
            key to move.

            frame_offsets is a tuple of numbers, specifying the offset to apply
            to each key. It must either be the same length as the key_indices
            tuple, or it must be a tuple of a single element, in which case all
            specified keys will be shifted by the same offset.


        """
    def smoothAutoSlopes(self, force: bool = False) -> None:
        """

        smoothAutoSlopes(self, force: bool = False)

            Smooths the slopes of any keys with the auto slope flag set to true.
            If the force parameter is set to True, smooths the slopes of all
            keys regardless of the auto slope flag.


        """
    def smoothAutoSlopesForKeys(self, start_index: int, end_index: int = -1, force: bool = False) -> None:
        """

        smoothAutoSlopesForKeys(self, start_index, end_index = -1, force: bool =
        False)

            Smooths the slopes of any keys in the given range which have the
            auto slope flag set to true. If the force parameter is set to True,
            smooths the slopes of all keys in the range regardless of the auto
            slope flag.

            start_index is the index at which to start smoothing auto slopes

            end_index is the index at which to stop smoothing slopes. If
            omitted, only the key at the start_index will be smoothed.


        """

class ChopNode(OpNode):
    """

    hou.ChopNode

    Class representing a CHOP node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns whether the node's bypass flag is on.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turn the node's bypass flag on or off, making this node have no
            effect.


        """
    def isLocked(self) -> bool:
        """

        isLocked(self) -> bool

            Returns whether this node's lock flag is on.


        """
    def setLocked(self, on: bool) -> None:
        """

        setLocked(self, on)

            Turn this node's lock flag on or off. Locking a node saves its
            current cooked channel data into the node. If you unlock a locked
            node, it will discard its locked channel data and recook, computing
            its channel data from its inputs and parameters.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Returns whether the node's display flag is on.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turns the node's display flag to on or off.


        """
    def isAudioFlagSet(self) -> bool:
        """

        isAudioFlagSet(self) -> bool

            Returns whether the node's audio flag is on.


        """
    def setAudioFlag(self, on: bool) -> None:
        """

        setAudioFlag(self, on)

            Turns the node's audio flag on or off.


        """
    def isExportFlagSet(self) -> bool:
        """

        isExportFlagSet(self) -> bool

            Returns whether the node's export flag is on.


        """
    def setExportFlag(self, on: bool) -> None:
        """

        setExportFlag(self, on)

            Turns the node's export flag to on or off.


        """
    def isUnloadFlagSet(self) -> bool:
        """

        isUnloadFlagSet(self) -> bool

            Returns whether the node's unload flag is on.


        """
    def setUnloadFlag(self, on: bool) -> None:
        """

        setUnloadFlag(self, on)

            Turns the node's unload flag to on or off.


        """
    def isCurrentFlagSet(self) -> bool:
        """

        isCurrentFlagSet(self) -> bool

            Returns whether the node's current flag is on.


        """
    def setCurrentFlag(self, on: bool) -> None:
        """

        setCurrentFlag(self, on)

            Turns the node's audio flag on or off.


        """
    def tracks(self, output_index: int = 0, cook: bool = True) -> Tuple[Track, ...]:
        """

        tracks(self) -> tuple of Tracks

            Returns a tuple of all the tracks in this node.


        """
    def track(self, track_name: str, output_index: int = 0, cook: bool = True) -> Optional[Track]:
        """

        track(self, track_name) -> hou.Track or None

            Return the track of the given name, or None if it doesn't exist.


        """
    def clip(self, output_index: int = 0) -> Clip:
        """

        clip(self, output_index=0) -> hou.Clip

            Returns the CHOP node's clip.


            output_index
                If the CHOP has multiple outputs, this specifies which output's
                clip is returned.


        """
    def sampleRate(self) -> float:
        """

        sampleRate(self) -> double

            Returns the sample rate used by this node in number of samples per
            second.


        """
    def sampleRange(self) -> Tuple[float, float]:
        """

        sampleRange(self) -> (start, end)

            Return a 2-tuple containing the start and end values of the sample
            range. The number of samples for each track in this node is start-
            end+1. Note that samples start from 0, not 1.


        """
    def frameToSamples(self, frame: float) -> float:
        """

        frameToSamples(self, frame) -> double

            Converts a value expressed as frames to a value expressed in
            samples.


        """
    def samplesToFrame(self, samples: float) -> float:
        """

        samplesToFrame(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            frames.


        """
    def timeToSamples(self, time: float) -> float:
        """

        timeToSamples(self, time) -> double

            Converts a value expressed in seconds to a value expressed in
            samples.


        """
    def samplesToTime(self, samples: float) -> float:
        """

        samplesToTime(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            seconds.


        """
    def clipData(self, binary: Any) -> bytes:
        """

        clipData(self, binary) -> str for Python 2, bytes for Python 3

            Returns the clip data for the CHOP node in ASCII or binary,
            depending on the value of the binary parameter.

            The returned clip data is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


        """
    def setClipData(self, source: bytes, binary: bool, offset: float = 0, rename: Optional[str] = None) -> None:
        """

        setClipData(self, data, binary)

            Sets the clip data for the CHOP node. Should only be called on
            locked nodes.


        """
    def saveClip(self, file_name: str) -> bool:
        """

        saveClip(self, file_name)

            Saves the node's output clip to a file. The filename extension
            determines the file format to use.


        """

class Clip:
    """

    hou.Clip

    Class representing an animation clip.

    RELATED

      * hou.ChopNode

      * hou.Track

      * hou.AgentClip


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__()

            Creates an empty clip.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def chopNode(self) -> Optional[ChopNode]:
        """

        chopNode(self) -> hou.ChopNode

            Returns the hou.ChopNode owner of this clip. This returns None if
            the clip is not owned by a CHOP.


        """
    def chopNodeOutputIndex(self) -> int:
        """

        chopNodeOutputIndex(self) -> int

            Returns the index of the CHOP node output that this clip corresponds
            to. This returns -1 if the clip is not owned by a CHOP.


        """
    def tracks(self) -> Tuple[Track, ...]:
        """

        tracks(self) -> tuple of hou.Track

            Returns a tuple of all the tracks in this clip.


        """
    def track(self, track_name: str) -> Optional[Track]:
        """

        track(self, track_name) -> hou.Track or None

            Returns the track of the given name, or None if it doesn't exist.


        """
    def sampleRate(self) -> float:
        """

        sampleRate(self) -> double

            Returns the sample rate used by this clip in number of samples per
            second.


        """
    def sampleRange(self) -> Tuple[float, float]:
        """

        sampleRange(self) -> (start, end)

            Return a 2-tuple containing the start and end values of the sample
            range. The number of samples for each track in this node is start-
            end+1. Note that samples start from 0, not 1.


        """
    def numSamples(self) -> int:
        """

        numSamples(self) -> int

            Return the number of samples in this clip.


        """
    def frameToSamples(self, frame: float) -> float:
        """

        frameToSamples(self, frame) -> double

            Converts a value expressed as frames to a value expressed in
            samples.


        """
    def samplesToFrame(self, samples: float) -> float:
        """

        samplesToFrame(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            frames.


        """
    def timeToSamples(self, time: float) -> float:
        """

        timeToSamples(self, time) -> double

            Converts a value expressed in seconds to a value expressed in
            samples.


        """
    def samplesToTime(self, samples: float) -> float:
        """

        samplesToTime(self, samples) -> double

            Converts a value expressed as samples to a value expressed in
            seconds.


        """
    def loadFromFile(self, filename: str) -> None:
        """

        loadFromFile(self, file_name)

            Loads the clip from a file, such as a .bclip.


        """
    def saveToFile(self, filename: str) -> None:
        """

        saveToFile(self, file_name)

            Saves the clip to a file. The filename extension determines the file
            format to use.


        """
    def mode(self) -> EnumValue:
        """

        mode(self) -> hou.clipMode

            Returns the CHOP evaluation mode that was used by the CHOP to
            produce the clip.


        """

class clone:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def runAsClone(start_port: int = 0, end_port: int = -1, debug: bool = False, block: bool = False, print_port: bool = False, connection_timeout_seconds: int = -1) -> None:
        """

        hou.clone.runAsClone

        Causes the current process to operate as a clone process.

        USAGE
          runAsClone(start_port=0, end_port=-1, debug=False, block=False,
          print_port=False, connection_timeout_seconds=-1)

        This method opens a network port to receive connections from a host
        process. Once connected, the host process sends its hip file contents
        and any changes made in the host process. This process maintains its
        network state to match the host process, and sends back rendered images
        to the host.

        Both graphical and non-graphical Houdini processes can act as clones.
        Using a graphical Houdini process as a clone may be useful for
        debugging, but generally clone processes will be non-graphical (hbatch
        or hython). Note that the synchronization if one way, from host to
        clones. Changes made in the clone process are not sent to the host
        process, and may cause issues with the synchronization of future changes
        from the host.

        Generally (except for debugging) it is easiest to run a clone process in
        a blocking mode where user input and interaction with the clone process
        is not permitted until the host process disconnects. This is controlled
        with the block parameter.


        start_port
            The lowest TCP/IP port number that can be opened for the host to
            establish a connection. The default value of 0 indicates that any
            available port can be used. In some renderfarm setups, only certain
            ports will allow a connection to be made from the host to the clone
            process. These restrictions will depend on the configuration of the
            firewall between the host and clone machines.

        end_port
            Highest TCP/IP port number that can be opened to receive the host
            connection. The default value of -1 allows any port number higher
            than the start_port.

        debug
            Sets the clone process' networking debug mode. Setting this to True
            will cause additional logging of networking events.

        block
            Controls whether user interation with this process should be
            blocked. This block lasts as long as a host process is connected to
            this clone (or the connection timeout expires without any host
            connection being established).

        print_port
            Set this to True to have this process output its port number to the
            standard output stream. The output will be of the form
            HOUDINI_CLONE_PORT=12345. The printing of this port is often
            necessary for the host process (which often launches the clone
            process) to know what port number it can use to connect to the clone
            process. The only other way to know the clone's port number is by
            setting the start_port and end_port parameters to the same fixed
            value.

        connection_timeout_seconds
            Indicates how long this method should wait for a host connection to
            be established before giving up and closing the connection port.
            This setting can help prevent zombie processes on a render farm, but
            be sure to allocate enough time for the host process to establish
            communication with the clone.


        """
    @staticmethod
    def isRunningAsClone() -> bool:
        """

        hou.clone.isRunningAsClone

        Return whether the current process is operating as a clone process.

        USAGE
          isRunningAsClone()

        Returns True if hou.clone.runAsClone has been called in this process,
        and the clone has not yet been shut down.


        """
    @staticmethod
    def createClone(id: Optional[str] = None) -> _clone_Connection:
        """

        hou.clone.createClone

        Creates a new hou.clone.Connection object.

        USAGE
          createClone(cloneid=None)

        Creates and returns a new default hou.clone.Connection object with the
        provided unique identifier. Note that this does not start a new clone
        process or establish a connection. It simply creates the connection
        object so that it can be configured and connected later. The
        hou.clone.Connection.duplicate method can also be used to create a new
        connection object.


        cloneid
            The unique identifier for the new clone connection. If this value is
            None or an empty string, a unique identifier is created
            automatically. If a clone with the provided identifier already
            exists, the provided identifier increments a numeric suffix until
            the identifier does not match any existing connectino object.


        """
    @staticmethod
    def clones() -> Tuple[_clone_Connection, ...]:
        """

        hou.clone.clones

        Return a tuple of all hou.clone.Connection objects.

        USAGE
          clones()

        Use this method to get access to all hou.clone.Connection objects that
        currently exist. To more efficiently look up a specific connection
        object, use hou.clone.clone instead.


        """
    @staticmethod
    def clone(id: str) -> Optional[_clone_Connection]:
        """

        hou.clone.clone

        Return a specific hou.clone.Connection object.

        USAGE
          clone(cloneid)

        Every hou.clone.Connection object has a unique identifier associated
        with it (see hou.clone.Connection.sessionId). This method returns the
        connection object that corresponds to the provided unique identifier.


        cloneid
            The unique identifier of the clone object that should be returned.
            If the provided identifier does not correspond to an existing
            hou.clone.Connection object, this method returns None.


        """
    @staticmethod
    def deleteClone(id: str) -> None:
        """

        hou.clone.deleteClone

        Deletes a hou.clone.Connection.

        USAGE
          deleteClone(cloneid)

        Disconnects and deletes an existing hou.clone.Connection object. This is
        different from simply disconnecting a clone using
        hou.clone.Connection.disconnect, after which the connection object still
        exists and can be reconnected. After calling this method, the provided
        clone identifier ceases to be valid,


        cloneid
            The unique identifier of the clone conenction object to delete. If
            the provided clone identifier doesn't correspond to an existing
            clone, this method does nothing.


        """
    @staticmethod
    def deleteDisconnectedClones() -> None:
        """

        hou.clone.deleteDisconnectedClones

        Deletes all disconnected hou.clone.Connection.

        USAGE
          deleteDisconnectedClones()

        This method is a shortcut for calling hou.clone.clones, checking the
        connection status of each clone, and calling for every clone that is not
        currently connected.


        """
    @staticmethod
    def removeAllConnectionChangeCallbacks() -> None:
        """

        hou.clone.removeAllConnectionChangeCallbacks

        Deregister all connection change callback methods.

        USAGE
          removeAllConnectionChangeCallbacks()

        This method is a shortcut for calling
        hou.clone.connectionChangeCallbacks and calling
        hou.clone.removeConnectionChangeCallback for each returned callback
        method.


        """
    @staticmethod
    def removeAllImageChangeCallbacks() -> None:
        """

        hou.clone.removeAllImageChangeCallbacks

        Deregister all image change callback methods.

        USAGE
          removeAllImageChangeCallbacks()

        This method is a shortcut for calling hou.clone.imageChangeCallbacks and
        calling hou.clone.removeImageChangeCallback for each returned callback
        method.


        """
    @staticmethod
    def addConnectionChangeCallback(callback: Callable[[str], None]) -> None:
        """

        hou.clone.addConnectionChangeCallback

        Registers a callback method to be run any time a hou.clone.Connection is
        modified.

        USAGE
          addConnectionChangeCallback(callback)

        This method allows code to monitor clone connections for creation,
        removal, and changes of configuration or state. To monitor changes to
        incoming rendered images, the hou.clone.addImageChangeCallback method
        must be used.


        callback
            The function that is invoked when a connection object changes. This
            method should accept a single cloneid parameter, which is the unique
            identifier of the clone object that has changed. Because this
            callback can indicate the destruction of a clone object, be aware
            that calling hou.clone.clone with this cloneid value may return
            None.


        """
    @staticmethod
    def removeConnectionChangeCallback(callback: Callable[[str], None]) -> None:
        """

        hou.clone.removeConnectionChangeCallback

        Deregisters a specific connection change callback method.

        USAGE
          removeConnectionChangeCallback(callback)

        Removes the provided callback from the list of methods that are run when
        a clone connection's state changes. This is the opposite of the
        hou.clone.addConnectionChangeCallback method.


        callback
            The callback method that should be deregistered. If this callback is
            not curently registered, this method raises a hou.OperationFailed
            exception.


        """
    @staticmethod
    def connectionChangeCallbacks() -> Tuple[Callable[[str], None],...]:
        """

        hou.clone.connectionChangeCallbacks

        Return a tuple of all registered connection change callbacks.

        USAGE
          connectionChangeCallbacks()

        Provides access to every callback method registered with the
        hou.clone.addConnectionChangeCallback method.


        """
    @staticmethod
    def addImageChangeCallback(callback: Callable[[str], None]) -> None:
        """

        hou.clone.addImageChangeCallback

        Registers a callback method to be run any time a hou.clone.Connection
        receives a new image.

        USAGE
          addImageChangeCallback(callback)

        This method allows code to monitor clone connections for changes to the
        any clone's rendered image. To monitor changes to the connection state,
        use hou.clone.addConnectionChangeCallback.


        callback
            The function that is invoked when a clone's rendered image is
            updated. This method should accept a single cloneid parameter, which
            is the unique identifier of the clone object whose image has
            changed.


        """
    @staticmethod
    def removeImageChangeCallback(callback: Callable[[str], None]) -> None:
        """

        hou.clone.removeImageChangeCallback

        Deregisters a specific image change callback method.

        USAGE
          removeImageChangeCallback(callback)

        Removes the provided callback from the list of methods that are run when
        a clone connection's rendered image changes. This is the opposite of the
        hou.clone.addImageChangeCallback method.


        callback
            The callback method that should be deregistered. If this callback is
            not curently registered, this method raises a hou.OperationFailed
            exception.


        """
    @staticmethod
    def imageChangeCallbacks() -> Tuple[Callable[[str], None],...]:
        """

        hou.clone.imageChangeCallbacks

        Return a tuple of all registered image change callbacks.

        USAGE
          imageChangeCallbacks()

        Provides access to every callback method registered with the
        hou.clone.addImageChangeCallback method.


        """

class _clone_Connection:
    """

    hou.clone.Connection

    Represents a connection to a clone process.

    These objects represent an active or potential connection to a Houdini
    clone process, either on the local machine or a remote machine. A
    connection can be connected and disconnected repeatedly, but the object
    continues to be valid. As with hou.Node objects, objects of thie type
    are references to the underlying connection object owned by the Houdini
    cloning framework. This means that all instances of this class that
    refer to the same underlying clone connection will affect each other.
    The underlying object can even be deleted in which case almost all
    methods on this object will raise exceptions (though the
    hou.clone.Connection.isValid method can be used to test if the
    underlying object still exists without raising an exception).

    Clone connections are identified by a unique session id string which
    behaves much like a Houdini node name. At any given time, the session id
    for each clone connection is unique. But session ids can be reused if a
    connection is deleted and a new one created. Clones connections are
    saved to the hip file, and are automatically disconnected when Huodini
    is shut down or a new hip file is opened. When opening a hip file, the
    loaded connection objects are always left in a disconnected state, and
    must be explicitly connected to start the clones processes.

    New connections can only be created by calling hou.clone.createClone or
    hou.clone.Connection.duplicate. Existing connection can be accessed
    using hou.clone.clone or hou.clone.clones.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isValid(self) -> bool:
        """

        isValid() -> bool

            Return True if the connection associated with this object is still
            valid. Valid simply means that the underlying connection has not
            been deleted. This method and hou.clone.Connection.sessionId are the
            only methods that will not raise an exception when run after the
            underlying connection has been deleted.


        """
    def sessionId(self) -> str:
        """

        sessionId() -> str

            Return the unique string that can be used to identify this
            connection object, or fetch it from the cloning framework using the
            hou.clone.clone method. This value is set when constructing the
            connection and cannot be changed. This value has limitations like
            those for node names.


        """
    def name(self) -> str:
        """

        name() -> str

            Return the user-facing name for this clone.


        """
    def setName(self, name: str) -> None:
        """

        setName(name)

            Checng the user-facing name for this clone. This is the name shown
            in the Clone control pane, and does not have any restrictions on its
            value (spaces and punctuation are allowed).


        """
    def lopNode(self) -> Node:
        """

        lopNode() -> hou.LopNode

            Return the LOP node that defines the stage which will be rendered by
            this clone.


        """
    def setLopNode(self, lop: Node) -> None:
        """

        setLopNode(lop)

            Set the LOP node that defines the stage which will be rendered by
            this clone. This value must be set for the clone to generate an
            image.


        """
    def cameraPath(self) -> str:
        """

        cameraPath() -> str

            Return the USD primitive path of the camera prim that defines the
            view that will be rendered by this clone.


        """
    def setCameraPath(self, camerapath: str) -> None:
        """

        setCameraPath(camerapath)

            Set the USD primitive path of the camera prim that defines the view
            that will be rendered by this clone. This path should point to a USD
            Camera primitive on the stage defined by the
            hou.clone.Connection.lopNode. This value must be set for the clone
            to generate an image.


        """
    def renderer(self) -> str:
        """

        renderer() -> str

            Return the name of the Render Delegate this clone will use.


        """
    def setRenderer(self, renderer: str) -> None:
        """

        setRenderer(renderer)

            Set the name of the Render Delegate this clone will use. This can be
            the internal name or label of any render delegate installed on the
            computer running this clone.


        """
    def renderSettings(self) -> str:
        """

        renderSettings() -> str

            Return the USD primitive path of the render settings prim that
            controls the rendering configurations for this clone.


        """
    def setRenderSettings(self, rendersettings: str) -> None:
        """

        setRenderSettings(rendersettings)

            Set the USD primitive path of the render settings prim that controls
            the rendering configurations for this clone. This path should point
            to a USD Render Settings primitive on the stage defined by the
            hou.clone.Connection.lopNode.


        """
    def renderPass(self) -> str:
        """

        renderPass() -> str

            Return the USD primitive path of the render pass prim, which
            controls the pass overrides applied to this clone.


        """
    def setRenderPass(self, renderpass: str) -> None:
        """

        setRenderPass(renderpass)

            Set the USD primitive path of the render pass prim, which controls
            the pass overrides applied to this render. This path should point to
            a USD Render Pass primitive on the stage defined by the
            hou.clone.Connection.lopNode.


        """
    def availableAovs(self) -> Tuple[str, ...]:
        """

        availableAovs(self) -> tuple of str

            Return the names of all AOVs generated by the clone render. This
            will return an empty tuple if the clone has not yet returned an
            image.


        """
    def displayAov(self) -> str:
        """

        displayAov(self) -> str

            Return the name of the AOV this clone should return to the host.
            This string may contain wildcards in which case multiple matching
            AOVs may be returned.


        """
    def setDisplayAov(self, displayaov: str) -> None:
        """

        setDisplayAov(self, aov)

            Set the name of the AOV this clone should return to the host. A
            string matching pattern can be specified to return multiple AOVs.
            Passing an empty string or None for the aov parameter instructs the
            clone to return all AOVs.


        """
    def resolutionScale(self) -> float:
        """

        resolutionScale(self) -> float

            Return the override resolution scale factor. This scaling is applied
            to the resolution set on the render settings for this clone. A value
            of 0 indicates that the render settings resolution will be used. A
            non-zero resolution scale value takes precedence over an override
            resolution explicitly set using setResolution.


        """
    def setResolutionScale(self, resolution_scale: float) -> None:
        """

        setResolutionScale(self, resolution_scale)

            Set the resolution scale for the image generated by this clone. This
            scale value is always applied to the resolution set on the render
            settings primitive. The value can be less than one to render a lower
            resolution image, or greater than one to render a higher resolution
            image. A value of 0 disables the resolution scaling.


        """
    def resolution(self) -> Tuple[int, int]:
        """

        resolution(self) -> (int, int)

            Return the override resolution set for the clone's returned image.
            If no override resolution has been set, this method returns (0, 0).
            In this case, the clone will generate an image with a resolution
            determined by the render settings primitive. A non-zero resolution
            scale value takes precedence over an override resolution explicitly
            set using setResolution, but the resolution scale setting does not
            affect the value returned by this method.


        """
    def setResolution(self, width: int, height: int) -> None:
        """

        setResolution(self, width, height)

            Set the resolution of the image generated by this clone. Specifying
            a width and height of 0 instructs the clone to generate an image
            with a resolution determined by the render settings primitive. A
            non-zero resolution scale value set with setResolutionScale takes
            precedence over an override resolution explicitly set using this
            method.


        """
    def renderRegion(self) -> Vector4:
        """

        renderRegion(self) -> hou.Vector4

            Return the render region set for the clone's returned image. If no
            override region has been set, this method returns (0.0, 0.0, 0.0,
            0.0). In this case, the clone will generate an image using the data
            window specified on the render settings prim or, if no such value
            has been authored, a full frame (i.e., (0.0, 0.0, 1.0, 1.0)).


        """
    def setRenderRegion(self, render_region: Vector4) -> None:
        """

        setRenderRegion(self, render_region)

            Set the render region of the image generated by this clone, where
            render_region is of the form (x0, y0, x1, y1). Specifying a region
            of (0.0, 0.0, 0.0, 0.0) instructs the clone to generate an image
            using the data window specified on the render settings prim or, if
            no such value has been authored, a full frame (i.e., (0.0, 0.0, 1.0,
            1.0)).


        """
    def frameExpression(self) -> str:
        """

        frameExpression(self) -> str

            Return a string specifying the expression that is run to generate
            the frame to which this clone should be set when cooking. If the
            returned string is empty, the frame number used by the clone will
            match the host's current frame number.


        """
    def setFrameExpression(self, expression: str) -> None:
        """

        setFrameExpression(self, expression)

            Set the expression that is run to generate the frame to which this
            clone should be set when cooking. The expression must always be a
            string, but can be any hscript expression that returns a number. For
            example, $F + 10 instructs the clone to cook ten frames ahead of the
            host's current frame. The expression is run in the host process, and
            the resulting value is sent to the clone.


        """
    def contextOptionExpression(self, opt: str) -> str:
        """

        contextOptionExpression(self, opt) -> str

            Return a string specifying the expression that is run to generate
            the value for the context option opt that this clone will use when
            cooking. If the returned string is empty, the context option value
            used by the clone will match the host's value for this option.


        """
    def setContextOptionExpression(self, opt: str, expression: str) -> None:
        """

        setContextOptionExpression(self, opt, expression)

            Set the expression that is run to generate the value for the context
            option opt that this clone uses when cooking. The expression must
            always be a string, but can be any hscript expression that returns a
            number or string. For example, $SHOT + 1 instructs the clone to cook
            with a value for SHOT that is one more than the host's value for
            this option. The expression is run in the host process, and the
            resulting value is sent to the clone.


        """
    def contextOptionsWithExpressions(self) -> Tuple[str, ...]:
        """

        contextOptionsWithExpressions(self) -> str

            Return a tuple of context option names that have expressions set for
            this clone, and thus where the clone's value for these context
            options may differ from the host process.


        """
    def processUpdates(self) -> bool:
        """

        processUpdates(self) -> bool

            Return a boolean value indicating whether the clone will restart its
            render in response to updates from the host.


        """
    def setProcessUpdates(self, process_updates: bool) -> None:
        """

        setProcessUpdates(self, process_updates)

            Configure the clone process to ignore updates from the host process,
            and continue rendering whatever stage is currently being rendered.


        """
    def launcherConfig(self) -> dict[str, Any]:
        """

        launcherConfig(self) -> dict

            Return a dictionary of configuration options that control the
            launcher plugin when starting up this clone process.


        """
    def setLauncherConfig(self, config: dict[str, Any]) -> None:
        """

        setLauncherConfig(self, config)

            Store the dictionary of launcher configuration options that should
            be used when launching this clone process. The contents and
            interpretation of this dictionary is under the discretion of the
            launcher plugin. It is stored with the clone connection object for
            convenience since launching a clone process is generally a pre-
            requisite to connecting to the clone.


        """
    def connect(self, host: str, port: int) -> bool:
        """

        connect(self, host, port) -> bool

            Connect this host to a running clone process on the specified host
            machine accessible through the provided TCP/IP port number. The
            connection attempt lasts for one second. If the connection is made,
            this method returns True. Returns False if the connection cannot be
            made for any reason. The host and port values are generally provided
            by the launcher plugin, which starts the clone process and reads the
            output from the process to determine the port number (which is
            output by the hou.clone.runAsClone method.


        """
    def disconnect(self) -> None:
        """

        disconnect(self)

            Disconnects from a connected clone process. Does nothing if the
            clone is not currently connected.


        """
    def isConnected(self) -> bool:
        """

        isConnected(self) -> bool

            Return true if this clone connection object represents an active
            connection to a clone process.


        """
    def isWaitingToConnect(self) -> bool:
        """

        isWaitingToConnect(self) -> bool

            Return true if setWaitingToConnect(True) has been called on this
            connection.


        """
    def setWaitingToConnect(self, waiting_to_connect: bool) -> None:
        """

        setWaitingToConnect(self, waiting_to_connect)

            Sets a flag on this connection indicating that it is waiting to
            connect to a clone process. This flag is only used as a visual hint
            and does not affect the operation of the clone framework. This flag
            can be set whether the clone is connected or disconnected. Only
            launcher plugins should set this flag, and only while waiting for a
            clone process to initialize or for a connection to be made to the
            clone process. Calling disconnect will also set this flag to False.


        """
    def host(self) -> str:
        """

        host(self) -> str

            Return the name of the host machine on which the connected clone
            process is running. Returns an empty string if there is no connected
            clone process.


        """
    def port(self) -> int:
        """

        port(self) -> int

            Return the port number used to connect to this object's clone
            process. Returns 0 if there is no connected clone process.


        """
    def imagePath(self) -> str:
        """

        imagePath(self) -> str

            Returns a string that can be used to access the image most recently
            returned by this clone. This string generally does not change when
            new images are sent from the clone, but this is not guaranteed. The
            format of this string will be of the form membuf:XXXXX. This unusual
            path value indicates that the image is not written to disk, but
            instead exists only as a block of memory. But Houdini nodes and HOM
            methods which can load images from disk will also be able to load
            the rendered image using this membuf path.


        """
    def imageVersion(self) -> int:
        """

        imageVersion(self) -> int

            A number that is increased every time a new image is sent to the
            host by this clone. This number can be used to detect when the image
            needs to be reloaded, redrawn, or otherwise re-processed to account
            for the updated image.


        """
    def imageSize(self) -> Tuple[int, ...]:
        """

        imageSize(self) -> tuple of int

            Returns a tuple of two integers that are the width and height of the
            image most recently returned by this clone. Note that the image size
            may change any time a new image is sent to the host if the
            resolution parameters or render settings primitive has changed.
            Becuase this is the true size of the most recently sent image, this
            value may differ from the resolution requested from this clone
            through the setResolution method.


        """
    def percentComplete(self) -> float:
        """

        percentComplete(self) -> float

            Indicates the progress of the render as reported through the render
            statistics.


        """
    def renderGalleryDataSource(self) -> Optional[AssetGalleryDataSource]:
        """

        renderGalleryDataSource(self) -> hou.AssetGalleryDataSource

            If this clone is currently connected and rendering, the resulting
            images are placed into the snapshot gallery for the target LOP
            Network. This method returns a hou.AssetGalleryDataSource that
            provides access to the snapshot gallery database in which the image
            metadata is stored. If this clone is not connected or has not
            generated any image data yet, this method returns None.


        """
    def renderGalleryItemId(self) -> str:
        """

        renderGalleryItemId(self) -> str

            If this clone is currently connected and rendering, the resulting
            images are placed into the snapshot gallery for the target LOP
            Network. This method returns the unique identifier of this image's
            entry in the snapshot gallery database. This identifier can be
            passed to the hou.AssetGalleryDataSource object returned by the
            renderGalleryDataSource method to look up additional information
            about the image. If this clone is not connected or has not generated
            any image data yet, this method returns an empty string.


        """
    def createSnapshot(self) -> str:
        """

        createSnapshot(self) -> str

            If this clone is currently connected and rendering, this method
            creates a snapshot in the LOP Network's snapshot gallery database,
            along with the current state of the LOP Network's nodes, just as
            when hitting the snapshot button to save the current viewport
            contents. The snapshot will contain all AOVs currently being sent
            from the clone process. Returns the snapshot gallery item identifier
            of the newly created snapshot. Returns an empty string if no
            snapshot could be created, or the clone is not connected or doesn't
            have image data avilable.


        """
    def duplicate(self) -> _clone_Connection:
        """

        duplicate(self) -> hou.clone.Connection

            Makes a copy of this clone object. All the settings and
            configuration information is duplicated. The new clone does not
            launch or connect to a new clone process even if this clone
            connection is currently active. This must be done explicitly, after
            creating the duplicate.


        """

class Color:
    """

    hou.Color

    Represents a color value.

    You can get and set the internal values using different color
    representations such as RGB and L*a*b*.

    Note that the constructor takes a single tuple of RGB values, not three
    arguments. So, for example, to create red you would say:

    > red = hou.Color((1.0, 0, 0))

    You can set the color in one color space and get the color in a
    different color space to convert between spaces.

    See HSL and HSV, Lab color space, CIE 1931 color space, and Color
    temperature for an introduction to the concepts the methods are based
    on.


    """
    thisown: Incomplete
    def __init__(self, rgb_tuple: Sequence[float]|float = ..., g: float = ..., b: float = ...) -> None:
        """

        __init__(self, rgb_tuple=(0.0, 0.0, 0.0)) -> Color

            Creates a color object, optionally from RGB values.

            To construct a color using a different representation, first create
            the object and then use a set method:

          > c = hou.Color()
          > c.setHSV(180, 0.5, 1.0)

        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def rgb(self) -> Tuple[float, float, float]:
        """

        rgb(self) -> (float, float, float)

            Returns the color as a tuple of (red, green, blue) floating point
            values, where each value is in the range 0.0 to 1.0.


        """
    def hsv(self) -> Tuple[float, float, float]:
        """

        hsv(self) -> (float, float, float)

            Returns the color as a tuple of (hue, saturation, value), where hue
            is 0 - 360, and saturation and value are 0.0 - 1.0.


        """
    def hsl(self) -> Tuple[float, float, float]:
        """

        hsl(self) -> (float, float, float)

            Returns the color as a tuple of (hue, saturation, lightness), where
            hue is 0 - 360, and saturation and lightness are 0.0 - 1.0.


        """
    def xyz(self) -> Tuple[float, float, float]:
        """

        xyz(self) -> (float, float, float)

            Returns the color as a tuple of (x, y, z) tristimulus values, where
            each component is 0.0 to 1.0 (but may go out of bounds from
            conversion).


        """
    def lab(self) -> Tuple[float, float, float]:
        """

        lab(self) -> (float, float, float)

            Returns the color as a tuple of (L, a, b) as defined in the L*a*b*
            model, where L is 0 - 100, and a and b are unbound. (Note that a and
            b are restricted to -128 - 127 in TIFF files).


        """
    def tmi(self) -> Tuple[float, float, float]:
        """

        tmi(self) -> (float, float, float)

            Returns the color as a tuple of (temperature, magenta, intensity),
            where each component is -1.0 to 1.0.


        """
    def setRGB(self, tuple: Sequence[float]) -> None:
        """

        setRGB(self, tuple)

            Sets the color using a tuple of (red, green, blue) floating point
            values. See the rgb() method.


        """
    def setHSV(self, tuple: Sequence[float]) -> None:
        """

        setHSV(self, tuple)

            Sets the color as a tuple of (hue, saturation, value). See the hsv()
            method.


        """
    def setHSL(self, tuple: Sequence[float]) -> None:
        """

        setHSL(self, tuple)

            Sets the color as a tuple of (hue, saturation, lightness). See the
            hsl() method.


        """
    def setXYZ(self, tuple: Sequence[float]) -> None:
        """

        setXYZ(self, tuple)

            Sets the color as a tuple of (x, y, z) tristimulus values. See the
            xyz() method.


        """
    def setLAB(self, tuple: Sequence[float]) -> None:
        """

        setLAB(self, tuple)

            Sets the color as a tuple of (L, a, b) as defined in the L*a*b*
            model. See the lab() method.


        """
    def setTMI(self, tuple: Sequence[float]) -> None:
        """

        setTMI(self, tuple)

            Sets the color as a tuple of (temperature, magenta, intensity). See
            the tmi() method.


        """
    @staticmethod
    def ocio_configPath() -> str:
        """

        ocio_configPath() -> str

            Query the full path to the current OpenColorIO 'config.ocio' file.


        """
    @staticmethod
    def ocio_spaces() -> Tuple[str, ...]:
        """

        ocio_spaces()

            Returns a list of the color spaces defined in the Open Color IO
            configuration in Houdini.


        """
    @staticmethod
    def ocio_activeDisplays() -> Tuple[str, ...]:
        """

        ocio_activeDisplays() -> tuple of str

            Return the list of active Displays, specified in the config file or
            the OpenColorIO OCIO_ACTIVE_DISPLAYS environment variable.


        """
    @staticmethod
    def ocio_activeViews() -> Tuple[str, ...]:
        """

        ocio_activeViews() -> tuple of str

            Return the list of active Views, specified in the config file or the
            OpenColorIO OCIO_ACTIVE_VIEWS environment variable.


        """
    @staticmethod
    def ocio_looks() -> Tuple[str, ...]:
        """

        ocio_looks() -> tuple of str

            Return the list of Looks in the current OpenColorIO config.


        """
    @staticmethod
    def ocio_roles() -> Tuple[str, ...]:
        """

        ocio_roles() -> tuple of str

            Return the list of Roles in the current OpenColorIO config.


        """
    @staticmethod
    def ocio_views(display: str) -> Tuple[str, ...]:
        """

        ocio_views(display) -> tuple of str

            Return the list of Views available for 'display'.


        """
    @staticmethod
    def ocio_defaultDisplay() -> str:
        """

        ocio_defaultDisplay() -> str

            Returns the default Display, specified in the config file or the
            OpenColorIO OCIO_ACTIVE_DISPLAYS environment variable (as the first
            Display in the list).


        """
    @staticmethod
    def ocio_defaultView() -> str:
        """

        ocio_defaultView() -> str

            Returns the default View, specified in the config file or the
            OpenColorIO OCIO_ACTIVE_VIEWS environment variable (as the first
            View in the list).


        """
    def ocio_transform(self, src_colorspace: str, dest_colorspace: str, looks: str) -> Color:
        """

        ocio_transform(src_colorspace, dest_colorspace, looks) -> hou.Color`

            Transforms from this color (in src_colorspace) to a different
            colorspace (dest_colorspace) with optional transforms specified in
            looks and returns the transformed color. The color space names and
            the look name must be defined in the current OCIO config file.


        """
    def ocio_viewTransform(self, src_colorspace: str, display: str, view: str) -> Color:
        """

        ocio_viewTransform(src_colorspace, display_name, view_name) ->
        hou.Color`

            Transforms from this color (in src_colorspace) to the view specified
            by 'display_name' and 'view_name', and returns the transformed
            color. The color space names, display name, and view name must be
            defined in the current OCIO config file.


        """
    @staticmethod
    def reloadOCIO() -> None:
        """

        reloadOCIO()

            Reloads the OpenColorIO configuration file. This is generally paired
            with setting the OCIO environment variable to a new config file
            beforehand.


        """

class CompositorViewer(PathBasedPaneTab):
    """

    hou.CompositorViewer

    Class representing a compositing view pane.

    This class provides the essential methods for supporting compositing
    shelf tools, COP states and handles. It doesn't currently offer
    programmatic control over most UI-available functions. For that purpose,
    the functions within the cop2toolutils module are more suitable.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def currentState(self) -> str:
        """

        currentState(self) -> str

            Returns the name of the tool currently in use in the view. This is
            an internal, undocumented designation but usually corresponds to the
            name of a node. You can change to a different tool using
            setCurrentState.


        """
    def enterViewState(self, wait_for_exit: bool = False) -> None:
        """

        enterViewState(self, wait_for_exit=False)

            Switch to the view tool.


        """
    def setCurrentState(self, state: str, wait_for_exit: bool = False) -> None:
        """

        setCurrentState(self, state, wait_for_exit=False)

            Sets the currently active tool in the view. state is a string
            containing an internal, undocumented designation. See
            currentState().


        """
    def usingOCIO(self) -> bool:
        """

        usingOCIO(self) -> bool

            Query if OpenColorIO is being used for color correction in the
            viewer.


        """
    def setUsingOCIO(self, enable: bool) -> None:
        """

        setUsingOCIO(self, enable)

            Enable or disable OpenColorIO for color correction in the viewer.


        """
    def setOCIODisplayView(self, display: Optional[str] = None, view: Optional[str] = None) -> None:
        '''

        setOCIODisplayView(self, display=\\"\\", view=\\"\\")

            Set the OpenColorIO display name, view name, or both. The display
            and view together define the output colorspace for the viewer, and
            any number of color transforms (Looks) to be performed on the linear
            viewport image.


        '''
    def getOCIODisplay(self) -> str:
        """

        getOCIODisplay(self) -> str

            Return the current OpenColorIO display used for color correction.


        """
    def getOCIOView(self) -> str:
        """

        getOCIOView(self) -> str

            Return the current OpenColorIO view used for color correction.


        """
    def curViewport(self) -> Optional[Viewport2D]:
        """

        curViewport(self) -> hou.Viewport2D

            Returns this viewer's current viewport. The current viewport is the
            one containing the mouse cursor.


        """
    def showHandle(self, name: str, value: bool) -> None:
        """

        showHandle(self, name, value)

            Shows or hides a display handle linked to the current tool state.
            This API is typically used with Python states and can be called from
            any python state callbacks. Avoid calling showHandle from the python
            state constructor, because this leads to a runtime error.

            See also hou.Handle.show.


            name
                The name of the handle as specified with
                hou.ViewerStateTemplate.bindHandle or the name or a built-in
                Houdini handle.

            value
                Bool value, True to show the handle, False to hide it.


        """
    def runStateCommand(self, name: str, args: Optional[Any] = None) -> None:
        '''

        runStateCommand(self, name, args=None)

            Executes a command implemented by the active python state. A state
            command can be invoked by specifying a name identifier along with
            arguments.

            An exception is thrown if the state is not a Python state type or
            the state is not running.


            name
                The command name identifier.

            args
                The command arguments. args can be any Python type, including
                built-in types, containers, sets, or dictionaries. A dictionary
                is commonly used to pass arguments to a command, as it
                simplifies the command\'s implementation and allows output values
                to be returned by the command. args defaults to None is omitted.

            An implementation example of a COP state command.

          > import hou
          > import viewerstate.utils as su
          > 
          > class State(object):
          >     def __init__(self, state_name, viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = viewer    
          > 
          >     def onCommand( self, kwargs ):        
          >         name = kwargs[\'command\']
          >         args = kwargs[\'command_args\']
          > 
          >         if name == \\"myCOPCommand\\"\':
          >             self.log(f\\"{name}({args})\\")
          > 
          > def createViewerStateTemplate():
          >     \\"\\"\\" Mandatory entry point to create and return the viewer state 
          >         template to register. \\"\\"\\"
          > 
          >     state_typename = \\"mycopstate\\"
          >     state_label = \\"My COP State\\"
          >     state_cat = hou.copNodeTypeCategory()
          > 
          >     template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
          >     template.bindFactory(State)
          >     template.bindIcon(\\"MISC_python\\")
          > 
          >     return template

            Here\'s how to invoke the command.

          > import viewerstate.utils as ut
          > 
          > v = ut.findCompositorViewer()       
          > v.runStateCommand(\\"myCOPCommand\\", {\\"arg0\\":0, \\"arg1\\":[1,2,3]})

        '''
    def bindViewerHandle(self, handle_type: str, name: str, settings: str|None = ..., cache_previous_parms: bool = ..., handle_parms: Sequence[str]|None = ...) -> None:
        """

        bindViewerHandle(self, handle_type, name, settings=None,
        cache_previous_parms=False, handle_parms=None)

            Binds a dynamic viewer handle to the current viewer state similarly
            to hou.ViewerStateTemplate.bindHandle. Unlike bindHandle though,
            this method creates and initializes the handle in a dynamic fashion
            so there is no need to register in advance the handle with the
            viewer state. You can call bindViewerHandle from almost anywhere in
            Houdini (from the viewer state handlers, from a python script,
            etc...), but it can only be called while the viewer state is
            running.

            To remove the viewer handles added with bindViewerHandle, use
            hou.SceneViewer.unbindViewerHandle. Houdini will take care of
            removing automatically all viewer handles added with
            bindViewerHandle when the state exits.

            This method works only with python states, an exception is raised if
            the state is not a python state.



                handle_type
                    A string naming the type of handle. See State handle types
                    for a list of handle types to choose from.

                name
                    A string to use to identify the handle. Each binding's name
                    must be unique within this state. Trying to bind the same
                    name more than once will raise an exception.

                settings
                    A string containing specific settings of the handle.
                    Multiple settings must be space separated.

                cache_previous_parms
                    If True, the handle retains a record of previous values.
                    This can be useful if you want your code to calculate deltas
                    as the user moves the handle, for example to know how fast
                    the user is dragging the handle.

                handle_parms
                    An array of handle parm names to specify the parms to
                    enable, only the parms contained in the array will be
                    available to the python state callbacks. All handle parms
                    are enabled when handle_parms is empty (default).


        """
    def bindViewerHandleStatic(self, handle_type: str, name: str, bindings: Sequence[tuple[str, str]], settings: str|None = ...) -> None:
        '''

        bindViewerHandleStatic(self, handle_type, name, bindings, settings=None)

            Binds a static viewer handle to the current viewer state similarly
            to hou.ViewerStateTemplate.bindHandleStatic. Unlike bindHandleStatic
            though, this method creates and initializes the handle in a dynamic
            fashion so there is no need to register in advance the handle with
            the viewer state. You can call bindViewerHandleStatic from almost
            anywhere in Houdini (from the viewer state handlers, from a python
            script, etc...), but it can only be called while the viewer state is
            running.

            To remove the viewer handles added with bindViewerHandleStatic, use
            hou.SceneViewer.unbindViewerHandle. Houdini will take care of
            removing automatically all viewer handles added with
            bindViewerHandleStatic when the state exits.

            This method works only with python states, an exception is raised if
            the state is not a python state.



                handle_type
                    A string naming the type of handle.

                name
                    A unique string to use to identify the handle. Each
                    binding\'s name must be unique within this state. Trying to
                    bind the same name more than once will raise an exception.

                bindings
                    A list of (\\"node_parm_name\\", \\"handle_parm_name\\") tuples.
                    This binds the parts of the handle to individual parameters
                    on the node.

                settings
                    A string containing specific settings of a handle. Multiple
                    settings must be space separated.


        '''
    def unbindViewerHandle(self, handle_instance_name: str) -> None:
        """

        unbindViewerHandle(self, name)

            Removes a viewer handle from the current python state.
            unbindViewerHandle can only unbind the viewer handles that were
            dynamically added with hou.SceneViewer.bindViewerHandle or
            hou.SceneViewer.bindViewerHandleStatic. An exception is raised if
            the viewer handle to unbind is a state registered viewer handle.

            This method works only with python states, an exception is raised if
            the state is not a python state.


            name
                The viewer handle name to unbind. This is the name used when
                binding the handle with bindViewerHandle or
                bindViewerHandleStatic.


        """

class ConstructionPlane:
    """

    hou.ConstructionPlane

    The grid (a.k.a. construction plane) in the scene viewer pane tab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def sceneViewer(self) -> SceneViewer:
        """

        sceneViewer(self) -> hou.SceneViewer

            Return the scene viewer containing this plane.


        """
    def isVisible(self) -> bool:
        """

        isVisible(self) -> bool

            Return whether the grid is visible in the viewer.


        """
    def setIsVisible(self, on: bool) -> None:
        """

        setIsVisible(self, on)

            Make this grid visible or invisible in the viewer.


        """
    def transform(self) -> Matrix4:
        """

        transform(self) -> hou.Matrix4

            Return the transformation matrix for this plane.

            When the transformation matrix is the identity matrix, the plane's
            bottom-left corner is at the origin and it sits in the XY plane. In
            this orientation, increasing the number of cells in x or the size of
            a cell in x grows the plane outward from the origin along the
            x-axis. Similarly, increasing the number of cells or size of a cell
            in y grows the plane along the y-axis.

            Note that the transformation matrix does not contain any scale
            information. Use the cellSize and numberOfCells methods to get the
            size of the plane.

            The following function will return the position of the center of the
            plane:

          > def origin(construction_plane):
          >     return hou.Vector3(0, 0, 0) * construction_plane.transform()

            The following function will return the normal of the plane:

          > def normal(construction_plane):
          >     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()

        """
    def setTransform(self, matrix: Matrix4) -> None:
        """

        setTransform(self, matrix)

            Set the transformation matrix for this plane to a hou.Matrix4.

            This matrix is used to translate and rotate the plane. See the
            transform method for more information.

            Note that scale information inside the transformation matrix is
            ignored. Use the setCellSize and setNumberOfCells methods to adjust
            the size of the plane.

            The following function will change the position of the center of the
            plane:

          > def set_origin(construction_plane, new_origin):
          >     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(construction_plane))
          >     construction_plane.setTransform(construction_plane.transform() * translation)
          > 
          > def origin(construction_plane):
          >     return hou.Vector3(0, 0, 0) * construction_plane.transform()

            The following function will change the normal of the plane:

          > def set_normal(construction_plane, normal_vector):
          >     existing_rotation = hou.Matrix4(construction_plane.transform().extractRotationMatrix3())
          >     rotation = existing_rotation * normal(construction_plane).matrixToRotateTo(normal_vector)
          >     translation = hou.hmath.buildTranslate(origin(construction_plane))
          >     construction_plane.setTransform(rotation * translation)
          > 
          > def normal(construction_plane):
          >     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()
          > 
          > def origin(construction_plane):
          >     return hou.Vector3(0, 0, 0) * construction_plane.transform()

        """
    def cellSize(self) -> Tuple[float, ...]:
        """

        cellSize(self) -> tuple of float

            Return the x and y sizes (width and height) of one cell in the grid
            of cells. The return value is a tuple of two floats.


        """
    def setCellSize(self, size: Sequence[float]) -> None:
        """

        setCellSize(self, size)

            Change the x and y sizes (width and height) of each cell in the grid
            of cells. size is a sequence of two floats.

            Changing the size of each cell will change the total size of the
            grid.


        """
    def numberOfCells(self) -> Tuple[int, ...]:
        """

        numberOfCells(self) -> tuple of int

            Return the number of cells in the x and y directions of the grid. In
            other words, return the number of columns and rows.


        """
    def setNumberOfCells(self, number: Sequence[int]) -> None: ...
    def numberOfCellsPerRulerLine(self) -> Tuple[int, ...]:
        """

        numberOfCellsPerRulerLine(self) -> tuple of int

            Return the number of cells in the x and y directions between ruler
            lines. Ruler lines are darker than the normal lines drawn between
            grid cells.


        """
    def setNumberOfCellsPerRulerLine(self, number: Sequence[int]) -> None: ...

class ContextViewer(PathBasedPaneTab):
    """

    hou.ContextViewer

    A class representing a context viewer pane tab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def sceneViewer(self) -> Optional[SceneViewer]:
        """

        sceneViewer(self) -> hou.SceneViewer

            Returns a SceneViewer if the ContextViewer is displaying a scene
            viewer. If not, returns None.


        """
    def compositorViewer(self) -> Optional[CompositorViewer]:
        """

        compositorViewer(self) -> hou.CompositorViewer

            Returns a CompositorViewer if the ContextViewer is displaying a
            compositor viewer. If not, returns None.


        """
    def findViewport(self, name: str) -> Optional[GeometryViewport]:
        """

        findViewport(self, viewport_name) -> hou.GeometryViewport

            Returns a GeometryViewport with the given viewport_name if the
            ContextViewer is displaying a scene viewer. If not, returns None.


        """

class CopCableStructure:
    """

    hou.CopCableStructure

    Captures types and names of wires in a Copernicus cable.

    A cable in Copernicus represents an ordered bundle of individual wires.
    This class represents the structure of a cable's contents, identifying
    the name and data type of each individual wire. You can call
    hou.CopNode.inputCableStructure and hou.CopNode.outputCableStructure to
    query the cables that are plugged into input ports or generated by
    output ports of a COP node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def wireCount(self) -> int:
        """

        wireCount(self) -> int

            Returns the number of wires contained in a cable.


        """
    def wireDataType(self, index: int) -> str: ...
    def wireName(self, index: int) -> str:
        """

        wireName(self, index) -> str

            Returns the name of the wire at the specified index.


        """
    def appearanceIndex(self, index: int) -> int:
        """

        appearanceIndex(self, index) -> int

            Multiple wires in a cable can have the same name, in which case they
            are distinguished by their appearance index. For example, if a cable
            has three different wires called color, the first wire's appearance
            index will be 0, the second wire's will be 1, and the third wire's
            will be 2. This method returns the appearance index of the wire at
            the specified index. That is, it returns 0-based index of a specific
            wire within all wires of the cable that have the same name as it.


        """

class CopNode(OpNode):
    """

    hou.CopNode

    Represents a Copernicus node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def geometry(self, output_index: int = 0) -> Optional[Geometry]:
        """

        geometry(self, output_index=0) -> hou.Geometry

            Return the geometry computed by this COP node. If the COP has not
            already cooked, this method will cook the COP.

            The returned Geometry object is frozen. See hou.Geometry.freeze for
            more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node.

            Non-geometry outputs are converted to geometry using the same rules
            as if they were brought into a SOP Network.


        """
    def geometryAtFrame(self, frame: float, output_index: int = 0) -> Optional[Geometry]:
        """

        geometryAtFrame(self, frame, output_index=0) -> hou.Geometry

            Return the geometry computed by this COP node cooked at the
            specified frame. If the COP has not already cooked, this method will
            cook the COP.

            The returned Geometry object is frozen. See hou.Geometry.freeze for
            more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node.

            Non-geometry outputs are converted to geometry using the same rules
            as if they were brought into a SOP Network.


        """
    def layer(self, output_index: int = 0) -> Optional[ImageLayer]:
        """

        layer(self, output_index=0) -> hou.ImageLayer

            Return the layer computed by this COP node. If the COP has not
            already cooked, this method will cook the COP.

            You can optionally specify the output_index argument to request the
            layer attached to another output on the node.


        """
    def layerAtFrame(self, frame: float, output_index: int = 0) -> Optional[ImageLayer]:
        """

        layerAtFrame(self, frame, output_index=0) -> hou.ImageLayer

            Return the layer computed by this COP node cooked at the specified
            frame. If the COP has not already cooked, this method will cook the
            COP.

            You can optionally specify the output_index argument to request the
            layer attached to another output on the node.


        """
    def vdb(self, output_index: int = 0) -> Optional[NanoVDB]:
        """

        vdb(self, output_index=0) -> hou.NanoVDB

            Return the vdb computed by this COP node. If the COP has not already
            cooked, this method will cook the COP.

            You can optionally specify the output_index argument to request the
            vdb attached to another output on the node.


        """
    def vdbAtFrame(self, frame: float, output_index: int = 0) -> Optional[NanoVDB]:
        """

        vdbAtFrame(self, frame, output_index=0) -> hou.NanoVDB

            Return the vdb computed by this COP node cooked at the specified
            frame. If the COP has not already cooked, this method will cook the
            COP.

            You can optionally specify the output_index argument to request the
            vdb attached to another output on the node.


        """
    def inputCableStructure(self, input_index: int) -> Optional[CopCableStructure]:
        """

        inputCableStructure(self, idx) -> hou.CopCableStructure

            Returns an object capturing names and types of wires in the cable
            plugged into the specified input port.


        """
    def outputCableStructure(self, output_index: int) -> Optional[CopCableStructure]:
        """

        outputCableStructure(self, idx) -> hou.CopCableStructure

            Returns an object capturing names and types of wires generated by
            the specified output port of this node.


        """
    def hasVerb(self) -> bool:
        """

        hasVerb(self) -> bool

            Returns if the node has a verb representation.


        """
    def verb(self) -> Optional[CopVerb]:
        """

        verb(self) -> hou.CopVerb

            Returns the verb associated with a specific node. This allows you to
            run the node's operation on geometry independent of the node itself.


        """
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns True if the node's bypass flag is turned on. Returns False
            otherwise.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turns the node's bypass flag on or off. When the bypass flag is on,
            the node will have no effect on the scene. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Returns True if the node's display flag is turned on. Returns False
            otherwise.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turns the node's display flag on or off. When the display flag is
            on, the node's image will appear in the image viewport. The value of
            the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isTemplateFlagSet(self) -> bool:
        """

        isTemplateFlagSet(self) -> bool

            Returns True if the node's template flag is turned on. Returns False
            otherwise.


        """
    def setTemplateFlag(self, on: bool) -> None:
        """

        setTemplateFlag(self, on)

            Turns the node's template flag on or off. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isSelectableTemplateFlagSet(self) -> bool:
        """

        isSelectableTemplateFlagSet(self) -> bool

            Return whether this node's selectable template flag is on. A
            selectable template displays like the display COP in the viewport.


        """
    def setSelectableTemplateFlag(self, on: bool) -> None:
        """

        setSelectableTemplateFlag(self, on)

            Turn this node's selectable template flag on or off.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isCompressFlagSet(self) -> bool:
        """

        isCompressFlagSet(self) -> bool

            Returns True if the node's compress flag is turned on. Returns False
            otherwise. The compress flag controls whether or not a preview image
            is shown for this node in the Network View.


        """
    def setCompressFlag(self, on: bool) -> None:
        """

        setCompressFlag(self, on)

            Turns the node's compress flag on or off. If the compress flag is
            True, this node will not show a preview image in the Network View.
            If the compress flag is False, a preview image will be shown in the
            Network View. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isExportFlagSet(self) -> bool:
        """

        isExportFlagSet(self) -> bool

            Returns True if the node's export flag is turned on. Returns False
            otherwise.


        """
    def setExportFlag(self, on: bool) -> None:
        """

        setExportFlag(self, on)

            Turns the node's export flag on or off. When the export flag is on,
            the node's image will appear in the 3d viewers rather than the
            display flag's.

            The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def outputDataTypes(self) -> Tuple[str, ...]:
        """

        outputDataTypes(self) -> tuple of str

            Returns a tuple of all output data types for this node. Data types
            for output connectors that are hidden are also included.


        """
    def inputDataTypes(self) -> Tuple[str, ...]:
        """

        inputDataTypes(self) -> tuple of str

            Returns a tuple of all input data types for this node. Data types
            for input connectors that are hidden are also included.


        """
    def isInputCompatible(self, idx: int, other: CopNode, other_idx: int, allow_conversions: bool = False) -> bool:
        """

        isInputCompatible(self, idx, other, other_idx, allow_conversions =
        False) -> bool`

            Return True if input idx of this object can be connected to output
            other_idx of node other. Two inputs can be connected if they are of
            the same data type. The allow_conversions provides API compatibility
            with VOPs, but currently COP types that are convertible (such as
            Mono to RGB) are considered valid regardless of this flag.


        """
    def displayNode(self) -> Optional[Node]:
        """

        displayNode(self) -> Node

            If this is a subnet COP, return the COP inside the subnet with its
            display flag on. Otherwise, return None.


        """

class CopVerb(OpVerb):
    """

    hou.CopVerb

    Represents the code of a copernicus node.

    See using a verb for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def execute(self, inputs: dict[str, Any]) -> dict[str, Any]:
        """

        execute(self, inputs) -> dict

            Applies the verb using the provided dictionary of inputs.

            The inputs can be keyed by the name of the input, or by the string
            representing the 0-based index of the input. Each input type must
            match the signature of the verb - if necessary the signature
            parameter can be provided to the parms.

            Returns a dictionary of the computed layers and geometry for the
            outputs. The output dictionary is keyed both by the output name and
            by the 0-based output index as a string.


            NOTE
                Node defaults may change between versions.


        """

class Cop2Node(OpNode):
    """

    hou.Cop2Node

    Represents a compositing node.


    WARNING
        As of Houdini 20.5, use Copernicus nodes instead of Compositing
        nodes. Though both networks still exist, the Compositing network is
        now designated as COP Network - Old. The Compositing network and its
        nodes will be deprecated and then removed in a future Houdini
        release.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns True if the node's bypass flag is turned on. Returns False
            otherwise.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turns the node's bypass flag on or off. When the bypass flag is on,
            the node will have no effect on the scene. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Returns True if the node's display flag is turned on. Returns False
            otherwise.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turns the node's display flag on or off. When the display flag is
            on, the node's image will appear in the image viewport. The value of
            the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isRenderFlagSet(self) -> bool:
        """

        isRenderFlagSet(self) -> bool

            Returns True if the node's render flag is turned on. Returns False
            otherwise.


        """
    def setRenderFlag(self, on: bool) -> None:
        """

        setRenderFlag(self, on)

            Turns the node's render flag on or off. The render flag controls
            which node in a compositing network will be rendered to or to disk.
            The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isTemplateFlagSet(self) -> bool:
        """

        isTemplateFlagSet(self) -> bool

            Returns True if the node's template flag is turned on. Returns False
            otherwise.


        """
    def setTemplateFlag(self, on: bool) -> None:
        """

        setTemplateFlag(self, on)

            Turns the node's template flag on or off. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isCompressFlagSet(self) -> bool:
        """

        isCompressFlagSet(self) -> bool

            Returns True if the node's compress flag is turned on. Returns False
            otherwise. The compress flag controls whether or not a preview image
            is shown for this node in the Network View.


        """
    def setCompressFlag(self, on: bool) -> None:
        """

        setCompressFlag(self, on)

            Turns the node's compress flag on or off. If the compress flag is
            True, this node will not show a preview image in the Network View.
            If the compress flag is False, a preview image will be shown in the
            Network View. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def planes(self) -> Tuple[str, ...]:
        """

        planes(self) -> tuple of strings

            Returns a tuple of plane names in the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def components(self, plane: str) -> Tuple[str, ...]:
        """

        components(self, plane) -> tuple of str

            Returns a tuple of component names for the specified plane in the
            node's image sequence. The value of the plane argument must be a
            plane name.

            Raises ValueError if plane is None or empty. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the given plane does not
            exist.


        """
    def depth(self, plane: str) -> EnumValue:
        '''

        depth(self, plane) -> hou.imageDepth enum value

            Return the data format used to represent one component of one pixel
            in the given image plane.

            For example, if the depth of the \\"C\\" (color) plane is
            hou.imageDepth.Int8, each of the red, green, and blue components is
            stored as an (unsigned) 8-bit integer, occupying one byte. If, for
            example, it is instead hou.imageDepth.Float32, each of the red,
            green, and blue components is a 32-bit float and occupies 4 bytes
            (12 bytes total for all 3 components combined).


        '''
    def maskInputIndex(self) -> int:
        """

        maskInputIndex(self) -> int

            Return the input index of the mask input for this node. Return -1 if
            this node type does not provide a mask input.


        """
    def getPixelByUV(self, plane: str, u: float, v: float, component: Optional[str] = None, interpolate: bool = True) -> Tuple[float, ...]:
        """

        getPixelByUV(self, plane, u, v, component=None, interpolate=True) ->
        tuple of float

            Returns plane values for a single pixel in the node's image. The
            plane is defined by the plane argument which must be set to the
            plane's name. The pixel is defined by (u, v) coordinates where u and
            v are values between 0.0 and 1.0. If the optional component argument
            is specified, then the value for that particular component is
            returned. Otherwise, all of the plane's component values are
            returned. The value of component should be the component's name
            (i.e. r, g, b, etc.).

            If the (u, v) coordinates do not fall exactly on a pixel, then the
            return values are calculated by linear blending of the values for
            the surrounding pixels. This can be disabled by setting the
            interpolate argument to False, in which case the values of the pixel
            located immediately to the bottom-left of (u, v) are returned.

            Note that the returned values are for the node's image at the
            current frame.

            Raises ValueError if either u or v is outside of the 0.0-1.0 range.
            Raises ValueError if plane is None or empty. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the given plane does not
            exist. Raises hou.OperationFailed if the given component does not
            exist in the plane.


        """
    def getPixelHSVByUV(self, u: float, v: float, interpolate: bool = True) -> Tuple[float, ...]:
        """

        getPixelHSVByUV(self, u, v, interpolate=True) -> tuple of float

            Returns a 3-tuple containing the hue, saturation and value for a
            single pixel in the node's image. The pixel is defined by (u, v)
            coordinates where u and v are values between 0.0 and 1.0.

            If the (u, v) coordinates do not fall exactly on a pixel, then the
            return values are calculated by linear blending of the values for
            the surrounding pixels. This can be disabled by setting the
            interpolate argument to False, in which case the values of the pixel
            located immediately to the bottom-left of (u, v) are returned.

            Note that the returned hue, saturation and value are for the node's
            image at the current frame.

            Raises ValueError if either u or v is outside of the 0.0-1.0 range.
            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def getPixelLuminanceByUV(self, u: float, v: float, interpolate: bool = True) -> float:
        """

        getPixelLuminanceByUV(self, u, v, interpolate=True) -> float

            Returns the luminance value for a single pixel in the node's image.
            The pixel is defined by (u, v) coordinates where u and v are values
            between 0.0 and 1.0.

            If the (u, v) coordinates do not fall exactly on a pixel, then the
            luminance is calculated by linear blending of the luminance values
            for the surrounding pixels. This can be disabled by setting the
            interpolate argument to False, in which case the luminance of the
            pixel located immediately to the bottom-left of (u, v) is returned.

            Note that the returned luminance value is for the node's image at
            the current frame.

            Raises ValueError if either u or v is outside of the 0.0-1.0 range.
            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def allPixels(self, plane: str = ..., component: str|None = ..., interleaved: bool = ..., time: float = ...) -> Tuple[float,...]:
        '''

        allPixels(self, plane=\\"C\\", component=None, interleaved=True, time=-1.0)
        -> tuple of float

            Return a tuple of floats containing all pixel values for a
            particular image plane. The pixels in the bottom scanline of the
            image are first in the result, followed by the second-last scanline,
            etc. Floating point values in the color plane (C), for example, are
            typically in the range 0.0 to 1.0.


            plane
                The name of the image plane to return. All images have C (color)
                and A (alpha) planes. Deep raster images may contain other
                planes, such as Pz (depth), N (normal), etc.

            component
                A particular subcomponent of the plane. For example, for the C
                plane you could specify one of the r, g, or b subcomponents.
                Specify None to indicate all components.

            interleaved
                Whether the different components of the plane are interleaved in
                the result. For example, if the plane is C, the interleaved
                result would be organized as rgbrgbrgb... while the
                uninterleaved result would be rrr...ggg...bbb.... This parameter
                has no effect when a particular component is specified.

            time
                The time at which to cook the COP node. If this value is
                negative, Houdini uses the current time.

                Note that this argument does not apply if allPixels is called
                from a Python COP that is cooking. In that case allPixels
                evaluates at the current cooking time.

            This method does not accept a depth parameter like allPixelsAsString
            does. The values are converted to floating point data, regardless of
            the actual depth of the image plane.

            Raises hou.OperationFailed if the time argument is set to a value
            greater than or equal to 0.0 and allPixels is called from a cooking
            Python COP.


        '''
    def allPixelsAsString(self, plane: str = ..., component: str|None = ..., interleaved: bool = ..., time: float = ...) -> bytes:
        '''

        allPixelsAsString(self, plane=\\"C\\", component=None, interleaved=True,
        time=-1.0, depth=None) -> str for Python 2, bytes for Python 3

            Return a binary string representation of the floats containing all
            the values of all voxels. This method is faster than
            hou.Cop2Node.allPixels, and you can use the array module to convert
            the string into a Python sequence. Note that this method returns
            binary float data, so there are 4 bytes per R, G, and B component,
            not 1 byte.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            If depth is hou.imageDepth.Float32, this method provides a faster
            implementation of the following:

          > import array
          > def allPixelsAsString(self):
          >     return array.array(\\"f\\", self.allPixels()).tostring()

            If depth is None and this method is called from the code
            implementing a Python COP to get an input plane, the depth will be
            the same as the plane\'s native depth. If depth is None and this
            method is called from outside a Python COP, the depth will be
            hou.imageDepth.Float32. Otherwise, if depth is a hou.imageDepth
            enumerated value the result will be converted to the specified
            depth.

            See hou.Cop2Node.allPixels for more information. See also
            hou.Volume.setVoxelSliceFromString.

            Raises hou.OperationFailed if the time argument is set to a value
            greater than or equal to 0.0 and allPixelsAsString is called from a
            cooking Python COP.


        '''
    def setPixelsOfCookingPlane(self, values: Sequence[float], component: Optional[str] = None, interleaved: bool = True, flip_vertically: bool = False) -> None:
        """

        setPixelsOfCookingPlane(self, values, component=None, interleaved=True,
        flip_vertically=False)

            Set the pixels of the plane being cooked by the currently-running
            Python COP.


            values
                A sequence of floats, organized with the contents of the bottom
                scanline first.

                If component is None, the length of the sequence of floats must
                be the number of pixels in the image times the number of
                components. Otherwise, it must be the number of pixels in the
                image.

            component
                Either the name of one component in the plane being cooked, or
                None. If a component name is given, values will contain only the
                values for that component. Otherwise, it will contain the values
                for all components of all pixels in the plane.

            interleaved
                If component is None and interleaved is True, values is contains
                the first component of the first pixel, followed by the second
                component of the first pixel, until the last component of the
                first pixel, then the first component of the second pixel, etc.
                If it is False, values contains all the values of the first
                component for all pixels, followed by all the values of the
                second component, etc.

                For example, if the plane is C and interleaved is True, the
                values will be organized as rgbrgbrgb.... If it is not
                interleaved, it will be organized as rrr...ggg...bbb....

                If component is not None, this parameter is ignored.

            flip_vertically
                The default value for this parameter is False, so the first
                scanline in the values array is assumed to be the bottom
                scanline. If flip_vertically is True, the input values are
                assumed to oriented starting at the top scanline.

            If you call this method from outside the cook function in a Python
            COP, raises hou.OperationFailed.

            See also hou.Cop2Node.allPixels and
            hou.Cop2Node.setPixelsOfCookingPlaneFromString. Also see the HOM
            cookbook and the Python COP documentation for examples.


        """
    def imageBounds(self, plane: str = ...) -> Tuple[int, int, int]:
        '''

        imageBounds(self, plane=\\"C\\") -> tuple of int

            Returns the x and y boundaries of the given plane in the form of
            (xmin, ymin, xmax, ymax). The value of the plane argument is the
            plane name. By default, the image bounds of the color plane is
            returned.

            Note that the image bounds is not the same as the image resolution.
            For example, the image bounds for a Font COP is the bounding
            rectangle around the displayed letters while the resolution is the
            size of the node\'s image.

            Note that the returned image bounds is for the current frame.

            Raises ValueError if plane is None or empty. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the given plane does not
            exist.


        '''
    def xRes(self) -> int:
        """

        xRes(self)

            Returns the x-resolution of the node's image for the current frame.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def yRes(self) -> int:
        """

        yRes(self)

            Returns the y-resolution of the node's image for the current frame.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def sequenceStartFrame(self) -> float:
        """

        sequenceStartFrame(self) -> float

            Returns the start frame in the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def sequenceEndFrame(self) -> float:
        """

        sequenceEndFrame(self) -> float

            Returns the last frame in the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def sequenceFrameLength(self) -> float:
        """

        sequenceFrameLength(self) -> float

            Returns the frame length of the node's image sequence.

            Raises hou.OperationFailed if the node could not be cooked or opened
            for processing.


        """
    def isSingleImage(self) -> bool:
        """

        isSingleImage(self) -> bool

            Returns True if the node has a single image. Returns False if the
            node has an image sequence.


        """
    def saveImage(self, file_name: str, frame_range: Sequence[float] = ...) -> None:
        """

        saveImage(self, file_name, frame_range=())

            Saves the node's cooked image sequence to disk. For multiple images,
            make sure that the file_name argument contains $F so that the
            sequence is written to multiple files.

            The optional frame_range argument can be specified to write only a
            subset of frames in the image sequence. frame_range must be a
            2-tuple or a 3-tuple, where the first element is the start frame,
            the second element is the end frame and the third element is the
            frame increment. If frame_range is not given, then every frame in
            the image sequence is saved to disk.

            Raises ValueError if the frame increment in frame_range is 0. Raises
            hou.InvalidSize if the size of frame_range is not 0, 2 or 3. Raises
            hou.OperationFailed if the node could not be cooked or opened for
            processing. Raises hou.OperationFailed if the image could not be
            saved to disk.


        """
    def hasMetaData(self, metadata_name: str) -> bool:
        """

        hasMetaData(self, metadata_name) -> bool

            Returns True if the metadata with name metadata_name exists, False
            otherwise.


        """
    def getMetaDataInt(self, metadata_name: str, index: int = 0) -> int:
        """

        getMetaDataInt(self, metadata_name, index=0) -> int

            Returns numeric metadata as a single integer. In the case of
            vectors, matrices and arrays, index indicates the component to
            fetch. Floating point metadata will be truncated.


        """
    def getMetaDataFloat(self, metadata_name: str, index: int = 0) -> float:
        """

        getMetaDataFloat(self, metadata_name, index=0) -> double

            Returns numeric metadata as a single double precision value. In the
            case of vectors, matrices and arrays, index indicates the component
            to fetch.


        """
    def getMetaDataString(self, metadata_name: str) -> str:
        """

        getMetaDataString(self, metadata_name) -> str

            Returns string metadata from metadata_name.


        """
    def getMetaDataIntArray(self, metadata_name: str) -> Tuple[int, ...]:
        """

        getMetaDataIntArray(self, metadata_name) -> tuple of int

            Returns numeric metadata as an array of integers. Floating point
            metadata values will be truncated.


        """
    def getMetaDataFloatArray(self, metadata_name: str) -> Tuple[float, ...]:
        """

        getMetaDataFloatArray(self, metadata_name) -> tuple of double

            Returns numeric metadata as an array of double-precision values.


        """
    def setPixelsOfCookingPlaneFromString(self, values: bytes, component: str|None = ..., interleaved: bool = ..., depth: EnumValue|None = ..., flip_vertically: bool = ...) -> None:
        """

        setPixelsOfCookingPlaneFromString(self, values, component=None,
        interleaved=True, depth=None, flip_vertically=False)

            Set the pixels of the plane being cooked by the currently-running
            Python COP. This method is like hou.Cop2Node.setPixelsOfCookingPlane
            except values contains a binary string representation of the data
            instead of a sequence of floats. Consequently, this method is
            faster.

            The values binary string must be a bytes object in Python 3 and a
            str object in Python 2. See HOM binary data for more information.

            The depth parameter specifies how to interpret the values in the
            binary string, and is a hou.imageDepth enumerated value. If depth is
            None, the depth is assumed to be in the depth of the plane being
            cooked. Note that, by specifying depth explicitly, you can provide
            data in any depth, regardless of the actual depth stored by the COP.

            Note that this method can accept more types that just a string: it
            can receive any Python object that supports the buffer interface. In
            particular, arrays from the array and numpy Python modules are
            supported, so there is no need to first construct strings from those
            arrays.

            See hou.Cop2Node.setPixelsOfCookingPlane and
            hou.Cop2Node.allPixelsAsString for more information.


        """

class crowds:
    """

    hou.crowds

    Crowd-related functions.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def addBlendshapeInputs(base_shape_geo: Geometry, shapes: Sequence[AgentShape], channel_names: Sequence[str]) -> None:
        """

        addBlendshapeInputs(self, base_shape_geo, shapes, channel_names)

            Adds blendshape inputs to a shape's geometry. This sets up the
            required detail attributes (blendshape_shapenames and
            blendshape_channels) on the base shape's geometry. For an existing
            agent shape, blendshape inputs can also be added using
            hou.AgentShape.addBlendshapeInputs.


            base_shape_geo
                A modifiable hou.Geometry for the base shape.

            shapes
                A hou.AgentShape sequence to add as blendshape inputs.
                hou.AgentShapeLibrary.addShape should be called separately to
                add these shapes to the shape library.

            channel_names
                A str sequence specifying the channel name to use for each
                shape. Raises hou.InvalidSize if the length does not match the
                shapes list.


        """
    @staticmethod
    def addInBetweenShapes(primary_shape_geo: Geometry, shapes: Sequence[AgentShape], weights: Sequence[float]) -> None:
        """

        addInBetweenShapes(self, primary_shape_geo, shapes, weights)

            Adds in-between shapes to a blendshape input. This sets up the
            required detail attributes (blendshape_shapenames and
            blendshape_inbetweenweights) on the primary shape's geometry. For an
            existing agent shape, in-between shapes can also be added using
            hou.AgentShape.addInBetweenShapes.


            primary_shape_geo
                A modifiable hou.Geometry for the primary shape.

            shapes
                A hou.AgentShape sequence to add as in-between shapes.
                hou.AgentShapeLibrary.addShape should be called separately to
                add these shapes to the shape library.

            weights
                A float sequence specifying the weight that each in-between
                shape is applied at. Raises hou.InvalidSize if the length does
                not match the shapes list.


        """
    @staticmethod
    def setBlendshapeDeformerParms(base_shape_geo: Geometry, attribs: str = ..., point_id_attrib: str = ..., prim_id_attrib: str = ...) -> None:
        '''

        setBlendshapeDeformerParms(self, base_shape_geo, attribs=\\"P N\\",
        point_id_attrib=\\"id\\", prim_id_attrib=\\"id\\")

            Adds attributes to the geometry to specify parameters for the
            blendshapes deformer. This creates the following detail attributes:
            blendshape_attribs, blendshape_ptidattr, and blendshape_primidattr.
            For an existing agent shape, the deformer parameters can be set
            using hou.AgentShape.setBlendshapeDeformerParms.


            attribs
                Specifies a list or pattern of attributes to be blended by the
                deformer.

            point_id_attrib
                Specifies the name of a point attribute used to match up points
                between the different blendshape inputs.

            prim_id_attrib
                Specifies the name of a primitive attribute used to match up
                points between the different blendshape inputs.


        '''
    @staticmethod
    def findAgentDefinitions(geometry: Geometry, group: str = ..., group_type: EnumValue = ...) -> Tuple[AgentDefinition,...]:
        '''

        findAgentDefinitions(geometry, group = \\"\\",
        group_type=hou.geometryType.Primitives) -> tuple of hou.AgentDefinition

            Returns a list of the unique agent definitions in the geometry.

            This is equivalent to the following code, but is significantly
            faster.

          > definitions = set()
          > for prim in geometry.globPrims(group):
          >     if prim.type() == hou.primType.Agent:
          >         definitions.add(prim.definition())
          > 
          > return definitions

            geometry
                A hou.Geometry.

            group
                An optional group string to filter which primitives are
                inspected. The pattern format is the same as the format used for
                group parameters on SOP nodes.

            group_type
                A hou.geometryType indicating whether to parse the group string
                as a point or primitive group. If the value is None, the group
                will be guessed by parsing it as a point group if it fails to
                parse as a primitive group.


        '''
    @staticmethod
    def replaceAgentDefinitions(geometry: Geometry, new_definition_map: Mapping[AgentDefinition, AgentDefinition], group: str = ..., group_type: EnumValue = ...) -> None:
        '''

        replaceAgentDefinitions(geometry, new_definition_map, group = \\"\\",
        group_type=hou.geometryType.Primitives)

            Replaces agent definitions in the geometry with new versions. This
            is a useful convenience function when modifying each agent
            definition in the geometry, particularly when also using
            hou.crowds.findAgentDefinitions.

            For example:

          > defns = hou.crowds.findAgentDefinitions(geo, group)
          > new_defn_map = {}
          > for defn in defns:
          >     new_defn = defn.freeze()
          >     new_defn_map[defn] = new_defn
          > 
          >     # Add a clip to the new agent definition.
          >     new_defn.addClip(...)
          > 
          > # Switch all agents in the group to their respective new agent definition.
          > hou.crowds.replaceAgentDefinitions(geo, new_defn_map, group)

            geometry
                A modifiable hou.Geometry.

            new_definition_map
                A dictionary mapping each hou.AgentDefinition to a
                hou.AgentDefinition that it should be replaced by.

            group
                An optional group string to filter which primitives are
                modified. The pattern format is the same as the format used for
                group parameters on SOP nodes.

            group_type
                A hou.geometryType indicating whether to parse the group string
                as a point or primitive group. If the value is None, the group
                will be guessed by parsing it as a point group if it fails to
                parse as a primitive group.


        '''
    @staticmethod
    def computeLocalTransforms(rig: AgentRig, world_xforms: typing.Iterable[Matrix4]) -> Tuple[Matrix4, ...]:
        """

        computeLocalTransforms(self, rig, xforms) -> tuple of hou.Matrix4

            Converts transforms from world space to local space using the
            provided rig.


            rig
                A hou.AgentRig, which specifies the transform hierarchy.

            xforms
                A sequence of hou.Matrix4, with a world space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
    @staticmethod
    def computeWorldTransforms(rig: AgentRig, local_xforms: typing.Iterable[Matrix4]) -> Tuple[Matrix4, ...]:
        """

        computeWorldTransforms(self, rig, xforms) -> tuple of hou.Matrix4

            Converts transforms from local space to world space using the
            provided rig.


            rig
                A hou.AgentRig, which specifies the transform hierarchy.

            xforms
                A sequence of hou.Matrix4, with a local space transform for each
                joint in the rig. Raises hou.InvalidSize if the length does not
                match hou.AgentRig.transformCount.


        """
    @staticmethod
    def computeRotationLimits(rig: AgentRig, clips: Sequence[AgentClip], xform_idx: int, parent_xform_idx: int) -> dict[str, Any]:
        """

        computeRotationLimits(rig, clips, transform, parent_transform) -> dict
        of str to values

            Computes rotation limits for the specified joint based on the range
            of motion in the provided clips.

            The return value is a dictionary with the following keys:

          * anchor_pos: A hou.Vector3 containing the cone's anchor position.

          * rotation: A hou.Vector3 containing the cone's orientation.

          * child_rotation: A hou.Vector3 containing the child's orientation.

          * twist_limits: A hou.Vector2 containing the rotation limits for the
            twist axis.

          * up_limits: A hou.Vector2 containing the rotation limits for the up
            axis.

          * out_limits: A hou.Vector2 containing the rotation limits for the out
            axis.


            rig
                A hou.AgentRig.

            clips
                A list of hou.AgentClip.

            transform
                Index of a transform in the agent's rig.

            parent_transform
                Index of the parent transform in the agent's rig.


        """
    @staticmethod
    def shapeDeformers() -> Tuple[AgentShapeDeformer, ...]:
        """

        shapeDeformers() -> tuple of hou.AgentShapeDeformer

            Returns a list of the available shape deformers.


        """
    @staticmethod
    def findShapeDeformer(name: str) -> Optional[AgentShapeDeformer]:
        """

        findShapeDeformer(name) -> hou.AgentShapeDeformer

            Finds the shape deformer with the specified name, or None if no such
            deformer exists.


        """
    @staticmethod
    def applyUsdProcedural(stage: pxr.Usd.Stage, selection_rule: LopSelectionRule, camera_path: str, resolution: Tuple[int, int], lod_threshold: float, offscreen_quality: float, optimize_identical_poses: bool, bake_all_agents: bool, frame: float, prototype_material: str, instance_material: str, default_material: str) -> None:
        """

        applyUsdProcedural(self, stage, selection_rule, camera_path, resolution,
        lod_threshold, frame, optimize_identical_poses, bake_all_agents,
        prototype_material, instance_material, default_material)

            Applies the crowd procedural to a USD stage.

            Raises hou.OperationFailed if an error occurred when applying the
            procedural.


            stage
                The USD stage to modify.

            selection_rule
                A hou.LopSelectionRule specifying the SkelRoot instances the
                procedural should be applied to.

            camera_path
                A path to a Camera primitive in the stage to use for evaluating
                LOD.

            resolution
                A pair of integers specifying the output image's resolution.

            lod_threshold
                The threshold at which the LOD optimization will be used. The
                default value of 1.0 means that the optimization will be used
                when tolerance between the agent poses is less than
                approximately 1 pixel. Lower values can eliminate deformed
                geometry differences which might still be noticeable depending
                on the scene, but make it less likely for the LOD optimization
                to trigger and may increase the render's memory footprint.

            offscreen_quality
                Scales the approximate size of the agent in screen space for
                agents that are not directly visible to the camera. Smaller
                values will make offscreen agents more likely to become an
                instance of another agent.

            optimize_identical_poses
                A boolean value indicating whether to instance the deformed
                geometry for agents with exactly the same pose (including
                foreground agents). In most scenarios it is rare for agents to
                have identical poses (due to randomizing clip speeds, time
                offsets, etc) so this can typically be disabled to eliminate
                unnecessary computation.

            bake_prototype_agents
                A boolean value indicating whether to generate deformed geometry
                for the SkelRoot primitives that became prototypes for
                background agents. This geometry is instanced by the matching
                background agents as well as the prototype's original source
                agent.

                When turned off, the procedural only authors overrides for the
                skel:animationSource relationship to bind background agents to
                the same SkelAnimation primitive (skeleton pose) as their
                prototype agent. This produces the same final result, rendering
                background agents as instances of the prototype's deformed
                geometry, but is only supported in Hydra 2 and will not work if
                the USDIMAGINGGL_ENGINE_ENABLE_SCENE_INDEX environment variable
                is set to 0. This method can be more efficient since the
                procedural authors a smaller set of changes to the stage, and
                the deformed point positions are generated through Hydra at
                render time in the usual manner.

            bake_all_agents
                A boolean value indicating whether to generate deformed geometry
                for the remaining SkelRoot primitives that did not become an
                instance or prototype. This can be useful if the deformed
                geometry is required for subsequent procedurals. Otherwise, the
                deformed point positions for these agents will be generated
                through Hydra at render time.

            frame
                The time sample to apply the procedural at.

            prototype_material
                The path to a material to apply to SkelRoot primitives whose
                deformed geometry became a prototype for background instances.

            instance_material
                The path to a material to apply to SkelRoot primitives which
                became an instance of another SkelRoot's deformed geometry.

            default_material
                The path to a material to apply to SkelRoot primitives which
                were not modified by the crowd procedural.


        """

class DataParmTemplate(ParmTemplate):
    """

    hou.DataParmTemplate

    Describes a parameter tuple containing data values.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, num_components: int, look: EnumValue = ..., naming_scheme: EnumValue = ..., unknown_str: str|None = ..., disable_when: str|None = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: dict[str, str] = ..., unknown_dict: dict[EnumValue, str] = ..., default_expression: Sequence[str] = ..., default_expression_language: Sequence[EnumValue] = ...) -> DataParmTemplate:  # type: ignore[misc]
        """

        __init__(self, name, label, num_components, look=hou.parmLook.Regular,
        naming_scheme=hou.parmNamingScheme.XYZW, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new DataParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
    __swig_destroy__: Incomplete
    def dataParmType(self) -> EnumValue:
        """

        dataParmType(self) -> hou.dataParmType enum value

            Return the type of this data parameter. This type determines whether
            the parameter stores geometry data or a JSON map structure.

            See hou.dataParmType for more information.


        """
    def setDataParmType(self, data_type: EnumValue) -> None: ...
    def defaultExpression(self) -> Tuple[str, ...]:
        """

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.

            For example, suppose this parm template is named t, the naming
            scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
            3.0), the default expression is ($F, hou.frame(), ) and the default
            expression language is (hou.scriptLanguage.Hscript,
            hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
            corresponding parm tuple instance on a node would be named t and
            would contain parameters tx, ty, tz. When the node is created, tx
            would have a default Hscript expression of $F, ty would have a
            default Python expression of hou.frame(), and tz would have a
            default value of 3.0.


        """
    def setDefaultExpression(self, default_expression: Sequence[str]) -> None:
        """

        setDefaultExpression(self, default_expression)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.DataParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
    def defaultExpressionLanguage(self) -> Tuple[EnumValue, ...]:
        """

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: Sequence[EnumValue]) -> None:
        """

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """

class DataTree(PaneTab):
    """

    hou.DataTree

    Represents a Data Tree panetab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def treeTypes(self) -> Tuple[str, ...]:
        """

        treeTypes(self) -> tuple of str

            Returns a tuple of strings that represent the different tree types
            that can be shown in the Data Tree pane.


        """
    def treeType(self) -> str:
        """

        treeType(self) -> str

            Returns the current tree type being shown in the Data Tree. This
            function may return an empty string if no tree type has been chosen
            yet.


        """
    def setTreeType(self, tree_type: str) -> bool:
        """

        setTreeType(self, tree_type) -> bool

            Changes the tree type being displayed in the Data Tree. Valid values
            are any strings returned by the treeTypes function. Returns True if
            the tree type was successfully changed, otherwise False.


        """
    def currentPath(self) -> str:
        """

        currentPath(self) -> str

            Returns the path to the current node in the tree.


        """
    def clearCurrentPath(self) -> None:
        """

        clearCurrentPath(self) -> str

            Clears the node(s) currently selected in the tree.


        """
    def setCurrentPath(self, path: str, multi_select: bool = False, index: int = -1) -> None:
        """

        setCurrentPath(self, path, multi=False, index=-1)

            Sets the currently selected node in the tree. If the provided path
            does not match a node in the tree, the tree will still attempt to
            set the current node to the best possible match of the provided
            path.

            If multi is set to True, the previous selection will not be cleared
            before selecting the new the node. This allows multiple nodes to be
            selected in the tree.


        """
    def setCurrentPaths(self, paths: Sequence[str], expanded: bool) -> None:
        """

        setCurrentPaths(self, paths, expand)

            Selects mutliple nodes in the data tree based on the array of paths
            passed in. If the expand flag is set to True the tree nodes will be
            expanded after selection.


        """
    def setTreeExpanded(self, expanded: bool) -> None:
        """

        setTreeExpanded(self, expanded)

            Recursively sets the expanded state of the entire data tree.


        """
    def setCurrentNodeExpanded(self, expanded: bool) -> None:
        """

        setCurrentNodeExpanded(self, expanded)

            Sets the expanded state of the currently selected node in the tree.
            If there is no selected node the method has no effect on the tree.


        """

class Desktop:
    """

    hou.Desktop

    Class representing a Houdini desktop (a pane layout).

    A desktop contains one or more panes. Each pane contains one or more
    pane tabs of various types (scene viewer, parameters, network editor,
    etc.) The main desktop window can be split horizontally or vertically
    into two panes, and each pane can itself be split horizontally or
    vertically.

    Note that a floating panel also contains one or more panes and a
    floating panel may optionally be attached to a desktop.

    The methods in this class that return pane tabs, panes, and floating
    panels only return those objects that are attached to (i.e. saved with)
    the desktop. To access all the visible pane tabs, panes, and floating
    panels, including those not attached to any desktop, use the functions
    in hou.ui.

    See also hou.ui.curDesktop, hou.ui.desktops, hou.Pane, hou.PaneTab, and
    hou.FloatingPanel.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def panes(self) -> Tuple[Pane, ...]:
        """

        panes(self) -> tuple of hou.Pane

            Return the panes inside this desktop. Note that the result includes
            panes in floating panels as long as they are attached to the
            desktop.

            The following function will return all visible panes, regardless of
            whether or not they are attached to a desktop:

          > def allPanes():
          >     '''Return a tuple of all visible panes, regardless of whether or not
          >        they are attached to a desktop.'''
          >     # Loop through all the pane tabs and add each tab's pane to the result
          >     # if it's not already there.  Note that the only way to uniquely
          >     # identify a pane is using its id.
          >     ids_to_panes = {}
          >     for pane_tab in hou.ui.paneTabs():
          >         pane = pane_tab.pane()
          >         if pane.id() not in ids_to_panes:
          >             ids_to_panes[pane.id()] = pane
          >     return ids_to_panes.values()

        """
    def paneTabs(self) -> Tuple[PaneTab, ...]:
        """

        paneTabs(self) -> tuple of hou.PaneTab

            Return the pane tabs that are contained in this desktop or are in
            floating panels attached to this desktop.

            This method does not return floating pane tabs that are not attached
            to this desktop. Use hou.ui.paneTabs to get all the visible pane
            tabs, regardless of whether they are attached to this desktop.


        """
    def currentPaneTabs(self) -> Tuple[PaneTab, ...]:
        """

        currentPaneTabs(self) -> tuple of hou.PaneTab

            Return the pane tabs that are contained in this desktop or are in
            floating panels attached to this desktop and are currently selected
            in their containing panes.

            This method does not return floating pane tabs that are not attached
            to this desktop. Use hou.ui.currentPaneTabs to get all the selected
            pane tabs, regardless of whether they are attached to this desktop.


        """
    def floatingPaneTabs(self) -> Tuple[PaneTab, ...]:
        """

        floatingPaneTabs(self) -> tuple of hou.PaneTab

            Return all the pane tabs in floating panels that are attached to
            this desktop.


        """
    def paneTabOfType(self, type: EnumValue, index: int = 0) -> Optional[PaneTab]:
        """

        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return the pane tab with the desired type. If no such tab
            exists, return None. Like hou.Desktop.paneTabs, this method searches
            pane tabs in the desktop or in floating panels attached to the
            desktop.

            Use hou.ui.paneTabOfType to search all the visible pane tabs,
            regardless of whether they are attached to this desktop.


            type
                A hou.paneTabType enumerated variable.

            index
                If there are multiple tabs with the desired type, this parameter
                determines which one is returned. Use index=0 to return the
                first found tab, index=1 to return the second found tab, etc. By
                default, index is 0.

            This method can be approximately implemented as follows:

          > def paneTabOfType(self, tab_type, index=0):
          >     pane_tabs = [t for t in self.paneTabs() if t.type() == tab_type]
          > 
          >     if max(index, 0) > len(pane_tabs):
          >         return None
          >     return pane_tabs[max(index, 0)]

        """
    def findPane(self, pane_id: int) -> Optional[Pane]:
        """

        findPane(self, pane_id) -> hou.Pane or None

            Return the pane with the given unique id, or None if no such pane
            exists. Like hou.Desktop.panes, this method searches panes in the
            desktop or in floating panels attached to the desktop.

            Use hou.ui.findPane to search all the visible panes, regardless of
            whether they are attached to this desktop.


        """
    def findPaneTab(self, name: str) -> Optional[PaneTab]:
        """

        findPaneTab(self, name) -> hou.PaneTab or None

            Return the pane tab with the given name, or None if no such tab
            exists. Like hou.Desktop.paneTabs, this method searches pane tabs in
            the desktop or in floating panels attached to the desktop.

            The name may optionally be prefixed by the desktop name and a
            period.

            Use hou.ui.findPaneTab to search all the visible pane tabs,
            regardless of whether they are attached to this desktop.


        """
    def createFloatingPaneTab(self, pane_tab_type: EnumValue, position: Sequence[float] = ..., size: Sequence[float] = ..., python_panel_interface: PythonPanelInterface|None = ..., immediate: bool = ...) -> PaneTab:
        """

        createFloatingPaneTab(self, pane_tab_type, position=(), size=(),
        python_panel_interface=None, immediate=False) -> hou.PaneTab

            Create and return a new floating window containing a single pane
            tab. Note that this method creates a floating panel with a single
            pane tab, and the graphical interface to add more tabs or split the
            pane inside the panel is not exposed.


            pane_tab_type
                A hou.paneTabType enumerated variable.

            position
                A tuple of two floats specifying the X and Y positions of the
                new window, respectively. The window will open near this
                position, not necessarily exactly at this position. If this
                value is an empty tuple, Houdini will choose a default location.

            size
                A tuple of two floats specifying the width and height of the new
                window, respectively. If this value is an empty tuple, Houdini
                will choose a default size.

            python_panel_interface
                The name of the Python Panel interface to be displayed in the
                floating pane tab. Specifying the interface name additionally
                hides the Python Panel toolbar. If python_panel_interface is
                None or points to an interface that does not exist then the
                default Python Panel pane tab is displayed along with the
                toolbar.

                This argument is ignored if pane_tab_type is not set to
                hou.paneTabType.PythonPanel.

            immediate
                Open the window immediately to help setting the window position
                correctly.

            Also note that the floating panel containing the new pane tab does
            not contain any panes: calling hou.PaneTab.pane on the pane tab
            returns None, and calling hou.FloatingPanel.panes on its floating
            panel returns an empty tuple. See hou.FloatingPanel for more
            information on these stripped down floating panels.

            See also hou.Desktop.createFloatingPanel.

            The following example function takes a hou.OpNode and opens a
            floating parameter pane pinned to that node.

          > def openParmPane(node):
          >     '''Open a floating parameter pane for a particular node.'''
          >     pane_tab = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.Parm)
          >     pane_tab.setCurrentNode(node)
          >     pane_tab.setPin(True)
          >     return pane_tab

        """
    def createFloatingPane(self, pane_tab_type: EnumValue, position: Sequence[float] = ..., size: Sequence[float] = ..., python_panel_interface: PythonPanelInterface|None = ..., immediate: bool = ...) -> PaneTab: ...
    def floatingPanels(self) -> Tuple[FloatingPanel, ...]:
        """

        floatingPanels(self) -> tuple of hou.FloatingPanel

            Return all the floating panels attached to this desktop.

            Use hou.ui.floatingPanels to get all the visible floating panels,
            including those not attached to this desktop.

            See also hou.Desktop.floatingPaneTabs.


        """
    def createFloatingPanel(self, pane_tab_type: EnumValue, position: Sequence[float] = ..., size: Sequence[float] = ..., python_panel_interface: PythonPanelInterface|None = ..., immediate: bool = ...) -> FloatingPanel:
        """

        createFloatingPanel(self, pane_tab_type, position=(), size=(),
        python_panel_interface=None, immediate=False) -> hou.FloatingPanel

            Create a floating panel and return it. The returned floating panel
            contains one pane which contains one pane tab of the desired type.

            See hou.Desktop.createFloatingPaneTab for a description of the
            parameters. This method differs from createFloatingPaneTab in two
            ways: First, it returns the floating panel instead of the pane tab.
            Second, the floating panel that is created from this method is not
            locked down, and the user can add more pane tabs and split the
            panes.

            The following example creates a floating panel with a parameters
            pane tab and a channel viewer (motion viewer) pane tab:

          > panel = hou.ui.curDesktop().createFloatingPanel(hou.paneTabType.Parm)
          > pane1 = panel.panes()[0]
          > pane2 = pane1.splitVertically()
          > pane2.tabs()[0].setType(hou.paneTabType.ChannelViewer)

        """
    def paneUnderCursor(self) -> Optional[Pane]:
        """

        paneUnderCursor(self)

            Return the hou.Pane object located under the mouse cursor. Return
            None if no pane is located under the mouse cursor.

            This method does not search floating panes that are not attached to
            this desktop. Use hou.ui.paneUnderCursor to search all the visible
            panes, regardless of whether they are attached to this desktop.


        """
    def paneTabUnderCursor(self) -> Optional[PaneTab]:
        """

        paneTabUnderCursor(self)

            Similar to hou.Desktop.paneUnderCursor but return the hou.PaneTab
            object instead located under the mouse cursor. Return None if no
            pane tab is located under the mouse cursor.

            This method does not search floating pane tabs that are not attached
            to this desktop. Use hou.ui.paneTabUnderCursor to search all the
            visible pane tabs, regardless of whether they are attached to this
            desktop.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the desktop's name.

            Each desktop has a unique name. The desktop's name cannot be changed
            through either the scripting interface or through Houdini.


        """
    def shelfDock(self) -> ShelfDock:
        """

        shelfDock(self) -> hou.ShelfDock

            Return the shelf dock for the current desktop.


        """
    def displaySideHelp(self, show: bool = True) -> Optional[PaneTab]:
        """

        displaySideHelp(self, show=True) -> hou.PaneTab

            Show or hide the side help pane.

            If show is set to True (default) this method displays the help pane
            and returns a help browser pane tab. If set to False then this
            method hides the help browser pane at the side of the desktop and
            returns None.


        """
    def displayHelp(self, node_type: NodeType) -> None:
        """

        displayHelp(self, node_type)

            Loads the help for the specified node type in the last opened help
            browser pane tab. Creates a help browser pane tab if no such pane
            tab already exists.


        """
    def displayHelpPath(self, help_path: str) -> None:
        """

        displayHelpPath(self, help_path)

            Loads the help for the specified help path in the last opened help
            browser pane tab. Creates a help browser pane tab if no such pane
            tab already exists. The path can either be a Houdini help URL (i.e.
            op:Sop/copy, tool:curve) or a raw help path (i.e. /nodes/sop/copy,
            shelf/curve).


        """
    def displayHelpPyPanel(self, interface_name: str) -> None:
        """

        displayHelpPyPanel(self, interface_name)

            Loads the help for the python panel with the specified name in the
            last opened help browser pane tab. Creates a help browser pane tab
            if no such pane tab already exists.

            Raises HOM_Error if the interface name is invalid.


        """
    def setAsCurrent(self) -> None:
        """

        setAsCurrent(self)

            Make this desktop the currently selected one. See also
            hou.ui.desktops.

            This example changes to the animate desktop:

          > desktops_dict = dict((d.name(), d) for d in hou.ui.desktops())
          > desktops_dict['Animate'].setAsCurrent()

        """

class Dialog:
    """

    hou.Dialog

    Class representing a Houdini dialog.

    This class represents only dialogs created by hou.ui.createDialog.

    Custom dialogs can be created with Houdini's User Interface Script
    Language. An overview of the language can be found in the Houdini
    Development Kit (HDK) documentation, specifically in the Houdini User
    Interface -> The .ui Script Language section.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def destroy(self) -> None:
        """

        destroy(self)

            Delete this dialog.

            If you call methods on a Dialog instance after it has been
            destroyed, Houdini will raise hou.ObjectWasDeleted.


        """
    def setValue(self, name: str, value: OptionType) -> None:
        """

        setValue(self, name, value)

            Set the value of the specified UI variable.

            Raises TypeError if either name or value is None. Raises
            hou.OperationFailed if no UI variable with the specified name
            exists.


        """
    def enableValue(self, name: str, onoff: bool) -> None:
        """

        enableValue(self, name, onoff)

            Enable or disable the specified UI variable.

            Set onoff to True to enable the variable. Set onoff to False to
            disable the variable.

            Raises TypeError if either name is None. Raises hou.OperationFailed
            if no UI variable with the specified name exists.


        """
    def waitForValueToChangeTo(self, name: str, new_value: OptionType) -> None:
        """

        waitForValueToChangeTo(self, name, new_value)

            Wait for the specified UI variable to change its value to new_value.

            This is a blocking call. The method will return execution when the
            variable has changed to the desired value. Note that Houdini will
            remain responsive even when this method is blocked waiting.

            If the variable's current value is already set to new_value then
            this method will return immediately.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
    def menuItems(self, name: str) -> Tuple[str, ...]:
        """

        menuItems(self, name) -> tuple of str

            Return the menu entries for the specified UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists. Raises
            hou.OperationFailed if the UI variable does not point to a menu.


        """
    def setMenuItems(self, name: str, items: Sequence[str]) -> None:
        """

        setMenuItems(self, name, items)

            Set the menu entries in the specified UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists. Raises
            hou.OperationFailed if the UI variable does not point to a menu.


        """
    def value(self, name: str) -> OptionType:
        """

        value(self, name)

            Return the value of the given UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
    def addCallback(self, name: str, callback: Callable[[], None]) -> None:
        """

        addCallback(self, name, callback)

            Register a callback function for the specified UI variable.

            The function is invoked when the value of the UI variable changes
            and receives no arguments.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """
    def removeCallback(self, name: str, callback: Callable[[], None]) -> None:
        """

        removeCallback(self, name, callback)

            Remove the specified callback function from the UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists. Raises
            hou.OperationFailed if the specified callback is not registered with
            the UI variable.


        """
    def callbacks(self, name: str) -> Tuple[Callable[[], None],...]:
        """

        callbacks(self, name) -> tuple of callbacks

            Return all callback functions registered with the given UI variable.

            Raises TypeError if name is None. Raises hou.OperationFailed if no
            UI variable with the specified name exists.


        """

class dop:
    """

    hou.dop

    DOP related functions.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def isScriptSolverRunning() -> bool:
        """

        isScriptSolverRunning() -> bool

            Return whether or not a Python script solver DOP is currently
            running.

            This function is called from the Python code that is automatically
            generated when you create a new Python solver DOP type.


        """
    @staticmethod
    def scriptSolverData() -> Optional[DopData]:
        """

        scriptSolverData() -> hou.DopData

            Return the solver solver data corresponding to the currently running
            Python script solver DOP.

            A Python script solver DOP runs in two passes. During the first
            pass, it evaluates its node parameters and stores them in the solver
            data. During this pass, hou.dop.isScriptSolverRunning returns False
            and you can access a writable version of the script solver data with
            hou.DopNode.pythonSolverData. During the second pass the solver is
            invoked to actually solve the objects. During this pass,
            hou.dop.isScriptSolverRunning returns True and you use this function
            to access a read-only version of the script solver data. You can
            access the objects being solved in this pass with
            hou.dop.scriptSolverNewObjects and hou.dop.scriptSolverObjects.

            DOP nodes attach data named Solver to each of the DOP objects being
            solved. If the only solver in use is the script solver, this data
            will be of type SIM_SolverScript. Otherwise, this data will be of
            type SIM_SolverMulti, and the SIM_SolverScript will be subdata of
            the multisolver data. This function provides an easy way of
            retrieving this data, regardless of where it exists.

            Typically, the solver data is shared between all the objects being
            solved. For this reason, the data returned by this function is read-
            only. Otherwise, if you modified this data, the DOP engine would
            copy it and the objects being solved would not share this data.


        """
    @staticmethod
    def scriptSolverNetwork() -> OpNode | None:
        """

        scriptSolverNetwork() -> hou.OpNode or None

            Return the DOP network node that contains the script solver DOP that
            is currently running, or None if not script solver is running. You
            would call this function from a script solver DOP.


        """
    @staticmethod
    def scriptSolverSimulation() -> Optional[DopSimulation]: ...
    @staticmethod
    def scriptSolverObjects() -> Tuple[DopData, ...]:
        """

        scriptSolverObjects() -> tuple of hou.DopObject

            Return a tuple of DOP objects being solved by the current script
            solver DOP. If no script solver is running, returns an empty tuple.


        """
    @staticmethod
    def scriptSolverNewObjects() -> Tuple[DopData, ...]:
        """

        scriptSolverNewObjects() -> tuple of hou.DopObject

            Return a tuple of newly-created DOP objects to later be solved by
            the current script solver DOP. If no script solver is running,
            returns an empty tuple.


        """
    @staticmethod
    def scriptSolverTimestepSize() -> float:
        """

        scriptSolverTimestepSize() -> float

            Return the timestep size for the script solver that is currently
            running, or 0.0 if no script solver is running.


        """
    @staticmethod
    def scriptSolverTime() -> float: ...

class DopNode(OpNode):
    """

    hou.DopNode

    Represents a dynamics node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def dopNetNode(self) -> OpNode:
        """

        dopNetNode(self) -> hou.OpNode

            Return the DOP network node that contains this DOP node.


        """
    def simulation(self) -> DopSimulation:
        """

        simulation(self) -> hou.DopSimulation

            Return the simulation that this node contributes to. This method is
            a shortcut for self.dopNetNode().simulation().


        """
    def processedObjects(self) -> Tuple[DopObject, ...]:
        """

        processedObjects(self) -> tuple of hou.DopObject

            Return a tuple of DOP objects that this DOP node processes.


        """
    def createdObjects(self) -> Tuple[DopObject, ...]:
        """

        createdObjects(self) -> tuple of hou.DopObject

            Return a tuple of DOP objects that this DOP node creates.


        """
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns whether the node's bypass flag is on.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turn the node's bypass flag on or off, making this node have no
            effect.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Return whether this node's display flag is on. This is the orange
            Output flag in the interface.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turn the node's display flag on or off. This the orange Output flag
            in the interface.


        """
    def isTemplateFlagSet(self) -> bool:
        """

        isTemplateFlagSet(self) -> bool

            Returns whether this node's template flag is on. This is the brown
            Hidden flag in the interface.


        """
    def setTemplateFlag(self, on: bool) -> None:
        """

        setTemplateFlag(self, on)

            Turns this node's template flag on or off. This is the brown Hidden
            flag in the interface.


        """
    def displayNode(self) -> OpNode | None:
        """

        displayNode(self) -> hou.OpNode or None

            If this node is a subnet (i.e. it contains child nodes), return the
            child that has its display flag set, or None if there are no
            children. Otherwise, return None.


        """
    def renderNode(self) -> OpNode | None: ...
    def objectsToProcess(self) -> Tuple[DopObject, ...]:
        """

        objectsToProcess(self) -> tuple of hou.DopObject

            Return a tuple of DOP objects that this node should process. Raises
            hou.PermissionError if called from outside a DOP implemented in
            Python.


        """
    def pythonSolverData(self) -> DopData:
        """

        pythonSolverData(self) -> hou.DopData

            If this node is a Python DOP solver, return the solver data added to
            the DOP network by this node. Otherwise, raises hou.PermissionError.

            This method is called from Python DOP solvers when the solver is not
            running, to copy data from the DOP parameters into the solver data.

            See also hou.dop.scriptSolverData.


        """

class DopObject(DopData):
    """

    hou.DopObject

    A type of DOP data that contains an object in the simulation.

    This object might be a rigid body, a fluid, cloth, etc. The type and
    properties of the DOP object are determined by the subdata attached to
    the object.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of this DOP object.


        """
    def objid(self) -> int:
        '''

        objid(self) -> int

            Return the index of this object in the output from
            hou.DopSimulation.objects. This method is a shortcut for
            self.options().field(\\"objid\\").

            See hou.DopData.id for an example.

            Some fields in DOP records store an objid to refer to other objects.
            The following function looks up an object by objid:

          > def findObjectByObjid(dopnet_node, objid):
          >     return dopnet_node.simulation().objects()[objid]

        '''
    def matches(self, pattern: str) -> bool:
        '''

        matches(self, pattern) -> bool

            Return whether or not this object\'s name matches a pattern. * will
            match any number of characters and ? will match any single
            character. The pattern string contains only one pattern, so spaces
            in the pattern will be compared against the object name.

          > >>> obj = hou.node(\\"/obj/AutoDopNetwork\\").simulation().objects()[0]
          > >>> obj.name()
          > \'box_object1\'
          > >>> obj.matches(\\"box*\\")
          > True
          > >>> obj.matches(\\"c*\\")
          > False
          > >>> obj.matches(\\"box* b*\\")
          > False
          > >>> obj.matches(\\"b?x_object1\\")
          > True

        '''
    def transform(self, include_geometry_transform: bool = True) -> Matrix4:
        '''

        transform(self, include_geometry_transform=True) -> hou.Matrix4

            Return the transformation matrix for this object. If
            include_geometry_transform is False, the result is determined only
            by the object\'s Position data. Otherwise, it is the transform in the
            object\'s Geometry data, followed by the position transform.

            For simple DopData types, this method can be approximately
            implemented as follows:

          > def transform(self, include_geometry_transform=True):
          >     result = hou.hmath.identityTransform()
          > 
          >     geometry = self.findSubData(\\"Geometry\\")
          >     if include_geometry_transform and geometry is not None:
          >         result *= geometry.record(\\"Transform\\").field(\\"transform\\")
          > 
          >     # Retrieve the position.  If there is Geometry data, use its
          >     # positionpath field to get the SIM_Position subdata.  If not, look
          >     # for data named Position.
          >     position = None
          >     if geometry is not None:
          >         position = geometry.findSubData(
          >             geometry.options().field(\\"positionpath\\"))
          >     if position is None:
          >         position = self.findSubData(\\"Position\\")
          > 
          >     # If we found position data, build a transformation from the pivot,
          >     # rotation quaternion, and translate.
          >     if position is not None:
          >         options = position.options()
          >         rotation = hou.Matrix4(options.field(\\"orient\\").extractRotationMatrix3())
          >         result *= (hou.hmath.buildTranslate(-options.field(\\"p\\")) *
          >             rotation *
          >             hou.hmath.buildTranslate(options.field(\\"p\\")) *
          >             hou.hmath.buildTranslate(options.field(\\"t\\")))
          > 
          >     return result

        '''

class DopRecord:
    """

    hou.DopRecord

    A table of values stored inside a DopData.

    See hou.DopData for a description of DOP data, records, and fields.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def recordType(self) -> str:
        """

        recordType(self) -> str

            Return the name of this record. See hou.DopData.recordTypes for more
            information.


        """
    def recordIndex(self) -> int:
        """

        recordIndex(self) -> int

            Return the index of this record. See hou.DopData.record and
            hou.DopData.records for more information.


        """
    def fieldNames(self) -> Tuple[str, ...]:
        """

        fieldNames(self) -> tuple of str

            Return the names of all the fields inside this record. See
            hou.DopRecord.field for an example.


        """
    def fieldType(self, field_name: str) -> EnumValue:
        """

        fieldType(self, field_name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in a field. Returns hou.fieldType.NoSuchField if no
            field exists with that name.

            See hou.DopRecord.field for an example.


        """
    def field(self, field_name: str) -> OptionType:
        '''

        field(self) -> int, bool, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, or hou.Matrix4

            Return the value of a field inside this record, or None if no such
            field exists.

            Note that you can add the suffixes x, y, and z to a vector field\'s
            name to access the individual float values.

          > # The following code assumes you have created a box from the shelf and used
          > # Rigid Bodies > RBD Object on the shelf to make it a rigid body.
          > >>> record = hou.node(\\"/obj/AutoDopNetwork\\").simulation().findData(\\"box_object1/Forces/Gravity_gravity1\\").options()
          > >>> record.fieldNames()
          > (\'force\', \'handlepos\')
          > >>> record.field(\\"force\\")
          > <hou.Vector3 [0, -9.80665, 0]>
          > >>> record.field(\\"forcey\\")
          > -9.8066501617431641
          > >>> record.fieldType(\\"force\\")
          > fieldType.Vector3
          > >>> record.fieldType(\\"forcey\\")
          > fieldType.Float

            This example function creates a dict out of a record:

          > def recordAsDict(record):
          >     return dict((field_name, record.field(field_name))
          >         for field_name in record.fieldNames())

            The following function returns the geometry transform of an object:

          > def dopGeometryTransform(dopnet_node, object_name):
          >     subdata = dopnet_node.simulation().findObject(object_name).findSubData(\\"Geometry\\")
          >     return subdata.record(\\"Transform\\").field(\\"transform\\")

        '''
    def setFieldBool(self, field_name: str, value: bool) -> None:
        """

        setFieldBool(self, field_name, value)

            Set a field to the specified boolean value. You would call this
            method from a script solver DOP.

            To set a field to a different type, use hou.DopRecord.setField.

            Raises hou.PermissionError if called from outside a script solver
            DOP.


        """
    def setField(self, field_name: str, value: OptionType) -> None:
        """

        setField(self, field_name, value)

            Set a field to the specified value. You would call this method from
            a script solver DOP. value may be an int, float, str, hou.Vector2,
            hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, or
            hou.Matrix4.

            Unfortunately, this method cannot be used to set a field to a
            boolean (True or False) value. If you pass a boolean to this method,
            it will set the field to the integer 1 or 0. To properly set it to a
            boolean value, use hou.DopRecord.setFieldBool.

            Raises hou.PermissionError if called from outside a script solver
            DOP.


        """

class DopRelationship(DopData):
    """

    hou.DopRelationship

    A type of DOP data that stores which DOP objects affect one another.

    In addition to the Basic and Options records, a DopRelationship contains
    ObjInAffectors and ObjInGroup records. The former contains the objects
    doing the affecting and the latter contains the objects being affected.

    See hou.DopSimulation.relationships for an example.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of this DOP relationship.


        """
    def matches(self, pattern: str) -> bool:
        """

        matches(self, pattern) -> bool

            Return whether or not this relationship's name matches a pattern.
            See hou.DopObject.matches for more information.


        """
    def setGroup(self, objects: Sequence[DopObject]) -> None:
        """

        setGroup(self, objects)

            Sets the list of objects that are being affected. This corresponds
            to the ObjInGroup record.

            objects: A list of DOP objects.

            Raises hou.PermissionError if called from outside a Python DOP.


        """
    def setAffectorGroup(self, objects: Sequence[DopObject]) -> None:
        """

        setAffectorGroup(self, objects)

            Sets the list of objects that are doing the affecting. This
            corresponds to the ObjInAffectors record.

            objects: A list of DOP objects.

            Raises hou.PermissionError if called from outside a Python DOP.


        """
    def relationshipTypeData(self) -> Optional[DopData]:
        """

        relationshipTypeData(self) -> hou.DopData or None

            Returns the subdata that defines the relationship type.


        """

class DopSimulation:
    """

    hou.DopSimulation

    A dynamics simulation contained inside a DOP network node.

    See hou.DopData for more information about the contents of a DOP
    simulation. Note that methods of this class implicitly use the
    simulation data from the current frame.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__()

            Creates a new simulation, which is not associated with a node. Use
            hou.DopNode.simulation to access a DOP network's simulation.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def createObject(self, name: str, solve_on_creation_frame: bool) -> Optional[DopData]:
        """

        createObject(self, name, solve_on_creation_frame) -> hou.DopObject

            Create and return a new DOP object, or return None if the object was
            not created successfully.


            name
                The name of the new object.

            solve_on_creation_frame
                If True, the object will be solved on its first frame of
                existence.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).

            Use hou.DopData.copyContentsFrom to clone data from an existing
            object.


        """
    def removeObject(self, obj: DopObject) -> None:
        """

        removeObject(self, object)

            Remove the given DOP object from the simulation.


            object
                The hou.DopObject to remove.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).


        """
    def createRelationship(self, name: str) -> Optional[DopData]:
        """

        createRelationship(self, name) -> hou.DopRelationship

            Create and return a new DOP relationship, or return None if the
            relationship was not created successfully.


            name
                The name of the new relationship.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).

            Use hou.DopData.copyContentsFrom to clone data from an existing
            relationship, and use hou.DopRelationship.setGroup and
            hou.DopRelationship.setAffectorGroup to update the ObjInGroup and
            ObjInAffectors records.


        """
    def removeRelationship(self, rel: DopRelationship) -> None:
        """

        removeRelationship(self, rel)

            Remove the given DOP relationship from the simulation.


            rel
                The hou.DopRelationship to remove.

            Raises hou.PermissionError if the simulation cannot be modified
            (e.g. called from outside a Python DOP).


        """
    def dopNetNode(self) -> Node:
        """

        dopNetNode(self) -> hou.OpNode

            Return the DOP network node containing this simulation.


        """
    def objects(self) -> Tuple[DopData, ...]:
        """

        objects(self) -> tuple of hou.DopData

            Return a tuple of all the DOP objects in the simulation.

            You cannot index into this list using the object ID (see
            hou.DopObject.objid). To create a dictionary mapping object IDs to
            hou.DopObjects, do this:

          > id_dict = dict((obj.objid(), obj) for obj in simulation.objects())

        """
    def relationships(self) -> Tuple[DopData, ...]:
        '''

        relationships(self) -> tuple of hou.DopRelationship

            Return a tuple of hou.DopRelationship objects for all the DOP
            relationships in the simulation.

          > # The following example assumes you have created two box objects and made
          > # them rigid bodies.
          > >>> simulation = hou.node(\\"/obj/AutoDopNetwork\\").simulation()
          > >>> relationship = simulation.relationships()[1]
          > >>> affecting_objects = [
          > ...     simulation.objects()[record.field(\\"objid\\")]
          > ...     for record in relationship.records(\\"ObjInAffectors\\")]
          > >>> [obj.name() for obj in affecting_objects]
          > [\'box_object1\']
          > >>> affected_objects = [
          > ...     simulation.objects()[record.field(\\"objid\\")]
          > ...     for record in relationship.records(\\"ObjInGroup\\")]
          > >>> [obj.name() for obj in affected_objects]
          > [\'box_object2\']

        '''
    def findObject(self, obj_spec: str) -> Optional[DopData]:
        """

        findObject(self, obj_spec) -> hou.DopObject or None

            Return the DOP object with the given name, or None if no object
            exists with that name. See also hou.DopSimulation.findData and
            hou.DopSimulation.objects.


        """
    def findRelationship(self, rel_spec: str) -> Optional[DopData]:
        """

        findRelationship(self, rel_spec) -> hou.DopRelationship

            Find a DOP relationship by name. Return None if no such relationship
            with that name exists. See also hou.DopSimulation.relationships.


        """
    def findData(self, data_spec: str) -> Optional[DopData]:
        """

        findData(self, data_spec) -> hou.DopData or None

            Return the DOP data with the given name. Note that the name may also
            be a slash-separated path to nested subdata.

            If the data path refers to a DOP object, this method returns a
            hou.DopObject instance. If it refers to a DOP relationship, it
            returns a hou.DopRelationship instance. Otherwise, it returns a
            hou.DopData instance.

            Note this method implicitly uses the simulation data from the
            current frame.

            See also hou.DopData.findSubData.


        """
    def findAllObjects(self, obj_spec: str) -> Tuple[DopData, ...]:
        '''

        findAllObjects(self, obj_spec) -> tuple of hou.DopObject

            Given a pattern, return a tuple of DOP objects whose names match the
            pattern.

          > >>> simulation = hou.node(\\"/obj/AutoDopNetwork\\").simulation()
          > >>> [obj.name() for obj in simulation.findAllObjects(\\"box_object?\\")]
          > [\'box_object1\', \'box_object2\']
          > >>> [obj.name() for obj in simulation.findAllObjects(\\"o* b*\\")]
          > [\'obj1\', \'obj2\', \'box_object1\', \'box_object2\']

        '''
    def findAllRelationships(self, rel_spec: str) -> Tuple[DopData, ...]:
        """

        findAllRelationships(self, rel_spec) -> tuple of hou.DopRelationship

            Return a tuple of hou.DopRelationship objects whose names match a
            pattern. See also hou.DopSimulation.relationships and
            hou.DopSimulation.findRelationship.


        """
    def findAllData(self, data_spec: str) -> Tuple[DopData, ...]:
        """

        findAllData(self, data_spec) -> tuple of hou.DopData

            Given a pattern, return a tuple of DOP data whose names match the
            pattern. See also hou.DopSimulation.findData.


        """
    def time(self) -> float:
        """

        time(self)

            Return the simulation's current time. This value is often the same
            as hou.time, unless it is called from a Python solver DOP or the
            Time Scale or Offset Time parameters of the DOP network have been
            changed from their default values.


        """
    def setTime(self, t: float, resim_last_timestep: bool = False, force_reset_sim: bool = False, allow_simulation: bool = True) -> None:
        """

        setTime(self, t, resim_last_timestep=False, force_reset_sim=False,
        allow_simulation=True)

            Sets the simulation's current time.


            resim_last_timestep
                Deletes the most recent simulation cache entry before setting
                the current time.

            force_reset_sim
                Resets the simulation before moving to the specified time.

            allow_simulation
                Specifies whether simulation is enabled when moving to the
                specified time.

            Raises hou.PermissionError if the simulation cannot be modified. If
            the simulation is owned by a DOP network, the simulation time should
            be changed through the playbar.


        """
    def timestep(self) -> float:
        """

        timestep(self)

            Returns the length of a simulation timestep.


        """
    def setTimestep(self, t: float) -> None:
        """

        setTimestep(self, t)

            Sets the length of a simulation timestep.

            Raises hou.PermissionError if the simulation cannot be modified. If
            the simulation is owned by a DOP network, the timestep should be set
            through the node's parameters.


        """
    def memoryUsage(self) -> int:
        """

        memoryUsage(self)

            Return the simulation's total memory usage.


        """

class Drawable:
    """

    hou.Drawable

    The base class for drawables.

    This class provides a common interface to all drawable classes.

    TIPS AND NOTES

      * Houdini supports various drawables such as hou.SimpleDrawable,
        hou.GeometryDrawable and hou.TextDrawable.

      * hou.SimpleDrawable and hou.GeometryDrawable represent extra geometry
        to draw in the viewer alongside user content (for example, as guide
        geometry).

      * hou.SimpleDrawable is the most basic Houdini drawable class, it is
        easy to use as you just need to attach a geometry, enable it and
        Houdini will take care of drawing the geometry.

      * hou.GeometryDrawable, hou.GadgetDrawable and
        hou.GeometryDrawableGroup also draw guide geometries but provide an
        API with advanced drawing capabilities.

      * hou.GadgetDrawable is similar to hou.GeometryDrawable but also
        allows you to identify located and picked geometries.

      * hou.TextDrawable draws text in the viewport.

      * hou.Drawable2D can draw shape entities in both compositing and scene
        viewers within a 2D context.

      * Drawables are mostly used with custom python states, you will
        generally store a reference to drawable objects on the state
        implementation object.

      * When you create a drawable object, it is hidden. You need to call
        show(True) for the attached element to appear. hou.SimpleDrawable
        requires an extra call to hou.SimpleDrawable.enable for the geometry
        to appear.

      * The drawable element will appear in the viewer until the drawable
        object is hidden or deleted. If there are no references to the
        object, Python will automatically delete it during garbage
        collection, and the attached element will disappear. So, you need to
        make sure to keep a live reference to the object as long as you want
        it to appear.

    RELATED

      * hou.AdvancedDrawable

      * hou.Drawable2D

      * hou.GadgetDrawable

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable

      * hou.TextDrawable


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self)

            The name of this drawable.


        """
    def label(self) -> str:
        """

        label(self)

            The label of this drawable.


        """
    def show(self, value: bool) -> None:
        """

        show(self, value)

            Displays or hides the element attached to this drawable in the
            viewport. The element will appear the next time the viewer redraws.


            value
                True to show the element or False to hide it.


        """
    def visible(self) -> bool:
        """

        visible(self) -> bool

            Returns True if the drawable is visible or not.


        """
    def transform(self) -> Matrix4:
        """

        transform(self): -> hou.Matrix4

            Returns the transform matrix of the element attached to the
            drawable.


        """
    def setTransform(self, xform: Matrix4) -> None:
        """

        setTransform(self, xform)

            Sets the transform matrix of the element attached to this drawable.
            The changes will appear the next time the viewer redraws.


            xform
                A hou.Matrix4 transformation matrix to set the element's
                translation, rotation, and scale.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self, label)

            Set the label for this drawable.


        """
    def setIsControl(self, is_control: bool) -> None:
        """

        setIsControl(self, value)

            Flags the drawable as control geometry. Simple Drawables are not
            affected by certain shading modes nor will they have decorations or
            visualizers drawn for it. They will be hidden when the Node Guides
            display option is off.


            NOTE
                This method does not apply to hou.Drawable2D objects.


        """
    def isControl(self) -> bool:
        """

        isControl(self): -> bool

            Query if a drawable has been flaged as control geometry.


        """

class Drawable2D(Drawable):
    """

    hou.Drawable2D

    Drawable for drawing 2D entities.

    OVERVIEW

        The hou.Drawable2D API provides a unified solution for drawing shape
        entities in both compositing and scene viewers within a 2D context.
        It supports rendering of various geometric primitives, from simple
        lines to complex freeform shapes, as either wireframes or filled
        areas. Full picking and locating functionality is integrated across
        both viewer types.


        NOTE
            hou.Drawable2D shape entities are constrained to the XY plane
            (z=0) in Front and Perspective views. Primarily intended for COP
            Python states and handles, they can also be utilized in other
            contexts like SOPs and LOPs. A current limitation prevents the
            concurrent use of hou.Drawable2D and hou.GeometryDrawable.


    """
    thisown: Incomplete
    def __init__(self, scene_viewer: SceneViewer|CompositorViewer, type: EnumValue, name: str, label: str|None = ..., pickable: bool = ..., params: dict[str, Any]|None = ...) -> None:
        """

        __init__(self, scene_viewer, type, name, label=None, pickable=False,
        params=None)

            Creates a new drawable object of a specified type. The newly created
            drawable is initially hidden.


            WARNING
                hou.Drawable2D objects must be created within the onEnter event
                of a Python state or Python handle. Creating them outside of
                this context may lead to unexpected behavior or the drawable not
                functioning correctly.


            scene_viewer
                A reference to the viewer where the drawable will be displayed,
                either a hou.SceneViewer or hou.CompositorViewer.

            type
                A hou.drawable2DType value indicating the type of drawable to
                create (e.g., Arc, Line, Shape).

            name
                A string used to uniquely identify this drawable object.

            label
                An optional string to set a display label for the drawable.
                Defaults to an empty string.

            pickable
                A boolean value indicating whether the drawable can be picked
                and located. Set to False to disable interaction. Defaults to
                True.

            params
                An optional dictionary containing parameters to configure the
                drawable's appearance and behavior. See hou.Drawable2D.setParams
                for a detailed list of available parameters for each drawable
                type.


        """
    __swig_destroy__: Incomplete
    def setParams(self, params: dict[str, Any]) -> None:
        """

        setParams(self, params)

            Sets the parameters of the drawable entity using a dictionary. The
            params dictionary can include attributes common to all drawable
            types (e.g., position, color) and those specific to the drawable's
            type (e.g., radius for an Arc, points for a Line or Shape).

            Common parameters available for each drawable type:

            color
            The main color of the drawable, as an RGB or RGBA value.

            Sequence of 3 or 4 ints or doubles, hou.Color. Defaults to
            hou.Color(1, 1, 1, 1).

            locate_color
            The locate color (or highlight) of the drawable, as an RGB or RGBA
            value.

            Sequence of 3 or 4 ints or doubles, hou.Color. Defaults to
            hou.Color(0, 0, 0, 0).

            Specific parameters for each drawable type:

            end_angle
            The ending angle of the arc in degrees.

            int or double. Defaults to 0.0

            end_cap
            The cap style at the end of the arc.

            hou.drawable2DCapStyle. Defaults to hou.drawable2DCapStyle.Butt.

            end_cap_color
            The end cap color, as an RGB or RGBA value.

            Array of 3 or 4 ints or doubles, hou.Color. Defaults to hou.Color(0,
            0, 0, 1).

            fill
            Whether to fill the arc area.

            int or bool. Defaults to False.

            inner_radius
            The inner radius of the arc.

            int or double. Defaults to 0.

            position
            The position where the entity is placed in the viewer (XY plane).

            Array of 2 ints or doubles, hou.Vector2. Defaults to
            hou.Vector2(0,0).

            radius
            The radius of the arc.

            int or double. Defaults to 0.5.

            start_angle
            The starting angle of the arc in degrees.

            int or double. Defaults to 0.

            start_cap
            The cap style at the start of the arc.

            hou.drawable2DCapStyle. Defaults to hou.drawable2DCapStyle.Butt.

            start_cap_color
            The start cap color, as an RGB or RGBA value.

            Array of 3 or 4 ints or doubles, hou.Color. Defaults to hou.Color(0,
            0, 0, 1).

            thickness
            The arc thickness value (1 to 5)

            int, double. Defaults to 2

            Circle
            Description
            Type
            fill
            Whether to fill the circle area.

            int or bool. Defaults to False.

            inner_radius
            The inner radius of the circle.

            int or double. Defaults to 0.

            position
            The position where the entity is placed in the viewer (XY plane).

            Array of 2 ints or doubles, hou.Vector2. Defaults to
            hou.Vector2(0,0).

            radius
            The radius of the circle.

            int or double. Defaults to 0.5.

            thickness
            The circle thickness value (1 to 5)

            int, double. Defaults to 2.

            Line
            Description
            Type
            end_cap
            The cap style at the end of the arc.

            hou.drawable2DCapStyle. Defaults to hou.drawable2DCapStyle.Butt.

            end_cap_color
            The end cap color, as an RGB or RGBA value.

            Array of 3 or 4 ints or doubles, hou.Color. Defaults to hou.Color(0,
            0, 0, 1).

            points
            An array containing the points defining the line. The first two
            values describe the starting point (x0, y0), and the next two
            describe the ending point (x1, y1).

            Array of 4 ints or doubles. Defaults to [0, 0, 1, 0].

            start_cap
            The cap style at the start of the line.

            hou.drawable2DCapStyle. Defaults to hou.drawable2DCapStyle.Butt.

            start_cap_color
            The start cap color, as an RGB or RGBA value.

            Array of 3 or 4 ints or doubles, hou.Color. Defaults to hou.Color(0,
            0, 0, 1).

            style
            The style of a line drawable.

            hou.drawable2DLineStyle. Defaults to hou.drawable2DLineStyle.Solid`.

            thickness
            The line thickness value (1 to 5)

            int, double. Defaults to 2.

            Marker
            Description
            Type
            position
            The position where the entity is placed in the viewer (XY plane).

            Array of 2 ints or doubles, hou.Vector2. Defaults to
            hou.Vector2(0,0).

            size
            Enumerator value to set the size of the marker.

            hou.drawable2DMarkerSize. Defaults to
            hou.drawable2DMarkerSize.Small.

            thickness
            The marker thickness value (1 to 5)

            int, double. Defaults to 2.

            style
            The style of marker.

            hou.drawable2DMarkerStyle. Defaults to
            hou.drawable2DMarkerStyle.Cross.

            Rect
            Description
            Type
            radius
            Corner radius parameter for rounded corners.

            int or double. Defaults to 0.

            fill
            Whether to fill the rectangle area.

            int or bool. Defaults to False.

            position
            The position where the entity is placed in the viewer (XY plane).

            Array of 2 ints or doubles, hou.Vector2. Defaults to
            hou.Vector2(0,0).

            size
            Sets the width and height of the rectangle. Pass a single value for
            a square.

            int, double, Array of 2 ints or doubles, hou.Vector2. Defaults to
            hou.Vector2(0.5,0.5).

            thickness
            The rectangle thickness value (1 to 5)

            int, double. Defaults to 2.

            Shape
            Description
            Type
            close
            If True, an extra vertex is automatically added to connect the last
            and first points, closing the shape.

            int or bool. Defaults to False.

            points

            The vertices describing the shape, defined as a flattened sequence
            of point coordinates (e.g., x0, y0, x1, y1, ...).

            thickness
            The shape thickness value (1 to 5)

            int, double. Defaults to 2.

            Text
            Description
            Type
            position
            The position where the entity is placed in the viewer (XY plane).

            Sequence of 2 ints or doubles, hou.Vector2. Defaults to
            hou.Vector2(0,0).

            size
            The text font size.

            int or double. Defaults to 11.

            text
            The text value.

            string


        """
    def params(self) -> dict[str, Any]:
        """

        params(self) -> dict[str, Any]

            Returns the parameter dictionary currently stored in a
            hou.Drawable2D object. See hou.Drawable2D.setParams for details on
            the dictionary's contents.


        """
    def draw(self, handle: Handle, params: dict[str, Any]|None = ...) -> None:
        """

        draw(self, handle, params=None)

            Draws the drawable in a viewport. This method is typically called
            during the Python state's onDraw or onDrawInterrupt event to render
            the drawable in the current viewport.


            handle
                An opaque identifier generated by Houdini for rendering the
                drawable. This handle value is provided to the Python state's
                onDraw callback and should be passed directly to this draw
                method of the drawable object.

            params
                An optional dictionary of parameters to override the drawable's
                current settings specifically for this draw call. These
                parameters are the same as those used by
                hou.Drawable2D.setParams.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.drawable2DType

            Returns the type of this drawable.


        """
    def setPickable(self, value: bool) -> None:
        """

        setPickable(self, value)

            Sets whether this drawable can be picked and located by user
            interactions.


            value
                A boolean value. Set to True to enable picking and locating for
                this drawable. Set to False to disable interaction.


        """
    def isPickable(self) -> bool:
        """

        isPickable(self) -> bool

            Returns True if this drawable is currently enabled for picking and
            locating, False otherwise.


        """
    def mapToModel(self, x: float, y: float, z: float = 0) -> Vector3:
        """

        mapToModel(self, x, y, z=0) -> hou.Vector3

            Maps a screen-space mouse position (x, y, z) to a corresponding
            point in the drawable's local model space. This is particularly
            useful for positioning and interacting with 2D drawables within both
            2D and 3D viewports.


            NOTE
                The z parameter is often 0 for interactions constrained to the
                2D plane.

            Returns a hou.Vector3 representing the mapped point in the
            drawable's model space.


            x
                The mouse's X-coordinate in screen space.

            y
                The mouse's Y-coordinate in screen space.

            z
                The mouse's Z-coordinate in screen space (typically 0 for 2D
                drawables).


        """

class AdvancedDrawable(Drawable):
    """

    hou.AdvancedDrawable

    The base class for advanced drawables.

    This base class provides a common interface for drawables such as
    hou.GeometryDrawable and hou.TextDrawable. These are advanced drawables
    used by custom python states for drawing text and guide geometries in
    the viewport and, to convey visual information from the state to the
    user.

    RELATED

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable

      * hou.TextDrawable


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def setParams(self, params: Mapping[str, Any]|None = ...) -> None:
        """

        setParams(self, params)

            Sets the parameters of the drawable. The settings will take effect
            in the viewport the next time hou.AdvancedDrawable.draw is called.


            params
                A dictionary of parameters for setting the drawable options.
                Each drawable type uses a specific set of parameters, detailed
                information can be found in the drawable derived class params
                documentation such as GeometryDrawable and TextDrawable.

                The following are parameters common to all hou.AdvancedDrawable
                types:

                color1
                hou.Vector4

                Vector representing an rgba value used as the main color of a
                drawable. This color is multiplied by the overlay stencil colors
                at the time of compositing. The default value is hou.Vector4(1,
                1, 1, 1).

                For hou.TextDrawable, color1 is the default foreground color for
                drawing the text.

                color2
                hou.Vector4

                Vector representing an rgba value for setting the glow color
                around the drawable generated matte. Defaults to hou.Vector4(0,
                0, 0, 0.25).

                For instance, color2 can be used for drawing a glow around the
                generated matte for a face or point drawable.

                fade_factor
                double

                Value used as the occlusion factor of the overlay in areas
                occluded by the existing geometry as determined by the depth
                buffer. A fade factor of 1.0 means no distinction must be made
                and a value of 0.0 completely hides occluded parts. Defaults to
                0.

                glow_width
                int

                Sets the glow width value. For instance, this changes the glow
                width of line segments or text. Defaults to 0.

                highlight_mode
                hou.drawableHighlightMode

                Sets the mode for highlighting the generated matte of the
                drawable. Defaults to hou.drawableHighlightMode.Matte.

                translate
                hou.Vector3 or sequence of 3 doubles

                Position of the geometry in 3D space.

                For hou.TextDrawable, it's the position of the text to display
                in viewport coordinates.

                Defaults to hou.Vector3(0, 0, 0).

                rotation
                hou.Vector3 or sequence of 3 doubles

                Rotation vector in degrees. Defaults to hou.Vector3(0, 0, 0).

                scale
                hou.Vector3 or sequence of 3 doubles

                Scaling vector. Defaults to hou.Vector3(1, 1, 1).

                screen_space
                Sequence of doubles or ints

                Assigns a 2D window to the viewport, in viewport coordinates,
                for drawing a geometry. The sequence defines the location and
                size of the window, and must contain the following values:

              * X position (defaults to 0)

              * Y position (defaults to 0)

              * Width (defaults to 0)

              * Height (defaults to 0)

              * X margin (defaults to 0)

              * Y margin (defaults to 0)

                use_cd
                Bool

                Specifies if the drawable should use the Cd attribute of the
                attached geometry (if any). If an Alpha attribute exists, the
                drawable will use it as well. Defaults to True.

                use_uv
                Bool

                Specifies if the drawable should use the Uv attribute of the
                attached geometry (if any). Defaults to True.


        """
    def draw(self, handle: Handle, params: Mapping[str, Any]|None = ...) -> None:
        """

        draw(self, handle, params=None)

            Method implemented by leaf classes to support the drawing of
            elements in a viewport. This method should normally be called from
            the python state onDraw or onDrawInterrupt event to render the
            drawable in the current viewport.


            handle
                This is an opaque value created by Houdini to render the
                drawable. This handle value is passed to the python state onDraw
                callback by Houdini and should be passed directly to the
                drawable object's draw method.

            params
                An optional dictionary of parameters for setting the drawable
                parameters. These are the same parameters
                hou.AdvancedDrawable.setParams is using.


        """

class SimpleDrawable(Drawable):
    '''

    hou.SimpleDrawable

    Represents extra geometry to draw in the viewer alongside user content
    (for example, as guide geometry).

    OVERVIEW

        You can attach geometry to a viewer in a Drawable object, causing
        the geometry to appear in the viewer even though the geometry is not
        actually part of the scene. This is useful to show guide geometry in
        a custom Python state.

        hou.SimpleDrawable basic support is ideal for simple guide
        geometries. For an advanced API for creating and drawing guide
        geometries, see hou.GeometryDrawable and hou.GeometryDrawableGroup.

      > import hou
      > # Create an empty geometry object
      > geo = hou.Geometry()
      > # Get the verb from the Box node
      > box_verb = hou.sopNodeTypeCategory().nodeVerb(\\"box\\")
      > # Set the verb\'s parameters
      > box_verb.setParms({
      >     \\"t\\": hou.Vector3(0.5, 0.5, -0.5),
      >     \\"scale\\": 0.5,
      > })
      > # Execute the verb and put its output in the Geometry object
      > box_verb.execute(geo, [])
      > 
      > # Grab a reference to the viewer
      > scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
      > # Create a Drawable object
      > drawable = hou.SimpleDrawable(scene_viewer, geo, \\"my_guide\\")
      > # Set the Drawable display mode as wireframe (this is the default)
      > drawable.setDisplayMode(hou.drawableDisplayMode.WireframeMode)
      > # Enable and show the drawable geometry
      > drawable.enable(True)
      > drawable.show(True)
      > # Tumble the view to see the geometry
      > import hou
      > # Create a geometry from the Sphere node
      > sphere_verb = hou.sopNodeTypeCategory().nodeVerb(\\"sphere\\")
      > geo = hou.Geometry()
      > sphere_verb.execute(geo, [])
      > 
      > # Add color and alpha attributes to the sphere
      > color_attrib = geo.addAttrib(hou.attribType.Prim, \\"Cd\\", (1.0, 1.0, 1.0))
      > alpha_attrib = geo.addAttrib(hou.attribType.Prim, \\"Alpha\\", 1.0)
      > 
      > color = hou.Color(1.0, 0.0, 0.0)
      > for prim in geo.prims():
      >     prim.setAttribValue(color_attrib, color.rgb())
      >     prim.setAttribValue(alpha_attrib, 0.7)
      > 
      > # Create a Drawable object
      > scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
      > drawable = hou.SimpleDrawable(scene_viewer, geo, \\"my_sphere\\")   
      > # Set the Drawable display mode with the current viewport shading mode
      > drawable.setDisplayMode(hou.drawableDisplayMode.CurrentViewportMode)
      > # Set the size of the sphere
      > drawable.setTransform(hou.hmath.buildScale(0.5, 0.5, 0.5))
      > drawable.enable(True)
      > drawable.show(True)

    TIPS AND NOTES

      * The SimpleDrawable object keeps a reference to the Geometry object
        you pass. You can change the Geometry object\'s contents and the next
        time the viewer redraws it will draw the new contents.

      * When you create the SimpleDrawable object, it is disabled and
        hidden. You need to call enable(True) and then show(True) for the
        geometry to appear.

      * Even after they are activated and shown, SimpleDrawable geometry
        does not appear in the viewer until the next redraw (for example,
        when the user changes the view).

            You can force an individual viewport to redraw using
            hou.GeometryViewport.draw.

          > scene_viewer.curViewport().draw()

      * You can generate the contents of a Geometry object from scratch
        using verbs, or grab a copy of the output of a SOP node using
        hou.SopNode.geometry.

      * You can also use hou.drawablePrimitive to specify a built-in shape
        to generate the content of a SimpleDrawable object.

      * enabling/disabling a drawable may cause performances issues if
        performed too often, especially with large geometries. It\'s good
        practice to use show instead of enable for hiding and showing a
        drawable.

      * It\'s also good practice to disable drawables when they are not
        actively used in a viewer.

      * Add a Vertex or Point uv attribute to the hou.SimpleDrawable
        geometry to draw in the UV view:

          > sops = hou.sopNodeTypeCategory()        
          > verb = sops.nodeVerb(\\"sphere\\")
          > verb.setParms(parms)
          > geo = hou.Geometry()
          > verb.execute(geo, [])
          > 
          > # add uv vertex attribute to the drawable.
          > geo.addAttrib(hou.attribType.Vertex, \\"uv\\", (0,0))            
          > 
          > # add color and alpha attributes
          > color_attrib = geo.addAttrib(hou.attribType.Prim, \\"Cd\\", (1.0, 1.0, 1.0))
          > for prim in geo.prims():
          >     prim.setAttribValue(color_attrib, StrokeCursor.COLOR.rgb())
          > 
          > # create a wireframe brush
          > brush = hou.SimpleDrawable(self.scene_viewer, geo, \'%s_%s\' % (self.state_name, \\"sphere\\"))
          > brush.setDisplayMode(hou.drawableDisplayMode.WireframeMode)

    RELATED

      * hou.TextDrawable

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup


    '''
    thisown: Incomplete
    def __init__(self, scene_viewer: SceneViewer, geometry: Geometry|EnumValue, name: str) -> None:
        '''

        __init__(self, scene_viewer, geometry, name)

            Creates a drawable object for drawing a geometry in a viewport. The
            new drawable is hidden and disabled by default.


            scene_viewer
                A hou.SceneViewer reference to the viewer the guide geometry
                will appear in.

            geometry
                Either a hou.Geometry object containing the geometry to draw, or
                a hou.drawablePrimitive value specifying a shape to draw.

            name
                A string to identify this drawable object. This should be unique
                across all drawables in the current session.

            In a custom state, you can base the SimpleDrawable\'s name on the
            state name to try to ensure uniqueness. For example:

          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          > 
          >         geo = hou.Geometry()
          >         verb = hou.sopNodeTypeCategory().nodeVerb(\\"box\\")
          >         verb.execute(geo, [])
          >         self._box = hou.SimpleDrawable(
          >             self.scene_viewer, geo,
          >             # Use the state name as the basis for the drawable\'s name
          >             self.state_name + \\"_box\\"
          >         )

        '''
    __swig_destroy__: Incomplete
    def enable(self, value: bool) -> None:
        """

        enable(self,value)

            Enables or disables the drawing of the geometry. This method is
            typically called first for the show method to take effect.


            value
                True to enable or False to disable the drawing.


        """
    def enabled(self) -> bool:
        """

        enabled(self,value) -> bool

            Returns True if the drawable is enabled or not.


        """
    def setDisplayMode(self, value: EnumValue) -> None:
        """

        displayMode(self): -> hou.drawableDisplayMode

            Returns the display mode of the geometry.


        """
    def displayMode(self) -> EnumValue: ...
    def setWireframeColor(self, color: Color) -> None:
        """

        setWireframeColor(self, color)

            Updates the color of the geometry when the drawable display mode is
            set to hou.drawableDisplayMode.WireframeMode. The change will appear
            the next time the viewer redraws.


            color
                A hou.Color value to specify the primitive color.


        """
    def wireframeColor(self) -> Color:
        """

        wireframeColor(self) -> hou.Color

            Returns the current wireframe color.


        """
    def setUseWireframeColor(self, value: bool) -> None:
        """

        setUseWireframeColor(self, value)

            Turns on or off usage of the drawable's wireframe color. The default
            is True. The change will appear the next time the viewer redraws.


            value
                True to turn on or False to turn off wireframe color usage.


        """
    def useWireframeColor(self) -> bool:
        """

        useWireframeColor(self) -> bool

            Returns whether the current wireframe color is being used.


        """
    def setXray(self, value: bool) -> None:
        """

        setXray(self, value)

            Sets the xray rendering flag on the drawable.


            value
                True to enable or False to disable xray rendering.


        """
    def isXray(self) -> bool:
        """

        isXray(self): -> bool

            Returns True if the drawable will render with xray rendering.


        """
    def setShowMaterials(self, value: bool) -> None:
        """

        setShowMaterials(self, value)

            Enables or disables materials for the drawable. The drawable
            geometry must have a valid shop_materialpath attribute.


            value
                True to enable or False to disable materials.


        """
    def isShowMaterials(self) -> bool:
        """

        isShowMaterials(self): -> bool

            Returns True if the drawable is drawn with materials.


        """
    def setCastShadows(self, value: bool) -> None:
        """

        setCastShadows(self, value)

            Enables or disables the shadow casting flag for the drawable.


            value
                True to enable or False to disable shadow casting.


        """
    def isCastShadows(self) -> bool:
        """

        isCastShadows(self): -> bool

            Returns True if the drawable is set to cast shadows.


        """
    def setDrawOutline(self, value: bool) -> None:
        """

        setDrawOutline(self, value)

            Turns on or off the outline drawing flag for the drawable.


            value
                True to turn on or False to turn off outline drawing.


        """
    def isDrawOutline(self) -> bool:
        """

        isDrawOutline(self): -> bool

            Returns True if the drawable is set to have outlines.


        """
    def setOutlineColor(self, color: Color|Vector4) -> None:
        """

        setOutlineColor(self, color)

            Updates the color of the outline of the drawable. Outlines are only
            displayed if the flag on the drawable has been turned on.


            color
                A hou.Color value to specify the outline color in RGB (Alpha is
                set to 1), or a hou.Vector4 value to specify the outline color
                in RGBA.


        """
    def outlineColor(self) -> Vector4:
        """

        outlineColor(self) -> hou.Vector4

            Returns the outline color of the drawable in RGBA format.


        """
    def setSeparateOutline(self, value: bool) -> None:
        """

        setSeparateOutline(self, value)

            Turns on or off the separate outline drawing flag for the drawable.
            By default, when multiple outlined objects overlap, only the
            silhouette of their combination is outlined. Use this flag to
            outline each object separately. Note: Separate outlines are
            expensive and can impact performance.


            value
                True to turn on or False to turn off separate outline drawing.


        """
    def isSeparateOutline(self) -> bool:
        """

        isSeparateOutline(self): -> bool

            Returns True if the drawable is set to have separate outlines.


        """
    def setOutlineOnly(self, value: bool) -> None:
        """

        setOutlineOnly(self, value)

            Turns on or off the outline only flag on the drawable. When outline
            only is turned on, only the outline of the drawable is drawn, and
            the drawable itself is not drawn.


            value
                True to turn on or False to turn off outline only drawing.


        """
    def isOutlineOnly(self) -> bool:
        """

        isOutlineOnly(self): -> bool

            Returns True if the drawable is set to only have its outline drawn.


        """
    def geometry(self) -> Geometry:
        """

        geometry(self): -> hou.Geometry

            Returns the drawable's geometry object. The returned geometry is
            read-only.


        """
    def setGeometry(self, geometry: Geometry) -> None:
        """

        setGeometry(self, geometry)

            Sets the drawable with a new geometry. The changes will appear the
            next time the viewer redraws.


            geometry
                A hou.Geometry object.


        """
    def setVisibleInViewport(self, viewport: GeometryViewport) -> None:
        """

        setVisibleInViewport(self, viewport)

            Restricts the drawable to be only visible in viewport. The drawable
            can be made visible in more than one viewport by calling this once
            per viewport.


        """
    def setVisibleInAllViewports(self) -> None:
        """

        setVisibleInAllViewports(self)

            Remove all per-viewport visibility restrictions, so that the
            drawable is shown in all viewports.


        """
    def isVisibleInViewport(self, viewport: GeometryViewport) -> bool:
        """

        isVisibleInViewport(self, viewport) -> bool

            Query to see if this drawable is visible in viewport.


        """

class Edge:
    """

    hou.Edge

    Each Edge object resides inside a Geometry object and stores an edge.
    Edges are reprsented as pairs of points.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Geometry: ...
    def points(self) -> Tuple[Point, ...]:
        """

        points(self) -> tuple of hou.Point

            Return a tuple of the points that make up this edge.


        """
    def edgeId(self) -> str:
        """

        edgeId(self) -> str

            Return a string such as p8-9 that identifies the edge


        """
    def length(self) -> float:
        """

        length(self) -> float

            Returns the length of this edge


        """
    def prims(self) -> Tuple[Prim, ...]:
        """

        prims(self) -> tuple of hou.Prim

            Return a tuple of the prims that has this edge


        """

class EdgeGroup:
    """

    hou.EdgeGroup

    A named group of edges inside a Geometry object.

    Edge groups reside inside the geometry, and each edge group has a unique
    name.

    See hou.Edge for more information about edges. See also hou.PrimGroup,
    hou.PointGroup, and hou.VertexGroup.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
    def name(self) -> str:
        """

        name(self)

            Return the name of the group. Each edge group has a unique name.


        """
    def iterEdges(self) -> _EdgeTupleGenerator:
        """

        iterEdges(self) -> generator of hou.Edge

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.EdgeGroup.edges allocates and returns a tuple of all the
            edges in the group, this method returns a generator object that will
            yield hou.Edge objects on demand.


        """
    def edges(self) -> Tuple[Edge, ...]:
        """

        edges(self) -> tuple of hou.Edge

            Return the contents of this group.

            See also hou.EdgeGroup.iterEdges.


        """
    def contains(self, edge: Edge) -> bool:
        """

        contains(self, edge) -> bool

            Return whether or not an edge is in this group.

            Raises hou.OperationFailed if the edge belongs to a different
            geometry object than this group.


        """
    def add(self, edge_or_list_or_edge_group: Edge|Sequence[Edge]|EdgeGroup) -> None:
        """

        add(self, edge_or_list_or_edge_group)

            If given a hou.Edge or a list of hou.Edge's, add the edge(s) to the
            group. If given a hou.EdgeGroup, merge the contents of the other
            edge group with this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is ok to add edges to the group that were already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the edge or edge group belong to a
            different geometry object than this group.


        """
    def remove(self, edge_or_list_or_edge_group: Edge|Sequence[Edge]|EdgeGroup) -> None:
        """

        remove(self, edge_or_list_or_edge_group)

            If given a hou.Edge or a list of hou.Edge's, remove the edge(s) from
            the group. If given a hou.EdgeGroup, remove all edges in the other
            group from this group (the other group is unaffected). You would
            typically call this method from the code of a Python-defined SOP.

            It is not an error to try to remove an edge from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the edge belongs to a different
            geometry object than this group.


        """
    def clear(self) -> None: ...
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def edgeCount(self) -> int:
        """

        edgeCount(self) -> int

            Returns the number of edges in this group.


        """
    def dataId(self) -> AttribDataId:
        """

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
    def incrementDataId(self) -> None:
        """

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """

class EditableDopGeometryGuard:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __enter__(self) -> Optional[Geometry]: ...
    def __exit__(self, type: Any, value: Any, traceback: Any) -> None: ...

class FlipbookSettings:
    """

    hou.FlipbookSettings

    A collection of options for the viewport flipbook dialog.

    The viewport flipbook has a set of options beyond the Display Options
    provided by the viewport itself. This object contains all these
    settings.

      * Use hou.SceneViewer.flipbookSettings to get this object representing
        the current flipbook settings for the viewer. Changing the options
        on this object changes the settings for future interactive flipbooks
        generated from the viewer.

      * You can also pass the settings object directly to
        hou.SceneViewer.flipbook to generate a flipbook using the current
        settings.

      * To generate a flipbook using custom settings, first use
        hou.SceneViewer.flipbookSettings to get the current settings, and
        call hou.FlipbookSettings.stash to create a copy (so changing the
        options won't affect the viewer's interactive options). Then modify
        the settings and pass the object to hou.SceneViewer.flipbook.

      > # Copy the viewer's current flipbook settings
      > scene = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
      > flipbook_options = scene.flipbookSettings().stash()
      > 
      > # Change the settings however you need
      > # (for example, set the frame range and output filename)
      > frame = hou.frame()
      > flipbook_options.frameRange( (frame, frame) )
      > flipbook_options.outputToMPlay(True) # or: flipbook_options.output(filename)
      > 
      > # Generate the flipbook using the modified settings
      > scene.flipbook(scene.curViewport(), flipbook_options)

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def stash(self) -> FlipbookSettings:
        """

        stash(self) -> hou.FlipbookSettings

            Return a new copy of this FlipbookSettings object. Changes to this
            new object will not update the flipbook dialog, but can be passed to
            hou.SceneViewer.flipbook() as the settings to use.


        """
    def copy(self, from_settings: FlipbookSettings) -> None:
        """

        copy(self, from_settings)

            Copy all settings in from_settings into this object.


        """
    def outputToMPlay(self, value: bool|None = ...) -> bool|None:
        """

        outputToMPlay(self) -> bool

            Query if images are being sent to an interactive MPlay sesion.


        """
    def leaveFrameAtEnd(self, value: bool|None = ...) -> bool|None:
        """

        leaveFrameAtEnd(self) -> bool

            Query if the playbar frame is being left at the last frame (True) or
            restored to the previous frame (False).


        """
    def output(self, value: str|None = ...) -> str|None:
        """

        output(self) -> str

            The current output destination for flipbooking.


        """
    def sessionLabel(self, value: str|None = ...) -> str|None:
        """

        sessionLabel(self) -> str

            The current flipbook session label.


        """
    def visibleObjects(self, value: str|None = ...) -> str|None:
        """

        visibleObjects(self) -> str

            The current visibility list for objects to be rendered.


        """
    def visibleTypes(self, value: EnumValue|None = ...) -> EnumValue|None:
        """

        visibleTypes(self) -> hou.flipbookObjectType

            The current visible object types.


        """
    def frameRange(self, value: Sequence[float]|None = ...) -> Tuple[float, float]|None:
        """

        frameRange(self) -> tuple of double

            The current frame range of the flipbook, as a tuple of 2 ints
            (start, end).


        """
    def frameIncrement(self, value: float|None = ...) -> float|None:
        """

        frameIncrement(self) -> double

            The current frame increment of the flipbook.


        """
    def beautyPassOnly(self, value: bool|None = ...) -> bool|None:
        """

        beautyPassOnly(self) -> bool

            The current state of the beauty pass render flag.


        """
    def renderAllViewports(self, value: bool|None = ...) -> bool|None:
        """

        renderAllViewports(self) -> bool

            Render all visible viewports (True), or only the currently selected
            one.


        """
    def appendFramesToCurrent(self, value: bool|None = ...) -> bool|None:
        """

        appendFramesToCurrent(self) -> bool

            The current state of the flipbook append mode, either Append (True)
            or Overwrite (False).


        """
    def scopeChannelKeyframesOnly(self, value: bool|None = ...) -> bool|None:
        """

        scopeChannelKeyframesOnly(self) -> bool

            The current state of scoped keyframe mode.


        """
    def blockEditing(self, value: bool|None = ...) -> bool|None:
        """

        blockEditing(self) -> bool

            The current state of block editing mode.


        """
    def initializeSimulations(self, value: bool|None = ...) -> bool|None:
        """

        initializeSimulations(self) -> bool

            The current state of simulation initialization. True indicates that
            simulations will be reset, and False indicates that any cached
            results will be used.


        """
    def audioFilename(self, audio_file: str|None = ...) -> str|None:
        """

        audioFilename(self, audio_file)

            The current audio file used by the flipbook.


        """
    def audioFrameStart(self, audio_file: float|None = ...) -> float|None:
        """

        audioFrameStart(self) -> double

            The frame where the audio will be playing audioTimeOffset seconds.


        """
    def audioTimeOffset(self, value: float|None = ...) -> float|None:
        """

        audioTimeOffset(self) -> double

            The audio time that will be playing at audioFrameStart frames.


        """
    def backgroundImage(self, value: str|None = ...) -> str|None:
        """

        backgroundImage(self) -> str

            The pathname of the background image or images.


        """
    def overrideGamma(self, value: bool|None = ...) -> bool|None:
        """

        overrideGamma(self) -> bool

            The current state of the gamma override.


        """
    def gamma(self, value: float|None = ...) -> float|None:
        """

        gamma(self) -> double

            The current gamma value.


        """
    def overrideLUT(self, value: bool|None = ...) -> bool|None:
        """

        overrideLUT(self) -> bool

            The current state of the LUT override.


        """
    def LUT(self, value: str|None = ...) -> str|None:
        """

        LUT(self) -> str

            The current LUT used for flipbooking.


        """
    def setUseFrameTimeLimit(self, limit: bool) -> None:
        """

        setUseFrameTimeLimit(self, limit)

            Enable the frame time limit for progressive renderers in LOPs.


        """
    def useFrameTimeLimit(self) -> bool:
        """

        useFrameTimeLimit(self) -> bool

            The frame time limit for progressive renderers in LOPs.


        """
    def setFrameTimeLimit(self, t: float) -> None:
        """

        setFrameTimeLimit(self, t)

            Set the frame time limit for progressive renderers in LOPs, in
            seconds. Once this is exceeeded the flipbook will advance to the
            next frame.


        """
    def frameTimeLimit(self) -> float:
        """

        frameTimeLimit(self) -> double

            The frame time limit for progressive renderers in LOPs, in seconds.
            Once this is exceeeded the flipbook will advance to the next frame.


        """
    def setUseFrameProgressLimit(self, limit: bool) -> None:
        """

        setUseFrameProgressLimit(self, limit)

            Enable the frame progress limit for progressive renderers in LOPs.


        """
    def useFrameProgressLimit(self) -> bool:
        """

        useFrameProgressLimit(self) -> bool

            The frame progress limit for progressive renderers in LOPs.


        """
    def setFrameProgessLimit(self, t: float) -> None:
        """

        setFrameProgessLimit(self, t)

            Specify the frame progress limit for progressive renderers in LOPs,
            in percent. Once this is exceeeded the flipbook will advance to the
            next frame.


        """
    def frameProgressLimit(self) -> float:
        """

        frameProgressLimit(self) -> double

            The frame progress limit for progressive renderers in LOPs, in
            percent. Once this is exceeeded the flipbook will advance to the
            next frame.


        """
    def antialias(self, value: EnumValue|None = ...) -> EnumValue|None:
        """

        antialias(self) -> hou.flipbookAntialias

            Query the current flipbook antialiasing setting:

          * hou.flipbookAntialias.UseViewportSetting: Use the current viewport
            setting.

          * hou.flipbookAntialias.Off: No antialiasing.

          * hou.flipbookAntialias.Fast: Minimal 2-sample antialiasing.

          * hou.flipbookAntialias.Good: 4-sample antialiasing.

          * hou.flipbookAntialias.HighQuality: 8-sample antialiasing.


        """
    def useMotionBlur(self, value: bool|None = ...) -> bool|None:
        """

        useMotionBlur(self) -> bool

            Query if motion blur is enabled.


        """
    def motionBlurSegments(self, value: int|None = ...) -> int|None:
        """

        motionBlurSegments(self) -> int

            Query the number of subframes currently used for motion blur.


        """
    def motionBlurFrameRange(self, value: EnumValue|None = ...) -> EnumValue|None:
        """

        motionBlurFrameRange(self) -> hou.flipbookMotionBlurBias

            Query the subframe range for motion blur:

          * hou.flipbookMotionBlurBias.Centered: Subframe range is centered
            around the currently rendering frame.

          * hou.flipbookMotionBlurBias.Forward: Subframe range starts at the
            currently rendering frame.

          * hou.flipbookMotionBlurBias.Previous: Subframe range ends at the
            currently rendering frame.


        """
    def shutterFromCamera(self, value: bool|None = ...) -> bool|None:
        """

        shutterFromCamera(self) -> bool

            Query if the shutter is sourced from the camera or the flipbook
            dialog.


        """
    def shutter(self, value: float|None = ...) -> float|None:
        """

        shutter(self) -> double

            Query the current camera shutter for motion blur.


        """
    def useDepthOfField(self, value: bool|None = ...) -> bool|None:
        """

        useDepthOfField(self) -> bool

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
    def depthOfFieldFromCamera(self, value: bool|None = ...) -> bool|None:
        """

        depthOfFieldFromCamera(self) -> bool

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
    def depthOfFieldQuality(self, value: float|None = ...) -> float|None:
        """

        depthOfFieldQuality(self) -> double

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
    def focusDistance(self, value: float|None = ...) -> float|None:
        """

        focusDistance(self) -> double

            Obsolete. Uses the setting on the camera.


        """
    def aperture(self, value: float|None = ...) -> float|None:
        """

        aperture(self) -> double

            Obsolete. Uses the setting on the camera.


        """
    def fStop(self, value: float|None = ...) -> float|None:
        """

        fStop(self) -> double

            Obsolete. Use the DOF settings in hou.GeometryViewportSettings.


        """
    def outputZoom(self, value: int|None = ...) -> int|None:
        """

        outputZoom(self) -> int

            Query the output zoom level. Valid settings are 100, 75, 50, and 25.


        """
    def useResolution(self, value: bool|None = ...) -> bool|None:
        """

        useResolution(self) -> bool

            Query if the resolution is defined by the flipbook dialog (True) or
            by the current size of the viewport (False).


        """
    def resolution(self, value: Tuple[int, int]|None = ...) -> Tuple[int, int]|None:
        """

        resolution(self) -> tuple of int

            Returns a 2-tuple of ints representing the width and height of the
            flipbook dialog image output resolution. This is not used unless
            useResolution is enabled.


        """
    def useSheetSize(self, value: bool|None = ...) -> bool|None:
        """

        useSheetSize(self) -> bool

            Query if the viewport captures will be arranged into a sheet (True)
            or each frame will produce a different flipbook image (False).


        """
    def sheetSize(self, value: Sequence[int]|None = ...) -> Tuple[int, int]|None:
        """

        sheetSize() -> tuple of int

            Returns a 2-tuple of ints representing the number of columns and
            rows of frames in each output image. This is not used unless
            useSheetSize is enabled.


        """
    def cropOutMaskOverlay(self, value: bool|None = ...) -> bool|None:
        """

        cropOutMaskOverlay(self) -> bool

            Query if the resulting image will be cropped to the camera area.


        """
    def fromAudioPanel(self, value: bool|None = ...) -> bool|None:
        """

        fromAudioPanel(self) -> bool

            When enabled, the flipbook gets it's audio settings from the Audio
            Panel.


        """

class FloatingPanel:
    """

    hou.FloatingPanel

    A floating window that contains one or more panes.

    Much like a desktop, a floating panel contains panes. A floating panel
    may be attached to a desktop, in which case it is saved with the
    desktop, hidden when the desktop is closed, and shown when the desktop
    is opened. You can use floating panels to create desktops that span
    multiple monitors.

    When you create a new floating panel, for example, it contains a single
    pane, which in turn contains a single pane tab showing the network
    editor.

    Note that a floating panel may be locked to one particular pane tab.
    These stripped down panels do not display the interface for adding new
    pane tabs or splitting panes. In fact, these stripped down floating
    panels do not contain any panes at all, and hou.FloatingPanel.panes will
    return an empty tuple. You can create such a stripped down floating
    panel with hou.Desktop.createFloatingPaneTab.

    See hou.Desktop for more information about panes and pane tabs.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def panes(self) -> Tuple[Pane, ...]:
        """

        panes(self) -> tuple of hou.Pane

            Return all the panes inside the panel. As mentioned in the
            documentation for this class, a floating panel may be stripped down
            and locked to one particular pane tab, and these stripped down
            floating panels do not contain any panes.


        """
    def paneTabs(self) -> Tuple[PaneTab, ...]:
        """

        paneTabs(self) -> tuple of hou.PaneTab

            Return all the pane tabs that are in this floating panel, regardless
            of which pane they are in.


        """
    def paneTabOfType(self, type: EnumValue, index: int = 0) -> Optional[PaneTab]:
        """

        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return the pane tab with the desired type or None if no
            such pane tab exists.


            type
                A hou.paneTabType enumerated variable.

            index
                If there are multiple tabs with the desired type, this parameter
                determines which one is returned. Use index=0 to return the
                first found tab, index=1 to return the second found tab, etc. By
                default, index is 0.


        """
    def findPaneTab(self, name: str) -> Optional[PaneTab]:
        """

        findPaneTab(self, name) -> hou.PaneTab or None

            Return the pane tab with the given name, or None if no such tab
            exists.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of the floating panel. The panel's name is displayed
            in its window's title.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Set this panel's name. Any characters in the name that are not
            letters, numbers, or underscores are replaced with underscores.

            Raises hou.OperationFailed if the name is an empty string.


        """
    def containsPlaybar(self) -> bool:
        """

        containsPlaybar(self) -> bool

            Return whether or not this panel contains Houdini's playbar.

            See also hou.FloatingPanel.setContainsPlaybar.


        """
    def setContainsPlaybar(self, on: bool) -> None:
        """

        setContainsPlaybar(self, on)

            If on is True, move Houdini's playbar to this panel. Otherwise, move
            it back to the main desktop window.

            See also hou.FloatingPanel.containsPlaybar.


        """
    def containsShelf(self) -> bool:
        """

        containsShelf(self) -> bool

            Return whether or not this panel contains Houdini's shelf.

            See also hou.FloatingPanel.setContainsShelf.


        """
    def setContainsShelf(self, on: bool) -> None:
        """

        setContainsShelf(self, on)

            If on is True, move Houdini's shelf to this panel. Otherwise, move
            it back to the main desktop window.

            See also hou.FloatingPanel.containsShelf.


        """
    def containsStatusBar(self) -> bool:
        """

        containsStatusBar(self) -> bool

            Return whether or not this panel contains Houdini's status bar (the
            bar at the bottom of the desktop for status messages).

            See also hou.FloatingPanel.setContainsStatusBar.


        """
    def setContainsStatusBar(self, on: bool) -> None:
        """

        setContainsStatusBar(self, on)

            If on is True, move Houdini's status bar to this panel. Otherwise,
            move it back to the main desktop window.

            See also hou.FloatingPanel.containsStatusBar.


        """
    def containsMenuBar(self) -> bool:
        """

        containsMenuBar(self) -> bool

            Return whether or not this panel contains Houdini's main menu bar.

            See also hou.FloatingPanel.setContainsMenuBar.


        """
    def setContainsMenuBar(self, on: bool) -> None:
        """

        setContainsMenuBar(self, on)

            If on is True, move Houdini's main menu bar to this panel.
            Otherwise, move it back to the main desktop window.

            See also hou.FloatingPanel.containsMenuBar.


        """
    def isAttachedToDesktop(self) -> bool:
        """

        isAttachedToDesktop(self) -> bool

            Return whether or not this panel is attached to the desktop. Panels
            attached to the desktop are saved with the desktop and are opened
            when the desktop is opened and closed when the desktop is closed.

            See also hou.FloatingPanel.attachToDesktop.


        """
    def attachToDesktop(self, on: bool) -> None:
        """

        attachToDesktop(self, on)

            Attach this panel to the desktop. See
            hou.FloatingPanel.isAttachedToDesktop for more information.


        """
    def isFullscreen(self) -> bool:
        """

        isFullscreen(self) -> bool

            Return whether or not this panel is in full screen mode.

            See also hou.FloatingPanel.setIsFullscreen.


        """
    def setIsFullscreen(self, on: bool) -> None:
        """

        setIsFullscreen(self, on)

            Set whether or not this panel is in full screen mode.

            See also hou.FloatingPanel.isFullscreen.


        """
    def position(self) -> Vector2:
        """

        position(self) -> hou.Vector2

            Return the desktop position (in pixels) of the floating panel
            window.


        """
    def setPosition(self, position: Sequence[int]) -> None:
        """

        setPosition(self, position)

            Move the floating panel window to the specified desktop position (in
            pixels).

            Raise TypeError if position does not contain exactly two values.


        """
    def size(self) -> Vector2:
        """

        size(self) -> hou.Vector2

            Return the floating panel window's size (in pixels).


        """
    def setSize(self, size: Sequence[int]) -> None:
        """

        setSize(self, size)

            Resize the floating panel window (in pixels).

            Raise TypeError if size does not contain exactly two values. Raise
            TypeError if size contains a value that is less than or equal to
            zero.


        """
    def close(self) -> None:
        """

        close(self)

            Close the floating panel's window, closing all the pane tabs inside
            it.


        """

class FloatParmTemplate(ParmTemplate):
    """

    hou.FloatParmTemplate

    Describes a parameter tuple containing floating point values.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, num_components: int, default_value: Sequence[float] = ..., min: float = ..., max: float = ..., min_is_strict: bool = ..., max_is_strict: bool = ..., look: EnumValue = ..., naming_scheme: EnumValue = ..., disable_when: str|None = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ..., default_expression: Sequence[str] = ..., default_expression_language: Sequence[EnumValue] = ...) -> None:
        """

        __init__(self, name, label, num_components, default_value=(), min=0.0,
        max=10.0, min_is_strict=False, max_is_strict=False,
        look=hou.parmLook.Regular, naming_scheme=hou.parmNamingScheme.XYZW,
        disable_when=None, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new FloatParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            default_value
                See the defaultValue method for more information.

            min
                See the minValue method for more information.

            max
                See the maxValue method for more information.

            min_is_strict
                See the minIsStrict method for more information.

            max_is_strict
                See the maxIsStrict method for more information.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
    __swig_destroy__: Incomplete
    def minValue(self) -> float:
        """

        minValue(self) -> float

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
    def setMinValue(self, min_value: float) -> None:
        """

        setMinValue(self, min_value)

            Set the minimum value of the parameter.

            See the minValue method for more information.


        """
    def maxValue(self) -> float:
        """

        maxValue(self) -> float

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
    def setMaxValue(self, max_value: float) -> None:
        """

        setMaxValue(self, max_value)

            Set the maximum value of the parameter.

            See the maxValue method for more information.


        """
    def minIsStrict(self) -> bool:
        """

        minIsStrict(self) -> bool

            Return whether the minimum value is strictly enforced.

            If a minimum value is not strictly enforced, the slider will not let
            you change the value below the minimum, but you can set the value to
            be lower than the minimum by typing it in, changing it via
            hou.Parm.setValue, or using the ladder handle.

            If it is strictly enforced and you try to change it below the
            minimum value using any mechanism, Houdini will set it to the
            minimum value.

            See also the minValue method.


        """
    def setMinIsStrict(self, on: bool) -> None:
        """

        setMinIsStrict(self, on)

            Set whether the minimum value is strictly enforced.

            See the minIsStrict method for more information.


        """
    def maxIsStrict(self) -> bool:
        """

        maxIsStrict(self) -> bool

            Return whether the maximum value is strictly enforced.

            See the minIsStrict method for more information.


        """
    def setMaxIsStrict(self, on: bool) -> None:
        """

        setMaxIsStrict(self, on)

            Set whether the maximum value is strictly enforced.

            See the maxIsStrict method for more information.


        """
    def defaultValue(self) -> Tuple[float, ...]:
        """

        defaultValue(self) -> tuple of float

            Return the default value for new parameter instances.

            For example, suppose this parm template is named t, the naming
            scheme is XYZW, it has 3 components, and the default value is (1.0,
            2.0, 3.0). The corresponding parm tuple instance on a node would be
            named t and would contain parameters tx, ty, and tz. When the node
            is created, tx would be 1.0, ty would be 2.0, and tz would be 3.0.


        """
    def setDefaultValue(self, default_value: Sequence[float]) -> None:
        """

        setDefaultValue(self, tuple_of_default_values)

            Set the default value for new parameter instances to a sequence of
            floats.

            See the defaultValue method for more information. Note that if the
            number of floats in the sequence is different from the number of
            components in the parm template, any extra values will be discarded
            and any missing values will become zeros.


        """
    def defaultExpression(self) -> Tuple[str, ...]:
        """

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.

            For example, suppose this parm template is named t, the naming
            scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
            3.0), the default expression is ($F, hou.frame(), ) and the default
            expression language is (hou.scriptLanguage.Hscript,
            hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
            corresponding parm tuple instance on a node would be named t and
            would contain parameters tx, ty, tz. When the node is created, tx
            would have a default Hscript expression of $F, ty would have a
            default Python expression of hou.frame(), and tz would have a
            default value of 3.0.


        """
    def setDefaultExpression(self, default_expression: Sequence[str]) -> None:
        """

        setDefaultExpression(self, tuple_of_default_expressions)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.FloatParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
    def defaultExpressionLanguage(self) -> Tuple[EnumValue, ...]:
        """

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: Sequence[EnumValue]) -> None:
        """

        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """

class FolderParmTemplate(ParmTemplate):
    """

    hou.FolderParmTemplate

    Describes a folder in a parameter dialog.

    Unlike all other hou.ParmTemplate subclasses, a folder does not
    correspond to an individual hou.ParmTuple. Instead, the set of adjacent
    folders form a folder set, and there is one parameter for this set that
    controls which folder is currently visible. These folder sets correspond
    to hou.FolderSetParmTemplate objects.

    Folder parm template objects are useful when manipulating the parameter
    interface of a node or a digital asset definition. Unlike folder set
    parm templates, they contain the parm templates inside the folder. They
    also let you add, remove, or hide an individual folder or move it from
    set one to another using hou.ParmTemplateGroup objects. Doing these
    individual folder-level operations is not possible with folder set parm
    templates.

    Note that folder parm templates are also used to represent multiparm
    blocks, much like the <Type Properties> dialog does. The folder parm
    template's hou.folderType determines whether it is a folder or a
    multiparm block. Unlike folder parm templates, which do not correspond
    directly to parameter instances, a multiparm parm template does
    correspond to an integer parameter that controls the number of instances
    of the multiparm.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, parm_templates: Sequence[ParmTemplate] = ..., folder_type: EnumValue = ..., is_hidden: bool = ..., ends_tab_group: bool = ..., tags: Mapping[str, str] = ..., conditionals: Mapping[EnumValue, str] = ..., tab_conditionals: Mapping[EnumValue, str] = ...) -> None:
        """

        __init__(name, label, parm_templates=(),
        folder_type=hou.folderType.Tabs, is_hidden=False, ends_tab_group=False,
        tags={}, conditionals={}, tab_conditionals={})

            Create a new folder parm template.


            name
                The internal name of the parm template. Normally, parm template
                names correspond directly to parm tuples on nodes. However,
                because folder sets, not folders, correspond directly to parm
                tuples, the name used for the folder set parm tuple is the name
                of the first folder parm template in the set of adjacent folder
                parm templates.

            label
                The name of the folder that is displayed in the parameter
                dialog.

            parm_templates
                A sequence of hou.ParmTemplate subclass objects for the
                parameters inside the folder. Folders may be nested in other
                folders by putting FolderParmTemplates in this sequence.

            folder_type
                A hou.folderType enumerated value controlling whether the
                parameter is a folder or a multiparm block. This value controls
                the look of the folder/multiparm instance.

            is_hidden
                Whether or not this folder is hidden.

            ends_tab_group
                If True, this folder will be the last in the folder set, even if
                the next parameter is also a folder. In that case, the next
                parameter will begin a new folder set.

            tags
                A dictionary of extra information attached to the parm template.

            conditionals
                A dictionary that specifies conditionals (i.e. disable when,
                hide when) on the parameter template. For folder tab parameters
                these conditionals affect the entire folder set.

                The dictionary maps hou.parmCondType types to conditional
                strings.

                See the Conditionals section of the <Operator Type Properties
                window> help for more information on conditional strings.

            tab_conditionals
                A dictionary that specifies conditionals (i.e. disable when,
                hide when) on the parameter template. These conditionals affect
                only the folder tab generated by this parameter template and not
                the entire folder set.

                The dictionary maps hou.parmCondType types to conditional
                strings.

                See the Conditionals section of the <Operator Type Properties
                window> help for more information on conditional strings.

                hou.OperationFailed is raised if tab conditionals are specified
                for multi-parameter templates or import blocks.


        """
    __swig_destroy__: Incomplete
    def folderStyle(self) -> EnumValue: ...
    def folderType(self) -> EnumValue:
        """

        folderType(self) -> hou.folderType enum value

            Return the type of folder. Note that the folder may actually be a
            multiparm block.


        """
    def setFolderType(self, folder_type: EnumValue) -> None:
        """

        setFolderType(self, folder_type)

            Set the type of folder to a hou.folderType enum value.


        """
    def isActualFolder(self) -> bool:
        """

        isActualFolder(self) -> bool

            Return whether or not this parm template corresponds to an actual
            folder, as opposed to a multiparm or import block.

            This method can be implemented as follows:

          > def isActualFolder(self):
          >     return self.folderType() in (
          >         hou.folderType.Tabs, hou.folderType.RadioButtons)

        """
    def defaultValue(self) -> int:
        """

        defaultValue(self) -> int

            Return the integer default value.

            The default value is only used for folders that are multiparm
            blocks, and controls the default number of multiparm instances in
            newly created nodes.


        """
    def setDefaultValue(self, default_value: int) -> None:
        """

        setDefaultValue(self, tuple_of_default_values)

            Set the default value to an integer.

            The default value is only used for folders that are multiparm
            blocks. See the defaultValue method for more information.


        """
    def tabConditionals(self) -> Optional[dict[EnumValue, str]]:
        """

        tabConditionals(self) -> dict of [Hom:hou.parmCondType] enum value to
        string

            Returns the set of conditionals that affect the folder tab generated
            by this parameter template. The conditionals correspond to the Tab
            disable when and Tab hide when properties that appear Edit Parameter
            Interface window for folder parameters.

            See the Conditionals section of the <Operator Type Properties
            window> help for more information on conditional strings.

            This method returns an empty dictionary if this parameter template
            is for a multi-parameter or import block.


        """
    def setTabConditional(self, cond_type: EnumValue, conditional: str) -> None:
        """

        setTabConditional(self, type, conditional)

            Set a conditional string of the given hou.parmCondType type that
            affects the folder tab generated by this parameter template. The
            string consists of rules on how this parameter's folder tab's
            display behaves when other parameters change.

            See the Conditionals section of the <Operator Type Properties
            window> help for more information on conditional strings.

            Raises hou.OperationFailed if this parameter template is for a
            multi-parameter or import block.


        """
    def endsTabGroup(self) -> bool:
        """

        endsTabGroup(self) -> bool

            Return whether this folder will be the last in the folder set, even
            if the next parameter is also a folder. In that case, the next
            parameter will begin a new folder set.

            This parameter only has meaning if the parm template is for an
            actual folder and not for a multiparm block.


        """
    def setEndsTabGroup(self, on: bool) -> None:
        """

        setEndsTabGroup(self, on)

            Set the flag to indicate whether or not the folder tab is the last
            one in the folder set. If the flag is set to True and the next
            parameter is also a folder, then that next folder will begin a new
            folder set.

            This parameter only has meaning if the parm template is for an
            actual folder and not for a multiparm block.


        """
    def parmTemplates(self) -> Tuple[ParmTemplate, ...]:
        """

        parmTemplates(self) -> tuple of hou.ParmTemplate

            Return a tuple of copies of the parm templates stored inside this
            folder.

            Because copies are returned, you cannot change the contents of the
            parm templates inside this folder by modifying the parm templates
            returned. Instead, use methods in hou.ParmTemplateGroup to modify
            parm templates in this folder.


        """
    def setParmTemplates(self, parm_templates: Sequence[ParmTemplate]) -> None:
        """

        setParmTemplates(self, parm_templates)

            Replace the parm templates inside this folder with a new sequence of
            parm templates.


        """
    def addParmTemplate(self, parm_template: ParmTemplate) -> None:
        """

        addParmTemplate(self, parm_template)

            Append a parm template to the end of the list of parm templates
            inside the folder.

            Note that hou.ParmTemplateGroup provides a number of methods to
            insert parm templates inside folders, including
            hou.ParmTemplateGroup.appendToFolder.


        """

class FolderSetParmTemplate(ParmTemplate):
    """

    hou.FolderSetParmTemplate

    Describes a set of folders.

    A folder set is a group of adjacent folders, and only one of those
    folders can be displayed at a time. A folder set corresponds to one
    parameter, and the value of that parameter determines which folder is
    displayed.

    Note that there is also a hou.FolderParmTemplate class. Folder sets are
    used when there is a mapping to a parameter; for example, asking a
    hou.ParmTuple for its parm template may return a folder set, but it will
    never return a folder. Folder parm templates are used by
    hou.ParmTemplateGroup because they easily let you add, remove, and move
    individual folders, and they let you easily place parameters inside
    folders. Attempting to place folder set parm templates in
    hou.ParmTemplateGroup objects will raise hou.OperationFailed.


    """
    thisown: Incomplete
    def __init__(self, name: str, folder_names: Sequence[str], folder_type: EnumValue, tags: Mapping[str, str] = ...) -> None:
        """

        hou.FolderSetParmTemplate

        Describes a set of folders.

        A folder set is a group of adjacent folders, and only one of those
        folders can be displayed at a time. A folder set corresponds to one
        parameter, and the value of that parameter determines which folder is
        displayed.

        Note that there is also a hou.FolderParmTemplate class. Folder sets are
        used when there is a mapping to a parameter; for example, asking a
        hou.ParmTuple for its parm template may return a folder set, but it will
        never return a folder. Folder parm templates are used by
        hou.ParmTemplateGroup because they easily let you add, remove, and move
        individual folders, and they let you easily place parameters inside
        folders. Attempting to place folder set parm templates in
        hou.ParmTemplateGroup objects will raise hou.OperationFailed.


        """
    __swig_destroy__: Incomplete
    def folderNames(self) -> list[str]:
        """

        setFolderNames(self, folder_names)

            Set the names of the folders in this set to the given sequence of
            strings.

            See the folderNames method for more information.

            Raises hou.OperationFailed if folder_names is an empty sequence.


        """
    def setFolderNames(self, folder_names: Sequence[str]) -> None: ...
    def folderType(self) -> EnumValue:
        """

        folderType(self) -> hou.folderType enum value

            Return the type of folder.


        """
    def setFolderType(self, folder_type: EnumValue) -> None:
        """

        setFolderType(self, folder_type)

            Set the type of folder to a hou.folderType enum value.

            Raises TypeError if the folder type is for a multiparm or import
            block.


        """
    def folderStyle(self) -> EnumValue:
        """

        folderStyle(self) -> hou.folderType enum value

            This method is deprecated. It is an alias for the folderType method.


        """

class GadgetContext:
    """

    hou.GadgetContext

    The base class for a viewer resource gadget context.

    OVERVIEW

        hou.GadgetContext provides a common interface to viewer resources
        such as Python viewer handles and Python viewer states. It holds
        relevant information about a gadget drawable or 2D drawable that is
        bound to the viewer resource currently active in a viewport. The
        term drawable is used interchangeably to refer to either a
        hou.GadgetDrawable or a hou.Drawable2D.

    RELATED

        hou.ViewerStateContext hou.ViewerHandleContext


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def gadget(self) -> str:
        """

        gadget(self) -> string

            Similar to name().


        """
    def gadgetLabel(self) -> str:
        """

        gadgetLabel(self) -> string

            Similar to label().


        """
    def name(self) -> str:
        """

        name(self) -> string

            Returns the name of the active drawable. A drawable is active when
            it is picked or when the mouse moves over its visuals (located).


        """
    def label(self) -> str:
        """

        label(self) -> string

            The active drawable label name.


        """
    def component1(self) -> int:
        """

        component1(self) -> int

            A component id of the active gadget geometry. The id refers to
            either a polygon, a polygon vertex or the start point of a line
            geometry. Returns -1 if no gadget is active.


            NOTE
                This method does not apply to hou.Drawable2D objects.


        """
    def component2(self) -> int:
        """

        component2(self) -> int

            A component id of the active gadget geometry. The returned id
            typically identifies the end point of a line geometry. Returns -1 if
            no line geometry is picked or located, or no gadget is active.


            NOTE
                This method does not apply to hou.Drawable2D objects.


        """
    def isLocating(self) -> bool:
        """

        isLocating(self) -> bool

            Returns True if any drawable is being located.


        """
    def isPicking(self) -> bool:
        """

        isPicking(self) -> bool

            Returns True if any drawable is being picked.


        """
    def isDrawing(self) -> bool:
        """

        isDrawing(self) -> bool

            Returns True if the handle is in a drawing state which means no
            drawable is being picked or located.


        """
    def isLocated(self, gadget_name: str) -> bool:
        """

        isLocated(drawable_name) -> bool

            Returns True if a given drawable is located.


            drawable_name
                Name of the drawable to test.


        """
    def isPicked(self, gadget_name: str) -> bool:
        """

        isPicked(drawable_name) -> bool

            Returns True if a given drawable is picked.


            drawable_name
                Name of the drawable to test.


        """

class galleries:
    """

    hou.galleries

    A module for managing galleries and their entries.

    This module provides a few basic functions for accessing and managing
    hou.Gallery and hou.GalleryEntry.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def galleries() -> Tuple[Gallery, ...]:
        """

        galleries() -> tuple of hou.Gallery

            Return a tuple containing all the galleries currently installed in
            the Houdini session.


        """
    @staticmethod
    def galleryEntries(name_pattern: Optional[str] = None, label_pattern: Optional[str] = None, keyword_pattern: Optional[str] = None, category: Optional[str] = None, node_type: Optional[NodeType] = None) -> Tuple[GalleryEntry, ...]:
        '''

        galleryEntries(name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry

            Return a tuple of hou.GalleryEntry objects matching the search
            criteria. The result is the intersection of the matches against all
            the parameters. If you call this function with no parameters, it
            returns all the gallery entries. See also
            hou.Gallery.galleryEntries.

            Unless a parameter is None, the results are filtered by the
            following:


            name_pattern
                gallery entry names matching this pattern

            label_pattern
                gallery entry label names matching this pattern

            keyword_pattern
                gallery entries that have a keyword matching this pattern

            category
                gallery entries in a category matching this pattern

            node_type
                gallery entries that can be applied to this node type

            This example prints all the gallery entries starting with a b that
            have the Material keyword.

          > >>> hou.galleries.galleryEntries(\\"b*\\", keyword_pattern=\\"Material\\")
          > (<hou.GalleryEntry \\"basic_surface\\">, <hou.GalleryEntry \\"bumpy_glass\\">, ...)

            This example prints the name and description of all the entries in
            the Metals category:

          > >>> for entry in hou.galleries.galleryEntries(category=\\"Metals\\"):
          > ...     print \\"%s: %s\\" % (entry.name(), entry.description())
          > chrome: Very bright metal with mirror reflections
          > aged_metal: Aged metal material with ray traced or environment mapped reflections
          > ...

            This example prints the gallery entry names for the Lsystem SOP.

          > >>> node_type = hou.nodeType(hou.sopNodeTypeCategory(), \\"lsystem\\")
          > >>> for entry in hou.galleries.galleryEntries(node_type=node_type):
          > ...     print entry.name()
          > planta
          > plantb
          > plantc
          > ...
          > sympodial_tree
          > ternary_tree
          > wheel

        '''
    @staticmethod
    def installGallery(gallery_path: str) -> Optional[Gallery]:
        """

        installGallery(gallery_path) -> hou.Gallery or None

            Load a gallery into the current Houdini session.


            gallery_path
                The file path of the gallery to be installed.


        """
    @staticmethod
    def removeGallery(gallery_path: str) -> bool:
        """

        removeGallery(gallery_path) -> bool

            Remove a gallery from the current Houdini session. Returns False if
            the specified gallery file was not installed.


            gallery_path
                The file path of the gallery to be removed.


        """
    @staticmethod
    def createGalleryEntry(gallery_path: str, entry_name: str, node: Optional[Node] = None) -> GalleryEntry:
        """

        createGalleryEntry(gallery_path, entry_name, node) -> hou.GalleryEntry
        or None

            Create and return a new gallery entry.


            gallery_path
                The path of the gallery file in which the new element should be
                stored.

            entry_name
                The name of the new gallery entry.

            node
                The operator node from which the new gallery entry should copy
                the settings. The settings include parameter values, channels,
                spare parameters etc, and also the children nodes if the node is
                a subnetwork.


        """

class Gallery:
    """

    hou.Gallery

    A collection of gallery entries that can be applied to operator nodes to
    set their parameters to predefined values.

    In Houdini, a gallery is a collection of node templates and their
    parameter presets, which are represented by a hou.GalleryEntry. A
    gallery corresponds to a file where such templates are saved. Galleries
    can be managed with a hou.galleries module.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def galleryEntries(self, name_pattern: Optional[str] = None, label_pattern: Optional[str] = None, keyword_pattern: Optional[str] = None, category: Optional[str] = None, node_type: Optional[NodeType] = None) -> Tuple[GalleryEntry, ...]:
        """

        galleryEntries(self, name_pattern=None, label_pattern=None,
        keyword_pattern=None, category=None, node_type=None) -> tuple of
        hou.GalleryEntry

            Return a tuple of entries that are stored in the gallery. See also
            hou.galleries.galleryEntries.


            name_pattern
                A pattern that the gallery entry name must match to be included
                in the returned tuple. The pattern can contain '?' to match a
                single character, '*' to match any number of characters, and ''
                to match any character in the set. If None, all gallery entries
                are considered to match it.

            label_pattern
                A pattern that the gallery entry label must match to be included
                in the returned tuple. See the name_pattern above for special
                characters in the pattern. If None, all gallery entries are
                considered to match it.

            keyword_pattern
                A pattern that any of the gallery entry keywords needs to match
                for the entry to be included in the returned tuple. See the
                name_pattern above for special characters in the pattern. If
                None, all gallery entries are considered to match it.

            category
                If not None, only gallery entries in the specified category will
                be included in the returned tuple.

            node_type
                If not None, only gallery entries for a given node type will be
                included in the returned tuple.


        """
    def createEntry(self, entry_name: str, node: Optional[Node] = None) -> GalleryEntry: ...
    def deleteEntry(self, entry_name: str) -> None: ...

class GalleryEntry:
    '''

    hou.GalleryEntry

    A gallery entry that can be applied to operator nodes to set their
    parameters to predefined values.

    A gallery entry is an entity containing data about an operator node
    setup. It has information about the node\'s parameter values, any
    additional spare parameters, channels, and for subnet nodes the
    information about the children, etc. Thus, a gallery entry is like a
    node template or a parameter preset. Such templates can be created from
    and applied to existing nodes.

    A gallery entry is identified by a unique, and has a non-unique label,
    and is usually associated with a specific hou.NodeType (or several node
    types) of the nodes to which it applies. In addition to the node
    information, gallery entries can have own categories that organize them
    into manageable sets and also can have keywords that identify their
    purpose. For more information about gallery entries, please see a
    gallery entry editor.

    In order for your gallery entries to appear in the Material Palette
    pane, they must satisfy two conditions. First, the node category must be
    set to indicate the gallery entry creates a SHOP node. Use code like:

    > hou.galleries.galleryEntries(\\"entry_name\\")[0].setNodeTypeCategory(hou.shopNodeTypeCategory())

    The second condition is that the entry must contain one or more keywords
    that indicate what renderer the SHOP works with. This affects whether
    the gallery entry appears when a specific renderer is chosen in the
    Material Palette renderer menu. Even if All is chosen in that menu, the
    gallery entry must contain a keyword that matches one of the renderers
    that appears in that menu. To associate a gallery entry with the Mantra
    renderer, do the following:

    > hou.galleries.galleryEntries(\\"entry_name\\")[0].setKeywords((\'Mantra\',))

    In HOM the gallery entries can be managed using hou.Gallery.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def canApplyToNode(self, node: Node) -> bool:
        """

        canApplyToNode(self, node) -> bool

            Return True if this gallery entry can be safely applied to the given
            node. See hou.GalleryEntry.applyToNode for more info.


            node
                A node to test whether the gallery entry can be applied to.


        """
    def applyToNode(self, node: Node) -> None:
        """

        applyToNode(self, node)

            Apply the gallery entry to a given node. This method sets the node's
            parameter values to match the ones stored by the entry. It may also
            add spare parameters and channels to the node and for the subnets,
            it may create new child nodes.


            node
                A node to which to apply the gallery entry.


        """
    def canCreateChildNode(self, parent: Node) -> bool:
        """

        canCreateChildNode(self, parent) -> bool

            Return True if hou.GalleryEntry.createChildNode can succeed.


        """
    def createChildNode(self, parent: Node) -> Node:
        """

        createChildNode(self, parent) -> Node

            Create a new node in the parent network and then apply this gallery
            entry to that newly created node.


            parent
                A subnetwork within which the new node should be created. If
                None, an implicit natural parent is chosen using a node type
                this gallery entry is associated with.


        """
    def setEqual(self, entry: GalleryEntry) -> None:
        """

        setEqual(self, entry)

            Set this gallery entry to be exactly the same as the given entry,
            except for the name, which is left unchanged.


            entry
                The gallery entry to copy the information from.


        """
    def name(self) -> str:
        """

        name(self) -> string

            Return the gallery entry name.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Set the gallery entry name.


            name
                The name string.


        """
    def label(self) -> str:
        """

        label(self) -> str

            Return the gallery entry label.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self, label)

            Set the gallery entry label.


            label
                The label string.


        """
    def description(self) -> str:
        """

        description(self) -> string

            Return a description of the gallery entry. A description is a short
            string that states the gallery entry purpose. It is used for tool-
            tip pop-ups.


        """
    def setDescription(self, description: str) -> None:
        """

        setDescription(self, description)

            Set the description of the gallery entry.


            description
                The text briefly describing the gallery entry purpose.


        """
    def helpURL(self) -> str:
        """

        helpURL(self) -> string

            Return the URL of the help document for this gallery entry.


        """
    def setHelpURL(self, helpurl: str) -> None:
        """

        setHelpURL(self, helpurl)

            Set the URL of the help document for this gallery entry.


        """
    def requiredHDAFile(self) -> str:
        """

        requiredHDAFile(self) -> string

            Return a file path to an HDA library that should be loaded before
            trying to apply this gallery entry. It is often used for gallery
            entries associated with a non-native operator type.


        """
    def setRequiredHDAFile(self, hda_file: str) -> None:
        """

        setRequiredHDAFile(self, hda_file)

            Set a file path to an HDA library on which this gallery entry
            depends.


            hda_file
                A path of the HDA library file (OTL).


        """
    def icon(self) -> str:
        """

        icon(self) -> string

            Return the icon name or a icon file path that should be used for
            this gallery entry.


        """
    def setIcon(self, icon: str) -> None:
        """

        setIcon(self, icon)

            Set the icon name or an icon file path that should be used for this
            gallery entry.


        """
    def allowIconRegeneration(self) -> bool:
        """

        allowIconRegeneration(self) -> bool

            Return True if this gallery entry wants to let Houdini regenerate
            the icon for it automatically using an appropriate renderer. Only
            applies to material gallery entries.


        """
    def setAllowIconRegeneration(self, on: bool) -> None:
        """

        setAllowIconRegeneration(self, allow)

            Sets the allow icon regeneration flag on this gallery entry.


        """
    def isHidden(self) -> bool:
        """

        isHidden(self) -> bool

            Return True if this gallery entry is hidden from the tools gallery
            menu.


        """
    def setHidden(self, hide: bool) -> None:
        """

        setHidden(self, hide)

            Set the hidden flag which controls whether a gallery entry is shown
            in the tools gallery menu.


        """
    def bestNodeType(self) -> Optional[NodeType]:
        """

        bestNodeType(self) -> NodeType or None

            Return a best node type which this gallery entry is associated with
            and whose nodes it can be applied to.


        """
    def nodeTypeNames(self) -> Tuple[str, ...]:
        """

        nodeTypeNames(self) -> tuple of strings

            Return the names of the node type this gallery is associated with.
            The gallery can be safely applied to the nodes of these types.


        """
    def setNodeTypeNames(self, nodetypes: Sequence[str]) -> None:
        """

        setNodeTypeNames(self, nodetypes)

            Set the names of the node types this gallery should be associated
            with.


            nodetypes
                A string containing white-space separated list of node type
                names.


        """
    def categories(self) -> Tuple[str, ...]:
        """

        categories(self) -> tuple of strings

            Return the categories this gallery entry subscribes to.


        """
    def setCategories(self, categories: Sequence[str]) -> None:
        """

        setCategories(self, categories)

            Set the categories this gallery entry subscribes to.


            categories
                A sequence of strings containing the categories to set the
                gallery entry to.


        """
    def keywords(self) -> Tuple[str, ...]:
        """

        keywords(self) -> tuple of strings

            Return the keywords that describe this gallery entry.


        """
    def setKeywords(self, keywords: Sequence[str]) -> None:
        """

        setKeywords(self, keywords)

            Set the keywords that describe this gallery entry.


            keywords
                A string containing a white-space separated list of keywords.


        """
    def nodeTypeCategory(self) -> NodeTypeCategory:
        """

        nodeTypeCategory(self) -> NodeTypeCategory

            Return the category of the node types this gallery entry is
            associated with.


        """
    def setNodeTypeCategory(self, category: NodeTypeCategory) -> None:
        """

        setNodeTypeCategory(self, category)

            Set the category of the node types this gallery entry should be
            associated with.


            category
                A hou.NodeTypeCategory to associate this gallery entry with.


        """
    def script(self) -> str:
        """

        script(self) -> string

            Return a script that modifies the node parameters to match the
            information stored in the gallery entry.


        """
    def setScript(self, script: str) -> None:
        """

        setScript(self, script)

            Set a script that modifies the parameters when the gallery entry is
            applied to a node.


            script
                A string that contains the commands setting the node's
                parameters.


        """
    def setScriptFromNode(self, node: Node) -> None:
        """

        setScriptFromNode(self, node)

            Set a script that modifies node parameters. Later on, when applying
            this gallery entry to a node, the script will reconstruct that
            node's parameters to match exactly the parameters of a node passed
            to this method.


            node
                A node object from which to build the script.


        """
    def setContentsFromNode(self, node: Node) -> None:
        """

        setContentsFromNode(self, node)

            Save the information about the node contents (i.e., child nodes).
            When applying the node entry later on, these nodes will be
            reconstructed in a new parent to match the contents of the current
            parent.


            node
                The parent of the nodes whose data should be saved.


        """

class Geometry:
    """

    hou.Geometry

    A Geometry object contains the points and primitives that define a 3D
    geometric shape. For example, each SOP node in Houdini generates a
    single Geometry object.

    If you ask a SOP for its geometry via hou.SopNode.geometry, you'll get a
    read-only reference to it. If the SOP recooks, the corresponding
    Geometry object will update to the SOP's new geometry. If the SOP is
    deleted, accessing the Geometry object will raise a hou.ObjectWasDeleted
    exception. If you call methods that try to modify the geometry, they
    will raise a hou.GeometryPermissionError exception.


    NOTE
        Whenever you call a method on a hou.Geometry object, Houdini will
        first attempt to acquire a handle to the underlying geometry. When
        working with read-only references to geometry on a SOP node, if the
        SOP in question fails to cook after the read-only reference has been
        assigned to a variable then any calls to methods on that variable
        will throw a hou.InvalidGeometry exception. If you receive this
        exception, your read-only reference is still 'live' and so methods
        on it will be accessible when the node errors are resolved, until
        then your code should handle this exception to avoid getting further
        errors. See hou.Geometry.isValid

    If you do not want the geometry to update when the SOP recooks, you can
    call hou.Geometry.freeze. freeze returns another Geometry object that
    will not change when the SOP recooks. Accessing frozen Geometry is
    slightly faster, since Houdini does not need to look up the SOP node for
    each access, so you may want to use frozen geometry for speed-crucial
    operations.

    If you're writing a SOP using Python, you will have read-write access to
    the geometry, and it will be frozen. To create a Python-defined SOP,
    select File > New Operator Type... and place the Python code in the Code
    tab.

    Finally, you can allocate a new frozen geometry with read-write access
    by creating an instance of hou.Geometry.

    GEOMETRY MODIFICATION

        Since Houdini 18, modifying geometry outside of cooking that is then
        passed into other HOM methods requires a corresponding increment of
        the appropriate data ids as well as incrementing the modification
        counter. This is especially important if you pass this geometry to
        be processed such as hou.SopVerb.execute since it uses data id
        optimizations. The simplest way to do this is to call
        hou.Geometry.incrementAllDataIds. However, a fine-grained list of
        methods can used to obtain the best performance:
        hou.Geometry.incrementDataIdsForAddOrRemove,
        hou.Geometry.incrementPrimitiveIntrinsicsDataId,
        hou.Geometry.incrementTopologyDataId, hou.Attrib.incrementDataId,
        hou.PointGroup.incrementDataId, hou.PrimGroup.incrementDataId,
        hou.EdgeGroup.incrementDataId, hou.VertexGroup.incrementDataId,
        hou.Geometry.incrementModificationCounter.

        When modifying geometry while inside a SOP, all data ids are
        automatically incremented, as well as the geometry change counter.
        To opt out of automatic data ids incrementing, call
        hou.SopNode.setManagesAttribDataIds with True. Note that you cannot
        opt out of incrementing the geometry change counter, it must be
        always done whenever a SOP node cooks. When unsure, it is better to
        leave hou.SopNode.managesAttribDataIds to the default False or else
        there is a risk that users of the output geometry (eg. the viewport)
        will fail to update when the geometry has changed.

    RELATED

      * hou.AttribDataId


    """
    thisown: Incomplete
    def __init__(self, geo: Optional[Geometry] = None, clone_data_ids: bool = False) -> None:
        """

        isValid(self)

            Check that the hou.Geometry object references a non-null geometry.

            Will only be False when the hou.Geometry is a read-only reference to
            a SOP node's geometry that has failed to cook since the reference
            was assigned.

            Will always be True for a 'frozen' geometry, see also
            hou.Geometry.freeze.


        """
    __swig_destroy__: Incomplete
    def sopNode(self) -> Optional[SopNode]:
        """

        sopNode(self) -> hou.SopNode

            If the Geometry is not frozen, return the hou.SopNode object
            corresponding to this Geometry. Otherwise, return None.

            See hou.Geometry.freeze for more information on frozen geometry.


        """
    def sopNodeOutputIndex(self) -> int:
        """

        sopNodeOutputIndex(self) -> int

            If the Geometry is not frozen, return the index of the SOP node
            output that this geometry corresponds to. Otherwise, return -1.

            For most cases this method will return 0 to indicate that the
            geometry corresponds to the first output. This method will only
            return a value other than 0 for SOP nodes that have multiple
            outputs.

            See hou.Geometry.freeze for more information on frozen geometry.


        """
    def isValid(self) -> bool: ...
    def freeze(self, read_only: bool = False, clone_data_ids: bool = False) -> Geometry:
        """

        freeze(self, read_only=False, clone_data_ids=False) -> hou.Geometry

            Return another Geometry object that is not linked to a particular
            SOP.

            Normally, when you call hou.SopNode.geometry, the resultant Geometry
            object retains a reference to that SOP, and is said to be unfrozen.
            Each time you access points, primitives, attributes, etc. in an
            unfrozen Geometry object, Houdini uses the SOP's latest cooked
            geometry. So, if you change parameters or change the time for an
            animated SOP, the Geometry object will update to the SOP's new
            geometry.

            Unless Python SOPs are involved, a frozen Geometry object does not
            have a similar live association with a particular SOP. If you ask a
            SOP for its geometry and then store a frozen copy of that geometry,
            when the SOP recooks the frozen Geometry object will not update.
            Instead, the frozen geometry saves its own copy of the point and
            primitive data, and is unaffected by subsequent changes to the SOP.
            When a frozen Geometry object is destroyed, any geometry copy it
            created is also destroyed.

            Note that accessing a Geometry object's points, primitives,
            attributes, etc. may be faster when dealing with frozen objects. You
            may want to work with frozen Geometry in speed-sensitive operations.

            Calling this method on an unfrozen Geometry object returns a frozen
            one. Calling it on a frozen object has no effect, and it returns a
            frozen object.

            When a Python-defined SOP cooks and runs Python code that asks for
            the SOP's geometry, the returned Geometry object is writable.
            Modifying this Geometry object affects the output of this SOP. For
            efficiency, this geometry object is already frozen, so calling
            freeze on it has no effect.


            read_only
                If True, the resulting frozen geometry will be read-only. Use
                read-only frozen geometry to share embedded geometry among
                multiple packed primitives.

            clone_data_ids
                If the conditions of this method causes a copy of the geometry
                to be made, then this specifies whether the new copy will have
                the same data ids. This is useful to enable optimizations that
                cache data by only looking at the attribute data id regardless
                of whether it is from the same geometry object or not.
                Otherwise, the new copy will have data ids that are unique.


        """
    def pointCount(self) -> int:
        """

        pointCount(self) -> int

            Returns the number of points in the geometry.


        """
    def vertexCount(self) -> int:
        """

        vertexCount(self) -> int

            Returns the number of vertices in the geometry.


        """
    def primCount(self) -> int:
        """

        primCount(self) -> int

            Returns the number of primitivesin the geometry.


        """
    def iterPoints(self) -> _PointTupleGenerator:
        """

        iterPoints(self) -> generator of hou.Point

            Return a generator that iterates through all the points in the
            geometry.

            Whereas hou.Geometry.points allocates and returns a tuple of all the
            points in the geometry, this method returns a generator object that
            will allocate hou.Point objects on demand. This object is very fast
            at random access into the sequence.

            If you're accessing a specific point by index and the geometry
            contains many points, it is faster to use iterPoints() than
            points(). If, however, you are iterating over all the points in the
            geometry, it is generally faster to use points() than iterPoints().

          > # This is preferred:
          > geo.iterPoints()[23]
          > 
          > # over this:
          > geo.points()[23]
          > 
          > # But this is preferred:
          > for point in geo.points():
          >     ...process point...
          > 
          > # over this:
          > for point in geo.iterPoints():
          >     ...process point...

        """
    def points(self) -> Tuple[Point, ...]:
        """

        points(self) -> tuple of hou.Point

            Return a tuple of all the points in the geometry.

            See also the hou.Geometry.iterPoints method.


        """
    def point(self, index: int) -> Optional[Point]:
        """

        point(self, index) -> hou.Point

            Return the point at the specified index.

            This is a convenience method for accessing a particular point
            without the overhead of obtaining all points via
            hou.Geometry.points.

            Return None if no such point at the specified index exists.


        """
    def iterPrims(self) -> _PrimTupleGenerator:
        """

        iterPrims(self) -> generator of hou.Prim

            Return a generator that iterates through all the primitives in the
            geometry.

            Whereas hou.Geometry.prims allocates and returns a tuple of all the
            primitives in the geometry, this method returns a generator object
            that will yield hou.Prim objects on demand. This object is very fast
            at random access into the sequence.

            If you're accessing a specific primitive by index and the geometry
            contains many primitives, it is faster to use iterPrims() than
            prims(). If, however, you are iterating over all the primitives in
            the geometry, it is generally faster to use prims() than
            iterPrims().

          > # This is preferred:
          > geo.iterPrims()[23]
          > 
          > # over this:
          > geo.prims()[23]
          > 
          > # But this is preferred:
          > for prim in geo.prims():
          >     ...process prim...
          > 
          > # over this:
          > for prim in geo.iterPrims():
          >     ...process prim...

            See also the hou.Geometry.prims method.


        """
    def prims(self) -> Tuple[Prim, ...]:
        """

        prims(self) -> tuple of hou.Prim

            Return a tuple of all the primitives in the geometry. The primitives
            returned will be subclasses of hou.Prim (e.g.polygons, volumes,
            etc.).

            See also:

          * hou.Geometry.iterPrims

          * hou.Face

          * hou.Polygon

          * hou.Surface

          * hou.Volume


        """
    def prim(self, index: int) -> Optional[Prim]:
        """

        prim(self, index) -> hou.Prim

            Return the primitive at the specified index.

            This is a convenience method for accessing a particular primitive
            without the overhead of obtaining all primitives via
            hou.Geometry.prims.

            Return None if no such primitive at the specified index exists.


        """
    def primTypeNames(self) -> Tuple[str, ...]:
        """

        primTypeNames(self) -> tuple of str

            Returns a list of all possible primitive type names. These are the
            internal names, as used by containsPrimType and similar functions.
            This includes HDK definied primitive types.

            Note the order may vary depending on library orders, but will be
            consistent with the other primType methods..


        """
    def primTypeLabels(self) -> Tuple[str, ...]:
        """

        primTypeLabels(self) -> tuple of str

            Returns a list of all possible primitive type labels. These are the
            external names meant to be more human readable. This includes HDK
            definied primitive types.

            Note the order may vary depending on library orders, but will be
            consistent with the other primType methods..


        """
    def primTypeIcons(self) -> Tuple[str, ...]:
        """

        primTypeIcons(self) -> tuple of str

            Returns a list of all possible primitive type icons. These are icon
            files that represent the primitive. Many are not defined. This
            includes HDK definied primitive types.

            Note the order may vary depending on library orders, but will be
            consistent with the other primType methods..


        """
    def containsPrimType(self, type_or_name: EnumValue|str) -> bool:
        '''

        containsPrimType(self, type_or_name) -> bool

            Returns whether the geometry contains at least one primitive of the
            specified type.


            type_or_name
                A hou.primType, or a string containing the name of a primitive
                type.

                Typical examples of string values are \\"Poly\\" (polygon) or
                \\"PackedAgent\\" (agent packed primitive). To see a complete list
                of possible typename values, run ginfo -P on a Houdini tools
                command line.


        '''
    def countPrimType(self, type_or_name: EnumValue|str) -> int:
        '''

        countPrimType(self, type_or_name) -> long

            Returns the number of primitives of the specified type in the
            geometry.


            type_or_name
                A hou.primType, or a string containing the name of a primitive
                type.

                Typical examples of string values are \\"Poly\\" (polygon) or
                \\"PackedAgent\\" (agent packed primitive). To see a complete list
                of possible typename values, run ginfo -P on a Houdini tools
                command line.


        '''
    def countUnusedPoints(self) -> int:
        """

        countUnusedPoints(self) -> long

            Returns the number of points in the geometry that are not part of
            any primitive.


        """
    def primsOfType(self, prim_type: EnumValue) -> Tuple[Prim, ...]:
        """

        primsOfType(primtype) -> tuple of hou.Prim

            Return a tuple of the primitives of the specified type in the
            geometry. The primitives returned will be subclasses of hou.Prim
            (e.g.polygons, volumes, etc.).


        """
    def iterPrimsOfType(self, prim_type: EnumValue) -> Iterator[Prim]:
        """

        iterPrimsOfType(primtype) -> generator of hou.Prim

            Return a generator that iterates through all the primitives of the
            specified type in the geometry.

            See also the hou.Geometry.prims and hou.Geometry.iterPrims methods.


        """
    def preferredPrecision(self) -> int:
        """

        preferredPrecision(self) -> int

            Returns the preferred computation precision of the geometry. This
            can be used to determine what sort of attributes to create and what
            precision to run intermediate computations in. Can be either 32 or
            64.


        """
    def setPreferredPrecision(self, prec: int) -> None:
        """

        setPreferredPrecision(self, int)

            Adjusts the preferred precision of the geometry. The value should be
            either 32 or 64. Nodes may use this precision as a hint to set
            default attribute creation and computation to a certain precision.


        """
    def averageMinDistance(self, local_transform: Matrix4, geometry: Geometry, geometry_transform: Matrix4) -> float:
        """

        averageMinDistance(self, local_transform, geometry, geometry_transform)
        -> float

            Return the average over all points in <geometry> of the minimum
            distance to the point set of <self>


            local_transform
                A transform to be applied to all points in this geometry.

            geometry
                The geometry to find distances from.

            geometry_transform
                A transform to be applied to all points in <geometry>.

            Raises hou.OperationFailed if <geometry> has no vertices.

          > query_geometry = query_node.geometry()
          > queried_geometry = queried_node.geometry()
          > 
          > # Return the average over all points in <queried_geometry> of the minimum
          > # distance to the point set of <query_geometry>
          > query_geometry.averageMinDistance(
          >     query_node.worldTransform(),
          >     queried_geometry,
          >     queried_node.worldTransform())

        """
    def averageEdgeLength(self) -> float:
        """

        averageEdgeLength(self) -> float

            Return the average edge length of the mesh.

            Raises hou.OperationFailed if mesh does not contain any edges.

          > # Return the average edge length.
          > geo.averageEdgeLength()

        """
    def globPoints(self, pattern: str, ordered: bool = False) -> Tuple[Point, ...]:
        '''

        globPoints(self, pattern, ordered=False) -> tuple of hou.Point

            Return a tuple of points corresponding to a pattern of point
            numbers.

            The pattern format is the same one used by the group fields on SOP
            nodes that take point selections. Elements in the pattern are
            separated by spaces, and elements can be point numbers, point number
            ranges, or group names.

            Optionally, the points can be returned in the order they were added
            to the group.

            This method can be useful when writing a Python SOP that works on
            only a selected set of points.

            Raises hou.OperationFailed if the pattern is not valid or if it
            refers to a group that does not exist. Note that an empty pattern is
            considered to be invalid. Numbers that do not refer to valid points
            are not errors, and simply do not match points.

          > # Return a tuple containing points 5 and 7.
          > geo.globPoints(\\"5 7\\")
          > 
          > # Return a tuple containing points 5 to 10.
          > geo.globPoints(\\"5-10\\")
          > 
          > # Return a tuple containing all the points in the pointgroup called group1.
          > geo.globPoints(\\"group1\\")
          > 
          > # Return all the points except those from 0 to 98.
          > geo.globPoints(\\"!0-98\\")
          > 
          > # Return points 5, 10 to 20, and those in group1.
          > geo.globPoints(\\"5 group1 10-20\\")

            The following Python SOP example is behaves similarly to the Point
            sop.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.  It assumes the Python sop has the following parm tuples:
          > #     group: A string containing which points to affect
          > #     t:     A set of 3 floats that behaves like the point sop\'s position
          > #            parameter.  Set these parameters to the expressions ($TX, $TY, $TZ).
          > geo = hou.pwd().geometry()
          > 
          > # Use the group field to determine which points to affect.  If it\'s blank,
          > # operate on all points.
          > pattern = hou.ch(\\"group\\")
          > if pattern == \\"\\":
          >     points = geo.points()
          > else:
          >     points = geo.globPoints(pattern)
          > 
          > # Loop through the points, setting the SOP\'s current point as we go.
          > # Then evaluate the t parm tuple, so it can use the current point (e.g.
          > # with hscript\'s $TX or Python\'s pwd().curPoint()).
          > for point in points:
          >     hou.pwd().setCurPoint(point)
          >     new_position = hou.pwd().evalParmTuple(\\"t\\")
          >     point.setPosition(new_position)

        '''
    def globPrims(self, pattern: str) -> Tuple[Prim, ...]:
        """

        globVertices(self, pattern) -> tuple of hou.Vertex

            Return a tuple of vertices corresponding to a pattern of vertex
            numbers.

            The pattern format is the same one used by the group fields on SOP
            nodes that take vertex selections. See hou.Geometry.globPoints for
            more information.


        """
    def globVertices(self, pattern: str) -> Tuple[Vertex, ...]: ...
    def globEdges(self, pattern: str) -> Tuple[Edge, ...]: ...
    def findPointAttrib(self, name: str, scope: EnumValue = ...) -> Attrib|None:
        """

        findPointAttrib(self, name, scope=hou.attribScope.Public) -> hou.Attrib
        or None

            Look up a point attribute by name. Returns the corresponding
            hou.Attrib object, or None if no attribute exists with that name.


            name
                The name of the point attribute.

            scope
                A hou.attribScope value to specify whether the attribute is
                public or private.

            Note that the point position attribute is named P and is 3 floats in
            size. Also, the point weight attribute is named Pw and is 1 float in
            size. P always exists, but Pw may not.

            See hou.Point.attribValue for an example.


        """
    def findPrimAttrib(self, name: str, scope: EnumValue = ...) -> Attrib|None:
        """

        findPrimAttrib(self, name, scope=hou.attribScope.Public) -> hou.Attrib
        or None

            Look up a primitive attribute by name. Returns the corresponding
            hou.Attrib object, or None if no attribute exists with that name.


            name
                The name of the primitive attribute.

            scope
                A hou.attribScope value to specify whether the attribute is
                public or private.


        """
    def findVertexAttrib(self, name: str, scope: EnumValue = ...) -> Attrib|None:
        """

        findVertexAttrib(self, name, scope=hou.attribScope.Public) -> hou.Attrib
        or None

            Look up a vertex attribute by name. Returns the corresponding
            hou.Attrib object, or None if no attribute exists with that name.


            name
                The name of the vertex attribute.

            scope
                A hou.attribScope value to specify whether the attribute is
                public or private.


        """
    def findGlobalAttrib(self, name: str, scope: EnumValue = ...) -> Attrib|None:
        """

        findGlobalAttrib(self, name, scope=hou.attribScope.Public) -> hou.Attrib
        or None

            Look up a global (a.k.a. detail) attribute by name. Returns the
            corresponding hou.Attrib object, or None if no attribute exists with
            that name.


            name
                The name of the global attribute.

            scope
                A hou.attribScope value to specify whether the attribute is
                public or private.


        """
    def attribType(self) -> EnumValue:
        """

        attribType(self) -> hou.attribType enum value

            Return the enumerated value hou.attribType.Global. Points,
            primitives, vertices, and geometry support the same set of methods
            for querying their attributes, and this method is one of them.

            See also:

          * hou.Prim.attribType

          * hou.Point.attribType

          * hou.Vertex.attribType


        """
    def floatAttribValue(self, name_or_attrib: str|Attrib) -> float:
        """

        floatAttribValue(self, name_or_attrib) -> float

            Return the global (a.k.a. detail) attribute value for a particular
            floating point attribute. The attribute may be specified by name or
            by hou.Attrib object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not a float of size 1.

            In most cases, you'll just use hou.Geometry.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
    def floatListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[float,...]:
        """

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the global (a.k.a. detail) attribute value for a particular
            floating point attribute. The attribute may be specified by name or
            by hou.Attrib object. The return value is a list of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a list with one element is returned.

            See also:

          * hou.Geometry.attribValue


        """
    def intAttribValue(self, attrib: Attrib|str) -> int:
        """

        intAttribValue(self, name_or_attrib) -> int

            Return the global (a.k.a. detail) attribute value for a particular
            integer attribute of size 1. The attribute may be specified by name
            or by hou.Attrib object. See hou.Geometry.floatAttribValue for more
            information.


        """
    def intListAttribValue(self, name_or_attrib: Attrib|str) -> Tuple[int,...]:
        """

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the global (a.k.a. detail) attribute value for a particular
            integer attribute. The attribute may be specified by name or by
            hou.Attrib object. The return value is a list of ints. See
            hou.Geometry.floatListAttribValue for more information.


        """
    def stringAttribValue(self, attrib: Attrib|str) -> str:
        """

        stringAttribValue(self, name_or_attrib) -> str

            Return the global (a.k.a. detail) attribute value for a particular
            string attribute. The attribute may be specified by name or by
            hou.Attrib object. See hou.Geometry.floatAttribValue for more
            information.


        """
    def stringListAttribValue(self, name_or_attrib: Attrib|str) -> Tuple[str,...]:
        """

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the global (a.k.a. detail) attribute value for a particular
            string attribute. The attribute may be specified by name or by
            hou.Attrib object. The return value is a list of strings. See
            hou.Geometry.floatListAttribValue for more information.


        """
    def dictAttribValue(self, attrib: Attrib|str) -> AttribDictReturnType:
        """

        dictAttribValue(self, name_or_attrib) -> dict

            Return the global (a.k.a detail) attribute value for a particular
            dictionary attribute. The attribute may be specified by name or by
            hou.Attrib object. See hou.Geometry.floatAttribValue for more
            information.


        """
    def dictListAttribValue(self, name_or_attrib: Attrib|str) -> Sequence[AttribDictReturnType]:
        """

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the global (a.k.a detail) attribute value for a particular
            dictionary attribute. The attribute may be specified by name or by
            hou.Attrib object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Geometry.floatAttribValue for more information.


        """
    def pointFloatAttribValues(self, name: str) -> Tuple[float, ...]:
        """

        pointFloatAttribValues(self, name) -> tuple of float

            Return a tuple of floats containing one attribute's values for all
            the points.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each point will correspond to
            multiple values in the result. For example, if Cd is a float
            attribute of size 3 and there are 3 points with values (0.1, 0.2,
            0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
            (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

            Calling this method is faster than looping over all the points and
            calling hou.Point.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def pointFloatAttribValuesAsString(self, name: str, float_type: EnumValue = ...) -> bytes:
        '''

        pointFloatAttribValuesAsString(self, name,
        float_type=hou.numericData.Float32) -> str for Python 2, bytes for
        Python 3

            Return a binary string representation of the floats of one
            attribute\'s value for all the points. This method is faster than
            hou.Geometry.pointFloatAttribValues, and you can use the array
            module to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            float_type
                A hou.numericData value to specify the float data type (either
                Float16, Float32 or Float64).

            This method provides a faster implementation of the following:

          > import array
          > def pointFloatAttribValuesAsString(self, name):
          >     return array.array(\\"f\\", self.pointFloatAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def pointFloatAttribValuesAsArray(geometry, name):
          >     a = array.array(\\"f\\")
          >     a.fromstring(geometry.pointFloatAttribValuesAsString(name))
          >     return a

            See hou.Geometry.pointFloatAttribValues for more information.


        '''
    def primFloatAttribValues(self, name: str) -> Tuple[float, ...]:
        """

        primFloatAttribValues(self, name) -> tuple of float

            Return a tuple of floats containing one attribute's values for all
            the primitives.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each primitive will correspond to
            multiple values in the result. For example, if Cd is a float
            attribute of size 3 and there are 3 primitives with values (0.1,
            0.2, 0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will
            be (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

            Calling this method is faster than looping over all the primitives
            and calling hou.Prim.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def primFloatAttribValuesAsString(self, name: str, float_type: EnumValue = ...) -> bytes:
        '''

        primFloatAttribValuesAsString(self, name) -> str for Python 2, bytes for
        Python 3

            Return a binary string representation of the floats of one
            attribute\'s value for all the primitives. This method is faster than
            hou.Geometry.primFloatAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            This method provides a faster implementation of the following:

          > import array
          > def primFloatAttribValuesAsString(self, name):
          >     return array.array(\\"f\\", self.primFloatAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def primFloatAttribValuesAsArray(geometry, name):
          >     a = array.array(\\"f\\")
          >     a.fromstring(geometry.primFloatAttribValuesAsString(name))
          >     return a

            See hou.Geometry.primFloatAttribValues for more information.


        '''
    def vertexFloatAttribValues(self, name: str) -> Tuple[float, ...]:
        """

        vertexFloatAttribValues(self, name) -> tuple of float

            Return a tuple of floats containing one attribute's values for all
            the vertices.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each vertex will correspond to
            multiple values in the result. For example, if attrib is a float
            attribute of size 3 and there are 3 vertices with values (0.1, 0.2,
            0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
            (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).

            Calling this method is faster than looping over all the vertices and
            calling hou.Vertex.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def vertexFloatAttribValuesAsString(self, name: str, float_type: EnumValue = ...) -> bytes:
        '''

        vertexFloatAttribValuesAsString(self, name,
        float_type=hou.numericData.Float32) -> str for Python 2, bytes for
        Python 3

            Return a binary string representation of the floats of one
            attribute\'s value for all the vertices. This method is faster than
            hou.Geometry.vertexFloatAttribValues, and you can use the array
            module to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            float_type
                A hou.numericData value to specify the float data type (either
                Float16, Float32 or Float64).

            This method provides a faster implementation of the following:

          > import array
          > def vertexFloatAttribValuesAsString(self, name):
          >     return array.array(\\"f\\", self.vertexFloatAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def vertexFloatAttribValuesAsArray(geometry, name):
          >     a = array.array(\\"f\\")
          >     a.fromstring(geometry.vertexFloatAttribValuesAsString(name))
          >     return a

            See hou.Geometry.vertexFloatAttribValues for more information.


        '''
    def pointIntAttribValues(self, name: str) -> Tuple[int, ...]:
        """

        pointIntAttribValues(self, name) -> tuple of int

            Return a tuple of integers containing one attribute's values for all
            the points.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each point will correspond to
            multiple values in the result. For example, if idmap is an integer
            attribute of size 2 and there are 3 points with values (1, 2), (2,
            3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).

            Calling this method is faster than looping over all the points and
            calling hou.Point.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def pointIntAttribValuesAsString(self, name: str, int_type: EnumValue = ...) -> bytes:
        '''

        pointIntAttribValuesAsString(self, name, int_type=hou.numericData.Int32)
        -> str for Python 2, bytes for Python 3

            Return a binary string representation of the integers of one
            attribute\'s value for all the points. This method is faster than
            hou.Geometry.pointIntAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            int_type
                A hou.numericData value to specify the integer data type (either
                Int8, Int16, Int32 or Int64).

            This method provides a faster implementation of the following:

          > import array
          > def pointIntAttribValuesAsString(self, name):
          >     return array.array(\\"i\\", self.pointIntAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def pointIntAttribValuesAsArray(geometry, name):
          >     a = array.array(\\"i\\")
          >     a.fromstring(geometry.pointIntAttribValuesAsString(name))
          >     return a

            See hou.Geometry.pointIntAttribValues for more information.


        '''
    def primIntAttribValues(self, name: str) -> Tuple[int, ...]:
        """

        primIntAttribValues(self, name) -> tuple of int

            Return a tuple of integers containing one attribute's values for all
            the primitives.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each primitive will correspond to
            multiple values in the result. For example, if idmap is an integer
            attribute of size 2 and there are 3 primitives with values (1, 2),
            (2, 3), and (3,4) then the result will be (1, 2, 2, 3, 3, 4).

            Calling this method is faster than looping over all the primitives
            and calling hou.Prim.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def primIntAttribValuesAsString(self, name: str, int_type: EnumValue = ...) -> bytes:
        '''

        primIntAttribValuesAsString(self, name, int_type=hou.numericData.Int32)
        -> str for Python 2, bytes for Python 3

            Return a binary string representation of the integers of one
            attribute\'s value for all the primitives. This method is faster than
            hou.Geometry.primFloatAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            int_type
                A hou.numericData value to specify the integer data type (either
                Int8, Int16, Int32 or Int64).

            This method provides a faster implementation of the following:

          > import array
          > def primIntAttribValuesAsString(self, name):
          >     return array.array(\\"i\\", self.primIntAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def primIntAttribValuesAsArray(geometry, name):
          >     a = array.array(\\"i\\")
          >     a.fromstring(geometry.primIntAttribValuesAsString(name))
          >     return a

            See hou.Geometry.primIntAttribValues for more information.


        '''
    def vertexIntAttribValues(self, name: str) -> Tuple[int, ...]:
        """

        vertexIntAttribValues(self, name) -> tuple of int

            Return a tuple of integers containing one attribute's values for all
            the vertices.

            This method only works on int or float attributes. If the attribute
            contains more than one element, each vertex will correspond to
            multiple values in the result. For example, if idmap is an integer
            attribute of size 2 and there are 3 vertices with values (1, 2), (2,
            3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).

            Calling this method is faster than looping over all the vertices and
            calling hou.Vertex.attribValue.

            If the attribute name is invalid or the attribute is not an int or
            float (e.g. it's a string attribute), this method raises
            hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def vertexIntAttribValuesAsString(self, name: str, int_type: EnumValue = ...) -> bytes:
        '''

        vertexIntAttribValuesAsString(self, name,
        int_type=hou.numericData.Int32) -> str for Python 2, bytes for Python 3

            Return a binary string representation of the integers of one
            attribute\'s value for all the vertices. This method is faster than
            hou.Geometry.vertexIntAttribValues, and you can use the array module
            to convert the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.


            int_type
                A hou.numericData value to specify the integer data type (either
                Int8, Int16, Int32 or Int64).

            This method provides a faster implementation of the following:

          > import array
          > def vertexIntAttribValuesAsString(self, name):
          >     return array.array(\\"i\\", self.vertexIntAttribValues(name)).tostring()

            You can convert the return value from this method to an array using
            the following method:

          > import array
          > def vertexIntAttribValuesAsArray(geometry, name):
          >     a = array.array(\\"i\\")
          >     a.fromstring(geometry.vertexIntAttribValuesAsString(name))
          >     return a

            See hou.Geometry.vertexIntAttribValues for more information.


        '''
    def pointStringAttribValues(self, name: str) -> Tuple[str, ...]:
        """

        pointStringAttribValues(self, name) -> tuple of str

            Return a tuple of strings containing one attribute's values for all
            the points.

            This method only works on string attributes. If the attribute
            contains more than one element, each point will correspond to
            multiple values in the result. For example, if strmap is a string
            attribute of size 2 and there are 3 points with values (apple,
            orange), (red, blue), and (one, two) then the result will be (apple,
            orange, red, blue, one, two).

            Calling this method is faster than looping over all the points and
            calling hou.Point.attribValue.

            If the attribute name is invalid or the attribute is not a string
            attribute then this method raises hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def primStringAttribValues(self, name: str) -> Tuple[str, ...]:
        """

        primStringAttribValues(self, name) -> tuple of str

            Return a tuple of strings containing one attribute's values for all
            the primitives.

            This method only works on string attributes. If the attribute
            contains more than one element, each primitive will correspond to
            multiple values in the result. For example, if strmap is a string
            attribute of size 2 and there are 3 primitives with values (apple,
            orange), (red, blue), and (one, two) then the result will be (apple,
            orange, red, blue, one, two).

            Calling this method is faster than looping over all the primitives
            and calling hou.Prim.attribValue.

            If the attribute name is invalid or the attribute is not a string
            attribute) then this method raises hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def vertexStringAttribValues(self, name: str) -> Tuple[str, ...]:
        """

        vertexStringAttribValues(self, name) -> tuple of str

            Return a tuple of strings containing one attribute's values for all
            the vertices.

            This method only works on string attributes. If the attribute
            contains more than one element, each vertex will correspond to
            multiple values in the result. For example, if strmap is a string
            attribute of size 2 and there are 3 vertices with values (apple,
            orange), (red, blue), and (one, two) then the result will be (apple,
            orange, red, blue, one, two).

            Calling this method is faster than looping over all the vertices and
            calling hou.Vertex.attribValue.

            If the attribute name is invalid or the attribute is not a string
            attribute then this method raises hou.OperationFailed.

            Note that you cannot pass a hou.Attrib object to this method like
            you can with many methods dealing with attributes. However, you can
            use hou.Attrib.name to easily get the name from an Attrib object.


        """
    def setPointFloatAttribValues(self, name: str, values: Sequence[float]) -> None:
        """

        setPointFloatAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all points.
            You would typically call this method from the code of a Python-
            defined SOP.


            name
                The name of the point attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.pointFloatAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.pointFloatAttribValues.


        """
    def setPrimFloatAttribValues(self, name: str, values: Sequence[float]) -> None:
        """

        setPrimFloatAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            primitives. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the primitive attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.primFloatAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.primFloatAttribValues.


        """
    def setVertexFloatAttribValues(self, name: str, values: Sequence[float]) -> None:
        """

        setVertexFloatAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            vertices. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the vertex attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.vertexFloatAttribValues. See that
                method for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.vertexFloatAttribValues.


        """
    def setPointFloatAttribValuesFromString(self, name: str, values: bytes, float_type: EnumValue = ...) -> None: ...
    def setPrimFloatAttribValuesFromString(self, name: str, values: bytes, float_type: EnumValue = ...) -> None: ...
    def setVertexFloatAttribValuesFromString(self, name: str, values: bytes, float_type: EnumValue = ...) -> None: ...
    def setPointIntAttribValues(self, name: str, values: Sequence[int]) -> None:
        """

        setPointIntAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all points.
            You would typically call this method from the code of a Python-
            defined SOP.


            name
                The name of the point attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.pointIntAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.pointIntAttribValues.


        """
    def setPrimIntAttribValues(self, name: str, values: Sequence[int]) -> None:
        """

        setPrimIntAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            primitives. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the primitive attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.primFloatAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.primIntAttribValues.


        """
    def setVertexIntAttribValues(self, name: str, values: Sequence[int]) -> None:
        """

        setVertexIntAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            vertices. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the vertex attribute.

            values
                A sequence of int or float values in the same format as that
                returned by hou.Geometry.vertexIntAttribValues. See that method
                for more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not an int or float (i.e. it's a string), or the array
            of values is not the correct size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.vertexIntAttribValues.


        """
    def setPointIntAttribValuesFromString(self, name: str, values: bytes, int_type: EnumValue = ...) -> None: ...
    def setPrimIntAttribValuesFromString(self, name: str, values: bytes, int_type: EnumValue = ...) -> None: ...
    def setVertexIntAttribValuesFromString(self, name: str, values: bytes, int_type: EnumValue = ...) -> None: ...
    def setPointStringAttribValues(self, name: str, values: Sequence[str]) -> None:
        """

        setPointStringAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all points.
            You would typically call this method from the code of a Python-
            defined SOP.


            name
                The name of the point attribute.

            values
                A sequence of string values in the same format as that returned
                by hou.Geometry.pointStringAttribValues. See that method for
                more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not a string, or the array of values is not the correct
            size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.pointStringAttribValues.


        """
    def setPrimStringAttribValues(self, name: str, values: Sequence[str]) -> None:
        """

        setPrimStringAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            primitives. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the primitive attribute.

            values
                A sequence of string values in the same format as that returned
                by hou.Geometry.primStringAttribValues. See that method for more
                information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not a string, or the array of values is not the correct
            size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.primStringAttribValues.


        """
    def setVertexStringAttribValues(self, name: str, values: Sequence[str]) -> None:
        """

        setVertexStringAttribValues(self, name, values)

            For a particular attribute, set the attribute values for all
            vertices. You would typically call this method from the code of a
            Python-defined SOP.


            name
                The name of the vertex attribute.

            values
                A sequence of string values in the same format as that returned
                by hou.Geometry.vertexStringAttribValues. See that method for
                more information.

            Raises hou.OperationFailed if the attribute name is not valid, the
            attribute is not a string, or the array of values is not the correct
            size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Also see hou.Geometry.vertexStringAttribValues.


        """
    def renamePointAttrib(self, old_name: str, new_name: str) -> None:
        """

        renamePointAttrib(self, old_name, new_name)

            Rename the point attribute with the specified old name to the new
            name. This method is typically called from within a Python-defined
            SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such point attribute with the old name exists.
            Raises OperationFailed if a point attribute with the new name
            already exists.


        """
    def renamePrimAttrib(self, old_name: str, new_name: str) -> None:
        """

        renamePrimAttrib(self, old_name, new_name)

            Rename the primitive attribute with the specified old name to the
            new name. This method is typically called from within a Python-
            defined SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such primitive attribute with the old name
            exists. Raises OperationFailed if a primitive attribute with the new
            name already exists.


        """
    def renameVertexAttrib(self, old_name: str, new_name: str) -> None:
        """

        renameVertexAttrib(self, old_name, new_name)

            Rename the vertex attribute with the specified old name to the new
            name. This method is typically called from within a Python-defined
            SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such vertex attribute with the old name
            exists. Raises OperationFailed if a vertex attribute with the new
            name already exists.


        """
    def renameGlobalAttrib(self, old_name: str, new_name: str) -> None:
        """

        renameGlobalAttrib(self, old_name, new_name)

            Rename the global attribute with the specified old name to the new
            name. This method is typically called from within a Python-defined
            SOP when the SOP's geometry is writable.

            Raises GeometryPermissionError if called on a read-only geometry.
            Raises TypeError if old_name or new_name is None. Raises
            OperationFailed if no such global attribute with the old name
            exists. Raises OperationFailed if a global attribute with the new
            name already exists.


        """
    def createPoint(self) -> Point:
        """

        createPoint(self) -> hou.Point

            Create a new point located at (0, 0, 0) and return the corresponding
            hou.Point object. You would typically call this method from the code
            of a Python-defined SOP.

            If the geometry contains point attributes, the new point receives
            the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See hou.Geometry.addAttrib, hou.Geometry.createPolygon, and
            hou.Face.addVertex for examples.


        """
    def createPoints(self, point_positions: Sequence[Sequence[float]]) -> Tuple[Point,...]:
        """

        createPoints(self, point_positions) -> tuple of hou.Point

            Create a set of points located at the specified positions and return
            a tuple of the new hou.Point objects. You would typically call this
            method from the code of a Python-defined SOP.

            point_positions can be either a tuple of hou.Vector3 objects or a
            tuple of 3-tuple floating point numbers. For example, if
            point_positions is ((0, 1, 2), (1, 2, 3)) then this method will
            create 2 points with one positioned at (0, 1, 2) and the other at
            (1, 2, 3).

            If the geometry contains point attributes, the new points receive
            the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable. Raises hou.InvalidSize if one of the specified point
            positions does not contain 3 values (for x, y, z).

            See hou.Geometry.addAttrib, hou.Geometry.createPolygons, and
            hou.Face.addVertex for examples.


        """
    def createPolygon(self, is_closed: bool = True) -> Polygon:
        """

        createPolygon(self, is_closed=True) -> hou.Polygon

            Create a new polygon and return the corresponding hou.Polygon
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created polygon has no vertices. Use hou.Face.addVertex to
            add them. The polygon is also closed (see hou.Face.isClosed for more
            information) by default unless specified otherwise for a polygon
            curve.

            If the geometry contains primitive attributes, the new polygon
            receives the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > geo = hou.pwd().geometry()
          > poly = geo.createPolygon()
          > for position in (0,0,0), (1,0,0), (0,1,0):
          >     point = geo.createPoint()
          >     point.setPosition(position)
          >     poly.addVertex(point)

            See hou.Face.addVertex for a slightly more complicated example.


        """
    def createPolygons(self, point_positions: Sequence[Point|Sequence[int]], is_closed: bool = ...) -> Tuple[Polygon,...]:
        """

        createPolygons(self, points, is_closed=True) -> tuple of hou.Polygon

            Create a set of polygons with the specified points as vertices and
            return a tuple of the new hou.Polygon objects. You would typically
            call this method from the code of a Python-defined SOP.

            points can be either a tuple of tuples of hou.Point objects or a
            tuple of tuples of integers representing the point numbers. For
            example, if points is ((0, 1, 2), (3, 4, 5, 6)) then this method
            will create 2 polygons with one having points 0, 1 and 2 as its
            vertices and the other one having points 3, 4, 5 and 6 as its
            vertices.

            The created polygons are closed (see hou.Face.isClosed for more
            information) by default unless specified otherwise for polygon
            curves.

            If the geometry contains primitive attributes, then the new polygons
            receive the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable. Raises hou.InvalidSize if one of the specified point
            tuples does not contain at least 3 elements. Raises hou.InvalidInput
            if one of the point numbers or hou.Point objects do not exist in the
            geometry.

            Example:

          > # Create 6 points in the geometry.
          > geo = hou.pwd().geometry()
          > point_positions = (
          >     (1, 0, 0), (0, 1, 0), (0, 0, 1),
          >     (1, 1, 0), (1, 0, 1), (0, 1, 1),
          > )
          > points = geo.createPoints(point_positions)
          > 
          > # Create 2 polygons.
          > # The first polygon uses the first 3 points in the geometry as its vertices.
          > # The second polygon uses the last 3 points in the geometry as its vertices.
          > polygons = geo.createPolygons(
          >     ((points[0], points[1], points[2]), (points[3], points[4], points[5])))

        """
    def createPacked(self, packed_type: str, point: Optional[Point] = None) -> PackedPrim:
        '''

        createPacked(self, typename, point=None) -> hou.PackedPrim


            typename
                A string containing the name of a type of packed primitive.
                Typical examples are \\"PackedDisk\\" (on-disk geometry file) or
                \\"AlembicRef\\" (Alembic file).

                To see a complete list of possible typename values, run ginfo -P
                on a Houdini tools command line.

            point

            See hou.PackedPrim for more information.


        '''
    def createTetrahedron(self) -> Prim:
        """

        createTetrahedron(self) -> hou.Prim

            Create a new tetrahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created tetrahedron has four vertices and new points have
            been allocated for them. To build a tetrahedron out of existing
            points, use hou.Geometry.createTetrahedronInPlace

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def createTetrahedronInPlace(self, p0: Point, p1: Point, p2: Point, p3: Point) -> Prim:
        """

        createTetrahedronInPlace(self, p0, p1, p2, p3) -> hou.Prim

            Create a new tetrahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created tetrahedron has four vertices and uses the points
            that have been passed into it.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def createHexahedron(self) -> Prim:
        """

        createHexahedron(self) -> hou.Prim

            Create a new hexahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created hexahedron has eight vertices and new points have
            been allocated for them. To build a hexahedron out of existing
            points, use hou.Geometry.createHexahedronInPlace

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def createHexahedronInPlace(self, p0: Point, p1: Point, p2: Point, p3: Point, p4: Point, p5: Point, p6: Point, p7: Point) -> Prim:
        """

        createHexahedronInPlace(self, p0, p1, p2, p3, p4, p5, p6, p7) ->
        hou.Prim

            Create a new hexahedron and return the corresponding hou.Prim
            object. You would typically call this method from the code of a
            Python-defined SOP.

            The newly created hexahedron has eight vertices and uses the points
            that have been passed into it.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def createNURBSCurve(self, num_points: int = 4, is_closed: bool = False, order: int = 4) -> Face:
        """

        createNURBSCurve(self, num_vertices=4, is_closed=False, order=4) ->
        hou.Face

            Create a new NURBS with the specified number of vertices and return
            it. You would typically call this method from the code of a Python-
            defined SOP.


            num_vertices
                The number of verticies in the curve. A new point is added to
                the geometry for each vertex, and this point is located at the
                origin until you change its position. You can also add more
                vertices with hou.Face.addVertex.

                The minimum number of vertices for a NURBS curve is identical to
                its order. So for the default order of 4, the curve must have a
                minimum of 4 vertices. If you specify too few vertices, this
                method raises hou.OperationFailed.

            is_closed
                Controls if the curve is open or closed; see hou.Face.isClosed
                for more information. If not specified, the resulting curve is
                open. This behavior is different from
                hou.Geometry.createPolygon, where the new polygon is closed. You
                can also open or close it with hou.Face.setIsClosed.

            order
                Specifies the curve's order. The default order is 4,
                corresponding to a cubic NURBS curve. An order of 2, the lowest
                order, will give a curve with linear segments.

            If the geometry contains primitive attributes, the new curve
            receives the default values for those attributes.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > curve = geo.createNURBSCurve(10)
          > i = 0
          > for vertex in curve.vertices():
          >     vertex.point().setPosition((i, i % 3, 0))
          >     i = i + 1

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also:

          * hou.Prim.vertices

          * hou.Point.setPosition


        """
    def createBezierCurve(self, num_points: int = 4, is_closed: bool = False, order: int = 4) -> Face:
        """

        createBezierCurve(num_points: 'int' = 4, is_closed: 'bool' = False,
        order: 'int' = 4) -> hou.Face

            Create a new Bezier curve with the specified number of vertices and
            return it. You would typically call this method from the code of a
            Python-defined SOP.


            num_vertices
                The number of verticies in the curve. A new point is added to
                the geometry for each vertex, and this point is located at the
                origin until you change its position. You can also add more
                vertices with hou.Face.addVertex.

            is_closed
                Controls if the curve is open or closed; see hou.Face.isClosed
                for more information. If not specified, the resulting curve is
                open. This behavior is different from
                hou.Geometry.createPolygon, where the new polygon is closed.

            order
                Specifies the curve's order. The default order is 4,
                corresponding to a cubic Bezier curve. An order of 2, the lowest
                order, will give a curve with linear segments.

            An open Bezier curve must have (order - 1) * n + 1 vertices for some
            integer n>=1 (so valid values for order 4 curves are 4, 7, 10,
            etc.). A closed Bezier curve must have (order - 1) * n vertices
            (e.g. 3, 6, 9, etc. for order 4 curve). This restriction does not
            apply to curves of order 2, however.

            As a consequence, you cannot use hou.Face.setIsClosed on non-linear
            Bezier curves, since the number of vertices would need to change.

            See hou.Geometry.createNURBSCurve for more information.


        """
    def createNURBSSurface(self, rows: int, cols: int, is_closed_in_u: bool = False, is_closed_in_v: bool = False, order_u: int = 4, order_v: int = 4) -> Surface:
        """

        createNURBSSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

            Create a NURBS surface in the XY plane centered at the origin with
            size (1, 1) and return it. You would typically call this method from
            the code of a Python-defined SOP.


            rows, cols
                Determines the size of the 2D array of vertices defining the
                control points of the surface. The number of cols and rows in
                each direction, must be equal to or larger than the U and V
                orders, respectively.

            is_closed_in_u, is_closed_in_v
                Controls if the surface is open or closed in each of the U and V
                directions; see hou.Surface.isClosedInU for more information. If
                not specified, the default behavior is to build an open surface.

            order_u, order_v
                Specifies the surface's order in each of the U and V directions.
                The default order for both is 4, corresponding to a cubic NURBS
                surface. An order of 2, the lowest order, will give a surface
                with linear segments, essentially a mesh.

            If the geometry contains primitive attributes, the new surface
            receives the default values for those attributes.

            You can move or resize the surface using
            hou.Geometry.transformPrims.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the number of rows and/or columns is
            invalid.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > 
          > # Create a surface with a 10x10 grid of vertices.
          > surf = geo.createNURBSSurface(10, 10)
          > 
          > # Initially, the center is at (0, 0, 0), size is (1, 1, 1), on the XY
          > # plane.  Scale to (20, 10) and rotate into the XZ plane.
          > geo.transformPrims((surf,),
          >     hou.hmath.buildScale((20, 10, 1)) *
          >     hou.hmath.buildRotateAboutAxis((1, 0, 0), 90))

            See also:

          * hou.Geometry.transformPrims

          * hou.Matrix4

          * hou.hmath


        """
    def createBezierSurface(self, rows: int, cols: int, is_closed_in_u: bool = False, is_closed_in_v: bool = False, order_u: int = 4, order_v: int = 4) -> Surface:
        """

        createBezierSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

            Create a Bezier surface in the XY plane centered at the origin with
            size (1, 1) and return it. You would typically call this method from
            the code of a Python-defined SOP.


            rows, cols
                Determines the size of the 2D array of vertices defining the
                control points of the surface.

                Note that the number of rows corresponds to v and the number or
                columns corresponds to u, which can be slightly confusing. For
                example, geo.createBezierSurface(9, 7, is_closed_in_u=False,
                is_closed_in_v=True) is valid, but geo.createBezierSurface(9, 7,
                is_closed_in_u=True, is_closed_in_v=False) raises
                hou.OperationFailed.

            is_closed_in_u, is_closed_in_v
                Determines if it is open or closed in each of the u and v
                directions; see hou.Surface.isClosedInU for more information.

            order_u, order_v
                Specifies the surface's order in of the U and V directions. The
                default order for both is 4, corresponding to a cubic NURBS
                surface. An order of 2, the lowest order, will give a surface
                with linear segments, essentially a mesh.

            As with Bezier curves, a Bezier surface has some restrictions on the
            point count in each of the U and V directions. For a given
            direction; if it's open the number of points in the direction must
            be (order - 1) * n + 1 for some integer n >= 1 (e.g. 4, 7, 10, ...).
            If it's open, the number of points must be (order - 1) * n where n
            >= 1 in that direction (e.g. 2, 4, 6, .. for order 3).

            You can move or resize the surface using
            hou.Geometry.transformPrims.

            If the geometry contains primitive attributes, the new surface
            receives the default values for those attributes.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > import math
          > 
          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > 
          > # Build a tube-like object about the y axis.
          > num_rows, num_cols = (10, 9)
          > surf = geo.createBezierSurface(num_rows, num_cols, is_closed_in_u=True)
          > for v_index in range(num_rows):
          >     for u_index in range(num_cols):
          >         angle = u_index * (2.0 * math.pi) / num_cols
          >         surf.vertex(u_index, v_index).point().setPosition(
          >             (math.cos(angle), v_index / float(num_cols-1), math.sin(angle)))

        """
    def createMeshSurface(self, rows: int, cols: int, is_closed_in_u: bool = False, is_closed_in_v: bool = False) -> Surface:
        """

        createMeshSurface(self, rows, cols, is_closed_in_u=False,
        is_closed_in_v=False) -> hou.Surface

            Create a quadrilateral mesh surface in the XY plane centered at the
            origin with size (1, 1) and return it. You would typically call this
            method from the code of a Python-defined SOP.

            Note that a mesh object is not the same as a set of polygons
            defining the same shape. A mesh object is a single primitive.

            See hou.Geometry.createNURBSSurface for more information.


        """
    def createVolume(self, xres: int, yres: int, zres: int, bounding_box: Optional[BoundingBox] = None) -> Volume:
        """

        createVolume(self, xres, yres, zres, bounding_box=None) -> hou.Volume

            Given the x, y, and z resolution (or size) of a voxel array, add a
            new volume primitive to the geometry and return it. The values in
            the new volume's voxels are all zero.


            xres, yres, zres
                Integers greater than zero that specify the size of the voxel
                array in one dimension. Raises hou.OperationFailed if any of
                these values are not positive.

            bounding_box
                A hou.BoundingBox that specifies the volume's 3D size. Note that
                this size is independent of the volume's voxel resolution. If
                this parameter is None, Houdini uses a bounding box going from
                (-1,-1,-1) to (1,1,1).


        """
    def createChannelPrim(self) -> ChannelPrim:
        """

        createChannelPrim(self) -> hou.ChannelPrim

            Creates and adds a new channel primitive to the geometry and returns
            it. The new channel primitive is initialized to an empty channel.


        """
    def transform(self, matrix: Matrix4) -> None:
        """

        transform(self, matrix)

            Transforms (e.g. rotates, scales, translates, etc.) the geometry by
            a transformation matrix. You would typically call this method from
            the code of a Python-defined SOP.

            See hou.hmath for functions that build transformation matrices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def transformPrims(self, prims: Sequence[Prim]|PrimGroup, matrix: Matrix4) -> None:
        """

        transformPrims(self, prims, matrix)

            Transforms a set of primitives (e.g. rotates, scales, translates,
            etc.) by a transformation matrix. You would typically call this
            method from the code of a Python-defined SOP.


            prims
                A list of hou.Prim objects or hou.PrimGroup to transform.

            matrix
                A hou.Matrix4 to transform with. See hou.hmath functions that
                build transformation matrices.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > import math
          > 
          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > 
          > def createCircle(geo, num_vertices=10):
          >     # Create a closed curve with the specified number of vertices.
          >     curve = geo.createNURBSCurve(num_vertices)
          >     curve.setIsClosed(True)
          > 
          >     # Arrange the points into a unit circle on the XZ plane,
          >     # centered about the origin.
          >     for i, vertex in enumerate(curve.vertices()):
          >         angle = i * (2.0 * math.pi) / num_vertices
          >         position = (math.cos(angle), 0, math.sin(angle))
          >         vertex.point().setPosition(position)
          >     return curve
          > 
          > # Create a bunch of circles on the XZ plane, tilt them slightly
          > # about X, translate them away from the origin, and rotate each
          > # one about the y axis by a different amount.
          > geo = hou.pwd().geometry()
          > num_copies = 20
          > for i in range(num_copies):
          >     curve = createCircle(geo)
          >     geo.transformPrims([curve],
          >         hou.hmath.buildRotateAboutAxis((1, 0, 0), 30) *
          >         hou.hmath.buildTranslate((2, 0, 0)) *
          >         hou.hmath.buildRotateAboutAxis((0, 1, 0), i * 360.0 / num_copies))

        """
    def deletePrims(self, prims: Sequence[Prim]|PrimGroup, keep_points: bool = ...) -> None:
        """

        deletePrims(self, prims, keep_points=False)

            Delete a sequence of primitives. You would typically call this
            method from the code of a Python-defined SOP.


            prims
                A list of hou.Prim objects or hou.PrimGroup to delete with.

            keep_points
                If True, the primitive will be deleted but its points will
                remain.

            To delete a single primitive, pass in a sequence with one primitive.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # Delete every other primitive:
          > prims = [p for p in geo.prims() if p.number() % 2 == 0]
          > geo.deletePrims(prims)
          > 
          > # Delete the first primitive:
          > geo.deletePrims([geo.iterPrims()[0]])

        """
    def deletePrimsOutsideBoundingBox(self, bbox: BoundingBox) -> None:
        """

        deletePrimsOutsideBoundingBox(self, bbox)

            Delete primitives who's bounding boxes are entirely outside of the
            specified bounding box.

            Also deletes points associated with the deleted primitives.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def deletePoints(self, points: Iterable[Point]|PointGroup) -> None:
        """

        deletePoints(self, points)

            Delete a sequence of points. You would typically call this method
            from the code of a Python-defined SOP.

            Note that Houdini will delete any vertices that reference the point.
            For example, suppose you have a box with 6 polygons, each with 4
            vertices. Also suppose that each point on the box is shared by 3
            vertices on 3 separate polygons. If you delete one of those points,
            Houdini will remove each of those vertices from their corresponding
            polygons, leaving 3 polygons with 4 vertices and 3 polygons with 3
            vertices.

            To delete a single primitive, pass in a sequence with one point.


            points
                A list of hou.Point objects or hou.PointGroup to delete with.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def addAttrib(self, type: EnumValue, name: str, default_value: AttribArgType|AttribDictArgType, transform_as_normal: bool = ..., create_local_variable: bool = ...) -> Attrib:
        '''

        addAttrib(self, type, name, default_value, transform_as_normal=False,
        create_local_variable=False) -> hou.Attrib

            Create a new point, primitive, vertex, or global (a.k.a. detail)
            attribute. Returns a hou.Attrib object describing the newly created
            attribute. You would typically call this method from the code of a
            Python-defined SOP.


            type
                A hou.attribType value to specify if the new attribute should be
                a point, primitive, vertex, or global attribute.

            name
                The new attribute\'s name. Each attribute in the geometry must
                have a unique name.

            default_value
                The default value for this attribute. When an attribute is
                created, all existing elements (e.g. primitives or points) will
                store this value. As well, elements that you add later will also
                use this value.

                This value also determines the attribute\'s data type.

                You can use one of the following Python types:

              * int

              * float

              * str

              * sequence (generator, iterator, list, or tuple) of int

              * sequence of float

              * sequence of str

              * dict

              * sequence of dict

                If the default value is a sequence of integers or floats, the
                sequence size will determine the attribute\'s size. Otherwise,
                the attribute\'s size is 1.

                String attributes do not support a default value and use this
                value solely for type determination.

            transform_as_normal
                This parameter may only be set to True when the default value is
                a sequence of 3 floats. For such attributes, Houdini will not
                modify the attribute values when it transforms (translates,
                rotates, etc.) the geometry. If you want to the attribute to be
                transformed as a vector (such as a normal vector) when Houdini
                transforms the geometry, set this parameter to True.

            create_local_variable
                If True, Houdini will create a local variable for this attribute
                that may be used in parameter expressions. The name of the local
                variable is the attribute\'s name, all in upper case. The mapping
                from attribute names to local variables is stored in a special
                global attribute named \\"varmap\\".

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if an attribute with this name already
            exists. If you are familiar with the C++ Houdini Development Kit
            (HDK), you know that Houdini can support attributes with the same
            name but with different types. However, many SOPs do not let you
            distinguish between attributes that have the same name, and multiple
            attributes with the same name are discouraged. For this reason, you
            cannot create them with this method.

            Raises hou.OperationFailed if transform_as_normal is True and the
            default value is not a sequence of 3 floats.

          > # Create an integer point attribute of size 1 named \\"population\\", and
          > # create 5 points with attribute values 0, 5, 10, 15, and 20.  This code
          > # will work from inside a Python SOP, but not from the Python shell.
          > geo = hou.pwd().geometry()
          > population_attrib = geo.addAttrib(hou.attribType.Point, \\"population\\", 0)
          > for i in range(5):
          >     point = geo.createPoint()
          >     point.setPosition((i, 0, 0))
          >     point.setAttribValue(population_attrib, i * 5)

            The following example shows how to copy an existing attribute:

          > def copyAttrib(attrib, new_name):
          >     return attrib.geometry().addAttrib(
          >         attrib.type(), new_name, attrib.defaultValue(), attrib.isTransformedAsNormal())

            If create_local_variable is True, this function performs the
            equivalent of the following code:

          > def addLocalVariable(geo, attrib_name):
          >     \'\'\'Create a geometry attribute and add a local variable for it.\'\'\'
          >     # The variable mappings are stored in the varmap attribute\'s string
          >     # table.  This table is different than varmap\'s current value, which
          >     # simply refers to an entry in that table.  So, to ensure an entry
          >     # exists in the table, we simply set varmap\'s value.
          >     map_value = \\"%s -> %s\\" % (attrib_name, attrib_name.upper())
          >     if geo.findGlobalAttrib(\\"varmap\\") is None:
          >         geo.addAttrib(hou.attribType.Global, \\"varmap\\", \\"\\")
          >     geo.setGlobalAttribValue(\\"varmap\\", map_value)

            See also:

          * hou.Prim.setAttribValue

          * hou.Point.setAttribValue

          * hou.Prim.setAttribValue

          * hou.Geometry.setGlobalAttribValue

          * hou.Geometry.setArrayAttrib


        '''
    def addArrayAttrib(self, type: EnumValue, name: str, data_type: EnumValue, tuple_size: int = 1) -> Attrib:
        """

        addArrayAttrib(self, type, name, data_type, tuple_size=1) -> hou.Attrib

            Create a new point, primitive, vertex, or global (a.k.a. detail)
            array attribute. Returns a hou.Attrib object describing the newly
            created attribute. You would typically call this method from the
            code of a Python-defined SOP.


            type
                A hou.attribType value to specify if the new attribute should be
                a point, primitive, vertex, or global attribute.

            name
                The new attribute's name. Each attribute in the geometry must
                have a unique name.

            data_type
                A hou.attribData value to specify if the new attribute should be
                an int, float, or string attribute.

            tuple_size
                The new attribute's tuple size.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if an attribute with this name already
            exists. If you are familiar with the C++ Houdini Development Kit
            (HDK), you know that Houdini can support attributes with the same
            name but with different types. However, many SOPs do not let you
            distinguish between attributes that have the same name, and multiple
            attributes with the same name are discouraged. For this reason, you
            cannot create them with this method.


        """
    def setGlobalAttribValue(self, name_or_attrib: str|Attrib, attrib_value: AttribArgType|AttribDictArgType) -> None:
        '''

        setGlobalAttribValue(self, name_or_attrib, attrib_value)

            Set a global (a.k.a. detail) attribute value. The attribute may be
            specified by name or by hou.Attrib object. You would typically call
            this method from the code of a Python-defined SOP.

            If the attribute is an array attribute, then a sequence of values
            with length divisble by the attribute\'s tuple size must be passed in
            for attrib_value. Any values at the end of the sequence that do not
            complete a tuple with the desired size are discarded.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute\'s data type does not match the value passed in. If
            the attribute\'s size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute\'s size.

            If the attribute is an array, the seqeunce must be a flat array, not
            an array of tuples. If the attribute is float, ensure the python
            objects are float, and not integer (1.0, not 1).

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > geo.addAttrib(hou.attribType.Global, \\"author\\", \\"\\")
          > geo.addAttrib(hou.attribType.Global, \\"version\\", (0, 0, 0))
          > geo.setGlobalAttribValue(\\"author\\", \\"Joe\\")
          > geo.setGlobalAttribValue(\\"version\\", (1, 0, 7))

            Here is an example for setting values in a global array attribute:

          > geo = hou.pwd().geometry()
          > geo.addArrayAttrib(
          >     hou.attribType.Global, \\"data\\", hou.attribData.Float, tuple_size=3)
          > 
          > # This will set the global attribute\'s value to 
          > # [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0)].
          > geo.setGlobalAttribValue(\\"data\\", [1.0, 2.0, 3.0, 4.0, 5.0, 6.0])

            See also:

          * hou.Geometry.attribValue

          * hou.Point.setAttribValue

          * hou.Prim.setAttribValue

          * hou.Vertex.setAttribValue


        '''
    def copyAttrib(self, attrib: Attrib) -> None:
        """

        copyAttribs(self, attribs)

            Copy a list of attributes hou.Attrib from another geometry.
            Attributes with the same name and right context must exist on the
            current geometry. Raises OperationFailed on failure describing the
            error condition in detail.


        """
    def copyAttribs(self, attribs: Sequence[Attrib]) -> None: ...
    def copy(self, geometry: Geometry, clone_data_ids: bool = False, prims: Optional[Selection] = None) -> None:
        """

        copy(self, geometry, clone_data_ids=False, prims=None)

            Copy the points and primitives from another hou.Geometry object into
            this one. This is faster than doing a clear() and a merge() as it
            avoid reallocating attributes and primitives. You would typically
            call this method from the code of a Python-defined SOP.

            When merging into an empty Geometry object, clone_data_ids specifies
            whether the resulting attributes will have the same data ids. This
            is useful to enable optimizations that cache data by only looking at
            the attribute data id regardless of whether it is from the same
            geometry object or not. Otherwise, the copied attributes will have
            data ids that are unique.

            The optional <prims> parameter is hou.Selection that gives a more
            precise subset of primitives to copy from.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.loadFromFile.


        """
    def copyPoints(self, geometry: Geometry, points: Optional[PointGroup] = None) -> None:
        """

        copyPoints(self, geometry, points=None)

            Copy a group of points from another hou.Geometry object into this
            one.


            geometry
                The hou.Geometry to copy.

            points
                The hou.PointGroup to copy. Raises hou.OperationFailed if
                geometry does not contain the points group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.copy.


        """
    def copyPrims(self, geometry: Geometry, prims: Optional[PrimGroup] = None) -> None:
        """

        copyPrims(self, geometry, prims=None)

            Copy a group of primitives from another hou.Geometry object into
            this one.


            geometry
                The hou.Geometry to copy.

            prims
                The hou.PrimGroup to copy. Raises hou.OperationFailed if
                geometry does not contain the prims group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.copy.


        """
    def copyEdges(self, geometry: Geometry, edges: Optional[EdgeGroup] = None) -> None:
        """

        copyEdges(self, geometry, edges=None)

            Copy a group of edges from another hou.Geometry object into this
            one. Each edge copied as a separate two-point line segment.


            geometry
                The hou.Geometry to copy.

            edges
                The hou.EdgeGroup to copy. Raises hou.OperationFailed if
                geometry does not contain the edges group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.copy.


        """
    def attribValue(self, name_or_attrib: str|Attrib) -> AttribReturnType|AttribDictReturnType:
        """

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return the global (a.k.a. detail) attribute value for a particular
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name.


        """
    def attributeCaptureRegions(self) -> Tuple[str, ...]:
        """

        attributeCaptureRegions(self) -> tuple of str

            Returns a tuple of strings representing the capture region paths for
            this geometry. The capture regions are identified from the
            geometry's capture attributes.

            See also:

          * hou.Geometry.attributeCaptureObjectPaths


        """
    def attributeCaptureObjectPaths(self) -> Tuple[str, ...]:
        """

        attributeCaptureObjectPaths(self) -> tuple of str

            Returns a tuple of strings representing the capture object paths for
            this geometry. The capture objects are those used to capture this
            geometry and are identified from the geometry's capture attributes.
            The skeleton root path is prepended to the capture object paths and
            the object nodes are given by:

          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > geo = hou.pwd().geometry()
          > nodes = [hou.node(x) for x in geo.attributeCaptureObjectPaths()]

            See also:

          * hou.Geometry.attributeCaptureRegions


        """
    def intrinsicNames(self) -> Tuple[str, ...]:
        """

        intrinsicNames(self) -> tuple of str

            Returns a tuple of strings representing the intrinsic values
            available for this geometry. Different geometry types will have
            different intrinsic values available. You can then get or set the
            value using intrinsicValue and/or setIntrinsicValue.

            See the intrinsicValue method for more information.


        """
    def intrinsicValue(self, intrinsic_name: str) -> AttribReturnType:
        """

        intrinsicValue(self, intrinsic_name) -> int, float, str, or tuple

            Gets the value of an intrinsic, often computed, value of the
            geometry, such as memoryusage, pointcount, pointattributes, and so
            on. Raises OperationFailed if the given intrinsic name does not
            exist.

            You can also view these values in the user interface using the
            geometry spreadsheet.

            In Houdini, some primitives have intrinsic values which can't be
            accessed directly through the attribute interface. Most intrinsic
            values are computed, such as measuredarea, however a few are
            writeable with the setIntrinsicValue method. For example, sphere
            primitives have a transform matrix as part of their definition.

            You can get a list of the available intrinsic value names with the
            intrinsicNames method. Different geometry types will have different
            intrinsic values available.

            Bounding box intrinsic values like bounds are returned in (xmin,
            xmax, ymin, ymax, zmin, zmax) order.


        """
    def intrinsicSize(self, intrinsic_name: str) -> int: ...
    def intrinsicReadOnly(self, intrinsic_name: str) -> bool: ...
    def setIntrinsicValue(self, intrinsic_name: str, value: AttribArgType) -> None:
        """

        setIntrinsicValue(self, intrinsic_name, value)

            Some intrinsic values can be modified. For example, you change the
            internal size and rotation (transform) of a sphere primitive by
            passing a 16 float tuple representing the transform to
            setIntrinsicValue. Raises Error if the intrinsic is not writeable or
            does not accept the passed value, or if the given intrinsic name
            does not exist.


            NOTE
                Modifying the geometry directly will lock the geometry's parent
                node.

            See the intrinsicValue method for more information.


        """
    def data(self) -> bytes:
        '''

        data(self) -> bytes

            Return the geometry data in bgeo format.

            For example:

          > geometry = hou.node(\\"/obj/geo1/torus1\\").geometry()
          > bgeo_data = geometry.data()
          > open(\\"/tmp/torus.bgeo\\", \\"wb\\").write(bgeo_data)

        '''
    def load(self, data: bytes) -> None:
        '''

        load(self, data)

            Loads a bgeo bytes into this object.

            For example:

          > torus = hou.node(\\"/obj/geo1/torus1\\").geometry()
          > bgeo_data = torus.data()
          > 
          > geometry = hou.Geometry()
          > geometry.load(bgeo_data)

        '''
    def saveToFile(self, file_name: str) -> None:
        """

        saveToFile(self, file_name)

            Save the contents of the geometry object to a file. The file
            extension determines what file format to use.

            All file formats supported by Houdini (e.g. geo, bgeo, obj, etc.),
            including extensions listed in GEOio, are supported. If the file
            extension is not recognized, the bgeo format is used.

            Raises hou.OperationFailed if the path to the file is invalid or
            there were permission or other I/O errors.


        """
    def loadFromFile(self, file_name: str) -> None:
        """

        loadFromFile(self, file_name)

            Replace the contents of this geometry object with the data stored in
            a file. You would typically call this method from the code of a
            Python-defined SOP.

            You may specify any type of file supported by Houdini's File SOP.
            See hou.Geometry.saveToFile for more information.

            Raises hou.OperationFailed if the file does not exist or otherwise
            cannot be loaded.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.merge.


        """
    def merge(self, geometry: Geometry, clone_data_ids: bool = False, prims: Optional[Selection] = None) -> None:
        """

        merge(self, geometry, clone_data_ids=False, prims=None)

            Merge the points and primitives from another hou.Geometry object
            into this one. The new points and primitives are appended to this
            geometry's points and primitives. You would typically call this
            method from the code of a Python-defined SOP.

            When merging into an empty Geometry object, clone_data_ids specifies
            whether the resulting attributes will have the same data ids. This
            is useful to enable optimizations that cache data by only looking at
            the attribute data id regardless of whether it is from the same
            geometry object or not. Otherwise, the copied attributes will have
            data ids that are unique.

            The optional <prims> parameter is hou.Selection that gives a more
            precise subset of primitives to merge from.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.loadFromFile.


        """
    def mergePoints(self, geometry: Geometry, points: Optional[PointGroup] = None) -> None:
        """

        mergePoints(self, geometry, points=None)

            Merge a group of points from another hou.Geometry object into this
            one. The new points are appended to this geometry's points.


            geometry
                The hou.Geometry to merge.

            points
                The hou.PointGroup to merge. Raises hou.OperationFailed if
                geometry does not contain the points group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.merge.


        """
    def mergePrims(self, geometry: Geometry, prims: Optional[PrimGroup] = None) -> None:
        """

        mergePrims(self, geometry, prims=None)

            Merge a group of primitives from another hou.Geometry object into
            this one. The new points and primitives are appended to this
            geometry's points and primitives.


            geometry
                The hou.Geometry to merge.

            prims
                The hou.PrimGroup to merge. Raises hou.OperationFailed if
                geometry does not contain the prims group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.merge.


        """
    def mergeEdges(self, geometry: Geometry, edges: Optional[EdgeGroup] = None) -> None:
        """

        mergeEdges(self, geometry, edges=None)

            Merge a group of edges from another hou.Geometry object into this
            one. The new points are appended to this geometry's points. Each
            edge merged as a separate two-point line segment.


            geometry
                The hou.Geometry to merge.

            edges
                The hou.EdgeGroup to merge. Raises hou.OperationFailed if
                geometry does not contain the edges group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Geometry.merge.


        """
    def clear(self) -> None:
        """

        clear(self)

            Remove everything from this geometry object. The geometry will have
            no points or primitives after calling this method.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def intersect(self, rayorig: Vector3, dir: Vector3, p: Vector3, n: Vector3, uvw: Vector3, pattern: Optional[str] = None, min_hit: float = 0.01, max_hit: float = 1e+18, tolerance: float = 0.01) -> int:
        '''

        intersect(self, ray_origin, ray_direction, position_out, normal_out,
        uvw_out, pattern=None, min_hit=0.01, max_hit=1E18, tolerance=0.01) ->
        int

            Determines the intersection point of a ray with the geometry in this
            object.


            NOTE
                This method is unusual in that instead of returning multiple
                pieces of information about the intersection, it requires that
                you pass it objects which it modifies in-place with the
                information.

          > # Get some geometry from a SOP node
          > geometry = hou.node(\\"/obj/geo1/sphere1\\").geometry()
          > # Shoot a ray from high up in the \\"sky\\" straight down at the origin
          > origin = hou.Vector3(0, 100, 0)
          > direction = hou.Vector3(0, -1, 0)
          > # Make objects for the intersect() method to modify
          > position = hou.Vector3()
          > normal = hou.Vector3()
          > uvw = hou.Vector3()
          > # Find the first intersection (if it exists)
          > did_intersect = geometry.intersect(origin, direction, position, normal, uvw)

            Returns the ID number of the hit primitive if the ray intersected
            the geometry, or -1 if the ray did not hit.


            ray_origin
                A hou.Vector3 object representing the starting point of the ray
                in world space.

            ray_direction
                A hou.Vector3 object representing the direction vector of the
                ray.

            position_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object\'s values to represent the intersection
                position in world space.

            normal_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object\'s values to represent the normal direction
                from the surface to the ray.

            uvw_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object\'s values to represent the UVW position within
                the intersecting primitive where the ray hit.

            pattern
                If you pass a string containing primitive group syntax, the ray
                can only intersect primitives that match the pattern.

            min_hit
                Ignore intersections closer than this distance. You can use the
                min_hit argument to iterate through all possible hits along the
                ray, by setting the min_hit a tiny bit farther than the previous
                hit.

              > hit_positions = []
              > prev_dist = 0.01
              > while geometry.intersect(origin, direction, position, normal, uvw,
              >                          min_hit=prev_dist):
              >     # Make sure to store a *copy* of the position, not the object
              >     # that is being modified in each iteration of the loop
              >     hit_positions.append(hou.Vector3(position))
              >     prev_dist = origin.distanceTo(position) + 0.01

            max_hit
                Ignore intersections farther than this distance.

            tolerance
                Use this parameter to adjust the accuracy of intersections. If
                the ray approaches the geometry within the tolerance value, an
                intersection hit is assumed. A 0.01 tolerance (default) gives
                strict intersections while larger values produces less accurate
                intersections.


        '''
    def pointGroups(self, scope: EnumValue = ...) -> Tuple[PointGroup,...]:
        """

        pointGroups(self, scope=hou.groupScope.Public) -> tuple of
        hou.PointGroup

            Return a tuple of all the point groups in the geometry.


            scope
                A hou.groupScope value to specify whether the public or private
                groups should be listed.

            The following function returns the names of all the groups in the
            geometry:

          > def pointGroupNames(geometry):
          >     return [group.name() for group in geometry.pointGroups()]

        """
    def findPointGroup(self, name: str, scope: EnumValue = ...) -> PointGroup|None:
        """

        findPointGroup(self, name, scope=hou.groupScope.Public) ->
        hou.PointGroup or None

            Return the point group with the given name, or None if no such group
            exists.


            name
                The name of the point group.

            scope
                A hou.groupScope value to specify whether the group is public or
                private.


        """
    def createPointGroup(self, name: str, is_ordered: bool = False, unique_name: bool = False) -> PointGroup:
        """

        createPointGroup(self, name, is_ordered=False, unique_name=False) ->
        hou.PointGroup

            Create a new point group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            is_ordered
                Whether or not the new group should be ordered. See
                hou.PointGroup for more information about ordered groups.

            unique_name
                By default, an exception is thrown if the given group already
                exists. If <unique_name> is set to True, then the name will
                instead be modified to a non-existing name based on <name>.

            Use hou.PointGroup.destroy to remove a point group from the
            geometry.


            NOTE
                Group names cannot start with a digit and can only contain
                alphanumeric characters or underscores.


        """
    def primGroups(self, scope: EnumValue = ...) -> Tuple[PrimGroup,...]:
        """

        primGroups(self, scope=hou.groupScope.Public) -> tuple of hou.PrimGroup

            Return a tuple of all the primitive groups in the geometry.


            scope
                A hou.groupScope value to specify whether the public or private
                groups should be listed.


        """
    def findPrimGroup(self, name: str, scope: EnumValue = ...) -> PrimGroup|None:
        """

        findPrimGroup(self, name, scope=hou.groupScope.Public) -> hou.PrimGroup
        or None

            Return the primitive group with the given name, or None if no such
            group exists.


            name
                The name of the primitive group.

            scope
                A hou.groupScope value to specify whether the group is public or
                private.


        """
    def createPrimGroup(self, name: str, is_ordered: bool = False, unique_name: bool = False) -> PrimGroup:
        """

        createPrimGroup(self, name, is_ordered=False, unique_name=False) ->
        hou.PrimGroup

            Create a new primitive group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            is_ordered
                Whether or not the new group should be ordered. See
                hou.PrimGroup for more information about ordered groups.

            unique_name
                By default, an exception is thrown if the given group already
                exists. If <unique_name> is set to True, then the name will
                instead be modified to a non-existing name based on <name>.

            Use hou.PrimGroup.destroy to remove a primitive group from the
            geometry.


            NOTE
                Group names cannot start with a digit and can only contain
                alphanumeric characters or underscores.


        """
    def edgeGroups(self, scope: EnumValue = ...) -> Tuple[EdgeGroup,...]:
        """

        edgeGroups(self, scope=hou.groupScope.Public) -> tuple of hou.EdgeGroup

            Return a tuple of all the edge groups in the geometry.


            scope
                A hou.groupScope value to specify whether the public or private
                groups should be listed.


        """
    def findEdgeGroup(self, name: str, scope: EnumValue = ...) -> EdgeGroup|None:
        """

        findEdgeGroup(self, name, scope=hou.groupScope.Public) -> hou.EdgeGroup
        or None


            name
                The name of the edge group.

            scope
                A hou.groupScope value to specify whether the group is public or
                private.

            Return the edge group with the given name, or None if no such group
            exists.


        """
    def createEdgeGroup(self, name: str) -> EdgeGroup:
        """

        createEdgeGroup(self, name) -> hou.EdgeGroup

            Create a new edge group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            Use hou.EdgeGroup.destroy to remove an edge group from the geometry.


        """
    def vertexGroups(self, scope: EnumValue = ...) -> Tuple[VertexGroup,...]:
        """

        vertexGroups(self, scope=hou.groupScope.Public) -> tuple of
        hou.VertexGroup

            Return a tuple of all the vertex groups in the geometry.


            scope
                A hou.groupScope value to specify whether the public or private
                groups should be listed.

            The following function returns the names of all the groups in the
            geometry:

          > def vertexGroupNames(geometry):
          >     return [group.name() for group in geometry.vertexGroups()]

        """
    def findVertexGroup(self, name: str, scope: EnumValue = ...) -> VertexGroup|None:
        """

        findVertexGroup(self, name, scope=hou.groupScope.Public) ->
        hou.VertexGroup or None

            Return the vertex group with the given name, or None if no such
            group exists.


            name
                The name of the vertex group.

            scope
                A hou.groupScope value to specify whether the group is public or
                private.


        """
    def createVertexGroup(self, name: str, is_ordered: bool = False) -> VertexGroup:
        """

        createVertexGroup(self, name, is_ordered=False) -> hou.VertexGroup

            Create a new vertex group in this geometry.


            name
                The name of the new group. Raises hou.OperationFailed if a group
                with this name already exists.

            is_ordered
                Whether or not the new group should be ordered. See
                hou.VertexGroup for more information about ordered groups.

            Use hou.VertexGroup.destroy to remove a vertex group from the
            geometry.


        """
    def findEdge(self, p0: Point, p1: Point) -> Optional[Edge]:
        """

        findEdge(self, p0, p1) -> hou.Edge


            p0
                The first point that makes up the edge. See hou.Point for more
                information.

            p1
                The second point that makes up the edge. See hou.Point for more
                information.

            finds an edge given two points, or None if no such edge exists


        """
    def boundingBox(self, transform: Optional[Matrix4] = None) -> BoundingBox:
        """

        boundingBox(self, transform=None) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box (of optionally transformed
            instantiation) that is sized and positioned to be large enough to
            hold this geometry.


            transform
                A hou.Matrix4 that transforms the geometry instance. Does not
                change the original geometry.


        """
    def pointBoundingBox(self, ptgroup: str) -> BoundingBox:
        """

        pointBoundingBox(self, pointpattern) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box that is sized and positioned
            to include the points specified by the point pattern. If the pattern
            is blank, all points will be included.

            Some primitives, such as spheres, extend beyond their points. This
            extension will not be included.


        """
    def primBoundingBox(self, primgroup: str) -> BoundingBox:
        """

        primBoundingBox(self, primpattern) -> hou.BoundingBox

            Return an axis-aligned 3D bounding box that is sized and positioned
            to include the primitives specified by the primitive pattern. If the
            pattern is blank, all primitives will be included.

            Some primitives, such as spheres, extend beyond their points. This
            extension will be included.


        """
    def orientedBoundingBox(self) -> OrientedBoundingBox:
        """

        orientedBoundingBox(self) -> hou.orientedBoundingBox

            Return an oriented 3D bounding box that is sized and positioned to
            be large enough to hold this geometry.


        """
    def orientedPointBoundingBox(self, ptgroup: str) -> OrientedBoundingBox:
        """

        orientedPointBoundingBox(self, pointpattern) -> hou.OrientedBoundingBox

            Return an oriented 3D bounding box that is sized and positioned to
            include the points specified by the point pattern. If the pattern is
            blank, all points will be included.

            Note oriented bounding boxes only use point locations, not the
            extents of primitives.


        """
    def orientedPrimBoundingBox(self, primgroup: str) -> OrientedBoundingBox:
        """

        orientedPrimBoundingBox(self, primpattern) -> hou.OrientedBoundingBox

            Return an oriented 3D bounding box that is sized and positioned to
            include the primitives specified by the primitive pattern. If the
            pattern is blank, all primitives will be included.

            Note oriented bounding boxes only use point locations, not the
            extents of primitives.


        """
    def nearestPrim(self, position: Sequence[float]) -> Tuple[Prim, float, float, float]:
        """

        nearestPrim(self, position) -> (hou.Prim or None, float, float, float)

            Given a sequence of three floats containing a position, find the
            location on the primitive closest to that position and return a
            tuple containing that primitive, the u value on the primitive, the v
            value on the primitive, and the distance to the primitive.

            Note that the first value in the return tuple can be None if there
            are no primitives in the geometry.

            NOTE: The returned UVs are in real coordinates, use the
            hou.Prim.primuvConvert to switch to unit coordinates to match VEX's
            xyzdist.


        """
    def nearestPoint(self, position: Sequence[float], ptgroup: Optional[str] = None, max_radius: float = 1e+18) -> Optional[Point]:
        """

        nearestPoint(self, position, ptgroup=None, max_radius=1E18) -> hou.Point
        or None

            Given a sequence of three floats containing a query position, find
            the closest point in the geometry to that position within
            max_radius.

            If ptgroup is a string group pattern, then the search will be
            restricted to the points specified.

            Note that None is returned when there are no points in the geometry.

            See also: hou.nearestPoints


        """
    def nearestPoints(self, position: Sequence[float], max_points: int, ptgroup: Optional[str] = None, max_radius: float = 1e+18) -> Tuple[Point, ...]:
        """

        nearestPoints(self, position, max_points, ptgroup=None, max_radius=1E18)
        -> tuple of hou.Point

            Given a sequence of three floats containing a query position, find
            the closest max_points in the geometry to that position within
            max_radius.

            If ptgroup is a string group pattern, then the search will be
            restricted to the points specified.

            Note that None is returned when there are no points in the geometry.

            See also: hou.nearestPoint


        """
    def primLoop(self, prims: Sequence[Prim], loop_type: EnumValue) -> Tuple[Prim,...]:
        """

        primLoop(self, prims, loop_type) -> tuple of hou.Prim

            Returns a tuple of hou.Prim objects that make a path connecting the
            primitives provided in the prims parameter. If multiple paths are
            being returned, they will be separated in the single returned tuple
            by a value of None. The paths are generated using the same algorithm
            used when performing loop selections in the viewport.

            prims: A list of hou.Prim objects that define the path or paths of
            connected primitives this function should return. Must contain at
            least two primitives.

            loop_type: Controls the type of path returned. Can be any of the
            hou.componentLoopType values. If using either the
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, the inputs prims cannot contain any None entries.
            Furthermore, each pair of primitives is used to define a separate
            full loop, so the number of primitives must be even. If these
            conditions are not met, a hou.OperationFailed exception will be
            thrown.

            Raises a hou.OperationFailed if it was unable to construct a loop
            from the desired components.


        """
    def pointLoop(self, points: Sequence[Point], loop_type: EnumValue) -> Tuple[Point,...]:
        """

        pointLoop(self, points, full_loop) -> tuple of hou.Point

            Returns a tuple of hou.Point objects that make a path connecting the
            points provided in the points parameter. If multiple paths are being
            returned, they will be separated in the single returned tuple by a
            value of None. The paths are generated using the same algorithm used
            when performing loop selections in the viewport.

            points: A list of hou.Point objects that define the path or paths of
            connected points this function should return. Must contain at least
            two points.

            loop_type: Controls the type of path returned. Can be any of the
            hou.componentLoopType values. If using either the
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, the inputs points cannot contain any None entries.
            Furthermore, each pair of points is used to define a separate full
            loop, so the number of points must be even. If these conditions are
            not met, a hou.OperationFailed exception will be thrown.

            Raises a hou.OperationFailed if it was unable to construct a loop
            from the desired components.


        """
    def edgeLoop(self, edges: Sequence[Edge], loop_type: EnumValue, full_loop_per_edge: bool, force_ring: bool, allow_ring: bool) -> Tuple[Edge,...]:
        """

        edgeLoop(self, edges, loop_type, full_loop_per_edge, force_ring,
        allow_ring) -> tuple of hou.Edge

            Returns a tuple of hou.Edge objects that make a path connecting the
            edges provided in the edges parameter. If multiple paths are being
            returned, they will be separated in the single returned tuple by a
            value of None. The paths are generated using the same algorithm used
            when performing loop selections in the viewport.

            edges: A list of hou.Edge objects that define the path or paths of
            connected edges this function should return. Must contain at least
            one or two edges depending on the loop options.

            loop_type: Controls the type of path returned. Can be any of the
            hou.componentLoopType values. If using either the
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, the inputs edges cannot contain any None entries. If these
            conditions are not met, a hou.OperationFailed exception will be
            thrown.

            full_loop_per_edge: If set to True, with the loop_type set to
            hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
            types, each inputs edge is used to create its own full loop or ring.
            If False, the edges are taken in pairs, and so the number of edges
            must be even.

            force_ring: If set to True, this function will return edge rings
            instead of edge loops.

            allow_ring: If set to True, this function may return an edge ring if
            the edges provided produce a ring more naturally than they produce a
            loop (for example if two perpendicular edges are provided from the
            same row on a polygonal grid). If set to False, only edge loops will
            be returned.

            Raises a hou.OperationFailed if it was unable to construct a loop
            from the desired components.


        """
    def pointNormals(self, points: Sequence[Point]|PointGroup) -> Sequence[Vector3]:
        """

        pointNormals(self, points) -> tuple of hou.Vector3

            Returns a tuple of hou.Vector3 objects representing the point
            normals for the supplied points.


            points
                A list of hou.Point objects or hou.PointGroup for which to
                compute point normals.


        """
    def importLop(self, lopnode: LopNode, selectionrule: LopSelectionRule, purpose: str|None = ..., traversal: str|None = ..., path_attrib_name: str|None = ..., name_attrib_name: str|None = ..., strip_layers: bool = ..., frame: float|None = ...) -> LopLockedStage:
        """

        importLop(self, lopnode, selectionrule, purpose=None, traversal=None,
        path_attrib_name=None, name_attrib_name=None, strip_layers=False,
        frame=None, lop_output_index=-1) -> hou.LopLockedStage

            Imports primitives from the stage of the specified LOP as packed
            primitives.

            Returns a hou.LopLockedStage object which should be kept in scope
            for as long as this geometry object contains packed primitives
            created by this method. Allowing this hou.LopLockedStage object to
            be destroyed will prevent the USD packed primitives from being
            displayed or unpacked.

            Primitives are selected according to the hou.LopSelectionRule.

            When a purpose is specified, only primitives with that purpose are
            imported.

            When a traversal method is specified, the children of primitives
            specified by the hou.LopSelectionRule will be traversed using the
            specified traversal. Possible values are, for example std:component,
            std:boundables, std:groups.

            When a path_attrib_name is given, the path of each LOP primitive is
            stored in an attribute of that name.

            When a name_attrib_name is given, the name of each LOP primitive is
            stored in an attribute of that name.

            If strip_layers is True, any layers preceding a Layer Break node
            connected directly or indirectly to the requested LOP node will be
            stripped from the USD stage before importing the stage. This can be
            useful if a Layer Break is being used to keep data that may be
            modified (added after the Layer Break node) separate from primitives
            that should not be modified (added to the stage before the Layer
            Break node).

            If frame is given, the LOP will be evaluated at that specific
            sample. If left at None, the current evaluation time sample will be
            used instead.

            The lop_output_index specifies which output of a multi-output LOP to
            inspect. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.


        """
    def importUsdStage(self, stage: pxr.Usd.Stage, selectionrule: LopSelectionRule, purpose: str|None = ..., traversal: str|None = ..., path_attrib_name: str|None = ..., name_attrib_name: str|None = ..., frame: float|None = ...) -> None:
        """

        importUsdStage(self, stage, selectionrule, purpose=None, traversal=None,
        path_attrib_name=None, name_attrib_name=None, frame=None)

            Imports primitives from a USD Stage as packed primitives.

            The USD Stage should be kept in scope for as long as this geometry
            object contains packed primitives created by this method. Allowing
            the Stage object to be destroyed may prevent the USD packed
            primitives from being displayed or unpacked.

            Primitives are selected according to the hou.LopSelectionRule.

            When a purpose is specified, only primitives with that purpose are
            imported.

            When a traversal method is specified, the children of primitives
            specified by the hou.LopSelectionRule will be traversed using the
            specified traversal. Possible values are, for example std:component,
            std:boundables, std:groups.

            When a path_attrib_name is given, the path of each LOP primitive is
            stored in an attribute of that name.

            When a name_attrib_name is given, the name of each LOP primitive is
            stored in an attribute of that name.

            If frame is given, time samples from the stage will be extracted for
            the requested sample. If left at None, Houdini's current evaluation
            time sample will be used instead.


        """
    def selection(self) -> Selection:
        """

        selection(self) -> hou.Selection

            Returns the current cook component selection associated with this
            geometry. This is the default selection set by the SOP that created
            the geometry.


        """
    def vexAttribDataId(self) -> Tuple[int, ...]:
        '''

        vexAttribDataId(self) -> tuple of int

            Return the same list of integers that the attribdataid() VEX
            function returns when calling attribdataid(geo, \\"meta\\", \\"detail\\").
            It is an identifier that can be used as a conservative check whether
            there are any modifications to this object. The value of
            hou.Geometry.modificationCounter is included in the return value.


        '''
    def modificationCounter(self) -> int:
        """

        modificationCounter(self) -> int or long

            Return a counter that can be used as a conservative check to
            determine if changes have been made to this object. Note that this
            counter is not unique across different hou.Geometry objects. To
            compare these values across different geometries, use
            hou.Geometry.vexAttribDataId instead.


        """
    def incrementModificationCounter(self) -> None:
        """

        incrementModificationCounter(self)

            Increment the modification counter to mark this object as having its
            contents modified.


        """
    def incrementAllDataIds(self) -> None:
        """

        incrementAllDataIds(self)

            Increment all data ids on attributes in this geometry. Use this as
            an easy way to mark that everything in this geometry has changed.
            Internally, this also calls
            hou.Geometry.incrementModificationCounter.


        """
    def incrementDataIdsForAddOrRemove(self, for_points: bool = True, for_prims: bool = True) -> None:
        """

        incrementDataIdsForAddOrRemove(self, for_points=True, for_prims=True)

            Increment data ids which indicate that points and/or primitives have
            been added or removed.


        """
    def primitiveIntrinsicsDataId(self) -> AttribDataId:
        """

        primitiveIntrinsicsDataId(self)

            Returns the data id that represents the contents of primitives,
            excluding primitive attributes. Note that this data id is also
            incremented whenever the number of primitives changes as well.


        """
    def incrementPrimitiveIntrinsicsDataId(self) -> None:
        """

        incrementPrimitiveIntrinsicsDataId(self)

            Increment the primitive intrinsics data id to indicate that the
            contents of primitives have changed, excluding primitive attributes.


        """
    def topologyDataId(self) -> AttribDataId:
        """

        topologyDataId(self)

            Returns the data id that represents the topology of this geometry
            such as when points are wired to primitives.


        """
    def incrementTopologyDataId(self) -> None:
        """

        incrementTopologyDataId(self)

            Increment data ids to indicate that topology in this geometry has
            changed in some way.


        """
    def generateAttribMenu(self, attrib_type: EnumValue|None = ..., data_type: EnumValue|None = ..., min_size: int = ..., max_size: int = ..., array_type: bool = ..., scalar_type: bool = ..., case_sensitive: bool = ..., pattern: str = ..., decode_tokens: bool = ...) -> Tuple[str,...]:
        '''

        generateAttribMenu(self, attrib_type=None, data_type=None, min_size=1,
        max_size=-1, array_type=True, scalar_type=True, case_sensitive=True,
        pattern=\\"*\\", decode_tokens=False) -> tuple of str

            Generates the tokens and labels for a parameter menu listing the
            geometry\'s attributes.


            attrib_type
                A hou.attribType value specifying whether to list point,
                primitive, vertex, or global attributes. Providing a value of
                None will list attributes of all types.

            data_type
                Filters the attribute list to include only attributes with the
                specified hou.attribData data type. Providing a value of None
                will list attributes of all data types.

            min_size
                Includes only attributes whose size is at least this value.

            max_size
                If greater than min_size, includes only attributes whose size is
                at most this value.

            array_type
                Specifies whether array attributes should be included.

            scalar_type
                Specifies whether attributes that do not contain array data
                should be included.

            case_sensitive
                Specifies whether the menu labels are produced in a case-
                sensitive order. This also controls whether the pattern is
                treated as case-sensitive.

            pattern
                Specifies a pattern of attribute names that should be included.

            decode_tokens
                If enabled, the menu tokens will contain the decoded attribute
                names rather than the actual attribute names. This can be useful
                for parameters that support matching against decoded attribute
                names.


        '''
    def isReadOnly(self) -> bool:
        """

        isReadOnly(self) -> bool

            Return true if the geometry is read-only.


        """
    def extractPackedPaths(self, pattern: str) -> Tuple[str, ...]:
        """

        extractPackedPaths(self, pattern) -> tuple of str

            Returns paths of any packed prim files that match the given pattern.
            See also hou.Geometry.unpackFromFolder and
            hou.Geometry.packToFolder.


        """
    def unpackFromFolder(self, path: str) -> Geometry:
        """

        unpackFromFolder(self, path) -> hou.Geometry

            Returns the unpacked geometry of the file at the given path. See
            also hou.Geometry.packToFolder and hou.Geometry.extractPackedPaths.


        """
    def packedFolderProperties(self, path: str) -> dict[str, bool]:
        """

        packedFolderProperties(self, path) -> dict

            Returns a dict containing the folder properties for the given path.
            The dict contains two entries: the entry under the visible key
            specifies whether the packed primitive is in the
            _3d_hidden_primitives group, and the entry under the treat_as_folder
            key specifies whether the primitive is treated as a folder with
            packed contents.


        """
    def packToFolder(self, path: str, geometry: Geometry, is_folder: bool = False, is_visible: bool = True, pack: bool = True) -> bool:
        """

        packToFolder(self, path, geometry, is_folder=False, is_visible=True,
        pack=True) -> bool

            Packs and inserts geometry into the folder at the given path. If
            is_folder is True, treat the inserted geometry as a folder with
            packed contents. is_visible controls the visibility of the packed
            primitive. If pack is true, the inputs are packed. If pack is false,
            the inputs are merged into a single stream of geometry and the names
            of all their primitives are set within each input.

            Returns True on success. Fails if the given path cannot be created.
            See also hou.Geometry.unpackFromFolder and
            hou.Geometry.extractPackedPaths.


        """
    def removeFromFolder(self, path: str) -> bool:
        """

        removeFromFolder(self, path) -> bool

            Removes a folder or file at the given path.

            Returns True on success. Fails if the given path cannot be created.
            See also hou.Geometry.unpackToFolder and
            hou.Geometry.extractPackedPaths.


        """

    # Missing methods added by stubgen
    def pointAttribs(self, scope: EnumValue = ...) -> Tuple[Attrib, ...]: ...
    def primAttribs(self, scope: EnumValue = ...) -> Tuple[Attrib, ...]: ...
    def vertexAttribs(self, scope: EnumValue = ...) -> Tuple[Attrib, ...]: ...
    def globalAttribs(self, scope: EnumValue = ...) -> Tuple[Attrib, ...]: ...

class GeometryDelta:
    """

    hou.GeometryDelta

    Geometry delta provides access to the geometry differences (deltas)
    stored by some Geometry nodes such as the edit SOP.

    If you ask a SOP for its geometry delta via hou.SopNode.geometryDelta,
    you'll get a reference to it. If the SOP recooks, the corresponding
    geometry delta objects will update to the SOP's new geometry delta
    object. If the SOP is deleted, accessing the geometry delta object will
    raise a hou.ObjectWasDeleted exception.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def setPointPositionsFromString(self, positions: bytes, float_type: EnumValue = ...) -> None:
        """

        setPointPositionsFromString(self, positions)

            Stores the differences between the provided positions and this SOP
            node's input geometry into this node's geometry delta object. This
            can be used, for example, to preload an edit SOP's delta so its
            output geometry matches a desired shape without changing the input
            geometry.

            The positions parameter should be a binary representation of the
            positions. For example, the result of calling
            hou.Geometry.pointFloatAttribValuesAsString.


        """

class GeometryDrawable(AdvancedDrawable):
    """

    hou.GeometryDrawable

    Advanced drawable for drawing guide geometries.

    OVERVIEW

        hou.GeometryDrawable lets you draw guide geometries like
        hou.SimpleDrawable, but offers more drawing options with various
        kind of visualization effects. For instance, you can use a
        hou.GeometryDrawable object for drawing the faces of the attached
        geometry, drawing points in different shapes, drawing lines or
        vectors. You may also use a glow matte effect to highlight faces,
        lines, point radius, etc...

        Like hou.SimpleDrawable, hou.GeometryDrawable uses mostly the same
        services for managing geometries in the viewer without being part of
        the actual scene. Like hou.TextDrawable, hou.GeometryDrawable is
        designed for python states and requires the onDraw handler for
        drawing its attached geometry.


        NOTE
            hou.GeometryDrawable can only be used with polygon mesh
            geometries.

    RELATED

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable

      * hou.TextDrawable


    """
    thisown: Incomplete
    def __init__(self, scene_viewer: SceneViewer, geo_type: EnumValue, name: str, label: str|None = ..., geometry: Geometry|None = ..., params: Mapping[str, Any]|None = ...) -> None:
        """

        __init__(self, scene_viewer, geo_type, name, label=None, geometry=None,
        params=None)

            Creates a new drawable object of a given highlight type. The new
            drawable is hidden by default.


            scene_viewer
                A hou.SceneViewer reference to the viewer the guide geometry
                will appear in.

            geo_type
                A hou.drawableGeometryType value for specifying the kind of
                drawable to create.

            name
                A string to identify this drawable object.

            label
                An optional string for the drawable label. Defaults to empty.

            geometry
                An optional hou.Geometry object containing the geometry to draw.

            params
                An optional parameter dictionary for setting the drawable
                parameters. The parameters contained in params must match the
                geo_type drawable being created or they will be ignored. These
                are the same parameters you can use with
                hou.AdvancedDrawable.setParams and hou.AdvancedDrawable.draw.

                Other common parameters are listed in
                hou.AdvancedDrawable.setParams.

                clip_plane
                hou.Vector4 or sequence of 4 doubles

                Vector representing a clip plane in world coordinates. (a, b, c,
                d) represents a plane ax + by + cz + d = 0, and geometry behind
                the plane is clipped. The default value is hou.Vector4(0, 0, 0,
                0). Setting this param also enables the use of clip plane on
                this drawable. This can be enabled/disabled with useClipPlane.

                Line parameter
                Type
                Description
                line_width
                double

                Sets the line width value. Defaults to 1.0.

                style
                hou.drawableGeometryLineStyle or sequence of 2 doubles

                Sets the line style to draw: solid, dashed, or dotted. When
                passing in 2 doubles, the first value is the length of the dash
                in pixels and the second is the length of the gap between dashes
                in pixels. Defaults to hou.drawableGeometryLineStyle.Plain.

                Face parameter
                Type
                Description
                backface_culling
                Bool

                Enable or disable backface culling. Defaults to the current
                viewport Remove Backfaces display option.

                color_ramp_parm
                hou.Parm

                Sets the drawable with a color ramp object. If the ramp is
                enabled (i.e. use_ramp_color=True), the drawable hilites the
                geometry polygons with the ramp value settings along with a pre-
                existing Cd attribute on the geometry. Defaults to an RGB ramp
                object type.

                The ramp works as a transformation on values from the Cd. It's
                done per component, so, if your Cd doesn't have the same value
                in all the three components, you won't get the colors from the
                ramp.

                The way it works is that the ramp ends up being a 1-dimensional
                OpenGL texture (512 pixels long). The drawable takes each
                component (R, G, B) of each fragment color and maps it linearly
                (using the ramp_range min and max values) into an index in
                (0...511) and reads off the corresponding color component from
                the texture and substitutes the Cd value with that value for
                that component.

                If the value ends up out of min-max range, then depending on the
                ramp_clamp setting it either gets clamped to one of the two ends
                of the range, or is taken modulo the range interval (repeating
                cyclically), or is just blacked out.

                glyphe_scale
                double

                A scale value for the face patterns. Default to 1.0.

                indices
                sequence of int

                A list of indices representing the geometry faces to draw. All
                geometry faces are drawn by default.

                period
                double

                A value for displaying faces in patterns based on the style
                option selected. Defaults to 0.

                style
                hou.drawableGeometryFaceStyle

                Sets the face style to draw. Defaults to
                hou.drawableGeometryFaceStyle.Plain.

                ramp_clamp
                hou.drawableRampClamp

                Sets the ramp clamp type for color_ramp_parm. Defaults to
                hou.drawableRampClamp.Edge.

                ramp_range
                hou.Vector2

                Sets the minimum and maximum ramp value for color_ramp_parm.
                Defaults to hou.Vector2(-1,-1).

                reverse_winding
                Bool

                Pick which side of a face to remove when backface culling is
                active. Defaults to False;

                use_color_ramp
                Bool

                Enable the use of the color ramp if one is set on the drawable.
                Defaults to False.

                Point parameter
                Type
                Description
                falloff_range
                hou.Vector2

                Sets the falloff range value. Defaults to hou.Vector2(0, 0).

                indices
                sequence of int

                A list of polygon point indices, only the points of the
                corresponding indices are drawn. If no indices are provided, all
                geometry points are drawn by default.

                num_rings
                int

                Sets the number of rings around the point. Works with
                hou.drawableGeometryPointStyle.RingsCircle or
                hou.drawableGeometryPointStyle.RingsSquare. Defaults to 0.

                radius
                double

                Sets the point radius value. Defaults to 0.05.

                style
                hou.drawableGeometryPointStyle

                Sets the point style to draw. Ring styles work better when the
                max falloff_range value is > 0. Defaults to
                hou.drawableGeometryPointStyle.LinearCircle.

                Vector parameter
                Type
                Description
                indices
                sequence of int

                A list of polygon point indices, only the vectors for the points
                of the corresponding indices are drawn. If no indices are
                provided, all vectors are drawn by default.

                bidirect
                Bool

                Draws the vector segment with an arrow on both end. Defaults to
                False.

                length_scale
                double

                Sets the length of the vector segment. Defaults to 1.0.

                vector_width
                int

                Sets the width of the vector segment in pixel units. Defaults to
                0.

                use_arrow
                Bool

                Draws the vector segment with an arrow on one end. Defaults to
                False.

                base_fade_factor
                double

                Fades the entire vector by this factor if the base point of the
                vector is occluded. Can be used in conjunction with fade_factor
                to achieve different levels of fading if the vector is occluded
                and the base of the vector is occluded, in which case the
                product of the two fade factors is used. Defaults to 0.25.


        """
    __swig_destroy__: Incomplete
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Returns the drawable's geometry object. The returned geometry is
            read-only.


        """
    def setGeometry(self, geometry: Geometry) -> None:
        """

        setGeometry(self, geometry)

            Sets the drawable with a new geometry. The changes will appear the
            next time the viewer redraws.


            geometry
                A hou.Geometry object.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.drawableGeometryType

            Returns the type of drawable as specified at creation time.


        """
    def useClipPlane(self, value: bool) -> None:
        """

        useClipPlane(self, value)

            Enable or disable the clip plane while rendering this drawable. It
            is disabled by default.


            value
                True to enable the clip plane and False to disable it.


        """

class GeometryDrawableGroup(AdvancedDrawable):
    '''

    hou.GeometryDrawableGroup

    A container of hou.GeometryDrawable objects.

    OVERVIEW

        hou.GeometryDrawableGroup acts as a regular hou.GeometryDrawable
        object which can contain several hou.GeometryDrawable children.
        hou.GeometryDrawableGroup performs operations on its children in the
        order they were added. You can also query specific children from
        hou.GeometryDrawableGroup for setting their parameters individually.

        Here\'s an example that creates a group composed of two
        hou.GeometryDrawable objects.

      > import hou
      > import viewerstate.utils as su
      > 
      > class State(object):       
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      > 
      >         # create the geometry
      >         sops = hou.sopNodeTypeCategory()
      >         verb = sops.nodeVerb(\'tube\')
      >         verb.setParms({
      >             \\"rad\\": (0.2, 0.4),
      >             \\"rows\\": 3,
      >             \\"cols\\": 6,
      >             \'height\': 1.0,
      >             \\"cap\\":True
      >         })
      > 
      >         geo = hou.Geometry()
      >         verb.execute(geo, [])
      > 
      >         # creates the drawable group              
      >         self.cursor = hou.GeometryDrawableGroup(\\"cursor\\")
      > 
      >         # adds the drawables
      >         self.cursor.addDrawable( hou.GeometryDrawable( self.scene_viewer,
      >             hou.drawableGeometryType.Face, \\"face\\", params = {\'color1\' : (0.0,1.0,0.0,1.0)} ))
      >         self.cursor.addDrawable( hou.GeometryDrawable(self.scene_viewer, 
      >             hou.drawableGeometryType.Line, \\"line\\", params = {\'color1\' : (0,0,0,1.0)} ))
      > 
      >         # set the geometry on all children
      >         self.cursor.setGeometry(geo)
      >         self.cursor.show(False)
      > 
      >         self.cursor_pos = hou.Vector3()
      > 
      >     def onMouseEvent(self, kwargs):
      >         ui_event = kwargs[\\"ui_event\\"]
      >         (origin, dir) = ui_event.ray()
      > 
      >         gi = su.GeometryIntersector(kwargs[\\"node\\"].geometry())
      >         gi.intersect(origin, dir)
      > 
      >         if gi.intersected:        
      >             self.cursor_pos = gi.position
      >             self.cursor.show(True)
      >         else:
      >             self.cursor.show(False)
      > 
      >     def onDraw(self, kwargs):
      >         handle = kwargs[\'draw_handle\']
      > 
      >         params = {
      >             \'translate\' : (self.cursor_pos[0], self.cursor_pos[1], self.cursor_pos[2]),            
      >             \'line_width\' : 0.25
      >         }
      > 
      >         self.cursor.draw( handle, params )

    RELATED

      * hou.GeometryDrawable


    '''
    thisown: Incomplete
    def __init__(self, name: str, label: str|None = ...) -> None:
        """

        __init__(self, name, label=None)

            Creates a new geometry drawable group object. The new object is
            empty and must be filled with hou.GeometryDrawable objects to be
            useful.


            name
                Name of the drawable group.

            label
                An optional string for the drawable label. Defaults to empty.


        """
    __swig_destroy__: Incomplete
    def addDrawable(self, drawable: GeometryDrawable) -> None:
        """

        addDrawable(geometry_drawable)

            Adds a hou.GeometryDrawable object at the end of the children.


            geometry_drawable
                The hou.GeometryDrawable to add.


        """
    def drawable(self, drawable_name: str) -> GeometryDrawable:
        """

        drawable(name): -> hou.GeometryDrawable

            Returns a drawable by name.


        """
    def drawables(self) -> Tuple[GeometryDrawable, ...]:
        """

        drawables(): -> list` of hou.GeometryDrawable

            Returns a list of all children.


        """
    def geometry(self) -> Geometry:
        """

        geometry(self): -> hou.Geometry

            Returns the drawable's geometry object. The returned geometry is
            read-only.


        """
    def setGeometry(self, geometry: Geometry) -> None:
        """

        setGeometry(self, geometry)

            Sets all drawable children with a new geometry. The changes will
            appear the next time the viewer redraws.


            geometry
                A hou.Geometry object.


        """
    def useClipPlane(self, value: bool) -> None:
        """

        useClipPlane(self, value)

            Enable or disable the clip plane on all drawables in this group. By
            default the clip plane for all drawables are disabled.


            value
                True to enable the clip plane on all drawables and False to
                disable it.


        """

class GadgetDrawable(GeometryDrawable):
    thisown: Incomplete
    def __init__(self, widget: int, gadget_context: int) -> None: ...
    __swig_destroy__: Incomplete

class GeometryRayCache:
    """

    hou.GeometryRayCache

    Geometry Ray Cache allows caching of ray-intersection structures.

    When you use hou.Geometry.intersect(), the hou.Geometry will store an
    acceleration structure. This is reset if the geometry changes at all,
    however. A ray cache allows you to maintain an acceleration structure
    and re-use it if only the point positions change.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Return a new GeometryRayCache. The same ray cache can be used across
            multiple geometries and, where possible, it will cache the
            acceleration structures for faster ray intersection.


        """
    __swig_destroy__: Incomplete
    def intersect(self, geo: Geometry, rayorig: Vector3, dir: Vector3, p: Vector3, n: Vector3, uvw: Vector3, min_hit: float = 0.01, max_hit: float = 1e+18, tolerance: float = 0.01) -> int:
        """

        intersect(self, ray_origin, ray_direction, position_out, normal_out,
        uvw_out, min_hit=0.01, max_hit=1E18, tolerance=0.01) -> int

            Determines the intersection point of a ray with the geometry in this
            object.


            NOTE
                This method is unusual in that instead of returning multiple
                pieces of information about the intersection, it requires that
                you pass it objects which it modifies in-place with the
                information.

            Returns the ID number of the hit primitive if the ray intersected
            the geometry, or -1 if the ray did not hit.


            ray_origin
                A hou.Vector3 object representing the starting point of the ray
                in world space.

            ray_direction
                A hou.Vector3 object representing the direction vector of the
                ray.

            position_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the intersection
                position in world space.

            normal_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the normal direction
                from the surface to the ray.

            uvw_out
                Pass a hou.Vector3 object to this argument. The method will
                change the object's values to represent the UVW position within
                the intersecting primitive where the ray hit.

            min_hit
                Ignore intersections closer than this distance. You can use the
                min_hit argument to iterate through all possible hits along the
                ray, by setting the min_hit a tiny bit farther than the previous
                hit.

              > hit_positions = []
              > prev_dist = 0.01
              > while geometry.intersect(origin, direction, position, normal, uvw,
              >                          min_hit=prev_dist):
              >     # Make sure to store a *copy* of the position, not the object
              >     # that is being modified in each iteration of the loop
              >     hit_positions.append(hou.Vector3(position))
              >     prev_dist = origin.distanceTo(position) + 0.01

            max_hit
                Ignore intersections farther than this distance.

            tolerance
                Use this parameter to adjust the accuracy of intersections. If
                the ray approaches the geometry within the tolerance value, an
                intersection hit is assumed. A 0.01 tolerance (default) gives
                strict intersections while larger values produces less accurate
                intersections.


        """
    def findAllInTube(self, geo: Geometry, rayorig: Vector3, dir: Vector3, radius: float, min_hit: float = 0.0, max_hit: float = 1e+18, tolerance: float = 0.005) -> Tuple[Point, ...]:
        """

        findAllInTube(self, line_origin, line_direction, radius, min_hit=0,
        max_hit=1E18, tolerance=5E-3) -> tuple of hou.Point

            Return a tuple of all the points in the geometry inside the tube
            given by the line and radius.


            ray_origin
                A hou.Vector3 object representing the starting point of the line
                in world space.

            ray_direction
                A hou.Vector3 object representing the direction vector of the
                line.

            radius
                Find points within this distance of the line.

            min_hit
                Ignore intersections closer than this distance. You can use the
                min_hit argument to iterate through all possible hits along the
                ray, by setting the min_hit a tiny bit farther than the previous
                hit.

            max_hit
                Ignore intersections farther than this distance.

            tolerance
                Use this parameter to adjust the accuracy of intersections. A
                5E-3 tolerance (default) gives strict intersections while larger
                values produces less accurate intersections.


        """

class GeometrySelection:
    """

    hou.GeometrySelection

    Represents a component selection performed by the user in a viewport.

    Calling hou.SceneViewer.selectGeometry waits for the user to perform a
    selection in the viewport, and returns an object of this type
    representing the elected components. The returned selection can be
    manipulated by converting it to a specific component type, grown, or
    shrunk. Then the selection can be converted to a string that can be used
    in a SOP node group parameter.

    If the selection contains components from more than one SOP, you can use
    the hou.GeometrySelection.mergedNode function to create a Merge SOP
    and/or Object Merge SOPs that brings all the referenced geometry into a
    single node.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        hou.GeometrySelection

        Represents a component selection performed by the user in a viewport.

        Calling hou.SceneViewer.selectGeometry waits for the user to perform a
        selection in the viewport, and returns an object of this type
        representing the elected components. The returned selection can be
        manipulated by converting it to a specific component type, grown, or
        shrunk. Then the selection can be converted to a string that can be used
        in a SOP node group parameter.

        If the selection contains components from more than one SOP, you can use
        the hou.GeometrySelection.mergedNode function to create a Merge SOP
        and/or Object Merge SOPs that brings all the referenced geometry into a
        single node.


        """
    __swig_destroy__: Incomplete
    def ordered(self) -> bool:
        """

        ordered(self) -> bool

            Returns true if this is an ordered selection. This means that the
            order in which the user selected the components is preserved. To
            have an ordered selection, the ordered parameter needs to have been
            set to True when calling hou.SceneViewer.geometrySelection.


        """
    def geometryType(self) -> EnumValue:
        """

        geometryType(self) -> hou.geometryType enum value

            Returns the type of component that was selected.


        """
    def setGeometryType(self, type: EnumValue) -> None:
        """

        setGeometryType(self, type)

            Changes the type of component contained in the selection, converting
            the existing selection to the new component type.


        """
    def connectivity(self) -> EnumValue:
        """

        connectivity(self) -> hou.connectivityType enum value

            Returns the hou.connectivityType that has been set on this geometry
            selection. Unless you call hou.GeometrySelection.setConnectivity,
            this function will return the no connectivity value.


        """
    def setConnectivity(self, connectivity: EnumValue) -> None:
        """

        setConnectivity(self, connectivity)

            Sets the type of connectivity to enforce when modifying the
            selection. The current selection is also expanded so that all
            connected components (using the supplied style of connectivity)
            become part of the selection.


        """
    def primitiveTypes(self) -> Tuple[EnumValue, ...]:
        """

        primitiveTypes(self) -> tuple of hou.primitiveType enum values

            Returns a tuple containing all primitive types that are contained in
            the selection.


        """
    def setPrimitiveTypes(self, primitive_types: Sequence[EnumValue]) -> None:
        """

        setPrimitiveTypes(self, primitive_types)

            Sets the tuple of primitive types allowed in the selection. Any
            primitives that are not of an allowed type are removed from the
            selection. Only has an effect if this is a primitive selection.


        """
    def nodes(self) -> Tuple[Node, ...]:
        """

        nodes(self) -> tuple of Nodes

            Returns a tuple of all nodes referenced by the selection.


        """
    def selectionStrings(self, empty_string_selects_all: bool = True, force_numeric: bool = False) -> Tuple[str, ...]:
        """

        selectionStrings(self, empty_string_selects_all=True, bool
        force_numeric=False) -> tuple of strings

            Returns a tuple of strings that can be used to refer to the selected
            components in each SOP node referenced by the selection.


        """
    def selections(self) -> Tuple[Selection, ...]:
        """

        selections(self) -> tuple of [Hom:hou.Selection]

            Returns a tuple of component selection objects. These correspond to
            the nodes returned by the nodes function.


        """
    def needsMergedNode(self, parent: Node) -> bool:
        """

        needsMergedNode(self, parent) -> bool

            Returns true if a Merge SOP needs to be created in order to access
            all components in the selection.


        """
    def mergedNode(self, parent: Node, creator_name: str, force_keep_original_objects: bool = False, display_original_objects: bool = False) -> SopNode:
        """

        mergedNode(self, parent, creator_name,
        force_keep_original_objects=False, display_original_objects=False) ->
        Node

            Creates a Merge SOP that combines all the SOPs referenced by the
            selection. Most selections will only reference a single SOP in which
            case no Merge SOP is required, and the selected SOP will be
            returned.


        """
    def mergedSelectionString(self, empty_string_selects_all: bool = True, force_numeric: bool = False) -> str:
        """

        mergedSelectionString(self, empty_string_selects_all=True,
        force_numeric=False) -> string

            Returns a single string that can be used in group parameters of the
            merged node returned by hou.GeometrySelection.mergedNode. If all
            components are selected from a single node this is equivalent to the
            first string in the tuple returned by
            hou.GeometrySelection.selectionStrings.


        """
    def shrinkSelection(self, check_uv: bool = True) -> None:
        """

        shrinkSelection(checkuv = true)

            Removes components that are on the boundary of the selection.


        """
    def growSelection(self) -> None:
        """

        growSelection()

            Expands the selection by adding all components that are connected to
            components currently in the selection.


        """
    def boundingBox(self) -> BoundingBox:
        """

        boundingBox(self) -> BoundingBox

            Returns the bounding box of the selected region.


        """
    def orientedBoundingBox(self) -> OrientedBoundingBox:
        """

        orientedBoundingBox(self) -> OrientedBoundingBox

            Returns the oriented bounding box of the selected region.


        """

class GeometrySpreadsheet(PathBasedPaneTab):
    """

    hou.GeometrySpreadsheet

    Represents a geometry spreadsheet pane tab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def numRows(self) -> int:
        """

        numRows(self) -> int

            Returns the number of rows in the geometry spreadsheet.


        """
    def numColumns(self) -> int:
        """

        numColumns(self) -> int

            Returns the number of columns in the geometry spreadsheet.


        """
    def cellText(self, row: int, col: int) -> str:
        """

        cellText(self, row, col) -> str

            Returns the text for the specified cell.


        """
    def attribType(self) -> EnumValue:
        """

        attribType(self) -> hou.attribType

            Returns whether the spreadsheet is displaying point, vertex,
            primitive, or detail attributes.


        """
    def setAttribType(self, attrib_type: EnumValue) -> None:
        """

        setAttribType(self, attrib_type)

            Sets whether the spreadsheet is displaying point, vertex, primitive,
            or detail attributes.


            attrib_type
                A hou.attribType specifying the type of attribute to display.


        """
    def groupFilter(self) -> str:
        """

        groupFilter(self) -> str

            Returns the spreadsheet's group filter pattern.


        """
    def setGroupFilter(self, group: str) -> None:
        """

        setGroupFilter(self, group)

            Sets the group pattern for the spreadsheet.


        """
    def groupFilterEnabled(self) -> bool:
        """

        groupFilterEnabled(self) -> bool

            Return whether the group filter is enabled in the spreadsheet.


        """
    def setGroupFilterEnabled(self, enable: bool) -> None:
        """

        setGroupFilterEnabled(self, enable)

            Toggles whether the group filter is enabled in the spreadsheet.


        """
    def attribFilter(self) -> str:
        """

        attribFilter(self) -> str

            Returns the spreadsheet's attribute filter pattern.


        """
    def setAttribFilter(self, filter: str) -> None:
        """

        setAttribFilter(self, filter)

            Sets the attribute filter pattern for the spreadsheet.


        """
    def attribFilterEnabled(self) -> bool:
        """

        attribFilterEnabled(self) -> bool

            Return whether the attribute filter is enabled in the spreadsheet.


        """
    def setAttribFilterEnabled(self, enable: bool) -> None:
        """

        setAttribFilterEnabled(self, enable)

            Toggles whether the attribute filter is enabled in the spreadsheet.


        """
    def viewOnlySelected(self) -> bool:
        """

        viewOnlySelected(self) -> bool

            Returns whether only the current selection's elements are displayed.


        """
    def setViewOnlySelected(self, enable: bool) -> None:
        """

        setViewOnlySelected(self, enable)

            Toggles whether only the current selection's elements are displayed.


        """
    def viewDecomposedMatrices(self) -> bool:
        """

        viewDecomposedMatrices(self) -> bool

            Returns whether matrix values are decomposed into translation,
            rotation, scale, and shear components.


        """
    def setViewDecomposedMatrices(self, enable: bool) -> None:
        """

        setViewDecomposedMatrices(self, enable)

            Toggles whether matrix values are decomposed into translation,
            rotation, scale, and shear components.


        """
    def sceneGraphTree(self) -> Optional[SceneGraphTree]:
        """

        sceneGraphTree(self) -> hou.SceneGraphTree or None

            Returns the scene graph tree pane that is embedded in the geometry
            spreadsheet pane when viewing the data for a LOP node.


        """

class GeometryViewport:
    '''

    hou.GeometryViewport

    A viewport within a Scene Viewer pane, for viewing the scene at the
    Object or SOP level.

    OVERVIEW

        A viewer is a type of pane that shows the scene. The viewer\'s
        contents is conceptually divided into viewports. By default, the
        scene viewer shows a single viewport, the Perspective view. However,
        you can use the view layout controls to, for example, split the view
        into four viewports (Perspective, Top, Front, and Right views).
        Viewports are the parts of the interface that actually display the
        scene to the user.


            To access a viewport, you must first get a reference to a Scene
            Viewer pane tab. See the following methods:


            hou.ui.paneTabOfType
                Use hou.ui.paneTabOfType(hou.paneTabType.SceneViewer) to get
                a reference to a Scene Viewer pane tab in the current pane
                layout. If the current layout has no Scene Viewer pane tab,
                this returns None.

                To be more precise about which viewer you grab in a possible
                multi-viewer layout, see also hou.ui.curDesktop to get a
                hou.Desktop object representing the current pane layout, and
                hou.Desktop.sceneViewers to get a list of scene viewer pane
                tabs in the current layout.

            Once you have a reference to a hou.SceneViewer pane object, you
            can use it to access the viewer pane\'s viewport or viewports.
            See the following methods:


            hou.SceneViewer.viewports
                Returns a list of the viewports in the viewer pane.

            hou.SceneViewer.findViewport
                Gets a single viewport by name, for example \\"Top\\".

            hou.SceneViewer.selectedViewport
                Gets the currently selected viewport. The user can select a
                viewport by pressing [Space + N] in the viewport. The view
                menus in the upper right corner are drawn brighter in the
                selected viewport.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def type(self) -> EnumValue:
        """

        type(self) -> hou.geometryViewportType enum value

            Query the viewport type (UV, 3D, top, left, etc).


        """
    def changeType(self, type: EnumValue) -> None:
        """

        changeType(self, [Hom:hou.geometryViewportType])

            Set the viewport type (hou.geometryViewportType). This method first
            attempts to restore a stashed view for the new viewport type, but
            failing that, will home the viewport.


        """
    def settings(self) -> GeometryViewportSettings:
        """

        settings(self) -> hou.GeometryViewportSettings

            Returns the hou.GeometryViewportSettings object for this viewport.
            By calling methods on that object, you can read/edit the viewport's
            display options.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Query of the name of the viewport (persp1, top1, etc).


        """
    def changeName(self, name: str) -> None:
        """

        changeName(self, str)

            Set the name of the viewport. Setting the name does not affect its
            type, so naming a perspective view front will be confusing. This is
            best used in conjunction with changeType().


        """
    def home(self) -> None:
        """

        home(self)

            Moves/tumbles the viewport to the default view.


        """
    def homeAll(self) -> None:
        """

        homeAll(self)

            Moves/tumbles the view to show all geometry/objects (including
            templated geometry). See also homeNonTemplated().


        """
    def homeSelected(self) -> None:
        """

        homeSelected(self)

            Moves/tumbles the view to show the selected geometry/objects.


        """
    def homeGrid(self) -> None:
        """

        homeGrid(self)

            Homes the viewport on the grid.


        """
    def homeNonTemplated(self) -> None:
        """

        homeNonTemplated(self)

            Moves/tumbles the view to show all non-templated geometry.


        """
    def homeBoundingBox(self, bbox: BoundingBox, center_to_origin: bool = False) -> None:
        """

        homeBoundingBox(self, bbox, center_to_origin=False)

            Moves/tumbles the viewport to show an arbitrary area in the scene.


            bbox
                A hou.BoundingBox representing the volume of space to focus on.

            center_to_origin


        """
    def frameAll(self) -> None:
        """

        frameAll(self)

            Moves the view to show all geometry/objects. See also
            frameNonTemplates().


        """
    def frameBoundingBox(self, bbox: Optional[BoundingBox] = None) -> None:
        """

        frameBoundingBox(self, bbox)

            Moves the view to show an arbitrary area in the scene.


            bbox
                A hou.BoundingBox representing the volume of space to focus on.


        """
    def frameSelected(self) -> None:
        """

        frameSelected(self)

            Moves the view to show the selected geometry/objects.


        """
    def frameGrid(self) -> None:
        """

        frameGrid(self)

            Frames the view on the grid.


        """
    def frameNonTemplated(self) -> None:
        """

        frameNonTemplated(self)

            Moves the view to show all non-templated geometry.


        """
    def draw(self) -> None:
        """

        draw(self)

            Request that the viewport redraw. Multiple draw() calls within the
            same script will be merged into a single call.


        """
    def viewTransform(self) -> Matrix4:
        """

        viewTransform(self) -> hou.Matrix4

            Returns the transform matrix of the view. To set the viewpoint
            programmatically, use defaultCamera() to get a hou.ViewportCamera
            object and manipulate that.


        """
    def modelToGeometryTransform(self) -> Matrix4:
        """

        modelToGeometryTransform(self) -> hou.Matrix4

            Returns the transform from the modeling space to the space of the
            points in the geometry. When modeling at object level, this converts
            from the object space into the SOP's space. When modeling at the SOP
            level, this is identity as the model space was the SOP space.


        """
    def cameraToModelTransform(self) -> Matrix4:
        """

        cameraToModelTransform(self) -> hou.Matrix4

            Equivalent to viewTransform, this is the transform matrix of the
            view. It converts from the camera's space into the space that
            modeling is currently being done at.


        """
    def ndcToCameraTransform(self) -> Matrix4:
        """

        ndcToCameraTransform(self) -> hou.Matrix4

            Returns the transform from normalized device coordinates to the
            viewport camera's space. This is often a projective transform, so if
            used the resulting points will have to be dehomogenized by dividing
            by w.


        """
    def viewportToNDCTransform(self) -> Matrix4:
        """

        viewportToNDCTransform(self) -> hou.Matrix4

            Returns the matrix converting from the viewport pixel coordinates to
            the normalized device coordinates. This is a two dimensional scale
            and translate, so the z and w components are identity.


        """
    def windowToViewportTransform(self) -> Matrix4:
        """

        windowToViewportTransform(self) -> hou.Matrix4

            Returns the matrix converting from the window pixel viewport
            coordinates to the viewport pixel coordinates. Window coordinates
            are present in hou.ViewerEvent and are unaware of quad-view
            viewports.

            This is a two dimensional translate, so z and w components are
            identity.


        """
    def viewPivot(self) -> Vector3:
        """

        viewPivot(self) -> hou.Vector3

            Returns a hou.Vector3 representing the view pivot as a point in
            world space.


        """
    def resolutionInPixels(self) -> Tuple[int, ...]:
        """

        resolutionInPixels(self) -> 2-tuple of int

            Returns the resolution of the viewport in pixels, as (width,
            height).


        """
    def camera(self) -> ObjNode: ...
    def cameraPath(self) -> str:
        """

        cameraPath(self) -> str

            Return the path to the camera that the viewport is looking through.
            If the viewport isn't looking through a camera, return an empty
            string. In objects, this is the path of the camera object node. In
            LOPs, this is the USD primitive path.


        """
    def setCamera(self, camera_node: ObjNode) -> None:
        """

        setCamera(self, camera_node)

            Copies the viewport transform from the transformation parameters of
            a camera or light onto the current view. This is the same as
            choosing a camera/light from the Look through submenu in the
            viewport's Camera menu.


            camera_node
                A hou.ObjNode object representing the node to save the view
                from.


        """
    def saveViewToCamera(self, camera_node: ObjNode) -> None:
        """

        saveViewToCamera(self, camera_node)

            Copies the viewpoint transform of the current view onto the
            transformation parameters of a camera or light node.


            camera_node
                A hou.ObjNode object representing the node to save the view to.


        """
    def defaultCamera(self) -> GeometryViewportCamera:
        """

        defaultCamera(self) -> hou.GeometryViewportCamera

            Returns an object representing the viewport's viewpoint. The
            returned object is live in that changing its settings will
            immediately change the view

            If a camera/light is locked to the view, changing the settings of
            the GeometryViewportCamera will change the camera/light node's
            parameters as well.

            Instead of a live object, you can get a disconnected version of the
            viewpoint using hou.GeometryViewportCamera.stash. This is a useful
            way to remember a certain viewpoint in code for later. You can
            restore a stashed camera using setDefaultCamera().

          > # Remember the current view
          > cam = viewport.defaultCamera()
          > saved = cam.stash()
          > 
          > # Change the view somehow
          > 
          > # Restore the original view
          > viewport.setDefaultCamera(saved)

        """
    def setDefaultCamera(self, cam_settings: GeometryViewportCamera) -> None:
        """

        setDefaultCamera(self, stashed_cam)

            Takes a hou.GeometryViewportCamera and copies its values into this
            viewport.

            Set the current camera settings of the viewport to the settings
            stored in cam_setting. If the viewport is looking through a camera
            and the view is not locked to the camera, it will be switched to No
            camera. If the view is locked to the camera, the camera object will
            be updated instead.


        """
    def useDefaultCamera(self) -> None:
        """

        useDefaultCamera(self)

            Set the viewport camera to No camera and stop looking through a
            camera object (or light).


        """
    def isCameraLockedToView(self) -> bool:
        """

        isCameraLockedToView(self) -> bool

            Query to see if the camera is locked to the view. This returns the
            state of the camera lock only; this can be enabled without viewing
            through a camera.


        """
    def lockCameraToView(self, arg2: bool) -> None:
        """

        lockCameraToView(self)

            Set the viewport camera lock. When True, any changes to the view
            will affect the camera object being viewed though. When False, the
            camera will become disconnected from the viewport and revert to the
            default viewport camera when the user tumbles the view. It is
            possible to enable this without the viewport looking through a
            camera, though view changes will not affect any objects until the
            user sets the viewport to look through a camera or light.


        """
    def isViewExportedToCameraContinuously(self) -> bool:
        """

        isViewExportedToCameraContinuously(self) -> bool

            Query to see if the view changes are exported to a locked camera
            continuously (True) or only on mouse release (False).


        """
    def exportViewToCameraContinuously(self, arg2: bool) -> None:
        """

        exportViewToCameraContinuously(self)

            Set whether the export of view changes to a locked camera happens
            continuously (True) or only on mouse release (False).


        """
    def isActive2D(self) -> bool:
        """

        isActive2D(self) -> bool

            Query if the viewport is currently displaying 2d geometry, often
            implying it is displaying UV information.


        """
    def isActive3D(self) -> bool:
        """

        isActive3D(self) -> bool

            Query if the viewport is currently displaying 3d geometry. This is
            the case for perspective and ortho viewports.


        """
    def usesConstructionPlane(self) -> bool:
        """

        usesConstructionPlane(self) -> bool

            Returns whether this viewport uses the construction plane when it is
            on.


        """
    def queryNodeAtPixel(self, x: int, y: int, pick_templates: bool = False) -> Optional[Node]:
        """

        queryNodeAtPixel(self, x, y, pick_templates=False) -> hou.ObjNode,
        hou.SopNode, or None

            Return the node draw at the specified pixel in the viewport, or None
            if there is nothing there. The type of node returned depends on the
            level of the viewer.

            If pick_templates is True then templated geometries will be included
            in the query.


        """
    def queryPrimAtPixel(self, node: Node, x: int, y: int) -> Optional[Prim]:
        """

        queryPrimAtPixel(self, node, x, y) -> hou.Prim or None

            Return the primitive drawn at the specified pixel in the viewport,
            or None if there is nothing there. The primitive returned will be a
            subclass of hou.Prim.

            The parameter node is used to restrict the query to geometry within
            a particular node. If node is None, then the query is unrestricted.


        """
    def queryInspectedGeometry(self) -> Optional[Geometry]:
        """

        queryInspectedGeometry(self) -> hou.Geometry or None

            Return the geometry currently being inspected in the viewport, or
            None when nothing is being inspected or when called outside of an
            inspect script.


        """
    def queryInspectedPrim(self) -> Optional[Prim]:
        """

        queryInspectedPrim(self) -> hou.Prim or None

            Return the primitive currently being inspected in the viewport, or
            None when nothing is being inspected or when called outside of an
            inspect script. The primitive returned will be a subclass of
            hou.Prim.


        """
    def mapToWorld(self, x: float, y: float) -> Tuple[Vector3, Vector3]:
        """

        mapToWorld(self, x, y) -> tuple of (hou.Vector3, hou.Vector3)

            Convert viewport coordinates to world coordinates. Returns a ray
            (direction vector and an origin point).


        """
    def mapToScreen(self, pos: Vector3) -> Vector2:
        """

        mapToScreen(self, position) -> hou.Vector2

            Convert world coordinates to viewport coordinates.


            position
                A hou.Vector3 containing a world space position.


        """
    def mapFromMouseChop(self, x: float, y: float) -> Tuple[int, int]:
        """

        mapFromMouseChop(self, x, y) -> tuple of (int, int)

            Convert from the Mouse CHOP's X and Y screen values (which range
            from -1 to 1) to viewport coordinates, where (0,0) is the bottom
            left corner of the viewport.


        """
    def queryWorldPositionAndNormal(self, x: int, y: int, selectionRestriction: bool = ...) -> Tuple[Vector3, Vector3, bool]:
        """

        queryWorldPositionAndNormal(self, x,y,selectionRestriction) -> tuple of
        (hou.Vector3, hou.Vector3, bool)

            Look up the world position and normal of geometry at viewport
            coordinates (x,y) where (0,0) is the bottom left corner of the
            viewport. The returned tuple contains the position, normal, and a
            boolean flag that is True if there is geometry at that screen
            position. The selectionRestriction can optionally exclude selected
            or non-selected prims; it defaults to querying all prims.


        """
    def size(self) -> Tuple[int, ...]:
        """

        size(self) -> tuple of double

            Returns the size of this viewport. The tuple elements are returned
            in viewport coordinates.

             1. X position (lower left)

             2. Y position (lower left)

             3. Width dimension

             4. Height dimension


        """
    def geometry(self) -> Tuple[int, ...]:
        """

        geometry(self) -> tuple of int

            Returns the position and size of this viewport in the UI space. The
            tuple elements are returned in viewport coordinates, relative to the
            lower-left corner position of the scene viewer.

             1. X position (lower left)

             2. Y position (lower left)

             3. Width dimension

             4. Height dimension


        """
    def isFloating(self) -> bool:
        """

        isFloating(self) -> bool

            Returns True if the viewport is a floating viewport, and False if it
            is one of the four docked viewports in the scene viewer layout.


        """
    def addEventCallback(self, callback: Callable[[dict[str, Any]], None]) -> None:
        '''

        addEventCallback(self, callback)

            Register a Python callback to be called whenever a viewport event
            occurs.


            callback
                Any callable Python object that expects keyworded arguments
                specific to an event type. This

            callback can be used for any geometry viewport event type.

            The kwargs contains the following:

          * event_type: A viewport event.

          * desktop: The desktop object holding the scene viewer.

          * viewer: The scene viewer object pointing to the viewport.

          * viewport: The viewport object that triggered the event.

          > import hou
          > 
          > def onViewportCB(**kwargs):
          >         event_type=kwargs[\'event_type\']
          >         desktop=kwargs[\'desktop\']
          >         viewer=kwargs[\'viewer\']
          >         viewport=kwargs[\'viewport\']
          > 
          >         print( \\"event type=\\",event_type )
          >         print( \\"desktop=\\",desktop )
          >         print( \\"viewer=\\",viewer )
          >         print( \\"viewport=\\",viewport )
          > 
          >         cam = viewport.camera()
          > if cam:
          >             print( \\"camera=%s

        \\"%(cam.name()) )
          > 
          > curSceneViewer = [item for item in hou.ui.curDesktop().currentPaneTabs() if item.type() == hou.paneTabType.SceneViewer][0]
          > curSceneViewer.curViewport().addEventCallback(onViewportCB)

        '''
    def removeEventCallback(self, callback: Callable[[dict[str, Any]], None]) -> None:
        """

        removeEventCallback(self,callback)

            Remove a specific Python callback that have been registered with
            hou.GeometryViewport.addEventCallback.


        """
    def clearEventCallbacks(self) -> None:
        """

        clearEventCallbacks(self)

            Remove all Python callbacks that have been registered with
            hou.GeometryViewport.addEventCallback.


        """
    def eventCallbacks(self) -> Tuple[Callable[[dict[str, Any]], None],...]:
        """

        eventCallbacks(self) -> tuple of callbacks

            Return a tuple of all the Python callbacks that have been registered
            with hou.GeometryViewport.addEventCallback.


        """

class GeometryViewportCamera:
    """

    hou.GeometryViewportCamera

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def stash(self) -> GeometryViewportCamera:
        """

        stash(self) -> hou.GeometryViewportCamera

            Create a copy of the camera settings which can be used to store the
            view, usually so it can be restored later. Stashed camera settings
            are not connected to a viewport, so modifying them will have no
            effect on the viewport until it is passed to the viewport via
            hou.GeometryViewport.setDefaultCamera().


        """
    def setPerspective(self, perspective: bool) -> None:
        """

        setPerspective(self, perspective)

            Set the camera view to perspective (True) or orthographic (False).
            Fixed orthographics views cannot be changed to perspective (Top,
            Bottom, Left, Right, Front, and Back).


        """
    def isPerspective(self) -> bool:
        """

        isPerspective(self) -> bool

            Query if the camara view uses a perspective projection.


        """
    def isOrthographic(self) -> bool:
        """

        isOrthographic(self) -> bool

            Query if the camara view uses an orthographic projection.


        """
    def setAperture(self, ap: float) -> None:
        """

        setAperture(self, ap)

            Set the aperture of the viewport camera. Throws an error if the
            viewport is looking though camera object and the view is not locked
            to that camera.


        """
    def aperture(self) -> float:
        """

        aperture(self) -> float

            Query the aperture of the viewport camera (or current camera).


        """
    def setFocalLength(self, fl: float) -> None:
        """

        setFocalLength(self, fl)

            Set the focal length of the viewport camera. Throws an error if the
            viewport is looking though camera object and the view is not locked
            to that camera.


        """
    def focalLength(self) -> float:
        """

        focalLength(self) -> float

            Query the focal length of the viewport camera (or current camera).


        """
    def focalUnitScale(self) -> float:
        """

        focalUnitScale(self) -> float

            Query the scale which needs to be applied to aperture and focal
            length due to the Focal Units parameter on the Camera object.


        """
    def setAspectRatio(self, ar: float) -> None:
        """

        setAspectRatio(self, ar)

            Set the view aspect ratio of the viewport camera (16:9 would be
            1.777). Throws an error if the viewport is looking though camera
            object and the view is not locked to that camera.


        """
    def aspectRatio(self) -> float:
        """

        aspectRatio(self) -> float


        """
    def setOrthoWidth(self, ow: float) -> None:
        """

        setOrthoWidth(self, ow)

            Set the orthographic width of the viewport camera. Throws an error
            if the viewport is looking though camera object and the view is not
            locked to that camera. This has no effect on perspective cameras.


        """
    def orthoWidth(self) -> float:
        """

        orthoWidth(self) -> float


        """
    def setRotation(self, mat: Matrix3) -> None: ...
    def rotation(self) -> Matrix3: ...
    def setTranslation(self, xyz: Sequence[float]) -> None:
        """

        setTranslation(self, xyz)


        """
    def translation(self) -> Tuple[float, ...]:
        """

        translation(self) -> 3-tuple of float

            Query the translation (position) of the viewport camera.


        """
    def setPivot(self, xyz: Sequence[float]) -> None:
        """

        setPivot(self, xyz)


        """
    def pivot(self) -> Tuple[float, ...]:
        """

        pivot(self) -> 3-tuple of float

            Query the pivot of the viewport camera.


        """
    def setClipPlanes(self, near_far: Sequence[float]) -> None:
        """

        setClipPlanes(self, near_far)


        """
    def clipPlanes(self) -> Tuple[float, ...]:
        """

        clipPlanes(self) -> 2-tuple of float

            Query the clip planes of the viewport camera as (near,far).


        """
    def setWindowOffset(self, xy: Sequence[float]) -> None:
        """

        setWindowOffset(self, xy)


        """
    def windowOffset(self) -> Tuple[float, ...]:
        """

        windowOffset(self) -> 2-tuple of float

            Query the window offset of the viewport, in (0,1) space.


        """
    def setWindowSize(self, size: Sequence[float]) -> None:
        """

        setWindowSize(self, size)


        """
    def windowSize(self) -> Tuple[float, ...]:
        """

        windowSize(self) -> 2-tuple of float

            Query the window size of the viewport, in (0,1) space.


        """

class GeometryViewportDisplaySet:
    """

    hou.GeometryViewportDisplaySet

    A Display Set represents a group of 3D viewport display options that
    apply to a particular context of geometry.

    OVERVIEW

        In Houdini's 3D viewer display options window, you can apply
        different display options to certain subsets of objects/geometry,
        for example selected objects, or the displayed SOP. This object
        represents a set of options that apply to one of these subsets. For
        example, you can set templated SOPs to display as wireframe:

      > # Get a reference to the geometry viewer
      > pane = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.SceneViewer)
      > 
      > # Get the display settings
      > settings = pane.curViewport().settings()
      > 
      > # Get the GeometryViewportDisplaySet for objects
      > tmplset = settings.displaySet(hou.displaySetType.TemplateModel)
      > 
      > # Tell Houdini to show set the shading mode for this subset to wireframe
      > tmplset.setShadedMode(hou.glShadingType.Wire)

        There are several subsets available:

        Objects

        hou.displaySetType.SceneObject
            Object nodes which are not selected or ghosted.

        hou.displaySetType.SelectedObject
            Object nodes which are selected.

        hou.displaySetType.GhostObject
            Object nodes which ghosted, which occurs when they are visible
            when at the SOP level and Ghost Other Objects is the current
            object mode, but are not the current object.

        Geometry

        hou.displaySetType.DisplayModel
            SOP with the display flag. This takes precedence over
            TemplateModel and CurrentModel, if the SOP has either the
            template flag set or is selected.

        hou.displaySetType.CurrentModel
            SOP that is currently selected. This takes precedence over
            TemplateModel, if that SOP also has the template flag set.

        hou.displaySetType.TemplateModel
            SOP that has a template flag set.

        You can set the options in each display set independently of the
        other sets. You can also link a subset to another, so this subset
        uses the linked set's options.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def displaySetType(self) -> EnumValue:
        '''

        displaySetType() -> hou.displaySetType

            Returns the geometry context this display set represents:

          * hou.displaySetType.SceneObject - object nodes which are not selected
            or ghosted.

          * hou.displaySetType.SelectedObject - object nodes which are selected.

          * hou.displaySetType.GhostObject - object nodes which ghosted, which
            occurs when they are visible when at the SOP level and \\"Ghost Other
            Objects\\" is the current object mode, but are not the current object.

          * hou.displaySetType.DisplayModel - SOP with the display flag. This
            takes precedence over TemplateModel and CurrentModel, if the SOP has
            either the template flag set or is selected.

          * hou.displaySetType.CurrentModel - SOP that is currently selected.
            This takes precedence over TemplateModel, if that SOP also has the
            template flag set.

          * hou.displaySetType.TemplateModel - SOP that has a template flag set.


        '''
    def showPointMarkers(self, b: bool) -> None:
        """

        showPointMarkers(self, on)

            Show or hide point markers.


        """
    def isShowingPointMarkers(self) -> bool:
        """

        isShowingPointMarkers(self) -> bool

            Query if point markers are shown (blue dots at points).


        """
    def showPointNumbers(self, b: bool) -> None:
        """

        showPointNumbers(self, on)

            Show or hide point numbers.


        """
    def isShowingPointNumbers(self) -> bool:
        """

        isShowingPointNumbers(self) -> bool

            Query if point numbers are shown as text (blue point numbers, one
            per point).


        """
    def showPointNormals(self, b: bool) -> None:
        """

        showPointNormals(self, on)

            Show or hide point normals.


        """
    def isShowingPointNormals(self) -> bool:
        """

        isShowingPointNormals(self) -> bool

            Query if point normals are shown.

            If the point normals are blue, the geometry has point normals. If
            they are dimmed, the model does not have normals and the normals
            shown have been automatically generated for display. If no normals
            are shown, the geometry has vertex normals. This query does not
            check for those conditions, but just the current setting of the
            display option.


        """
    def showPointPositions(self, b: bool) -> None:
        """

        showPointPositions(self, on)

            Show or hide point position text display, drawn by each point.


        """
    def isShowingPointPositions(self) -> bool:
        """

        isShowingPointPositions(self) -> bool

            Query if 3D point positions are being shown, as text: (x,y,z).


        """
    def showPointUVs(self, b: bool) -> None:
        """

        showPointUVs(self, on)

            Show or hide point UVs. If the geometry does not have point UVs,
            nothing will be displayed (ie. no UVs or vertex UVs).


        """
    def isShowingPointUVs(self) -> bool:
        """

        isShowingPointUVs(self) -> bool

            Query if point texture coordinates are being shown, as text: (u,v).


        """
    def showPointTrails(self, b: bool) -> None:
        """

        showPointTrails(self, on)

            Show or hide point trails on all points. Geometry must have a
            velocity attribute v.


        """
    def isShowingPointTrails(self) -> bool:
        """

        isShowingPointTrails(self) -> bool

            Query if point trails are shown (based on the velocity v attribute).


        """
    def showCoincidentPoints(self, b: bool) -> None:
        """

        showCoincidentPoints(self, on)

            Enable or disable coincident point detection. Orange points markers
            and a duplicate count are placed where coincident points are
            detected.

            Coincident point detection has affects viewport performance more
            significantly than other markers. It is best used when zoomed in on
            an area of the geometry for dense meshes, to avoid false positives.


            NOTE
                Coincident point detection has affects viewport performance more
                significantly than other markers. It is best used when zoomed in
                on an area of the geometry for dense meshes, to avoid false
                positives.


        """
    def isShowingCoincidentPoints(self) -> bool:
        """

        isShowingCoincidentPoints(self) -> bool

            Query if coincident point detection is enabled (yellow points and a
            duplicate count where coincident points are detected).


        """
    def showPrimHulls(self, b: bool) -> None:
        """

        showPrimHulls(self, on)

            Enable or disable primitive hulls. Only certain primitive types have
            hulls, such as NURBS, volumes, agents, and bezier curves.


        """
    def isShowingPrimHulls(self) -> bool:
        """

        isShowingPrimHulls(self) -> bool

            Query if primitive hulls are shown. Only some primitives have hulls,
            such as volumes, NURBS, crowd agents, and bezier curves.


        """
    def showPrimNumbers(self, b: bool) -> None:
        """

        showPrimNumbers(self, on)

            Enable or disable the display of primitive numbers, which are shown
            in the middle of the primitive.


        """
    def isShowingPrimNumbers(self) -> bool:
        """

        isShowingPrimNumbers(self) -> bool

            Query if primitive numbers are shown. The primitive numbers can be
            used to specify primitives in primitive groups. The number is shown
            at the center of the primitive.


        """
    def showPrimNormals(self, b: bool) -> None:
        """

        showPrimNormals(self, on)

            Enable or disable primitive face normals. This shows the face
            normals of polygons, not the value of a primitive N attribute.


        """
    def isShowingPrimNormals(self) -> bool:
        """

        isShowingPrimNormals(self) -> bool

            Query if the primitive face normals are shown. Only polygon-based
            primitives have face normals.


        """
    def showPrimProfiles(self, b: bool) -> None:
        """

        showPrimProfiles(self, on)

            Enable or disable profile curve display on NURBS surfaces.


        """
    def isShowingPrimProfiles(self) -> bool:
        """

        isShowingPrimProfiles(self) -> bool

            Query if profile curves are shown, on NURBS surfaces only.


        """
    def showPrimBreakpoints(self, b: bool) -> None:
        """

        showPrimBreakpoints(self, on)

            Enable or disable breakpoints display. Breakpoints are only
            available on NURBS and bezier surfaces and curves, and appear as
            hollow circles along the isoparms.


        """
    def isShowingPrimBreakpoints(self) -> bool:
        """

        isShowingPrimBreakpoints(self) -> bool

            Query if breakpoints are displayed. Breakpoints are only available
            on NURBS and bezier surfaces and curves.


        """
    def showPrimProfileNumbers(self, b: bool) -> None:
        """

        showPrimProfileNumbers(self, on)

            Enable or disable profile curve number display on NURBS surfaces.
            Each profile on a NURBS surface has an index from 0 to #profiles-1.


        """
    def isShowingPrimProfileNumbers(self) -> bool:
        """

        isShowingPrimProfileNumbers(self) -> bool

            Query if profile curve numbers are shown, on NURBS surfaces only.
            Each profile curve has an index from 0 to #profiles-1.


        """
    def showPrimBackfaces(self, b: bool) -> None:
        """

        showPrimBackfaces(self, on)

            Enable to tint backfacing polygons to distinguish them from front
            facing polygons.


        """
    def isShowingPrimBackfaces(self) -> bool:
        """

        isShowingPrimBackfaces(self) -> bool

            Query if backfacing polygons are tinted to distinguish them from
            front facing polygons.


        """
    def showVertexMarkers(self, b: bool) -> None:
        """

        showVertexMarkers(self, on)

            Enable or disable vertex markers. Vertex markers are drawn as small
            squares inset into its parent polygon slightly.


        """
    def isShowingVertexMarkers(self) -> bool:
        """

        isShowingVertexMarkers(self) -> bool

            Query if vertex markers are shown. Vertex markers are inset into
            their polygon slightly, for ease of selection and selection display.
            The markers are small hollow squares. Not all primitive types have
            vertex markers.


        """
    def showVertexNumbers(self, b: bool) -> None:
        """

        showVertexNumbers(self, on)

            Enable or disable vertex numbers. Vertex numbers are drawn as
            numbers inset into its parent polygon slightly, ranging 0 to
            #edges-1.


        """
    def isShowingVertexNumbers(self) -> bool:
        """

        isShowingVertexNumbers(self) -> bool

            Query if vertex numbers are shown. Each vertex on a polygon or mesh
            is numbered 0 to #edges-1.


        """
    def showVertexNormals(self, b: bool) -> None:
        """

        showVertexNormals(self, on)

            Enable or disable vertex normal display. Vertex normals are drawn
            inset into its parent polygon slightly. The geometry must have
            vertex normals to be shown (vertex N).


        """
    def isShowingVertexNormals(self) -> bool:
        """

        isShowingVertexNormals(self) -> bool

            Query if vertex normals are shown. If the geometry does not have
            vertex normals, they will not be shown. The base of the vertex
            normal is inset slightly into its polygon to make it easier to see
            which polygon the normal is influencing.


        """
    def showVertexUVs(self, b: bool) -> None:
        """

        showVertexUVs(self, on)

            Enable or disable vertex UV texture display. Vertex UVs are drawn
            inset into its parent polygon. The geometry must have vertex texture
            coordinates to be shown (vertex uv).


        """
    def isShowingVertexUVs(self) -> bool: ...
    def showUVBackfaces(self, b: bool) -> None:
        """

        showUVBackfaces(self, on)

            Enable or disable UV backface highlighting in the UV viewport.
            Backfacing polygons would have the texture displayed on them
            backwards, from the point of view of the background image in the UV
            viewport.


        """
    def isShowingUVBackfaces(self) -> bool:
        """

        isShowingUVBackfaces(self) -> bool

            Query if UV Backface highlighting is enabled in the UV view.
            Highlight polygons that are facing away, as the texture will appear
            backwards on these polygons.


        """
    def showUVOverlap(self, b: bool) -> None:
        """

        showUVOverlap(self, on)

            Enable or disable highlighting of UV overlap. Areas of the texture
            that would be share the same UVs are highlighted.


        """
    def isShowingUVOverlap(self) -> bool:
        """

        isShowingUVOverlap(self) -> bool

            Query if the UV overlap is shown in the UV texture viewport. UV
            areas that reuse the same UV coordinates will be highlighted.


        """
    def setPointMarkerVisibility(self, v: EnumValue) -> None:
        """

        setPointMarkerVisibility(self, visibility)

            Controls how point markers are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only markers for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Markers close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Markers under the mouse cursor
            are shown.


        """
    def pointMarkerVisibility(self) -> EnumValue:
        """

        pointMarkerVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point markers.


        """
    def setPointNumberVisibility(self, v: EnumValue) -> None:
        """

        setPointNumberVisibility(self, visibility)

            Controls how point numbers are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only numbers for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Numbers close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
            are shown.


        """
    def pointNumberVisibility(self) -> EnumValue:
        """

        pointNumberVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point numbers.


        """
    def setPointNormalVisibility(self, v: EnumValue) -> None:
        """

        setPointNormalVisibility(self, visibility)

            Controls how point normals are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only normals for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Normals close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Normals under the mouse cursor
            are shown.


        """
    def pointNormalVisibility(self) -> EnumValue:
        """

        pointNormalVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point normals.


        """
    def setPointPositionVisibility(self, v: EnumValue) -> None:
        """

        setPointPositionVisibility(self, visibility)

            Controls how point positions are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only positions for selected points
            are shown.

          * hou.markerVisibility.AroundPointer: Positions close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Positions under the mouse cursor
            are shown.


        """
    def pointPositionVisibility(self) -> EnumValue:
        """

        pointPositionVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point UVs.


        """
    def setPointUVVisibility(self, v: EnumValue) -> None:
        """

        setPointUVVisibility(self, visibility)

            Controls how point UVs are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only UVs for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: UVs close to the 3D point the
            mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: UVs under the mouse cursor are
            shown.


        """
    def pointUVVisibility(self) -> EnumValue:
        """

        pointUVVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point UVs.


        """
    def setPointTrailVisibility(self, v: EnumValue) -> None:
        """

        setPointTrailVisibility(self, visibility)

            Controls how point trails are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only trails for selected points are
            shown.

          * hou.markerVisibility.AroundPointer: Trails close to the 3D point the
            mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Trails under the mouse cursor are
            shown.


        """
    def pointTrailVisibility(self) -> EnumValue:
        """

        pointTrailVisibility(self) -> hou.markerVisibility

            Query the visibility setting of point trails.


        """
    def setPrimNumberVisibility(self, v: EnumValue) -> None:
        """

        setPrimNumberVisibility(self, visibility)

            Controls how primitive numbers are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only numbers for selected primitives
            are shown.

          * hou.markerVisibility.AroundPointer: Numbers close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
            are shown.


        """
    def primNumberVisibility(self) -> EnumValue:
        """

        primNumberVisibility(self) -> hou.markerVisibility

            Query the visibility setting of primitive numbers.


        """
    def setPrimNormalVisibility(self, v: EnumValue) -> None:
        """

        setPrimNormalVisibility(self, visibility)

            Controls how primitive face normals are shown when displayed.

          * hou.markerVisibility.Always: All are shown.

          * hou.markerVisibility.Selected: Only normals for selected primitives
            are shown.

          * hou.markerVisibility.AroundPointer: Normals close to the 3D point
            the mouse cursor is currently over are shown.

          * hou.markerVisibility.UnderPointer: Normals under the mouse cursor
            are shown.


        """
    def primNormalVisibility(self) -> EnumValue:
        """

        primNormalVisibility(self) -> hou.markerVisibility

            Query the visibility setting of primitive normals.


        """
    def setPrimBreakpointVisibility(self, v: EnumValue) -> None:
        """

        setPrimBreakpointVisibility(self, visibility)

            Controls how primitive breakpoints are shown when displayed.


        """
    def primBreakpointVisibility(self) -> EnumValue:
        """

        primBreakpointVisibility(self) -> hou.markerVisibility

            Query the visibility setting of primitive breakpoints.


        """
    def setVertexMarkerVisibility(self, v: EnumValue) -> None:
        """

        setVertexMarkerVisibility(self, visibility)

            Controls how vertex markers are shown when displayed.


        """
    def vertexMarkerVisibility(self) -> EnumValue:
        """

        vertexMarkerVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex markers.


        """
    def setVertexNormalVisibility(self, v: EnumValue) -> None:
        """

        setVertexNormalVisibility(self, visibility)

            Controls how vertex normals are shown when displayed.


        """
    def vertexNormalVisibility(self) -> EnumValue:
        """

        vertexNormalVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex normals.


        """
    def setVertexNumberVisibility(self, v: EnumValue) -> None:
        """

        setVertexNumberVisibility(self, visibility)

            Controls how vertex numbers are shown when displayed.


        """
    def vertexNumberVisibility(self) -> EnumValue:
        """

        vertexNumberVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex numbers.


        """
    def setVertexUVVisibility(self, v: EnumValue) -> None:
        """

        setVertexUVVisibility(self, visibility)

            Controls how vertex normals are shown when displayed.


        """
    def vertexUVVisibility(self) -> EnumValue:
        """

        vertexUVVisibility(self) -> hou.markerVisibility

            Query the visibility setting of vertex UVs.


        """
    def useGhostedLook(self, b: bool) -> None:
        """

        useGhostedLook(self, on)

            Make all geometry in the display set appear ghosted - slightly
            translucent. This allows geometry behind the ghosted to seen and de-
            emphasizes the ghosted geometry in the viewport. This is normal used
            to direct focus to other geometry (displayed SOP within an object,
            for example).


        """
    def isUsingGhostedLook(self) -> bool:
        """

        isUsingGhostedLook(self) -> bool

            Query if the display set is ghosted. Ghosted geometry appears
            translucent so that geometry behind it can be easily seen.


        """
    def useFadedLook(self, b: bool) -> None:
        """

        useFadedLook(self, on)

            Suppress geometry color (Cd attribute, point, primitive, or vertex)
            on the geometry in the display set.


        """
    def isUsingFadedLook(self) -> bool:
        """

        isUsingFadedLook(self) -> bool

            Query if the display set is faded. Faded geometry suppresses the
            display of geometry color.


        """
    def useXRay(self, b: bool) -> None:
        """

        useXRay(self, on)

            Draw the geometry in the display set as XRay, which draws the
            geometry normally if not occluded, and as a dimmed wireframe where
            occluded by other geometry.


        """
    def isUsingXRay(self) -> bool:
        """

        isUsingXRay(self) -> bool

            Query if the display set is drawn with XRay. XRay geometry will
            appear as a faded wireframe behind other geometry that occludes it.


        """
    def useLighting(self, b: bool) -> None:
        """

        useLighting(self, on)

            Enable lighting for the geometry in the display set. This works in
            conjunction with the global lighting mode in the viewport. Both this
            option and the global lighting mode must be set to a lighting mode
            in order to see lighting (ie, enabling Lighting on this display set
            will not cause it to be lit if the global viewport mode is No
            Lighting).


        """
    def isUsingLighting(self) -> bool:
        """

        isUsingLighting(self) -> bool

            Query if lighting is used for this display set. When off, the
            geometry is displayed without any lighting (often much brighter).


        """
    def useUVMap(self, b: bool) -> None:
        """

        useUVMap(self, on)

            Use a UV map texture for visualizing UVs when a model has UVs but no
            material assignment.


        """
    def isUsingUVMap(self) -> bool:
        """

        isUsingUVMap(self) -> bool

            Query if a UV map texture is used for visualizing UVs when a model
            has UVs but no material assignment.


        """
    def setShadingModeLocked(self, b: bool) -> None:
        """

        setShadingModeLocked(self, on)

            Locks the shading mode so that it cannot be changed by the user
            using the Shading Mode menu in the viewport or the wireframe toggle
            hotkey. Passing False unlocks the display set so that it follows the
            viewport's shading mode.


        """
    def isShadingModeLocked(self) -> bool:
        """

        isShadingModeLocked(self) -> bool

            Query if the shading mode is locked. When locked, changing the
            shading mode in the viewport will not affect the look of geometry in
            this display set.


        """
    def setToolbarLinked(self, b: bool) -> None:
        """

        setToolbarLinked(self, on)

            Link the display set's options to the option toggles in the right
            viewport toolbar. When linked, clicking a display option button on
            this toolbar will affect the corresponding option in this display
            set.


        """
    def isToolbarLinked(self) -> bool:
        """

        isToolbarLinked(self) -> bool

            Query if the display set is linked to the right viewport toolbar.
            When linked, clicking a display option button on this toolbar will
            affect the corresponding option in this display set.


        """
    def setUniqueDisplaySet(self, b: bool) -> None:
        """

        setUniqueDisplaySet(self, on)

            When True, remove any link from this display set to another display
            set. Its own settings will be used. Passing False has no effect; use
            setLinkToDisplaySet to link this set to another display set.


        """
    def isUniqueDisplaySet(self) -> bool:
        """

        isUniqueDisplaySet(self) -> bool

            A display set can be linked to another display set, so that all of
            its options are taken from that linked set rather than its own. This
            method returns True if the display set is unique, in that it is not
            linked to another display set, and False if the set refers to
            another display set.


        """
    def setShadedMode(self, arg2: EnumValue) -> None:
        """

        setShadedMode(self, shaded_mode)

            Sets the shading mode for this display set:

          * hou.glShadingType.WireBoundingBox: no geometry, only bounding box
            outline

          * hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box

          * hou.glShadingType.Wire: wireframe

          * hou.glShadingType.WireGhost: wireframe with muted hidden lines

          * hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines

          * hou.glShadingType.HiddenLineGhost: wireframe with solid constant
            faces

          * hou.glShadingType.Flat: shaded with primitive face normals

          * hou.glShadingType.FlatWire: shaded with primitive face normals,
            outlined polygons

          * hou.glShadingType.Smooth: shaded with point or vertex normals

          * hou.glShadingType.SmoothWire: shaded with point or vertex normals,
            outlined polygons


        """
    def shadedMode(self) -> EnumValue:
        """

        shadedMode(self) -> hou.glShadingType

            Query the shading mode of the display set (hou.glShadingType):

          * hou.glShadingType.WireBoundingBox: no geometry, only bounding box
            outline

          * hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box

          * hou.glShadingType.Wire: wireframe

          * hou.glShadingType.WireGhost: wireframe with muted hidden lines

          * hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines

          * hou.glShadingType.HiddenLineGhost: wireframe with solid constant
            faces

          * hou.glShadingType.MatCap: shaded with a MatCap texture, ignores
            other lighting and shading.

          * hou.glShadingType.MatCapWire: shaded MatCap texture, outlined
            polygons

          * hou.glShadingType.Flat: shaded with primitive face normals

          * hou.glShadingType.FlatWire: shaded with primitive face normals,
            outlined polygons

          * hou.glShadingType.Smooth: shaded with point or vertex normals

          * hou.glShadingType.SmoothWire: shaded with point or vertex normals,
            outlined polygons


        """
    def setBoundaryMode(self, arg2: EnumValue) -> None:
        """

        setBoundaryMode(self, hou.boundaryDisplay)

            Set the viewport types that highlight 3D boundaries for the geometry
            in the display set.

          * hou.boundaryDisplay.Off:

                No 3D boundaries are displayed.

          * hou.boundaryDisplay.On:

                3D boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                3D boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                3D boundaries are shown in UV viewports only.


        """
    def boundaryMode(self) -> EnumValue:
        """

        boundaryMode(self) -> hou.boundaryDisplay

            Query which viewport types display 3D boundaries
            (hou.boundaryDisplay).

          * hou.boundaryDisplay.Off:

                No 3D boundaries are displayed.

          * hou.boundaryDisplay.On:

                3D boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                3D boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                3D boundaries are shown in UV viewports only.


        """
    def setUVBoundaryMode(self, arg2: EnumValue) -> None:
        """

        setUVBoundaryMode(self, hou.boundaryDisplay)

            Set viewport types that highlight UV boundaries for the geometry in
            the display set.

          * hou.boundaryDisplay.Off:

                No UV boundaries are displayed.

          * hou.boundaryDisplay.On:

                UV boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                UV boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                UV boundaries are shown in UV viewports only.


        """
    def uvBoundaryMode(self) -> EnumValue:
        """

        uvBoundaryMode(self) -> hou.boundaryDisplay

            Query which viewport types display UV boundaries
            (hou.boundaryDisplay).

          * hou.boundaryDisplay.Off:

                No UV boundaries are displayed.

          * hou.boundaryDisplay.On:

                UV boundaries are shown in all viewports.

          * hou.boundaryDisplay.View3D:

                UV boundaries are shown in 3D viewports only.

          * hou.boundaryDisplay.ViewUV: .

                UV boundaries are shown in UV viewports only.


        """
    def setLinkToDisplaySet(self, arg2: EnumValue) -> None:
        """

        setLinkToDisplaySet(self, view_display_set)

            Link this display set to the settings of another display set. This
            display set's option settings are then ignored, and the other sets
            are used in their place. Linking a set to itself restores its own
            settings.

          * hou.displaySetType.SceneObject

          * hou.displaySetType.SelectedObject

          * hou.displaySetType.GhostObject

          * hou.displaySetType.DisplayModel

          * hou.displaySetType.CurrentModel

          * hou.displaySetType.TemplateModel


        """
    def linkedToDisplaySet(self) -> EnumValue:
        """

        linkedToDisplaySet(self) -> hou.displaySetType

            A display set can be linked to another display set, so that all of
            its options are taken from that linked set rather than its own. This
            method returns the display set this set is linked to. If it is not
            linked to another set, it will return the its own set.


        """

class GeometryViewportSettings:
    '''

    hou.GeometryViewportSettings

    A collection of settings controlling a viewport\'s view of the scene
    (such as the view angle and whether different guides are displayed).
    Many of this object\'s methods correspond to settings in the Display
    Options dialog.

    OVERVIEW


            To access a viewport, you must first get a reference to a Scene
            Viewer pane tab. See the following methods:


            hou.ui.paneTabOfType
                Use hou.ui.paneTabOfType(hou.paneTabType.SceneViewer) to get
                a reference to a Scene Viewer pane tab in the current pane
                layout. If the current layout has no Scene Viewer pane tab,
                this returns None.

                To be more precise about which viewer you grab in a possible
                multi-viewer layout, see also hou.ui.curDesktop to get a
                hou.Desktop object representing the current pane layout, and
                hou.Desktop.sceneViewers to get a list of scene viewer pane
                tabs in the current layout.

            Once you have a reference to a hou.SceneViewer pane object, you
            can use it to access the viewer pane\'s viewport or viewports.
            See the following methods:


            hou.SceneViewer.viewports
                Returns a list of the viewports in the viewer pane.

            hou.SceneViewer.findViewport
                Gets a single viewport by name, for example \\"Top\\".

            hou.SceneViewer.selectedViewport
                Gets the currently selected viewport. The user can select a
                viewport by pressing [Space + N] in the viewport. The view
                menus in the upper right corner are drawn brighter in the
                selected viewport.

        You can then get a GeometryViewportSettings object for the viewport
        by calling hou.GeometryViewport.settings.


        TIP
            Some of the more commonly-used methods, such as setting the view
            to look through a camera, are duplicated on the
            hou.GeometryViewport object for convenience.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def viewportType(self) -> EnumValue:
        """

        viewportType(self) -> hou.geometryViewportType enum value

            Query the viewport type (UV, 3D, top, left, etc).


        """
    def displaySet(self, settype: EnumValue) -> GeometryViewportDisplaySet:
        """

        displaySet(self, display_set) -> hou.GeometryViewportDisplaySet

            Returns the hou.GeometryViewportDisplaySet object associated with
            display_set, which must be a type of hou.displaySetType. A display
            set describes a certain category of displayed geometry (for example,
            templated geometry, or current (selected) geometry). The associated
            GeometryViewportDisplaySet object lets you customize how that
            category of geometry is drawn in the viewport, for example
            wireframe/shaded, showing point numbers, and so on.


        """
    def viewAspectRatio(self, masked: bool = True) -> float:
        """

        viewAspectRatio(self, masked) -> float

            Query the actual viewport aspect ratio. If masked is True, return
            the aspect ratio of the area inside the camera mask, otherwise
            return the full viewport aspect ratio.


        """
    def normalScale(self) -> float: ...
    def setNormalScale(self, normal_scale: float) -> None:
        """

        setNormalScale(self, normal_scale)

            Set a scale factor for the display of normals to increase or
            decrease their length.


        """
    def vectorScale(self) -> float:
        """

        vectorScale(self) -> float

            Query the scale applied to the length of vector decorations.


        """
    def setVectorScale(self, vec_scale: float) -> None:
        """

        setVectorScale(self, scale)

            Set the scale applied to vector decorations, to make them longer or
            shorter.


        """
    def pointMarkerSize(self) -> float:
        """

        pointMarkerSize(self) -> float

            Queries the size of point marker decorations, in pixels.


        """
    def setPointMarkerSize(self, psize: float) -> None:
        """

        setPointMarkerSize(self, point_size)

            Set the size of point marker decorations, in pixels.


        """
    def originGnomonSize(self) -> float:
        """

        originGnomonSize(self) -> float

            Queries the world size of the gnomon axes that appear at the world
            origin.


        """
    def setOriginGnomonSize(self, size: float) -> None:
        """

        setOriginGnomonSize(self, size)

            Sets the world size of the gnomon axes that appear at the world
            origin.


        """
    def floatingGnomonSize(self) -> float:
        """

        floatingGnomonSize(self) -> float

            Queries the size of the gnomon axes that appear in the corner of the
            3D viewport.


        """
    def setFloatingGnomonSize(self, size: float) -> None:
        """

        setFloatingGnomonSize(self, size)

            Sets the world size of the gnomon axes that appear in the corner of
            the 3D viewport.


        """
    def camera(self) -> Optional[ObjNode]:
        """

        camera(self) -> ObjNode or None

            Return the camera or light node that the viewport is looking
            through. Return None if the viewport is not looking through a camera
            or light node.


        """
    def setCamera(self, camera_node: ObjNode) -> None:
        """

        setCamera(self, camera_node)

            Makes the viewport look through the given camera node.


        """
    def saveViewToCamera(self, camera_node: ObjNode) -> None:
        """

        saveViewToCamera(self, camera_node)

            Saves the viewport's current view into the given camera node. It
            does this by setting the camera's transform parameters to match the
            viewport's view transform matrix.


        """
    def geometryInfo(self, arg: EnumValue) -> EnumValue:
        """

        geometryInfo(self, hou.viewportGeometryInfo)

            Queries the current geometry information display setting:

          * hou.viewportGeometryInfo.Off: No information displayed.

          * hou.viewportGeometryInfo.SelectedOnly: only display information if
            something is selected.

          * hou.viewportGeometryInfo.Always: Always display information.


        """
    def handleHighlight(self, arg: EnumValue) -> EnumValue:
        """

        handleHighlight(self, hou.viewportHandleHighlight)

            Sets the size of the handle highlight when the mouse is over a
            handle part:

          * hou.viewportHandleHighlight.Off: Handles do not show highlights.

          * hou.viewportHandleHighlight.Small: Handles have a subtle highlight.

          * hou.viewportHandleHighlight.Normal: Handles use their default
            highlight, which is twice the width of the small highlight.


        """
    def closureSelection(self, arg: EnumValue) -> EnumValue:
        """

        closureSelection(self, hou.viewportClosureSelection)

            Change the closure selection display setting. A Closure selection is
            shown on a primitive when any part of that primitive is selected.

          * hou.viewportClosureSelection.Hide: Do not show closure selections.

          * hou.viewportClosureSelection.HullPrimitives: Only show closure
            selections on primitives that have hulls which are disconnected from
            the tessellated surface or curve (such as a NURBS surface).

          * hou.viewportClosureSelection.Show: Show closure selections on all
            primitive types.


        """
    def guideFontSize(self) -> EnumValue: ...
    def setOffsetVertexMarkers(self, enable: bool) -> None:
        """

        setOffsetVertexMarkers(self, enable)

            When enabled, vertex markers and normals are inset into the polygon
            so they can be selected independently when part of a seamless mesh.
            When disabled, the markers and normals are placed at the actual
            vertex, potentially overlapping.


        """
    def offsetVertexMarkers(self) -> bool:
        """

        offsetVertexMarkers(self) -> bool

            When enabled, vertex markers and normals are inset into the polygon
            so they can be selected independently when part of a seamless mesh.
            When disabled, the markers and normals are placed at the actual
            vertex, potentially overlapping.


        """
    def enableGuide(self, guide: EnumValue, enabled: bool) -> None:
        """

        enableGuide(self, guide, on)

            Show or hide a guide. The guide argument must be a type of
            hou.viewportGuide.


        """
    def guideEnabled(self, guide: EnumValue) -> bool:
        """

        guideEnabled(self, guide) -> bool

            Test if a guide is visible. The guide argument must be a type of
            hou.viewportGuide.


        """
    def levelOfDetail(self) -> float:
        """

        levelOfDetail(self) -> double

            Query the current level of detail used for tessellating geometry.


        """
    def volumeQuality(self) -> EnumValue:
        """

        volumeQuality(self) -> hou.viewportVolumeQuality

            Query the volume display quality.

          * hou.viewportVolumeQuality.VeryLow: Very fast, low quality preview

          * hou.viewportVolumeQuality.Low: Fewer slices than Normal for speed

          * hou.viewportVolumeQuality.Normal: Good quality vs. speed setting.

          * hou.viewportVolumeQuality.High: Large number of slices with
            jittering


        """
    def volumeAmbientShadows(self) -> float:
        """

        volumeAmbientShadows(self) -> double

            Query the default intensity of self-shadowing for fog volumes from
            ambient light sources.


        """
    def volumeBSplines(self) -> EnumValue:
        """

        volumeBSplines(self) -> hou.viewportVolumeBSplines

            Query if higher order interpolation is used by the viewport to draw
            fog volumes.

          * hou.viewportVolumeBSplines.Off: the viewport will never use higher-
            order volume interpolation. This is the fastest to draw, but low
            resolution volumes may appear blocky in the viewport.

          * hou.viewportVolumeBSplines.NonInteractive: the viewport will use the
            higher-order interpolation when not interacting with the viewport.
            This mode falls back to linear interpolation while interacting with
            the viewport to speed up draws.

          * hou.viewportVolumeBSplines.On: the viewport will always use higher-
            order volume interpolation. This is the slowest, highest quality
            option.


            NOTE
                The equivalent setting in the viewport display options can be
                found in the Geometry tab and is labelled Volume Filtering.


        """
    def volumeWireAsPoints(self) -> bool:
        """

        volumeWireAsPoints(self) -> bool

            Query if volumes are currently drawn as a point field in wireframe.


        """
    def polygonConvexQuality(self) -> bool:
        """

        polygonConvexQuality(self) -> bool

            Query the polygon convexing quality, true for high quality and false
            for fast convexing.


        """
    def subdivsionLimit(self) -> int:
        """

        subdivsionLimit(self) -> int

            Returns the current subdivision polygon limit, in millions of
            polygons.


        """
    def wireWidth(self) -> float:
        """

        wireWidth(self) -> double

            Query the width of lines drawn for wireframe and wire-over-shaded
            modes.


        """
    def wireBlend(self) -> float:
        """

        wireBlend(self) -> double

            Query the blend factor between wires and the surface in wire-over-
            shaded modes. Values close to 0 produce very faint lines, values
            closer to 1 produce solid lines.


        """
    def interiorWireAlpha(self) -> float:
        """

        interiorWireAlpha(self) -> double

            Query the dimness of the interior wires in a tet mesh. Outer wires
            are drawn normally, inner wires are dimmed. This only affects tet
            meshes in wireframe mode.


        """
    def shadeOpenCurves(self) -> bool:
        """

        shadeOpenCurves(self) -> bool

            Query if shaded open curves are enabled or not.


        """
    def selectWireframeAsSolid(self) -> bool:
        """

        selectWireframeAsSolid(self) -> bool

            Query if selection of wireframe polygons is done by face (true) or
            edge (false).


        """
    def setWireOverPackedGeo(self, wire_over_packed: bool) -> None:
        """

        setWireOverPackedGeo(self, wire_over_packed)

            Show polygon outlines on meshes in packed geometry when drawing a
            wire-over-shaded mode. Disabling this hides the outlines on packed
            geometry, making meshes appear as a single shape, which packed
            geometry technically is.


        """
    def wireOverPackedGeo(self) -> bool:
        """

        wireOverPackedGeo(self) -> bool

            Query if polygon outlines are visible on packed geometry when a
            wire-over-shaded mode is active.


        """
    def particleDisplayType(self) -> EnumValue:
        """

        particleDisplayType(self) -> hou.viewportParticleDisplay

            Query the default particle display.

          * hou.viewportParticleDisplay.Points: Constant sized point marker,
            with the diameter specified by particlePointSize. This marker is
            unaffected by pscale.

          * hou.viewportParticleDisplay.Pixels: Single pixel drawn for a
            particle.

          * hou.viewportParticleDisplay.Lines: Streak trail plus marker.

          * hou.viewportParticleDisplay.Discs: World-space circle, affected by
            pscale or discSize.


        """
    def allowParticleSprites(self) -> bool:
        """

        allowParticleSprites(self) -> bool

            Query if particles are drawn as sprites when sprite attributes are
            detected on the particle (sprite* or shop_materialpath).


        """
    def particlePointSize(self) -> float:
        """

        particlePointSize(self) -> double

            Query the point diameter for particles drawn as Points or Lines.


        """
    def particleDiscSize(self) -> float:
        """

        particleDiscSize(self) -> double

            Query the disc diameter for particles drawn as Discs or Sprites if
            the pscale attribute does not exist. This is specified in world-
            space units.


        """
    def orientDiscToNormal(self) -> bool:
        """

        orientDiscToNormal(self) -> bool

            Queries if discs and sprites are oriented to the normal (true) or
            not. The normal will be orthogonal to the disc (they will face in
            that direction).


        """
    def spriteTextureLimit(self) -> Tuple[int,...]:
        """

        spriteTextureLimit(self) -> tuple of int

            Query the maximum texture resolution for sprites. This is primarily
            a performance vs. quality trade-off option. Larger sprites look
            better but may cause slowdowns for large particle systems.


        """
    def pointInstancing(self) -> bool:
        """

        pointInstancing(self) -> bool

            Query if point instancing is globally enabled.


        """
    def pointInstancingPercent(self) -> float:
        """

        pointInstancingPercent(self) -> double

            Query the percentage of instances shown in the viewport for point
            instancing.


        """
    def pointInstancingLimit(self) -> int:
        """

        pointInstancingLimit(self) -> int

            Query the current polygon limit for instancing.


        """
    def instanceStandInGeometry(self) -> EnumValue:
        """

        instanceStandInGeometry(self) -> hou.viewportStandInGeometry

            Query the current stand-in geometry for culled instances.

          * hou.viewportStandInGeometry.DisplayOff: Show nothing for culled
            instances.

          * hou.viewportStandInGeometry.LocationMarker: Show a location marker
            at the local space origin of each instanced.

          * hou.viewportStandInGeometry.BoundingBox: Show the culled instances'
            bounding boxes.


        """
    def autoGenerateVertexNormals(self) -> bool:
        """

        autoGenerateVertexNormals(self) -> bool

            Query if vertex normals are produced when geometry is missing
            normals. If false, point numbers are produced.


        """
    def vertexNormalCuspAngle(self) -> float:
        """

        vertexNormalCuspAngle(self) -> double

            Query the cusp angle for vertex normal generation. Any shared edge
            between polygons will be considered a hard edge if the polygon faces
            differ by more than this angle, otherwise the normals will be smooth
            over the edge.


        """
    def vertexNormalLimit(self) -> int:
        """

        vertexNormalLimit(self) -> int

            Query the polygon limit for generating vertex normals, in millions
            of polygons.


        """
    def setSceneAntialias(self, aa: int) -> None:
        """

        setSceneAntialias(self, aalevel)

            Sets the viewports full-scene antialiasing level to one of 1, 2, 4,
            8, 16, 32, 64, or 128. This represents the number of samples
            rendered to produce a higher quality image. Higher numbers produce
            better antialiasing, but this can affect the viewport's rendering
            performance. Some graphics hardware only support a subset of these
            modes (eg. up to 8 or 32).


        """
    def sceneAntialias(self) -> int:
        """

        sceneAntialias(self)

            Returns the number of samples used to antialias the viewport.
            Possible values are 1 (no antialiasing), 2, 4 (default for most
            hardware), 8, 16, 32, 64, or 128.


        """
    def setHdrRendering(self, hdr: bool) -> None:
        """

        hdrRendering(self) -> bool

            Queries if High Dynamic Range (HDR) rendering is enabled.


        """
    def hdrRendering(self) -> bool: ...
    def setXrayDrawing(self, global_enable: bool) -> None:
        """

        setXrayDrawing(self, global_enable)

            Globally enable or disable X-ray drawing. Object must have their
            X-ray flag set in order to render as X-ray. X-ray causes the object
            to be visible when occluded.


        """
    def xrayDrawing(self) -> bool:
        """

        xrayDrawing(self) -> bool

            Query if X-ray drawing is enabled globally.


        """
    def setXrayQuality(self, quality: bool) -> None:
        """

        setXrayQuality(self, quality)

            Enable high-quality X-ray rendering, which draws X-rayed objects as
            dimmed shaded surfaces when occluded, with up to 8 levels of overlap
            between X-rayed objects. This looks better but takes longer to
            render. Regular X-ray rendering displays X-ray objects as wireframe
            when occluded.


        """
    def xrayQuality(self) -> bool:
        """

        xrayQuality(self) -> bool

            Queries if high quality X-ray rendering is active.


        """
    def setXrayStrength(self, strength: float) -> None:
        """

        setXrayStrength(self, strength)

            Sets the strength of the occluded x-ray objects. Lower values make
            occluded X-ray objects dimmer.


        """
    def xrayStrength(self) -> float:
        """

        xrayStrength(self) -> double

            Query the strength of occluded x-ray objects.


        """
    def setObjectOrigins(self, globel_enable: bool) -> None:
        """

        setObjectOrigins(self, globel_enable)

            Globally allow object origins to be displayed. Object origins are
            enabled by setting the Origin flag on objects.


        """
    def objectOrigins(self) -> bool:
        """

        objectOrigins(self) -> bool

            Query if object origin display is globally enabled.


        """
    def setOnionSkinning(self, global_enable: bool) -> None:
        """

        setOnionSkinning(self, global_enable)

            Globally allow onion skinning to be displayed. Onion skinning is
            enabled on a per-object basis in the Misc tab of objects. This shows
            animation as a series of ghosted poses at other frames around the
            current frame.


        """
    def onionSkinning(self) -> bool:
        """

        onionSkinning(self) -> bool

            Query if onion skinning is globally enabled.


        """
    def setOnionSkinFramesBeforeCount(self, num_frames: int) -> None:
        """

        setOnionSkinFramesBeforeCount(self, num_frames)

            Set the number of onion skins before the current frame. Their
            spacing depends on the onion skin frame increment.


        """
    def onionSkinFramesBeforeCount(self) -> int:
        """

        onionSkinFramesBeforeCount(self) -> int

            Queries the number of onion skins before the current frame.


        """
    def setOnionSkinFramesBeforeTint(self, tint: Color) -> None:
        """

        setOnionSkinFramesBeforeTint(self, tint)

            Tint all onion skins that appear before the current frame with this
            color.


        """
    def onionSkinFramesBeforeTint(self) -> Color:
        """

        onionSkinFramesBeforeTint(self) -> tuple of double

            Query the tint color of skins that appear before the current frame.


        """
    def setOnionSkinFramesAfterCount(self, num_frames: int) -> None:
        """

        setOnionSkinFramesAfterCount(self, num_frames)

            Set the number of onion skins after the current frame. Their spacing
            depends on the onion skin frame increment.


        """
    def onionSkinFramesAfterCount(self) -> int:
        """

        onionSkinFramesAfterCount(self) -> int

            Queries the number of onion skins after the current frame.


        """
    def setOnionSkinFramesAfterTint(self, tint: Color) -> None:
        """

        setOnionSkinFramesAfterTint(self, tint)

            Tint all onion skins that appear after the current frame with this
            color.


        """
    def onionSkinFramesAfterTint(self) -> Color:
        """

        onionSkinFramesAfterTint(self) -> tuple of double

            Query the tint color of skins that appear after the current frame.


        """
    def setOnionSkinFrameIncrement(self, frame_increment: int) -> None:
        """

        setOnionSkinFrameIncrement(self, frame_increment)

            Set the frame increment between onion skins. Using 1 will draw every
            frame around the current frame ($F-2 $F-1 $F $F+1 $F+2, while 5
            would step by 5 ($F-10 $F-5 $F $F+5 $F+10).


        """
    def onionSkinFrameIncrement(self) -> int:
        """

        onionSkinFrameIncrement(self) -> int

            Query the frame increment between onion skins.


        """
    def setOnionSkinOpacity(self, opacity: float) -> None:
        """

        setOnionSkinOpacity(self, opacity)

            Set the opacity of the onion skins to make them more or less
            prominent.


        """
    def onionSkinOpacity(self) -> float:
        """

        onionSkinOpacity(self) -> double

            Query the current onion skin opacity.


        """
    def setSceneGamma(self, gamma: float) -> None:
        """

        setSceneGamma(self, gamma)

            Set the gamma correction for the scene. This value should match the
            calibrated gamma of the display device.


        """
    def sceneGamma(self) -> float:
        """

        sceneGamma(self) -> double

            Query the scene gamma correction.


        """
    def setUseSceneLUT(self, enable: bool) -> None:
        """

        setUseSceneLUT(self, enable)

            Enable Lookup Table (LUT) color correction. A valid LUT file must
            also be present.


        """
    def useSceneLUT(self) -> bool:
        """

        useSceneLUT(self) -> bool

            Query if Lookup Table color correction is enabled. This will return
            True even no LUT file exists.


        """
    def setSceneLUT(self, lut_file: str) -> None:
        """

        setSceneLUT(self, lut_file)

            Specify a Lookup Table (LUT) file to use for color correction.


        """
    def sceneLUT(self) -> str:
        """

        sceneLUT(self) -> str

            Query the current Lookup Table (LUT) file.


        """
    def setBackgroundImageGammaLUT(self, apply_to_bg: bool) -> None:
        """

        setBackgroundImageGammaLUT(self, apply_to_bg)

            Apply gamma and Lookup Table (LUT) color correction to the
            background image.


        """
    def backgroundImageGammaLUT(self) -> bool:
        """

        backgroundImageGammaLUT(self) -> bool

            Query if color correction is applied to the background image.


        """
    def setDepthOfField(self, enable: bool) -> None:
        """

        setDepthOfField(self, enable)

            Enable depth of field effect (also requires the viewport look
            through a camera with a non-zero fstop).


        """
    def getDepthOfField(self) -> bool:
        """

        getDepthOfField(self) -> bool

            Query if the Depth of Field setting is enabled.


        """
    def setDepthOfFieldBokeh(self, viewportDOFBokeh: EnumValue) -> None:
        """

        setDepthOfFieldBokeh(self, viewportDOFBokeh)

            Set the bokeh effect.

          * hou.viewportDOFBokeh.NoBokeh:

                No additional bokeh effect.

          * hou.viewportDOFBokeh.Circular:

                Circular bokeh (can also be oval if the aspect is adjusted).

          * hou.viewportDOFBokeh.Texture:

                Use a texture, either from a image file or COP (using the op:
                syntax).


        """
    def getDepthOfFieldBokeh(self) -> EnumValue:
        """

        getDepthOfFieldBokeh(self) -> hou.EnumValue

            Query the current bokeh effect state.


        """
    def setDepthOfFieldBokehTexture(self, file_or_node: str) -> None:
        """

        setDepthOfFieldBokehTexture(self, file_or_node)

            Set the path to an image file or COP node to use as the bokeh shape.
            COP references use the op: syntax.


        """
    def getDepthOfFieldBokehTexture(self) -> str:
        """

        getDepthOfFieldBokehTexture(self) -> str

            Return the file or COP path of the bokeh shape.


        """
    def setDepthOfFieldBokehBoost(self, boost: float) -> None:
        """

        setDepthOfFieldBokehBoost(self, boost)

            Boost the brightness of the image to produce more more and brighter
            bokeh shapes.


        """
    def getDepthOfFieldBokehBoost(self) -> float:
        """

        getDepthOfFieldBokehBoost(self) -> float

            Query the current bokeh boost.


        """
    def setDepthOfFieldBokehAspect(self, aspect: float) -> None:
        """

        setDepthOfFieldBokehAspect(self, aspect)

            Set the aspect ratio (width/height) of the bokeh shape.


        """
    def getDepthOfFieldBokehAspect(self) -> float:
        """

        getDepthOfFieldBokehAspect(self) -> float

            Query the current bokeh aspect ratio.


        """
    def showsName(self, show: bool) -> None:
        """

        showsName(self, show)

            Display the viewport name and menu in the upper right corner.


        """
    def showName(self) -> bool:
        """

        showName(self) -> bool

            Query if the viewport name menu is displayed.


        """
    def showsCameraName(self, show: bool) -> None:
        """

        showsCameraName(self, show)

            Display the camera name and menu in the upper right corner.


        """
    def showCameraName(self) -> bool:
        """

        showCameraName(self) -> bool

            Query if the camera name menu is displayed.


        """
    def showsStateStatus(self, show: bool) -> None:
        """

        showsStateStatus(self, show)

            Display any status messages of the current tool.


        """
    def showStateStatus(self) -> bool:
        """

        showStateStatus(self) -> bool

            Query if the tool status messages are displayed.


        """
    def showsBadges(self, show: bool) -> None:
        """

        showsBadges(self, show)

            Display viewport status badges as icons beside the camera menu,
            which presents additional state information.


        """
    def showBadges(self) -> bool:
        """

        showBadges(self) -> bool

            Query if viewport status badges are displayed. Badges are icons
            which present additional state information.


        """
    def useAspectRatio(self, enable: bool) -> None:
        """

        useAspectRatio(self, enable)

            Enforce a specific aspect ratio for the viewport, which will add
            bars if the viewport aspect ratio does not match.


        """
    def usingAspectRatio(self) -> bool:
        """

        usingAspectRatio(self) -> bool

            Query if a specific aspect ratio is being enforced.


        """
    def setAspectRatio(self, aspect: float) -> None:
        """

        setAspectRatio(self, aspect)

            Set the viewport aspect ratio (width/height).


        """
    def aspectRatio(self) -> float:
        """

        aspectRatio(self) -> float

            Query the viewport aspect ratio display option. Use
            viewAspectRatio() to query the current viewport aspect ratio.


        """
    def setViewMaskOpacity(self, opacity: float) -> None:
        """

        setViewMaskOpacity(self, opacity)

            Set the opacity of the bars used to mask areas out the viewport
            outside the aspect ratio.


        """
    def viewMaskOpacity(self) -> float:
        """

        viewMaskOpacity(self) -> float

            Query the opacity of the bars used to mask areas out the viewport
            outside the aspect ratio.


        """
    def setStereoMode(self, viewportStereoMode: EnumValue) -> None:
        """

        setStereoMode(self, viewportStereoMode)

            Set the stereo display mode when viewing through a stereo camera.

          * hou.viewportStereoMode.Anaglyph:

                Anaglyph display of left/right as red/cyan.

          * hou.viewportStereoMode.HorizontalInterlace:

                Interlace left and right on alternating scanlines. Only useful
                for 3D monitors which support this.

          * hou.viewportStereoMode.HorizontalInterlaceReverse:

                Interlace left and right on alternating scanlines, swapping
                which scanlines are used for left and right.

          * hou.viewportStereoMode.QuadBufferGL:

                Use OpenGL quad buffer stereo, generally only available on
                professional cards.


        """
    def stereoMode(self) -> EnumValue:
        """

        stereoMode(self) -> hou.viewportStereoMode

            Query the current stereo display mode.


        """
    def setHomeAutoAdjustsClip(self, viewportHomeClipMode: EnumValue) -> None:
        """

        setHomeAutoAdjustsClip(self, viewportHomeClipMode)

            Set which camera clip planes are adjusted when performing a homing
            operation.

          * hou.viewportHomeClipMode.Neither:

                Neither clip plane is adjusted.

          * hou.viewportHomeClipMode.FarOnly:

                Only the far clip plane is adjusted.

          * hou.viewportHomeClipMode.NearOnly:

                Only the near clip plane is adjusted.

          * hou.viewportHomeClipMode.NearAndFar:

                Both clip planes are adjusted.


        """
    def homeAutoAdjustClip(self) -> EnumValue:
        """

        homeAutoAdjustClip(self) -> hou.viewportHomeClipMode

            Queries which camera clip planes are adjusted when performing a
            homing operation.


        """
    def setClipPlanes(self, clip: Sequence[float]) -> None:
        """

        setClipPlanes(self, clip)

            Set the near and far camera clip planes from a 2-tuple.


        """
    def clipPlanes(self) -> Tuple[float, ...]:
        """

        clipPlanes(self) -> tuple of float

            Query the near and far camera clip planes, returning them in a
            2-tuple.


        """
    def setMinHomeSize(self, min_size: float) -> None:
        """

        setMinHomeSize(self, min_size)

            Set the smallest area that viewport can home to, in world units.


        """
    def minHomeSize(self) -> float:
        """

        minHomeSize(self) -> float

            Query the smallest area that viewport can home to, in world units.


        """
    def setUVDisplayAttribute(self, uv: str) -> None: ...
    def uvDisplayAttribute(self) -> str:
        """

        uvDisplayAttribute(self) -> str

            Return the attribute currently displayed in the UV viewport.


        """
    def setUVAutoAttribute(self, detect: bool) -> None: ...
    def uvAutoAttribute(self) -> bool:
        """

        uvAutoAttribute(self) -> bool

            Return True if the UV viewport is auto-detecting the class of the
            displayed UV attribute.


        """
    def setUVVertexType(self, is_vertex_uv: bool) -> None: ...
    def uvVertexType(self) -> bool:
        """

        uvVertexType(self) -> bool

            Return the class of the UV attribute, Point or Vertex. This returns
            the viewport setting, and not the detected class of the current UV
            attribute. If uvAutoAttribute is enabled, the class will be the same
            as the currently displayed attribute, but if it is disabled it may
            be different.


        """
    def setUVMapTexture(self, uv_file: str) -> None:
        """

        setUVMapTexture(self, uv)

            Set the file path of the texture map used to visualize UVs when
            geometry has a UV attribute but no material assigned.


        """
    def uvMapTexture(self) -> str:
        """

        uvMapTexture(self) -> str

            Return the file path of the texture map used to visualize UVs when
            geometry has a UV attribute but no material assigned.


        """
    def setUVMapScale(self, uv_scale: float) -> None:
        """

        setUVMapScale(self, scale)

            Set the UV scaling factor for the UV Map when visualizing UVs. It
            defaults to 1.


        """
    def uvMapScale(self) -> float:
        """

        uvMapScale(self) -> float

            Returns the UV scaling factor for the UV Map when visualizing UVs.


        """
    def setLighting(self, viewportLighting: EnumValue) -> None:
        """

        setLighting(self, viewportLighting)

            Set the global lighting mode for all viewports.

          * hou.viewportLighting.Off:

                No lighting, constant shaded.

          * hou.viewportLighting.Headlight:

                Basic lighting from a single directional light defined in the
                display options.

          * hou.viewportLighting.Normal:

                Good quality lighting from up to 10 basic lights (area lights
                modeled as point lights, limited environment lights).

          * hou.viewportLighting.HighQuality:

                High quality lighting from an unlimited number of lights
                including area, geometry, environment and ambient occlusion.

          * hou.viewportLighting.HighQualityWithShadows:

                High quality lighting with shadows.


        """
    def lighting(self) -> EnumValue:
        """

        lighting(self) -> hou.viewportLighting

            Query the current global lighting mode.


        """
    def setWorkLightType(self, viewportWorkLight: EnumValue) -> None:
        """

        setWorkLightType(self, viewportWorkLight)

            Set the work light type. Does not change the lighting mode to
            Headlight; this must be done separately.

          * hou.viewportWorkLight.Headlight:

                Single over-the-shoulder distant light.

          * hou.viewportWorkLight.Domelight:

                Environment light with optional texture map.

          * hou.viewportWorkLight.PhysicalSky:

                Outdoor lighting with a distant and environment map based on the
                sun position and atmospheric conditions.

          * hou.viewportWorkLight.ThreePoint:

                Three distant lights set up in a classic three point lighting
                arrangement.


        """
    def workLightType(self) -> EnumValue:
        """

        workLightType(self) -> hou.viewportWorkLight

            Return the current work light type.


        """
    def setWorkLightOptions(self, p: dict[str, Any]) -> None:
        """

        setWorkLightOptions(self, light_parms)

            Set any number of the work light parameters using a python
            dictionary. The name and types of the parameters can be queried with
            workLightOptions.


        """
    def workLightOptions(self) -> dict[str, Any]:
        """

        workLightOptions(self) -> dictionary

            Return a python dictionary of the parameters of all the work light
            types, which can be modified and passed back to setWorkLightOptions.


        """
    def showDiffuse(self, enable: bool) -> None:
        """

        showDiffuse(self, enable)

            Enable diffuse contribution of lighting. When disabled, diffuse will
            not contribute to the final lit color. This can be used to debug
            lighting.


        """
    def showingDiffuse(self) -> bool:
        """

        showingDiffuse(self) -> bool

            Query if diffuse lighting is enabled.


        """
    def showSpecular(self, enable: bool) -> None:
        """

        showSpecular(self, enable)

            Enable specular highlights. When disabled, specular will not
            contribute to the final lit color. This will also disable most
            reflections. This can be used to debug lighting.


        """
    def showingSpecular(self) -> bool:
        """

        showingSpecular(self) -> bool

            Query if specular lighting is enabled.


        """
    def showAmbient(self, enable: bool) -> None:
        """

        showAmbient(self, enable)

            Enable ambient lighting. When disabled, all ambient lights will not
            contribute to the final lit color. This can be used to debug
            lighting.


        """
    def showingAmbient(self) -> bool:
        """

        showingAmbient(self) -> bool

            Query if ambient lighting is enabled.


        """
    def showEmission(self, enable: bool) -> None:
        """

        showEmission(self, enable)

            Enable emissive lighting. Emission lighting comes from materials on
            geometry, not lights, so modifying the lights in the scene has no
            effect on it. This can be used to debug lighting.


        """
    def showingEmission(self) -> bool:
        """

        showingEmission(self) -> bool

            Query if emission lighting is enabled.


        """
    def setLightSampling(self, num_samples: int) -> None:
        """

        setLightSampling(self, num_samples)

            Set the number of lighting samples to perform when doing high
            quality lighting for area and environment lights.


        """
    def lightSampling(self) -> int:
        """

        lightSampling(self) -> int

            Query the number of lighting samples.


        """
    def setMaxLightSamples(self, samples: int) -> None:
        """

        setMaxLightSamples(self, samples)

            Set the maximum number of light samples to use, across all lights.
            If there are more lights than samples, at least 1 sample will be
            used for each light. Setting this to zero removes the limit and each
            light will use up to the number of samples defined by the Light
            Sampling display option. Not all lights use multiple samples.


        """
    def maxLightSamples(self) -> int:
        """

        maxLightSamples(self) -> int

            Return the maximum light samples, or zero if there is no limit.


        """
    def setLightLimit(self, limit: int) -> None:
        """

        setLightLimit(self, limit)

            Set the maximum number of lights to contribute to lighting in HQ
            Lighting. The brightest lights are taken first. Setting this to zero
            disables the limit.


        """
    def getLightLimit(self) -> int:
        """

        getLightLimit(self) -> int

            Return the maximum number of lights to use in HQ Lighting, or zero
            if there is no light limit.


        """
    def setHeadlightIntensity(self, intensity: float) -> None:
        """

        setHeadlightIntensity(self, intensity)

            Set the intensity of the headlight used in Headlight lighting mode.


        """
    def headlightIntensity(self) -> float:
        """

        headlightIntensity(self) -> double

            Query the intensity of the headlight.


        """
    def setHeadlightDirection(self, dir: Sequence[float]) -> None:
        """

        setHeadlightDirection(self, dir)

            Set the direction of the headlight used in Headlight lighting mode.
            This is expressed as a direction vector in camera space (the camera
            looks down -Z).


        """
    def headlightDirection(self) -> Tuple[float, ...]:
        """

        headlightDirection(self) -> tuple of double

            Query the vector direction of the headlight.


        """
    def setHeadlightSpecular(self, enable: bool) -> None:
        """

        setHeadlightSpecular(self, enable)

            Enable specular reflections when in Headlight lighting mode. Turning
            this off results in purely diffuse lighting.


        """
    def headlightSpecular(self) -> bool:
        """

        headlightSpecular(self) -> bool

            Query if specular reflections are generated by the headlight.


        """
    def setHeadlightOcclusion(self, enable: bool) -> None:
        """

        setHeadlightOcclusion(self, enable)

            Enables ambient occlusion when in headlight mode. This has no effect
            if a lighting mode other than headlight is active.


        """
    def headlightOcclusion(self) -> bool:
        """

        headlightOcclusion(self) -> bool

            Query if ambient occlusion is active for headlight mode.


        """
    def setAmbientOcclusion(self, enable: bool) -> None:
        """

        setAmbientOcclusion(self, enable)

            Enable an ambient occlusion pass in high quality lighting modes.
            This generates local occlusion shadows.


        """
    def ambientOcclusion(self) -> bool:
        """

        ambientOcclusion(self) -> bool

            Query if ambient occlusion is enabled. This can return true even if
            not in a high quality mode as this queries the raw display option
            value, not a reflection of whether the pass is active. If querying
            it the pass is active, the lighting mode should also be checked.


        """
    def setAmbientOcclusionLevel(self, level: int) -> None:
        """

        setAmbientOcclusionLevel(self, level)

            Set the level of occlusion to generate, from 1-4. Higher levels
            produce a larger area of effect, while lower values produce fine
            detail.


        """
    def ambientOcclusionLevel(self) -> int:
        """

        ambientOcclusionLevel(self) -> int

            Return the current occlusion level for ambient occlusion.


        """
    def setShadowQuality(self, viewportShadowQuality: EnumValue) -> None:
        """

        setShadowQuality(self, viewportShadowQuality)

            Set the quality of shadow sampling in High Quality Lighting with
            Shadows lighting mode.

          * hou.viewportShadowQuality.Point:

                Area lights are treated as point lights when generating and
                sampling shadow maps. This is the fastest option.

          * hou.viewportShadowQuality.PointAA:

                Do some antialiasing of shadow edges. Treat area lights as point
                lights when generating and sampling shadow maps.

          * hou.viewportShadowQuality.Area:

                Area lights generate multiple shadow maps which are sampled to
                generate an approximation of a blurred shadow from an area
                source.

          * hou.viewportShadowQuality.AreaAA:

                Area lights generate multiple maps and antialias the shadow
                lookups.


        """
    def shadowQuality(self) -> EnumValue:
        """

        shadowQuality(self) -> hou.viewportShadowQuality

            Query the current shadow quality.


        """
    def setShadowSensitivity(self, offset: Sequence[int]) -> None:
        """

        setShadowSensitivity(self, offset)

            Set the shadow bias to avoid self-shadowing. A 2-tuple is expected,
            with the first value setting the variable offset (depending on how
            parallel the surface is to the view direction) and the second a
            constant offset. Generally these don't need to be changed from their
            default, but larger values reduce self shadowing but increase the
            risk of missing shadows for very close geometry.


        """
    def shadowSensitivity(self) -> Tuple[int, ...]:
        """

        shadowSensitivity(self) -> tuple of int

            Query the variable and constant shadow offsets, returned in a
            2-tuple.


        """
    def setShadowMapSize(self, size: int) -> None:
        """

        setShadowMapSize(self, size)

            Set the maximum shadow map size, in pixels. Larger maps will produce
            sharper shadows but increase memory usage. Shadow maps are always
            square.


        """
    def shadowMapSize(self) -> int:
        """

        shadowMapSize(self) -> int

            Query the maximum size of the shadow maps used by High Quality
            Lighting with Shadows lighting mode.


        """
    def setShadowMapSizeFromLight(self, enable: bool) -> None:
        """

        setShadowMapSizeFromLight(self, enable)

            Set whether to use the shadow map size specified by the Shadow Map
            size parameter in the light object (clamped to the maximum size
            specified in the display options) or always use the maximum size.


        """
    def shadowMapSizeFromLight(self) -> bool:
        """

        shadowMapSizeFromLight(self) -> bool

            Query if the shadow map size is defined by the light object.


        """
    def setShadowMapMem(self, mem_in_mb: int) -> None:
        """

        setShadowMapMem(self, mem_in_mb)

            Set the amount of VRAM to use for all shadowmaps, in MiB.


        """
    def getShadowMapMem(self) -> int:
        """

        getShadowMapMem(self) -> int

            Query the amount of VRAM used for shadowmaps, in MiB.


        """
    def setShadowMapTime(self, time_in_sec: float) -> None:
        """

        setShadowMapTime(self, time_in_sec)

            Set the time limit for generating shadowmaps in one redraw (in
            seconds). If more shadowmaps are left to generate, cause another
            redraw (and so on until all are complete).


        """
    def getShadowMapTime(self) -> float:
        """

        getShadowMapTime(self) -> int

            Return the time limit for generating shadowmaps within one redraw,
            in seconds.


        """
    def useReflections(self, enable: bool) -> None:
        """

        useReflections(self, enable)

            Enable reflection mapping. Objects with reflective materials
            generate reflection maps of the scene around them, which can be
            quite expensive.


        """
    def usingReflections(self) -> bool:
        """

        usingReflections(self) -> bool

            Query if reflection mapping is enabled.


        """
    def setHdrReflections(self, hdr_reflect: bool) -> None:
        """

        setHdrReflections(self, hdr_reflect)

            Enable High Dynamic Range (HDR) color buffers for the generated
            scene cubemap, which allows for higher contrast and bright spots in
            reflections.


        """
    def hdrReflections(self) -> bool:
        """

        hdrReflections(self) -> bool

            Query if High Dynamic Range (HDR) color buffers are use for the
            scene cubemap.


        """
    def setReflectMapSize(self, size: int) -> None:
        """

        setReflectMapSize(self, size)

            Set the size of the cubemap used to store the surrounding scene as
            an environment map. Larger cubemaps produce sharper reflections but
            increase memory use.


        """
    def reflectMapSize(self) -> int:
        """

        reflectMapSize(self) -> int

            Query the size of reflection cubemaps.


        """
    def setMinReflectAmount(self, min_reflect: float) -> None:
        """

        setMinReflectAmount(self, min_reflect)

            Set the minimum level of reflection required for a reflection
            cubemap to be generated for an object. This is based on the largest
            reflective value from all the materials assigned to the object. The
            larger this value, the more reflective an object must be to generate
            a reflection maps. A value of zero is not recommended, as all
            objects will generate a reflection map.


        """
    def minReflectAmount(self) -> float:
        """

        minReflectAmount(self) -> double

            Query the minimum reflection level required for a cubemap to be
            generated for an object.


        """
    def setUseRayTracing(self, enable: bool) -> None:
        """

        setUseRayTracing(self)

            Ray tracing is used for Ambient Occlusion and shading lights. This
            can be enabled even if the hardware doesn't support ray tracing, in
            which case it will be as if the option is off.


        """
    def useRayTracing(self) -> bool:
        """

        getUseRayTracing(self) -> bool

            Query if ray tracing is enabled. This may return True if even if the
            hardware does not support ray tracing (but it will not have any
            effect in that case).


        """
    def setUseDenoising(self, enable: bool) -> None:
        """

        setUseDenoising(self)

            Control if denoising may be used to smooth out noise from
            environment lights, ambient occlusion, and/or raytraced lights.


        """
    def useDenoising(self) -> bool:
        """

        getUseDenoising(self) -> bool

            Query if denoising is enabled.


        """
    def setFastInteractiveSampling(self, fast: bool) -> None:
        """

        setFastInteractiveSampling(self, fast)

            When enabled, drops the number of samples used in HQ Lighting to
            improve performance when interacting with the viewer, which includes
            tumbling, moving handles, or playing the timeline. This may result
            in slightly different lighting while interacting with the viewer.


        """
    def fastInteractiveSampling(self) -> bool:
        """

        fastInteractiveSampling(self) -> bool

            Query if Fast Interactive Sampling is enabled on the viewer. This
            drops the number of samples used in HQ Lighting to improve
            performance when interacting with the viewer.


        """
    def showMaterials(self, enable: bool) -> None:
        """

        showMaterials(self, enable)

            Enable materials on geometry from SHOPs or VOPs. When disabled,
            these material assignments are ignored and only the attributes on
            the geometry will affect shading.


        """
    def showingMaterials(self) -> bool:
        """

        showingMaterials(self) -> bool

            Query if materials are shown.


        """
    def showGeometryColor(self, enable: bool) -> None:
        """

        showGeometryColor(self, enable)

            Enable contribution of the geometry Cd attribute to the material.
            When disabled, this is ignored. Cd multiplies both the material
            diffuse and ambient colors.


        """
    def showingGeometryColor(self) -> bool:
        """

        showingGeometryColor(self) -> bool

            Query if geometry Cd contributes to the material.


        """
    def useTransparency(self, enable: bool) -> None:
        """

        useTransparency(self, enable)

            Enable transparency rendering. When transparency is enabled, another
            pass handles areas of the geometry that have Alpha less than one
            (either due to an Alpha attribute or material opacity). When
            disabled, alpha is ignored and rendered as opaque.


        """
    def usingTransparency(self) -> bool:
        """

        usingTransparency(self) -> bool

            Query if transparency rendering is enabled.


        """
    def setTransparencyQuality(self, viewportTransparency: EnumValue) -> None:
        """

        setTransparencyQuality(self, viewportTransparency)

            Set the quality of the transparency pass performed by the viewport.

          * hou.viewportTransparency.Cutout:

                Fast test to render the transparent pixel as opaque (>0) or to
                discard it (0). This can be used for texture cards such as
                leaves. This doesn't require an additional pass for
                transparency.

          * hou.viewportTransparency.Low:

                Render transparent pixels in a separate pass. Only the front-
                most transparent pixel is rendered.

          * hou.viewportTransparency.Medium:

                Render transparent pixels in an Order-Independent buffer of 8
                samples, which is then sorted and composited together to do
                multi-layer transparency for up to 8 layers of overlapping
                transparency.

          * hou.viewportTransparency.High:

                Render transparent pixels in an Order-Independent buffer of 16
                samples, which is then sorted and composited together to do
                multi-layer transparency for up to 16 layers of overlapping
                transparency.


        """
    def transparencyQuality(self) -> EnumValue:
        """

        transparencyQuality(self) -> hou.viewportTransparency

            Query the transparency quality.


        """
    def useDisplacement(self, enable: bool) -> None:
        """

        useDisplacement(self, enable)

            Enable displacement mapping for materials that have a displacement
            map. When disabled, the displacement map is ignored. This can have a
            significant hit for lower-end GPUs.


        """
    def usingDisplacement(self) -> bool:
        """

        usingDisplacement(self) -> bool

            Query if displacement mapping is allowed.


        """
    def setDisplacementLevel(self, level: float) -> None:
        """

        setDisplacementLevel(self, level)

            Set the level of detail for displacement mapping. Displacement
            mapping adaptively subdivides the geometry to provide finer detail.
            Higher values result in denser subdivision, while lower values
            produce lighter meshes. The default is 1.0.


        """
    def displacementLevel(self) -> float:
        """

        displacementLevel(self) -> double

            Query the level of detail used for displacement mapping.


        """
    def setDefaultMaterialDiffuse(self, tint: Color) -> None:
        """

        setDefaultMaterialDiffuse(self, tint)

            Set the diffuse color of the default material (used when no material
            assignment is present or Show Materials is disabled).


        """
    def defaultMaterialDiffuse(self) -> Color:
        """

        defaultMaterialDiffuse(self) -> hou.Color

            Query the default material's diffuse color.


        """
    def setDefaultMaterialSpecular(self, tint: Color) -> None:
        """

        setDefaultMaterialSpecular(self, tint)

            Set the specular color of the default material (used when no
            material assignment is present or Show Materials is disabled).


        """
    def defaultMaterialSpecular(self) -> Color:
        """

        defaultMaterialSpecular(self) -> hou.Color

            Query the default material's specular color.


        """
    def setDefaultMaterialAmbient(self, tint: Color) -> None:
        """

        setDefaultMaterialAmbient(self) -> hou.Color

            Query the default material's ambient color.


        """
    def defaultMaterialAmbient(self) -> Color:
        """

        defaultMaterialAmbient(self, tint)

            Set the ambient color of the default material (used when no material
            assignment is present or Show Materials is disabled).


        """
    def setDefaultMaterialEmission(self, tint: Color) -> None:
        """

        setDefaultMaterialEmission(self) -> hou.Color

            Query the default material's emission color.


        """
    def defaultMaterialEmission(self) -> Color:
        """

        defaultMaterialEmission(self, tint)

            Set the emission color of the default material (used when no
            material assignment is present or Show Materials is disabled).


        """
    def setDefaultMaterialMatCapFile(self, filepath: str) -> None:
        """

        setDefaultMaterialMatCapFile(self, filepath)

            Set the file path to a Material Capture (MatCap) texture for the
            MatCap default material. A MatCap texture encodes lighting and
            shading information, much like a lat-long environment map.


        """
    def getDefaultMaterialMatCapFile(self) -> str:
        """

        getDefaultMaterialMatCapFile(self) -> str

            Return the file path of the current MatCap texture.


        """
    def setDefaultMaterialMatCapIntensity(self, i: float) -> None:
        """

        setDefaultMaterialMatCapIntensity(self, i)

            Set the intensity of the MatCap texture, which can be used to boost
            or dim the values in a MatCap texture file. This is a direct
            multiplier on the texture values.


        """
    def getDefaultMaterialMatCapIntensity(self) -> float:
        """

        getDefaultMaterialMatCapIntensity(self) -> float

            Return the MatCap texture intensity multiplier.


        """
    def setDefaultMaterialType(self, viewportDefaultMaterial: EnumValue) -> None:
        """

        setDefaultMaterialType(self, viewportDefaultMaterial)

            Set the default material type used when the geometry has to material
            assignment.

          * hou.viewportDefaultMaterial.Simple:

                An untextured material with variable roughness and color
                settings for diffuse, specular, emission, and ambient values.

          * hou.viewportDefaultMaterial.MatCap:

                A material that uses a MatCap texture (Material Capture) to
                define the lighting and shading of the surface rather than the
                lights in the scene.


        """
    def getDefaultMaterialType(self) -> EnumValue:
        """

        getDefaultMaterialType(self) -> hou.EnumValue

            Return the default material type, either Simple or MatCap


        """
    def setUniformFog(self, enable: bool) -> None:
        """

        setUniformFog(self, enable)

            Draw an simple atmospheric fog effect in the viewport, based on
            distance and not affected by lighting.


        """
    def getUniformFog(self) -> bool:
        """

        getUniformFog(self) -> bool

            Query if uniform fog is active.


        """
    def setUniformFogColor(self, color: Sequence[float]) -> None:
        """

        setUniformFogColor(self, color)

            Tints the generated fog so it can be made to look more like smog,
            haze, or dust.


        """
    def getUniformFogColor(self) -> Tuple[float, ...]:
        """

        getUniformFogColor(self) -> tuple of float

            Query the uniform fog color.


        """
    def setUniformFogDensity(self, density: float) -> None:
        """

        setUniformFogDensity(self, density)

            Factor that controls how dense the fog is. Must be a positive value.


        """
    def getUniformFogDensity(self) -> float:
        """

        getUniformFogDensity(self) -> float

            Query the uniform fog density.


        """
    def setUniformFogOpacity(self, opacity: float) -> None:
        """

        setUniformFogOpacity(self, opacity)

            An additional factor on the final fog result to make it heavier
            (>1.0) or lighter (<1.0). Must be zero or greater.


        """
    def getUniformFogOpacity(self) -> float:
        """

        getUniformFogOpacity(self) -> float

            Query the fog opacity.


        """
    def setUniformFogDepthRange(self, range: Sequence[float]) -> None:
        """

        setUniformFogDepthRange(self, range)

            For uniform fog, this is the depths where the fog begins and ends,
            in unit distance from the camera. All depths beyond the end are
            clamped to the end depth. Any depth before the fog start do not have
            fog applied. The fog start should be smaller than fog end, and both
            should be positive.


        """
    def getUniformFogDepthRange(self) -> Tuple[float, ...]:
        """

        getUniformFogDepthRange(self) -> tuple of float

            Query the uniform depth range (near,far).


        """
    def setUniformFogHeightMode(self, viewportFogHeightMode: EnumValue) -> None:
        """

        setUniformFogHeightMode(self, viewportFogHeightMode)

          * hou.viewportFogHeightMode.Off:

                Height has no effect on the fog.

          * hou.viewportFogHeightMode.Above:

                Fog only appears above the fog height.

          * hou.viewportFogHeightMode.Below:

                Fog only appears below the fog height.


        """
    def getUniformFogHeightMode(self) -> EnumValue:
        """

        getUniformFogHeightMode(self) -> hou.EnumValue

            Query the uniform fog height mode.


        """
    def setUniformFogHeight(self, h: float) -> None:
        """

        setUniformFogHeight(self, h)

            Set the height where fog starts, in world units.


        """
    def getUniformFogHeight(self) -> float:
        """

        getUniformFogHeight(self) -> float

            Query the uniform fog height.


        """
    def setUniformFogHeightFalloff(self, h: float) -> None:
        """

        setUniformFogHeightFalloff(self, h)

            Set the height of the fog transition area between no and uniform
            full fog, in world units.


        """
    def getUniformFogHeightFalloff(self) -> float:
        """

        getUniformFogHeightFalloff(self) -> float

            Query the uniform fog falloff.


        """
    def setUniformFogDepthClip(self, depth: float) -> None:
        """

        setUniformFogDepthClip(self, depth)

            Anything beyond the depth clip value not have uniform fog applied.
            This is useful for preventing fog on skyboxes or other image-based
            background elements.


        """
    def getUniformFogDepthClip(self) -> float:
        """

        getUniformFogDepthClip(self) -> float

            Query the depth clip value.


        """
    def setUniformFogUseSun(self, enable: bool) -> None:
        """

        setUniformFogUseSun(self, enable)

            Enable or disable simple lighting of uniform fog based on a distant
            light in the scene.


        """
    def getUniformFogUseSun(self) -> bool:
        """

        getUniformFogUseSun(self) -> bool

            Query if the sun light is enabled for uniform fog.


        """
    def setUniformFogSunBloom(self, bloom: float) -> None:
        """

        setUniformFogSunBloom(self, bloom)

            Set the size of the light bloom around the sun (scattering).


        """
    def getUniformFogSunBloom(self) -> float:
        """

        getUniformFogSunBloom(self) -> float

            Query the sun bloom.


        """
    def setUniformFogSunIntensity(self, intensity: float) -> None:
        """

        setUniformFogSunIntensity(self, intensity)

            For uniform fog with the Sun enabled, this provides an additional
            intensity adjustment on the distant light's color.


        """
    def getUniformFogSunIntensity(self) -> float:
        """

        getUniformFogSunIntensity(self) -> float

            Query the sun light intensity modifier.


        """
    def setVolumeFog(self, enable: bool) -> None:
        """

        setVolumeFog(self, enable)

            Draw an simple atmospheric fog effect in the viewport, based on
            distance and not affected by lighting.


        """
    def getVolumeFog(self) -> bool:
        """

        getVolumeFog(self) -> bool

            Query if volume fog is active.


        """
    def setVolumeFogColor(self, color: Sequence[float]) -> None:
        """

        setVolumeFogColor(self, color)

            Tints the generated fog so it can be made to look more like smog,
            haze, or dust.


        """
    def getVolumeFogColor(self) -> Tuple[float, ...]:
        """

        getVolumeFogColor(self) -> tuple of float

            Query the volume fog color.


        """
    def setVolumeFogDensity(self, density: float) -> None:
        """

        setVolumeFogDensity(self, density)

            Factor that controls how dense the fog is. Must be a positive value.


        """
    def getVolumeFogDensity(self) -> float:
        """

        getVolumeFogDensity(self) -> float

            Query the volume fog density.


        """
    def setVolumeFogOpacity(self, opacity: float) -> None:
        """

        setVolumeFogOpacity(self, opacity)

            An additional factor on the final fog result to make it heavier
            (>1.0) or lighter (<1.0). Must be zero or greater.


        """
    def getVolumeFogOpacity(self) -> float:
        """

        getVolumeFogOpacity(self) -> float

            Query the fog opacity.


        """
    def setVolumeFogDepthRange(self, range: Sequence[float]) -> None:
        """

        setVolumeFogDepthRange(self, range)

            For volume fog, this is the depths where the fog begins and ends, in
            unit distance from the camera. All depths beyond the end are clamped
            to the end depth. Any depth before the fog start do not have fog
            applied. The fog start should be smaller than fog end, and both
            should be positive.


        """
    def getVolumeFogDepthRange(self) -> Tuple[float, ...]:
        """

        getVolumeFogDepthRange(self) -> tuple of float

            Query the volume depth range (near,far).


        """
    def setVolumeFogHeightMode(self, viewportFogHeightMode: EnumValue) -> None:
        """

        setVolumeFogHeightMode(self, viewportFogHeightMode)

          * hou.viewportFogHeightMode.Off:

                Height has no effect on the fog.

          * hou.viewportFogHeightMode.Above:

                Fog only appears above the fog height.

          * hou.viewportFogHeightMode.Below:

                Fog only appears below the fog height.


        """
    def getVolumeFogHeightMode(self) -> EnumValue:
        """

        getVolumeFogHeightMode(self) -> hou.EnumValue

            Query the volume fog height mode.


        """
    def setVolumeFogHeight(self, h: float) -> None:
        """

        setVolumeFogHeight(self, h)

            Set the height where fog starts, in world units.


        """
    def getVolumeFogHeight(self) -> float:
        """

        getVolumeFogHeight(self) -> float

            Query the volume fog height.


        """
    def setVolumeFogHeightFalloff(self, h: float) -> None:
        """

        setVolumeFogHeightFalloff(self, h)

            Set the height of the fog transition area between no and volume full
            fog, in world units.


        """
    def getVolumeFogHeightFalloff(self) -> float:
        """

        getVolumeFogHeightFalloff(self) -> float

            Query the volume fog falloff.


        """
    def setVolumeFogQuality(self, viewportFogQuality: EnumValue) -> None:
        """

        setVolumeFogQuality(self, viewportFogQuality)

            The quality determines the size of the volume used for fog lighting.

          * hou.viewportFogQuality.Low:

                Small volume for fast drawing.

          * hou.viewportFogQuality.Medium:

                Larger volume balanced for quality and speed.

          * hou.viewportFogQuality.High:

                Very large volume for quality.


        """
    def getVolumeFogQuality(self) -> EnumValue:
        """

        getVolumeFogQuality(self) -> hou.EnumValue

            Query the volume fog quality.


        """
    def setVolumeFogLightIntensity(self, h: float) -> None:
        """

        setVolumeFogLightIntensity(self, h)

            Set the default light intensity modifier for any lights without the
            gl_fogintensity property on them. Zero will cause only lights with
            that property to contribute to the lighting.


        """
    def getVolumeFogLightIntensity(self) -> float:
        """

        getVolumeFogLightIntensity(self) -> float

            Query the volume light intensity modifier.


        """
    def setVolumeFogLightScattering(self, scatter: Sequence[float]) -> None:
        """

        setVolumeFogLightScattering(self, scatter)


        """
    def getVolumeFogLightScattering(self) -> Tuple[float, ...]:
        """

        getVolumeFogLightScattering(self) -> tuple of float

            Query the volume light scattering (2-tuple).


        """
    def setBloom(self, enable: bool) -> None:
        """

        setBloom(self, enable)

            Enable or disable the drawing of the bloom post-process effect which
            creates light bloom around very bright pixels.


        """
    def getBloom(self) -> bool:
        """

        getBloom(self) -> bool

            Query if bloom is enabled.


        """
    def setBloomScale(self, scale: float) -> None:
        """

        setBloomScale(self, scale)

            Scale the radius of blooms. The size is initially based on the
            brightness of the pixel, and this multiplies that value.


        """
    def getBloomScale(self) -> float:
        """

        getBloomScale(self) -> float

            Query the bloom scale.


        """
    def setBloomIntensity(self, i: float) -> None:
        """

        setBloomIntensity(self, i)

            Brighten or darken the blooms. The intensity is initially based on
            the brightness of the pixel, and this multiplies that value.


        """
    def getBloomIntensity(self) -> float:
        """

        getBloomIntensity(self) -> float

            Query the bloom intensity.


        """
    def setBloomThreshold(self, i: float) -> None:
        """

        setBloomThreshold(self, i)

            Any pixels in the scene which are brighter than this threshold will
            have bloom applied to them (white being 1.0). Increasing this value
            reduces the amount of bloom generated.


        """
    def getBloomThreshold(self) -> float:
        """

        getBloomThreshold(self) -> float

            Query the bloom threshold.


        """
    def setFogNode(self, node: Node) -> None:
        """

        setFogNode(self, node)

            Specify a node path which contains the fog parameters above. Any
            parameter that is found will override its corresponding display
            option. See Fog Properties. Passing None will clear the fog node and
            use the display option settings instead.


        """
    def getFogNode(self) -> Optional[Node]:
        """

        getFogNode(self) -> hou.OpNode

            Query the fog node override.


        """
    def setDisplayOrthoGrid(self, enable: bool) -> None:
        """

        setDisplayOrthoGrid(self, enable)

            Display the grid in fixed orthographic views (Top, Left, Front,
            Bottom, Right, Back).


        """
    def displayOrthoGrid(self) -> bool:
        """

        displayOrthoGrid(self) -> bool

            Query if the grid is displayed in fixed orthographic views.


        """
    def setOrthoGridOffset(self, offset: Sequence[float]) -> None:
        """

        setOrthoGridOffset(self, offset)

            Set the offset of the grid in fixed orthographic views, as a 3-tuple
            in world space.


        """
    def orthoGridOffset(self) -> Tuple[float, ...]:
        """

        orthoGridOffset(self) -> tuple of float

            Query the offset of the grid in fixed orthographic views.


        """
    def setOrthoGridSpacing(self, offset: Sequence[float]) -> None:
        """

        setOrthoGridSpacing(self, offset)

            Set the spacing of the grid lines in fixed orthographic views as a
            2-tuple.


        """
    def orthoGridSpacing(self) -> Tuple[float, ...]:
        """

        orthoGridSpacing(self) -> tuple of float

            Query the spacing of the grid lines in fixed orthographic views as a
            2-tuple.


        """
    def setOrthoGridRuler(self, offset: Sequence[int]) -> None:
        """

        setOrthoGridRuler(self, offset)

            Set the spacing of the grid numbers in fixed orthographic views as a
            2-tuple.


        """
    def orthoGridRuler(self) -> Tuple[int, ...]:
        """

        orthoGridRuler(self) -> tuple of int

            Query the spacing of the grid numbers in fixed orthographic views as
            a 2-tuple.


        """
    def setOrthoRuler(self, viewportGridRuler: EnumValue) -> None:
        """

        setOrthoRuler(self, viewportGridRuler)

            Where to display the grid numbers on the fixed orthographic view
            grid.

          * hou.viewportGridRuler.Hide:

                Do not display.

          * hou.viewportGridRuler.MainAxis:

                Display along the main axes at grid line intersections.

          * hou.viewportGridRuler.GridPoints:

                Display on grid line intersections.


        """
    def orthoRuler(self) -> EnumValue:
        """

        orthoRuler(self) -> hou.viewportGridRuler

            Query where the grid numbers are displayed on the fixed orthographic
            view grid.

          * hou.viewportGridRuler.Hide:

                Not displayed.

          * hou.viewportGridRuler.MainAxis:

                Displayed along the main axes at grid line intersections.

          * hou.viewportGridRuler.GridPoints:

                Displayed on grid line intersections.


        """
    def setUVReferenceGrid(self, enable: bool) -> None:
        """

        setUVReferenceGrid(self, enable)

            Display the grid in UV viewports.


        """
    def uvReferenceGrid(self) -> bool:
        """

        uvReferenceGridOverImage(self) -> bool

            Query if the dot grid is displayed.


        """
    def setUVDisplayGridOverImage(self, enable: bool) -> None: ...
    def uvReferenceGridOverImage(self) -> bool: ...
    def setUVGridPixelSpacing(self, offset: Sequence[int]) -> None:
        """

        setUVGridPixelSpacing(self, offset)

            Set the spacing of the UV dot grid displayed over the background
            image.


        """
    def uvGridPixelSpacing(self) -> Tuple[int, ...]:
        """

        uvGridPixelSpacing(self) -> tuple of float

            Query the spacing of the UV dot grid displayed over background
            images.


        """
    def setUVGridPixelOffset(self, offset: Sequence[float]) -> None:
        """

        setUVGridPixelOffset(self, offset)

            Set the spacing, in pixels, of the dot grid.


        """
    def uvGridPixelOffset(self) -> Tuple[float, ...]:
        """

        uvGridPixelOffset(self) -> tuple of float

            Query the spacing of the dot grid in pixels.


        """
    def setClampUVGridToBackground(self, enable: bool) -> None:
        """

        setClampUVGridToBackground(self, enable)

            Restrict the grid to the background image's area.


        """
    def clampUVGridToBackground(self) -> bool:
        """

        clampUVGridToBackground(self) -> bool

            Query if the grid is restricted to the background image's area.


        """
    def setDisplayUVTileBoundaries(self, enable: bool) -> None:
        """

        setDisplayUVTileBoundaries(self, enable)

            Display the boundaries of UV tiles at integral U and V numbers.


        """
    def displayUVTileBoundaries(self) -> bool:
        """

        displayUVTileBoundaries(self) -> bool

            Query if the boundaries of UV tiles are displayed.


        """
    def setColorScheme(self, viewportColorScheme: EnumValue) -> None:
        """

        setColorScheme(self, viewportColorScheme)

            Set the color scheme for the viewport.

          * hou.viewportColorScheme.Dark:

                Black background.

          * hou.viewportColorScheme.Grey:

                Light grey background.

          * hou.viewportColorScheme.Light:

                Light blue gradient background.

          * hou.viewportColorScheme.DarkGrey:

                Dark grey background.


        """
    def colorScheme(self) -> EnumValue:
        """

        colorScheme(self) -> hou.viewportColorScheme

            Query the current viewport color scheme.

          * hou.viewportColorScheme.Dark:

                Black background.

          * hou.viewportColorScheme.Grey:

                Light grey background.

          * hou.viewportColorScheme.Light:

                Light blue gradient background.

          * hou.viewportColorScheme.DarkGrey:

                Dark grey background.


        """
    def colorFromName(self, name: str) -> Color:
        """

        colorFromName(self, colorName) -> hou.Color

            Query a specific color from the current viewport color scheme. The
            valid color names can be found in the color scheme configuration
            files in 3DSceneColors.


        """
    def alphaFromName(self, name: str) -> float:
        """

        alphaFromName(self, colorName) -> double

            Query a specific alpha from the current viewport color scheme. The
            valid alpha names can be found in the color scheme configuration
            files in 3DSceneColors.


        """
    def backgroundImage(self, viewportBackgroundView: EnumValue, layer: int = 1) -> GeometryViewportBackground:
        """

        backgroundImage(self, viewportBGImageView, layer=1) ->
        hou.GeometryViewportBackground

            Access the background image parameters for the target view type.
            layer is currently not used but reserved for future use.

          * hou.viewportBGImageView.Perspective:

                The 3D view not attached to a camera (No cam).

          * hou.viewportBGImageView.Camera:

                The 3D view looking through a camera.

          * hou.viewportBGImageView.Top:

                The orthographic top view.

          * hou.viewportBGImageView.Front:

                The orthographic front view.

          * hou.viewportBGImageView.Right:

                The orthographic right view.

          * hou.viewportBGImageView.Bottom:

                The orthographic bottom view.

          * hou.viewportBGImageView.Back:

                The orthographic back view.

          * hou.viewportBGImageView.Left:

                The orthographic left view.

          * hou.viewportBGImageView.UV:

                The UV texture viewport.


        """
    def setDisplayBackgroundImage(self, enable: bool) -> None:
        """

        setDisplayBackgroundImage(self, enable)

            Globally enable background image display.


        """
    def displayBackgroundImage(self) -> bool:
        """

        displayBackgroundImage(self) -> bool

            Query if background image display is globally enabled.


        """
    def setDisplayEnvironmentBackgroundImage(self, enable: bool) -> None:
        """

        setDisplayEnvironmentBackgroundImage(self, enable)

            Allow environment lights to show their environment maps as 360
            degree background images.


        """
    def displayEnvironmentBackgroundImage(self) -> bool:
        """

        displayEnvironmentBackgroundImage(self) -> bool

            Query if environment lights' environment maps are shown as 360
            degree background images.


        """
    def setFilterBackgroundImage(self, enable: bool) -> None:
        """

        setFilterBackgroundImage(self, enable)

            Enable texture filtering of background images. When off, individual
            pixels are shown as blocks at high zoom levels rather than blended.


        """
    def filterBackgroundImage(self) -> bool:
        """

        filterBackgroundImage(self) -> bool

            Query if texture filtering of background images is enabled.


        """
    def setApplyZoomToBackgroundImage(self, enable: bool) -> None:
        """

        setApplyZoomToBackgroundImage(self, enable)

            Allow the camera zoom to affect the background image.


        """
    def applyZoomToBackgroundImage(self) -> bool:
        """

        applyZoomToBackgroundImage(self) -> bool

            Query if the camera zoom is affecting the background image.


        """
    def setBackgroundImageQuality(self, quality: int) -> None:
        """

        setBackgroundImageQuality(self, quality)

            Set the quality of the background image, from 0-100. Values less
            than 100 will scale down the resolution of the background image.


        """
    def backgroundImageQuality(self) -> int:
        """

        backgroundImageQuality(self) -> int

            Query the quality of background image display, from 0-100.


        """
    def setDisplayTextures(self, enable: bool) -> None:
        """

        setDisplayTextures(self, enable)

            Enable material texturing.


        """
    def displayTextures(self) -> bool:
        """

        displayTextures(self) -> bool

            Query if material texturing is enabled.


        """
    def setDisplayTextureLayers(self, enable: bool) -> None:
        """

        setDisplayTextureLayers(self, enable)

            Enable multiple texture layers when texturing. This causes an extra
            render of the geometry per texture layer.


        """
    def displayTextureLayers(self) -> bool:
        """

        displayTextureLayers(self) -> bool

            Query if multiple texture layers are rendered.


        """
    def setDisplayProjectedTextures(self, enable: bool) -> None:
        """

        setDisplayProjectedTextures(self, enable)

            Enable projected textures from spotlights with a valid texture.


        """
    def displayProjectedTextures(self) -> bool:
        """

        displayProjectedTextures(self) -> bool

            Query if projected textures from spotlights are rendered.


        """
    def setTextureMipmapping(self, enable: bool) -> None:
        """

        setTextureMipmapping(self, enable)

            Enable mipmapping for textures, improving display quality but
            increasing texture memory use by 50%.


        """
    def textureMipmapping(self) -> bool:
        """

        textureMipmapping(self) -> bool

            Query if texture mipmapping is enabled.


        """
    def setTextureAnisotropicFilter(self, num_samples: int) -> None:
        """

        setTextureAnisotropicFilter(self, num_samples)

            Set the number of samples for anisotropic texture filtering. More
            samples produces better results for textures on polygons on an angle
            to the view direction.


        """
    def textureAnisotropicFilter(self) -> int:
        """

        textureAnisotropicFilter(self) -> int

            Query the number of samples used for anisotropic texture filtering.


        """
    def setTextureCacheSize(self, size_in_mb: int) -> None:
        """

        setTextureCacheSize(self, size_in_mb)

            Set the size of the texture cache, in megabytes. The viewport will
            use as much texture memory as it needs, even if it exceeds this
            level, but textures will be culled once they are no longer used to
            remain within this limit.


        """
    def textureCacheSize(self) -> int:
        """

        textureCacheSize(self) -> int

            Query the texture cache size, in megabytes.


        """
    def setTextureMaxMemory(self, size_in_mb: int) -> None:
        """

        setTextureMaxMemory(self, size_in_mb)

            Set the maximum size of a single texture, in megabytes. This
            prevents extremely large textures from starving the graphics
            hardware's bandwidth (mostly by 3D textures).


        """
    def textureMaxMemory(self) -> int:
        """

        textureMaxMemory(self) -> int

            Return the maximum size of a single texture, in megabytes.


        """
    def setTextureAutoReduce(self, enable: bool) -> None:
        """

        setTextureAutoReduce(self, enable)

            Enable auto-reduction of viewport textures. This attempts to scale
            down textures to fit within the texture cache.


        """
    def textureAutoReduce(self) -> bool:
        """

        textureAutoReduce(self) -> bool

            Query if auto-reduction of viewport textures is enabled.


        """
    def setTextureAutoReduce2D(self, enable: bool) -> None:
        """

        setTextureAutoReduce2D(self, enable)

            Allow auto-reduction of regular 2D textures.


        """
    def textureAutoReduce2D(self) -> bool:
        """

        textureAutoReduce2D(self) -> bool

            Query if auto-reduction of regular 2D textures is allowed.


        """
    def setTextureAutoReduce3D(self, enable: bool) -> None:
        """

        setTextureAutoReduce3D(self, enable)

            Allow auto-reduction of 3D textures (volumes).


        """
    def textureAutoReduce3D(self) -> bool:
        """

        textureAutoReduce3D(self) -> bool

            Query if auto-reduction of 3D textures is allowed.


        """
    def setTextureResLimit2D(self, enable: bool) -> None:
        """

        setTextureResLimit2D(self, enable)

            Limit the resolution of all 2D textures, so that the width and
            height cannot exceed the limit. Even if disabled, OpenGL has its own
            texture limits which will be applied (usually 8k or 16k).


        """
    def textureResLimit2D(self) -> bool:
        """

        textureResLimit2D(self) -> bool

            Query if 2D textures have their resolutions limited.


        """
    def setTextureMaxRes2D(self, res: Sequence[int]) -> None:
        """

        setTextureMaxRes2D(self, res)

            Set the maximum resolution of a 2D texture. res is an integer
            2-tuple of (width, height). OpenGL has its own limit, and setting
            this limit higher than that will have no effect. The image will be
            scaled to fit the limit if it exceeds it.


        """
    def textureMaxRes2D(self) -> Tuple[int, ...]:
        """

        textureMaxRes2D(self) -> 2-tuple of int

            Return the maximum resolution for a 2D texture.


        """
    def setTextureBitDepthLimit2D(self, viewportTextureDepth: EnumValue) -> None:
        """

        setTextureBitDepthLimit2D(self, viewportTextureDepth)

            Set the maximum bit depth for a 2D texture. Textures with a bit
            depth higher than this will be downconverted to this bit depth.
            Textures with an equal or lower bit depth will not be converted.

          * hou.viewportTextureDepth.Compressed8:

                Compressed, 8b SDR texture format. Smallest memory use.

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with care.


        """
    def textureBitDepthLimit2D(self) -> EnumValue:
        """

        textureBitDepthLimit2D(self) -> hou.viewportTextureDepth

            Query the maximum bit depth for a 2D texture.

          * hou.viewportTextureDepth.Compressed8:

                Compressed, 8b SDR texture format. Smallest memory use.

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with care.


        """
    def setTextureScale2D(self, scale: float) -> None:
        """

        setTextureScale2D(self, scale)

            Uniformly downscale all 2D textures by this fraction (default 1.0,
            no scale).


        """
    def textureScale2D(self) -> float:
        """

        textureScale2D(self) -> float

            Query the uniform scale applied to 2D textures.


        """
    def setTextureResLimit3D(self, enable: bool) -> None:
        """

        setTextureResLimit3D(self, enable)

            Limit the resolution of all 3D textures (volumes), so that the
            width, height, and depth cannot exceed the limit. Even if disabled,
            OpenGL has its own texture limits which will be applied (usually 2k
            or 8k).


        """
    def textureResLimit3D(self) -> bool:
        """

        textureResLimit3D(self) -> bool

            Query if 3D textures have their resolutions limited.


        """
    def setTexture2DSettingsFor3D(self, enable: bool) -> None:
        """

        setTexture2DSettingsFor3D(self, enable)

            When enabled, use all the 2D texture settings for 3D textures.


        """
    def texture2DSettingsFor3D(self) -> bool:
        """

        texture2DSettingsFor3D(self) -> bool

            Query if the 2D settings are used for 3D textures.


        """
    def setTextureMaxRes3D(self, res: Sequence[int]) -> None:
        """

        setTextureMaxRes3D(self, res)

            Set the maximum resolution of a 3D texture (volume). res is an
            integer 3-tuple of (width, height, depth). OpenGL has its own limit,
            and setting this limit higher than that will have no effect. The
            image will be scaled to fit the limit if it exceeds it.


        """
    def textureMaxRes3D(self) -> Tuple[int, ...]:
        """

        textureMaxRes3D(self) -> 3-tuple of int

            Query the maximum resolution of a 3D texture (volume).


        """
    def setTextureBitDepthLimit3D(self, viewportTextureDepth: EnumValue) -> None:
        """

        setTextureBitDepthLimit3D(self, viewportTextureDepth)

            Set the maximum bit depth for a 3D texture (volume). Textures with a
            bit depth higher than this will be downconverted to this bit depth.
            Textures with an equal or lower bit depth will not be converted. 3D
            textures do not support compressed formats.

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with care.


        """
    def textureBitDepthLimit3D(self) -> EnumValue:
        """

        textureBitDepthLimit3D(self) -> hou.viewportTextureDepth

            Query the maximum bit depth of a 3D texture (volume).

          * hou.viewportTextureDepth.Fixed8:

                8b SDR texture format. Good balance between memory and quality.

          * hou.viewportTextureDepth.HDR16:

                16b HDR texture format. Excellent dynamic range, but more memory
                use and slower texturing performance.

          * hou.viewportTextureDepth.FullHDR:

                32b HDR texture format. Extreme dynamic range, but very high
                memory use and slow texturing performance. Use with extreme
                care.


        """
    def setTextureScale3D(self, scale: float) -> None:
        """

        setTextureScale3D(self, scale)

            Uniformly downscale all 3D textures (volumes) by this fraction
            (default 1.0, no scale).


        """
    def textureScale3D(self) -> float:
        """

        textureScale3D(self) -> float

            Query the uniform scale applied to 3D textures (volumes).


        """
    def useMaterialStylesheets(self, enable: bool) -> None:
        """

        useMaterialStylesheets(self, enable)

            Enable evaluation of material stylesheets for viewport material
            assignment.


        """
    def usingMaterialStylesheets(self) -> bool:
        """

        usingMaterialStylesheets(self) -> bool

            Query if material stylesheet assignment is active.


        """
    def usePerPrimStylesheets(self, enable: bool) -> None:
        """

        usePerPrimStylesheets(self, enable)

            Enable evaluation of per-primitive stylesheets.


        """
    def usingPerPrimStylesheets(self) -> bool:
        """

        usingPerPrimStylesheets(self) -> bool

            Query if per-primitive stylesheets are evaluated.


        """
    def usePackedStylesheets(self, enable: bool) -> None:
        """

        usePackedStylesheets(self, enable)

            Enable assignment of material stylesheets to geometry within packed
            primitives.


        """
    def usingPackedStylesheets(self) -> bool:
        """

        usingPackedStylesheets(self) -> bool

            Query if material stylesheet assignments are applied to geometry
            within packed primitives.


        """
    def useMaterialOverrides(self, enable: bool) -> None:
        """

        useMaterialOverrides(self, enable)

            Allow material overrides from material stylesheets and the
            material_override attribute.


        """
    def usingMaterialOverrides(self) -> bool:
        """

        usingMaterialOverrides(self) -> bool

            Query if material overrides are being applied to material
            assignments.


        """
    def setSingleObjectMaterialLimit(self, num_materials: int) -> None:
        """

        setSingleObjectMaterialLimit(self, num_materials)

            Set the maximum number of material variations for a single object.


        """
    def singleObjectMaterialLimit(self) -> int:
        """

        singleObjectMaterialLimit(self) -> int

            Query the maximum number of material variations for a single object.


        """
    def setMaterialUpdate(self, viewportMaterialUpdate: EnumValue) -> None:
        """

        setMaterialUpdate(self, viewportMaterialUpdate)

            Set the material assignment update frequency.

          * hou.viewportMaterialUpdate.Always:

                Update assignments whenever needed.

          * hou.viewportMaterialUpdate.OffForPlayback:

                Update assignments whenever needed, but not during playback.

          * hou.viewportMaterialUpdate.Manual:

                Only update assignments when Update Materials is pressed.


        """
    def materialUpdate(self) -> EnumValue:
        """

        materialUpdate(self) -> hou.viewportMaterialUpdate

            Query the material assignment update frequency.

          * hou.viewportMaterialUpdate.Always:

                Update assignments whenever needed.

          * hou.viewportMaterialUpdate.OffForPlayback:

                Update assignments whenever needed, but not during playback.

          * hou.viewportMaterialUpdate.Manual:

                Only update assignments when Update Materials is pressed.


        """
    def setInteractiveMaterialUpdate(self, enable: bool) -> None:
        """

        setInteractiveMaterialUpdate(self, enable)

            Update materials when they are changed to reflect their new state.
            When disabled, Update Materials must be pressed manually for changes
            to be reflected in the viewport.


        """
    def interactiveMaterialUpdate(self) -> bool:
        """

        interactiveMaterialUpdate(self) -> bool

            Query if materials are updated when they change.


        """
    def updateMaterials(self) -> None:
        """

        updateMaterials(self)

            Manually update all materials and material assignments.


        """
    def setVisibleObjects(self, uv: str) -> None:
        """

        setVisibleObjects(self, uv)

            Set the mask for all visible objects in the viewport. Wildcards can
            be used.


        """
    def visibleObjects(self) -> str:
        """

        visibleObjects(self) -> str

            Query the current visible object mask.


        """
    def setRemoveBackfaces(self, enable: bool) -> None:
        """

        setRemoveBackfaces(self, enable)

            Cull polygons facing backwards instead of rasterizing them.


        """
    def removeBackfaces(self) -> bool:
        """

        removeBackfaces(self) -> bool

            Query if backwards facing polygons are culled.


        """
    def setHullsOnly(self, enable: bool) -> None:
        """

        setHullsOnly(self, enable)

            Draw only hulls for complex curves and surfaces like NURBS and
            Beziers.


        """
    def hullsOnly(self) -> bool:
        """

        hullsOnly(self) -> bool

            Query if only hulls are drawn for complex curves and surfaces.


        """
    def setDistanceBasedPackedCulling(self, enable: bool) -> None:
        """

        setDistanceBasedPackedCulling(self, enable)

            Enable culling of packed primitives when the polygon count of the
            visible objects in the frustum exceeds a certain amount, starting
            with the most distant.


        """
    def distanceBasedPackedCulling(self) -> bool:
        """

        distanceBasedPackedCulling(self) -> bool

            Query if packed primitive culling is enabled.


        """
    def setScenePolygonLimit(self, millions_of_polygons: int) -> None:
        """

        setScenePolygonLimit(self, millions_of_polygons)

            Set the maximum number of polygons in the view frustum, in millions,
            before the viewport begins culling packed primitives.


        """
    def scenePolygonLimit(self) -> int:
        """

        scenePolygonLimit(self) -> int

            Query the maximum allowed number of polygons in the view frustum, in
            millions of polygons.


        """
    def setPackedBoundingBoxMode(self, viewportPackedBoxMode: EnumValue) -> None:
        """

        setPackedBoundingBoxMode(self, viewportPackedBoxMode)

            Define how culled packed primitives are displayed.

          * hou.viewportPackedBoxMode.NoDisplay:

                Culled packed primitives are not displayed at all.

          * hou.viewportPackedBoxMode.Wireframe:

                A wireframe bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.Shaded:

                A shaded bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.CurrentShadingMode:

                A bounding box replaces the packed primitive, drawn wireframe in
                wireframe shading modes and shaded otherwise.


        """
    def packedBoundingBoxMode(self) -> EnumValue:
        """

        packedBoundingBoxMode(self) -> hou.viewportPackedBoxMode

            Query how culled packed primitives are displayed.

          * hou.viewportPackedBoxMode.NoDisplay:

                Culled packed primitives are not displayed at all.

          * hou.viewportPackedBoxMode.Wireframe:

                A wireframe bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.Shaded:

                A shaded bounding box replaces the packed primitive.

          * hou.viewportPackedBoxMode.CurrentShadingMode:

                A bounding box replaces the packed primitive, drawn wireframe in
                wireframe shading modes and shaded otherwise.


        """
    def setOptimizeGeometry(self, enable: bool) -> None:
        """

        setOptimizeGeometry(self, enable)

            Optimize packed geometry when loaded to make it faster for display
            (triangulating and splitting meshes).


        """
    def optimizeGeometry(self) -> bool:
        """

        optimizeGeometry(self) -> bool

            Query if packed geometry is optimized.


        """
    def setAgentLODReduction(self, enable: bool) -> None:
        """

        setAgentLODReduction(self, enable)

            Enable the use of multiple levels of detail for crowd agents, each
            LOD level being half the polygon count of the previous level.


        """
    def agentLODReduction(self) -> bool:
        """

        agentLODReduction(self) -> bool

            Query if multiple levels of detail (LOD) are generated for crowd
            agents.


        """
    def setAgentLODReductionBias(self, reduce_bias: int) -> None:
        """

        setAgentLODReductionBias(self, reduce_bias)

            Set the LOD balance from Performance (0) to Quality (10), which
            biases which LOD levels are chosen.


        """
    def agentLODReductionBias(self) -> int:
        """

        agentLODReductionBias(self) -> int

            Query the LOD bias for agents.


        """
    def setAgentShapePointCutoff(self, num_points: int) -> None:
        """

        setAgentShapePointCutoff(self, num_points)

            Set the minimum number of points in an agent LOD level. If an LOD
            level would go below this number, it is not generated.


        """
    def agentShapePointCutoff(self) -> int:
        """

        agentShapePointCutoff(self) -> int

            Query the minimum number of points in an agent LOD level.


        """
    def setMaxLODLevels(self, num_levels: int) -> None:
        """

        setMaxLODLevels(self, num_levels)

            Set the maximum number of levels to generate for an agent. This will
            be the original model plus this number.


        """
    def maxLODLevels(self) -> int:
        """

        maxLODLevels(self) -> int

            Query the maximum number of levels generated for an agent.


        """
    def setBaseLODLevel(self, base_level: int) -> None:
        """

        setBaseLODLevel(self, base_level)

            Set the level to use as the full level of detail model, generally 0
            (the original agent model). For very heavy poly count agents, this
            can be set to higher values to reduce the polygon count of the
            highest level of detail model.


        """
    def baseLODLevel(self) -> int:
        """

        baseLODLevel(self) -> int

            Query the base level of detail.


        """
    def setSingleBoneDeform(self, viewportAgentBoneDeform: EnumValue) -> None:
        """

        setSingleBoneDeform(self, viewportAgentBoneDeform)

            Set the complexity of bone-based deformation on agents.

          * hou.viewportAgentBoneDeform.Always:

                Only use 1 bone to deform on all agent instances (the one with
                the most influence).

          * hou.viewportAgentBoneDeform.ReducedLOD:

                Use up to 4 bones to deform the highest LOD agent instances, and
                1 bone on all the reduced LOD instances.

          * hou.viewportAgentBoneDeform.Disabled:

                Use up to 4 bones to deform on all agent instances.


        """
    def singleBoneDeform(self) -> EnumValue:
        """

        singleBoneDeform(self) -> hou.viewportAgentBoneDeform

            Query the complexity of bone-based deformation on agents.

          * hou.viewportAgentBoneDeform.Always:

                Only use 1 bone to deform on all agent instances (the one with
                the most influence).

          * hou.viewportAgentBoneDeform.ReducedLOD:

                Use up to 4 bones to deform the highest LOD agent instances, and
                1 bone on all the reduced LOD instances.

          * hou.viewportAgentBoneDeform.Disabled:

                Use up to 4 bones to deform on all agent instances.


        """
    def setAgentWireframe(self, viewportAgentWireframe: EnumValue) -> None:
        """

        setAgentWireframe(self, viewportAgentWireframe)

            Set the appearance of agents in wireframe mode.

          * hou.viewportAgentWireframe.Bone:

                Agents are rendered as bone-based skeletons.

          * hou.viewportAgentWireframe.Line:

                Agents are rendered as line-based skeletons.


        """
    def agentWireframe(self) -> EnumValue:
        """

        agentWireframe(self) -> hou.viewportAgentWireframe

            Query the appearance of agents in wireframe mode.

          * hou.viewportAgentWireframe.Bone:

                Agents are rendered as bone-based skeletons.

          * hou.viewportAgentWireframe.Line:

                Agents are rendered as line-based skeletons.


        """
    def setAgentBlendShapes(self, enable: bool) -> None:
        """

        setAgentBlendShapes(self, enable)

            Enable the display of blend shapes for crowd agents.


        """
    def agentBlendShapes(self) -> bool:
        """

        agentBlendShapes(self) -> bool

            Query if blend shape display is enabled for crowd agents.


        """

class GeometryViewportBackground:
    """

    hou.GeometryViewportBackground

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def setImageFile(self, file_path: str) -> None:
        """

        setImageFile(self, file_path)

            Set the filename of the background image and set the background
            source to 'File'.


        """
    def imageFile(self) -> str:
        """

        imageFile(self) -> str

            Query the filename of the background image.


        """
    def setImageCOP(self, op_path: str) -> None:
        """

        setImageCOP(self, op_path)

            Set the path to the Composite operator defining the background image
            and set the background source to 'COP'.


        """
    def imageCOP(self) -> str:
        """

        imageCOP(self) -> str

            Query the operation path of the background image.


        """
    def sourceFromCOP(self, use_cop: bool) -> None:
        """

        sourceFromCOP(self, use_cop)

            Fetch the background image from a composite operator instead of a
            disk file. If False, a disk file is used.


        """
    def isCOPSource(self) -> bool:
        """

        isCOPSource(self) -> bool

            Query if the background image is sourced from a composite operator.


        """
    def isFileSource(self) -> bool:
        """

        isFileSource(self) -> bool

            Query if the background image is sourced from a disk file.


        """
    def setImageSource(self, file_or_op_path: str) -> None:
        """

        setImageSource(self, file_or_op_path)

            Set the file or cop path, depending on the current background image
            source.


        """
    def imageSource(self) -> str:
        """

        imageSource(self) -> str

            Query the file or cop path, depending on the current background
            image source.


        """
    def setEnvironmentMap(self, enable: bool) -> None:
        """

        setEnvironmentMap(self, enable)

            Draw the background image as a 360 degree environment map, or a
            regular 2D image if set to False.


        """
    def isEnvironmentMap(self) -> bool:
        """

        isEnvironmentMap(self) -> bool

            Query if the background image is drawn as 360 degree environment
            map..


        """
    def setAutoPlace(self, enable: bool) -> None:
        """

        setAutoPlace(self, enable)

            Automatically fit the background image to the viewport. If False,
            use the manual offset and scale to position the image.


        """
    def autoPlace(self) -> bool:
        """

        autoPlace(self) -> bool

            Query if the background image is automatically fit to the viewport.


        """
    def setImageFitMode(self, mode: EnumValue) -> None:
        """

        setImageFitMode(self, mode)

            Sets how the auto-placed background image is fit to the viewport.


        """
    def imageFitMode(self) -> EnumValue:
        """

        imageFitMode(self) -> hou.geometryViewportBackgroundImageFitMode

            Queries how the auto-placed background image is fit to the viewport.


        """
    def setImageOffset(self, offset: Sequence[float]) -> None:
        """

        setImageOffset(self, offset)

            Set the background image offset, which is a 2-tuple of float. The
            values should be in the 0-1 range, representing fractions of the
            viewport width and height.


        """
    def imageOffset(self) -> Tuple[float, ...]:
        """

        imageOffset(self) -> tuple of float

            Query the background image offset.


        """
    def setImageScale(self, scale: Sequence[float]) -> None:
        """

        setImageScale(self, scale)

            Set the background image scale, which is a 2-tuple of float. The
            values should be in the 0-1 range, representing fractions of the
            viewport width and height.


        """
    def imageScale(self) -> Tuple[float, ...]:
        """

        imageScale(self) -> tuple of float

            Query the background image scale.


        """
    def setOpacity(self, opacity: float) -> None:
        """

        setOpacity(self, opacity)

            Set the opacity of the background image. A value of 1 makes it fully
            opaque, and smaller values turn it more transparent.


        """
    def opacity(self) -> float:
        """

        opacity(self) -> float

            Query the opacity of the background image.


        """
    def setBrightness(self, intensity: float) -> None:
        """

        setBrightness(self, intensity)

            Set the intensity multiplier of the background image. A value of 1
            keeps it at its original intensity, and values less than that dim
            it.


        """
    def brightness(self) -> float:
        """

        brightness(self) -> float

            Query the intensity multiplier of the background image.


        """

class _GUDetailHandle:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isFrozen(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def destroy(self) -> None: ...

class Handle:
    """

    hou.Handle

    Gives access to an handle bound to a viewer state.

    OVERVIEW

        The Handle class lets you manipulate handles bound to viewer states.


    """
    thisown: Incomplete
    def __init__(self, scene_viewer: PaneTab, name: str) -> None:
        '''

        __init__(self, scene_viewer, name)

            Creates an object for accessing a handle of a given name. hou.Handle
            is typically used with python viewer states.


            WARNING
                Handle objects are typically created from a python viewer state
                constructor. However, calling methods on Handle objects must be
                done once the state has been entered, exceptions will be raised
                otherwise.


            scene_viewer
                A hou.SceneViewer object referencing the scene viewer where the
                handle is going to be used. Exception is thrown if the scene
                viewer is not compatible.

            name
                A string to identify the handle object. The name corresponds to
                the handle\'s name used at binding time. See
                hou.ViewerStateTemplate.bindHandle or
                hou.ViewerStateTemplate.bindStaticHandle for details.

          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >         self.handle = hou.Handle(scene_viewer, \\"Transform\\")
          > 
          > # Create a template to describe the state and its bindings
          > template = hou.ViewerStateTemplate(\\"mystate\\", \\"My Custom State\\", hou.sopNodeTypeCategory())
          > template.bindFactory(MyState)
          > template.bindHandle(\\"xform\\", \\"Transform\\")

        '''
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self): -> string

            The name of this handle.


        """
    def label(self) -> str:
        """

        label(self): -> string

            The label of this handle for UI display purposes.


        """
    def type(self) -> str:
        """

        type(self): -> string

            Returns the type name of the handle. The return value corresponds to
            the type used for binding the handle. See
            hou.ViewerStateTemplate.bindHandle or
            hou.ViewerStateTemplate.bindStaticHandle for details.


        """
    def show(self, value: bool) -> None:
        """

        show(self, value)

            Shows or hides the handle.


            value
                Bool value, True to show the handle, False to hide it.


        """
    def update(self, immediate: bool = False, node_update: bool = False, force_update: bool = False) -> None:
        """

        update(self, immediate, node_update=False, force_update=False)

            Updates the handle if the value in any of its parameters has
            changed. Useful if a change made to a viewer state requires one of
            its handle to get updated. For dynamic handles, this will trigger a
            call to the onStateToHandle callback, allowing the viewer state to
            update the proper handle parameter(s).


            immediate
                Controls when the update is performed. If False, the update is
                delayed until Houdini is on idle. If True, the update is
                performed immediately. Defaults to False.

            node_update
                Calling update updates the handle parms by default. Set
                node_update to True to update the state node parms bound to the
                handle instead.


                NOTE
                    This flag is supported for python viewer handles only.


                force_update
                    Forces the underlying handle to update (default to False).
                    Typically used with HUD handles to refresh their UI.


                NOTE
                    This flag is supported for python viewer handles only.


        """
    def visible(self) -> bool:
        """

        visible(self): -> bool

            Returns True if the handle is visible, False otherwise.


        """
    def enableParms(self, parm_names: Sequence[str]) -> None:
        """

        enableParms(self, parm_names)

            Dynamically enables the parms of this handle specified with
            parm_names. If handle_parms is empty (default), all handle parms are
            enabled.

            Raises exception if the handle is not bound dynamically to a viewer
            state.


            NOTE
                Some handles like xform may not display its components right
                away when enabled. This can happen if the components were
                previously disabled. For instance, disabling the rotation
                (rx,ry,rz) and re-enabling it again will not restore the
                previous rotate mode to display the rotation knobs. Restoring
                the rotate mode must rather be achieved by cycling the Y key or
                by calling hou.Handle.applySetting.

            See also hou.Handle.disableParms.


            parm_names
                A list of names specifying the handle parms to enable.
                parm_names must contain the handle parm names as described here.
                Exception is raised if parm_names contains unknown parm names.


        """
    def disableParms(self, parm_names: Sequence[str]) -> None:
        """

        disableParms(self, parm_names)

            This method does the opposite of hou.Handle.enableParms and
            dynamically disables the handle parms specified in parm_names. If
            handle_parms is empty (default), all handle parms are disabled.

            Raises exception if the handle is not bound dynamically to a viewer
            state.


            parm_names
                A list of names specifying the handle parms to disable.
                parm_names must contain the handle parm names as described here.
                Exception is raised if parm_names contains unknown parm names.


        """
    def applySettings(self, settings: str) -> None:
        """

        applySettings(self, settings)

            Apply one or more settings to this handle.


            settings
                A string containing the handle specific settings. Multiple
                settings must be space separated.


        """
    def settingValue(self, setting_name: str) -> Any:
        """

        settingValue(self, setting_name) -> value

            Return the value of a setting parameter bound to this handle.


            setting_name
                The name of the setting to retrieve.


        """
    def makePersistent(self, value: bool) -> None:
        """

        makePersistent(self, value)

            Turns this handle to a persistent handle to make it visible when the
            node's handle is not selected.


            value
                If True, the handle is set as a persistent handle. If False, the
                handle is set to non-persistent and will only be visible when
                the node is selected.


                NOTE
                    HUD handles, like HUD handles for parameters, are deleted
                    and removed from the viewer if value is False.


        """
    def isPersistent(self) -> bool:
        """

        isPersistent(self): -> bool

            Returns True if the handle is a persistent handle, False otherwise.


        """
    def isValid(self) -> bool:
        """

        isValid(self): -> bool

            Returns True if the handle has been created properly, False
            otherwise.


        """
    def isActive(self) -> bool:
        """

        isActive(self): -> bool

            Returns True if the handle has been activated, False otherwise. This
            method indicates the handle has been initialized and activated by
            the current state.


        """
    def parmPaths(self) -> Tuple[str, ...]:
        """

        parmPaths(self): -> list of string

            Returns all parm paths mapped to this handle. A parm path is useful
            for creating a hou.Parm object.


        """
    def isDynamic(self) -> bool:
        """

        isDynamic(self): -> bool

            Returns True if the handle is bound to a python state dynamically.


        """
    def info(self) -> str:
        """

        info(self): -> string

            Returns a JSON dictionary string representing the python handle
            definition for this handle. Returns an empty string if the
            underlying handle type is not a python handle.

            See also hou.ui.viewerHandleInfo


        """
    def nodePath(self, index: int = 0) -> str:
        """

        nodePath(self, index): -> string

            Returns the node path for this handle.


            index
                The node index. Defaults to 0.


        """
    def makeAsDefault(self) -> None:
        """

        makeAsDefault(self)

            Make the current handle parms values the new default for the
            underlying handle type.


        """
    def revertToDefault(self) -> None:
        """

        revertToDefault(self)

            Set the current handle parms values with the handle default values.


        """
    def revertToFactoryDefault(self) -> None:
        """

        revertToFactoryDefault(self)


            Set the current handle parms values with the parms default values of
            the node definition. NOTE
                This method overwrites the current handle parms default values
                as well.


        """
    def exportToHDA(self) -> None:
        """

        exportToHDA(self)

            Adds the handle and its parms to the currently open digital asset
            editor.


        """
    def exportParmsToHDA(self) -> None:
        """

        exportParmsToHDA(self)

            Adds the handle parms to the currently open digital asset editor.


        """
    def beginUndo(self) -> None:
        """

        beginUndo(self)

            Opens an undo block to perform undoable operations with the
            underlying handle. All operations performed after


        """
    def endUndo(self) -> None:
        """

        endUndo(self)

            Closes an undo block previously opened with hou.Handle.beginUndo.


        """
    def detach(self) -> None:
        """

        detach(self)

            Places the handle in a detached mode. When in this mode, the
            handle's position and orientation can be manipulated independently
            without updating its bound parameters.

            This method toggles the handle's detached state. If the handle is
            currently detached, calling this method will re-attach it;
            otherwise, it will be detached.

            This functionality is applicable to handles that support detachment,
            such as xform and sidefx_transform2d handles.


        """
    def attach(self) -> None:
        """

        attach(self)

            Re-attaches the handle if it is currently in detached mode.


        """
    def isDetached(self) -> bool:
        """

        isDetached(self)

            Returns True if the handle is in detached mode; otherwise, returns
            False.


        """
    def isDetachable(self) -> bool:
        """

        isDetachable(self)

            Returns True if the handle can be detached; otherwise, returns
            False. Handles are not detachable by default.


        """

class hda:
    """

    hou.hda

    Module containing functions related to Houdini Digital Assets.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def installFile(file_path: str, oplibraries_file: Optional[str] = None, change_oplibraries_file: bool = True, force_use_assets: bool = False) -> None:
        """

        installFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True, force_use_assets=False)

            Install all the node types defined in an hda file into the current
            Houdini session. This function is equivalent to File > Install
            Digital Asset Library... in Houdini.


            file_path
                The hda file to load.

            oplibraries_file
                The path to an OPlibraries file or None. OPlibraries files are
                text files containing lists of hda files to load on startup.
                When Houdini starts up it reads all the OPlibraries files it
                finds in the Houdini path and loads all the hda files listed in
                them. By creating OPlibraries files in $HOME/houdiniX.Y,
                $HSITE/houdiniX.Y, $JOB, etc. you can create libraries that are
                specific to a particular user, studio, job, etc.

                This parameter is only meaningful when change_oplibraries_file
                is True.

                Note that OPlibraries are only used when the Use OPlibraries
                files to find HDAS checkbox in the Configuration tab of the
                Operator Type Manager is checked.

                If None or Current HIP File, the hda file is loaded only into
                the current Houdini session. The file name will also be saved in
                the Hip file so that when the same Hip file is loaded, the hda
                file will also be loaded automatically.

                If Scanned Asset Library Directories, this is equivalent to the
                installation menu entry in the Install Digital Asset Library
                dialog.

            change_oplibraries_file
                When oplibraries_file is not None and this parameter is True,
                Houdini will modify the OPlibraries file, adding the hda file to
                it.

            force_use_assets
                When True, ensure that the definitions inside the hda file are
                current. If they would not otherwise provide the current
                definition, they are marked as preferred to ensure they are
                current. See hou.HDADefinition.isPreferred for more information.

            Note that, if you do not store the path to the hda file in an
            OPlibraries file, Houdini will store it in the current Houdini
            session. So, when you load a hip file, it will try to load the hda
            files that it references.


        """
    @staticmethod
    def uninstallFile(file_path: str, oplibraries_file: Optional[str] = None, change_oplibraries_file: bool = True) -> None:
        '''

        uninstallFile(file_path, oplibraries_file=None,
        change_oplibraries_file=True)

            Uninstall an hda file and all the node type definitions it provides
            from the current Houdini session. The hda file and its contents on
            disk are unchanged.

            You can set file_path to the special name \\"Embedded\\" to refer to the
            digital assets embedded in the current hip file. The following
            example removes any embedded digital asset definitions from the
            current Houdini session:

          > hou.hda.uninstallFile(\\"Embedded\\")

            If oplibraries_file is not None and change_oplibraries_file is True,
            Houdini will remove the path to the hda from the specified
            OPlibraries file. See hou.hda.installFile for more information about
            these parameters.

            If all the definitions of a node type are uninstalled, any instances
            of that node type will warn that they are using an incomplete asset
            definition. They will, however, retain their parameter values as
            spare parameters. Installing an hda file with the missing node type
            will restore those node instances and remove the warnings.

            See also hou.HDADefinition.destroy.


        '''
    @staticmethod
    def installFiles(file_paths: Sequence[str], oplibraries_file: Optional[str] = None, change_oplibraries_file: bool = True, force_use_assets: bool = False) -> None:
        """

        installFiles(file_paths, oplibraries_file=None,
        change_oplibraries_file=True, force_use_assets=False)

            Batch install all the node types defined in the list of hda files
            into the current Houdini session. This function is equivalent to
            File > Install Digital Asset Library... in Houdini.


            file_paths
                The list of hda files to install.

            See hou.hda.installFile for more information about installing files.


        """
    @staticmethod
    def uninstallFiles(file_paths: Sequence[str], oplibraries_file: Optional[str] = None, change_oplibraries_file: bool = True) -> None:
        """

        uninstallFiles(file_paths, oplibraries_file=None,
        change_oplibraries_file=True)

            Batch uninstall a list of hda file and all the node type definitions
            it provides from the current Houdini session. The hda files and
            their contents on disk are unchanged.


            file_paths
                The list of hda files to uninstall.

            See hou.hda.uninstallFile for more information about uninstalling
            files.

            See also hou.HDADefinition.destroy.


        """
    @staticmethod
    def reloadFiles(file_paths: Sequence[str]) -> None:
        """

        reloadFiles(file_paths)

            Batch reload the contents of a list of hda file, loading any updated
            digital asset definitions inside them.

            You only need to call this function if the hda files were modified
            from outside the current Houdini session.


            file_paths
                The list of hda files to reload.

            See also hou.hda.reloadFile.


        """
    @staticmethod
    def reloadFile(file_path: str) -> None:
        """

        reloadFile(file_path)

            Reload the contents of an hda file, loading any updated digital
            asset definitions inside it.

            You only need to call this function if an hda file was modified from
            outside the current Houdini session.


        """
    @staticmethod
    def reloadAllFiles(rescan: bool = True) -> None:
        """

        reloadAllFiles(rescan=True)

            Reload the digital asset files and update asset definitions in the
            current session.

            If the rescan is true, Houdini will check the hda directories for
            any new hda files and load them too.

            See also hou.hda.reloadFile.


        """
    @staticmethod
    def reloadNamespaceOrder() -> None:
        """

        reloadNamespaceOrder()

            Check HOUDINI_OPNAMESPACE_HIERARCHY environment variable and rebuild
            the node type preference order that determines the node type to use
            when only unqualified root name is used in scripts, or, when Tab
            menu settings specify to show only a single preferred entry among
            several potential choices from different namespaces.


        """
    @staticmethod
    def expandToDirectory(file_path: str, directory_path: str) -> None:
        """

        expandToDirectory(file_path, directory_path)

            Expand the contents of the hda file in file_path into the directory
            directory_path. If the directory does not already exist it is
            created.

            When expanding an hda file, Houdini puts each digital asset
            definition in the file into its own directory. As well, it puts each
            section inside a definition into its own file. Each directory inside
            the expanded file tree contains a Sections.List file that maps the
            actual file or directory names into the section names, since section
            names may contain characters that cannot occur in directory or file
            names. See hou.HDASection for more information about sections.

            This function provides an easy way to inspect and modify the
            contents of an hda file. See also hou.hda.collapseFromDirectory.


        """
    @staticmethod
    def collapseFromDirectory(file_path: str, directory_path: str) -> None:
        """

        collapseFromDirectory(file_path, directory_path)

            Given a directory that contains a previously expanded hda file,
            collapse it into the hda file specified by file_path.

            This function provides the inverse of hou.hda.expandToDirectory.


        """
    @staticmethod
    def loadedFiles() -> Tuple[str, ...]:
        """

        loadedFiles() -> tuple of str

            Return a tuple of paths to the hda files that are loaded into the
            current Houdini session.

            This method is can be approximately implemented as follows:

          > def loadedFiles():
          >     '''Return a list of hda files loaded into this Houdini session.'''
          >     # Look through all the node types, and for those that have digital
          >     # asset definitions, remember the hda file containing the definition.
          >     result = []
          >     for category in hou.nodeTypeCategories().values():
          >         for node_type in category.nodeTypes().values():
          >             definition = node_type.definition()
          >             if definition is None:
          >                 continue
          >             if definition.libraryFilePath() not in result:
          >                 result.append(definition.libraryFilePath())
          >     return result

            See hou.HDADefinition.isCurrent for an example.


        """
    @staticmethod
    def renameSource(oplibraries_file: str, source_name: Optional[str] = None) -> None:
        """

        renameSource(oplibraries_file, source_name=None)

            Give a name to an OPlibraries file. This name appears in the
            Operator Type Manager's list of OPlibraries file. If source_name is
            None, the name is removed from the OPlibraries file.

            If the oplibraries_file does not already exist, it is created.

            See hou.hda.installFile for more information about OPlibraries
            files.


        """
    @staticmethod
    def definitionsInFile(file_path: str) -> Tuple[HDADefinition, ...]:
        '''

        definitionsInFile(file_path) -> tuple of hou.HDADefinition

            Return all the digital asset definitions inside an hda file. See
            hou.HDADefinition for more information.

            Raises hou.OperationFailed if file_path does not refer to a valid
            hda file.

          > # Print the node types defined by digital assets in $HOME/houdiniX.Y/hda/OPcustom.hda:
          > >>> import os
          > >>> my_hda_file = \\"%s/hda/OPcustom.hda\\" % hou.homeHoudiniDirectory()
          > >>> for definition in hou.hda.definitionsInFile(my_hda_file):
          > ...     print definition.nodeTypeCategory().name() + \\"/\\" + definition.nodeTypeName()
          > Sop/gcoggeo
          > Sop/gCogFlatGeo
          > Sop/gDivideAtCentroid
          > Object/gAxle
          > Object/gCog

        '''
    @staticmethod
    def componentsFromFullNodeTypeName(node_type_name: str) -> Tuple[str, ...]:
        """

        componentsFromFullNodeTypeName(node_type_name) -> tuple of str

            Returns a tuple of operator type name components that constitute the
            full node type name. The components in the tuple appear in the
            following order: scope network type, node type namespace, node type
            core name, and version.

          > >>> # Parse the full name into components
          > >>> hou.hda.componentsFromFullNodeTypeName('MyUserNamespace::MyHDA::2.5')
          > ('', 'MyUserNamespace', 'MyHDA', '2.5')
          > >>> hou.hda.componentsFromFullNodeTypeName('Sop/foreach::MyCounterHDA')
          > ('Sop/foreach', '', 'MyCounterHDA', '')

        """
    @staticmethod
    def fullNodeTypeNameFromComponents(scope_node_type: str, name_space: str, name: str, version: str) -> str:
        """

        fullNodeTypeNameFromComponents(scope_node_type, name_space, name,
        version) -> str

            Returns a full node type name build out of the given components. The
            arguments represent the following components: scope network type,
            node type namespace, node type core name, and version.

          > >>> # Compose the node type full name from components
          > >>> hou.hda.fullNodeTypeNameFromComponents('', 'userA', 'sphere', '')
          > 'userA::sphere'
          > >>> hou.hda.fullNodeTypeNameFromComponents('', 'userB', 'myHda', '2.6')
          > 'userB::myHda::2.6'
          > >>> hou.hda.fullNodeTypeNameFromComponents('Sop/foreach', '', 'MyCounterHDA', '')
          > 'Sop/foreach::MyCounterHDA'

        """
    @staticmethod
    def changeCurrentStoreUser(new_user: str) -> None: ...
    @staticmethod
    def safeguardHDAs() -> bool:
        """

        safeguardHDAs() -> bool

            Return True if the Safeguard Operator Definitions configuration
            option is turned on. When safeguarding is turned on then no digital
            asset definition can be modified in the Houdini session.


        """
    @staticmethod
    def setSafeguardHDAs(on: bool) -> None:
        """

        setSafeguardHDAs(on)

            Set whether the Safeguard Operator Definitions configuration option
            should be turned on or off. The on argument must be either True of
            False.


        """
    @staticmethod
    def removeAllEventCallbacks() -> None:
        """

        removeAllEventCallbacks(self)

            Remove all event callbacks for all event types.

            See hou.hda.addEventCallback for more information.


        """
    @staticmethod
    def defaultFileExtension() -> str:
        """

        defaultFileExtension(self) -> str

            Returns the default hda file extension for the current session based
            on the taint.


        """
    @staticmethod
    def addEventCallback(event_types: Sequence[EnumValue], callback: Callable) -> None:
        '''

        addEventCallback(self, event_types, callback)

            Register a Python callback that Houdini will call whenever a
            particular action, or event, occurs with digital asset libraries.

            Callbacks only persist for the current session. For example, they
            are not saved to the .hip file. If you want persistent callbacks in
            every session, you can add them in code in pythonrc.py (runs on
            startup) or 456.py (runs when the user opens a .hip file). See where
            to add Python scripting for more information.


            event_types
                A sequence of hou.hdaEventType enumeration values describing the
                event types that will cause Houdini to call the callback
                function.

            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

                Houdini calls the function with an event_type keyword argument
                containing the hou.hdaEventType value corresponding to the event
                that triggered the callback.

                Houdini will pass additional keyword arguments depending on the
                event type. For example, in a callback for the LibraryInstalled
                or LibraryUninstalled events, Houdini will pass a library_path
                keyword argument containing the path of the .hda file that was
                installed or uninstalled. See hou.hdaEventType for the
                additional arguments passed for each event type.

                You can add **kwargs to the argument list to accept all keyword
                arguments, to allow the same callback to be used for different
                events, or to be safe from future changes:

              > def event_callback(event_type, **kwargs):
              >     ...

            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to an event. However, it may be useful to add the same
                function if you want to register it with different event_types.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            The following example shows to set up a function that\'s called
            whenever a new asset is added to Houdini:

          > 
          > def hda_event(event_type, asset_definition, **kwargs):
          >     label = asset_definition.description()
          >     library_path = asset_definition.libraryFilePath()
          >     print(\\"New asset %s in %s\\" % (label, library_path))
          > 
          > hou.hda.addEventCallback((hou.hdaEventType.AssetCreated, ), hda_event)

            See also hou.hda.removeEventCallback and
            hou.hda.removeAllEventCallbacks.


        '''
    @staticmethod
    def removeEventCallback(event_types: Sequence[EnumValue], callback: Callable) -> None:
        """

        removeEventCallback(self, event_types, callback)

            Given a callback that was previously added and a sequence of
            hou.hdaEventType enumerated values, remove those event types from
            the set of event types for the callback. If the remaining set of
            event types is empty, the callback will be removed entirely.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.hda.addEventCallback for more information.


        """
    @staticmethod
    def eventCallbacks() -> Tuple[Tuple[Tuple[EnumValue, ...], Any], ...]: ...

    # Missing methods added by stubgen
    @staticmethod
    def reloadHDAModule(hda_module: HDAModule) -> None: ...

class HDADefinition:
    """

    hou.HDADefinition

    Represents the definition of a houdini digital asset (HDA).

    A digital asset definition defines a node type and exists inside an hda
    file. The node type is implemented in terms of other nodes wired
    together inside a subnet. These nodes inside the subnet are called the
    definition's contents.

    An hda file contains one or more digital asset definitions, and
    installing an hda file installs all the definitions in the file. When a
    digital asset definition is installed, the node type it defines is added
    to Houdini. Note that you can access an HDADefinition without installing
    it.

    A digital asset's algorithm is determined by the nodes inside it. To
    edit those nodes you create an instance of the digital asset, unlock it,
    modify the contents, and save the definition. New digital asset
    instances are normally locked, meaning that they are read-only, and they
    automatically update when the asset's definition changes. An unlocked
    instance is editable, does not update when the definition changes, and
    you can save its contents to change the definition.

    To unlock a node, select Allow Editing of Contents or call
    hou.OpNode.allowEditingOfContents. To save the contents of an unlocked
    node to the definition, select Save Operator Type or call
    hou.HDADefinition.updateFromNode. To revert an unlocked instance back to
    the last saved definition and change it back into a locked instance,
    select Match Current Definition or call
    hou.OpNode.matchCurrentDefinition.

    See also hou.hda and hou.HDAOptions.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def nodeType(self) -> OpNodeType:
        """

        nodeType(self) -> hou.NodeType

            Return the node type defined by this digital asset. Raises
            hou.OperationFailed if the digital asset is not installed.


        """
    def nodeTypeCategory(self) -> OpNodeTypeCategory:
        """

        nodeTypeCategory(self) -> hou.NodeTypeCategory

            Return the node type category (e.g. Objects, SOPs, DOPs, etc.) for
            the node type defined by this digital asset. See
            hou.NodeTypeCategory for more information.

            It is safe to call this method if the digital asset is not
            installed. If the digital asset is installed, this method is
            equivalent to self.nodeType().category().


        """
    def nodeTypeName(self) -> str:
        """

        nodeTypeName(self) -> str

            Return the name of the node type defined by this digital asset.
            Raises hou.OperationFailed if the digital asset is not installed.

            If the digital asset is installed, this method is a shortcut for
            self.nodeType().name().


        """
    def libraryFilePath(self) -> str:
        '''

        libraryFilePath(self) -> str

            Return the path to the hda file containing the digital asset\'s
            definition.

            Note that it is possible to save an asset with a hip file, without
            storing it in an hda file. In this case, this method returns
            \\"Embedded\\".


        '''
    def embeddedHelp(self) -> str:
        """

        embeddedHelp(self) -> str

            Return the help text embedded in the digital asset. Return an empty
            string if no embedded help exists.

            Embedded help typically comes from the Help tab of the operator type
            properties window, but it may also come from a dialog script.


        """
    def isInstalled(self) -> bool:
        """

        isInstalled(self) -> bool

            Return whether this definition is installed in Houdini.

            It is possible to access HDADefinition objects in hda files that are
            not installed with hou.hda.definitionsInFile.

            See also hou.hda.installFile.


        """
    def installed(self) -> bool: ...
    def isCurrent(self) -> bool:
        '''

        isCurrent(self) -> bool

            Return whether this definition is the one currently in use by
            Houdini.

            This example shows how you can access other definitions for the same
            node type:

          > def otherDefinitions(definition):
          >     \'\'\'Given an HDADefinition object, return the other loaded definitions
          >        for the same node type.\'\'\'
          >     # Look through all the loaded hda files for definitions providing
          >     # the same node type.
          >     result = []
          >     for hda_file in hou.hda.loadedFiles():
          >         # Skip the hda file containing the definition that was passed in.
          >         if hda_file == definition.libraryFilePath():
          >             continue
          > 
          >         for other_definition in hou.hda.definitionsInFile(hda_file):
          >             if other_definition.nodeType() == definition.nodeType():
          >                 result.append(other_definition)
          >     return result
          > # Print the paths to hda files providing other definitions for a digital asset instance.
          > >>> for other_definition in otherDefinitions(hou.node(\\"/obj/my_hda1\\").type().definition()):
          > ...     print other_definition.libraryFilePath()
          > /path/to/file1.hda
          > /path/to/file2.hda

        '''
    def current(self) -> bool: ...
    def isPreferred(self) -> bool:
        """

        isPreferred(self) -> bool

            Return whether this definition is preferred.

            After loading hda files, Houdini uses a set of rules to resolve
            conflicts when it encounters multiple definitions for the same node
            type (e.g. preferring the most recent hda file, preferring
            definitions embedded in the hip file, etc.). When these rules do not
            use the definition you want, you can override them by explicitly
            marking a definition as preferred. Houdini saves this list of
            preferred definitions with the hip file. Marking a definition as not
            preferred will remove it from this list, and the normal rules will
            apply again.


        """
    def preferred(self) -> bool: ...
    def setIsPreferred(self, preferred: bool) -> None:
        """

        setIsPreferred(self, preferred)

            Set whether this definition is preferred. See
            hou.HDADefinition.isPreferred for more information.


        """
    def setPreferred(self, preferred: bool) -> None: ...
    def enableCreateBackups(self, create_backups: bool) -> None:
        """

        enableCreateBackups(self, create_backups)

            Sets whether or not backup files should be created each time the HDA
            is modified, e.g. if a section is added or removed, if the icon is
            changed, etc.


        """
    def isCreateBackupsEnabled(self) -> bool:
        """

        isCreateBackupsEnabled(self) -> bool

            Returns true if the HDA Definition creates backup files on disk when
            modified.


        """
    def sections(self) -> dict[str, HDASection]:
        """

        sections(self) -> dict of str to hou.HDASection

            Return a dictionary mapping section names to hou.HDASection objects.
            See hou.HDASection for more information on sections.


        """
    def hasSection(self, name: str) -> bool:
        """

        hasSection(self, name) -> bool

            Return True if the HDA definition contains a section with the
            specified name and False otherwise.

            See hou.HDASection for more information on sections.


        """
    def addSection(self, name: str, contents: str = ..., compression_type: EnumValue = ...) -> HDASection:
        '''

        addSection(self, name, contents=\\"\\",
        compression_type=hou.compressionType.NoCompression) -> hou.HDASection

            Create a new section with the specified contents. If a section
            already exists with this name, changes the existing contents to the
            new contents. Note that the contents may contain binary data. Also
            note that section names may contain \'/\'.

            You can optionally specify a compression type, hou.compressionType,
            to compress the contents. Note that you must specify the same
            compression type when reading the contents back to decompress them.

            For Python 3, the contents can be either a str object for plain text
            data or a bytes object for binary data.

            See hou.HDASection for more information on sections. To remove a
            section, use hou.HDASection.destroy.

            Sections can have associated properties stored in the
            hou.HDADefinition.extraFileOptions.

          > def addSectionFromFile(hda_definition, section_name, file_name):
          >     \'\'\'Add a section whose contents come from a file.  If the section
          >        already exists, replace its contents.\'\'\'
          >     section_file = open(file_name, \\"r\\")
          >     hda_definition.addSection(section_name, section_file.read())
          >     section_file.close()

        '''
    def removeSection(self, name: str) -> None:
        """

        removeSection(self, name)

            Remove an existing section. Only remove sections that you explicitly
            added. Do not remove the special sections that Houdini uses to store
            the contents of the digital asset definition, or Houdini will
            generate errors or strange side effects.

            See hou.HDASection for more information on sections. Note that
            hou.HDASection.destroy will also remove a section.

            Raises hou.OperationFailed if no such section exists in the
            definition.


        """
    def description(self) -> str:
        """

        description(self) -> str

            Return the description for this definition's node type. Houdini uses
            this description for user interface elements such as the TAB menu.
            This description is also called the operator label in Houdini.

            See also hou.NodeType.description.


        """
    def setDescription(self, label: str) -> None:
        """

        setDescription(self, description)

            Set the description for this definition's node type. Houdini uses
            this description for user interface elements such as the TAB menu.
            This description is also called the operator label in Houdini.

            See also hou.HDADefinition.description and hou.NodeType.description.


        """
    def icon(self) -> str:
        """

        icon(self) -> str

            Return the name or path of the icon for this definition's node type.
            Note that Houdini uses its search path to locate icons, so you do
            not need to pass in a full path.

            See also hou.NodeType.icon.


        """
    def setIcon(self, icon: str) -> None:
        """

        setIcon(self, icon)

            Set the icon for this definition's node type. See
            hou.HDADefinition.icon for more information.


        """
    def minNumInputs(self) -> int:
        """

        minNumInputs(self) -> int

            Return the minimum number of connected inputs that node instances of
            this digital asset can have. If these inputs are not connected, the
            node will generate an error.

            See also hou.NodeType.minNumInputs.


        """
    def setMinNumInputs(self, min_num_inputs: int) -> None:
        """

        setMinNumInputs(self, min_num_inputs)

            Set the minimum number of connected inputs that node instances of
            this digital asset must have. min_num_inputs must be between 0 and
            4, inclusive. If a node does not have the minimum number of inputs,
            it will generate an error.


        """
    def maxNumInputs(self) -> int:
        """

        maxNumInputs(self) -> int

            Return the maximum number of inputs that node instances of this
            digital asset can have. Return a number greater than 4 if this node
            type can accept an unlimited number of inputs.

            See also hou.NodeType.maxNumInputs.


        """
    def setMaxNumInputs(self, max_num_inputs: int) -> None:
        """

        setMaxNumInputs(self, max_num_inputs)

            Set the maximum number of inputs that node instances of this digital
            asset may have. This number must be greater than or equal to the
            minimum number of inputs. If it is 5 or greater, Houdini will use a
            merge SOP-style input connector that allows an unlimited number of
            inputs. Otherwise, the node will have between 0 and 4 input
            connectors, each of which may or may not be connected, that
            correspond to the subnet indirect inputs inside the digital asset.

            See hou.Node.inputConnectors and hou.SubnetIndirectInput for more
            information on input connectors and subnet indirect inputs.


        """
    def maxNumOutputs(self) -> int:
        """

        maxNumOutputs(self) -> int

            Return the maximum number of outputs that node instances of this
            digital asset can have.

            See also hou.NodeType.maxNumOutputs.


        """
    def setMaxNumOutputs(self, max_num_outputs: int) -> None:
        """

        setMaxNumOutputs(self, max_num_outputs)

            Set the maximum number of outputs that node instances of this
            digital asset may have.


        """
    def extraInfo(self) -> str:
        """

        extraInfoValue(self, key) -> str

            Return a string with the extra information item stored under known
            key key.

            See also hou.HDADefinition.extraInfo.


        """
    def setExtraInfo(self, extra_info: str) -> None:
        """

        setExtraInfo(self, extra_info)

            Set extra information about the asset definition that isn't stored
            elsewhere, like the representative node, guide geometry, etc. This
            string is encoded in a specific format, so it is recommended that
            you only call this method with values returned from
            hou.HDADefinition.extraInfo.


        """
    def extraInfoValue(self, key: str) -> str: ...
    def userInfo(self) -> str:
        """

        userInfo(self) -> str

            Return a string containing user specified information about the
            asset definition.


        """
    def setUserInfo(self, extra_info: str) -> None:
        """

        setUserInfo(self, extra_info)

            Set user information about the asset definition. This info isn't
            used by Houdini so it can contain any text.


        """
    def hideDefaultParameters(self) -> bool:
        """

        hideDefaultParameters(self) -> bool

            Return whether the parameters that are common to nodes types in this
            node type category are hidden or not. For example, nearly all
            objects have common translation, rotation, scale, etc. parameters,
            and object level digital assets have these parameters by default. If
            hidden, though, these parameters are still there but are not
            displayed to the user.

            Note that this value is also stored in the string returned by
            hou.HDADefinition.extraInfo.


        """
    def representativeNodePath(self) -> str:
        """

        representativeNodePath(self) -> str

            Return the contents of the Representative Node field on the Basic
            tab of the Type Properties dialog.

            For object-level digital assets that contain other object nodes, it
            is possible to make Houdini treat your digital asset like a camera
            or light by choosing a node inside the asset to represent it. For
            example, if you choose a camera inside the asset as the
            representative node, instances of the digital asset will appear in
            the viewport's list of camera objects.

            Note that this value is also stored in the string returned by
            hou.HDADefinition.extraInfo.


        """
    def comment(self) -> str: ...
    def setComment(self, comment: str) -> None: ...
    def version(self) -> str: ...
    def setVersion(self, version: str) -> None: ...
    def modificationTime(self) -> int:
        '''

        modificationTime(self) -> int

            Return the time when the definition was last modified. This time is
            returned as a POSIX timestamp, such as is returned by time.time().

          > >>> import time
          > >>> time.ctime(hou.nodeType(hou.objNodeTypeCategory(), \\"toon_character\\").
          > ...     definition().modificationTime())
          > \'Thu Nov  6 18:22:38 2008\'

        '''
    def setModificationTime(self, time: int = -1) -> None:
        """

        setModificationTime(self, time=-1)

            Set the modification time for the definition to the given POSIX
            timestamp. If the time parameter is negative, uses the current time.

            See also hou.HDADefinition.modificationTime.


        """
    def options(self) -> HDAOptions:
        """

        options(self) -> hou.HDAOptions

            Return a hou.HDAOptions object for the options stored in this
            digital asset. See hou.HDAOptions for more information.


        """
    def setOptions(self, options: HDAOptions) -> None:
        """

        setOptions(self, options)

            Set this digital asset definition's options to the data in a
            hou.HDAOptions object. See hou.HDAOptions for more information.


        """
    def updateFromNode(self, node: Node) -> None:
        '''

        updateFromNode(self, node)

            Update and save the definition to match the contents of a given
            unlocked instance of the asset. Calling this method is the same as
            selecting Save Operator Type on the node\'s menu.

          > def saveUnlockedNodes():
          >     \'\'\'Look through all the nodes in the file for unlocked digital asset
          >        instances and save and lock them.\'\'\'
          >     for node in hou.node(\\"/\\").allSubChildren():
          >         if node.type().definition() is None or node.matchesCurrentDefinition():
          >             continue
          > 
          >         node.type().definition().updateFromNode(node)
          >         node.matchCurrentDefinition()

        '''
    def save(self, file_name: str, template_node: Optional[Node] = None, options: Optional[HDAOptions] = None, black_box: bool = False, create_backup: bool = True) -> None:
        """

        save(self, file_name, template_node=None, options=None, black_box=False,
        create_backup=True)

            Save the definition into an hda file.


            file_name
                Where to save the definition. To save to the current hda file,
                use the return value from hou.HDADefinition.libraryFilePath.

            template_node
                Either None or a hou.OpNode object containing an unlocked
                instance of the digital asset that defines the definition's new
                contents. If None, this method does not update the definition's
                contents.

            options
                Either None or a hou.HDAOptions object that specifies extra
                behaviors of the definition. If template_node is not None, the
                compressContents, lockContents, saveSpareParms, and
                makeInitialParmsDefaults values of the hou.HDAOptions object are
                used. Otherwise, only the compressContents value is used.

            black_box
                If True, then the asset is saved as a black box asset that
                cannot be unlocked or edited. This parameter only applies if the
                template_node parameter is not None. The contents of the
                template node are compiled and saved into the black box asset.

            create_backup
                Create a backup before modifying existing hda files.

            See also hou.HDADefinition.updateFromNode for a way to save an
            unlocked node's definition to the current hda file. See also
            hou.HDADefinition.copyToHDAFile.


        """
    def copyToHDAFile(self, file_name: str, new_name: Optional[str] = None, new_menu_name: Optional[str] = None) -> None:
        """

        copyToHDAFile(self, file_name, new_name=None, new_menu_name=None)

            Copy this definition into an hda file.


            file_name
                The hda file where the definition will be saved. If the file
                does not already exist, it will be created. If it already
                contains a definition for this node type, it will be
                overwritten.

            new_name
                The new name of the node type. If None, the definition will be
                saved as the existing node type name. See also
                hou.NodeType.name.

            new_menu_name
                The new description of the node type that appears in the tab
                menu. If None, Houdini will use the existing description. Note
                that the node type name must be unique within the hda file, so
                saving the definition with a new description to an hda file
                containing a definition with the old node name will still
                overwrite the existing definition. See also
                hou.NodeType.description.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Uninstall this definition and delete it from the hda file. Any node
            instances of this asset will warn that they are using an incomplete
            asset definition.

            See also hou.hda.uninstallFile.


        """
    def parmTemplateGroup(self) -> ParmTemplateGroup:
        '''

        parmTemplateGroup(self) -> hou.ParmTemplateGroup

            Return the group of parm templates corresponding to the current
            parameter layout for this node.

            You can edit the parameter layout for this node (add or remove spare
            parameters, reorder or hide built-in parameters, etc.) by getting
            the current parameter group, modifying it, and calling
            hou.Node.setParmTemplateGroup with it.

            The following example creates a geometry object, adds a My Parms
            folder to it, and adds a My Parm float parameter to it in that
            folder. The parameters are added only to the geometry object
            created; other geometry objects are unaffected.

          > >>> node = hou.node(\\"/obj\\").createNode(\\"geo\\")
          > >>> group = node.parmTemplateGroup()
          > >>> folder = hou.FolderParmTemplate(\\"folder\\", \\"My Parms\\")
          > >>> folder.addParmTemplate(hou.FloatParmTemplate(\\"myparm\\", \\"My Parm\\", 1))
          > >>> group.append(folder)
          > >>> node.setParmTemplateGroup(group)

            See hou.ParmTemplateGroup and the setParmTemplateGroup method for
            more information and examples.


        '''
    def setParmTemplateGroup(self, parm_template_group: ParmTemplateGroup, rename_conflicting_parms: bool = False, create_backup: bool = True) -> None:
        """

        setParmTemplateGroup(self, parm_template_group,
        rename_conflicting_parms=False)

            Change the spare parameters for this node.


            parm_template_group
                A hou.ParmTemplateGroup object containing the new parameter
                layout.

            rename_conflicting_parms
                If True, parameters in the group with the same parm tuple names
                will be automatically renamed. If False and there are parms with
                the same name, this method raises hou.OperationFailed.

            Note that each node type has a set of parameters which must exist
            and must be of certain types. If your parm template group does not
            contain the required parameters for the node type the will be added
            at the bottom and will be made invisible. Similarly, if your parm
            template group attempts to modify the type, range, label, or other
            property of a required parameter, all changes to that parameter
            other than visibility settings will be ignored.

            This method is preferred over the other parameter-related methods in
            this class (addSpareParmTuple, removeSpareParmTuple,
            replaceSpareParmTuple, addSpareParmFolder, removeSpareParmFolder)
            because it lets you more easily make manipulate parameters.

            See hou.HDADefinition.setParmTemplateGroup to change the parameter
            interface of a digital asset.


        """
    def setExtraFileOption(self, name, value: OptionType, type_hint: EnumValue = ...) -> None:
        '''

        setExtraFileOption(self, name, value, type_hint =
        hou.fieldType::NoSuchField)

            Set an entry in the dictionary of extra file options. See
            hou.HDADefinition.extraFileOptions for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.

            The following example function marks an section, such as OnCreated,
            as containing Python code:

          > def markSectionAsPython(definition, section_name):
          >     definition.setExtraFileOption(section_name + \\"/IsPython\\", True)

        '''
    def removeExtraFileOption(self, name: str) -> None:
        """

        removeExtraFileOption(self, name)

            Remove an entry in the dictionary of extra file options. See
            hou.HDADefinition.extraFileOptions for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
    def compileCodeSection(self, source_section: str, destination_section: str) -> None:
        """

        compileCodeSection(self, source_section, destination_section)

            This function is deprecated. Compiled VEX code should no longer be
            stored inside of an HDA.


        """
    def tools(self) -> dict[str, Tool]:
        """

        tools() -> dict of str to hou.Tool

            Returns a dictionary mapping from the internal name of tool defined
            in definition's shelf section to a corresponding hou.Tool object.
            The dictionary does not contain tools that are defined elsewhere.


            NOTE
                If you only want to get a single tool by its internal name, use
                the hou.shelves.tool function. Using shelves.tool(name) is much
                faster that constructing this dictionary and then pulling a
                single tool out of it.


        """
    def extraFileOptions(self) -> dict[str, OptionType]:
        """

        extraFileOptions(self) -> dict of str to bool, int, float, str

            Return a dictionary containing the extra options attached to
            sections in the asset's definition. For example, event handler
            scripts such as OnCreated are stored as sections inside the asset,
            and extra metadata in this dictionary determines whether Houdini
            runs these scripts as Python as as Hscript.

            These is one dictionary for the entire asset, and keys in this
            dictionary are usually of the form section_name/option_name. For
            example, if the OnCreated section is marked as containing Python
            code, this dictionary will contain OnCreated/IsPython set to True.

            Note that the contents of this dictionary are saved in the
            ExtraFileOptions section and are encoded in a binary format.

            See also hou.HDADefinition.setExtraFileOption and
            hou.HDADefinition.removeExtraFileOption.


        """

class HDAModule:
    '''

    hou.HDAModule

    User-defined Python module containing functions, classes, and constants
    that are stored with and accessed from a digital asset.

    In Python, a module lets you organize functions, classes, and constants
    into a common namespace. For example, os is a module and os.getcwd is a
    function inside that module, and you access the contents of a module by
    looking up Python attributes on it.

    An HDAModule is a Python module that is associated with a particular
    digital asset type. It lets you store a library of Python code in one
    location in your asset, and you can invoke that code from parameters,
    event handlers, and callbacks inside that asset.

    The module\'s source code is stored in the Python Module section of the
    Scripts tab in the Type Properties dialog. For example, suppose the
    digit asset is an object named gear and the Python Module section
    contains the following:

    > def position():
    >     return (hou.frame() * 1.2, 0.0, 3.2)
    > 
    > def onButtonPress():
    >     print \\"you pressed the button\\"
    > 
    > def onLoaded():
    >     print \\"onLoaded section running\\"

    Unlike regular Python modules, which you access by name, you access a
    digital asset\'s Python module by calling hou.NodeType.hdaModule on its
    node type. For example, suppose you created an object-level digital
    asset named gear and put the above code in its Python Module section.
    You could then access the contents of the Python module as follows:

    > >>> node_type = hou.nodeType(hou.objNodeTypeCategory(), \\"gear\\")
    > >>> node_type.hdaModule().position()
    > (1.2, 0.0, 3.2)
    > >>> node_type.hdaModule().onButtonPress()
    > you pressed the button

    One use for the Python module is drive parameter expressions on nodes
    inside the digital asset. For example, suppose /obj/gear1 is an instance
    of the digital asset and /obj/gear1/geo1 is a node inside the asset. You
    could put the following inside geo1\'s tx parameter expression:

    > hou.node(\\"..\\").type().hdaModule().position()[0]

    For convenience, you can also access the module from a node instance of
    the digital asset using hou.OpNode.hdaModule. So, you could simplify the
    above expression to:

    > hou.node(\\"..\\").hdaModule().position()[0]

    And since you don\'t need to use the hou. prefix inside expressions, you
    could further simplify it to:

    > node(\\"..\\").hdaModule().position()[0]

    The following example shows how you might run code in the module from
    the Callback Script field of a button parameter:

    > hou.pwd().hdaModule().onButtonPress()

    In an event handler script, such as On Loaded, you can use the kwargs
    dict to access the node type:

    > kwargs[\\"type\\"].hdaModule().onLoaded()

    Note that Houdini creates a local kwargs dict that\'s accessible from the
    Python Module, too. It contains one entry with the key \\"type\\", to give
    you access to the hou.NodeType defined by the digital asset.

    If you find that a digital asset has too much Python code to store in
    one module, it\'s possible to create submodules. For example, if you want
    to create a submodule named bar, put its source code in a new digital
    asset section (say, \\"bar_PythonModule\\"). Then, from the Python Module
    section, you can write the following:

    > import toolutils
    > bar = toolutils.createModuleFromSection(\\"bar\\", kwargs[\\"type\\"], \\"bar_PythonModule\\")

    NOTE
        New to Houdini 18.0, the createModuleFromSection function expects
        the code in the HDA section to have Python 3 style print statements.

        In general this means that print statements in the HDA section must
        have the arguments enclosed in parentheses.


        For example
          > print(\\"Hello world!\\")
        instead of
          > print \\"Hello world!\\"
    bar now appears as a submodule of the main module. If, for example, the
    bar_PythonModule section contains:

    > def foo():
    >     return 3.2

    then you could write the following from a parameter on the digital asset
    node:

    > pwd().hdaModule().bar.foo()

    Note that the Python Module code is stored in a section of the digital
    asset named \\"PythonModule\\". For example, you can get a string containing
    that source code using
    node_type.definition().sections()[\\"PythonModule\\"].contents().


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __getattr__(self, name: str) -> Any: ...

class HDAOptions:
    '''

    hou.HDAOptions

    Stores miscellaneous options about a houdini digital asset (HDA).

    The contents of this object correspond to some of the checkboxes on the
    Basic tab of the Type Properties dialog. These values are stored in the
    TypePropertiesOptions section of a digital asset definition.

    Call hou.HDADefinition.options to get an HDAOptions instance. Note that
    an instance of this class is simply a data structure, and is not
    associated with an particular digital asset instance. In other words,
    changing the values inside this object will not change the digital
    asset. To save these values to the digital asset definition, call
    hou.HDADefinition.setOptions.

    > >>> node = hou.node(\\"/obj/my_digital_asset1\\")
    > >>> definition = node.type().definition()
    > >>> print definition.sections()[\'TypePropertiesOptions\'].contents()
    > ParmsFromVfl := 0;
    > PrefixDroppedParmName := 1;
    > UseDSParms := 1;
    > ForbidOutsideParms := 1;
    > LockContents := 1;
    > SaveSpareParms := 0; # <-- Currently 0
    > CheckExternal := 1;
    > GzipContents := 1;
    > MakeDefault := 1;
    > PrefixDroppedParmLabel := 1;
    > UnlockOnCreate := 0;
    > 
    > >>> options = definition.options()
    > >>> options.saveSpareParms()
    > False
    > >>> options.setSaveSpareParms(True)
    > >>> definition.setOptions(options)
    > >>> print definition.sections()[\'TypePropertiesOptions\'].contents()
    > ParmsFromVfl := 0;
    > PrefixDroppedParmName := 1;
    > UseDSParms := 1;
    > ForbidOutsideParms := 1;
    > LockContents := 1;
    > SaveSpareParms := 1; # <-- Now 1
    > CheckExternal := 1;
    > GzipContents := 1;
    > MakeDefault := 1;
    > PrefixDroppedParmLabel := 1;
    > UnlockOnCreate := 0;

    '''
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Create an HDAOptions object with default settings.

            See the class documentation for more information.


        """
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def checkForExternalLinks(self) -> bool:
        """

        checkForExternalLinks(self) -> bool

            Return whether the Check for External Node References option is set.

            If set, this option changes all absolute node references inside the
            digital asset into relative references.


        """
    def setCheckForExternalLinks(self, on: bool) -> None:
        """

        setCheckForExternalLinks(self, check_for_external_links)

            Sets the Check for External Node References option. See
            hou.HDAOptions.checkForExternalLinks for more information.


        """
    def compressContents(self) -> bool:
        """

        compressContents(self) -> bool

            Return whether the Compress Contents option is on.

            When this option is set, Houdini compresses the contents of the
            asset definition to reduce the size of the .hda file. Note that this
            option only as effect when the result of hou.HDAOptions.lockContents
            is True.


        """
    def setCompressContents(self, on: bool) -> None:
        """

        setCompressContents(self, compress_contents)

            Sets the Compress Contents option. See
            hou.HDAOptions.compressContents for more information.


        """
    def compressionType(self) -> int: ...
    def setCompressionType(self, type: int) -> None: ...
    def forbidOutsideParms(self) -> bool:
        """

        forbidOutsideParms(self) -> bool

            Return whether the Forbid Linking Parameters from Outside this
            Subnet option is set.

            When set, this option does not allow you to drag parameters from
            nodes outside the contents of the digital asset.


        """
    def setForbidOutsideParms(self, on: bool) -> None:
        """

        setForbidOutsideParms(self, forbid_outside_parms)

            Sets the Forbid Linking Parameters from Outside this Subnet option.
            See hou.HDAOptions.forbidOutsideParms for more information.


        """
    def lockContents(self) -> bool:
        """

        lockContents(self) -> bool

            Return whether the Save Contents as Locked option is on.

            When this option is not set, Houdini will use a creation script to
            store the contents of the digital asset instead of storing the node
            data. A creation script cannot store extra data like locked SOPs,
            edit SOP information, paint SOP information, etc.

            If this option is not set, new instances of the digital asset will
            be locked, so the user can edit the contents. However, you probably
            do not ever want to turn this option off. Instead, if you want to
            lock new instances of the digital asset, see
            hou.HDAOptions.unlockNewInstances.


        """
    def setLockContents(self, on: bool) -> None:
        """

        setLockContents(self, lock_contents)

            Sets the Save Contents as Locked option. See
            hou.HDAOptions.lockContents for more information.


        """
    def makeInitialParmsDefaults(self) -> bool:
        """

        makeInitialParmsDefaults(self) -> bool

            Return whether the Save Defaults as Initial Parameters option is on.

            When set, this option uses the default values of the original
            parameters as the initial values for new nodes, instead of their
            current values.


        """
    def setMakeInitialParmsDefaults(self, on: bool) -> None:
        """

        setMakeInitialParmsDefaults(self, make_initial_parms_defaults)

            Sets the Save Defaults as Initial Parameters option. See
            hou.HDAOptions.makeInitialParmsDefaults for more information.


        """
    def parametersFromVexCode(self) -> bool:
        """

        parametersFromVexCode(self) -> bool

            Return whether the Get Properties from VEX Code option is on.

            When this option is set, most properties and parameters of the
            operator come from pragma statements in the VEX source code.


        """
    def setParametersFromVexCode(self, on: bool) -> None:
        """

        setParametersFromVexCode(self, parameters_from_vex_code)

            Sets the Get Properties from VEX Code option. See
            hou.HDAOptions.parametersFromVexCode for more information.


        """
    def prefixDroppedParmLabels(self) -> bool: ...
    def setPrefixDroppedParmLabels(self, on: bool) -> None:
        """

        setPrefixDroppedParmLabels(self, prefix_dropped_parm_labels)

            Sets the Prefix Dropped Parameter Labels option. See
            hou.HDAOptions.prefixDroppedParmLabels for more information.


        """
    def prefixDroppedParmNames(self) -> bool:
        """

        prefixDroppedParmNames(self) -> bool

            Return whether the Prefix Dropped Parameter Names option is on.

            When this option is set, Houdini will not include a prefix on
            parameter names when you drag and drop parameters into the Existing
            Parameters areas of the Parameters tab of the Type Properties
            dialog.

            See also hou.HDAOptions.prefixDroppedParmLabels.


        """
    def setPrefixDroppedParmNames(self, on: bool) -> None:
        """

        setPrefixDroppedParmNames(self, prefix_dropped_parm_names)

            Sets the Prefix Dropped Parameter Names option. See
            hou.HDAOptions.prefixDroppedParmNames for more information.


        """
    def saveInitialParmsAndContents(self) -> bool:
        """

        saveInitialParmsAndContents(self) -> bool

            Return whether the Save Initial Contents and Parameters option is
            on.

            When this option is set, Houdini saves any parameter values and node
            contents referenced by the digital asset to be saved as part of the
            asset's definition.


        """
    def setSaveInitialParmsAndContents(self, on: bool) -> None:
        """

        setSaveInitialParmsAndContents(self, save_initial_parms_and_contents)

            Set the Save Initial Contents and Parameters option. See
            hou.HDAOptions.saveInitialParmsAndContents for more information.


        """
    def unlockNewInstances(self) -> bool:
        """

        unlockNewInstances(self) -> bool

            Return whether the Unlock New Nodes on Creation option is set.

            When this option is set, Houdini will unlock new instances of the
            digital asset when they are created. Note that this option only has
            effect when the result of hou.HDAOptions.lockContents is True.


        """
    def setUnlockNewInstances(self, on: bool) -> None:
        """

        setUnlockNewInstances(self, unlock_new_instances)

            Sets the Unlock New Nodes on Creation option. See
            hou.HDAOptions.unlockNewInstances for more information.


        """
    def saveSpareParms(self) -> bool:
        """

        saveSpareParms(self) -> bool

            Return the Save Spare Parameters option.

            When set, this option will add code into the asset creation script
            to recreate the node's current spare parameters. New node instances
            of the digital asset will contain the same spare parameters as those
            on the representative node.


        """
    def setSaveSpareParms(self, on: bool) -> None:
        """

        setSaveSpareParms(self, save_spare_parms)

            Set the Save Spare Parameters option. See
            hou.HDAOptions.saveSpareParms for more information.


        """
    def saveCachedCode(self) -> bool:
        """

        saveCachedCode(self) -> bool

            Return the Save Cached Code option.

            When set, this option will save cached code for applicable
            definitions, such as digital assets defined by VOP networks that
            generate VEX code. With this option on, the compiled code will be
            saved to the HDA section(s) and will be used for shaders, etc,
            without the need to recompile the network. This can save significant
            amounts of time for complex shaders.


        """
    def setSaveCachedCode(self, on: bool) -> None:
        """

        setSaveCachedCode(self, save_cached_code)

            Set the Save Cached Code option. See hou.HDAOptions.saveCachedCode
            for more information.


        """
    __swig_destroy__: Incomplete

class HDASection:
    '''

    hou.HDASection

    Represents a section of data stored along with a digital asset.

    A digital asset stores its contents in a number of different pieces of
    data called sections. Each section is named and contains an arbitrarily
    sized piece of data, often textual. Each section is like a file embedded
    inside the definition, and Houdini uses specially named sections to
    store the node contents, list of parameters, etc. You can embed your own
    data into a digital asset by putting it inside a section.

    Any parameter in Houdini that references a file can also reference a
    section inside a digital asset. For example, if car is an object-level
    digital asset and the section is named \\"texture.jpg\\", you can reference
    that texture with opdef:/Object/car?texture.jpg. Note that hou.readFile
    also supports this opdef: syntax.

    By moving files into digital asset sections, you can build self-
    contained digital assets that can be distributed via a single hda file.

    Note that section names may contain \'/\'.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def definition(self) -> HDADefinition:
        """

        definition(self) -> hou.HDADefinition

            Return the digital asset definition containing this section.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of this section.

            Note that is is not possible to rename a section, but the following
            function will emulate renaming:

          > def renameSection(section):
          >     '''Rename a section by removing it and creating a new one.  Return the new section.'''
          >     new_section = section.definition().addSection(new_name, section.contents())
          >     section.destroy()
          >     return new_section

        """
    def contents(self, compressionType: EnumValue = ...) -> str:
        '''

        contents(self, compressionType=hou.compressionType.NoCompression) -> str

            Return a string containing the contents of this section.

            You can optionally specify a compression type, hou.compressionType,
            to decompress the contents.

            Raises hou.OperationFailed if a compression type is specified and
            the contents are not compressed by that type.

          > def saveSectionToFile(section, file_name):
          >     \'\'\'Given a section, save it to a file.\'\'\'
          >     section_file = file(file_name, \\"w\\")
          >     section_file.write(section.contents())
          >     section_file.close()

        '''
    def binaryContents(self, compressionType: EnumValue = ...) -> bytes:
        '''

        binaryContents(self, compressionType=hou.compressionType.NoCompression)
        -> bytes

            Only available in Python 3.

            Similar to hou.HDASection.contents but return a bytes object
            instead. Ideal for sections containing binary data.

          > def saveBinarySectionToFile(section, file_name):
          >     \'\'\'Given a section, save it to a file.\'\'\'
          >     section_file = file(file_name, \\"wb\\")
          >     section_file.write(section.binaryContents())
          >     section_file.close()

        '''
    def setContents(self, contents: str, compressionType: EnumValue = ...) -> None:
        """

        setContents(self, contents,
        compressionType=hou.compressionType.NoCompression)

            Set the contents of this section to the given string. A section may
            contain binary information, like bgeo files, images, etc.

            You can optionally specify a compression type, hou.compressionType,
            to compress the contents. Note that you must specify the same
            compression type when reading the contents back to decompress them.

            For Python 3, the contents can be either a str object for plain text
            data or a bytes for binary data.

            See hou.HDADefinition.addSection for an example of how to create a
            section from a file on disk.


        """
    def size(self) -> int:
        """

        size(self) -> int

            Return the number of bytes in the contents. This method is a
            shortcut for len(self.contents()).


        """
    def modificationTime(self) -> int:
        '''

        modificationTime(self) -> int

            Return the time when the section was last modified. This time is
            returned as a POSIX timestamp, such as is returned by time.time().

          > >>> hou.nodeType(hou.cop2NodeTypeCategory(), \\"colorwheel\\").definition()
          > <hou.HDADefinition of Cop2 colorwheel in /opt/hfs9.5/houdini/hda/OPlibCop2.hda>
          > >>> definition = hou.nodeType(hou.cop2NodeTypeCategory(), \\"colorwheel\\").definition()
          > >>> definition.sections().keys()
          > [\'VflCode\', \'DialogScript\', \'VexCode\']
          > >>> section = definition.sections()[\'VflCode\']
          > >>> section.modificationTime()
          > 1177535169
          > >>> import datetime, time
          > >>> datetime.datetime.fromtimestamp(section.modificationTime())
          > datetime.datetime(2007, 4, 25, 17, 6, 9)
          > >>> time.ctime(section.modificationTime())
          > \'Wed Apr 25 17:06:09 2007\'

        '''
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this section from the HDA definition. You can also remove a
            section with hou.HDADefinition.removeSection, and this method is
            equivalent to self.definition().removeSection(self.name()).

            Only remove sections that you explicitly added. Do not remove the
            special sections that Houdini uses to store the contents of the
            digital asset definition, or Houdini will generate errors or strange
            side effects.

            To add a section, use hou.HDADefinition.addSection.


        """

class HDAViewerHandleModule:
    """

    hou.HDAViewerHandleModule

    User-defined Python module containing the implementation and
    registration code of a python viewer handle stored in a digital asset.

    HDAViewerHandleModule is similar to hou.HDAViewerStateModule but
    dedicated for python viewer handles. It is mainly used to access the
    python viewer handle module that is associated with a particular digital
    asset type. You don't normally need HDAViewerHandleModule for using
    python handles though, this object is typically used by Houdini for
    registering the python handles embedded in the digital asset.

    The python handle state module's source code is stored in the
    ViewerHandle Module section of the Interactive|Handle Script tab in the
    Type Properties dialog. The source code can be edited with the Handle
    script editor.

    See hou.OpNode.hdaViewerHandleModule and
    hou.NodeType.hdaViewerHandleModule for creating HDAViewerHandleModule
    instances.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __getattr__(self, name: str) -> Any: ...

class HDAViewerStateModule:
    """

    hou.HDAViewerStateModule

    User-defined Python module containing the implementation and
    registration code of a python viewer state stored in a digital asset.

    HDAViewerStateModule is similar to hou.HDAModule but dedicated for
    python viewer states. It is mainly used to access the python viewer
    state module that is associated with a particular digital asset type.
    You don't normally need HDAViewerStateModule for using python states
    though, this object is typically used by Houdini for registering the
    python states embedded in the digital asset.

    The python viewer state module's source code is stored in the
    ViewerState Module section of the Interactive|State Script tab in the
    Type Properties dialog. The source code can be edited with the State
    script editor.

    See hou.OpNode.hdaViewerStateModule and
    hou.NodeType.hdaViewerStateModule for creating HDAViewerStateModule
    instances.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __getattr__(self, name: str) -> Any: ...

class HelpBrowser(PaneTab):
    """

    hou.HelpBrowser

    Class representing a help browser pane tab. Provides methods for
    controlling the help browser.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def displayHelp(self, node_type: NodeType) -> None:
        """

        displayHelp(self, node_type)

            Loads the help for the specified node type.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
    def displayHelpPath(self, help_path: str) -> None:
        """

        displayHelpPath(self, help_path)

            Loads the help for the specified help path. The path can either be a
            Houdini help URL (i.e. op:Sop/copy, tool:curve) or a raw help path
            (i.e. /nodes/sop/copy, shelf/curve).


        """
    def displayHelpPyPanel(self, interface_name: str) -> None:
        """

        displayHelpPyPanel(self, interface_name)

            Loads the help for the python panel with the specified name.

            Raises HOM_Error if the interface name is invalid.


        """
    def homePage(self) -> str:
        """

        homePage(self) -> str

            Returns the home page URL of this help browser.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
    def setHomePage(self, home_page: str) -> None:
        """

        setHomePage(self, home_page)

            Sets the home page for this help browser to the specified URL.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted, and raises HOM_Error if home_page is not given.


        """
    def url(self) -> str:
        """

        url(self) -> str

            Return the current URL of this help browser.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """
    def setUrl(self, url: str) -> None:
        """

        setUrl(self, url)

            Loads the specified URL.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted, and raises HOM_Error if url is not given.


        """
    def showUI(self, show: bool) -> None:
        """

        showUI(self, show)

            Shows or hides the help browser's navigation controls.

            Raises HOM_ObjectWasDeleted if the help browser pane tab was
            deleted.


        """

class hipFile:
    """

    hou.hipFile

    Functions for working with the current scene (.hip) file.


    NOTE
        Houdini inherits the current directory (sometimes called the current
        working directory) from the environment where you run it. Some
        functions return or accept paths relative to the current directory.
        You can check Houdini's current directory by calling os.getcwd(),
        and change it by calling os.chdir.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def save(file_name: Optional[str] = None, save_to_recent_files: bool = True) -> None:
        """

        save(file_name=None, save_to_recent_files=True)

            Saves the current scene to a .hip file.


            file_name
                If this is a string, saves the current scene to a file at this
                path, like File > Save As. The path can be absolute or relative
                to the current directory.

                If this is None, saves the scene to its current path
                (hou.hipFile.path), like File > Save.

                If intermediate directories in the path do not exist, Houdini
                will create them.

            save_to_recent_files
                In a graphical session, whether to add this file to the list of
                recent files in the File > Open Recent Files menu. The default
                is True.

                In a non-graphical session (hython), the function always acts
                like save_to_recent_files is off.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
    @staticmethod
    def saveAndIncrementFileName() -> None:
        """

        saveAndIncrementFileName()

            Saves the scene to its current path (same as File > Save), but
            increments a number at the end of the filename.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
    @staticmethod
    def saveAndBackup() -> str:
        """

        saveAndBackup() -> str

            Saves the current scene but first creates a backup of the previous
            saved state to a backup file in $HOUDINI_BACKUP_DIR with _bak and an
            increasing number added before the .hip extension. If
            $HOUDINI_BACKUP_DIR is not set, then this method creates the backup
            file in a backup directory in the same directory as the scene file.

            Returns the absolute path of the backup file.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
    @staticmethod
    def saveAsBackup() -> str:
        """

        saveAsBackup() -> str

            Saves the current scene to a new file in $HOUDINI_BACKUP_DIR with
            _bak and an increasing number added before the .hip extension. If
            $HOUDINI_BACKUP_DIR is not set, this saves the file to a backup
            directory in the same directory as the scene file.

            Returns the absolute path of the backup file.

            Raises hou.OperationFailed if Houdini can't create intermediate
            directories or write to the specified file (for example, because of
            filesystem permissions).

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
    @staticmethod
    def basename() -> str:
        """

        basename() -> str

            Return the filename portion of the current scene's path (including
            the .hip extension).


        """
    @staticmethod
    def name() -> str:
        """

        name() -> str

            Return the path of the current hip file relative to the current
            directory. Remember that a file may not exist at this path if the
            current scene hasn't been saved yet.

            This function returns a relative path from the current directory.
            For example, if the current directory is /home/alyah/ and the
            current scene file is /home/alyah/Houdini/Projects/city.hip, this
            would return Houdini/Projects/city.hip. If the current scene file,
            this is the same as calling hou.hipFile.basename().

            If you want an absolute path to the current scene file, use
            Hom:hou.hipFile#path instead.


        """
    @staticmethod
    def path() -> str:
        """

        path() -> str

            Return the absolute file path of the current scene file. Remember
            that a file may not exist at this path if the current scene hasn't
            been saved yet.


        """
    @staticmethod
    def setName(file_name: str) -> None:
        """

        setName(file_name)

            Sets the in-memory path of the current scene file. This is the path
            Houdini will save to if the user chooses File > Save or you call
            hou.hipFile.save without a file path.


            file_name
                The path to use. This can be an absolute path or relative to the
                current directory.

            This function does not save the scene, it only changes the path
            Houdini thinks the scene should be saved at. To actually save the
            scene to a new path, use hou.hipFile.save.


        """
    @staticmethod
    def saveMode() -> EnumValue:
        """

        saveMode(self) -> hou.saveMode

            Return the save mode of the current scene, either
            hou.saveMode.Binary or hou.saveMode.Text.


        """
    @staticmethod
    def setSaveMode(savemode: EnumValue) -> None:
        """

        setSaveMode(self, save_mode)

            Set the save mode of the current scene to either hou.saveMode.Binary
            or hou.saveMode.Text.


        """
    @staticmethod
    def clear(suppress_save_prompt: bool = False) -> bool:
        """

        clear(suppress_save_prompt=False) -> bool

            Clears the contents of the current scene file, starting a new
            unsaved file. Returns True if the contents were cleared and False
            otherwise. The contents will not be cleared, if, in a graphic
            session, the user chooses to cancel when prompted to save the
            current file.


            suppress_save_prompt
                Normally, in a graphical session, this function acts the same as
                if the user had chosen File > New, and prompts to save the
                current file if it has unsaved changes. You can force Houdini to
                clear without prompting by passing suppress_save_prompt=True.

                In a non-graphical session (hython), the function always acts
                like suppress_save_prompt is on.


        """
    @staticmethod
    def load(file_name: str, suppress_save_prompt: bool = False, ignore_load_warnings: bool = False) -> None:
        """

        load(file_name, suppress_save_prompt=False, ignore_load_warnings=False)

            Loads a new scene (.hip) file.

            Raises hou.OperationFailed if Houdini cannot read the file.

            Raises hou.LoadWarning if loading the new file triggers warnings
            (such as missing assets). You can prevent these exceptions by
            passing ignore_load_warnings=True.


            file_name
                The path to the scene file to load.

            suppress_save_prompt
                Normally, in a graphical session, this function acts the same as
                if the user had chosen File > Open, and prompts to save the
                current file if it has unsaved changes. You can force Houdini to
                load the new file without prompting by passing
                suppress_save_prompt=True.

                In a non-graphical session (hython), the function always acts
                like suppress_save_prompt is on.

            ignore_load_warnings
                Prevents Houdini from raising hou.LoadWarning exceptions if
                loading the new file triggers warnings (such as missing assets).

            Raises hou.OperationFailed if you call this while Houdini is cooking
            a node, shutting down (see hou.hipFile.isShuttingDown) or if Houdini
            is saving the scene file. If this method is called when loading a
            hip file (from 456.py), the operation will succeed, but after
            merging the hip file the 456.py script will not be run again.


        """
    @staticmethod
    def merge(file_name: str, node_pattern: str = ..., overwrite_on_conflict: bool = ..., ignore_load_warnings: bool = ...) -> None:
        '''

        merge(file_name, node_pattern=\\"*\\", overwrite_on_conflict=False,
        ignore_load_warnings=False)

            Imports the contents of the file at path file_name into the current
            scene. (This does not save the current scene file.)

            Raises hou.LoadWarning if loading the new file triggers warnings
            (such as missing assets). You can prevent these exceptions by
            passing ignore_load_warnings=True.


            node_pattern
                Only merge in nodes matching this pattern.

            overwrite_on_conflict
                What to do if merged-in nodes have the same path/name as
                existing nodes. If this is True, merged in nodes replace
                existing nodes. If this is False (the default), merged in nodes
                are renamed if the conflict with existing nodes.

                See hou.hipFile.collisionNodesIfMerged to check for conflicts
                before merging.

            ignore_load_warnings
                Prevents Houdini from raising hou.LoadWarning exceptions if
                loading the new file triggers warnings (such as missing assets).

            Raises hou.OperationFailed if the file to merge doesn\'t exist or
            Houdini cannot read the file.

            Also raises hou.OperationFailed if you call this while Houdini is
            cooking a node, shutting down (see hou.hipFile.isShuttingDown) or if
            Houdini is saving the scene file. If this method is called when
            loading a hip file (from 456.py), the operation will succeed, but
            after merging the hip file the 456.py script will not be run again.


        '''
    @staticmethod
    def collisionNodesIfMerged(file_name: str, node_pattern: str = ...) -> Tuple[OpNode,...]:
        '''

        collisionNodesIfMerged(file_name, node_pattern=\\"*\\") -> tuple of
        hou.OpNode

            Returns a sequence of hou.OpNode objects representing the nodes that
            would have conflicts if you tried to merge the given file with
            hou.hipFile.merge.


            node_pattern
                Only check nodes matching this pattern.

            Raises hou.OperationFailed if the file to merge doesn\'t exist or
            Houdini cannot read the file.

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        '''
    @staticmethod
    def isLoadingHipFile() -> bool:
        """

        isLoadingHipFile() -> bool

            Returns True if Houdini is currently loading a scene file.


        """
    @staticmethod
    def isShuttingDown() -> bool:
        """

        isShuttingDown() -> bool

            Returns True if Houdini is currently exiting.


        """
    @staticmethod
    def isNewFile() -> bool:
        """

        isNewFile() -> bool

            Returns whether the current Houdini file is a new file or is a
            previously loaded file.

            This function only works accurately in a graphical session. In a
            non-graphical session (hython) it will always return True if the
            filename matches the default filename.


        """
    @staticmethod
    def hasUnsavedChanges() -> bool:
        """

        hasUnsavedChanges() -> bool

            Returns whether the current Houdini session has been modified since
            it was last saved. (This is sometimes referred to as the current
            file being dirty.)

            This function only works in a graphical session. In a non-graphical
            session (hython) it will always return True.


        """
    @staticmethod
    def groupColorTable() -> dict[str, Color]:
        """

        groupColorTable() -> dict of str to hou.Color

            Returns a dictionary of color overrides for the viewport group list.
            The viewport group list automatically assigns colors to groups based
            on a hash of the group name. The group color table is a dictionary
            of overrides to these default color assignments. This allows
            particular important groups to be assigned distinctive colors. The
            group color table is saved with the hip file. The color table can be
            modified with hou.hipFile.setGroupColorTable.


        """
    @staticmethod
    def setGroupColorTable(color_table: dict[str, Color]) -> None:
        """

        setGroupColorTable(color_table)

            Sets a dictionary of color overrides for the viewport group list.
            The viewport group list automatically assigns colors to groups based
            on a hash of the group name. The group color table is a dictionary
            of overrides to these default color assignments. This allows
            particular important groups to be assigned distinctive colors. The
            group color table is saved with the hip file. The current color
            table can be queried with hou.hipFile.groupColorTable.

            The supplied color_table must be a dict of str to hou.Color. The
            following example will cause groups names 'special_group' to appear
            with a red overlay:

          > color_table = { 'special_group' : hou.Color([1,0,0]) }
          > hou.hipFile.setGroupColorTable(color_table)

        """
    @staticmethod
    def importFBX(file_name: str, suppress_save_prompt: bool = ..., merge_into_scene: bool = ..., import_cameras: bool = ..., import_joints_and_skin: bool = ..., import_geometry: bool = ..., import_lights: bool = ..., import_animation: bool = ..., import_materials: bool = ..., resample_animation: bool = ..., resample_interval: float = ..., override_framerate: bool = ..., framerate: int = ..., hide_joints_attached_to_skin: bool = ..., convert_joints_to_zyx_rotation_order: bool = ..., material_mode: EnumValue = ..., compatibility_mode: EnumValue = ..., single_precision_vertex_caches: bool = ..., triangulate_nurbs: bool = ..., triangulate_patches: bool = ..., import_global_ambient_light: bool = ..., import_blend_deformers_as_blend_sops: bool = ..., segment_scale_already_baked_in: bool = ..., convert_file_paths_to_relative: bool = ..., unlock_geometry: bool = ..., unlock_deformations: bool = ..., import_nulls_as_subnets: bool = ..., import_into_object_subnet: bool = ..., convert_into_y_up_coordinate_system: bool = ..., create_sibling_bones: bool = ..., override_scene_frame_range: bool = ..., convert_units: bool = ...) -> Tuple[ObjNode,...]:
        """

        importFBX(file_name, suppress_save_prompt=False, merge_into_scene=True,
        import_cameras=True, import_joints_and_skin=True, import_geometry=True,
        import_lights=True, import_animation=True, import_materials=True,
        resample_animation=False, resample_interval=1.0,
        override_framerate=False,framerate=-1,
        hide_joints_attached_to_skin=True,
        convert_joints_to_zyx_rotation_order=False,
        material_mode=hou.fbxMaterialMode.FBXShaderNodes,
        compatibility_mode=hou.fbxCompatibilityMode.Maya,
        single_precision_vertex_caches=False, triangulate_nurbs=False,
        triangulate_patches=False, import_global_ambient_light=False,
        import_blend_deformers_as_blend_sops=False,
        segment_scale_already_baked_in=True,
        convert_file_paths_to_relative=True, unlock_geometry=False,
        unlock_deformations=False, import_nulls_as_subnets=False,
        import_into_object_subnet=True,
        convert_into_y_up_coordinate_system=False, create_sibling_bones=True,
        override_scene_frame_range=False, convert_units=False) -> (hou.ObjNode,
        str)

            Imports the contents of an FBX file into the scene, like when the
            user chooses File > Import > FBX. Returns a tuple of the parent
            Subnetwork Object node containing the FBX nodes (see
            import_into_object_subnet option) and a string containing any
            generated load messages.

            Important: see the help for the FBX import dialog for information on
            the various options.


            import_into_object_subnet
                When this is True (the default), Houdini creates a new
                Subnetwork node at the object level and puts imported FBX nodes
                inside the subnet. If you pass import_into_object_subnet=False,
                Houdini creates the FBX nodes directly at the object level (and
                the first item in the returned tuple will be the /obj network
                node).

            Raises hou.OperationFailed if the file to merge doesn't exist or
            Houdini cannot read the file.

            Also raises hou.OperationFailed if you call this while Houdini is
            shutting down (see hou.hipFile.isShuttingDown) or if Houdini is
            already loading or saving the scene file (see
            hou.hipFile.isLoadingHipFile).


        """
    @staticmethod
    def clearEventCallbacks() -> None:
        """

        clearEventCallbacks()

            This method is deprecated in favor of
            hou.hipFile.removeEventCallback.

            Removes all Python callbacks that have been registered with
            hou.hipFile.addEventCallback.


        """

    # Missing methods added by stubgen
    @staticmethod
    def addEventCallback(callback: Callable[[EnumValue], None]) -> None: ...
    @staticmethod
    def removeEventCallback(callback: Callable[[EnumValue], None]) -> None: ...
    @staticmethod
    def eventCallbacks() -> Tuple[Callable[[EnumValue], None], ...]: ...

class hmath:
    """

    hou.hmath

    Houdini and 3D related math functions.

    See hou.Geometry.transformPrims and hou.Matrix4.explode for matrix
    transform examples.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def identityTransform() -> Matrix4:
        """

        identityTransform() -> hou.Matrix4

            Returns the identity matrix. This is the same as hou.Matrix4(1) but
            may make your code more understandable.

          > >>> hou.hmath.identityTransform()
          > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]>

            See hou.Matrix4.


        """
    @staticmethod
    def buildTranslate(tx: float|Vector3, ty: float = ..., tz: float = ...) -> Matrix4:
        """

        buildTranslate(tx, ty, tz) -> hou.Matrix4

            Returns a transformation matrix containing only a translation. You
            can build more complex transformations by multiplying this with
            another transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3.

          > forward_z = hou.hmath.buildTranslate(0, 0, 1)
          > forward_x = hou.hmath.buildTranslate(hou.Vector3(1, 0, 0))

        """
    @staticmethod
    def buildScale(sx: float|Vector3, sy: float = ..., sz: float = ...) -> Matrix4:
        """

        buildScale(sx, sy, sz) -> hou.Matrix4

            Returns a transformation matrix containing only a scale. You can
            build more complex transformations by multiplying this with another
            transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3. To apply a uniform scale, use the
            same value for x, y, and z.

          > stretch = hou.hmath.buildScale(2, 1, 1)
          > uniform = hou.hmath.buildScale(hou.Vector3(2, 2, 2))

            See hou.Geometry.createNURBSSurface for an example.


        """
    @staticmethod
    def buildShear(shearx: float|Vector3, sheary: float = ..., shearz: float = ...) -> Matrix4:
        """

        buildShear(shearx, sheary, shearz) -> hou.Matrix4

            Returns a transformation matrix containing only a shear. You can
            build more complex transformations by multiplying this with another
            transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3.

            See Wikipedia's shear matrix page for more information.


        """
    @staticmethod
    def buildRotate(rx: float|Vector3, ry: float = ..., rz: float = ..., order: str = ...) -> Matrix4:
        '''

        buildRotate(rx, ry, rz, order=\\"xyz\\") -> hou.Matrix4

            Returns a transformation matrix containing only a rotation, given
            Euler angles in degrees. You can build more complex transformations
            by multiplying this with another transform matrix.

            You can supply three float values for x, y, and z, or a sequence of
            three floats, or a hou.Vector3.

          > xform1 = hou.hmath.buildRotate(45, 45, 0)
          > xform2 = hou.hmath.buildRotate(hou.Vector3(90, 0, 90))

            order
                A string containing a permutation of the letters x, y, and z
                that controls the order of rotations.

            See Wikipedia\'s Euler angles page for more information.


        '''
    @staticmethod
    def buildRotateAboutAxis(axis: Sequence[float], angle_in_deg: float) -> Matrix4:
        """

        buildRotateAboutAxis(axis, angle_in_deg) -> hou.Matrix4

            Returns a transformation matrix containing only a rotation computed
            from an axis and a rotation amount. You can build more complex
            transformations by multiplying this with another transform matrix.


            axis
                A hou.Vector3 normal defining an axis to rotate around. For
                example, hou.Vector3(0, 1, 1) would rotate around a diagonal
                pointed along positive Y and Z.

            angle_in_deg
                Number of degrees of rotation around the axis to store in the
                matrix.

          > turn_45_around_yz = hou.hmath.buildRotateAboutAxis(hou.Vector3(0, 1, 1), 45)

            If you want to convert Euler angles into a corresponding axis and
            angle, you can use the following code:

          > def extractAxisAndAngleFromRotateMatrix(m):
          >     '''
          >     Given a matrix, return an (Vector3, float) tuple containing the
          >     axis and angle.  See Wikipedia's rotation representation page for
          >     more details.
          >     '''
          > 
          >     import math
          > 
          >     acos_input = (m.at(0, 0) + m.at(1, 1) + m.at(2, 2) - 1.0) * 0.5
          >     if acos_input < -1.0 or acos_input > 1.0:
          >         return None
          > 
          >     angle = math.acos(acos_input)
          >     if angle >= -1e-6 and angle <= 1e-6:
          >         # There is no rotation.  Choose an arbitrary axis and a rotation of 0.
          >         return hou.Vector3(1, 0, 0), 0.0
          > 
          >     inv_sin = 1.0 / (2.0 * math.sin(angle))
          >     axis = hou.Vector3(
          >         (m.at(1, 2) - m.at(2, 1)) * inv_sin,
          >         (m.at(2, 0) - m.at(0, 2)) * inv_sin,
          >         (m.at(0, 1) - m.at(1, 0)) * inv_sin)
          >     return axis, hou.hmath.radToDeg(angle)
          > 
          > def eulerToAxisAndAngle(angles):
          >     return extractAxisAndAngleFromRotateMatrix(hou.hmath.buildRotate(angles))

            See Wikipedia's axis angle page and rotation representation page for
            more information.


        """
    @staticmethod
    def buildRotateZToAxis(axis: Sequence[float]) -> Matrix4:
        """

        buildRotateZToAxis(axis) -> hou.Matrix4

            Returns a transformation matrix rotating the z-axis onto the given
            axis. You can build more complex transformations by multiplying this
            with another transform matrix.


            axis
                A hou.Vector3 defining an axis to rotate the z-axis to.

          > rotate_z_to_x = hou.hmath.buildRotateZToAxis(hou.Vector3(1, 0, 0))

            The rotation picked is the shortest rotation. If the goal vector is
            pointed the opposite direction of the z-axis, an arbitrary but
            consistent rotation that maps to the negative z-axis will be picked.


        """
    @staticmethod
    def buildRotateLookAt(_from: Vector3, to: Vector3, up: Vector3) -> Matrix4:
        """

        buildRotateLookAt(__from, to, up) -> hou.Matrix4

            Returns a rotation matrix to orient negative z-axis point along the
            vector (_from-to). up is an up vector that defines the roll and
            orienting the positive y-axis.


            _from
                A hou.Vector3 defining the origin position of the lookat.

            to
                A hou.Vector3 defining the target position of the lookat.

            up
                A hou.Vector3 defining the up vector.

          > p0 = hou.Vector3(1, 2, 3)
          > p1 = hou.Vector3(1, 1, 0)
          > up = hou.Vector3(0, 1, 0)
          > lookat_m = hou.hmath.buildRotateLookAt(p0, p1, up)
          > 
          > # You can change which axis is the target by using another lookat
          > # and multiplying by the inverse matrix.
          > lookaxis = hou.Vector3(1, 0, 0)
          > upaxis = hou.Vector3(0, 0, 1)
          > fix_m = hou.hmath.buildRotateLookAt(hou.Vector3(0,0,0), lookaxis, upaxis)
          > lookat_m1 = fix_m.inverted() * lookat_m

        """
    @staticmethod
    def buildTransform(values_dict: Mapping[str, Vector3|Sequence[float]], transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ..., rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ...) -> Matrix4:
        '''

        buildTransform(values_dict, transform_order=\\"srt\\", rotate_order=\\"xyz\\")
        -> hou.Matrix4

            Takes a dictionary containing mapping strings to vectors (such as
            produced by hou.Matrix4.explode), and returns a hou.Matrix4
            transformation. You can use this to explode a matrix, modify one or
            a few components, and then recompose into a matrix, or to generate a
            matrix from scratch from a few components.

            The dictionary can contain any of the following keys: translate,
            rotate, scale, shear, pivot, pivot_rotate. The values can be
            hou.Vector3 objects or 3-tuples of floats.


            transform_order
                A string containing a permutation of the letters s, r, and t.
                The rotate, scale, and translate results are dependent on the
                order in which you perform those operations, and this string
                specifies that order.

            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes. This does not apply to the pivot_rotate

                angles, which are always applied in \\"xyz\\" order.

            This function could be re-implemented like this:

          > def buildTransform(values_dict, transform_order=\\"srt\\", rotate_order=\\"xyz\\"):
          >     # Take the return value from explode, along with the transform and
          >     # rotate order, and rebuild the original matrix.
          >     result = hou.hmath.identityTransform()
          >     for operation_type in transform_order:
          >         if operation_type == \\"t\\":
          >             result *= hou.hmath.buildTranslate(values_dict[\\"translate\\"])
          >         elif operation_type == \\"s\\":
          >             result *= hou.hmath.buildScale(values_dict[\\"scale\\"])
          >             if \\"shear\\" in values_dict:
          >                 result *= hou.hmath.buildShear(values_dict[\\"shear\\"])
          >         elif operation_type == \\"r\\":
          >             result *= hou.hmath.buildRotate(values_dict[\\"rotate\\"], rotate_order)
          >         else:
          >             raise ValueError(\\"Invalid transform order\\")
          >     return result

        '''
    @staticmethod
    def degToRad(degrees: float) -> float:
        """

        degToRad(degrees) -> float

            Given a value in degrees, return the corresponding value in radians.

            This function is equivalent to degrees * math.pi / 180.0.


        """
    @staticmethod
    def radToDeg(radians: float) -> float:
        """

        radToDeg(radians) -> double

            Given a value in radians, return the corresponding value in degrees.

            This function is equivalent to radians * 180.0 / math.pi.


        """
    @staticmethod
    def noise1d(pos: Sequence[float]) -> float:
        """

        noise1d(self, pos) -> float

            Given a sequence of 1 to 4 floats representing a position in
            N-dimensional space, return a single float corresponding to 1
            dimensional noise.

            This function matches the output of the noise() function from VEX.


        """
    @staticmethod
    def noise3d(pos: Sequence[float]) -> Vector3:
        """

        noise3d(self, pos) -> hou.Vector3

            Given a sequence of 1 to 4 floats representing a position in
            N-dimensional space, return a hou.Vector3 object representing the
            vector noise at the given position.

            This function matches the output of the noise() function from VEX.


        """
    @staticmethod
    def fit(value: float, oldmin: float, oldmax: float, newmin: float, newmax: float) -> float:
        """

        fit(value, old_min, old_max, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range old_min and old_max. If the value is outside
            the old_min to old_max range, it will be clamped to the new range.

          > >>> hou.hmath.fit(3, 1, 4, 5, 20)
          > 15.0

        """
    @staticmethod
    def fit01(value: float, newmin: float, newmax: float) -> float:
        """

        fit01(value, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range 0 and 1. If the value is outside the 0 to 1
            range, it will be clamped to the new range.

            This function is a shortcut for hou.hmath.fit(value, 0.0, 1.0,
            new_min, new_max).


        """
    @staticmethod
    def fit10(value: float, newmin: float, newmax: float) -> float:
        """

        fit10(value, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range 1 to 0. If the value is outside the 1 to 0
            range, it will be clamped to the new range.

            This function is a shortcut for hou.hmath.fit(value, 1.0, 0.0,
            new_min, new_max).


        """
    @staticmethod
    def fit11(value: float, newmin: float, newmax: float) -> float:
        """

        fit11(value, new_min, new_max) -> float

            Returns a number between new_min and new_max that is relative to the
            value between the range -1 to 1. If the value is outside the -1 to 1
            range, it will be clamped to the new range.

            This function is a shortcut for hou.hmath.fit(value, -1.0, 1.0,
            new_min, new_max).


        """
    @staticmethod
    def sign(value: float) -> float:
        """

        sign(value) -> int

            Returns 1.0 if value is positive, -1.0 if negative and 0.0 if value
            is zero.

            Note that you can achieve the same effect with Python's built-in cmp
            function: float(cmp(value, 0)).


        """
    @staticmethod
    def clamp(value: float, min: float, max: float) -> float:
        """

        clamp(value, min, max) -> float

            Returns the value clamped to the range min to max. See also
            hou.hmath.wrap. This function is useful in expressions to prevent a
            value from going outside the specified range.


        """
    @staticmethod
    def smooth(value: float, min: float, max: float) -> float:
        '''

        smooth(value, min, max) -> float

            Takes a value and range and returns a smooth interpolation between 0
            and 1.

            When value is less than min, the return value is 0. If value is
            greater than max, the return value is 1.

          > >>> hou.hmath.smooth(5, 0, 20)
          > 0.15625
          > >>> hou.hmath.smooth(10, 0, 20)
          > 0.5
          > >>> hou.hmath.smooth(15, 0, 20)
          > 0.84375
          > # Visualize the output of this function by positioning geometry objects at  various locations.
          > def createSpheres(num_spheres=40):
          >     for i in range(num_spheres):
          >         sphere = hou.node(\\"/obj\\").createNode(\\"geo\\").createNode(\\"sphere\\")
          >         sphere.parmTuple(\\"rad\\").set((0.1, 0.1, 0.1))
          >         sphere.setDisplayFlag(True)
          > 
          >         # Given a value between 0 and 5, we\'ll call smooth with a range
          >         # of 0 to 3, and the resulting y value will be between 0 and 1.
          >         x = 5.0 * i / num_spheres
          >         y = hou.hmath.smooth(x, 0, 3)
          >         sphere.parent().setParmTransform(hou.hmath.buildTranslate((x, y, 0)))

        '''
    @staticmethod
    def wrap(value: float, min: float, max: float) -> float:
        """

        wrap(value, min, max)

            Similar to the hou.hmath.clamp function in that the resulting value
            will always fall between the specified minimum and maximum value.
            However, it will create a saw-tooth wave for continuously increasing
            or decreasing parameter values.


        """
    @staticmethod
    def rand(seed: float) -> float:
        """

        rand(seed) -> float

            Returns a pseudo-random number from 0 to 1. Using the same seed will
            always give the same result.


        """
    @staticmethod
    def orient2d(pa: Sequence[float], pb: Sequence[float], point: Sequence[float]) -> float:
        """

        orient2d(pa, pb, point) -> float

            Performs an adaptive exact sidedness test of the 2d point against
            the line defined by pa and pb.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
    @staticmethod
    def orient3d(pa: Sequence[float], pb: Sequence[float], pc: Sequence[float], point: Sequence[float]) -> float:
        """

        orient3d(pa, pb, pc, point) -> float

            Performs an adaptive exact sidedness test of the 3d point against
            the plane defined by pa, pb, and pc.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
    @staticmethod
    def inCircle(pa: Sequence[float], pb: Sequence[float], pc: Sequence[float], point: Sequence[float]) -> float:
        """

        inCircle(pa, pb, pc, point) -> float

            Performs an adaptive exact inside test of the 2d point against the
            circle defined by pa, pb, and pc. pa, pb, and pc must be in counter-
            clockwise order to get a positive value for interior points.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
    @staticmethod
    def inSphere(pa: Sequence[float], pb: Sequence[float], pc: Sequence[float], pd: Sequence[float], point: Sequence[float]) -> float:
        """

        inSphere(pa, pb, pc, pd, point) -> float

            Performs an adaptive exact inside test of the 3d point against the
            sphere defined by pa, pb, pc, and pd. Note that inconsistent
            orientation of the four sphere defining points will reverse the sign
            of the result.

            See http://www.cs.cmu.edu/~quake/robust.html for details of the
            implementation.


        """
    @staticmethod
    def intersectPlane(plane_point: Vector3, plane_dir: Vector3, line_origin: Vector3, line_dir: Vector3) -> Vector3:
        """

        intersectPlane(plane_point, plane_normal, line_origin, line_dir) ->
        hou.Vector3

            Takes a plane defined by an origin point and normal vector
            (plane_point and plane_normal) and a line defined by an origin and
            direction (line_origin and line_dir) and returns a hou.Vector3 value
            representing the XYZ coordinates of the intersection point between
            the line and plane. All arguments must be hou.Vector3.

          > hou.hmath.intersectPlane(
          >     hou.Vector3(0, 0, 0), hou.Vector3(0, 1, 0),
          >     hou.Vector3(0.212, 1.56, 0), hou.Vector3(0, 0.62, -0.34)
          > )  # -> hou.Vector3(0.212, -1.19209e-07, 0.855484)

            (Note that line runs forward and backward along the line_dir from
            the origin. That is, even if line_dir points away from the plane,
            you will get the intersection behind the origin.)

          > hou.hmath.intersectPlane(
          >     hou.Vector3(0, 0, 0), hou.Vector3(0, 1, 0),  # Ground plane
          >     hou.Vector3(0, 1, 0), hou.Vector3(0, 1, 0)  # Line up from 1u above ground
          > )  # -> hou.Vector3(0, 0, 0)

            This function raises an exception if the line is parallel to the
            plane, or if the line_dir has no length, or even if the line is not
            mathematically parallel but parallel enough that the answer would be
            outside roughly a -100000, -100000 to 100000, 100000 square.


        """
    @staticmethod
    def combineLocalTransform(local: Matrix4, world: Matrix4, parent_local: Matrix4|None = ..., mode: EnumValue = ...) -> Matrix4:
        """

        combineLocalTransform(local, world, parent_local=None,
        mode=hou.scaleInheritanceMode.Default) -> hou.Matrix4

            Returns a new world transform given its local and parent world
            transforms.


        """
    @staticmethod
    def extractLocalTransform(local: Matrix4, world: Matrix4, parent_local: Matrix4, mode: EnumValue = ..., effective_local: Matrix4|None = ...) -> Matrix4:
        """

        extractLocalTransform(world, parent_world, parent_local,
        mode=hou.scaleInheritanceMode.Default, effective_local=None) ->
        hou.Matrix4

            Returns a new local transform given its world and new parent
            transforms. If effective_local is given, then it is a hou.Matrix4
            modified to be the effective local transform taking into account
            mode.


        """
    @staticmethod
    def slerpTransforms(xforms: typing.Iterable[Matrix4], input_weights: Sequence[float], normalize_weigths: bool = True, slerp_method: int = 1, slerp_flip_mehtod: int = 1) -> Matrix4:
        """

        slerpTransforms( xforms, input_weights, normalize_weights, slerp_method,
        slerp_flip_method) -> hou.Matrix4

            Spherically blend transforms by decomposing into separate
            quaternions. xforms is the array of hou.Matrix4 transforms to blend.
            input_weights is an array of floats with the same size as the
            xforms. Set normalize_weights to True to normalize the input
            weights. slerp_method can be 0 to blend using normalized linear
            interpolation of quaternions or 1 to use an iterative method.
            slerp_flip_method defines a flip methid for slerp to ensure
            consistency during blending. It can be 0 to use the hemisphere of
            the first quaternion, or 1 to compare each adjacent quaternions when
            using NLERP.


        """

class hotkeys:
    """

    hou.hotkeys

    Module containing hotkey related functions.

    See hotkeys for information about hotkeys in Houdini.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def assignments(hotkey_symbol: str) -> Tuple[str,...]: ...
    @staticmethod
    def assignmentsAsTuples(context: str, command: str, resolve_refs: bool = True) -> Tuple[Tuple[str, ...], ...]: ...
    @staticmethod
    def hotkeyDescription(hotkey_symbol: str) -> str:
        '''

        hotkeyDescription(hotkey_symbol) -> str

            Returns the long description/help for a the given symbol string.

          > desc = hou.hotkeys.hotkeyDescription(\\"h.open\\")
          > # \\"Open a file\\"

        '''
    @staticmethod
    def hotkeyLabel(hotkey_symbol: str) -> str:
        '''

        hotkeyLabel(hotkey_symbol) -> str

            Return the human-readable label for a symbol string.


            hotkey_symbol
                The target hotkey symbol name.

          > label = hou.hotkeys.hotkeyLabel(\\"h.open\\")
          > # \\"Open\\"

        '''
    @staticmethod
    def isKeyMatch(key: str, hotkey_symbol: str) -> bool:
        """

        isKeyMatch(key, hotkey_symbol) -> bool

            Return True is key is a match for the given hotkey symbol. If key is
            a keyvoard shortcut string then it must match one of the keyboard
            shortcuts assigned to the hotkey. If key is a hotkey symbol then it
            must be a string match to hotkey_symbol.


            key
                Either a keyboard sequence string or a hotkey symbol. This is
                typically something given to us by an event processing system
                which would either know the hotkey invoked (like when a button
                is clicked) or just the key sequence pressed.

            hotkey_symbol
                The hotkey to check for a match against.


        """
    @staticmethod
    def isKeycodeMatch(key_code: int, hotkey_symbol: str) -> bool:
        """

        isKeycodeMatch(key_code, hotkey_symbol) -> bool

            Return True is keycode is a match for the given hotkey symbol.


            key_code
                A keycode from a keyboard event.

            hotkey_symbol
                The hotkey to check for a match against.


        """
    @staticmethod
    def findConflicts(context: str, hotkey_symbol: str, key: str|None = ...) -> Tuple[str,...]:
        '''

        findConflicts(context, symbol, key) -> tuple of str

            Returns a sequence of symbol strings in ancestor and/or descendant
            contexts relative to the given context (including the symbol you
            passed in itself) that use the given key. This lets you see existing
            or potential conflicts. The returned strings are encoded as
            <context>?<symbol>.

            This function also has a deprecated signature without the context
            argument. The deprecated signature should not be used unless use of
            the old hotkey system has been forced with an environment variable.
            Under the old hotkey system, the returned strings are simply the
            symbols.

            An example of a conflict would be if a high level action (for
            example, h.copy, in the h context) has hotkey [Ctrl + C], and a
            lower-level action (for example,
            h.panes.gview.state.sop.demo.duplicate in the
            h.panes.gview.state.sop.demo context) also uses [Ctrl + C], then
            where you\'re in that state, the higher-level Copy key won\'t be
            available because it\'s overridden by the lower-level key.

          > # Find potential conflicts with K on the top-level Add Keyframe command
          > symbols = hou.hotkeys.findConflicts(\\"h\\", \\"h.add_key\\", \\"k\\")
          > # Returns (\'h.pane.gview.state.sop.topobuild?h.pane.gview.state.sop.topobuild.bridge\', \'h?h.add_key\'),
          > # meaning K is assigned to both h.add_key and
          > # h.pane.gview.state.sop.topobuild.bridge
          > # in the same hierarchy
          > 
          > # Find potential conflicts with Ctrl + C on the top-level Copy command
          > symbols = hou.hotkeys.findConflicts(\\"h.copy\\", \\"ctrl+c\\")  # (Use cmd+c on Mac)
          > # Returns (\\"h.copy\\",) meaning there are no conflicts (the symbol
          > # you checked is the only symbol in that hierarchy using that key)

        '''
    @staticmethod
    def resolveAssignments(contexts: Sequence[str], hotkey_symbols: Sequence[str]) -> Tuple[Tuple[str, ...], ...]:
        '''

        resolveAssignments(self, contexts, hotkey_symbols) -> tuple of tuple of
        str

            Return a tuple of strings that represent the hotkeys that will
            invoke each action from a tuple of hotkey symbols when resolved
            against a specific list of hotkey contexts. The key strings are of
            the form returned by the hou.ui.hotkeys method, which is a
            combination of the symbol on the key, and any modifier keys
            involved, such as \\"Ctrl+Shift+G\\".


        '''
    @staticmethod
    def changeIndex() -> int:
        """

        changeIndex() -> int

            Return the monotonically increasing change index from the hotkey
            manager. This number increases by one whenever any change is made to
            the hotkey manager. If a module is caching any information from the
            hotkey manager it should check this change index to see if any
            changes have been made and thus the cache should be refreshed.


        """
    @staticmethod
    def commandsInContext(context: str) -> Tuple[dict[str, str], ...]:
        """

        commandsInContext(context) -> tuple of dict

            This method is deprecated under the new hotkey system. Use either
            hou.hotkeys.commandsInCategory or
            hou.hotkeys.commandBindingsInContext instead.

            Return all hotkey commands at the given parent hotkey context.

            Each command is a dict with the following keys: symbol, label, and
            help.


            context
                The hotkey symbol of the context.


        """
    @staticmethod
    def contextsInContext(context: str) -> Tuple[dict[str, str], ...]:
        """

        contextsInContext(context) -> tuple of dict

            Return all hotkey contexts at the given parent hotkey context.

            Each command is a dict with the following keys: symbol, label, and
            help.


            context
                The hotkey symbol of the context.


        """
    @staticmethod
    def commandCategoriesInCategory(category: str) -> Tuple[dict[str, str], ...]:
        """

        commandCategoriesInCategory(category) -> tuple of dict

            Return all hotkey command categories under the given parent hotkey
            category.

            Each category is a dict with the following keys: symbol, label, and
            help.


            category
                The symbol of the command category.


        """
    @staticmethod
    def commandsInCategory(category: str) -> Tuple[dict[str, str], ...]:
        """

        commandsInCategory(category) -> tuple of dict

            Return all hotkey commands under the given parent category.

            Each command is a dict with the following keys: symbol, label, and
            help.


            category
                The symbol of the command category.


        """
    @staticmethod
    def commandBindingsInContext(context: str) -> Tuple[dict[str, str], ...]:
        """

        commandBindingsInContext(context) -> tuple of dict

            Return all commands bound in the given hotkey context.

            Each command is a dict with the following keys: symbol, label, and
            help.


            context
                The hotkey symbol of the context.


        """
    @staticmethod
    def addCommand(hotkey_symbol: str, label: str, description: str, assignments: Sequence[str]) -> bool:
        '''

        addCommand(hotkey_symbol, label, description, assignments) -> bool

            This method is deprecated. Use hou.hotkeys.installDefinitions
            instead.

            Registers a new configurable hotkey command with Houdini. The
            context it belongs to should already exist, see
            hou.hotkeys.addContext.

            A hotkey symbol represents an action, for example deleting the
            selected geometry when a certain tool is active. The user can change
            the actual key assigned to the action using the hotkey editor. After
            registering the symbol you can programmatically assign a default key
            using hou.hotkeys.addAssignment.

            To add a delete action to the demo python state, you would do
            something like this:

          > # Add a hotkey context for the demo python state
          > demo_context = \\"h.pane.gview.state.sop.demo\\"
          > hou.hotkeys.addContext(demo_context, \\"demo Operation\\", \\"These keys apply to the demo operations\\")
          > 
          > # Add hotkeys to the \\"demo\\" state
          > delete_symbol = demo_context + \\".delete\\"
          > hou.hotkeys.addCommand(
          >     delete_symbol,
          >     \\"Delete Selected\\",
          >     \\"Delete the selected geometry\\"
          > )
          > commit_symbol = demo_context + \\".commit\\"
          > hou.hotkeys.addCommand(
          >     commit_symbol,
          >     \\"Commit Changes\\",
          >     \\"Save changes to parameters and start a new cache\\"
          > )
          > cancel_symbol = demo_context + \\".cancel\\"
          > hou.hotkeys.addCommand(
          >     cancel_symbol,
          >     \\"Cancel Changes\\",
          >     \\"Discard any  changes and return to an empty cache\\"
          > )

            hotkey_symbol
                A string containing a full dotted hotkey symbol.

            label
                A human readable title for the action. For example, Delete
                Selected.

            description
                A human readable description of the action. This should
                generally be one to three sentences of help text for the action.

            assignments
                An optional list of shortcut strings to be used as the default
                assignments for this command.


        '''
    @staticmethod
    def addContext(hotkey_symbol: str, label: str, description: str) -> bool:
        """

        addContext(hotkey_symbol, label, long_description ) -> bool

            This method is deprecated. Use hou.hotkeys.installDefinitions
            instead.

            Registers a new hotkey context with Houdini. A context should be
            created before creating contexts or commands within that context.

            Currently this is only useful for adding hotkeys to Python states.


            hotkey_symbol
                A string containing a full dotted hotkey symbol representing the
                context. Currently the only useful value for hotkey_symbol is:

              > h.pane.gview.state.sop

            label
                A human readable title for the context. For example, Demo State
                Operation.

            description
                A human readable description of the context. This should
                generally be one to three sentences of help text for the action.


        """
    @staticmethod
    def installDefinitions(definitions: PluginHotkeyDefinitions) -> None:
        """

        uninstallDefinitions(definitions)

            Uninstalls any command categories, commands, binding contexts and
            default bindings used by a plugin.


            definitions
                A populated hou.PluginHotkeyDefinitions object that was
                previously used to install the definitions with
                hou.hotkeys.installDefinitions().


        """
    @staticmethod
    def uninstallDefinitions(definitions: PluginHotkeyDefinitions) -> None: ...
    @staticmethod
    def addCommandBinding(context: str, command: str) -> bool:
        """

        addCommandBinding(context, command) -> bool

            Adds a binding for command in context so that it appears in the
            hotkey manager for key assignment if one does not already exist.
            Keys can then be assigned to this binding via
            hou.hotkeys.addAssignment. It is not necessary to do this prior to
            adding assignments, but if you want to create an empty binding
            without any assigned keys, use this.


            context
                The hotkey context in which to create the binding.

            command
                The hotkey command to bind in the given context.


        """
    @staticmethod
    def removeCommandBinding(context: str, command: str) -> bool:
        """

        removeCommandBinding(context, command) -> bool

            Removes the binding for command from context. Note that in most
            cases you probably want remove all key assignments from the binding,
            leaving the binding itself in place. See
            hou.hotkeys.clearAssignments.


            context
                The hotkey context from which to remove the binding.

            command
                The hotkey command to unbind from the given context.


        """
    @staticmethod
    def removeHotkeySymbol(hotkey_symbol: str) -> None:
        '''

        removeHotkeySymbol(hotkey_symbol)

            This method is deprecated. Use hou.hotkeys.uninstallDefinitions
            instead.

            Removes an existing hotkey previously created with .


            hotkey_symbol
                A string containing a full dotted hotkey symbol.

                Currently this is only useful for removing hotkeys of Python SOP
                states, so symbol will be in the form:

                h.pane.gview.state.sop.<state_name>.<action_name>

          > hou.hotkeys.removeHotkeySymbol(\\"h.pane.gview.state.sop.demo.delete\\")

        '''
    @staticmethod
    def hotkeySymbol(english_context: str, english_command: Optional[str] = None) -> str:
        '''

        hotkeySymbol(context_label_path, command_label=None) -> str or None

            Does a reverse-lookup to retrieve the hotkey symbol given the human-
            readable context label(s). If you supply only a context label, the
            function returns the context\'s prefix symbol. If you also supply a
            command label, the function returns the command\'s hotkey symbol.


            context_label_path
                A string containing a path through the hierarchy of human-
                readable context labels, starting with and separated by slashes.
                For example, \\"/Houdini/Panes/Geometry Viewers\\".

            command_label
                An optional human-readable command label, for example \\"Box
                Selection\\".

          > hou.hotkeys.hotkeySymbol(\\"/Houdini/Panes/Geometry Viewers\\", \\"Box Selection\\")
          > # \\"h.pane.gview.selectstylebox\\"

        '''
    @staticmethod
    def clearAssignments(context: str, hotkey_symbol: str = ...) -> bool:
        '''

        clearAssignments(context, hotkey_symbol) -> bool

            Removes any keys assigned to a hotkey symbol in the given context.

          > hou.hotkeys.clearAssignments(\\"h.pane.gview.state.sop.demo\\", \\"h.pane.gview.state.sop.demo.delete\\")

            context
                The hotkey context in which to clear the asssignments.

            hotkey_symbol
                The symbol string for the action you want to remove hotkeys
                from.

            This function also has a deprecated signature without the context
            argument. The deprecated signature should not be used unless use of
            the old hotkey system has been forced with an environment variable.

            RELATED

                hou.hotkeys.addCommand


        '''
    @staticmethod
    def addAssignment(context: str, hotkey_symbol: str, key: str = ...) -> bool:
        '''

        addAssignment(context, hotkey_symbol, key) -> bool

            Assigns a key (or key combination) to a hotkey symbol in the given
            context.

          > hou.hotkeys.addAssignment(\\"h.pane.gview.state.sop.demo\\", \\"h.pane.gview.state.sop.demo.delete\\", \\"alt+k\\")
          > hou.hotkeys.addAssignment(\\"h.pane.gview.state.sop.demo\\", \\"h.pane.gview.state.sop.demo.delete\\", \\"shift+del\\")

            Returns True if the assignment succeeds, or False if the symbol is
            unknown or the key string is not valid.


            context
                The hotkey context in which to add the asssignment.

            hotkey_symbol
                The symbol string for the action you want to assign a hotkey to.

            key
                A string specifying the key (or key combination) to assign to
                the action. For example, \\"shift+del\\".

            This function also has a deprecated signature without the context
            argument. The deprecated signature should not be used unless use of
            the old hotkey system has been forced with an environment variable.


        '''
    @staticmethod
    def removeAssignment(context: str, hotkey_symbol: str, key: str = ...) -> bool:
        '''

        removeAssignment(context, hotkey_symbol, key) -> bool

            Removes a key (or key combination) from a hotkey symbol in a given
            context.

          > hou.hotkeys.removeAssignment(\\"h.pane.gview.state.sop.demo\\", \\"h.pane.gview.state.sop.demo.delete\\", \\"alt+k\\")

            context
                The target context name.

            hotkey_symbol
                The target hotkey symbol name.

            key
                The key string identifier to remove. For example, \\"shift+del\\".

            This function also has a deprecated signature without the context
            argument. The deprecated signature should not be used unless use of
            the old hotkey system has been forced with an environment variable.


        '''
    @staticmethod
    def availableKeycodes(context: str, hotkey_symbol: str, layout_keys: Sequence[str]|None = ..., modifiers: int = ...) -> Tuple[int,...]:
        """

        availableKeycodes(context, hotkey_symbol, layout_keys, modifiers=0) ->
        tuple of int

            Return all available shortcut keycodes with their conflict status
            bits set w.r.t. the specified hotkey symbol. A keycode is considered
            available if it isn't assigned to another hotkey within the given
            context.


            context
                The context to check for availability.

            hotkey_symbol
                The target hotkey symbol name.

            layout_keys
                A list of unmodified keycodes to check. If empty, the unmodified
                keycodes from a standard US keyboard will be checked.

            modifiers
                UI_KeyBindings modifier key bits to be applied. Only keycodes
                with these modifier bits are returned.

            This function also has a deprecated signature without the context
            argument. The deprecated signature should not be used unless use of
            the old hotkey system has been forced with an environment variable.


        """
    @staticmethod
    def keycodeToString(keycode: int, modifiers: int = 0) -> str:
        """

        keycodeToString(keycode, modifiers=0) -> str

            Convert a hotkeymanager keycode to a key string.


            modifiers
                UI_KeyBindings modifier key bits to be applied.


        """
    @staticmethod
    def stringToKeycode(key: str, modifiers: int = 0) -> int:
        """

        stringToKeycode(key, modifiers=0) -> int

            Convert a keystring to a hotkeymanager keycode.


            modifiers
                UI_KeyBindings modifier key bits to be applied.


        """
    @staticmethod
    def splitKeySequenceString(key: str) -> Tuple[str, ...]:
        """

        splitKeySequenceString(key) -> tuple of str

            Splits a string specifying a key sequence into its component key
            strings. If the string does not specify a valid key sequence, it
            returns a tuple of one element containing that string.


            key
                A string specifying a key sequence or key combination or
                reference to a command binding.


        """
    @staticmethod
    def revertToDefaults(context: str, hotkey_symbol: str, one_level_only: bool) -> None:
        """

        revertToDefaults(context, hotkey_symbol, one_level_only)

            Revert the specified hotkey to its defaults from the keymap.


            hotkey_symbol
                The hotkey command symbol to reset. If using the deprecated
                signature without the context argument, this can also be a
                hotkey context symbol, otherwise a value of None or an empty
                string to revert all the bindings in the context.

            one_level_only
                When False, this item and its children are all set to their
                default. When True, only this context or command is reset. This
                only has an effect for contexts since commands have no children.

            This function also has a deprecated signature without the context
            argument. The deprecated signature should not be used unless use of
            the old hotkey system has been forced with an environment variable.


        """
    @staticmethod
    def saveOverrides() -> bool:
        """

        saveOverrides() -> bool

            Save changes to the hotkeys as overrides to the current keymap.
            Changes are things that are different from their default value e.g.
            modifying a shortcut key assignment. Note that adding a new hotkey
            command with addHotkey will treat it as a new default so that it
            won't be saved unless a change is made to it after it is added.


        """
    @staticmethod
    def saveAsKeymap(name: str, path: Optional[str] = None) -> bool:
        """

        saveAsKeymap(name, path=None) -> bool

            Save the currently defined hotkeys as a keymap. This combines the
            loaded keymap with all of the defined overrides into a single new
            keymap. Returns True upon successful save.


            name
                The name of the new keymap.

            path
                Optional save path for the new keymap. If None then it will be
                saved into the user prefs dir with a filename derived from the
                keymap name.


        """
    @staticmethod
    def loadKeymap(name: str, path: Optional[str] = None) -> bool:
        """

        loadKeymap(name, path=None) -> bool

            Save the currently defined hotkeys as a keymap. This combines the
            loaded keymap with all of the defined overrides into a single new
            keymap. Returns True upon successful load.


            name
                The name of the keymap to load.

            path
                Optional path for the keymap to load. If None then it will be
                searched in the search path.


        """
    @staticmethod
    def importKeymap(name: str, path: str) -> bool:
        """

        importKeymap(name, path=None) -> bool

            Copy the specified keymap into the user preferences directory and
            save it with an appropriate name. Returns True upon successful
            import.


            name
                The new name of the keymap.

            path
                The path of the keymap to import.


        """
    @staticmethod
    def keymaps() -> Tuple[Tuple[str, str], ...]:
        """

        keymaps() -> tuple or str

            Return a list of tuples of all the keymaps found. The tuple has the
            keymap's name and path.


        """
    @staticmethod
    def currentKeymap() -> str:
        """

        currentKeymap() -> str

            Return the name of the currently loaded keymap.


        """

class ik:
    """

    hou.ik

    Module containing functions related to inverse kinematics.

    API



    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def solveFBIK(skeleton: Sequence[_ik_Skeleton], targets: Sequence[_ik_Target], iters: int = ..., tolerance: float = ..., pin_root: bool = ...) -> None:
        """

        hou.ik.solveFBIK

        Applies a full-body inverse kinematics algorithm to a skeleton.

        USAGE
          solveFBIK(skeleton, targets, iters=30, tolerance=1e-5, pin_root=False)

        This solver is equivalent to the solvefbik() VEX function.


        skeleton
            The hou.ik.Skeleton to solve. The joints' transforms will be updated
            with the solution.

        targets
            A list of hou.ik.Target specifying the goal transforms for
            particular joints. Raises hou.ValueError if any of the targets are
            not attached to a joint, or if multiple targets are attached to the
            same joint.

        iters
            The maximum number of iterations to perform. The solver may
            terminate early if the tolerance parameter is used.

        tolerance
            The tolerance to use when checking for convergence, defaults to
            1e-5. If positions converge to within this tolerance, the algorithm
            will stop. If 0, the solver will always perform exactly iters
            iterations.

        pin_root
            Specifies whether the root joint is allowed to translate.


        """
    @staticmethod
    def solvePhysFBIK(skeleton: Sequence[_ik_Skeleton], targets: Sequence[_ik_Target], com_target: _ik_Target|None = ..., iters: int = ..., damping: float = ..., tolerance: float = ...) -> None:
        """

        hou.ik.solvePhysFBIK

        Applies a full-body inverse kinematics algorithm to a skeleton, with
        optional control over the center of mass.

        USAGE
          solvePhysFBIK(skeleton, targets, com_target=None, iters=30,
          damping=0.5, tolerance=1e-5)

        This solver is equivalent to the solvephysfbik() VEX function.


        skeleton
            The hou.ik.Skeleton to solve. The joints' transforms will be updated
            with the solution.

        targets
            A list of hou.ik.Target specifying the goal transforms for
            particular joints. Raises hou.ValueError if any of the targets are
            not attached to a joint, or if multiple targets are attached to the
            same joint.

        com_target
            An optional hou.ik.Target which specifies the goal position of the
            skeleton's center of mass.

        iters
            The maximum number of iterations to perform. The solver may
            terminate early if the tolerance parameter is used.

        damping
            Damping factor for the solver. Larger values will produce more
            stable results when, for example, a target is unreachable. A value
            that is too large, however, will require more iterations to
            converge. Around 0.5 is typically a suitable initial value.

        tolerance
            The tolerance to use when checking for convergence, defaults to
            1e-5. If positions converge to within this tolerance, the algorithm
            will stop. If 0, the solver will always perform exactly iters
            iterations.


        """

class _ik_Joint:
    """

    hou.ik.Joint

    Represents a joint in an inverse kinematics skeleton.

    Joints can be created using hou.ik.Skeleton.addJoint.

    RELATED

      * hou.ik.Skeleton

      * hou.ik.Target


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def worldTransform(self) -> Matrix4:
        """

        worldTransform() -> hou.Matrix4

            Returns the joint's world space transform.


        """
    def setWorldTransform(self, xform: Matrix4) -> None:
        """

        setWorldTransform(xform)

            Sets the joint's world space transform (a hou.Matrix4).


        """
    def parent(self) -> Optional[_ik_Joint]:
        """

        parent() -> hou.ik.Joint

            Returns the joint's parent, or None for a root joint.


        """
    def setParent(self, parent: _ik_Joint) -> None: ...
    def rotationOrder(self) -> str:
        """

        rotationOrder() -> str

            Returns the joint's rotation order. See
            hou.ik.Joint.setRotationOrder.


        """
    def setRotationOrder(self, rotate_order: str) -> None:
        """

        setRotationOrder(rotate_order)

            Sets the joint's rotation order.


            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.


        """
    def rotationWeights(self) -> Vector3:
        """

        rotationWeights() -> hou.Vector3

            Returns the weights for the joint's rotation axes. See
            hou.ik.Joint.setRotationWeights.


        """
    def setRotationWeights(self, weights: Vector3) -> None:
        """

        setRotationWeights(weights)

            Sets a hou.Vector3 specifying the weight of each rotation axis.
            Given a larger relative weight, the solution will tend to be
            achieved by rotating around that axis. A weight of zero will disable
            the rotation axis.


        """
    def translationWeights(self) -> Vector3:
        """

        translationWeights() -> hou.Vector3

            Returns the weights for the joint's translation axes. See
            hou.ik.Joint.setTranslationWeights.


        """
    def setTranslationWeights(self, weights: Vector3) -> None:
        """

        setTranslationWeights(weights)

            Sets a hou.Vector3 specifying the weight of each translation axis.
            Given a larger relative weight, the solution will tend to be
            achieved by translating along that axis. A weight of zero will
            disable the translation axis. To set up an unpinned root joint, the
            root's translation weight should be non-zero (e.g. hou.Vector3(1, 1,
            1)).


        """
    def mass(self) -> float:
        """

        mass() -> float

            Returns the mass of the body attached to this joint. See
            hou.ik.Joint.setMass.


        """
    def setMass(self, mass: float) -> None:
        """

        setMass(mass)

            Sets the mass of the body attached to this joint. This is only used
            by solvers that support center of mass targets, such as
            hou.ik.solvePhysFBIK.


        """
    def localCenterOfMass(self) -> Vector3:
        """

        localCenterOfMass() -> hou.Vector3

            Returns the local space position of the body attached to this joint.
            See hou.ik.Joint.setLocalCenterOfMass.


        """
    def setLocalCenterOfMass(self, com: Vector3) -> None:
        """

        setLocalCenterOfMass(position)

            Sets the local space position of the body attached to this joint. A
            position of hou.Vector3(0, 0, 0) will position the center of mass at
            the joint's world space position. This is only used by solvers that
            support center of mass targets, such as hou.ik.solvePhysFBIK.


        """
    def rotationLimits(self) -> Tuple[Vector3, Vector3]:
        """

        rotationLimits() -> (hou.Vector3, hou.Vector3)

            Returns the lower and upper rotation limits (in radians) for the
            joint, relative to the rest transform. If
            hou.ik.Joint.hasRotationLimits() is False, (None, None) is returned.


        """
    def setRotationLimits(self, lower: Vector3, upper: Vector3) -> None:
        """

        setRotationLimits(lower, upper)

            Sets the lower and upper rotation limits (a hou.Vector3 in radians)
            for the joint.


        """
    def translationLimits(self) -> Tuple[Vector3, Vector3]:
        """

        translationLimits() -> (hou.Vector3, hou.Vector3)

            Returns the lower and upper translation limits for the joint,
            relative to the rest transform.


        """
    def setTranslationLimits(self, lower: Vector3, upper: Vector3) -> None:
        """

        setTranslationLimits(lower, upper)

            Sets the lower and upper translation limits for the joint.


        """
    def restTransform(self) -> Matrix4:
        """

        restTransform() -> hou.Matrix4

            Returns the joint's rest pose, or None if it has not been set.


        """
    def setRestTransform(self, xform: Matrix4) -> None:
        """

        setRestTransform(xform)

            Sets a local space hou.Matrix4 specifying the joint's rest pose. If
            not specified, the identity transform is used.

            The solver will attempt to maintain this local transform based on
            the rest rotation weights and rest translation weights. This has a
            priority lower than any of the end effector targets.

            Additionally, joint limits are enforced relative to this rest
            transform.


        """
    def restRotationWeights(self) -> Vector3:
        """

        restRotationWeights() -> hou.Vector3

            Returns the rest weights for the joint's rotation axes. See
            hou.ik.Joint.setRestRotationWeights.


        """
    def setRestRotationWeights(self, weights: Vector3) -> None:
        """

        setRestRotationWeights(weights)

            Sets a hou.Vector3 specifying how strongly the solver attempts to
            match the rest transform for the rotation axes. A value of 0.1 is
            typically a suitable value when enabling this behavior, and a value
            of 0 will disable the constraint. The default value is {0,0,0}.


        """
    def restTranslationWeights(self) -> Vector3:
        """

        restTranslationWeights() -> hou.Vector3

            Returns the rest weights for the joint's translation axes. See
            hou.ik.Joint.setRestTranslationWeights.


        """
    def setRestTranslationWeights(self, weights: Vector3) -> None:
        """

        setRestTranslationWeights(weights)

            Sets a hou.Vector3 specifying how strongly the solver attempts to
            match the rest transform for the translation axes. A value of 0.1 is
            typically a suitable value when enabling this behavior, and a value
            of 0 will disable the constraint. The default value is {0,0,0}.


        """

class _ik_Skeleton:
    """

    hou.ik.Skeleton

    Represents a skeleton for use with inverse kinematics solvers.

    RELATED

      * hou.ik.Joint


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        hou.ik.Skeleton

        Represents a skeleton for use with inverse kinematics solvers.

        RELATED

          * hou.ik.Joint


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def addJoint(self, world_transform: Matrix4 = ..., parent: _ik_Joint|None = ..., rotation_weights: Vector3 = ..., translation_weights: Vector3 = ..., mass: float = ..., local_com: Vector3 = ...) -> _ik_Joint:
        """

        addJoint(self, world_transform=hou.Matrix4(1.0), parent=None,
        rotation_weights=hou.Vector3(1,1,1),
        translation_weights=hou.Vector3(0,0,0), mass=1.0,
        local_com=hou.Vector3(0,0,0)) -> hou.ik.Joint

            Appends a new joint to the skeleton.


            world_transform
                See hou.ik.Joint.setWorldTransform

            parent
                See hou.ik.Joint.setParent

            rotation_weights
                See hou.ik.Joint.setRotationWeights

            translation_weights
                See hou.ik.Joint.setTranslationWeights

            mass
                See hou.ik.Joint.setMass

            local_com
                See hou.ik.Joint.setLocalCenterOfMass


        """
    def joints(self) -> Iterator[_ik_Joint]:
        """

        joints(self) -> tuple of hou.ik.Joint

            Returns a list of the joints in the skeleton. The list follows the
            order in which the joints were added to the skeleton.


        """
    def centerOfMass(self) -> Vector3:
        """

        centerOfMass() -> hou.Vector3

            Returns the world space position of the skeleton's center of mass.
            This is computed from the mass, center of mass, and world transform
            of each joint.


        """

class _ik_Target:
    """

    hou.ik.Target

    Represents a position or orientation target for inverse kinematics
    solvers.

    RELATED

      * hou.ik.Joint

      * hou.ik.targetType


    """
    thisown: Incomplete
    def __init__(self, joint: _ik_Joint|None = ..., goal_transform: Matrix4 = ..., joint_offset: Matrix4 = ..., target_type: EnumValue = ..., weight: float = ..., priority: int = ..., depth: int = ...) -> None:
        """

        __init__(joint=None, goal_transform=hou.Matrix4(1.0),
        joint_offset=hou.Matrix4(1.0), target_type=hou.ik.targetType.Position,
        weight=1.0, priority=0, depth=-1)

            Creates a new target.


            joint
                See hou.ik.Target.setJoint.

            goal_transform
                See hou.ik.Target.setGoalTransform.

            joint_offset
                See hou.ik.Target.setJointOffset.

            target_type
                See hou.ik.Target.setTargetType.

            weight
                See hou.ik.Target.setWeight.

            priority
                See hou.ik.Target.setPriority.

            depth
                See hou.ik.Target.setDepth.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def joint(self) -> _ik_Joint:
        """

        joint() -> hou.ik.Joint

            Returns the joint that the target is attached to, or None.


        """
    def setJoint(self, joint: _ik_Joint) -> None:
        """

        setJoint(joint)

            Sets the hou.ik.Joint that the target is attached to. This may be
            None if, for example, the target defines a goal position for the
            skeleton's center of mass.


        """
    def goalTransform(self) -> Matrix4:
        """

        goalTransform() -> hou.Matrix4

            Returns the world space goal transform.


        """
    def setGoalTransform(self, xform: Matrix4) -> None:
        """

        setGoalTransform(xform)

            Sets the target world space transform (a hou.Matrix4) for the joint.


        """
    def jointOffset(self) -> Matrix4:
        """

        jointOffset() -> hou.Matrix4

            Returns the local space joint offset transform. See
            hou.ik.Target.setJointOffset.


        """
    def setJointOffset(self, offset: Matrix4) -> None:
        """

        setJointOffset(xform)

            Sets a local space transform (a hou.Matrix4) that is combined with
            the joint transform to produce the transform that the solver
            attempts to align with the goal transform. This can be used to place
            the target at an offset from the joint (for example, at the end of a
            bone).


        """
    def targetType(self) -> EnumValue:
        """

        targetType() -> hou.ik.targetType

            Returns the target's type. See hou.ik.Target.setTargetType.


        """
    def setTargetType(self, target_type: EnumValue) -> None:
        """

        setTargetType(target_type)

            Sets a hou.ik.targetType, which specifies whether the target affects
            position, orientation, or both.


        """
    def weight(self) -> float:
        """

        weight() -> float

            Returns the target's weight. See hou.ik.Target.setWeight.


        """
    def setWeight(self, weight: float) -> None:
        """

        setWeight(weight)

            Sets a float specifying the importance of the target. When multiple
            targets have the same priority level, targets with a higher relative
            weight are more likely to be reached.


        """
    def priority(self) -> int:
        """

        priority() -> int

            Returns the target's priority level. See hou.ik.Target.setPriority.


        """
    def setPriority(self, level: int) -> None:
        """

        setPriority(priority)

            Sets an int specifying the target's priority level. Targets from a
            lower priority level cannot interfere with targets from a higher
            priority level. For example, priority levels can be used to ensure
            that the feet remain planted when manipulating the upper body of a
            skeleton.


        """
    def depth(self) -> int:
        """

        depth() -> int

            Returns the target's depth. See hou.ik.Target.setDepth.


        """
    def setDepth(self, depth: int) -> None:
        """

        setDepth(depth)

            Specifies the number of parent joints that can be adjusted to
            achieve the goal transform. A negative depth indicates that the
            entire chain can be affected.


        """

class ImageLayer:
    """

    hou.ImageLayer

    An ImageLayer object contains the pixels that define a 2D image layer.
    For example, COP nodes in Houdini can generate multiple ImageLayer
    objects.

    If you ask a COP for its geometry via the hou.CopNode.layer, you'll cook
    the COP and get a read-only hou.ImageLayer. Unlike with SOPs and
    Geometry objects, the result is no longer tied to the COP Node so it
    stays the same if the COP node recooks or is deleted.

    Call hou.ImageLayer.freeze to edit an ImageLayer. This returns another
    ImageLayer object that's an independent writeable copy. Writing to the
    frozen layer doesn't affect the earlier read-only versions.


    """
    thisown: Incomplete
    def __init__(self, layer: Optional[ImageLayer] = None) -> None:
        """

        hou.ImageLayer

        An ImageLayer object contains the pixels that define a 2D image layer.
        For example, COP nodes in Houdini can generate multiple ImageLayer
        objects.

        If you ask a COP for its geometry via the hou.CopNode.layer, you'll cook
        the COP and get a read-only hou.ImageLayer. Unlike with SOPs and
        Geometry objects, the result is no longer tied to the COP Node so it
        stays the same if the COP node recooks or is deleted.

        Call hou.ImageLayer.freeze to edit an ImageLayer. This returns another
        ImageLayer object that's an independent writeable copy. Writing to the
        frozen layer doesn't affect the earlier read-only versions.


        """
    __swig_destroy__: Incomplete
    def __enter__(self) -> Optional[ImageLayer]: ...
    def __exit__(self, type: Any, value: Any, traceback: Any) -> None: ...
    def close(self) -> None:
        """

        close(self)

            Resets this object to be an empty object. This stops it holding a
            reference to the underlying ImageLayer data. This will also happen
            when the object goes out of scope and is garbage collected, but the
            close() provides exact control over the timing.

            ImageLayers also support contexts so the with statement can be used
            to auto-close the nanovdb at the with-block end.


        """
    def storageType(self) -> EnumValue:
        """

        storageType(self) -> hou.imageLayerStorageType enum value

            Returns the layer's storage type, which consists of its precision
            and float vs integer type.


        """
    def border(self) -> EnumValue:
        """

        border(self) -> hou.imageLayerBorder enum value

            Returns the layer's border type.


        """
    def typeInfo(self) -> EnumValue:
        """

        typeInfo(self) -> hou.imageLayerTypeInfo enum value

            Returns the semantic type of the layer. This is used for things like
            automatic visualizations.


        """
    def setStorageType(self, storagetype: EnumValue) -> None:
        """

        setStorageType(self, storagetype)

            Changes the storage type of the layer. Existing data will be lost.

            Requires a writable layer.


        """
    def setBorder(self, storagetype: EnumValue) -> None:
        """

        setBorder(self, storagetype)

            Changes the border of the layer.

            Requires a writable layer.


        """
    def setTypeInfo(self, storagetype: EnumValue) -> None:
        """

        setTypeInfo(self, storagetype)

            Changes the semantic type of the layer.

            Requires a writable layer.


        """
    def channelCount(self) -> int:
        """

        channelCount(self) -> int

            Returns the number of channels in the layer.


        """
    def setChannelCount(self, chan: int) -> None:
        """

        setChannelCount(self, chan)

            Changes the number of channels in the layer. Existing data will be
            lost. Must be within 1 and 4.

            Requires a writable layer.


        """
    def bufferResolution(self) -> Tuple[int, ...]:
        """

        bufferResolution(self) -> tuple of int

            Returns the underlying buffer size. This is the number of data
            elements in the X and Y directions. When PixelScale is 1, this
            corresponds to the number of pixels.


        """
    def onCPU(self) -> bool:
        """

        onCPU(self) -> bool

            An ImageLayer may be stored on the CPU or GPU. This is true if it is
            stored on the CPU.


        """
    def onGPU(self) -> bool:
        """

        onGPU(self) -> bool

            An ImageLayer may be stored on the CPU or GPU. This is true if it is
            stored on the GPU.


        """
    def isConstant(self) -> bool:
        """

        isConstant(self) -> bool

            True if the layer is compressed as a single constant value. Note
            that a layer that has all the same values will not necessarily
            return True, as this only detects if it has been collapsed to a
            single constant value.


        """
    def storesIntegers(self) -> bool:
        """

        storesIntegers(self) -> bool

            True if the layer holds integer data.


        """
    def makeConstant(self, val: Sequence[float]) -> None:
        """

        makeConstant(self, val)

            Collapse the layer into a single constant value of the value
            provided. Value should be a tuple which will be extended to the
            required number of channels.

            Requires a writable layer.


        """
    def dataWindow(self) -> BoundingRect:
        """

        dataWindow(self) -> hou.BoundingRect

            Return the data window. This is the area, in pixels, that the buffer
            elements cover.


        """
    def displayWindow(self) -> BoundingRect:
        """

        displayWindow(self) -> hou.BoundingRect

            Return the display window. This is the area, in pixels, that is
            framed to Image space.


        """
    def pixelAspectRatio(self) -> float:
        """

        pixelAspectRatio(self) -> float

            The ratio Image space coordinates and pixel coordinates.


        """
    def pixelScale(self) -> Tuple[float, ...]:
        """

        pixelScale(self) -> tuple of float

            The scaling factor between the pixel values and the underlying
            buffer elements. This is the number of pixels in each dimension that
            fit in a buffer element. Thus (2,2) would create one buffer element
            for every 2x2 block of pixels.


        """
    def setDataWindow(self, x: int, y: int, w: int, h: int) -> None:
        """

        setDataWindow(self, x, y, w, h)

            Set the buffer to cover the provided pixels. The actual size of the
            buffer will vary according to pixel scale. If pixel scale is 1, w
            and h will be the resolution. Existing data will be lost.

            This requires a writable layer.


        """
    def setDisplayWindow(self, x: float, y: float, w: float, h: float) -> None:
        """

        setDisplayWindow(self, x, y, w, h)

            Set the area in pixels that're framed by the Image space conversion.

            This requires a writable layer.


        """
    def setPixelAspectRatio(self, aspect: float) -> None:
        """

        setPixelAspectRatio(self, aspect)

            Set the ratio between pixel space and image space.

            This requires a writable layer.


        """
    def setPixelScale(self, scale: Sequence[float]) -> None:
        """

        setPixelScale(self, scale)

            Set the scaling between buffer space and pixel space.

            This requires a writable layer.


        """
    def projection(self) -> EnumValue:
        """

        projection(self) -> hou.imageLayerProjection

            Returns the style of projection performed by the layer's implicit
            camera.


        """
    def aperture(self) -> float:
        """

        aperture(self) -> float

            Returns the width of the camera aperture, nominally in mm, but most
            importantly in the same units as focalLength.


        """
    def focalLength(self) -> float:
        """

        focalLength(self) -> float

            Returns the focal length of the camera, nominally in mm, but most
            importantly in the same units as aperture.


        """
    def cameraPosition(self) -> Tuple[float, ...]:
        """

        cameraPosition(self) -> tuple of float

            The location of the projection point of the camera as measured from
            the center of image space.


        """
    def fStop(self) -> float:
        """

        fStop(self) -> float

            The camera's FStop.


        """
    def clippingRange(self) -> Tuple[float, ...]:
        """

        clippingRange(self) -> tuple of float

            The clipping range of the layer's camera.


        """
    def focusDistance(self) -> float:
        """

        focusDistance(self) -> float

            The location of the focus plane of the camera.


        """
    def shutter(self) -> Tuple[float, ...]:
        """

        shutter(self) -> tuple of float

            The duration of the camera's shutter. This is measured relative to a
            nominal zero point.


        """
    def setProjection(self, projection: EnumValue) -> None:
        """

        setProjection(self, projection)

            Change the projection type of the camera.


        """
    def setAperture(self, aperture: float) -> None:
        """

        setAperture(self, aperture)

            Set the camera's aperture.


        """
    def setFocalLength(self, focal: float) -> None:
        """

        setFocalLength(self, focal)

            Set the camera's focal length.


        """
    def setCameraPosition(self, pos: Sequence[float]) -> None:
        """

        setCameraPosition(self, pos)

            Adjust the position of the focus point of the camera, as measured in
            the image space of the layer.


        """
    def setFStop(self, fstop: float) -> None:
        """

        setFStop(self, fstop)

            Set the camera's FStop.


        """
    def setClippingRange(self, range: Sequence[float]) -> None:
        """

        setClippingRange(self, range)

            Set the camera's near/far clipping range.


        """
    def setFocusDistance(self, focus: float) -> None:
        """

        setFocusDistance(self, focus)

            Set the camera's focus distance.


        """
    def setShutter(self, shutter: Sequence[float]) -> None:
        """

        setShutter(self, shutter)

            Set the camera's shutter.


        """
    def projectionTransform(self) -> Matrix4:
        """

        projectionTransform(self) -> hou.Matrix4

            Compute the transform from world space to image space, including the
            camera's projection.


        """
    def imageToWorldTransform(self) -> Matrix4:
        """

        imageToWorldTransform(self) -> hou.Matrix4

            Compute the non-projective transform from image space to world
            space.


        """
    def imageToPixelScale(self) -> Tuple[float, ...]:
        """

        imageToPixelScale(self) -> tuple of float

            Return the scale factor from image space to pixel space.


        """
    def imageToPixelTranslate(self) -> Tuple[float, ...]:
        """

        imageToPixelTranslate(self) -> tuple of float

            Return the offset from image space to pixel space.


        """
    def imageToBufferScale(self) -> Tuple[float, ...]:
        """

        imageToBufferScale(self) -> tuple of float

            Return the scale factor from image space to buffer space.


        """
    def imageToBufferTranslate(self) -> Tuple[float, ...]:
        """

        imageToBufferTranslate(self) -> tuple of float

            Return the offset from image space to buffer space.


        """
    def bufferToPixelScale(self) -> Tuple[float, ...]:
        """

        bufferToPixelScale(self) -> tuple of float

            Return the scale factor from buffer space to pixel space.


        """
    def bufferToPixelTranslate(self) -> Tuple[float, ...]:
        """

        bufferToPixelTranslate(self) -> tuple of float

            Return the offset from buffer space to pixel space.


        """
    def textureToBufferScale(self) -> Tuple[float, ...]:
        """

        textureToBufferScale(self) -> tuple of float

            Return the scale factor from texture space to buffer space.


        """
    def imageToPixel(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        imageToPixel(self, p) -> tuple of float

            Convert a 2-tuple from image space to pixel space.


        """
    def imageToBuffer(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        imageToBuffer(self, p) -> tuple of float

            Convert a 2-tuple from image space to buffer space.


        """
    def imageToTexture(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        imageToTexture(self, p) -> tuple of float

            Convert a 2-tuple from image space to texture space.


        """
    def pixelToImage(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        pixelToImage(self, p) -> tuple of float

            Convert a 2-tuple from pixel space to image space.


        """
    def pixelToBuffer(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        pixelToBuffer(self, p) -> tuple of float

            Convert a 2-tuple from pixel space to buffer space.


        """
    def pixelToTexture(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        pixelToTexture(self, p) -> tuple of float

            Convert a 2-tuple from pixel space to texture space.


        """
    def bufferToPixel(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        bufferToPixel(self, p) -> tuple of float

            Convert a 2-tuple from buffer space to pixel space.


        """
    def bufferToImage(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        bufferToImage(self, p) -> tuple of float

            Convert a 2-tuple from buffer space to image space.


        """
    def bufferToTexture(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        bufferToTexture(self, p) -> tuple of float

            Convert a 2-tuple from buffer space to texture space.


        """
    def textureToPixel(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        textureToPixel(self, p) -> tuple of float

            Convert a 2-tuple from texture space to pixel space.


        """
    def textureToImage(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        textureToImage(self, p) -> tuple of float

            Convert a 2-tuple from texture space to image space.


        """
    def textureToBuffer(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        textureToBuffer(self, p) -> tuple of float

            Convert a 2-tuple from texture space to buffer space.


        """
    def worldToBuffer(self, p: Sequence[float]) -> Tuple[float, ...]:
        """

        worldToBuffer(self, p) -> tuple of float

            Convert a 3-tuple from world space to buffer space.


        """
    def bufferIndexV4(self, x: int, y: int) -> Tuple[float, ...]:
        """

        bufferIndexV4(self, int x, int y) -> tuple of float

            Returns a layer's RGBA value at the buffer coordinate (x, y).


        """
    def bufferIndexI(self, x: int, y: int) -> int:
        """

        bufferIndexI(self, int x, int y) -> int

            Returns an integer layer's value at the buffer coordinate (x, y).


        """
    def bufferIndex(self, x: int, y: int) -> Any:
        """

        bufferIndex(self, int x, int y) -> tuple of float | float | int

            Returns a layer's value at the buffer coordinate (x, y). The return
            type corresponds to the layer type, for example a mono layer returns
            a single float value.


        """
    def bufferIndexRaw(self, x: int, y: int) -> bytes:
        """

        bufferIndexRaw(self, int x, int y) -> bytes

            Returns a layer's raw bytes at the buffer coordinate (x, y).


        """
    def freeze(self) -> Optional[ImageLayer]:
        """

        freeze(self) -> hou.ImageLayer

            Create a writable copy of this and return it.


            NOTE
                The actual buffer duplication won't be done until a write is
                performed.


        """
    def isFrozen(self) -> bool:
        """

        isFrozen(self) -> bool

            Returns if this is frozen, and hence writable.


        """
    def attributes(self) -> dict[str, Any]:
        """

        attributes(self) -> dict

            Returns the layer attributes present on this layer.


        """
    def setAttributes(self, p: dict[str, Any]) -> None:
        """

        setAttributes(self, p)

            Replaces the layer attributes with the provided dictionary.


        """
    def updateAttributes(self, p: dict[str, Any]) -> None:
        """

        updateAttributes(self, p)

            Updates the layer attributes with the provided dictionary, replacing
            any matching keys.


        """
    def allBufferElements(self, *args) -> bytes:
        """

        allBufferElements(self, storagetype, channels) -> hou.BinaryString

            Return all the buffer elements as a binary string. This can then be
            effeciently re-interpreted and handled by numpy or tensor packages.
            The number of elements is the same as the bufferResolution. The bit
            depth and channels returned will match those provided, a conversion
            will be performed just-in-time if they differ from the internal
            layout.


        """
    def setAllBufferElements(self, *args) -> None:
        """

        setAllBufferElements(self, values, length)

            Take a binary string in values and replace all of the buffer
            elements of this layer with them. The binary string must have a
            number of elements matching the bufferResolution and be of the same
            storagetype and channels as this layer.


        """

class IndexPairPropertyTable:
    """

    hou.IndexPairPropertyTable

    Describes properties of an index pair attribute.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def attrib(self) -> Attrib:
        """

        attrib(self) -> hou.Attrib

            Return the parent index pair attribute.


        """
    def numIndices(self) -> int: ...
    def propertyNames(self) -> Tuple[str, ...]:
        """

        propertyNames(self) -> tuple of string

            Return a list of all property names.


        """
    def propertyDataType(self, prop_name: str) -> EnumValue:
        """

        propertyDataType(self, property_name) -> hou.attribData enum value

            Return the property's data type (int, float or string).


        """
    def propertySize(self, prop_name: str) -> int:
        """

        propertySize(self, property_name) -> int

            Return the number of data components in the property value.


        """
    def floatPropertyValueAtIndex(self, prop_name: str, idx: int) -> float:
        """

        floatPropertyValueAtIndex(self, property_name, row) -> float

            Return the property value for a particular floating point property.

            Raises hou.OperationFailed if no property exists with this name or
            the property is not float of size 1.


        """
    def floatListPropertyValueAtIndex(self, prop_name: str, idx: int) -> Tuple[float, ...]:
        """

        floatListPropertyValueAtIndex(self, property_name, row) -> tuple of
        float

            Return a list of property values for a particular floating point
            property.

            Raises hou.OperationFailed if no property exists with this name.


        """
    def intPropertyValueAtIndex(self, prop_name: str, idx: int) -> int:
        """

        intPropertyValueAtIndex(self, property_name, row) -> int

            Return the property value for a particular integer property.

            Raises hou.OperationFailed if no property exists with this name or
            the property is not integer of size 1.


        """
    def intListPropertyValueAtIndex(self, prop_name: str, idx: int) -> Tuple[int, ...]:
        """

        intListPropertyValueAtIndex(self, property_name, row) -> tuple of int

            Return a list of property values for a particular integer property.

            Raises hou.OperationFailed if no property exists with this name.


        """
    def stringPropertyValueAtIndex(self, prop_name: str, idx: int) -> str:
        """

        stringPropertyValueAtIndex(self, property_name, row) -> string

            Return the property value for a particular string property.

            Raises hou.OperationFailed if no property exists with this name or
            the property is not string of size 1.


        """
    def stringListPropertyValueAtIndex(self, prop_name: str, idx: int) -> Tuple[str, ...]:
        """

        stringListPropertyValueAtIndex(self, property_name, row) -> tuple of
        string

            Return a list of property values for a particular string property.

            Raises hou.OperationFailed if no property exists with this name.


        """

class IndirectInput(NetworkMovableItem):
    """

    hou.IndirectInput

    An abstract base class for a network item that can be used as an input
    to nodes in the same network, but which is not a node itself.

    There are two specific forms of an indirect input. The
    hou.SubnetIndirectInput provides a way to connect nodes outside a sub-
    network to nodes inside the sub-network. The hou.NetworkDot allows
    connections to be routed through a network along any path.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def outputs(self) -> Tuple[Node, ...]:
        """

        outputConnections(self) -> tuple of hou.NodeConnection

            Return a tuple of objects representing each connection to a node
            from the output of this object. The objects returned by this method
            allow you to discover not just which nodes are connected to this
            object, but which inputs it feeds into.


        """
    def outputConnections(self) -> Tuple[NodeConnection, ...]: ...
    def input(self) -> Optional[Node]: ...
    def inputOutputIndex(self) -> int: ...
    def inputItem(self) -> Optional[NetworkMovableItem]:
        """

        inputItem(self) -> hou.NetworkMovableItem

            Returns the item connected directly to the input side of this
            indirect input. This may be a node, indirect input, or None if
            nothing is connected. Note that the returned item may not be inside
            the same parent network as this object if it is a
            hou.SubnetIndirectInput.


        """
    def inputItemOutputIndex(self) -> int:
        """

        inputItemOutputIndex(self) -> int

            Returns the index of the output connection on the network item
            connected directly to the input side of this object. Returns 0 if
            nothing is connected. This value will only be non-zero if a hou.Node
            is connected to this object since all other network items only has a
            single output connector.


        """
    def setColorDefault(self) -> None:
        """

        setColorDefault(self)

            Sets the color of this object to be the default for indirect inputs.
            By explicitly setting to the default color, any future changes to
            the default indirect input color will cause this object to use the
            new color. This method clears the symbolicColorName setting and the
            useColorFromOutput setting.


        """
    def setUseColorFromOutput(self, use_output_color: bool) -> None:
        """

        setUseColorFromOutput(self, use_output_color)

            Set this indirect input to display itself with the same color as the
            first input connector connected as an output to this object. If set
            to False, this object is displayed with its color returned by the
            hou.NetworkMovableItem.setColor method. This method clears the
            symbolicColorName setting, and causes the color value to be ignored.


        """
    def useColorFromOutput(self) -> bool:
        """

        useColorFromOutput(self) -> bool

            Return True if this object will be displayed based on the color of
            the first input to which it is connected. Return False if will be
            displayed using the color return by the hou.NetworkMovableItem.color
            method.


        """
    def setSymbolicColorName(self, name: str) -> None:
        """

        setSymbolicColorName(self, name)

            Sets the color of this object to use a symbolic color name defined
            in the current Houdini color scheme (see hou.ui.colorByName). The
            symbolic color name will be saved with the hip file so that changes
            to the color scheme will result in a new color being used for this
            object. This method clears the useColorFromDefault setting, and
            causes the color value to be ignored.


        """
    def symbolicColorName(self) -> str:
        """

        symbolicColorName(self) -> str

            Return the symbolic color name used to display this object, set with
            the setSymbolicColorName method. Returns an empty string if the
            color of this object was set using the setUseColorFromOutput or
            hou.NetworkMovableItem.setColor methods. The symbolic color name can
            be converted to a hou.Color using hou.ui.colorFromName.


        """

class OpIndirectInput(IndirectInput):
    """

    hou.OpIndirectInput

    An abstract base class for an indirect input in an OP network.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class InterruptableOperation:
    '''

    hou.InterruptableOperation

    Use this class to turn any Python code block into an interruptable
    operation.

    This class is a context manager which allows the user to press [Esc] to
    interrupt a long-running operation, and can also display a progress
    percentage in the status line at the bottom of the main window.

    You should use this in potentially long-running Python nodes (such as
    Python SOP) or shelf scripts. For example if you have code looping over
    every point in the input geometry, if the geometry has millions of
    points the operation could take a long time. You should perform the
    operation inside a hou.InterruptableOperation block so the user can
    interrupt it, and so you can display progress.

    Important: The script only checks if the user has pressed Escape when
    you call the context object\'s updateProgress() method. So you need to
    add calls to updateProgress() in the block, usually at the start of each
    iteration of a loop (even if you don\'t provide a progress fraction).

    (Calling updateProgress() also gives Houdini a chance to respond to
    events, so it doesn\'t appear to be non-responsive to the operating
    system. For example, regularly calling updateProgress() prevents macOS
    from showing the beachball cursor.)

    If the user interrupts the operation, the context block will exit with a
    hou.OperationInterrupted exception. However, you may not want to catch
    the exception in your script.

      * If you don\'t catch the hou.OperationInterrupted exception in a shelf
        tool, the tool script will simply stop and Houdini will not display
        the exception to the user. If your script doesn\'t require any
        cleanup, this is usually what the user would expect.

      * If you don\'t catch the exception in a Python node (for example, a
        Python SOP), Houdini will automatically display an error on the node
        (with the error text Cooking was interrupted). Again, this is
        typical of how nodes deal with long-running operations being
        interrupted.

    To try this object out, you can create a shelf tool and paste the
    following into the tool script:

    > import time
    > import hou
    > 
    > try:
    >     with hou.InterruptableOperation(\\"Waiting around doing nothing\\") as iop:
    >         for i in range(100):
    >             # Real work would go here, instead we\'ll just go to sleep
    >             time.sleep(0.1)
    >             # In a loop or series of steps, call updateProgress() on
    >             # the context object to check for interruption. You can optionally
    >             # pass a fraction to let the user know how much is done.
    >             # (The first argument is called \\"percentage\\" but it actually takes
    >             # a fraction.)
    >             iop.updateProgress(i / 100)
    > except hou.OperationInterrupted:
    >     # The user pressed Esc (or the operation timed out if you used the
    >     # timeout_ms argument)
    >     hou.ui.displayMessage(\\"Interrupted\\")
    > else:
    >     # The operation finished without interruption
    >     hou.ui.displayMessage(\\"Completed\\")

    NESTED OPERATIONS

        You can nest multiple interruptable operations. For example:

      > # Start the overall, long operation.
      > with hou.InterruptableOperation(\\"Beginning operation\\",
      >                                 \\"Performing a Long Operation\\",
      >                                 open_interrupt_dialog=True) as iop:
      >     for i in range(num_tasks):
      >         # Update overall progress
      >         operation.updateLongProgress(i / num_tasks)
      > 
      >         # Start the sub-operation
      >         with hou.InterruptableOperation(f\\"Performing Task {i + 1}\\") as sub_iop:
      >             for j in range(num_subtasks):
      >                 # Update sub-operation progress
      >                 sub_iop.updateProgress(j / num_subtasks)
      > 
      >                 #
      >                 # PERFORM SUBTASK HERE.
      >                 #

    TIMING OUT OPERATIONS

        You can use the timeout_ms argument when you create the context
        object to limit the amount of time an operation can take.

      * Hitting the time limit raises hou.OperationInterrupted, just like
        the user pressing [Esc].

      * Just like the user pressing [Esc], the timeout is usually only
        checked when you call the updateProgress() method, so you need to
        call the method regularly inside the block.

            Some HOM functions may internally update progress, which can
            also trigger a check of the timeout. For example, you can wrap a
            call to LopNode.stagePrimStats() in a hou.InterruptableOperation
            block with a timeout, and the timeout will interrupt
            stagePrimStats() because internally stagePrimStats() updates
            Houdini as it works.

        For example, this modified version of the example would normally run
        for 10 seconds, but will display Interrupted after 1 second because
        of the timeout_ms=1000 argument:

      > import time
      > import hou
      > 
      > try:
      >     with hou.InterruptableOperation(\\"Waiting around doing nothing\\",
      >                                     timeout_ms=1000) as iop:
      >         for i in range(100):
      >             # Real work would go here, instead we\'ll just go to sleep
      >             time.sleep(0.1)
      >             iop.updateProgress(i / 100)
      > except hou.OperationInterrupted:
      >     # The user pressed Esc (or the operation timed out if you used the
      >     # timeout_ms argument)
      >     hou.ui.displayMessage(\\"Interrupted\\")
      > else:
      >     # The operation finished without interruption
      >     hou.ui.displayMessage(\\"Completed\\")

    TIPS AND NOTES

      * By default, Houdini only shows the progress as text in the status
        line. If you pass open_interrupt_dialog=True when you create the
        object, Houdini will open a progress dialog that shows progress
        using a progress bar. You should generally open a dialog if the
        operation could take more than one or two seconds.

      * The call to updateProgress() takes a small amount of time that can
        add up. Inside tight loops you may want to only call it, for
        example, every 10th iteration instead of every iteration.

      * hou.InterruptableOperation` does not work in the Python Shell. If
        you just want to try it out, use a shelf tool.

      * Houdini may not display every progress update in the status bar. It
        updates the status bar on its own schedule for performance reasons.

      * Trying to create this object outside of a with statement will raise
        hou.OperationFailed.


    '''
    thisown: Incomplete
    def __init__(self, operation_name: str, long_operation_name: Optional[str] = None, open_interrupt_dialog: bool = False, timeout_ms: int = 0) -> None:
        """

        __init__(self, operation_name, long_operation_name=None,
        open_interrupt_dialog=False, timeout_ms=0)

            Construct a new InterruptableOperation.


            operation_name
                A description of the interruptable operation that appears in the
                progress bar of the interrupt dialog.

            long_operation_name
                A description of the long, or higher-level, operation. If it is
                not None, a second progress bar appears on the interrupt dialog
                with the long operation name in it.

            open_interrupt_dialog
                Determines whether the interrupt dialog should appear or not.

            timeout_ms
                An integer value specifying the number of milliseconds an
                operation is allowed to spend before automatically being
                interrupted. The timeout is only checked when the progress is
                updated using the updateProgress or updateLongProgress methods
                (or the C++ equivalents when invoking native Houdini methods).
                Timeouts cannot be nested. A timeout set on an inner operation,
                after an outer operation already has a timeout, will be ignored.

                An interrupt triggered due to a timeout is treated exactly like
                an interrupt triggered by the user, and so may cause nodes to
                enter an interrupted error state. If you wish to avoid this
                situation, be sure to cook any nodes whose data may be required
                before starting the interruptable operation with the timeout.


        """
    __swig_destroy__: Incomplete
    def updateLongProgress(self, percentage: float = -1.0, long_op_status: Optional[str] = None) -> None:
        """

        updateLongProgress(self, percentage=-1.0, long_op_status=None)

            Update the progress percentage and status of the long, or high-
            level, operation. At the same time, check if the operation was
            interrupted by the user.


            percentage
                Despite the name, this argument takes a fraction from 0.0 to
                1.0, not a percentage. If this number is negative, Houdini will
                not display the progress.

            long_op_status
                Text describing the current status of the long operation, if
                there is one. If pass a value for this argument, it overwrites
                the text in the 2nd progress bar of the interrupt dialog.


        """
    def updateProgress(self, percentage: float = -1.0) -> None:
        """

        updateProgress(self, percentage=-1.0)

            Update the progress percentage of the operation. At the same time,
            check if the operation was interrupted by the user.


            percentage
                Despite the name, this argument takes a fraction from 0.0 to
                1.0, not a percentage. If this number is negative, Houdini will
                not display the progress.


        """
    def __enter__(self) -> InterruptableOperation: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class IntParmTemplate(ParmTemplate):
    """

    hou.IntParmTemplate

    Describes a parameter tuple containing integer values.

    Note that integer parameters may also be menu parameters. Integer
    parameters with menus are conceptually the same as parameters derived
    from hou.MenuParmTemplate.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, num_components: int, default_value: Sequence[int] = ..., min: int = ..., max: int = ..., min_is_strict=..., max_is_strict: bool = ..., look: EnumValue = ..., naming_scheme: EnumValue = ..., menu_items: Sequence[str] = ..., menu_labels: Sequence[str] = ..., icon_names: Sequence[str] = ..., item_generator_script: str|None = ..., item_generator_script_language: EnumValue|None = ..., menu_type: EnumValue = ..., disable_when: str|None = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ..., default_expression: Sequence[str] = ..., default_expression_language: Sequence[str] = ...) -> None:
        """

        __init__(self, name, label, num_components, default_value=(), min=0,
        max=10, min_is_strict=False, max_is_strict=False,
        look=hou.parmLook.Regular, naming_scheme=hou.parmNamingScheme.XYZW,
        menu_items=(), menu_labels=(), icon_names=(),
        item_generator_script=None, item_generator_script_language=None,
        menu_type=hou.menuType.Normal, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new IntParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            default_value
                See the defaultValue method for more information.

            min
                See the minValue method for more information.

            max
                See the maxValue method for more information.

            min_is_strict
                See the minIsStrict method for more information.

            max_is_strict
                See the maxIsStrict method for more information.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            menu_items
                See the menuItems method for more information. Note that
                num_components must be 1 if menu items are supplied.

            menu_labels
                See the menuLabels method for more information.

                If this parameter is not given, it defaults to the value of the
                menu_items parameter.

            icon_names
                See the iconNames method for more information.

                If this parameter is an empty tuple, the menu will not contain
                icons.

            item_generator_script
                See the itemGeneratorScript method for more information. Note
                that num_components must be 1 if a script is given.

            item_generator_script_language
                See the itemGeneratorScriptLanguage method for more information.
                If this parameter is None it defaults to
                hou.scriptLanguage.Python.

            menu_type
                See the menuType method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
    __swig_destroy__: Incomplete
    def minValue(self) -> int:
        """

        minValue(self) -> int

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
    def setMinValue(self, min_value: int) -> None:
        """

        setMinValue(self, min_value)

            Set the minimum value of the parameter.

            See the minValue method for more information.


        """
    def maxValue(self) -> int:
        """

        maxValue(self) -> int

            Return the minimum value of the parameter.

            See also the minIsStrict method.


        """
    def setMaxValue(self, max_value: int) -> None:
        """

        setMaxValue(self, max_value)

            Set the maximum value of the parameter.

            See the maxValue method for more information.


        """
    def minIsStrict(self) -> bool:
        """

        minIsStrict(self) -> bool

            Returns whether the minimum value is strictly enforced.

            If a minimum value is not strictly enforced, the slider will not let
            you change the value below the minimum, but you can set the value to
            be lower than the minimum by typing it in, changing it via
            hou.Parm.setValue, or using the ladder handle.

            If it is strictly enforced and you try to change it below the
            minimum value using any mechanism, Houdini will set it to the
            minimum value.

            See also the minValue method.


        """
    def setMinIsStrict(self, on: bool) -> None:
        """

        setMinIsStrict(self, on)

            Set whether the minimum value is strictly enforced.

            See the minIsStrict method for more information.


        """
    def maxIsStrict(self) -> bool:
        """

        maxIsStrict(self) -> bool

            Return whether the maximum value is strictly enforced.

            See the minIsStrict method for more information.


        """
    def setMaxIsStrict(self, on: bool) -> None:
        """

        setMaxIsStrict(self, on)

            Set whether the maximum value is strictly enforced.

            See the maxIsStrict method for more information.


        """
    def defaultValue(self) -> Tuple[int, ...]:
        """

        defaultValue(self) -> tuple of int

            Return the default value for new parameter instances.

            For example, suppose this parm template is named divisions, the
            naming scheme is XYZW, it has 3 components, and the default value is
            (10, 20, 30). The corresponding parm tuple instance on a node would
            be named divisions and would contain parameters divisionsx,
            divisionsy, and divisionsz. When the node is created, divisionsx
            would be 10, divisionsy would be 20, and divisionsz would be 30.


        """
    def setDefaultValue(self, default_value: Sequence[int]) -> None:
        """

        setDefaultValue(self, tuple_of_default_values)

            Set the default value for new parameter instances to a sequence of
            ints.

            See the defaultValue method for more information. Note that if the
            number of ints in the sequence is different from the number of
            components in the parm template, any extra values will be discarded
            and any missing values will become zeros.


        """
    def defaultExpression(self) -> Tuple[str, ...]:
        """

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.

            For example, suppose this parm template is named divisions, the
            naming scheme is XYZW, it has 3 components, the default value is
            (10, 20, 30), the default expression is ($F, hou.frame(), ) and the
            default expression language is (hou.scriptLanguage.Hscript,
            hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
            corresponding parm tuple instance on a node would be named divisions
            and would contain parameters divisionsx, divisionsy, divisionsz.
            When the node is created, divisionsx would have a default Hscript
            expression of $F, divisionsy would have a default Python expression
            of hou.frame(), and divisionsz would have a default value of 30.


        """
    def setDefaultExpression(self, default_expression: Sequence[str]) -> None:
        """

        setDefaultExpression(self, tuple_of_default_expressions)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.IntParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
    def defaultExpressionLanguage(self) -> Tuple[EnumValue, ...]:
        """

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: Sequence[EnumValue]) -> None:
        """

        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """
    def menuItems(self) -> Tuple[str, ...]:
        """

        menuItems(self) -> tuple of str

            Return the tuple of internal menu names. If this integer does not
            use a menu, returns an empty tuple.

            These internal menu names are not displayed in the UI, but they can
            be passed to hou.Parm.set.


        """
    def setMenuItems(self, menu_items: Sequence[str]) -> None:
        """

        setMenuItems(self, menu_items)

            Set the internal menu names to the given sequence of strings.

            See the menuItems method for more information.

            If the new number of menu items is less than the old number, the
            menu labels will be shortened and the default value will be modified
            if it is out of range.


        """
    def menuLabels(self) -> Tuple[str, ...]:
        """

        menuLabels(self) -> tuple of str

            Return the tuple of menu labels displayed in the UI. These labels
            are used when this parm template uses a menu.


        """
    def setMenuLabels(self, menu_labels: Sequence[str]) -> None:
        """

        setMenuLabels(self, menu_labels)

            Set the menu labels displayed in the UI to the given sequence of
            strings.

            If the number of menu labels is less than the number of menu items,
            Houdini uses the internal menu item names for the missing labels. If
            the number of labels is more than the number of menu items, Houdini
            discards the extra labels.

            If you want to change both the menu items and menu labels, be sure
            to change the menu items first.


        """
    def iconNames(self) -> Tuple[str, ...]:
        """

        iconNames(self) -> tuple of str

            Return the tuple of icons corresponding to the menu items. If there
            are no icons, returns a tuple of empty strings.

            These icons are used when this parm template uses a menu.


        """
    def setIconNames(self, icon_names: Sequence[str]) -> None:
        """

        setIconNames(self, icon_names)

            Set the icon names to the given sequence of strings.


        """
    def itemGeneratorScript(self) -> str:
        """

        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

            Return the script used to generate menu items, or an empty string if
            there is no such script.


        """
    def setItemGeneratorScript(self, item_generator_script: str) -> None:
        """

        setItemGeneratorScript(self, item_generator_script)

            Set the script used to generate menu items.

            See the itemGeneratorScript method for more information.


        """
    def itemGeneratorScriptLanguage(self) -> EnumValue: ...
    def setItemGeneratorScriptLanguage(self, language: EnumValue) -> None:
        """

        setItemGeneratorScriptLanguage(self, language)

            Set the script language used to generate menu items to a
            hou.scriptLanguage enum value.

            See the itemGeneratorScriptLanguage method for more information.


        """
    def menuType(self) -> EnumValue:
        """

        menuType(self) -> hou.menuType enum value

            Return the type of menu. See hou.menuType for more information.


        """
    def setMenuType(self, menu_type: EnumValue) -> None:
        """

        setMenuType(self, menu_type)

            Set the type of menu to a hou.menuType enum value.

            See the menuType method for more information.


        """
    def menuUseToken(self) -> bool:
        """

        menuUseToken(self) -> bool

            Return whether the parameter is set to the token value instead of
            the index.

            See also the setMenuUseToken method.


        """
    def setMenuUseToken(self, menuusetoken: bool) -> None:
        """

        setMenuUseToken(self, on)

            Set whether the parameter is set to the token value instead of the
            index.

            See also the menuUseToken method.


        """

class IPRViewer(PaneTab):
    """

    hou.IPRViewer

    An interactive preview render (IPR) window.

    The IPR viewer progressively refines a render, first providing a rough
    view of the rendered image and eventually providing the fully rendered
    image. When you change a shader value, move an object, etc., the viewer
    will re-render the image.

    When you Ctrl+click on a pixel in the rendered image, Houdini searches
    $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. The version of
    this file that ships with Houdini pops up the shader contributing the
    pixel, or an information window if there is is no shader. If Houdini
    cannot find that Python file it then looks for the Hscript file
    scripts/ipr/pickpixel.cmd.

    When you drag a SHOP node onto the rendered image, Houdini searches for
    and runs scripts/ipr/dragdrop.py. By default, this script assigns the
    SHOP to the object contributing the pixel. If it cannot find a Python
    version, Houdini then looks for scripts/ipr/dragdrop.cmd.

    Note that shelf scripts can access the last location the user clicked on
    with hou.IPRViewer.lastClickLocation.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isPaused(self) -> bool:
        """

        isPaused(self) -> bool

            Indicates whether the IPR session is paused. If there is no active
            session, this returns false.


        """
    def isRendering(self) -> bool:
        """

        isRendering(self) -> bool

            Indicates whether the IPR session has an render in progress. Returns
            True even if the render is paused.


        """
    def isActive(self) -> bool:
        """

        isActive(self) -> bool

            Indicates whether an active IPR sessions exists.


        """
    def killRender(self) -> None:
        """

        killRender(self)

            Kills the active IPR session (if there is one).


        """
    def pauseRender(self) -> None:
        """

        pauseRender(self)

            Pauses the active IPR session (if there is one).


        """
    def resumeRender(self) -> None:
        """

        resumeRender(self)

            Resumes the active IPR session (if there is one).


        """
    def startRender(self) -> None:
        """

        startRender(self)

            Start a new render if there is no active IPR session or issue a re-
            render if there is one.


        """
    def isPreviewOn(self) -> bool:
        """

        isPreviewOn(self) -> bool

            Return whether or not the Preview checkbox is checked. When it is
            unchecked, the viewer will not progressively refine the image using
            IPR, and will instead use the rendering engine from the ROP node to
            render it.

            See also hou.IPRViewer.setPreview.


        """
    def setPreview(self, on: bool) -> None:
        """

        setPreview(self, on)

            Check or uncheck the Preview checkbox.

            See hou.IPRViewer.isPreviewOn for more information.


        """
    def isAutoSaveOn(self) -> bool:
        """

        isAutoSaveOn(self) -> bool

            Returns whether or not the Auto Save toggle is selected. When turned
            on, IPR will periodically save the render progress to the auto save
            file path. The time between saves can be configured by setting the
            auto save time.

            See also hou.IPRViewer.setAutoSave.


        """
    def setAutoSave(self, on: bool) -> None:
        """

        setAutoSave(self, on)

            Set or unset the Auto Save toggle.

            See hou.IPRViewer.isAutoSaveOn for more information.


        """
    def autoSavePath(self) -> str:
        """

        autoSavePath(self) -> str

            Returns the render save path. This is the path that is used when the
            IPR viewer is set to automatically save render progress to disk.

            See also hou.IPRViewer.setSavePath.


        """
    def setAutoSavePath(self, path: str) -> None:
        """

        setAutoSavePath(self, path)

            Sets the render progress save path.

            See also hou.IPRViewer.autoSavePath for more information.


        """
    def isAutoUpdateOn(self) -> bool:
        """

        isAutoUpdateOn(self) -> bool

            Return whether or not the Auto-Update checkbox is checked. When it
            is unchecked, the viewer will not refresh when objects, shaders,
            lights, etc. change. In this case, you can force a re-render by
            clicking on the Render button.

            See also hou.IPRViewer.setAutoUpdate.


        """
    def setAutoUpdate(self, on: bool) -> None:
        """

        setAutoUpdate(self, on)

            Check or uncheck the Auto-Update checkbox.

            See hou.IPRViewer.isAutoUpdateOn for more information.


        """
    def autoSaveTime(self) -> float:
        """

        autoSaveTime(self) -> float

            Returns the time between IPR auto saves in seconds. When auto saving
            is on, a render progress image is written out at this rate.

            See also hou.IPRViewer.setAutoSaveTime.


        """
    def setAutoSaveTime(self, time: float) -> None:
        """

        setAutoSaveTime(self, float)

            Sets the auto save time in seconds.

            See also hou.IPRViewer.autoSaveTime for more information.


        """
    def delay(self) -> float:
        """

        delay(self) -> float

            Return the contents of the viewer's Delay field. This value
            determines how long Houdini waits between when you change a
            parameter value and when it starts re-rendering.

            See also hou.IPRViewer.setDelay and hou.IPRViewer.updateTime.


        """
    def setDelay(self, time: float) -> None:
        """

        setDelay(self, time)

            Set the contents of the viewer's Delay field.

            See hou.IPRViewer.delay for more information.


        """
    def updateTime(self) -> float:
        """

        updateTime(self) -> float

            Return the contents of the viewer's Update Time field. This value
            determines approximately how long each progressive refinement should
            take. Smaller values will produce more progressive renders where
            detail is added more gradually.

            See also hou.IPRViewer.setUpdateTime and hou.IPRViewer.delay.


        """
    def setUpdateTime(self, time: float) -> None:
        """

        setUpdateTime(self, time)

            Set the contents of the viewer's Update Time field.

            See hou.IPRViewer.updateTime for more information.


        """
    def lastClickLocation(self) -> Tuple[int, ...]:
        '''

        lastClickLocation(self) -> (int, int)

            Return the x and y coordinates for the pixel location where the user
            last clicked in the IPR viewer. Note that this location might be
            outside the image: the x and y coordinates can be negative and can
            be greater than or equal to the image resolution. Note that if the
            user never clicked in the viewer, the x and y coordinates will be
            negative.

            You would typically call this method from a shelf script. For
            example, a user can click on a pixel in the IPR viewer and then
            click on the shelf to perform an action on that pixel (e.g. display
            the shader parameters, assign a shader, etc.).

            Use hou.IPRViewer.imageResolution to get the valid range for pixel
            coordinates.

            Note that when you Ctrl-click on a pixel, Houdini searches
            $HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. This script
            can access the viewer with kwargs[\\"viewer\\"] and the location where
            the user clicked with kwargs[\\"position\\"].

            The following script opens a floating parameter window for the
            shader corresponding to the pixel the user last clicked on.

          > viewer = hou.ui.paneTabOfType(hou.paneTabType.IPRViewer)
          > px, py = viewer.lastClickLocation()
          > 
          > if (px < 0 or px > viewer.imageResolution()[0] or
          >         py < 0 or py >= viewer.imageResolution()[1]):
          >     hou.ui.displayMessage(\\"Click on the image and then run this script again\\")
          > else:
          >     material = viewer.materialNode(px, py)
          > 
          >     if material is not None:
          >         parm_window = hou.ui.curDesktop().createFloatingPaneTab(
          >             hou.paneTabType.Parm)
          >         parm_window.setCurrentNode(material)
          >         parm_window.setPin(True)
          >     else:
          >         hou.ui.displayMessage(\\"Click on an object to bring up the shader.\\")

        '''
    def ropNode(self) -> Optional[Node]:
        """

        ropNode(self) -> hou.RopNode or None

            Return the ROP node that is selected in the viewer, or None if
            nothing is selected.


        """
    def setRopNode(self, rop_node: Node) -> None:
        """

        setRopNode(self, rop_node)

            Set the ROP node to use for rendering.


        """
    def imageResolution(self) -> Tuple[int, ...]:
        """

        imageResolution(self) -> (int, int)

            Return the resolution of the image.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
    def cropRegion(self) -> Tuple[float, ...]:
        """

        cropRegion(self) -> (float, float, float, float)

            Return the x0, x1, y0, and y1 normalized coordinates of the
            subregion that is selected, where (x0, y0) is the bottom-left corner
            and (x1, y1) is the top-right corner of the subregion.

            You can optionally tell the IPR viewer to only re-render only a
            portion of the image. To select a subportion of the image, hold down
            shift and select the box.

            Note that the bottom-left corner is (0.0, 0.0) and the top-right
            corner is (1.0, 1.0). For example, if the entire image is being
            rendered, this method returns (0.0, 1.0, 0.0, 1.0).


        """
    def planes(self) -> Tuple[str, ...]:
        """

        planes(self) -> tuple of str

            Return the names of the image planes in the rendered output.

            Note that the special Op_Id image plane contains the
            hou.Node.sessionId ids of the object nodes in the image. -1
            indicates that there is no object node associated with the pixel.
            Use hou.IPRViewer.objectNode to access the object corresponding to
            that id.

            Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
            primitives in the image. Use hou.IPRViewer.prim to access the
            primitive corresponding to that id.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
    def displayedPlane(self) -> str:
        """

        displayedPlane(self) -> str

            Return the name of the currently-displayed image plane in the
            rendered output.

            Note that the special Op_Id image plane contains the
            hou.Node.sessionId ids of the object nodes in the image. -1
            indicates that there is no object node associated with the pixel.
            Use hou.IPRViewer.objectNode to access the object corresponding to
            that id.

            Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
            primitives in the image. Use hou.IPRViewer.prim to access the
            primitive corresponding to that id.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
    def pixel(self, plane_name: str, x: int, y: int) -> Tuple[float, ...]:
        '''

        pixel(self, plane_name, x, y) -> tuple of float

            Return the value of a pixel in one plane of the image. This method
            returns a tuple of 1 to 4 floats, depending on the type of image
            plane.

            Note that the color plane is named C.

            Raises hou.OperationFailed if the plane name is invalid, the pixel
            location is outside the image, or the viewer does not contain an
            image.

            You can determine the number of components in the image plane using
            the following: len(viewer.pixel(plane_name, 0, 0)).

          > >>> viewer.pixel(\\"C\\", 300, 200)
          > (0.69970703125, 0.46728515625, 0.289794921875, 1.0)

        '''
    def pixels(self, plane_name: str) -> Tuple[Tuple[float, ...], ...]:
        '''

        pixels(self, plane_name) -> tuple of tuple of float

            Returns the value of all pixels in one plane of the image. This
            method returns a tuple of tuples of 1 to 4 floats, depending on the
            type of image plane. The results are in row-major order, starting at
            the bottom left corner of the IPR image.

            Note that the color plane is named C.

            Raises hou.OperationFailed if the plane name is invalid or the
            viewer does not contain an image.

          > >>> all_pixels = viewer.pixels(\\"C\\")
          > >>> width = viewer.imageResolution()[0]
          > >>> all_pixels[width*200 + 300]
          > (0.69970703125, 0.46728515625, 0.289794921875, 1.0)

        '''
    def evaluatedStyleSheetJSON(self, x: int, y: int) -> str:
        """

        evaluatedStyleSheetJSON(self, x, y) -> str

            Returns a JSON string describing the material style sheet at a given
            pixel. If no style sheet is active, an empty string is returned.


        """
    def evaluatedStyleSheetPaths(self, x: int, y: int) -> Tuple[Tuple[str, int], ...]:
        """

        evaluatedStyleSheetPaths(self, x, y) -> tuple of str

            Returns a list of paths to the styles that contribute to the style
            sheet at the current pixel.


        """
    def saveFrame(self, file_path: str, snapshot: int = ..., xres: int = ..., yres: int = ..., color: str = ..., alpha: str = ..., scope: str = ..., lut: str = ..., gamma: float = ..., convert: bool = ...) -> bool:
        """

        saveFrame(self, file_path, snapshot=0, xres=-1, yres=-1, color='C',
        alpha='C', scope='*', lut='', gamma=1.0, convert=True) -> bool

            Saves the current IPR render to the specified file path. It is
            possible to save an in progress/incomplete render.

            The output image type is inferred from the file extension on the
            provided file path. The snapshot parameter controls which IPR
            snapshot to save. A value of 0 indicates the active render.

            The native IPR resolution is used by default, however a custom
            resolution can be specified with the xres and yres parameters. The
            color and alpha parameters control which render planes are used when
            writing RGBA images like .jpg or .png. If a deep image format such
            as .pic or .exr is used, the scope parameter can be used to specify
            which image planes to include in the output.


        """
    def objectNode(self, x: int, y: int) -> Optional[Node]:
        """

        objectNode(self, x, y) -> hou.ObjNode or None

            Return the object node contributing the pixel at the specified
            location, or None if there is no object at the pixel or if the pixel
            location is outside the image bounds

            The following function returns the SOP node containing the geometry
            that contributes the pixel to the final image:

          > def sopNode(viewer, x, y):
          >     obj_node = viewer.objectNode(x, y)
          >     return (obj_node.renderNode() if obj_node is not None else None)

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
    def prim(self, x: int, y: int) -> Optional[Prim]:
        """

        prim(self, x, y) -> hou.Prim or None

            Return the geometry primitive contributing the pixel at the
            specified location, or None if there is nothing at the pixel or if
            the pixel location is outside the image bounds

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
    def materialNode(self, x: int, y: int) -> Optional[Node]:
        """

        materialNode(self, x, y) -> hou.ShopNode or None

            Return the SHOP node contributing the pixel at the specified
            location, or None if there is nothing at the pixel, the pixel
            location is outside the image bounds, or there is no shader on the
            geometry.

            This method first checks the primitive corresponding to the pixel
            and returns the SHOP corresponding to its shop_materialpath
            attribute. If the primitive does not have this attribute then it
            returns the SHOP assigned to the object. If no SHOP is assigned to
            the object, it returns None.

            Raises hou.OperationFailed if the viewer does not contain an image.


        """
    def usingOCIO(self) -> bool:
        """

        usingOCIO(self) -> bool

            Query if OpenColorIO is being used for color correction in the
            viewer.


        """
    def setUsingOCIO(self, enable: bool) -> None:
        """

        setUsingOCIO(self, enable)

            Enable or disable OpenColorIO for color correction in the viewer.


        """
    def setOCIODisplayView(self, display: Optional[str] = None, view: Optional[str] = None) -> None:
        '''

        setOCIODisplayView(self, display=\\"\\", view=\\"\\")

            Set the OpenColorIO display name, view name, or both. The display
            and view together define the output colorspace for the viewer, and
            any number of color transforms (Looks) to be performed on the linear
            viewport image.


        '''
    def getOCIODisplay(self) -> str:
        """

        getOCIODisplay(self) -> str

            Return the current OpenColorIO display used for color correction.


        """
    def getOCIOView(self) -> str:
        """

        getOCIOView(self) -> str

            Return the current OpenColorIO view used for color correction.


        """

class Keyframe(BaseKeyframe):
    """

    hou.Keyframe

    Class representing the default keyframe type, a numerical keyframe.


    """
    thisown: Incomplete
    def __init__(self, value: float|None = ..., time: float|None = ...) -> None:
        """

        __init__(self, values)

            Return a new Keyframe object. You can pass no parameters (the result
            will have no value set), a float value, a float value and float
            time, or a Keyframe object.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def evaluatedType(self) -> EnumValue:
        """

        evaluatedType(self) -> hou.parmData enum value

            Return the data type of the keyframe's evaluated value. For
            keyframes storing numerical values this method returns
            hou.parmData.Float.


        """
    def setValue(self, value: float) -> None:
        """

        setValue(self, value)

            Sets the value leaving the keyframe.


        """
    def value(self) -> float:
        """

        value(self) -> double

            Returns the value leaving the keyframe.

            This method raises hou.KeyframeValueNotSet if the value has not been
            set.


        """
    def isValueSet(self) -> bool:
        """

        isValueSet(self) -> bool

            Returns True if the value entering or leaving the keyframe has been
            set.


        """
    def setInValue(self, in_value: float) -> None:
        """

        setInValue(self, in_value)

            Sets the value entering the keyframe. Sets the value leaving the
            keyframe, if not already set. Unties the value.


        """
    def unsetInValue(self) -> None:
        """

        unsetInValue(self)

            Unsets the value entering the keyframe and tie the values.


        """
    def inValue(self) -> float:
        """

        inValue(self) -> double

            Returns the value entering the keyframe.

            This method raises hou.KeyframeValueNotSet if the value has not been
            set or the value is tied.


        """
    def isValueTied(self) -> bool:
        """

        isValueTied(self) -> bool

            Returns True if the value entering the keyframe has not been set.


        """
    def isValueUsed(self) -> bool:
        """

        isValueUsed(self) -> bool

            Returns True if the value entering or leaving the keyframe is being
            used.


        """
    def useValue(self, use: bool) -> None:
        """

        useValue(self, on)

            Sets the value used flag.


        """
    def setSlope(self, slope: float) -> None:
        """

        setSlope(self, slope)

            Sets the slope leaving the keyframe.


        """
    def slope(self) -> float:
        """

        slope(self) -> double

            Returns the slope leaving the keyframe.

            This method raises hou.KeyframeValueNotSet if the slope has not been
            set.


        """
    def isSlopeSet(self) -> bool:
        """

        isSlopeSet(self) -> bool

            Returns True if the slope entering or leaving the keyframe has been
            set.


        """
    def isSlopeUsed(self) -> bool:
        """

        isSlopeUsed(self) -> bool

            Returns True if the slope entering or leaving the keyframe is being
            used.


        """
    def useSlope(self, use: bool) -> None:
        """

        useSlope(self, on)

            Sets the slope used flag.


        """
    def isSlopeAuto(self) -> bool:
        """

        isSlopeAuto(self) -> bool

            Returns True if the slope leaving the keyframe is set to automatic.


        """
    def setSlopeAuto(self, on: bool) -> None:
        """

        setSlopeAuto(self, on)

            Sets the slope leaving the keyframe to automatic.


        """
    def setInSlope(self, in_slope: float) -> None:
        """

        setInSlope(self, in_slope)

            Sets the slope entering the keyframe. Sets the slope leaving the
            keyframe, if not already set. Unties the slope.


        """
    def unsetInSlope(self) -> None:
        """

        unsetInSlope(self)

            Unsets the slope entering the keyframe and tie the slope.


        """
    def inSlope(self) -> float:
        """

        inSlope(self) -> double

            Returns the slope entering the keyframe.

            This method raises hou.KeyframeValueNotSet if the slope has not been
            set or the slope is tied.


        """
    def isSlopeTied(self) -> bool:
        """

        isSlopeTied(self) -> bool

            Returns True if the slope entering the keyframe has not been set.


        """
    def isInSlopeAuto(self) -> bool:
        """

        isInSlopeAuto(self) -> bool

            Returns True if the slope entering the keyframe is set to automatic.


        """
    def setInSlopeAuto(self, on: bool) -> None:
        """

        setInSlopeAuto(self, on)

            Sets the slope entering the keyframe to automatic.


        """
    def setAccel(self, accel: float) -> None:
        """

        setAccel(self, accel)

            Sets the acceleration leaving the keyframe.


        """
    def accel(self) -> float:
        """

        accel(self) -> double

            Returns the acceleration leaving the keyframe.

            This function raises hou.KeyframeValueNotSet if the acceleration has
            not been set.


        """
    def isAccelSet(self) -> bool:
        """

        isAccelSet(self) -> bool

            Returns True if the acceleration entering or leaving the keyframe
            has been set.


        """
    def isAccelUsed(self) -> bool:
        """

        isAccelUsed(self) -> bool

            Returns True if the acceleration entering or leaving the keyframe is
            being used.


        """
    def useAccel(self, use: bool) -> None:
        """

        useAccel(self, on)

            Sets the acceleration used flag.


        """
    def setInAccel(self, in_accel: float) -> None:
        """

        setInAccel(self, in_accel)

            Sets the acceleration entering the keyframe. Sets the acceleration
            leaving the keyframe, if not already set. Unties the acceleration.


        """
    def unsetInAccel(self) -> None:
        """

        unsetInAccel(self)

            Unsets the acceleration entering the keyframe and tie the
            acceleration.


        """
    def inAccel(self) -> float:
        """

        inAccel(self) -> double

            Returns the acceleration entering the keyframe.

            This method raises hou.KeyframeValueNotSet if the acceleration has
            not been set or it is tied.


        """
    def isAccelTied(self) -> bool:
        """

        isAccelTied(self) -> bool

            Returns True if the acceleration entering the keyframe has not been
            set.


        """
    def interpretAccelAsRatio(self, on: bool) -> None:
        """

        interpretAccelAsRatio(self, on)

            Sets whether Houdini should interpret the acceleration values
            entering and leaving the keyframe as a single ratio. When set to
            True, the ratio of the in-acceleration to out-acceleration is always
            maintained. If, for example, the in-acceleration is made to be twice
            as large using the Animation Editor, then the out-acceleration will
            automatically be adjusted to be twice as large as well. This is the
            default behavior for Houdini keyframes.


        """
    def isAccelInterpretedAsRatio(self) -> bool:
        """

        isAccelInterpretedAsRatio(self) -> bool

            Returns True if the acceleration values entering and leaving the
            keyframe are interpreted as a ratio by Houdini.


        """

class LabelParmTemplate(ParmTemplate):
    """

    hou.LabelParmTemplate

    Describes a label parameter. Unlike most other parameters, labels do not
    store parameter values.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, column_labels: Sequence[str] = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., tags: Mapping[str, str] = ...) -> None:
        """

        __init__(self, name, label, column_labels=(), is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None, tags={})

            Create a new LabelParmTemplate instance.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            column_labels
                See the setColumnLabels method for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            tags
                See hou.ParmTemplate.tags for more information.

            Note that the number of components in a label parm template
            corresponds to the number of column labels.


        """
    __swig_destroy__: Incomplete
    def labelParmType(self) -> EnumValue:
        """

        labelParmType() -> hou.labelParmType

            Returns the label parm type for this parm template.


        """
    def setLabelParmType(self, label_parm_type: EnumValue) -> None:
        """

        setLabelParmType(label_parm_type)

            Sets the label parm type to a hou.labelParmType enum value.


        """
    def columnLabels(self) -> Tuple[str, ...]:
        """

        columnLabels() -> tuple of str

            Return the tuple of strings of column labels. Normally, label parm
            templates do not have any column labels. However, they may have
            these extra labels that are displayed in addition to the main label.

            Note that the number of components in a label parm template
            corresponds to the number of column labels.


        """
    def setColumnLabels(self, column_labels: Sequence[str]) -> None:
        """

        setColumnLabels(column_labels)

            Set the column labels to a sequence of strings.

            The parameter editor in the <Type Properties Dialog> always has at
            least one column label, so if you supply an empty sequence there
            will be one column label that is an empty string.

            See the columnLabels method for more information.


        """

class logging:
    """

    hou.logging

    Module containing functions and classes for logging warnings and errors.

    Houdini's logging system consists of sources and sinks. Sources generate
    and distribute log entries. Sinks receive log entries from sources, and
    do something with them. Sources are global, and identified by a unique
    name string (such as Node Errors which is a source that generates a log
    entry for every message, warning, or error generated by nodes). There
    can be any number of sinks created in a Houdini session, and each one
    can connect to a different set of sources. Thus you could create one
    sink that sends all node errors to a file, another sink that sends all
    rendering messages to a different file, and a third sink that captures
    in memory all log entries generated by any sink (the same source may be
    connected to multiple sinks). This system allows for fine grained
    control over which log entries are captured, and what is done with each
    log entry.

    API



    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def sources() -> Tuple[str, ...]:
        """

        hou.logging.sources

        Return a tuple of all available log source names.

        USAGE
          sources() -> tuple of str

        The HDK can be used to create additional log sources, but the default
        list of sources returned by this method will be:

          * Generic Logging: Logs generated by Houdini which do not fall into
            any other category.

          * Licensing: Messages related to acquiring licenses to run Houdini.

          * Mocap Stream: Messages generated by motion capture devices.

          * Networking: Messages generated by networking components such as
            Houdini's built-in web server.

          * Node Errors: All messages, warnings, and errors generated by Houdini
            nodes.

          * Rendering: Messages generated by Karma running within the Houdini
            process. Use hou.logging.setRenderLogVerbosity to set the equivalent
            of the verbosity command line argument for external rendering
            processes.

          * Standard Error: Text sent to the stderr stream.

          * Standard Output: Text sent to the stdout stream.

          * USD Logging: Messages generated in the USD logging system.


        """
    @staticmethod
    def setRenderLogVerbosity(verbosity: int) -> None:
        """

        hou.logging.setRenderLogVerbosity

        Set the Karma logging verbosity level.

        USAGE
          setRenderLogVerbosity(verbosity)

        Set the current logging verbosity level for Karma running within the
        current Houdini session. This is equivalent to the value of the -V
        values passed to the husk process for a command line render. Values
        range from 0 to 9, and high values can impact the performance of the
        render.


        """
    @staticmethod
    def renderLogVerbosity() -> int:
        """

        hou.logging.renderLogVerbosity

        Return the Karma logging verbosity level.

        USAGE
          renderLogVerbosity() -> int

        Return the current logging verbosity level for Karma running within the
        current Houdini session. This is equivalent to the value of the -V
        values passed to the husk process for a command line render. Values
        range from 0 to 9, and high values can impact the performance of the
        render.


        """
    @staticmethod
    def saveLogsToFile(logs: typing.Iterable[_logging_LogEntry], filepath: str) -> None:
        """

        hou.logging.saveLogsToFile

        Save a tuple of LogEntry objects to a file in JSON format.

        USAGE
          saveLogsToFile(logs, filepath)

        Creates a file containing a JSON representation of a collection of
        hou.logging.LogEntry objects. This file can be converted back to a tuple
        of hou.logging.LogEntry objects by calling hou.logging.loadLogsFromFile
        with the same filepath.


        logs
            Iterable object containing hou.Logging.LogEntry objects which are to
            be saved to disk in a JSON format the preserves all available
            information from each entry.

        filepath
            Path to the file on disk where the log entries will be written.


        """
    @staticmethod
    def loadLogsFromFile(filepath: str) -> Tuple[_logging_LogEntry, ...]:
        """

        hou.logging.loadLogsFromFile

        Load a tuple of LogEntry objects saved in JSON format from a file.

        USAGE
          loadLogsFromFile(filepath) -> tuple of hou.logging.LogEntry

        Returns a tuple of log entries stored in a JSON file on disk. This file
        was most likely created with a call to hou.logging.saveLogsToFile.


        filepath
            The path to the file containing the JSON representation of an array
            of log entries.


        """
    @staticmethod
    def createSource(source_name: str) -> None:
        """

        hou.logging.createSource

        Create a new logging source which can send out log entries generated in
        python.

        USAGE
          createSource(source_name)

        Creates a new logging source that can be passed as the source_name
        argument to the hou.logging.log method. That method will create new
        logging sources automatically, but it can be useful to create logging
        sources before any logs are generated by that source so the user can
        enable the source in the Log Viewer pane.


        source_name
            The name for the new logging source. If this name matches any
            existing source (as returned by hou.logging.sources), this method
            does nothing.


        """
    @staticmethod
    def log(entry: _logging_LogEntry, source_name: Optional[str] = None) -> None:
        """

        hou.logging.log

        Send a LogEntry object to all log sinks connected to a logging source.

        USAGE
          log(entry, source_name = None)

        Sends a hou.logging.LogEntry from a source with the specified
        source_name. If no source_name is provided, or it is an empty string,
        then the source set on the log entry is used. If that source name is
        also not set, then the default source name of Python Logging is used.


        entry
            A hou.logging.LogEntry object which will be sent from the named
            logging source to all connected sinks. The source attribute of the
            log entry object will be automatically overridden to use the
            specified source_name.

        source_name
            The name of the logging source from which the log entry is sent.
            Only logging sources compatible with sending python log entries can
            be used here. If no value is specified, the value is assumed to be
            Python Logging. Other valid values are Generic Logging, or any value
            that does not match an existing logging source name. In this case a
            new logging source is automatically created as if
            hou.logging.createSource had been called.


        """
    @staticmethod
    def defaultSink(force_create: bool = False) -> Optional[_logging_MemorySink]:
        """

        hou.logging.defaultSink

        Return a shared memory sink object owned by the current Houdini session.

        USAGE
          defaultSink(force_create) -> hou.logging.MemorySink or None

        Every Houdini session can have a single shared hou.logging.MemorySink
        object which is used by all Log Viewer panes to display logs generated
        by the current Houdini session. This function provides access to this
        shared sink object.


        force_create
            If the default sink for the current Houdini session has not been
            created, this parameter controls whether the default sink should be
            created. Otherwise this method will return None. If the default sink
            has already been created, this parameter has no effect.


        """
    @staticmethod
    def defaultFileSink() -> Optional['_logging_FileSink']:
        """

        hou.logging.defaultFileSink

        Return a shared file sink object owned by the current Houdini session.

        USAGE
          defaultFileSink() -> hou.logging.FileSink or None

        Every Houdini session can have a single shared hou.logging.FileSink
        object which is used to log messages generated by the current Houdini
        session. This function provides access to this shared sink object. If
        the HOUDINI_DEFAULT_LOG_FILE or HOUDINI_DEFAULT_LOG_FILE_SOURCES
        environment variables are not set, Houdini will not send its logs to a
        file, and so this method will return None.


        """

class _logging_FileSink(_logging_Sink):
    """

    hou.logging.FileSink

    Represents a logging destination that writes log entries to a file.

    This kind of sink can be used to send log entries to a file on disk.
    Some of the log entry details are lost in writing the data to disk, as
    each log entry is output simply as a time stamp followed by the message
    text. So for most situations, using the Log Viewer pane to investigate
    log entries will be preferable.


    Tip
        In order to ensure all logs are captured and committed to disk, this
        sink type opens the log file, writes the log entry, and closes the
        file for each log message. This can introduce noticeable performance
        issues if a large amount of information is being logged. Therefore
        it is strongly recommended that the destination file be local to the
        machine running Houdini, and preferably be kept on an SSD hard
        drive.


    """
    thisown: Incomplete
    def __init__(self, filepath: str) -> None:
        """

        __init__(self, filepath)

            Creates a new file sink object which writes logs to the specified
            file path.


        """
    __swig_destroy__: Incomplete
    def filePath(self) -> str:
        """

        filePath() -> str

            Returns the path to the file where logs are written.


        """

class _logging_LogEntry:
    """

    hou.logging.LogEntry

    Represents a single log message that is sent by a source to a sink.


    """
    thisown: Incomplete
    def __init__(self, message: Optional[str] = None, source: Optional[str] = None, source_context: Optional[str] = None, severity: Optional[EnumValue] = None, verbosity: int = 0, time: float = 0.0, thread_id: int = 0, has_external_info: bool = False, external_host_name: Optional[str] = None, external_identifier: Optional[str] = None, external_command_line: Optional[str] = None, external_process_id: int = 0) -> None:
        """

        __init__(self, message = None, source = None, source_context = None,
        severity = None, verbosity = 0, time = 0.0, thread_id = 0,
        has_external_info = False, external_host_name = None,
        external_identifier = None, external_command_line = None,
        external_process_id = 0)

            Return a new LogEntry with the provided data members.


        """
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def source(self) -> str:
        """

        source() -> str

            Return the names of the source that generated this log entry.


        """
    def sourceContext(self) -> str:
        """

        sourceContext() -> str

            Return an optional string that identifies the context within the
            source that generated this log entry. One example is that the Node
            Errors source sets this value to the path of the specific Houdini
            node that generated the log entry.


        """
    def message(self) -> str:
        """

        message() -> str

            Return the main log entry message text.


        """
    def severity(self) -> EnumValue:
        """

        severity() -> hou.severityType

            Return an optional severity value for the log entry. This value will
            be set for node error logs, USD logs, and other sources with a well
            defined set of logging severity levels.


        """
    def verbosity(self) -> int:
        """

        verbosity() -> int

            Return an optional verbosity value for the log entry. This value
            will be set for rendering logs, and indicates the minimum
            hou.logging.renderLogVerbosity level required for Karma to generate
            this log entry.


        """
    def time(self) -> float:
        '''

        time() -> float

            Return the time at which this log entry was generated. This value is
            expressed as the number of seconds since January 1, 1970, 00:00:00
            (UTC). This value can be converted to a local time using the python
            time module using code such as time.strftime(\\"%H:%M:%S\\",
            time.localtime(log.time())). Although log entries from a single
            source should always arrive in chronological order, some sources may
            delay their log reporting, and so log entries may arrive at a sink
            out of order.


        '''
    def threadId(self) -> int:
        """

        threadId() -> int

            Return a number that uniquely identifies within a given Houdini
            session which thread in the process generated the log entry. This
            can be useful to establish a chronology of log entries when multiple
            threads are generating logs simultaneously.


        """
    def hasExternalInfo(self) -> bool:
        """

        hasExternalInfo() -> bool

            Return True if this log entry was generated by a process other than
            the current Houdini session. In this case, the various methods
            starting with external will return meaningful information. If this
            method returns False, the external methods should not be called on
            this object.


        """
    def externalHostName(self) -> str:
        """

        externalHostName() -> str

            If the external process was running on a different machine, return
            the name of the machine running the process. Otherwise return an
            empty string.


        """
    def externalIdentifier(self) -> str:
        """

        externalIdentifier() -> str

            Return an optional string to help identify the machine or process
            which generated the log entry. The meaning of this value varies
            depending on the logging source.


        """
    def externalCommandLine(self) -> str:
        """

        externalCommandLine() -> str

            Return the full command line used to launch the external process
            that generated this log entry.


        """
    def externalProcessId(self) -> int:
        """

        externalProcessId() -> int

            Return the process identifier (pid) of the process that generated
            the log entry.


        """

class _logging_MemorySink(_logging_Sink):
    """

    hou.logging.MemorySink

    Represents a logging destination that stores log entries in memory.

    All log entries sent to this sink are held in memory forever unless
    stealLogEntries is called. Depending on the frequency of logging, this
    can eventually result in a very large amount of memory being consumed by
    these logs, however in most normal operating circumstances this is very
    unlikely to be a problem.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        hou.logging.MemorySink

        Represents a logging destination that stores log entries in memory.

        All log entries sent to this sink are held in memory forever unless
        stealLogEntries is called. Depending on the frequency of logging, this
        can eventually result in a very large amount of memory being consumed by
        these logs, however in most normal operating circumstances this is very
        unlikely to be a problem.


        """
    __swig_destroy__: Incomplete
    def logEntries(self) -> Iterator[_logging_LogEntry]:
        """

        logEntries() -> iterable of hou.logging.LogEntry

            Return an iterable object that represents all the log entries held
            in memory by this sink object.


        """
    def stealLogEntries(self) -> Tuple[_logging_LogEntry, ...]:
        """

        stealLogEntries() -> tuple of hou.logging.LogEntry

            Returns a tuple of all log entries that were held in memory by this
            sink object. In addition, all log entries owned by this sink object
            are cleared from memory. Thus subsequent calls to logEntries or
            stealLogEntries will not return any of these log entries again.


        """

class LopLockedStage:
    """

    hou.LopLockedStage

    Guarantees the lifetime of a USD stage created by a LOP node.

    This object is returned by a call to hou.Geometry.importLop. This object
    must remain in scope as long as the hou.Geometry object contains packed
    primitives representing USD primitives created from the LOP node. Once
    this object leaves scope, it may become impossible to view or unpack the
    USD packed primitives in the hou.Geometry object.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def rootLayerIdentifier(self) -> str:
        """

        rootLayerIdentifier(self) -> str

            Returns the identifier for the root layer of the stage held by this
            object. This will always be an anonymous layer identifier.


        """

class LopNetwork(OpNode):
    """

    hou.LopNetwork

    Represents a lighting node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isDebugFlagSet(self) -> bool:
        """

        isDebugFlagSet(self) -> bool

            Returns True if the node's debug flag is turned on. Returns False
            otherwise.


        """
    def setDebugFlag(self, on: bool) -> None:
        """

        setDebugFlag(self, on)

            Turns the node's debug flag on or off. The debug flag on a LOP node
            is used to force the node to create its own USD Layer and apply its
            edits in that new layer. This makes it easier to track which scene
            graph modifications were made by which LOP node. Setting this flag
            will also affect the performance of the LOP Network since
            composition of the USD stage takes longer if there are more layers.

            Raises hou.PermissionError if the node is unwritable.


        """
    def displayNode(self) -> Optional[Node]:
        """

        displayNode(self) -> Node

            Return the LOP node inside this network with its display flag on.
            Otherwise, return None.


        """
    def viewerNode(self) -> Optional[Node]:
        """

        viewerNode(self) -> Node

            Return the LOP node inside this LOP network with its display flag
            on. This method exists to mirror the matching hou.LopNode.viewerNode
            method. But unlike that method, in a LOP network, unless there are
            no child nodes at all, there will always be a node with the display
            flag set, so this method will return the same values as the
            displayNode method.


        """
    def viewportOverrides(self, lop: LopNode, output_index: int = 0) -> LopViewportOverrides:
        """

        viewportOverrides(self, lop, output_index = 0) ->
        hou.LopViewportOverrides

            Return a hou.LopViewportOverrides object that allows editing of the
            current session-only modifications which should be applied to any
            scene being viewed in a Scene Graph Tree pane or a Scene Viewer
            pane.

            The lop must be a hou.LopNode object. The cooked stage from this LOP
            Node is used to perform the requested edit operations in the
            returned hou.LopViewportOverrides object. The output_index controls
            which output of this LOP node will be used to author the stage
            presented through the hou.LopViewportOverrides.stage method. The
            layer_index parameter controls which specific session sublayer is to
            be modified.


        """
    def saveNamedViewportOverrides(self, name: str, overrides: Optional[LopViewportOverrides] = None) -> None:
        """

        saveNamedViewportOverrides(self, name, overrides=None)

            Saves the current set of session overrides to the LOP Network under
            the specified name. This set of overrides will be saved to the hip
            file, and can be restored with the loadNamedViewportOverrides
            method.


        """
    def loadNamedViewportOverrides(self, name: str) -> None:
        """

        loadNamedViewportOverrides(self, name)

            Loads the session overrides saved under the specified name on the
            LOP Network. This set of overrides will be applied to any viewport
            pointed at this LOP Network. These named session override sets can
            be created with the saveNamedViewportOverrides method.


        """
    def namedViewportOverrides(self) -> Tuple[str, ...]:
        """

        namedViewportOverrides(self) -> tuple of str

            Returns a list of the named session overrides saved on the LOP
            Network. The names returned from this method can be passed to the
            loadNamedViewportOverrides method to load a particular set of
            overrides saved with the saveNamedViewportOverrides method.


        """
    def viewportOverridesLayer(self, layer_id: EnumValue) -> pxr.Sdf.Layer:
        """

        viewportOverridesLayer(self, layer_id) -> pxr.Sdf.Layer

            Return a pxr.Sdf.Layer object that holds the specified viewport
            overrides layer. This layer should be treated as read only. To
            modify a viewport overrides layer, use the viewportOverrides method.
            The layer_id must be one of the hou.lopViewportOverridesLayer
            values. Each layer is used to hold a different type of edit. In
            strongest to weakest order the available layers are:


            Custom
                Reserved for use by tools created by users. Houdini itself will
                not author opinions on this layer. Use the
                hou.LopViewportOverrides.layer method to access and edit this
                layer.

            Purpose
                Used to isolate and display specific geometry based on its
                purpose attribute. Other purposes for the same geometry will be
                hidden.

            SoloGeometry
                Used to express soloing opinions on geometry, for making all
                geometry invisible except for a specific set.

            SoloLights
                Used to express soloing opinions on lights, for deactivating all
                lights except for a specific set.

            Base
                Used for most edits performed in the scene graph tree, such as
                deactivating or hiding individual primitives.


        """
    def copyViewportOverrides(self, saved_name: Optional[str] = None) -> Optional[LopViewportOverrides]:
        """

        copyViewportOverrides(self, saved_name) -> hou.LopViewportOverrides


        """
    def setViewportOverrides(self, overrides: LopViewportOverrides) -> None:
        """

        setViewportOverrides(self, overrides)


        """
    def viewportLoadMasks(self) -> LopViewportLoadMasks:
        """

        viewportLoadMasks(self) -> hou.LopViewportLoadMasks

            Returns the load masking configuration for the viewport currently
            set on the LOP Network. This controls payload loading, stage
            population masking, and layer muting on any viewport pointed at this
            LOP Network.


        """
    def setViewportLoadMasks(self, load_masks: LopViewportLoadMasks) -> None:
        """

        setViewportLoadMasks(self, payload_config)

            Sets a new load masking configuration on the LOP Network.


        """
    def saveNamedViewportLoadMasks(self, name: str, load_masks: LopViewportLoadMasks) -> None:
        """

        saveNamedViewportLoadMasks(self, name)

            Saves the supplied load masking configuration to the LOP Network
            under the specified name. This configuration will be saved to the
            hip file, and can be restored with the loadNamedViewportLoadMasks
            method.


        """
    def loadNamedViewportLoadMasks(self, name: str) -> LopViewportLoadMasks:
        """

        loadNamedViewportLoadMasks(self, name) -> hou.LopViewportLoadMasks

            Returns the load masking configuration saved under the specified
            name on the LOP Network. Raises a hou.OperationFailed exception if
            there is no load masking configuration stored under the specified
            name.


        """
    def namedViewportLoadMasks(self) -> Tuple[str, ...]:
        """

        namedViewportLoadMasks(self) -> tuple of str

            Returns a list of the named load masking configurations saved on the
            LOP Network. The names returned from this method can be passed to
            the loadNamedViewportLoadMasks method to load a particular load
            masking configuration saved with the saveNamedViewportLoadMasks
            method.


        """
    def editablePostLayer(self, name: str, lop: LopNode, output_index: int = 0) -> LopPostLayer:
        """

        editablePostLayer(self, name, lop, output_index=0) -> hou.LopPostLayer

            Return a hou.LopPostLayer object which can be used to manipulate the
            contents of a post-layer on this LOP Network. If the specified layer
            does not exist, it will be created as the weakest post-layer. If it
            does exist, the current contents of the layer are composed onto the
            stage accessible through the LopPostLayer object. In either case,
            all stronger post-layers will be composed on the stage accessible
            through the LopPostLayer.

            The lop (a hou.LopNode) and output_index parameters define the USD
            stage on which the post layer is composed, and provides the context
            in which and USD API calls can be run. This LOP stage is accessible
            through the hou.LopPostLayer.stage method.

            A LopPostLayer object must be used to begin a with block. When the
            block exits the LopPostLayer object is destroyed, and the modified
            post-layer is saved to the LOP Network.

            The following code creates a post layer called pl1 on the /stage LOP
            network containing a Null LOP named null1, and adds a sphere prim:

          > from pxr import UsdGeom
          > with hou.node('/stage').editablePostLayer('pl1', hou.node('/stage/null1')) as pl:
          >     s = pl.stage()
          >     UsdGeom.Sphere.Define(s, '/postlayer/sphere1')

        """
    def postLayerNames(self) -> Tuple[str, ...]:
        """

        postLayerNames(self) -> tuple of str

            Returns the names of all post-layers authored on the LOP Network.
            These names can be passed to the other post-layer methods on this
            object to uniquely identify a specific post-layer to operate on. The
            list is ordered from strongest to weakest in terms of its effect on
            the composed stage.


        """
    def postLayer(self, name: str) -> pxr.Sdf.Layer|None:
        """

        postLayer(self, name) -> pxr.Sdf.Layer or None

            Returns a non-editable pxr.Sdf.Layer object that can be used to
            inspect the contents of a post-layer without triggering any change
            notifications as would occur when calling editablePostLayer. If
            there is no post-layer with the specified name, None is returned
            instead.


        """
    def removePostLayer(self, name: str) -> None:
        """

        removePostLayer(self, name)

            Removes a post-layer from the LOP Network. If the specified name
            does not identify an existing post-layer, this method does nothing.


        """
    def selection(self) -> Tuple[str, ...]:
        """

        selectionWithInstanceIds(self) -> tuple of str

            Return a tuple of strings representing all the scene graph locations
            of the instances currently selected in the LOP Network parent of
            this LOP node.


        """
    def selectionCurrentPrim(self) -> str:
        """

        selectionCurrentPrim(self) -> str

            Return a string with the path to the scene graph primitive that
            should be displayed in the Scene Graph Details pane. Set this value
            with the hou.LopNetwork.setSelection method.


        """
    def selectionWithInstanceIds(self) -> Tuple[str, ...]: ...
    def setSelection(self, selection: Sequence[str], currentprim: Optional[str] = None) -> None:
        """

        setSelection(self, selection, currentprim = None)

            Accepts a tuple of strings holding the scene graph locations which
            should become the selection in the LOP Network parent of this LOP
            node. This selection will be reflected in the Scene Graph Tree pane
            and the LOP viewport.

            The optional currentprim string can be supplied to have the Scene
            Graph Details pane show the information for a primitive at a
            specific path. The currentprim is usually in the selection list, but
            it doesn't need to be. Passing None for currentprim will set the
            current primitive to be the first primitive in the selection list.


        """
    def selectionRules(self) -> dict[str, LopSelectionRule]:
        """

        selectionRules(self) -> dict of str to hou.LopSelectionRule

            Return a dictionary mapping string names to hou.LopSelectionRule
            objects that match the selection rules stored on the LOP Network
            that owns this LOP node.


        """
    def clearSelectionRules(self) -> None:
        """

        clearSelectionRules(self)

            Deletes all selection rules stored on the LOP Network that owns this
            LOP node.


        """
    def setSelectionRule(self, name: str, rule: LopSelectionRule) -> None:
        """

        setSelectionRule(self, name, rule)

            Stores a named selection rule on the LOP Network that owns this LOP
            node. The rule parameter must be a hou.LopSelectionRule or None. Use
            None to remove a single named rule from the LOP Network.

            The selection rule name can be a slash-separated path, in which case
            the selection rule will appear in the Scene Graph Tree pane as part
            of a nested hierarchy. This in no way affects the operation of the
            rule, serving only as a way of organizing sets of rules.


        """
    def expansionState(self) -> Optional[LopExpansionState]:
        """

        expansionState(self) -> hou.LopExpansionState


        """
    def setExpansionState(self, expansion_state: LopExpansionState) -> None:
        """

        setExpansionState(self, expansion_state)


        """
    def saveNamedExpansionState(self, name: str, expansion_state: LopExpansionState) -> None:
        """

        saveNamedExpansionState(self, name, expansion_state)


        """
    def loadNamedExpansionState(self, name: str) -> Optional[LopExpansionState]:
        """

        loadNamedExpansionState(self, name) -> hou.LopExpansionState


        """
    def namedExpansionStates(self) -> Tuple[str, ...]:
        """

        namedExpansionStates(self) -> tuple of str


        """
    def setPrimitiveExpansionUnlocked(self, path: str, preserve_descendant_expansion: bool = True) -> bool:
        """

        setPrimitiveExpansionUnlocked(self, path,
        preserve_descendant_expansion=True) -> bool

            Removes the path from the expansionLockedPrimitives set. This also
            removes this prim and all its descendants from the
            expansionLockedExpandedPrimitives set.

            Setting preserve_descendant_expansion to False causes this method to
            remove all descendants of the path from the list of expansion locked
            and expansion locked expanded prims before setting the newly
            requested expansion locking and expanded states.

            The effect of this method is the same as fetching the
            hou.LopExpansionState object using expansionState, calling
            hou.LopExpansionState.setPrimitiveExpansionUnlocked on that object,
            then calling setExpansionState. But calling this method directly on
            the LOP Network will be much faster in scenarios with large, complex
            expansion states.


        """
    def setPrimitiveExpansionLocked(self, path: str, expanded_subpaths: Optional[Any] = None, preserve_descendant_expansion: bool = True) -> bool:
        """

        setPrimitiveExpansionLocked(self, path, expanded_subpaths,
        preserve_descendant_expansion=True) -> bool

            Locks the expansion state effect of a branch of the scene graph
            tree. The path parameter specifies the root prim which is locked,
            and will appear in the expansionLockedPrimitives set. The
            expanded_subpaths iterable of str or pxr.Sdf.Path objects is the set
            of all prims at or descended from path which should be treated as
            being expanded. For a prim to be treated as expanded by the
            expansion effect, every prim between the root path and the final
            prim must appear in this set.

            Prims in the expanded_subpaths which are not descendants of path are
            ignored.

            Setting preserve_descendant_expansion to False causes this method to
            remove all descendants of the path from the list of expansion locked
            and expansion locked expanded prims before setting the newly
            requested expansion locking and expanded states.

            The effect of this method is the same as fetching the
            hou.LopExpansionState object using expansionState, calling
            hou.LopExpansionState.setPrimitiveExpansionLocked on that object,
            then calling setExpansionState. But calling this method directly on
            the LOP Network will be much faster in scenarios with large, complex
            expansion states.


        """

class LopNode(OpNode):
    """

    hou.LopNode

    Represents a lighting node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns whether this node's bypass flag is on.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turns this node's bypass flag on or off, making this node have no
            effect.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Returns whether this node's display flag is on.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turn this node's display flag on or off.


        """
    def isDebugFlagSet(self) -> bool:
        """

        isDebugFlagSet(self) -> bool

            Returns True if the node's debug flag is turned on. Returns False
            otherwise.


        """
    def setDebugFlag(self, on: bool) -> None:
        """

        setDebugFlag(self, on)

            Turns the node's debug flag on or off. The debug flag on a LOP node
            is used to force the node to create its own USD Layer and apply its
            edits in that new layer. This makes it easier to track which scene
            graph modifications were made by which LOP node. Setting this flag
            will also affect the performance of the LOP Network since
            composition of the USD stage takes longer if there are more layers.

            Raises hou.PermissionError if the node is unwritable.


        """
    def displayNode(self) -> LopNode:
        """

        displayNode(self) -> Node

            If this is a LOP Network or a subnet LOP, return the LOP node inside
            the subnet with its display flag on. Otherwise, return None.


        """
    def viewerNode(self) -> Node:
        """

        viewerNode(self) -> Node

            If this is a subnet LOP, return the LOP node inside the subnet with
            its display flag on. If the subnet LOP doesn't contain any children
            with a display flag set, the viewer node of the containing LOP
            Network or subnet is returned. This algorithm is the one used to
            determine which LOP node's stage to display in the 3D viewport. This
            recursive approach allows the user to work on the nodes inside a
            sub-network while viewing the result of the containing LOP network
            in the viewport.


        """
    def editableLayer(self) -> pxr.Sdf.Layer:
        """

        editableLayer(self) -> pxr.Sdf.Layer

            Returns a pxr.Sdf.Layer object with permission to edit that
            represents the active layer in a Python LOP. After calling this
            method, the uneditableStage method can be called to access a read-
            only pxr.Usd.Stage representation of the input to the Python LOP.


        """
    def activeLayer(self, output_index: int = ..., ignore_errors: bool = ..., use_last_cook_context_options: bool = ..., frame: float|None = ..., context_options: Mapping[str, Any] = ...) -> pxr.Sdf.Layer:
        """

        activeLayer(self, output_index = -1, ignore_errors = False,
        use_last_cook_context_options = True, frame = None, context_options =
        {}) -> pxr.Sdf.Layer

            Returns a pxr.Sdf.Layer object representing the USD layer that has
            been modified by this node.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            The ignore_errors can be set to True to indicate that if this LOP
            node is in an error state after cooking, this method should search
            up the network looking for the first node not in an error state, and
            return the active layer from that node instead.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def editableStage(self) -> pxr.Usd.Stage:
        """

        editableStage(self) -> pxr.Usd.Stage

            Returns a pxr.Usd.Stage object with permission to edit that
            represents the USD stage input to a Python LOP.


        """
    def uneditableStage(self) -> pxr.Usd.Stage:
        """

        uneditableStage(self) -> pxr.Usd.Stage

            Returns a pxr.Usd.Stage object after requesting either the
            editableStage or editableLayer of the currently running Python LOP
            node. If this node is not a Python LOP or neither editable object
            has yet been retrieved, this method returns None.

            If this method is called after calling editableStage, it returns
            exactly the same stage object, so it will in fact be editable, and
            any changes made through one stage object will be immediately
            visible on the other stage object.

            If this method is called after calling editableLayer, the returned
            stage will not have write permissions, and changes made to the
            editable layer will not be reflected on this stage object. The
            editable layer is not composed onto the returned stage object so
            changing it has no effect.


        """
    def stage(self, output_index: int = ..., apply_viewport_overrides: bool = ..., ignore_errors: bool = ..., use_last_cook_context_options: bool = ..., apply_post_layers: bool = ..., frame: float|None = ..., context_options: Mapping[str, Any] = ...) -> pxr.Usd.Stage:
        """

        stage(self, output_index = -1, apply_viewport_overrides = False,
        ignore_errors = False, use_last_cook_context_options = True,
        apply_post_layers = True, frame = None, context_options = {}}) ->
        pxr.Usd.Stage

            Returns a pxr.Usd.Stage object representing the USD stage output
            from this node. Set apply_viewport_overrides to True to return a
            stage with its session layer set with any temporary activation or
            visibility settings configured in the scene graph tree. Set it to
            False to return the stage without these overrides applied in the
            session layer.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            The apply_viewport_overrides flag controls whether or not the
            returned stage will have the LOP Network's current set of viewport
            overrides applied to the session layer. These viewport overrides are
            authored by interacting with the Scene Graph Tree pane.

            The ignore_errors flag can be set to True to indicate that if this
            LOP node is in an error state after cooking, this method should
            search up the network looking for the first node not in an error
            state, and return the stage from that node instead.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            The apply_post_layers flag controls whether or not the returned
            stage will have the LOP Network's post-layers applied to the session
            layer.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def sourceLayer(self, layer_index: int = ..., output_index: int = ..., use_last_cook_context_options: bool = ..., frame: float|None = ..., context_options: Mapping[str, Any] = ...) -> pxr.Sdf.Layer:
        """

        sourceLayer(self, layer_index = 0, output_index = -1,
        use_last_cook_context_options = True, frame = None, context_options =
        {}) -> pxr.Sdf.Layer

            Return a pxr.Sdf.Layer object representing the specific requested
            USD layer that is used to build the stage that is the output of this
            node.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def stagePrimStats(self, primpath: str|None = ..., output_index: int = ..., apply_viewport_overrides: bool = ..., ignore_errors: bool = ..., do_geometry_counts: bool = ..., do_separate_purposes: bool = ..., use_last_cook_context_options: bool = ..., apply_post_layers: bool = ..., frame: float|None = ..., context_options: Mapping[str, str|float]|None = ...) -> dict[str, int]:
        """

        stagePrimStats(self, primpath = None, output_index = -1,
        apply_viewport_overrides = False, ignore_errors = False,
        do_geometry_counts = False, do_separate_purposes = False,
        use_last_cook_context_options = True, apply_post_layers = True, frame =
        None, context_options = {}, do_kind_counts = False, include_root = True)
        -> dict

            Returns a dictionary of statistics about the specified USD primitive
            on the USD stage output from this node. These statistics include a
            count of primitives of each type, the number of primitives with
            loaded and unloaded payloads, and other useful information about the
            type and complexity of information under the specified primitive.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            Set apply_viewport_overrides to True to return statistics from a
            stage with its session layer set with any temporary activation or
            visibility settings configured in the scene graph tree. Set it to
            False to return the statistics for the stage with an empty session
            layer.

            The apply_post_layers flag controls whether or not the stats will be
            generated with the LOP Network's post-layers applied to the session
            layer.

            The ignore_errors parameter can be set to True to indicate that if
            this LOP node is in an error state after cooking, this method should
            search up the network looking for the first node not in an error
            state, and return the statistics from that node instead.

            The do_geometry_counts parameter can be set to True to generate more
            details information about some USD primitive types, such as the
            total number of polygons on Mesh primitives, the number of curves on
            BasisCurves primitives, and the number of instances in
            PointInstancer primitives. The generation of these statistics may
            involve reading additional data from USD files on disk.

            Set do_separate_purposes to True to return per-purpose statistics,
            as well as the total counts. This separation into purposes applies
            to both basic primitive counts and the detailed geometry counts.

            Set do_kind_counts to True to return counts of the number of prims
            of each Kind. The returned dictionary of stats puts the count for
            each kind under a key of the form Kind:<kind_name>:count. The
            validity of the model hierarchy is taken into account, so a prim
            that specifies group kind but which is not part of a valid model
            hierarchy will not be counted.

            Set include_root to False if you do not want the prim specified by
            primpath to be included in the counts.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def lastModifiedPrims(self) -> Tuple[pxr.Sdf.Path, ...]:
        """

        lastModifiedPrims(self) -> tuple of pxr.Sdf.Path

            Returns the paths of the USD primitives modified by this node's last
            cook.


        """
    def inputPrims(self, inputidx: int) -> Tuple[pxr.Sdf.Path, ...]:
        """

        inputPrims(self, inputidx) -> tuple of pxr.Sdf.Path

            Returns the paths of the USD primitives modified by the specified
            input of this node. Returns None if the input is not connected. This
            method is roughly equivalent to:

          > lopnode.inputs()[inputidx].lastModifiedPrims()

        """
    def setLastModifiedPrims(self, primPaths: Sequence[str]) -> None:
        """

        setLastModifiedPrims(self, primpaths)

            When used in a Python based LOP node, this method sets the value
            that will be returned by subsequent calls to lastModifiedPrims. The
            primpaths parameter must be an iterable of pxr.Sdf.Path objects or
            strings.


        """
    def loadMasks(self, output_index: int = ..., force_cook: bool = ..., use_last_cook_context_options: bool = ..., frame: float|None = ..., context_options: Mapping[str, str|float]|None = ...) -> LopViewportLoadMasks:
        """

        loadMasks(self, output_index = -1, force_cook = False,
        use_last_cook_context_options = True, frame = None, context_options =
        {}) -> hou.LopViewportLoadMasks

            Returns the load masking configuration cooked into the stage at this
            LOP node. This object controls stage population masking and layer
            muting. These masks can be set using the Configure Stage LOP. These
            load masks will affect the primitives available on the stage when
            cooking this node or nodes below it.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            The force_cook flag can be set to True to cause the LOP node to cook
            before returning the load mask.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def sourceLayerCount(self, output_index: int = ..., use_last_cook_context_options: bool = ..., frame: float|None = ..., context_options: Mapping[str, str|float]|None = ...) -> LopViewportLoadMasks:
        """

        sourceLayerCount(self, output_index = -1, use_last_cook_context_options
        = True, frame = None, context_options = {}) -> int

            Returns the number of source layers that are used to build the stage
            at the output of this node. The result from this method will be one
            greater than the maximum value that can be passed to the sourceLayer
            method.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def layersAboveLayerBreak(self, output_index: int = ..., use_last_cook_context_options: bool = ..., frame: float|None = ..., context_options: Mapping[str, str|float]|None = ...) -> Tuple[str,...]:
        """

        layersAboveLayerBreak(self, output_index = -1,
        use_last_cook_context_options = True, frame = None, context_options =
        {}) -> tuple of str

            Returns the identifiers of all layers that will be removed by layer
            flattening or USD save operations because they were added to the
            stage above a Layer Break LOP. These are identifiers may include
            anonymous layer identifiers and paths to USD layers on disk.

            The output_index specifies which output of a multi-output LOP to
            access. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.

            The use_last_cook_context_options flag indicates that when cooking
            this node, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            A frame number can be provided to return the result of cooking the
            LOP node at a particular frame.

            The context_options parameter is a dict of str to either str or
            float values. These context options are used to cook the LOP node,
            overriding the current global context options.


        """
    def isMostRecentStageLock(self) -> bool:
        """

        isMostRecentStageLock(self) -> bool

            Return True if this LOP node was the node that most recently locked
            its shared USD stage. Since many LOP nodes can share a single USD
            stage, it is generally node safe to hold onto the result of a call
            to stage() beyond the invocation of a single python function.
            Houdini may need to cook another node in the LOP network that shares
            the USD stage with this node. At which point accessing data from
            this previously fetched stage object can return unexpected results.
            If this method returns True, then it is safe to read from the
            previously fetched stage object, and expect the results to reflect
            the state of the stage as output by this LOP node.


        """
    def inEditLayerBlock(self) -> bool:
        """

        inEditLayerBlock(self) -> bool

            Return True if this LOP node is inside an Edit Layer Block. This
            occurs if this node's input is connected to Edit Layer Begin LOP, or
            another LOP that is in an Edit Layer Block.


        """
    def selectionRule(self, inputidx: int = -1, pattern: Optional[str] = None) -> LopSelectionRule:
        """

        selectionRule(self, inputidx=-1, pattern=None) -> hou.LopSelectionRule

            Returns a selection rule pre-configured to evaluate its pattern
            using this node as the source of the USD stage when calling
            hou.LopSelectionRule.expandedPaths or similar methods that take a
            LOP node as a parameter. The inputidx parameter can further be used
            to cause selection rule evaluations to use the USD stage of one of
            the inputs to this node, instead of this node itself. This shortcut
            can simplify the code for evaluating a rule repeatedly.

            The optional pattern parameter populates the selection rule with the
            supplied pattern string. This is equivalent to creating the rule and
            then calling hou.LopSelectionRule.setPathPattern.


        """
    def addLockedGeometry(self, identifier: str, geo: Geometry, args: Mapping[str, str]|None = ...) -> str:
        """

        addLockedGeometry(self, identifier, geo, args = {}) -> str

            Adds a locked copy of a hou.Geometry to a registry, so that it can
            be used as a USD reference or sublayer.

            The returned string is a USD layer identifier that can be used when
            adding a composition arc.

            If an args dictionary is specified, the contents must be pre-
            converted to be strings. For example: { 't': '1.0' } is valid, but {
            't': 1.0 } is not.


            NOTE
                The registry entries created by using this function are tied to
                this LOP node and will be destroyed when the LOP node is
                destroyed.

            Example:

          > geo = hou.Geometry()
          > geo.loadFromFile('$HH/geo/shaderteapot.bgeo')
          > node = hou.pwd()
          > stage = node.editableStage()
          > layer_id = node.addLockedGeometry('teapot', geo)
          > node.addSubLayer(layer_id)

            See also hou.lop.addLockedGeometry


        """
    def addHeldLayer(self, identifier: str) -> None:
        """

        addHeldLayer(self, identifier)

            Add the USD layer specified by the identifier argument to an
            internal registry to prevent it from being deleted by USD if the
            layer is no longer part of a composed stage (for example if it was
            created by a Python LOP inside as Subnet which then had the Bypass
            flag enabled).

            Note the loputils.createPythonLayer method will automatically call
            this, and hou.LopNode.addSubLayer similarly holds the layer
            automatically.

          > import loputils
          > from pxr import Sdf
          > node = hou.pwd()
          > stage = node.editableStage()
          > layer = loputils.createPythonLayer(node)
          > subLayer1 = loputils.createPythonLayer(node)
          > subLayer2 = Sdf.Layer.CreateAnonymous()
          > node.addHeldLayer(subLayer2.identifier)
          > layer.subLayerPaths.append(subLayer1)
          > layer.subLayerPaths.append(subLayer2)
          > node.addSubLayer(layer.identifier)

        """
    def addSubLayer(self, identifier: str) -> None:
        """

        addSubLayer(self, identifier)

            Add the USD layer specified by the identifier argument as a sublayer
            to the root layer of the USD stage. The layer identifier can refer
            to an existing file on disk, or an anonymous layer created earlier
            in the python script. Call editableStage() before calling this
            method, or it will raise an exception.

            Houdini has certain requirements for anonymous layers authored by
            LOP nodes to ensure that they can be saved to disk in a predictable
            way. The loputils.createPythonLayer method creates a new layer,
            properly configured so that it can be added to the LOP stage and
            saved to disk like any other LOP-authored layer.

          > import loputils
          > from pxr import Sdf
          > node = hou.pwd()
          > stage = node.editableStage()
          > layer = loputils.createPythonLayer(node, '$HIP/myfile.usda')
          > p = Sdf.CreatePrimInLayer(layer, '/cube')
          > p.specifier = Sdf.SpecifierDef
          > p.typeName = 'Cube'
          > node.addSubLayer(layer.identifier)

        """
    def savePaths(self) -> Tuple[str, ...]:
        """

        savePaths(self) -> list of str

            Returns a list of all the save paths for all layers used by the
            stage.


        """

class lop:
    """

    hou.lop

    Module containing functions related to Houdini LOP nodes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def defaultNewPrimPath() -> str:
        """

        defaultNewPrimPath() -> str

            Return the USD primitive path that will be used by default on new
            LOP nodes with a primpath parameter with a default of /$OS.


        """
    @staticmethod
    def setDefaultNewPrimPath(path: str) -> None:
        """

        setDefaultNewPrimPath(path)

            Set the USD primitive path that will be used by default on new LOP
            nodes with a primpath parameter with a default of /$OS. This
            identifies a parameter that is used to create a new USD primitive.
            Being able to control this default makes it easier to conform to
            studio-wide standard naming conventions for primitive paths.


        """
    @staticmethod
    def defaultCollectionsPrimPath() -> str:
        """

        defaultCollectionsPrimPath() -> str

            Return the USD primitive path that will be used as the default
            location when creating new collections. If not set, the default
            value is /collections.


        """
    @staticmethod
    def setDefaultCollectionsPrimPath(path: str) -> None:
        """

        setDefaultCollectionsPrimPath(path)

            Set the USD primitive path that will be used as the default location
            when creating new collections. Being able to control this default
            makes it easier to conform to studio-wide standard naming
            conventions for primitive paths.


        """
    @staticmethod
    def defaultCollectionsPrimType() -> str:
        """

        defaultCollectionsPrimType() -> str

            Return the USD primitive type that will be created for holding
            collections when the destination primitive doesn't already exist. If
            not set, the default value is an empty string, indicating that a
            typeless primitive will be created.


        """
    @staticmethod
    def setDefaultCollectionsPrimType(primtype: str) -> None:
        """

        setDefaultCollectionsPrimType(path)

            Set the USD primitive type that will be created for holding
            collections when the destination primitive doesn't already exist.
            Being able to control this default makes it easier to conform to
            studio-wide standard conventions for using primitive types.


        """
    @staticmethod
    def defaultLightsPrimPath() -> str:
        """

        defaultLightsPrimPath() -> str

            Return the USD primitive path that will be used as the default
            location when creating new lights. If not set, the default value is
            /lights.


        """
    @staticmethod
    def setDefaultLightsPrimPath(path: str) -> None:
        """

        setDefaultLightsPrimPath(path)

            Set the USD primitive path that will be used as the default location
            when creating new lights. Being able to control this default makes
            it easier to conform to studio-wide standard naming conventions for
            primitive paths.


        """
    @staticmethod
    def defaultCamerasPrimPath() -> str:
        """

        defaultCamerasPrimPath() -> str

            Return the USD primitive path that will be used as the default
            location when creating new cameras. If not set, the default value is
            /cameras.


        """
    @staticmethod
    def setDefaultCamerasPrimPath(path: str) -> None:
        """

        setDefaultCamerasPrimPath(path)

            Set the USD primitive path that will be used as the default location
            when creating new cameras. Being able to control this default makes
            it easier to conform to studio-wide standard naming conventions for
            primitive paths.


        """
    @staticmethod
    def defaultTransformSuffix() -> str:
        """

        defaultTransformSuffix() -> str

            Return the string that will be used as the default suffix on
            transform attribute names.


        """
    @staticmethod
    def setDefaultTransformSuffix(suffix: str) -> None:
        """

        setDefaultTransformSuffix(suffix)

            Set the string that will be used as the default suffix on transform
            attribute names. USD transforms always start with xformOp: followed
            by the transform type (translate, rotate, transform), followed by an
            optional suffix that describes the transform. This string is the
            default Houdini will use in situations where this suffix can be
            provided, which can help make USD layers authored in LOPs conform to
            studio-wide standard naming conventions.


        """
    @staticmethod
    def showResolvedPaths() -> bool:
        """

        showResolvedPaths() -> bool

            Return True if the option to show resolved layer file paths is
            turned on.


        """
    @staticmethod
    def setShowResolvedPaths(show_resolved_paths: bool) -> None:
        """

        setShowResolvedPaths(show_resolved_paths)

            Set the option to control whether panels that show layer file paths
            should display the exact path set on the layer, or the path after
            passing it through the USD path resolver. The resolved path will
            generally be a full path to a file on disk, where the unresolved
            path may be a relative path, a search path, or a path format that is
            specific to a custom resolver.


        """
    @staticmethod
    def panesFollowCurrentNode() -> bool:
        """

        panesFollowCurrentNode() -> bool

            Return True if LOP panes such as the Scene Graph Tree and Scene
            Graph Details should follow the current node selected in the network
            editor.


        """
    @staticmethod
    def setPanesFollowCurrentNode(follow_current_node: bool) -> None:
        """

        setPanesFollowCurrentNode(follow_current_node)

            Set the option for LOP panes such as the Scene Graph Tree and Scene
            Graph Details to follow the current node selected in the network
            editor. If set to False, these panes will instead show information
            for the LOP node with its display flag set.


        """
    @staticmethod
    def panesShowViewportStage() -> bool:
        """

        panesShowViewportStage() -> bool

            Return True if LOP panes such as the Scene Graph Tree and Scene
            Graph Details should show information about the USD stage generated
            by applying any viewport overrides set in the Scene Graph Tree.


        """
    @staticmethod
    def setPanesShowViewportStage(show_viewport_stage: bool) -> None:
        """

        setPanesShowViewportStage(show_viewport_stage)

            Set the option for LOP panes such as the Scene Graph Tree and Scene
            Graph Details to show information about the USD stage generated by
            applying any viewport overrides set in the Scene Graph Tree.

            Turning this option off will improve the performance of these panes
            when there are viewport overrides applied to the scene. The tradeoff
            is that the values shown in the scene graph tree and scene graph
            details for visibility and activation may not match what is shown in
            the viewport. However it will better match the scene description
            that would be used by a final render, as viewport overrides are not
            included in the USD sent to a final render.


        """
    @staticmethod
    def panesShowPostLayers() -> bool:
        """

        panesShowPostLayers() -> bool

            Return True if LOP panes such as the Scene Graph Tree and Scene
            Graph Details should show information about the USD stage generated
            by applying any post-layers applied to the parent LOP Network.


        """
    @staticmethod
    def setPanesShowPostLayers(show_post_layers: bool) -> None:
        """

        setPanesShowPostLayers(show_post_layers)

            Set the option for LOP panes such as the Scene Graph Tree and Scene
            Graph Details to show information about the USD stage generated by
            applying any post-layers applied to the parent LOP Network.


        """
    @staticmethod
    def autoSetAssetResolverContext() -> bool:
        """

        autoSetAssetResolverContext() -> bool

            Return True if the Sublayer and Reference LOP nodes should
            automatically use their first USD layer loaded from disk as the
            resolver context asset path passed to the USD stage to define it's
            asset resolver context.


        """
    @staticmethod
    def setAutoSetAssetResolverContext(auto_set_context: bool) -> None:
        """

        setAutoSetAssetResolverContext(auto_set_context)

            Pass in a value of True if the Sublayer and Reference LOP nodes
            should automatically use their first USD layer loaded from disk as
            the resolver context asset path passed to the USD stage to define
            it's asset resolver context. The resolver context is used by the USD
            asset resolver to help find the right files when opening a layer
            file in the context of a particular stage. Often this resolver
            context can be determined by looking at the root layer of the stage.
            In the case of LOPs, the first layer loaded by a Sublayer or
            Reference LOP is the closest thing we have to a root layer. This
            preference makes it easier to implement this workflow. The
            alternative involves using a Configure Stage LOP as the first node
            in the LOP Network to explicitly set the resolver context asset
            path. Similarly this option only affects a Sublayer or Reference LOP
            if it is the first node in the chain.


        """
    @staticmethod
    def updateRendererInBackground() -> bool:
        """

        updateRendererInBackground() -> bool

            Return True if the LOP viewport has been configured to run update
            tasks in the background.


        """
    @staticmethod
    def setUpdateRendererInBackground(update_in_background: bool) -> None:
        """

        setUpdateRendererInBackground(update_in_background)

            Pass in a value of True to cause the LOP viewport to run update
            tasks in the background, which results in better interactivity but
            allows the viewport display to be temporarily out of sync with the
            current cooked LOP stage.


        """
    @staticmethod
    def loadPayloadsByDefault() -> bool:
        """

        loadPayloadsByDefault() -> bool

            Return True if new LOP Networks will be created with the option to
            load all payloads in the viewport enabled.


        """
    @staticmethod
    def setLoadPayloadsByDefault(load_payloads: bool) -> None:
        """

        setLoadPayloadsByDefault(load_payloads)

            Pass in a value of True to cause new LOP Networks to be created with
            the option to load all payloads in the viewport enabled. Pass in a
            value of False to disable the loading of payloads in the viewport
            for any new LOP Networks. No existing LOP Networks are affected by
            this method. The default value for this preference is True.


        """
    @staticmethod
    def allowViewportOnlyPayloads() -> bool:
        """

        allowViewportOnlyPayloads() -> bool

            Return True if the scene graph tree can allow the user to force the
            loading of a payload into the viewport which has been prevented from
            loading by a Configure Stage node. Return False if the scene graph
            tree should prevent the explicit loading of such payloads. This
            value ensures that the viewport will only show payloads that have
            been processed by the LOP network, eliminating a potential mismatch
            between the scene displayed in the viewport, and the same scene
            rendered with the USD Render ROP with a different set of loaded
            payloads processed by the LOP Network.


        """
    @staticmethod
    def setAllowViewportOnlyPayloads(allow_viewport_only_payloads: bool) -> None:
        """

        setAllowViewportOnlyPayloads(allow_viewport_only_payloads)

            Set the flag that indicates whether the viewport is allowed to load
            payloads that have been specified as unloaded by a Configure Stage
            node.


        """
    @staticmethod
    def pathParameterCompletion() -> bool:
        """

        pathParameterCompletion() -> bool

            Return True if USD Primitive Path parameters should provide syntax
            highlighting and prim path completion hints. Enabling this may cause
            pauses when editing Primitive Path parameters with very large USD
            stages.


        """
    @staticmethod
    def setPathParameterCompletion(path_parameter_completion: bool) -> None:
        """

        setPathParameterCompletion(path_parameter_completion)

            Set the flag that indicates whether the USD Primitive Path
            parameters should provide path completion hints.


        """
    @staticmethod
    def defaultMetersPerUnit() -> float:
        """

        defaultMetersPerUnit() -> float

            Return the default meters per unit metric that will be saved into
            USD layers that do not have this value explicitly set. A value of
            zero indicates that Houdini's Unit Length option will be used to
            generate an equivalent meters per unit value.


        """
    @staticmethod
    def setDefaultMetersPerUnit(meters_per_unit: float) -> None:
        """

        setDefaultMetersPerUnit(meters_per_unit)

            Set the default meters per unit metric that will be saved into USD
            layers that do not have this value explicitly set. A value of zero
            indicates that Houdini's Unit Length option should be used to
            generate an equivalent meters per unit value.


        """
    @staticmethod
    def defaultUpAxis() -> str:
        """

        defaultUpAxis() -> str

            Return the default up axis value that will be saved into USD layers
            that do not have this value explicitly set. An empty string
            indicates that the USD up axis fallback value
            (pxr.UsdGeom.GetFallbackUpAxis) should be used.


        """
    @staticmethod
    def setDefaultUpAxis(up_axis: str) -> None:
        """

        setDefaultUpAxis(up_axis)

            Set the default up axis that will be saved into USD layers that do
            not have this value explicitly set. An empty string indicates that
            the USD up axis fallback value (pxr.UsdGeom.GetFallbackUpAxis)
            should be used. Other acceptable values are Y and Z. Trying to set
            any other value will raise a hou.ValueError exception.


        """
    @staticmethod
    def savePreferences() -> bool:
        """

        savePreferences() -> bool

            Saves out the current LOP preferences to
            $HOME/houdiniX.Y/solaris.pref. This happens automatically when the
            preferences are modified in the preferences dialog, and when exiting
            Houdini. But in a batch scripting environment, changes made to these
            preferences will not be saved automatically, so this method must be
            used. Returns True is the preference file was saved successfully.


        """
    @staticmethod
    def reloadLayer(layer_path: str, recursive: bool = False) -> None:
        """

        reloadLayer(layer_path, recursive = False)

            This method calls the USD Reload method for the specified layer
            path. In addition, it updates internal Houdini data structures of
            the reload so that they can update. This method should be used in
            place of the pxr.Sdf.Layer.Reload or similar methods when running in
            Houdini.

            Setting the recursive parameter to True will cause Houdini to
            recursively look for other layers referenced by the specified layer,
            and reload them as well.


        """
    @staticmethod
    def mutingIdentifier(identifier: str) -> str:
        """

        mutingIdentifier(self, identifier)

            Return the identifier that will be returned by
            hou.LopViewportLoadMasks.muteLayers when muting a USD layer authored
            by a LOP node. This identifier will be of the form
            lop:/path/to/lop/node, which is not a valid USD layer identifier,
            and should not be used as such. But in the context of layer muting,
            this special string is recognized as a way to mute anonymous layers
            authored by LOP nodes (even if that LOP node occurs later in the LOP
            network). When calling hou.LopViewportLoadMasks.addMuteLayer or
            hou.LopViewportLoadMasks.removeMuteLayer, either the original
            anonymous LOP layer identifier of the return of calling this method
            are acceptable. Anonymous layer identifiers will be automatically
            translated into this special muting identifier form.


        """
    @staticmethod
    def makeValidPrimName(name: str) -> str:
        """

        makeValidPrimName(name) -> str

            This function ensures that a string meets the requirements of a
            legal USD primitive name that can be used as part of a valid
            primitive path. Invalid characters such as spaces and most
            punctuation will be converted to underscores. Note that this means
            the translation is not reversible. If the original string is already
            a legal primitive name, the name is returned unchanged.


        """
    @staticmethod
    def makeValidPrimPath(path: str, allow_relative: bool = False) -> str:
        """

        makeValidPrimPath(path, allow_relative = False) -> str

            This function ensures that a string meets the requirements of a
            legal USD primitive path that can be converted into a psx.Sdf.Path
            object. Invalid characters such as spaces and most punctuation will
            be converted to underscores. Note that this means the translation is
            not reversible. If the original string is already a legal primitive
            path, the string is returned unchanged.

            If the allow_relative value is True, the path is allowed to be a
            relative primitive path. A relative path is one that starts with ./
            or ../. If this argument is False, only absolute paths (which start
            with /) are allowed. Relative prefixes are simply removed from the
            path and the returned path will always start with a /.


        """
    @staticmethod
    def createParmsForProperty(source: LopNode|str, primpath: str, propertyname: str, parametername: str|None = ..., prepend_control_parm: bool = ..., prefix_xform_parms: bool = ...) -> ParmTemplateGroup:
        """

        createParmsForProperty(source, primpath, propertyname, parametername,
        prepend_control_parm, prefix_xform_parms) -> [Hom:hou.ParmTemplateGroup]

            Given a property on a USD stage, this method returns a
            hou.ParmTemplateGroup object that describes the parameters that can
            be placed on an Edit Properties LOP node to control that USD
            property.


            source
                Either a hou.LopNode object or a string. If a hou.LopNode, the
                property is extracted from the USD stage owned by that LOP node.
                If a string, the USD file on disk at the specified path will be
                loaded, and the property extracted from there.

            primpath
                Path to the USD primitive where the property lives.

            propertyname
                The name of the USD property for which parameters will be
                created.

            parametername
                The name of the parameter to generate. This value can be a
                string or None, in which case the parameter name will match the
                property name. It is the parameter names that determines the
                name of the property that will be authored by the Edit
                Properties node, so setting a value for this parameter will
                cause a different property to be authored than the one used to
                generate the parameter.

            prepend_control_parm
                Set to True if the returned parameter template group should
                include a menu for choosing whether the property value should be
                set, ignored, or one of the other standard actions supported by
                the Edit Properties node.

            prefix_xform_parms
                If the specified property is a transform property, this method
                will generate separate translate, rotate, scale, and other
                parameters that get combined to generate a transformation
                matrix. If this option is set to False, these additional
                parameters will use standard Houdini transform parameter names
                like t, s, and r. If set to True, these parameter will be
                prefixed by the property name, which means the parameter names
                will not conflict with other transform parameters on the Edit
                Properties node.


        """
    @staticmethod
    def createParmsForParameter(source: ParmTemplate, parametername: Optional[str] = None, usdvaluetype: Optional[str] = None, prepend_control_parm: bool = True, propertyname: Optional[str] = None) -> ParmTemplateGroup:
        """

        createParmsForParameter(source, parametername, usdvaluetype,
        prepend_control_parm, propertyname) -> [Hom:hou.ParmTemplateGroup]

            Given a source node parameter, this method returns a
            hou.ParmTemplateGroup object that describes the parameters that can
            be placed on an Edit Properties LOP node to control a value of a
            corresponding USD property.

            The returned group contains a control parameter that decides how the
            USD property is changed and a value parameter, which is very similar
            to the given parameter, except for disable-when condition and a few
            other small differences.


            source
                A hou.ParmTemplate object on which to base the returned edit
                parameter group.

            parametername
                The name of the parameter to generate. This value can be a
                string or None, in which case the parameter name will match the
                given parameter.

            usdvaluetype
                The name of the USD type of the corresponding USD attribute.

            prepend_control_parm
                Set to True if the returned parameter template group should
                include a menu for choosing whether the property value should be
                set, ignored, or one of the other standard actions supported by
                the Edit Properties node.

            propertyname
                The name of the USD property that corresponds to this parameter.
                Usually, property name is inferred from the parameter name, but,
                optionally, it can be explicitly specified with this parameter.


        """
    @staticmethod
    def createConnectionParmsForProperty(source: LopNode|str, primpath: str, propertyname: str, parametername: str|None = ..., prepend_control_parm: bool = ...) -> ParmTemplateGroup:
        """

        createConnectionParmsForProperty(source, primpath, propertyname,
        parametername=None, prepend_control_parm=True) ->
        [Hom:hou.ParmTemplateGroup]

            Given a property on a USD stage, this method returns a
            hou.ParmTemplateGroup object that describes the parameters that can
            be placed on an Edit Properties LOP node to modify the connection of
            that USD (destination) property to a source attribute.


            source
                Either a hou.LopNode object or a string. If a hou.LopNode, the
                property is extracted from the USD stage owned by that LOP node.
                If a string, the USD file on disk at the specified path will be
                loaded, and the property extracted from there.

            primpath
                Path to the USD primitive where the property lives.

            propertyname
                The name of the USD property for which parameters will be
                created.

            parametername
                The name of the parameter to generate. This value can be a
                string or None, in which case the parameter name will be based
                on the property name.

            prepend_control_parm
                Set to True if the returned parameter template group should
                include a menu for choosing whether the property connection
                should be set, severed, or ignored or one of the other standard
                actions supported by the Edit Properties node.


        """
    @staticmethod
    def setParmTupleFromProperty(parmtuple: ParmTuple, source: LopNode|str, primpath: str, propertyname: str) -> None:
        """

        setParmTupleFromProperty(parmtuple, source, primpath, propertyname)

            Set the value of a node parameter tuple from the value of a property
            on a USD primitive. If the parameter cannot be set because the data
            type of the parameter is not compatible with the data type of the
            USD property, or the USD property cannot be found, raises a
            hou.OperationFailed exception.


            parmtuple
                A hou.ParmTuple object specifying the parameter which should be
                set to the value of the USD property.

            source
                A hou.LopNode object holding the USD stage from which the USD
                property value will be extracted.

                Either a hou.LopNode object or a string. If a hou.LopNode, the
                property value is extracted from the USD stage owned by that LOP
                node. If a string, the USD file on disk at the specified path
                will be loaded, and the property value extracted from there.

            primpath
                A string indicating the scene graph path of the USD primitive.

            propertyname
                A string indicating the name of the property on the USD
                primitive.


        """
    @staticmethod
    def shaderTranslatorID(node: Node) -> int:
        """

        shaderTranslatorID(node) -> int

            Returns the ID of the shader translator for the given node. The ID
            is specific to Houdini session and can change between them.


        """
    @staticmethod
    def shaderRenderContextName(node: Node, node_output_name: str) -> str:
        """

        shaderRenderContextName(node, node_output_name) -> str

            Returns the render context name for the given node and output. It is
            used in the USD material primitive output name, to associate the
            connected shader with a given renderer.


            node
                The shader node to whose render context name to return.

            node_output_name
                The output name for which to return the render context name.
                Nodes can have several output, each for a different renderer.


        """
    @staticmethod
    def translateShader(node: Node, node_output_name: str, material_prim_path: str, container_prim_path: str, shader_prim_name: str|None = ..., frame: float|None = ...) -> str:
        """

        translateShader(node, node_output_name, material_prim_path,
        container_prim_path, shader_prim_name=None, frame=None ) -> str

            Creates a new shader primitive and returns a path to the shader
            primitive output.


            node
                The shader node to translate into a USD shader primitive.

            node_output_name
                The node output that represents the shader to translate (if the
                node is a material), or an output value that is needed as an
                input to another USD shader primitive.

            material_prim_path
                The USD path to the material primitive that contains the USD
                shader.

            container_prim_path
                The path to the parent primitive (ie, NodeGraph or Material) in
                which the USD shader should be directly authored.

            shader_prim_name
                The name to be used for the created USD shader primitive. If not
                given, it will be inferred from the node.

            frame
                The frame number at which to evaluate node parameters, and also
                the USD time code at which to author animated attributes. If not
                given, the current time is used for evaluating parameters, and
                the USD attribute values are authored at the default time code.


        """
    @staticmethod
    def reportShaderTranslation(node: Node, usd_shader_path: str) -> None:
        """

        reportShaderTranslation(node, usd_shader_path)

            Adds an entry to the table of known shader translations. This allows
            LOPs to find out the USD shader primitives given a shader VOP node,
            which is necessary for incremental re-translation of shaders.


            node
                The shader node that was translated into a USD shader primitive.

            usd_shader_path
                The USD shader primitive path to which the node was translated.


        """
    @staticmethod
    def shaderNodeType(shader_name: str) -> NodeType:
        '''

        shaderNodeType(shader_name) -> hou.NodeType

            Returns a shader hou.NodeType given the shader name.

            Shader name is generic identifier of the abstract shader entity, and
            the returned node type is a representation of that shader in a form
            of the node of that type.

            For example, shader \\"foo\\" may correspond to a VOP node of type
            my_namespace::FooShader::2.0.


        '''
    @staticmethod
    def availableRendererNames() -> Tuple[str, ...]:
        """

        availableRendererNames() -> tuple of str

            Returns a tuple with the internal names of registered renderer
            plugins.


        """
    @staticmethod
    def availableRendererLabels() -> Tuple[str, ...]:
        """

        availableRendererLabels() -> tuple of str

            Returns a tuple with the display labels of registered renderer
            plugins.


        """
    @staticmethod
    def outputProcessors() -> Tuple[Tuple[str, str], ...]:
        """

        outputProcessors() -> tuple of tuple of str

            Returns a tuple holding the internal name and user facing label for
            each output processor plugin in the registry. See the USD ROP for
            more information about output processors.


        """
    @staticmethod
    def outputProcessorParms(name: str) -> ParmTemplateGroup:
        """

        outputProcessorParms(name) -> hou.ParmTemplateGroup

            Returns the parameters that can be used to configure the output
            processor with an internal name that matches the name parameter. See
            the USD ROP for more information about output processors.


        """
    @staticmethod
    def usdVersionInfo() -> dict[str, str]:
        """

        usdVersionInfo() -> dict of str to str

            Returns a dictionary holding information about the USD library built
            into Houdini.


            usdversion
                The USD release number converted to a string. USD releases take
                the form YY.MM, where YY and MM are the year and month in which
                the release occurred.

            packageurl
                The URL of the git repository from which the USD library was
                built.

            packagerevision
                The git commit hash code for the specific branch used to build
                the USD library.

            The packageurl and packagerevision values may return an empty string
            if the USD library that ships with Houdini is replaced with a custom
            USD build.


        """
    @staticmethod
    def usdOutputMinimumSeverity() -> EnumValue:
        """

        usdOutputMinimumSeverity() -> hou.severityType

            Returns the minimum USD message severity that will be output to
            standard output. The USD library can produce a variety of messages
            indicating error or warning conditions, or just status messages. If
            such a message is generated while a LOP node is cooking, the message
            will never be output to the console, regardless of this setting.


        """
    @staticmethod
    def setUsdOutputMinimumSeverity(severity: EnumValue) -> None:
        """

        setUsdOutputMinimumSeverity(hou.severityType)

            Sets the minimum message severity produced by the USD library that
            should be written to standard output. This method only controls the
            output of messages produced when a LOP node is not cooking.


        """
    @staticmethod
    def addLockedGeometry(identifier: str, geo: Geometry, args: Mapping[str, str]|None = ...) -> str:
        """

        addLockedGeometry(self, identifier, geo, args = {}) -> str

            Adds a locked copy of a hou.Geometry to a registry, so that it can
            be used as a USD reference or sublayer.

            The returned string is a USD layer identifier that can be used when
            adding a composition arc.

            If an args dictionary is specified, the contents must be pre-
            converted to be strings. For example: { 't': '1.0' } is valid, but {
            't': 1.0 } is not.


            NOTE
                The registry entries created by using this function must be
                explicitly removed via hou.lop.removeLockedGeometry.

            Example:

          > from pxr import Usd
          > geo = hou.Geometry()
          > geo.loadFromFile('shaderteapot.bgeo')
          > stage = Usd.Stage.CreateInMemory()
          > layer_id = hou.lop.addLockedGeometry('teapot', geo)
          > stage.GetRootLayer().subLayerPaths.append(layer_id)

            See also hou.LopNode.addLockedGeometry


        """
    @staticmethod
    def removeLockedGeometry(identifier: str) -> bool:
        """

        removeLockedGeometry(self, identifier) -> bool

            Removes a locked hou.Geometry from the registry, returning a bool to
            indicate success or failure.


            NOTE
                The identifier should be the str value returned from a previous
                call to hou.lop.addLockedGeometry.

            Example:

          > geo = hou.Geometry()
          > geo.loadFromFile('shaderteapot.bgeo')
          > layer_id = hou.lop.addLockedGeometry('teapot', geo)
          > hou.lop.removeLockedGeometry(layer_id)

        """
    @staticmethod
    def forceReloadAllFilesFromDisk(reload_viewports: bool = False) -> None:
        """

        forceReloadAllFilesFromDisk(self, reload_viewports)

            Presses the reload button on every LOP node with such a parameter.
            If the reload_viewports parameter is True, this method also clears
            all USD stages owned by scene viewer panes, which will effectively
            cause all USD stages in Houdini to be rebuilt from scratch. This is
            a potentially very expensive operation, but in some cases may be
            required to force USD to reload and re-resolve paths to assets on
            disk, such as when the configuration of an asset resolver has been
            changed.


        """
    @staticmethod
    def availableRendererInfo() -> list[dict[str, Any]]:
        """

        availableRendererInfo() -> list of dict

            Returns a list of dicts containing meta data for registered renderer
            plugins.


        """
    @staticmethod
    def addPreferenceChangeCallback(callback: Callable) -> None:
        """

        addPreferenceChangeCallback(callback)

            Registers a callback function that is invoked any time one of these
            preferences is changed.


        """
    @staticmethod
    def removePreferenceChangeCallback(callback: Callable) -> None:
        """

        removePreferenceChangeCallback(callback)

            Deregisters a callback function previously registered with a call to
            addPreferenceChangeCallback.


        """

class LopExpansionState:
    """

    hou.LopExpansionState

    Used to inspect or edit the scene graph tree expansion state of a LOP
    network.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Create an empty expansion state object, with no expanded primitives.


        """
    def setPinnedPathExpanded(self, path: str, expanded: bool) -> bool:
        """

        setPinnedPathExpanded(self, path, expanded) -> bool

            Change the expanded state of a single path in the pinned primitives
            section of the scene graph tree to be either expanded or collapsed.
            Returns True if this changes the expansion state, False otherwise.


        """
    def setPathExpanded(self, path: str, expanded: bool) -> bool:
        """

        setPathExpanded(self, path, expanded) -> bool

            Change the expanded state of a single path in the scene graph tree
            to be either expanded or collapsed. Returns True if this changes the
            expansion state, False otherwise.


        """
    def setPrimitiveExpansionUnlocked(self, path: str, preserve_descendant_expansion: bool = True) -> bool:
        """

        setPrimitiveExpansionUnlocked(self, path,
        preserve_descendant_expansion=True) -> bool

            Removes the path from the expansionLockedPrimitives set. This also
            removes this prim and all its descendants from the
            expansionLockedExpandedPrimitives set.

            Setting preserve_descendant_expansion to False causes this method to
            remove all descendants of the path from the list of expansion locked
            and expansion locked expanded prims before setting the newly
            requested expansion locking and expanded states.


        """
    def dumps(self) -> bytes:
        """

        dumps(self) -> hou.BinaryString

            Serialize the contexts of this expansion state object into a binary
            string.


        """
    def loads(self, expansion_str: bytes) -> None:
        """

        loads(self, overrides_str)

            Load the contents of a binary string into this expansion state
            object.


        """
    def expandedPinnedPaths(self) -> Any:
        """

        expandedPinnedPaths(self) -> tuple of pxr.Sdf.Path

            Return a tuple of paths that are expanded in the pinned primitives
            branch of the scene graph tree.


        """
    def setExpandedPinnedPaths(self, expanded_paths: Any) -> None:
        """

        setExpandedPinnedPaths(self, expanded_paths)

            The expanded_paths parameter is an iterable collection of strings or
            pxr.Sdf.Path objects indicating which primitives in the pinned
            primitives branch of the scene graph tree should be expanded.


        """
    def expandedPaths(self) -> Any:
        """

        expandedPaths(self) -> tuple of pxr.Sdf.Path

            Return a tuple of paths that are expanded in the scene graph tree.


        """
    def setExpandedPaths(self, expanded_paths: Any) -> None:
        """

        setExpandedPaths(self, expanded_paths)

            The expanded_paths parameter is an iterable collection of strings or
            pxr.Sdf.Path objects indicating which primitives in the scene graph
            tree should be expanded.


        """
    def expansionLockedPrimitives(self) -> Any:
        """

        expansionLockedPrimitives(self) -> tuple of pxr.Sdf.Path

            Returns the paths of all prims which have had their expansion effect
            in the scene graph tree locked, so this prim and its descendants are
            no longer affected by the scene graph tree expansion state. A prim
            in this set may be either locked in the expanded or collapsed state.


        """
    def expansionLockedExpandedPrimitives(self) -> Any:
        """

        expansionLockedExpandedPrimitives(self) -> tuple of pxr.Sdf.Path

            Returns the paths of all prims which have had their expansion effect
            in the scene graph tree locked in the expanded state. These prims
            will all be in or descndants of prims in the
            expansionLockedPrimitives set. Note that a prim in the
            expansionLockedPrimitives set may not appear in this set if the prim
            has been locked in a collapsed state.


        """
    def setPrimitiveExpansionLocked(self, path: str, expanded_subpaths: Optional[Any] = None, preserve_descendant_expansion: bool = True) -> bool:
        """

        setPrimitiveExpansionLocked(self, path, expanded_subpaths=None,
        preserve_descendant_expansion=True) -> bool

            Locks the expansion state effect of a branch of the scene graph
            tree. The path parameter specifies the root prim which is locked,
            and will appear in the expansionLockedPrimitives set. The
            expanded_subpaths iterable of str or pxr.Sdf.Path objects is the set
            of all prims at or descended from path which should be treated as
            being expanded. For a prim to be treated as expanded by the
            expansion effect, every prim between the root path and the final
            prim must appear in this set.

            Prims in the expanded_subpaths which are not descendants of path are
            ignored.

            Setting preserve_descendant_expansion to False causes this method to
            remove all descendants of the path from the list of expansion locked
            and expansion locked expanded prims before setting the newly
            requested expansion locking and expanded states.


        """
    __swig_destroy__: Incomplete

class LopInstanceIdRule:
    """

    hou.LopInstanceIdRule

    Stores a string that expresses a pattern to select instances from a
    point instancer primitive by id.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Create a LopInstanceIdRule object with default settings.


        """
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def instanceIds(self, lopnode: LopNode, use_last_cook_context_options: bool = True) -> Tuple[int, ...]:
        """

        instanceIds(self, lopnode, use_last_cook_context_options = True) ->
        tuple of int

            Calculates the instance ids that match the pattern on the point
            instancer primitive on the stage generated by the provided LOP node
            object. The returned tuple of integers are ids from the point
            instancer's ids attribute. If no ids attribute is set on the point
            instancer, the instances are assumed to have increasing ids starting
            at 0.

            The use_last_cook_context_options flag indicates that when cooking
            the lopnode, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.


        """
    def primPath(self) -> str:
        """

        primPath(self) -> str

            Return the path to the point instancer primitive that is used to
            evaluate the instance id pattern.


        """
    def setPrimPath(self, primpath: str) -> None:
        """

        setPrimPath(self, primpath)

            Sets the path to the point instancer primitive that is used to
            evaluate the instance id pattern.


        """
    def instanceIdPattern(self) -> str:
        """

        instanceIdPattern(self) -> str

            Return the pattern that described the instance ids that should be
            returned by the instanceIds method. This pattern accepts standard
            Houdini numeric range formatting, like what is provided in SOP group
            parameters.


        """
    def setInstanceIdPattern(self, pattern: str) -> None:
        """

        setInstanceIdPattern(self, pattern)

            Sets the pattern that described the instance ids that should be
            returned by the instanceIds method. This pattern accepts standard
            Houdini numeric range formatting, like what is provided in SOP group
            parameters, such as 2-5 to indicate ids between 2 and 5, or ^15 to
            exclude id number 15.


        """
    __swig_destroy__: Incomplete

class LopPostLayer:
    """

    hou.LopPostLayer

    Provides the ability to author post-layer data on a LOP Network.

    This object is used to define a with block in Python, which guarantees a
    well defined lifetime. Inside this block, this object provides access to
    an editable USD layer. When the block ends and this object is destroyed,
    the changes made to the USD layer are saved to the LOP Network, and any
    viewers pointed at nodes inside that LOP Network will be updated
    appropriately.

    This object is returned by a call to hou.LopNetwork.editablePostLayer.

    A post-layer is a concept within Solaris which allows USD layers to be
    added to the session layer of every LOP node's composed stage. These
    layers live outside the LOP node cook process, and so their content does
    not affect the operation of any LOP nodes. For example, primitives
    defined in a post-layer cannot be seen by any LOP nodes. But any request
    to access the stage of a LOP node will contain the content of these
    post-layers unless you specifically request that post-layers be excluded
    (using the apply_post_layers parameter in hou.LopNode.stage or turning
    off post layers in the Scene Viewer). Disabling post-layers should
    generally only be required when debugging the post-layer content.

    Because these are session layers, their opinions are stronger than any
    opinions authored by LOP nodes (which author opinions on the stage's
    root layer). Unlike Viewport Overrides, the content of these layers is
    also saved by the USD and USD Render ROPs, and so will affect final
    renders.

    Use cases for post-layers include the creation of standard primitives
    (like Render Settings) which should be available anywhere in the LOP
    Network. Another use case would be to apply a final pass to the scene
    graph data, such as disabling all materials for quick render tests. But
    since post-layers can only be authored by python code, integrating them
    into an artist's workflow will always require some custom user
    interface, though that interface may be as simple as providing
    checkboxes to turn certain post-layers on or off.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __enter__(self) -> LopPostLayer: ...
    def layer(self) -> pxr.Sdf.Layer: ...
    def stage(self) -> pxr.Usd.Stage: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class LopSelectionRule:
    """

    hou.LopSelectionRule

    Stores a set of rules that define how to make a selection of scene graph
    primitives.

    See for more information on primitive patterns.


    """
    thisown: Incomplete
    def __init__(self, pattern: Optional[str] = None) -> None:
        """

        __init__(self, pattern=None)

            Create a LopSelectionRule object with default settings.

            The optional pattern parameter populates the selection rule with the
            supplied pattern string. This is equivalent to creating the rule and
            then calling hou.LopSelectionRule.setPathPattern.


        """
    def expandedPaths(self, lopnode: LopNode|None = ..., return_ancestors: bool = ..., fallback_to_new_paths: bool = ..., stage: pxr.Usd.Stage|None = ..., use_last_cook_context_options: bool = ...) -> Tuple[pxr.Sdf.Path,...]:
        """

        expandedPaths(self, lopnode=None, return_ancestors=False,
        fallback_to_new_paths=False, stage=None, use_last_cook_context_options =
        True, lop_output_index = -1) -> tuple of pxr.Sdf.Path

            Calculates the scene graph primitive selection using the scene graph
            from the LOP node object provided as the lopnode parameter. If this
            selection rule was created with a call to hou.LopNode.selectionRule
            the lopnode parameter is assumed to be equal to the creator node. As
            an alternative to providing a LOP node, the pattern will evalaute
            over any Usd.Stage passed as the stage parameter. If both a LOP node
            and a Usd.Stage are provided, the stage parameter takes priority.

            Returns the full paths to every scene graph primitive matching the
            selection rules. All collections in the path pattern are expanded to
            list their included prims explicitly.

            If return_ancestors is set to True, after the full set of primitives
            is calculated, if there are any primitives with all of their direct
            children in the set, the parent primitive is added to the set, and
            the child primitives are removed from the set. This reduced set can
            be very useful to reduce the number of primitives that need to be
            modified if the modification is one that inherits down the scene
            graph tree (such as visibility or activation).

            The fallback_to_new_paths parameter can be set to True to allow the
            selection rule to return scene graph paths if the pattern consists
            entirely of explicit paths which do not correspond to any existing
            primitives on the stage. Such paths may be used to express desired
            scene graph locations for new primitives. If the pattern contains a
            mix of existing paths and new paths, this method will always return
            only the existing paths. The new paths in such a scenario can be
            accessed by calling hou.LopSelectionRule.newPaths.

            The use_last_cook_context_options flag indicates that when cooking
            the lopnode, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            The lop_output_index specifies which output of a multi-output LOP to
            inspect. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.


        """
    def firstPath(self, lopnode: LopNode|None = ..., return_ancestors: bool = ..., fallback_to_new_paths: bool = ..., stage: pxr.Usd.Stage|None = ..., use_last_cook_context_options: bool = ...) -> pxr.Sdf.Path:
        """

        firstPath(self, lopnode=None, return_ancestors=False,
        fallback_to_new_paths=False, stage=None, use_last_cook_context_options =
        True, lop_output_index = -1) -> pxr.Sdf.Path

            Behaves exactly like hou.LopSelectionRule.expandedPaths, but returns
            only a single path, which will be the first match (alphabetically
            sorted) of all matches, or the first new path if no matches are
            found.

            The use_last_cook_context_options flag indicates that when cooking
            the lopnode, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            The lop_output_index specifies which output of a multi-output LOP to
            inspect. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.


        """
    def collectionAwarePaths(self, lopnode: LopNode|None = ..., fallback_to_new_paths: bool = ..., stage: pxr.Usd.Stage|None = ..., use_last_cook_context_options: bool = ...) -> Tuple[pxr.Sdf.Path,...]:
        """

        collectionAwarePaths(self, lopnode=None, fallback_to_new_paths=False,
        stage=None, use_last_cook_context_options = True, lop_output_index = -1)
        -> tuple of pxr.Sdf.Path

            Calculates the scene graph primitive selection using the scene graph
            from the LOP node object provided as the lopnode parameter. If this
            selection rule was created with a call to hou.LopNode.selectionRule
            the lopnode parameter is assumed to be equal to the creator node. As
            an alternative to providing a LOP node, the pattern will evalaute
            over any Usd.Stage passed as the stage parameter. If both a LOP node
            and a Usd.Stage are provided, the stage parameter takes priority.

            Returns the full paths to every scene graph primitive or collection
            matching the selection pattern. Unlike the expandedPaths method,
            collections are not expanded to explicitly list their contents as
            primitives. Instead the full path of the collection itself is
            returned.

            If the primitive pattern contains any exclusions the included
            collections cannot be accurately tracked, so the results of this
            method will be the same as for expandedPaths.

            The fallback_to_new_paths parameter can be set to True to allow the
            selection rule to return scene graph paths if the pattern consists
            entirely of explicit paths which do not correspond to any existing
            primitives on the stage. Such paths may be used to express desired
            scene graph locations for new primitives. If the pattern contains a
            mix of existing paths and new paths, this method will always return
            only the existing paths. The new paths in such a scenario can be
            accessed by calling hou.LopSelectionRule.newPaths.

            The use_last_cook_context_options flag indicates that when cooking
            the lopnode, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            The lop_output_index specifies which output of a multi-output LOP to
            inspect. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.


        """
    def newPaths(self, lopnode: LopNode|None = ..., stage: pxr.Usd.Stage|None = ..., use_last_cook_context_options: bool = ...) -> Tuple[pxr.Sdf.Path,...]:
        """

        newPaths(self, lopnode=None, stage=None, use_last_cook_context_options =
        True, lop_output_index = -1) -> tuple of pxr.Sdf.Path

            Calculates the scene graph primitive selection using the scene graph
            from the LOP node object provided as the lopnode parameter. If this
            selection rule was created with a call to hou.LopNode.selectionRule
            the lopnode parameter is assumed to be equal to the creator node. As
            an alternative to providing a LOP node, the pattern will evalaute
            over any Usd.Stage passed as the stage parameter. If both a LOP node
            and a Usd.Stage are provided, the stage parameter takes priority.

            Nothing will be returned by this method unless the pattern consists
            entirely of explicit paths. Paths which represent existing
            primitives on the USD stage are not returned by this method.

            The use_last_cook_context_options flag indicates that when cooking
            the lopnode, the context option values used on the previous cook
            should be used if any context options used by this node do not exist
            in the global context option set. If the
            HOUDINI_NEW_CONTEXT_OPTION_RULES environment variable is set, the
            last cook context options will take priority over any global
            options, unless the node being cooked has its display flag set in
            which case last cook context options are never used.

            The lop_output_index specifies which output of a multi-output LOP to
            inspect. The special value -1 in most cases is simply treated as
            meaning 0 (the first output). However, when use as part of a
            parameter expression in a LOP node, it indicates the output that is
            connected to the input of the node that owns the parameter being
            evaluated. This can greatly simplify the authoring of expressions
            that need to access data from the connected input LOP.


        """
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def lastError(self) -> str:
        """

        lastError(self) -> str

            Any status or error messages generated the last time expandedPaths
            or collectionAwarePaths was called. This will generally contain
            information about invalid pattern strings.


        """
    def lastErrorSeverity(self) -> EnumValue:
        """

        lastErrorSeverity(self) -> hou.severityType

            The error status of the last time expandedPaths or
            collectionAwarePaths was called. If this value is anything other
            than hou.severityType.None, the lastError method will return a
            string with more information.


        """
    def lastMayBeTimeVarying(self) -> bool:
        """

        lastMayBeTimeVarying(self) -> bool

            A boolean indicating if the most recent calculation of the members
            of this selection rule might produce a time varying result. This may
            occur if the selection rule depends on a time varying attribute such
            as the transform or bounding box of some primitives.


        """
    def pathPattern(self) -> str:
        """

        pathPattern(self) -> str

            Return the path pattern string used in this selection rule.


        """
    def setPathPattern(self, pattern: str) -> None:
        """

        setPathPattern(self, pattern)

            Sets the path pattern string used in this selection rule.

            See for the pattern syntax.


        """
    def traversalDemands(self) -> int:
        """

        traversalDemands(self) -> int

            Return an integer value that expresses any demands made on the USD
            primitives while traversing the scene graph looking for matches.


        """
    def setTraversalDemands(self, demands: int) -> None:
        """

        setTraversalDemands(self, options)

            Set demands that must be met by primitives while traversing the
            scene graph. These demands are expressed as an integer value. This
            value can be any combination of the hou.lopTraversalDemands values.

            Multiple demands can be combined with the | operator. The following
            builds a rule that will only return USD primitives that are active
            and defined:

          > >>> rule = hou.LopSelectionRule()
          > >>> rule.SetTraversalDemands(hou.lopTraversalDemands.Active | hou.lopTraversalDemands.Defined)

        """
    def icon(self) -> str:
        """

        icon(self) -> str

            Return the icon that should be associated with this selection rule
            when displaying it in the Scene Graph Tree collection panel.


        """
    def setIcon(self, icon: str) -> None:
        """

        setIcon(self, icon)

            Set the path to the icon file that should be associated with this
            selection rule in the Scene Graph Tree collection panel. This string
            can be a path to an image or SVG file on disk, or the name of any
            standard Houdini icon.


        """
    def sourceNode(self) -> LopNode | None:
        """

        sourceNode(self) -> hou.LopNode or None

            Return the LOP node that was used to create this rule, if it was
            created by calling hou.LopNode.selectionRule. Otherwise return None.


        """
    def sourceNodeInputIndex(self) -> int:
        """

        sourceNodeInputIndex(self) -> int

            Return the input index parameter used to create this rule, if it was
            created by calling hou.LopNode.selectionRule. Otherwise return -1.


        """
    __swig_destroy__: Incomplete

class LopViewportLoadMasks:
    """

    hou.LopViewportLoadMasks

    Stores a description of which payloads on the USD stage should be loaded
    into the viewport.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Create a LopViewportLoadMasks object with default settings. This
            object describes various options for controlling which primitives
            and layers are composed together on the stage that is visible in the
            viewport. This object allows for the control of the stage population
            mask, the loading of payload primitives, and the muting of layers
            from disk. The default settings populate and load all primitives and
            layers.


        """
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def setPopulateAll(self, populate_all: bool = True) -> None:
        """

        setPopulateAll(self, populate_all = True)

            Configures the stage mask to include the entire scene graph. This
            clears the current list of paths to populate because it is not
            needed. If populate_all is set to False, and populateAll is
            currently set to True, this method is equivalent to calling
            setPopulatePaths with an empty path list. If populateAll is already
            False, calling this method with a populate_all value of False will
            do nothing. Calling any method which manipulates the list of paths
            to populate will automatically set this flag back to False.


        """
    def populateAll(self) -> bool:
        """

        populateAll(self) -> bool

            Returns True if the stage mask is configured to include the entire
            scene graph. If True, the explicit list of paths has no meaning.


        """
    def populatePaths(self) -> Tuple[str, ...]:
        """

        populatePaths(self) -> tuple of str

            Return the list of all paths which should be populated on the stage.
            Descendants of explicitly named primitives will also populate on the
            stage.


        """
    def isPathPopulated(self, path: str, exact_match: bool = True) -> bool:
        """

        isPathPopulated(self, path, exact_match = True) -> bool

            Return True if the specified scene graph path is explicitly named in
            the list of paths to populate. If exact_match is False, this method
            also returns true if any ancestor of the supplied path is in the set
            of paths to populate.


        """
    def setPopulatePaths(self, paths: Sequence[str]) -> None:
        """

        setPopulatePaths(self, paths)

            Set the list of paths which should be populated on the stage.


        """
    def addPopulatePath(self, path: str) -> None:
        """

        addPopulatePath(self, path)

            Adds a single path to the list of paths to populate. If the path is
            already in the list of paths, this method does nothing.


        """
    def removePopulatePath(self, path: str, remove_children: bool = False) -> None:
        """

        removePopulatePath(self, path)

            Removes a single path from the list of paths to populate . If the
            path is not in the list of paths, this method does nothing.

            If remove_children is set to True, all children of the primitive at
            path are also removed from the set of populated paths.


        """
    def muteLayers(self) -> Tuple[str, ...]:
        """

        muteLayers(self) -> tuple of str

            Return the list of all muted layer identifiers.


        """
    def isLayerMuted(self, identifier: str) -> bool:
        """

        isLayerMuted(self, identifier) -> bool

            Return True if the specified layer identifier should be ignored when
            composing the stage.


        """
    def setMuteLayers(self, identifiers: Sequence[str]) -> None:
        """

        setMuteLayers(self, identifiers)

            Set the list of layer identifiers that should be muted.


        """
    def addMuteLayer(self, identifier: str) -> None:
        """

        addMuteLayer(self, identifier)

            Adds a single layer identifier to the list of muted layer
            identifiers. If the identifier is already being muted, this method
            does nothing.


        """
    def removeMuteLayer(self, identifier: str) -> None:
        """

        removeMuteLayer(self, identifier)

            Removes a single layer identifier from the list of muted layer
            identifiers. If the identifier is not being muted, this method does
            nothing.


        """
    def setLoadAll(self, load_all: bool = True) -> None:
        """

        setLoadAll(self, load_all = True)

            Set the flag indicating that all payloads should be loaded by
            default. If load_all is set to False, and loadAll is currently set
            to True, this method is equivalent to calling setLoadPaths with an
            empty path list. If loadAll is already False, calling this method
            with a load_all value of False will do nothing. Calling any method
            which manipulates the list of paths to be loaded will automatically
            set this flag back to False.


        """
    def loadAll(self) -> bool: ...
    def loadPaths(self) -> Tuple[str, ...]:
        """

        loadPaths(self) -> tuple of str

            Return a list of all scene graph branches which will load their
            payloads in the viewport. Descendants of explicitly named primitives
            will also load their payloads.


        """
    def isPathLoaded(self, path: str, exact_match: bool = True) -> bool:
        """

        isPathLoaded(self, path, exact_match = True) -> bool

            Return True if the specified scene graph path is explicitly named in
            the list of paths to load. If exact_match is False, this method also
            returns true if any ancestor of the supplied path is in the set of
            paths to load.


        """
    def isAnyChildPathLoaded(self, path: str) -> bool:
        """

        isAnyChildPathLoaded(self, path) -> bool

            Return True if the specified scene graph path or any of its children
            appear in the list of paths to load.


        """
    def setLoadPaths(self, paths: Sequence[str]) -> None:
        """

        setLoadPaths(self, paths)

            Set the list of scene graph paths which should load their payloads
            in the viewport.


        """
    def addLoadPath(self, path: str) -> None:
        """

        addLoadPath(self, path)

            Adds a single path to the list of scene graph paths which will load
            their payloads inthe viewport. If the path is already in the list,
            this method does nothing.


        """
    def removeLoadPath(self, path: str, remove_children: bool = False) -> None:
        """

        removeLoadPath(self, path, remove_children = False)

            Removes a single path from the list of scene graph paths which will
            load their payloads in the viewport. If the path is not in the list,
            this method does nothing.

            If remove_children is set to True, all children of the primitive at
            path are also removed from the set of loaded paths.


        """
    def setVariantSelectionFallbacks(self, fallbacks: dict[str, typing.Iterable[str]]) -> None: ...
    def variantSelectionFallbacks(self) -> dict[str, Tuple[str, ...]]: ...
    def dumps(self) -> str: ...
    def loads(self, masks_str: str) -> bool: ...
    __swig_destroy__: Incomplete

class LopViewportOverrides:
    """

    hou.LopViewportOverrides

    Used to edit the current session overlay layer that is applied to the
    current LOP node's scene graph.

    This object can exist in one of two modes. One mode does not allow
    editing of the overrides other than to save and load the entire object.
    An object is created in this mode either using the default constructor,
    or by calling hou.LopNetwork.copyViewportOverrides which makes a read-
    only copy of either the current viewport overrides, or a saved set of
    overrides.

    In its other mode, this object is a context manager. You can create one
    using hou.LopNetwork.viewportOverrides. At the end of the with block,
    the notification of the session edits is propagated to viewer panes.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Creates an empty, read-only set of viewport overrides. This
            constructor is necessary to allow loading the contents of a binary
            string previsouly with the dumps method.


        """
    def __enter__(self) -> LopViewportOverrides: ...
    def setDrawMode(self, prims: LopSelectionRule, drawmode: str) -> None:
        """

        setDrawMode(self, prims, drawmode)

            Change the draw mode of USD primitives by editing the session layer
            of a LOP Network. The draw mode of a primitive is only respected if
            the primitive is part of a valid, contiguous USD model hierarchy.
            The LOP Network to edit is determined by looking at the LOP node
            used to create this session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            drawmode
                A string value indicating the new draw mode for the USD
                primitives. Only primitives that are part of a valid USD model
                hierarchy can have their draw mode changed. The allowed values
                for this string are default (draw the full geometry), origin
                (draw a set of axes at the origin of the primitive), bounds
                (draw a bounding box around the primitive), and cards (draw
                three axis-aligned cards that fill the primitive's bounding
                box).


        """
    def setActive(self, prims: LopSelectionRule, active: bool) -> None:
        """

        setActive(self, prims, active)

            Change the active state of USD primitives by editing the session
            layer of a LOP Network. Deactivated primitives do not appear in the
            viewport, and cannot be expanded in the scene graph tree. The LOP
            Network to edit is determined by looking at the LOP node used to
            create this session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            active
                A boolean value indicating the new activation state of the USD
                primitives.


        """
    def setVisible(self, prims: LopSelectionRule, visible: bool) -> None:
        """

        setVisible(self, prims, visible)

            Change the visibility of USD primitives by editing the session layer
            of a LOP Network. Invisible primitives are not drawn in the
            viewport, but still appear in the scene graph tree. The LOP Network
            to edit is determined by looking at the LOP node used to create this
            session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            visible
                A boolean value indicating whether the USD primitives should be
                visible.


        """
    def setSelectable(self, prims: LopSelectionRule, active: bool, solo: bool = False) -> None:
        """

        setSelectable(self, prims, selectable, solo = False)

            Change the selectability of USD primitives by editing the session
            layer of a LOP Network. Unselectable primitives are ignored when
            performing a selection operation in the viewport. The LOP Network to
            edit is determined by looking at the LOP node used to create this
            session editor object. All descendants of an unselectable primitive
            are also unselectable, even if they are explicitly set as
            selectable. An unselectable setting on and ancestor primitive takes
            precedence.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            selectable
                A boolean value indicating the new selectable value of the USD
                primitives.

            solo
                A boolean value indicating that the supplied set of primitives
                should be the only primitives in the scene that are selectable
                (or not selectable). This may involve modifying the selectable
                attribute on many primitives across the scene, not just the
                specified primitives.


        """
    def setSoloLights(self, prims: Optional[LopSelectionRule] = None) -> None:
        """

        setSoloLights(self, prims)

            Deactivates any lights not specified by the prims parameter.


            prims
                A hou.LopSelectionRule object that specifies which USD light
                primitives should be remain active after running this method. Or
                can be None to disable any existing soloing of lights.


        """
    def addSoloLights(self, prims: LopSelectionRule) -> None:
        """

        addSoloLights(self, prims)

            Adds lights to the set of activated lights in the scene.


            prims
                A hou.LopSelectionRule object that specifies which USD light
                primitives should be added to the set of solo active lights.


        """
    def removeSoloLights(self, prims: LopSelectionRule) -> None:
        """

        removeSoloLights(self, prims)

            Remove lights from the set of activated lights in the scene. If all
            lights are removed from the solo lights group, all lights in the
            scene will be activated.


            prims
                A hou.LopSelectionRule object that specifies which USD light
                primitives should be removed from the set of solo active lights.


        """
    def setSoloGeometry(self, prims: Optional[LopSelectionRule] = None) -> None:
        """

        setSoloGeometry(self, prims)

            Turns off the visibility of any geometry not specified by the prims
            parameter.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives should be remain visible after running this method.
                Any descendants of the specified primitives will also be made
                visible. This parameter can also be None to disable any existing
                soloing of geometry.


        """
    def addSoloGeometry(self, prims: LopSelectionRule) -> None:
        """

        addSoloGeometry(self, prims)

            Adds geometry primitives to the set of activated geometry in the
            scene.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives should be added to the set of solo visible geometry.


        """
    def removeSoloGeometry(self, prims: LopSelectionRule) -> None:
        """

        removeSoloGeometry(self, prims)

            Remove geometry from the set of visible geometry in the scene. If
            all geometry are removed from the solo geometry group, all geometry
            in the scene will be made visible.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives should be removed from the set of solo visible
                geometry.


        """
    def showPurpose(self, prims: LopSelectionRule, purpose: str) -> None:
        """

        showPurpose(self, prims, purpose)

            Show the selected purpose for a geometry primitive if it exists.
            Other purposes for the same geometry are hidden from the viewport.


            prims
                A hou.LopSelectionRule object that specifies which USD geometry
                primitives' purpose should be isolated and displayed.

            purpose
                A string value indicating the purpose(render/proxy/guide) to
                display.


        """
    def setDisplayOpacity(self, prims: LopSelectionRule, opacity: float) -> None:
        """

        setDisplayOpacity(self, prims, opacity)

            Change the display opacity of USD primitives by editing the session
            layer of a LOP Network. The LOP Network to edit is determined by
            looking at the LOP node used to create this session editor object.


            prims
                A hou.LopSelectionRule object that specifies which USD
                primitives should be affected.

            opacity
                A float value between 0 (fully transparent) and 1 (fully
                opaque).


        """
    def clear(self, layer_id: Optional[EnumValue] = None, from_prim: Optional[str] = None) -> None:
        """

        clear(self, layer_id = None, from_prim = None)

            Clears one or all viewport overrides layers.


            layer_id
                A hou.lopViewportOverridesLayer value to clear a specific
                overrides layer, or None to clear all layers.

            from_prim
                A path to the primitive that is the root of the portion of the
                scene graph tree from which the overrides should be cleared. Set
                to None to clear overrides for the whole scene graph.


        """
    def dumps(self) -> bytes:
        """

        dumps(self) -> hou.BinaryString

            Generates a binary string that contains a serialized copy of this
            object. The format of this serialization is opaque and should not be
            directly inspected or modified. The output should only be used to
            persist this object for later reuse in another process.


        """
    def loads(self, overrides_str: bytes) -> None:
        """

        loads(self, overrides_str)

            Loads the contents of a binary string into this object. The provided
            data must have been generated by calling the dumps method. This
            method can only be called either on a read-only object created by
            calling the default constructor method, or on an object returned by
            hou.LopNetwork.viewportOverrides.


        """
    def layer(self) -> pxr.Sdf.Layer:
        """

        layer(self) -> pxr.Sdf.Layer

            Return the pxr.Sdf.Layer object that contains current custom session
            edits to the scene graph. These edits are accessible using the
            hou.lopViewportOverridesLayer.Custom layer id. This layer does not
            include opinions set using built in Houdini panels. This layer only
            hold opinions authored through the layer returned by this method.
            This object can be modified using the pxr.Sdf.Layer API to make
            further session modifications to the scene graph.


        """
    def stage(self) -> pxr.Usd.Stage:
        """

        stage(self) -> pxr.Sdf.Stage

            Return the pxr.Usd.Stage object that contains all the current
            session edits to the scene graph. This object can be modified using
            the pxr.Usd.Stage API to make further session modifications to the
            scene graph.


        """
    def soloLights(self) -> pxr.Sdf.Path:
        """

        soloLights(self) -> tuple of pxr.Sdf.Path

            Return a set containing the paths to all solo active light
            primitives.


        """
    def soloGeometry(self) -> pxr.Sdf.Path:
        """

        soloGeometry(self) -> tuple of pxr.Sdf.Path

            Return a set containing the paths to all solo visible geometry
            primitives.


        """
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...
    __swig_destroy__: Incomplete

class Matrix2:
    """

    hou.Matrix2

    A 2x2 matrix of floating point values.


    """
    thisown: Incomplete
    def __init__(self, values: int|float|Sequence[int]|Sequence[float]|Sequence[Sequence[int]|Sequence[float]]|'Matrix2' = ...) -> None:
        """

        __init__(self, values)

            Return a new Matrix2. You can pass no parameters (the result will
            contain all zeros), a float (the result's diagonal values will
            contain that float and the rest is all zeros), a sequence of 4
            floats, or a sequence of sequences of 2 floats.

          > >>> hou.Matrix2()
          > <hou.Matrix2 [[0, 0], [0, 0]]]>
          > 
          > >>> hou.Matrix2(1)
          > <hou.Matrix2 [[1, 0], [0, 1]]>
          > 
          > >>> hou.Matrix2((0, 1, 2, 3))
          > <hou.Matrix2 [[0, 1], [2, 3]]>
          > 
          > >>> hou.Matrix2(((0, 1), (3, 4)))
          > <hou.Matrix2 [[0, 1], [2, 3]]>

            Note that Houdini's matrices are stored in row-major order, so the
            matrix's contents are grouped by row.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, matrix2: Matrix2, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, matrix2, tolerance=0.00001) -> bool

            Returns whether this matrix is equal to another, within a tolerance.


        """
    def __hash__(self) -> int: ...
    def at(self, row: int, col: int) -> float:
        """

        at(self, row, col) -> double

            Return the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 1,
            inclusive. Note that negative indices will not index from the end.


        """
    def asTuple(self) -> Tuple[float, ...]:
        """

        asTuple(self) -> tuple of float

            Return the contents of the matrix as a tuple of 4 floats.


        """
    def asTupleOfTuples(self) -> Tuple[Tuple[float, ...], ...]:
        """

        asTupleOfTuples(self) -> tuple of tuple of float

            Return the contents of the matrix as a tuple of tuples of 2 floats.


        """
    def setAt(self, row: int, col: int, value: float) -> None:
        """

        setAt(self, row, col, value)

            Set the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 1,
            inclusive. Note that negative indices will not index from the end.


        """
    def setTo(self, value: Sequence[float]) -> None:
        """

        setTo(self, tuple)

            Set this matrix's contents. The sequence may contain either 4 floats
            or 2 sequences, each with 2 floats.

            See hou.Matrix2.__init__ for examples of suitable parameter values.


        """
    def setToIdentity(self) -> None:
        """

        setToIdentity(self)

            Set this matrix to the multiplicative identity, having 1's in the
            diagonal.

            The matrix will contain the values [[1, 0], [0, 1]]. Note that you
            can construct a new matrix with these values using hou.Matrix2(1).


        """
    def setToZero(self) -> None:
        """

        setToZero(self)

            Set this matrix to contain all zeros.

            Note that you can construct a new matrix with all zeros with
            hou.Matrix2().


        """
    def __add__(self, matrix2: Matrix2) -> Matrix2:
        """

        __add__(self, matrix2) -> hou.Matrix2

            Add two matrices by adding corresponding entries together and return
            a new matrix. This method lets you write m1 + m2, where m1 and m2
            are Matrix2 objects.


        """
    def __sub__(self, matrix2: Matrix2) -> Matrix2:
        """

        __sub__(self, matrix2) -> hou.Matrix2

            Subtract another matrix from this one, subtracting corresponding
            entries, and return a new matrix. This method lets you write m1 -
            m2, where m1 and m2 are Matrix2 objects.


        """
    def __mul__(self, matrix2_or_scalar: Matrix2|float) -> Matrix2:
        """

        __mul__(self, matrix2_or_scalar) -> hou.Matrix2

            Multiply this matrix by another matrix or by a scalar, returning a
            new matrix. This method lets you write m1 * m2, where m1 and m2 are
            Matrix2 objects, or m1 * s, where s is a float.

            See Wikipedia's matrix multiplication page for details on how each
            element in the result is computed.


        """
    def preMult(self, matrix2: Matrix2) -> Matrix2:
        """

        preMult(self, matrix2) -> hou.Matrix2

            Returns matrix2 * self. Note that __mul__ returns self * matrix2,
            which is a different result because matrix multiplication is not
            commutative.


        """
    def transposed(self) -> Matrix2:
        """

        transposed(self) -> hou.Matrix2

            Return the transpose of this matrix. The result is such that
            self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 1.

            See Wikipedia's transpose page for more information.


        """
    def inverted(self) -> Matrix2:
        """

        inverted(self) -> hou.Matrix2

            Return the inverse of this matrix.

            Raises hou.OperationFailed if the matrix is not invertible.
            Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix2(1)) is
            True.

            See Wikipedia's invertible matrix page for more information.


        """
    def determinant(self) -> float:
        """

        determinant(self) -> double

            Return the determinant of the matrix.

            See Wikipedia's determinant page.


        """

class Matrix3:
    """

    hou.Matrix3

    A 3x3 matrix of floating point values.

    3x3 matrices are typically used in Houdini to represent a 3D rotation
    (with a possible scale). Most places in Houdini use hou.Matrix4, which
    can store generation 3D transformations (including translations).

    Note that you can construct a general transformation Matrix4 from a
    Matrix3 by writing hou.Matrix4(matrix3).


    """
    thisown: Incomplete
    def __init__(self, values: int|float|Sequence[int]|Sequence[float]|Sequence[Sequence[int]|Sequence[float]]|'Matrix3' = ...) -> None:
        """

        __init__(self, values)

            Return a new Matrix3. You can pass no parameters (the result will
            contain all zeros), a float (the result's diagonal values will
            contain that float and the rest is all zeros), a sequence of 9
            floats, a sequence of sequences of 3 floats, or a hou.Matrix4.

          > >>> hou.Matrix3()
          > <hou.Matrix3 [[0, 0, 0], [0, 0, 0], [0, 0, 0]]>
          > 
          > >>> hou.Matrix3(1)
          > <hou.Matrix3 [[1, 0, 0], [0, 1, 0], [0, 0, 1]]>
          > 
          > >>> hou.Matrix3((0, 1, 2, 3, 4, 5, 6, 7, 8))
          > <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>
          > 
          > >>> hou.Matrix3(((0, 1, 2), (3, 4, 5), (6, 7, 8)))
          > <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>
          > 
          > >>> matrix4 = hou.Matrix4((0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))
          > >>> matrix4
          > <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>
          > >>> hou.Matrix3(matrix4)
          > <hou.Matrix3 [[0, 1, 2], [4, 5, 6], [8, 9, 10]]>

            Note that Houdini's matrices are stored in row-major order, so the
            matrix's contents are grouped by row.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, matrix3: Matrix3, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, matrix3, tolerance=0.00001) -> bool

            Returns whether this matrix is equal to another, within a tolerance.


        """
    def __hash__(self) -> int: ...
    def at(self, row: int, col: int) -> float:
        """

        at(self, row, col) -> double

            Return the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 2,
            inclusive. Note that negative indices will not index from the end.


        """
    def asTuple(self) -> Tuple[float, ...]:
        """

        asTuple(self) -> tuple of float

            Return the contents of the matrix as a tuple of 9 floats.


        """
    def asTupleOfTuples(self) -> Tuple[Tuple[float, ...], ...]:
        """

        asTupleOfTuples(self) -> tuple of tuple of float

            Return the contents of the matrix as a tuple of tuples of 3 floats.


        """
    def setAt(self, row: int, col: int, value: float) -> None:
        """

        setAt(self, row, col, value)

            Set the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 2,
            inclusive. Note that negative indices will not index from the end.


        """
    def setTo(self, value: Sequence[float]) -> None:
        """

        setTo(self, tuple)

            Set this matrix's contents. The sequence may contain either 9 floats
            or 3 sequences, each with 3 floats.

            See hou.Matrix3.__init__ for examples of suitable parameter values.


        """
    def setToIdentity(self) -> None:
        """

        setToIdentity(self)

            Set this matrix to the multiplicative identity, having 1's in the
            diagonal.

            The matrix will contain the values [[1, 0, 0], [0, 1, 0], [0, 0,
            1]]. Note that you can construct a new matrix with these values
            using hou.Matrix3(1).


        """
    def setToZero(self) -> None:
        """

        setToZero(self)

            Set this matrix to contain all zeros.

            Note that you can construct a new matrix with all zeros with
            hou.Matrix3().


        """
    def __add__(self, matrix3: Matrix3) -> Matrix3:
        """

        __add__(self, matrix3) -> hou.Matrix3

            Add two matrices by adding corresponding entries together and return
            a new matrix. This method lets you write m1 + m2, where m1 and m2
            are Matrix3 objects.


        """
    def __sub__(self, matrix3: Matrix3) -> Matrix3:
        """

        __sub__(self, matrix3) -> hou.Matrix3

            Subtract another matrix from this one, subtracting corresponding
            entries, and return a new matrix. This method lets you write m1 -
            m2, where m1 and m2 are Matrix3 objects.


        """
    def __mul__(self, matrix3_or_scalar: Matrix3|float) -> Matrix4:
        """

        __mul__(self, matrix3_or_scalar) -> hou.Matrix3

            Multiply this matrix by another matrix or by a scalar, returning a
            new matrix. This method lets you write m1 * m2, where m1 and m2 are
            Matrix3 objects, or m1 * s, where s is a float.

            See Wikipedia's matrix multiplication page for details on how each
            element in the result is computed. Also see hou.Matrix4.


        """
    def preMult(self, matrix3: Matrix3) -> Matrix3:
        """

        preMult(self, matrix3) -> hou.Matrix3

            Returns matrix3 * self. Note that __mul__ returns self * matrix3,
            which is a different result because matrix multiplication is not
            commutative.


        """
    def transposed(self) -> Matrix3:
        """

        transposed(self) -> hou.Matrix3

            Return the transpose of this matrix. The result is such that
            self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 2.

            See Wikipedia's transpose page for more information.


        """
    def inverted(self) -> Matrix3:
        """

        inverted(self) -> hou.Matrix3

            Return the inverse of this matrix.

            Raises hou.OperationFailed if the matrix is not invertible.
            Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix3(1)) is
            True.

            See Wikipedia's invertible matrix page for more information.


        """
    def determinant(self) -> float:
        """

        determinant(self) -> double

            Return the determinant of the matrix.

            See Wikipedia's determinant page.


        """
    def extractRotates(self, rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ...) -> Vector3:
        '''

        extractRotates(self, rotate_order=\\"xyz\\") -> hou.Vector3

            Return a Vector3 of Euler angles, in degrees, representing the
            rotation component of this matrix. Rotating about the coordinate
            axes in the specified order by these amounts will yield the rotation
            contained in this matrix.


            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.

            Raises hou.OperationFailed if the matrix does not represent a valid
            rotation matrix (e.g. it is singular) or the rotate order is not a
            permutation of the string \'xyz\'.

            See also hou.Matrix4.explode and hou.Matrix4.extractRotates.


            WARNING
                If there are scales or shears in the matrix, the results are as
                if they were first removed on the left side. (ie. SR -> R). If
                you wish to control for this, first use
                hou.Matrix3.removeScalesAndShears with the desired transform
                order.


        '''
    def removeScalesAndShears(self, transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ...) -> Tuple[Vector3, Vector3]:
        '''

        removeScalesAndShears(self, transform_order=\\"srt\\") -> tuple of
        (hou.Vector3, hou.Vector3)

            Remove scales and shears from this matrix and return them as a tuple
            of (scales, shears).


            transform_order
                A 3 character string containing a permutation of the letters s,
                r, and t. If s occurs before r, then the scales/shears are
                extracted from the left of this matrix. Otherwise, they will be
                extracted from the right instead.

            Raises hou.OperationFailed if transform_order is invalid.

            See also: hou.Matrix3.extractRotates, hou.Matrix4.extractRotates,
            hou.Matrix4.extractRotationMatrix3


        '''

class Matrix4:
    """

    hou.Matrix4

    A 4x4 matrix of floating point values.

    4x4 matrices are typically used in Houdini to represent a 3D
    transformation (e.g. some combination of rotation, scaling, shearing,
    and translation). A single matrix compactly represents a transformation,
    and is much easier to deal with than multiple translate, rotate, scale,
    shear, transformation order, and rotation order values.

    Note that Houdini's matrices are stored in row-major format, and vectors
    that are multiplied with matrices are treated as row vectors. So, if p
    is a hou.Vector4 representing a point and M is a Matrix4, you write p*M,
    not M*p. Similarly, p*M1*M2 will first transform p by M1, and then
    transform it by M2.


    NOTE
        Most mathematical notations treat vectors and points as column
        vectors instead of row vectors. They will often use A*B*C (or simply
        ABC) to refer to a combined transform that first applies C's
        transform, then B's, and then applies A's. However, the convention
        is different in Houdini. To represent the equivalent matrix
        expression in Houdini, you need to concatenate the transforms in the
        reverse order. So, you would instead write C'*B'*A', where C', B',
        A' are the transpose of C, B, A respectively.

    You can multiply Vector3s or Vector4s by Matrix4s. If you multiply a
    Vector3, it is the same as multiplying a Vector4 where the fourth
    component is 1 (see hou.Vector3.__mul__).

    To transform a normal (as opposed to a point or vector), you need to
    multiply by the inverse transpose of the matrix. For example, suppose:


    p
        is a hou.Vector3 object representing a position (or a hou.Vector4
        with p[3]==1)

    v
        is a hou.Vector4 object representing a vector (a direction with a
        length but no fixed location in space), with v[3]==0

    n
        is a hou.Vector4 object representing a normal, with v[3]==0

    m
        is a Matrix4 object representing a transform matrix

    Then you would write:

    > p * m # to transform the point
    > v * m # to transform the vector
    > n * m.inverted().transposed() # to transform the normal
    > # (note that m.inverted().transposed() is mathematically equivalent to m.transposed().inverted())

    Here is a concrete example:

    > >>> m = hou.hmath.buildTranslate((1, 1, 2))
    > >>> m
    > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 2, 1]]>
    > >>> p = hou.Vector3(1, 2, 3)
    > >>> p * m
    > <hou.Vector3 [2, 3, 5]>

    Both VEX and the UT_DMatrix4 class in the Houdini Development Kit (HDK)
    also store matrices in row-major format.

    RELATED

      * hou.hmath

      * hou.Matrix3

      * hou.Quaternion

      * hou.Vector3

      * hou.Vector4


    """
    thisown: Incomplete
    def __init__(self, values: int|float|Sequence[int]|Sequence[float]|Sequence[Sequence[int]|Sequence[float]]|'Matrix4' = ...) -> None:
        """

        __init__(self, values)

            Return a new Matrix4. You can pass no parameters (the result will
            contain all zeros), a float (the result's diagonal values will
            contain that float and the rest is all zeros), a sequence of 16
            floats, a sequence of sequences of 4 floats, or a hou.Matrix3.

          > >>> hou.Matrix4()
          > <hou.Matrix4 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]>
          > 
          > >>> hou.Matrix4(1)
          > <hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]>
          > 
          > >>> hou.Matrix4((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
          > <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>
          > 
          > >>> hou.Matrix4(((0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11), (12, 13, 14, 15)))
          > <hou.Matrix4 [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]>
          > 
          > >>> matrix3 = hou.Matrix3((0, 1, 2, 3, 4, 5, 6, 7, 8))
          > >>> matrix3
          > <hou.Matrix3 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]>
          > >>> hou.Matrix4(matrix3)
          > <hou.Matrix4 [[0, 1, 2, 0], [3, 4, 5, 0], [6, 7, 8, 0], [0, 0, 0, 1]]>

            Note that Houdini's matrices are stored in row-major order, so the
            matrix's contents are grouped by row.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, matrix4: Matrix4, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, matrix4, tolerance=0.00001) -> bool

            Return whether this matrix is equal to another, within a tolerance.


        """
    def __hash__(self) -> int: ...
    def at(self, row: int, col: int) -> float:
        """

        at(self, row, col) -> float

            Return the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 3,
            inclusive. Note that negative indices will not index from the end.


        """
    def asTuple(self) -> Tuple[float, ...]:
        """

        asTuple(self) -> tuple of float

            Return the contents of the matrix as a tuple of 16 floats.


        """
    def asTupleOfTuples(self) -> Tuple[Tuple[float, ...], ...]:
        """

        asTupleOfTuples(self) -> tuple of tuple of float

            Return the contents of the matrix as a tuple of tuples of 4 floats.


        """
    def setAt(self, row: int, col: int, value: float) -> None:
        """

        setAt(self, row, col, value)

            Set the value of the matrix at the given row and column.

            Raises IndexError if the row or column are not between 0 and 3,
            inclusive. Note that negative indices will not index from the end.


        """
    def setTo(self, value: Sequence[float]) -> None:
        """

        setTo(self, sequence)

            Set this matrix's contents. The sequence may contain either 16
            floats or 4 sequences, each with 4 floats.

            See hou.Matrix4.__init__ for examples of suitable parameter values.


        """
    def setToIdentity(self) -> None:
        """

        setToIdentity(self)

            Set this matrix to the multiplicative identity, having 1's in the
            diagonal.

            The matrix will contain the values [[1, 0, 0, 0], [0, 1, 0, 0], [0,
            0, 1, 0], [0, 0, 0, 1]]. Note that you can construct a new matrix
            with these values using hou.hmath.identityTransform or
            hou.Matrix4(1).


        """
    def setToZero(self) -> None:
        """

        setToZero(self)

            Set this matrix to contain all zeros.

            Note that you can construct a new matrix with all zeros with
            hou.Matrix4().


        """
    def __add__(self, matrix4: Matrix4) -> Matrix4:
        """

        __add__(self, matrix4) -> hou.Matrix4

            Add two matrices by adding corresponding entries together and return
            a new matrix. This method lets you write m1 + m2, where m1 and m2
            are Matrix4 objects.


        """
    def __sub__(self, matrix4: Matrix4) -> Matrix4:
        """

        __sub__(self, matrix4) -> hou.Matrix4

            Subtract another matrix from this one, subtracting corresponding
            entries, and return a new matrix. This method lets you write m1 -
            m2, where m1 and m2 are Matrix4 objects.


        """
    def __mul__(self, matrix4_or_scalar: Matrix4|float) -> Matrix4:
        """

        __mul__(self, matrix4_or_scalar) -> hou.Matrix4

            Multiply this matrix by another matrix or by a scalar, returning a
            new matrix. This method lets you write m1 * m2, where m1 and m2 are
            Matrix4 objects, or m1 * s, where s is a float.

            If m1 and m2 are transformation matrices and v is a vector, v * m1 *
            m2 will transform v by m1, and then transform it by m2. This
            ordering occurs because Houdini's Matrices are stored in row-major
            format, and is opposite from the ordering used in traditional
            mathematical notation. Note that m1 * v is not a valid expression in
            Houdini

            See the Matrix4 class documentation and hou.Vector3.__mul__ for more
            information. See Wikipedia's matrix multiplication page for details
            on how each element in the result is computed.


        """
    def preMult(self, matrix4: Matrix4) -> Matrix4:
        """

        preMult(self, matrix4) -> hou.Matrix4

            Returns matrix4 * self. Note that __mul__ returns self * matrix4,
            which is a different result because matrix multiplication is not
            commutative.


        """
    def transposed(self) -> Matrix4:
        """

        transposed(self) -> hou.Matrix4

            Return the transpose of this matrix. The result is such that
            self.at(i, j) == self.transposed().at(j, i) for 0 <= i,j <= 3.

            See Wikipedia's transpose page for more information.


        """
    def inverted(self) -> Matrix4:
        """

        inverted(self) -> hou.Matrix4

            Return the inverse of this matrix.

            Raises hou.OperationFailed if the matrix is not invertible.
            Otherwise, (self *
            self.inverted()).isAlmostEqual(hou.hmath.identityTransform()) is
            True.

            See Wikipedia's invertible matrix page for more information.


        """
    def determinant(self) -> float:
        """

        determinant(self) -> float

            Return the determinant of the matrix.

            See Wikipedia's determinant page.


        """
    def explode(self, transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ..., rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ..., pivot: Vector3 = ..., pivot_rotate: Vector3 = ...) -> dict[str, Vector3]:
        """

        explode(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -> dict of str to
        hou.Vector3

            Return a dictionary with keys 'rotate', 'scale', 'translate', and
            'shear' whose values are hou.Vector3 objects. When applied in the
            specified order, the corresponding rotations, scales (and shears),
            and translations will give this matrix.

            The rotation is returned as a set of Euler angles, in degrees. See
            Wikipedia's Euler angles page for more information.


            transform_order
                A string containing a permutation of the letters s, r, and t.
                The rotate, scale, and translate results are dependent on the
                order in which you perform those operations, and this string
                specifies that order.

                For example, imagine a transformation where you first translate
                in x by one unit, then you rotate in z by 45 degrees. With a
                transform order of 'trs' (translate, rotate, scale), the
                translate component is (1, 0, 0). However, this same
                transformation could be constructed, for example, by first
                scaling, then rotating, and then translating. For this
                transformation order, the translate component would be (1.0 /
                math.sqrt(2), 1.0 / math.sqrt(2), 0).

            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.

            pivot
                A Vector3 containing a position about which rotations and scales
                are performed. By default, this parameter is set to the origin.

            pivot_rotate
                A Vector3 containing the Euler angles about the x, y, and z
                axes, in degrees, that specifies the base rotation about the
                pivot. These angles are always processed in 'xyz' order.

            Raises hou.OperationFailed if the matrix does not represent a valid
            transform matrix (e.g. it is singular), the transform order is not a
            permutation of the string 'srt', or the rotate order is not a
            permutation of the string 'xyz'.

            See hou.hmath.buildRotateAboutAxis for an example of how to convert
            Euler angles into an axis and rotation.

            See hou.ObjNode.setParmTransform for an example. This method is the
            inverse of hou.hmath.buildTransform. See also the other functions in
            hou.hmath that build transformation matrices.


        """
    def extractTranslates(self, transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ..., pivot: Vector3 = ..., pivot_rotate: Vector3 = ...) -> Vector3:
        """

        extractTranslates(self, transform_order='srt',
        pivot_rotate=hou.Vector3(), pivot=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, hou.Vector3(), pivot,
            pivot_rotate)['translate']. See hou.Matrix4.explode for more
            information.

          > >>> matrix = hou.hmath.buildTranslate(1, 0, 0) * hou.hmath.buildRotate(0, 0, 45)
          > >>> matrix.extractTranslates('trs')
          > <hou.Vector3 [4, 0, 0]>
          > >>> matrix.extractTranslates('srt')
          > <hou.Vector3 [0.707107, 0.707107, 0]>

        """
    def extractRotates(self, transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ..., rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ..., pivot: Vector3 = ..., pivot_rotate: Vector3 = ...) -> Vector3:
        """

        extractRotates(self, transform_order='srt', rotate_order='xyz',
        pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, rotate_order, pivot,
            pivot_rotate)['rotate']. See hou.Matrix4.explode for more
            information.


        """
    def extractScales(self, transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ..., pivot: Vector3 = ..., pivot_rotate: Vector3 = ...) -> Vector3:
        """

        extractScales(self, transform_order='srt', pivot=hou.Vector3(),
        pivot_rotate=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, rotate_order, pivot,
            pivot_rotate)['scale']. See hou.Matrix4.explode for more
            information.


        """
    def extractShears(self, transform_order: Literal['srt','str','rst','rts','tsr','trs'] = ..., pivot: Vector3 = ..., pivot_rotate: Vector3 = ...) -> Vector3:
        """

        extractShears(self, transform_order='srt', pivot=hou.Vector3(),
        pivot_rotate=hou.Vector3()) -> hou.Vector3

            A shortcut for self.explode(transform_order, rotate_order, pivot,
            pivot_rotate)['shear']. See hou.Matrix4.explode for more
            information.


        """
    def extractRotationMatrix3(self) -> Matrix3:
        """

        extractRotationMatrix3(self) -> hou.Matrix3

            Extracts the 3x3 rotation matrix from this matrix, assuming it is a
            transformation matrix. If it fails to extract the rotation, for
            example if scaling is zero on one axis, it returns the identity
            matrix instead.


        """
    def setToPerspective(self, zoom: float, image_aspect: float = 1, pixel_aspect: float = 1, clip_near: float = 0, clip_far: float = 1, window_xmin: float = 0, window_xmax: float = 1, window_ymin: float = 0, window_ymax: float = 1) -> None:
        """

        setToOrthographic(self, zoom, orthowidth=1, image_aspect=1,
        pixel_aspect=1, clip_near=0, clip_far=1, window_xmin=0, window_xmax=1,
        window_ymin=0, window_ymax=1)

            Set this matrix to an orthographic projection matrix with the given
            parameters.

            Sometimes the zoom is expressed in terms of focal and aperture. In
            this case: zoom = focal/aperture. Sometimes the image_aspect is
            expressed in terms of xres and yres. In this case: image_aspect =
            xres / yres.


        """
    def setToOrthographic(self, zoom: float, orthowidth: float = 1, image_aspect: float = 1, pixel_aspect: float = 1, clip_near: float = 0, clip_far: float = 1, window_xmin: float = 0, window_xmax: float = 1, window_ymin: float = 0, window_ymax: float = 1) -> None: ...

class MenuParmTemplate(ParmTemplate):
    """

    hou.MenuParmTemplate

    Describes a menu parameter containing evaluating to integer values. Note
    that StringParmTemplates may also have menus.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, menu_items: Sequence[str], menu_labels: Sequence[str] = ..., default_value: int = ..., icon_names: Sequence[str] = ..., item_generator_script: str = ..., item_generator_script_language: EnumValue|None = ..., disable_when: str|None = ..., menu_type: EnumValue = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ..., default_expression: str = ..., default_expression_language: EnumValue = ..., store_default_value_as_string: bool = ..., menu_use_token: bool = ..., is_button_strip: bool = ..., strip_uses_icons: bool = ...) -> None:
        '''

        __init__(self, name, label, menu_items, menu_labels=(), default_value=0,
        icon_names=(), item_generator_script=\'\',
        item_generator_script_language=None, disable_when=None,
        menu_type=hou.menuType.Normal, is_hidden=False, is_label_hidden=False,
        join_with_next=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=\\"\\",
        default_expression_language=hou.scriptLanguage.Hscript,
        store_default_value_as_string=False, menu_use_token=False,
        is_button_strip=False, strip_uses_icons=False)


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            menu_items
                See the menuItems method for more information.

            menu_labels
                See the menuLabels method for more information.

                If this parameter is not given, it defaults to the value of the
                menu_items parameter.

            default_value
                See the defaultValue method for more information.

            icon_names
                See the iconNames method for more information.

                If this parameter is an empty tuple, the menu will not contain
                icons.

            item_generator_script
                See the itemGeneratorScript method for more information.

            item_generator_script_language
                See the itemGeneratorScriptLanguage method for more information.
                If this parameter is None it defaults to
                hou.scriptLanguage.Python.

            menu_type
                See the menuType method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.

            store_default_value_as_string
                If set to True then the template stores the chosen default
                string instead of the default index in dialog scripts and other
                parameter formats internal to Houdini. menu_use_token: See the
                menuUseToken method for more information.

            is_button_strip
                See hou.ParmTemplate.isButtonStrip for more information.

            strip_uses_icons
                See hou.ParmTemplate.isIconStrip for more information.

            Note that MenuParmTemplates have only one component.


        '''
    __swig_destroy__: Incomplete
    def defaultValue(self) -> int:
        """

        defaultValue(self) -> int

            Return the index of the default menu item.

            See also the defaultValueAsString method.


        """
    def defaultValueAsString(self) -> str: ...
    def setDefaultValue(self, default_value: int) -> None:
        """

        setDefaultValue(self, default_value)

            Set the index of the default menu item.

            Note that if this index is out of range of the menu item entries, it
            will be adjusted. If the menu is driven by a script, i.e. the
            itemGeneratorScript is set to a non-empty value, the default value
            is not adjusted.


        """
    def defaultExpression(self) -> str:
        """

        defaultExpression(self) -> string

            Return the expression, which when evaluated, returns the index of
            the default menu item.

            The default expression takes precedence over the default value. If
            the default expression is not set (i.e. an empty string), then the
            default value is used instead.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
    def setDefaultExpression(self, default_expression: str) -> None:
        """

        setDefaultExpression(self, default_expression)

            Set the default expression, which when evaluated, returns the index
            of the default menu item.

            If default_expression is the empty string, then the default
            expression is unset.


        """
    def defaultExpressionLanguage(self) -> EnumValue:
        """

        defaultExpressionLanguage(self) -> hou.scriptLanguage

            Return the default expression language.

            The default expression language only applies if the default
            expression is set. If the default expression is not set, then the
            expression language is set to hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: EnumValue) -> None:
        """

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language.

            See the defaultExpressionLanguage method for more information.


        """
    def menuItems(self) -> Tuple[str, ...]:
        """

        menuItems(self) -> tuple of str

            Return the tuple of internal menu names.

            These internal menu names are not displayed in the UI, but they can
            be passed to hou.Parm.set and will be returned by
            hou.Parm.evalAsString for menu parameters.


        """
    def setMenuItems(self, menu_items: Sequence[str]) -> None:
        """

        setMenuItems(self, menu_items)

            Set the internal menu names to the given sequence of strings.

            See the menuItems method for more information.

            If the new number of menu items is less than the old number, the
            menu labels will be shortened and the default value will be modified
            if it is out of range.


        """
    def menuLabels(self) -> Tuple[str, ...]:
        """

        menuLabels(self) -> tuple of str

            Return the tuple of menu labels displayed in the UI.


        """
    def setMenuLabels(self, menu_labels: Sequence[str]) -> None:
        """

        setMenuLabels(self, menu_labels)

            Set the menu labels displayed in the UI to the given sequence of
            strings.

            If the number of menu labels is less than the number of menu items,
            Houdini uses the internal menu item names for the missing labels. If
            the number of labels is more than the number of menu items, Houdini
            discards the extra labels.

            If you want to change both the menu items and menu labels, be sure
            to change the menu items first.


        """
    def iconNames(self) -> Tuple[str, ...]:
        """

        iconNames(self) -> tuple of str

            Return the tuple of icons corresponding to the menu items. If there
            are no icons, returns a tuple of empty strings.


        """
    def setIconNames(self, icon_names: Sequence[str]) -> None:
        """

        setIconNames(self, icon_names)

            Set the icon names to the given sequence of strings.


        """
    def itemGeneratorScript(self) -> str:
        """

        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

            Return the programming language for the script that generates menu
            items.


        """
    def setItemGeneratorScript(self, item_generator_script: str) -> None:
        """

        setItemGeneratorScript(self, item_generator_script)

            Set the script used to generate menu items.

            See the itemGeneratorScript method for more information.


        """
    def itemGeneratorScriptLanguage(self) -> EnumValue: ...
    def setItemGeneratorScriptLanguage(self, language: EnumValue) -> None:
        """

        setItemGeneratorScriptLanguage(self, language)

            Set the script language used to generate menu items to a
            hou.scriptLanguage enum value.

            See the itemGeneratorScriptLanguage method for more information.


        """
    def menuType(self) -> EnumValue:
        """

        menuType(self) -> hou.menuType enum value

            Return the type of menu. Note that some menu types only apply to
            string parameters with menus, so the meaningful menu types for
            MenuParmTemplates are hou.menuType.Normal (for standard menus) and
            hou.menuType.Mini for menus that only display a dropdown arrow. See
            hou.menuType for more information.


        """
    def setMenuType(self, menu_type: EnumValue) -> None:
        """

        setMenuType(self, menu_type)

            Set the type of menu to a hou.menuType enum value.

            See the menuType method for more information.


        """
    def menuUseToken(self) -> bool:
        """

        menuUseToken(self) -> bool

            Return whether the parameter is set to the token value instead of
            the index.

            See also the setMenuUseToken method.


        """
    def setMenuUseToken(self, menuusetoken: bool) -> None:
        """

        setMenuUseToken(self, on)

            Set whether the parameter is set to the token value instead of the
            index.

            See also the menuUseToken method.


        """
    def isButtonStrip(self) -> bool:
        """

        isButtonStrip(self) -> bool

            Return whether the parameter is set to use the button strip widget.


        """
    def isIconStrip(self) -> bool:
        """

        isIconStrip(self) -> bool

            Return whether the parameter is set to use the icon strip widget.


        """
    def isMenu(self) -> bool:
        """

        isMenu(self) -> bool

            Return whether the parameter is set to use the drop down menu
            widget.


        """
    def setAsButtonStrip(self) -> None:
        """

        setAsButtonStrip(self)

            Set the parameter to use a Button Strip widget.

            See also the setAsMenu, setAsIconStrip methods.


        """
    def setAsIconStrip(self) -> None:
        """

        setAsIconStrip(self)

            Set the parameter to use a Icon Strip widget.

            See also the setAsMenu, setAsButtonStrip methods.


        """
    def setAsMenu(self) -> None:
        """

        setAsMenu(self)

            Turn back the parameter to a default menu drop down.

            See also the setAsButtonStrip, setAsIconStrip methods.


        """

class NanoVDB:
    """

    hou.NanoVDB

    An NanoVDB object contains the voxels that define a sparse 3D vdb
    volume. For example, COP nodes in Houdini can generate multiple NanoVDB
    objects.

    If you ask a COP for its geometry via the hou.CopNode.vdb, you'll cook
    the COP and get a read-only hou.NanoVDB. Unlike with SOPs and Geometry
    objects, the result is no longer tied to the COP Node so it stays the
    same if the COP node recooks or is deleted.

    Call hou.NanoVDB.freeze to edit an NanoVDB. This returns another NanoVDB
    object that's an independent writeable copy. Writing to the frozen layer
    doesn't affect the earlier read-only versions.


    """
    thisown: Incomplete
    def __init__(self, layer: Optional[NanoVDB] = None) -> None:
        """

        hou.NanoVDB

        An NanoVDB object contains the voxels that define a sparse 3D vdb
        volume. For example, COP nodes in Houdini can generate multiple NanoVDB
        objects.

        If you ask a COP for its geometry via the hou.CopNode.vdb, you'll cook
        the COP and get a read-only hou.NanoVDB. Unlike with SOPs and Geometry
        objects, the result is no longer tied to the COP Node so it stays the
        same if the COP node recooks or is deleted.

        Call hou.NanoVDB.freeze to edit an NanoVDB. This returns another NanoVDB
        object that's an independent writeable copy. Writing to the frozen layer
        doesn't affect the earlier read-only versions.


        """
    __swig_destroy__: Incomplete
    def __enter__(self) -> Optional[NanoVDB]: ...
    def __exit__(self, type: Any, value: Any, traceback: Any) -> None: ...
    def close(self) -> None:
        """

        close(self)

            Resets this object to be an empty object. This stops it holding a
            reference to the underlying NanoVDB data. This will also happen when
            the object goes out of scope and is garbage collected, but the
            close() provides exact control over the timing.

            NanoVDBs also support contexts so the with statement can be used to
            auto-close the nanovdb at the with-block end.


        """
    def vdbType(self) -> EnumValue:
        """

        vdbType(self) -> hou.EnumValue

            Returns the vdb's vdb type, which consists of its precision, float
            vs integer, and vector size.


        """
    def typeInfo(self) -> EnumValue:
        """

        typeInfo(self) -> hou.EnumValue

            Returns the semantic type of the vdb. This is used for things like
            automatic visualizations.


        """
    def setTypeInfo(self, storagetype: EnumValue) -> None:
        """

        setTypeInfo(self, storagetype)

            Changes the semantic type of the vdb.

            Requires a writable layer.


        """
    def leafCount(self) -> int:
        """

        leafCount(self) -> int64

            Returns the number of active leaf nodes in the VDB. If the leaf
            nodes are fully active, the active voxels will be 512 times this.


        """
    def onCPU(self) -> bool:
        """

        onCPU(self) -> bool

            A NanoVDB may be stored on the CPU or GPU. This is true if it is
            stored on the CPU.


        """
    def onGPU(self) -> bool:
        """

        onGPU(self) -> bool

            A NanoVDB may be stored on the CPU or GPU. This is true if it is
            stored on the GPU.


        """
    def voxelSize(self) -> Vector3:
        """

        voxelSize(self) -> hou.Vector3

            The world space size of voxels in the VDB.


        """
    def indexToWorldTransform(self) -> Matrix4:
        """

        indexToWorldTransform(self) -> hou.Matrix4

            A transform from the voxel indices into worlds space. Note this does
            not account for tapers.


        """
    def worldToIndexTransform(self) -> Matrix4:
        """

        worldToIndexTransform(self) -> hou.Matrix4

            A transform from the world space into the voxel indices. Note this
            does not account for tapers.


        """
    def freeze(self) -> Optional[NanoVDB]:
        """

        freeze(self) -> hou.NanoVDB

            Create a writable copy of this and return it.


            NOTE
                The actual buffer duplication won't be done until a write is
                performed.


        """
    def isFrozen(self) -> bool:
        """

        isFrozen(self) -> bool

            Returns if this is frozen, and hence writable.


        """
    def attributes(self) -> dict[str, Any]:
        """

        attributes(self) -> std::map<std::string,hboost::any>

            Returns the vdb attributes present on this layer.


        """
    def setAttributes(self, p: dict[str, Any]) -> None:
        """

        setAttributes(self, std::map<std::string, p)

            Replaces the vdb attributes with the provided dictionary.


        """
    def updateAttributes(self, p: dict[str, Any]) -> None:
        """

        updateAttributes(self, std::map<std::string, p)

            Updates the layer attributes with the provided dictionary, replacing
            any matching keys.


        """
    def rawNanoVDB(self) -> bytes:
        """

        rawNanoVDB(self) -> hou.BinaryString

            Return all the voxels as a binary string. This is in the NanoVDB
            memory layout, so can be re-interpreted into third party tools that
            understand NanoVDB.

            Note NanoVDB is not meant as a long term storage format, so it is
            recommended any long term storage is done with VDBs rather than
            relying on this format being the same.


        """
    def setFromRawNanoVDB(self, values: Any) -> None:
        """

        setFromRawNanoVDB(self, values, length)

            Take a binary string in values and replaces this NanoVDB with the
            NanoVDB so encoded.


        """

class NetworkDot(IndirectInput):
    """

    hou.NetworkDot

    A small dot in a network that allows wires to be routed along specific
    paths without affecting the data passing through them.

    Network dots are allowed to have a single input, but may have many
    outputs. They can be moved around to force a wire connecting two nodes
    to follow a specific path. They can also be used as scaffolding for a
    set of nodes that you want to be able to quickly add or remove in a
    larger network.

    New dots are created by calling hou.Node.createNetworkDot on the node
    that will contain the dot. A list of all existing dots in a network can
    be generated by calling hou.Node.networkDots.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isPinned(self) -> bool:
        """

        isPinned(self) -> bool

            Returns the pinned state of this dot. See hou.NetworkDot.setPinned
            for a more detailed discussion of the meaning of a pinned dot.


        """
    def setPinned(self, pinned: bool) -> None:
        """

        setPinned(self, pinned)

            Sets the boolean pinned state of this dot. Pinned dots are not
            functionally different from unpinned dots, but are treated
            differently by the network editor. A pinned dot remains even if its
            input and output connections are removed. An unpinned dot will be
            deleted automatically by the network editor if its input or last
            output is cut.

            The following code is a greatly simplified version of the code for
            automatically deleting unconnected dots, which will delete any dots
            that are not pinned and that don't have an input connection:

          > >>> net = hou.node('/obj')
          > >>> net.createNetworkDot().setPinned(False)
          > >>> net.createNetworkDot().setPinned(True)
          > >>> net.networkDots()
          > (<hou.NetworkDot dot1 in /obj>, <hou.NetworkDot dot2 in /obj>)
          > >>> for dot in net.networkDots():
          > ...   if not dot.isPinned():
          > ...     if dot.inputItem() is None:
          > ...       dot.destroy()
          > ...
          > >>> net.networkDots()
          > (<hou.NetworkDot dot2 in /obj>,)

        """
    def setInput(self, input_index: int, item_to_become_input: NetworkMovableItem|None, output_index: int = ...) -> None:
        """

        setInput(self, item_to_become_input, output_index=0)

            Connects a network item to the input of this dot. This effectively
            rewires any nodes that are connected to the output of this dot.

            Raises hou.InvalidInput if output_index is invalid. Raises
            hou.OperationFailed if item_to_become_input is not in the same
            network as this dot. Raises hou.PermissionError if the dot is inside
            a locked asset.


        """
    def inputConnections(self) -> Tuple[NodeConnection, ...]:
        """

        inputConnections(self) -> tuple of hou.NodeConnection

            Returns a tuple of hou.NodeConnection objects for the connection
            coming into this dot. The tuple will have a length of one if
            anything is connected to the input of this dot. Returns an empty
            tuple if nothing is connected.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Delete this dot. Connections in and out of the dot are automatically
            re-established such that the behavior of the network will be
            unchanged by the removal of this dot.


        """

class OpNetworkDot(OpIndirectInput, NetworkDot):
    """

    hou.OpNetworkDot

    A small dot in an OP network that allows wires to be routed along
    specific paths without affecting the data passing through them.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class NetworkEditor(PathBasedPaneTab):
    """

    hou.NetworkEditor

    Represents a Network Editor panetab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isShowingConnectors(self) -> bool:
        """

        isShowingConnectors(self) -> bool

            Return True if the network editor zoom level is high enough that
            input and output connectors are visible. This can be useful in
            network editor event handlers that expect the user to click on a
            connector. If the connectors are not visible, some alternative
            interaction is required.


        """
    def isUnderCursor(self) -> bool: ...
    def isPosInside(self, pos: Vector2, ignore_floating_windows: bool = True) -> bool:
        """

        isPosInside(self, pos, ignore_floating_windows=True) -> bool

            Return True if the hou.Vector2 passed as the pos parameter is inside
            the network view. The values in pos are mouse coordinates expressed
            relative to the network editor pane.


            ignore_floating_windows
                When set to True, isPosInside will ignore any windows floating
                over the network view at the given position and will return True
                as long as the position is inside the network view area. When
                set to False, isPosInside will additionally check for floating
                windows and will return True if the position is inside the
                network view and if no other window is on top of the network
                view at the given position.


        """
    def setCursorPosition(self, pos: Vector2) -> None:
        """

        setCursorPosition(self, pos)

            Moves the mouse cursor to the position specified by the hou.Vector2
            pos parameter.


        """
    def cursorPosition(self, confine_to_view: bool = True) -> Vector2:
        '''

        cursorPosition(self, confine_to_view=True) -> hou.Vector2

            Return the current mouse cursor position expressed in network view
            coordinates. If confine_to_view is True, the returned value will be
            clipped to the area of the network currently visible in the network
            editor.

            Here is an example of moving a node underneath the mouse cursor:

          > # Get the network editor.
          > net_editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > 
          > # Get the node.
          > node = hou.node(\\"/obj/myNode\\")
          > 
          > # Set the node\'s new position.
          > node.setPosition(net_editor.cursorPosition())

        '''
    def screenBounds(self) -> BoundingRect:
        """

        screenBounds(self) -> hou.BoundingRect

            Return the screen space bounds of the network editor viewing area.
            This does not include the menu bar, toolbar, or other UI elements.
            Only the area where the network contents are displayed is returned.
            The bounds are relative to the network area itself, so the lower
            left corner of the returned bounding box will always be (0, 0).


        """
    def visibleBounds(self) -> BoundingRect:
        """

        visibleBounds(self) -> hou.BoundingRect

            Return the network space bounds of the network editor viewing area.


        """
    def setVisibleBounds(self, bounds: BoundingRect, transition_time: float = 0.0, max_scale: float = 0.0, set_center_when_scale_rejected: bool = False) -> None:
        """

        setVisibleBounds(self, bounds, transition_time=0.0, max_scale=0.0,
        set_center_when_scale_rejected=False)

            Sets the visible bounds of the network editor viewing area,
            expressed in network space coordinates. This method will never alter
            the screen space size or location of the network editor. If the area
            specified by the bounds parameter has a different aspect ratio from
            the actual network editor, this method will automatically adjust the
            bounds to ensure that the area specified is fully visible.


            bounds
                A hou.BoundingRect specifying the area that should be visible in
                the network editor.

            transition_time
                The amount of time, in seconds, over which the network editor
                will animate the transition from the current visible bounds to
                the new visible bounds.

            max_scale
                If set to a non-zero value, this parameter controls the maximum
                zoom level that will be allowed. The default maximum scale used
                by the network editor code is 100.

            set_centered_when_scale_rejected
                If set to True, but the new zoom level is determined to be the
                same as the previous zoom, no change is made to the bounds at
                all. This prevents a bounds change, that was intended as a pure
                zoom, from inadvertently panning the view if the zoom doesn't
                actually change.


        """
    def requestZoomReset(self) -> None:
        """

        requestZoomReset()

            Request zoom reset so that all the items in the network will be
            visible. Actual calculation happens in the next drawing.


        """
    def isZoomResetRequested(self) -> bool:
        """

        isZoomResetRequested()

            Return True if there has been a request to reset zoom. This means
            the visible bounds are not vaild until the next drawing. After the
            reset this function will return False.


        """
    def setLocatingEnabled(self, enabled: bool) -> None:
        """

        setLocatingEnabled(self, enabled)

            Enables or disables highlighting of UI elements under the mouse in
            the network editor. When disabled, mouse events sent to the network
            editor event processing code will never specify a located or
            selected UI element. In some modes (such as when in a viewing state
            where mouse events only modify the view) it is desirable to disable
            this behavior.


        """
    def locatingEnabled(self) -> bool:
        """

        locatingEnabled(self) -> bool

            Return True if the network editor will highlight UI elements under
            the mouse, and allow clicking on those UI elements.


        """
    def lengthToScreen(self, len: float) -> float:
        """

        lengthToScreen(self, len) -> float

            Given a length value len, expressed in network units, return the
            equivalent length in screen units (pixels). The result will depend
            on the current zoom level of the network editor.


        """
    def lengthFromScreen(self, len: float) -> float:
        """

        lengthFromScreen(self, len) -> float

            Given a length value len, expressed in screen units (pixels), return
            the equivalent length in network units. The result will depend on
            the current zoom level of the network editor.


        """
    def sizeToScreen(self, size: Vector2) -> Vector2:
        """

        sizeToScreen(self, size) -> hou.Vector2

            Given a box size value size as a hou.Vector2, expressed in network
            units, return the equivalent size in screen units (pixels). This is
            equivalent to making two separate calls to lengthToScreen() for the
            width and height. The result will depend on the current zoom level
            of the network editor.


        """
    def sizeFromScreen(self, size: Vector2) -> Vector2:
        """

        sizeFromScreen(self, size) -> hou.Vector2

            Given a box size value size as a hou.Vector2, expressed in screen
            units (pixels), return the equivalent size in network units. This is
            equivalent to making two separate calls to lengthFromScreen() for
            the width and height. The result will depend on the current zoom
            level of the network editor.


        """
    def posToScreen(self, pos: Vector2) -> Vector2:
        """

        posToScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in network
            units, return the equivalent position in screen units (pixels). The
            result will depend on both the current zoom level and view position
            of the network editor.

            This method is intended to be used for drawing and positioning
            within the network editor, so the returned screen coordinates are in
            pixels relative to the lower left corner of the network editor
            window, rather than being relative to a specific position on the
            user's monitor. If the specified position is not currently visible
            in the network editor pane, the resulting screen position may be
            negative, or larger than the size of the network editor pane (see
            hou.NetworkEditor.visibleBounds).


        """
    def posFromScreen(self, pos: Vector2) -> Vector2:
        """

        posFromScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in screen
            units (pixels), return the equivalent position in network units. The
            result will depend on both the current zoom level and view position
            of the network editor.

            See hou.NetworkEditor.posToScreen for more detail about the way the
            screen position is interpreted by this method.


        """
    def overviewPosToScreen(self, pos: Vector2) -> Vector2:
        """

        overviewPosToScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in network
            units, return the equivalent position in screen units (pixels)
            within the overview gadget in the network editor. This method
            returns a value that assumes the overview area is visible, even if
            it is not.


        """
    def overviewPosFromScreen(self, pos: Vector2) -> Vector2:
        """

        overviewPosFromScreen(self, pos) -> hou.Vector2

            Given a position value pos as a hou.Vector2, expressed in screen
            units (pixels) within the overview gadget, return the equivalent
            position in network units. This method returns a value that assumes
            the overview area is visible, even if it is not. If the provided
            position is outside the overview area, this method returns a value
            that assumes the overview gadget extends as far as required to reach
            the specified coordinates.


        """
    def overviewVisible(self) -> bool:
        """

        overviewVisible(self) -> bool

            Return a boolean indicating whether or not the overview gadget is
            currently visible. This result reflects the true state of the
            overview gadget even if the overview is configured to display
            automatically.


        """
    def overviewVisibleIfAutomatic(self) -> bool:
        """

        overviewVisibleIfAutomatic(self) -> bool

            Return a boolean indicating whether or not the overview gadget would
            currently be visible if it was configured to display automatically.
            In other words, this method returns True if any part of the network
            is currently outside the visible bounds of the editor.


        """
    def networkItemsInBox(self, pos1: Vector2, pos2: Vector2, for_drop: bool = False, for_select: bool = False) -> Tuple[Tuple[NetworkItem, str, int], ...]:
        """

        networkItemsInBox(self, pos1, pos2, for_drop=False, for_select=False) ->
        tuple of (hou.NetworkItem, str, int)

            Return any network items inside the bounding box defined by the
            hou.Vector2 points pos1 and pos2. These points are specified in
            screen space, which makes it easy to call this function given a
            mouse position.

            The returned tuple of triples are sorted in increasing distance from
            the center of the specified bounding box. Each triple consists of a
            network item (which may be a node, sticky note, wire, etc.), a
            string which describes the part of the UI for that item that was
            found in the box, and an optional index value which differentiates
            between different instances of the same item/name combination. For
            example, if the connector for input 2 of the node geo1 was the only
            thing inside the provided box, the return value would be:

          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> editor.networkItemsInBox(pos1, pos2)
          > ((<hou.ObjNode of type subnet at /obj/subnet1>, 'input', 2),)

            One of for_drop or for_select may be set to True to use a different
            criteria for deciding what a valid target is. By default, any UI
            widget that highlights with the mouse over it will be returned by
            this method. Setting for_drop to True will return only UI widgets
            that can be drop targets. Setting for_select to True will only
            return UI widgets that result in the item being selected when box
            picking.


        """
    def setDropTargetItem(self, item: NetworkItem, name: str, index: int) -> None:
        """

        setDropTargetItem(self, item, name, index)

            When the user is performing a drag and drop operation within the
            network editor, it is important that they receive some feedback
            about where the thing they are dragging will be dropped if they let
            go of the mouse button. This indication is provided by highlighting
            the drop target in the UI. This method allows the current drop
            target to be specified in python code. Usually the item, name, and
            index will be values returned in one of the tuples from the
            networkItemsInBox method.


        """
    def dropTargetItem(self) -> Tuple[NetworkItem, str, int]:
        """

        dropTargetItem(self) -> (hou.NetworkItem, str, int)

            Return the currently set drop target item information. These are
            just the values passed into the last call to setDropTargetItem.


        """
    def setDecoratedItem(self, item: NetworkItem, interactive: bool) -> None:
        """

        setDecoratedItem(self, item, interactive)

            This method is similar to setDropTargetItem in that it tells the
            network editor to highlight a particular item when drawing it. In
            the case of the decorated item, however, only the network item needs
            to be provided. The result of setting a node as the decorated item
            is to bring up the node ring. Network dots may also be the decorated
            item, in which case the input and output connectors for the dot are
            shown. The interactive boolean flag indicates whether the user is
            allowed to interact with the decorations. If not, the node ring is
            drawn faded, and its buttons cannot be clicked. This non-interactive
            mode corresponds to having the Control key pressed while moving the
            mouse around the network editor.


        """
    def decoratedItem(self) -> Optional[NetworkItem]:
        """

        decoratedItem(self) -> hou.NetworkItem

            Return the currently set decorated item. This is just the item value
            passed into the last call to setDecoratedItem.


        """
    def decorationInteractive(self) -> bool:
        """

        decorationInteractive(self) -> bool

            Return whether the currently decorated item is interactive. This is
            just the interactive value passed into the last call to
            setDecoratedItem.


        """
    def setPreSelectedItems(self, items: Sequence[NetworkItem]) -> None:
        """

        setPreSelectedItems(self, items)

            When box selecting items in the network, it is useful to be able to
            see what will be selected if the mouse button is released. These
            items are drawn to the overlay layer of the network editor canvas in
            a light blue color with transparency. The network items passed as a
            tuple to this method are the ones that get drawn with this pre-
            selection highlight.


        """
    def preSelectedItems(self) -> Tuple[NetworkItem, ...]:
        """

        selectedConnections(self) -> tuple of hou.NodeConnection

            Return the currently selected wires.


        """
    def selectedConnections(self) -> Tuple[NodeConnection, ...]: ...
    def clearAllSelected(self) -> None:
        """

        clearAllSelected(self)

            For an OP network editor, the behavior is equivalent to
            hou.clearAllSelected, deselecting all network items and wires. For
            an APEX network editor, this clears the selection for the current
            APEX graph.


        """
    def setNetworkBoxPendingRemovals(self, items: Sequence[NetworkMovableItem]) -> None:
        """

        setNetworkBoxPendingRemovals(self, items)

            When moving items around the network, network boxes automatically
            resize to contain their child items as they move. To indicate that
            items will be removed from their network box, pass them as a tuple
            to this method. Doing so will cause their network box containers to
            not resize to fit the items as they move.


        """
    def networkBoxPendingRemovals(self) -> Tuple[NetworkMovableItem, ...]:
        """

        networkBoxPendingRemovals(self) -> tuple of hou.NetworkMovableItem

            Return the items currently pending remove from their network box.
            These are just the values passed into the last call to
            setNetworkBoxPendingRemovals.


        """
    def setFootprints(self, footprints: typing.Iterable[NetworkFootprint]) -> None:
        """

        setFootprints(self, footprints)

            Configure the footprint rings that the network editor should
            display. The footprints parameter must be a tuple of
            hou.NetworkFootprint objects. See that class for more information.


        """
    def footprints(self) -> Tuple[NetworkFootprint, ...]:
        """

        footprints(self) -> tuple of hou.NetworkFootprint

            Return the current footprint configuration as a tuple of
            hou.NetworkFootprint objects. These are just the values passed into
            the last call to setFootprints.


        """
    def setCursorMap(self, cursors: dict[Tuple[str, int], str]) -> None:
        """

        setCursorMap(self, cursors)

            Tells the network editor which mouse cursor to use based on what UI
            widget is under the mouse. This configuration is specified as a
            dictionary mapping a tuple to a string. The string is the name of
            the cursor, which can be any of the cursor file names from the
            $HFS/houdini/config/Cursors directory. Each tuple consists of a
            string and an integer. The string is the name of the UI widget, and
            the integer represents the specific index value within that UI
            widget.

            The following code sets the network editor to show a connect cursor
            for all node inputs and outputs:

          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> editor.setCursorMap({
          > ... ('input', -1): 'wire',
          > ... ('output', -1): 'wire'
          > ... })

            The following code sets the network editor to show an appropriate
            resize icon based on the specific section of the sticky note border
            under the mouse:

          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> editor.setCursorMap({
          > ... ('stickynoteborder', 0): 'arrowSWNE',
          > ... ('stickynoteborder', 1): 'arrowLeftRight',
          > ... ('stickynoteborder', 2): 'arrowNWSE',
          > ... ('stickynoteborder', 3): 'arrowUpDown',
          > ... ('stickynoteborder', 4): 'arrowSWNE',
          > ... ('stickynoteborder', 5): 'arrowLeftRight',
          > ... ('stickynoteborder', 6): 'arrowNWSE',
          > ... ('stickynoteborder', 7): 'arrowUpDown'
          > ... })

        """
    def cursorMap(self) -> dict[Tuple[str, int], str]:
        """

        cursorMap(self) -> dict of (str, int) to str

            Return the current mouse cursor configuration. This will just be the
            dictionary passed into the last call to setCursorMap.


        """
    def setDefaultCursor(self, cursor_name: str) -> None:
        """

        setDefaultCursor(self, cursor_name)

            Tells the network editor which mouse cursor to use when none of the
            UI mentioned in the dictionary sent to setCursorMap() is under the
            mouse.


        """
    def defaultCursor(self) -> str:
        """

        defaultCursor(self) -> str

            Return the default mouse cursor set by the last call to
            setDefaultCursor().


        """
    def setBackgroundImages(self, images: typing.Iterable[NetworkImage]) -> None:
        """

        setBackgroundImages(self, images)

            Configures the background images to be displayed in the network
            editor. The network editor saves and loads the image descriptions
            into the user data for each network, which allows a different set of
            background images for each network. The images are specified as a
            tuple of hou.NetworkImage objects. See the documentation of that
            class for more information.


        """
    def backgroundImages(self) -> Tuple[NetworkImage, ...]:
        """

        backgroundImages(self) -> tuple of hou.NetworkImage

            Return the descriptors for the current set of background images
            being displayed in the network editor. This will be the tuple passed
            into the last call to setBackgroundImages.


        """
    def itemRect(self, item: NetworkMovableItem, adjusted: bool = True) -> BoundingRect:
        """

        itemRect(self, item, adjusted=True) -> hou.BoundingRect

            Return the bounding rectangle of the hou.NetworkMovableItem
            specified by the item parameter. If the adjusted parameter is set to
            True, any adjustments to this item's size and position set in the
            most recent call to setAdjustments() will be taken into account. If
            False, these adjustments will be ignored. Note that for nodes, only
            the node body is taken into account, not the node name, badges, or
            other decorations.


        """
    def itemInputPos(self, item: NetworkMovableItem, input_index: int, adjusted: bool = True) -> Vector2:
        """

        itemInputPos(self, item, input_index, adjusted=True) -> hou.Vector2

            Return the center point of the input connector of the hou.Node or
            hou.NetworkDot specified by item. The input_index parameter
            specifies the specific input of interest. For network dots, this
            value must be zero. If the adjusted parameter is set to True, any
            adjustments to this item's size and position set in the most recent
            call to setAdjustments() will be taken into account. If False, these
            adjustments will be ignored.


        """
    def itemInputDir(self, item: NetworkMovableItem, input_index: int) -> Vector2:
        """

        itemInputDir(self, item, input_index) -> hou.Vector2

            Return a normalized vector indicating the direction at which the
            wire connected to the specified input should emerge from its
            connector. The item parameter may be a hou.Node or hou.NetworkDot.
            The input_index specifies which input is of interest. This value
            must be zero if the item is a network dot.


        """
    def itemOutputPos(self, item: NetworkMovableItem, output_index: int, adjusted: bool = True) -> Vector2:
        """

        itemOutputPos(self, item, output_index, adjusted=True) -> hou.Vector2

            Return the center point of the output connector of the hou.Node,
            hou.NetworkDot, or hou.SubnetIndirectInput specified by item. The
            output_index parameter specifies the specific output of interest.
            For network dots and subnet indirect inputs, this value must be
            zero. If the adjusted parameter is set to True, any adjustments to
            this item's size and position set in the most recent call to
            setAdjustments() will be taken into account. If False, these
            adjustments will be ignored.


        """
    def itemOutputDir(self, item: NetworkMovableItem, output_index: int) -> Vector2:
        """

        itemOutputDir(self, item, output_index) -> hou.Vector2

            Return a normalized vector indicating the direction at which the
            wire connected to the specified output should emerge from its
            connector. The item parameter may be a hou.Node, hou.NetworkDot, or
            hou.SubnetIndirectInput. The output_index specifies which output is
            of interest. This value must be zero if the item is a network dot or
            subnet indirect input.


        """
    def allVisibleRects(self, ignore_items: Sequence[NetworkMovableItem], adjusted: bool = True) -> Tuple[Tuple[NetworkMovableItem, BoundingRect], ...]:
        """

        allVisibleRects(self, ignore_items) -> tuple of (hou.NetworkMovableItem,
        hou.BoundingRect)

            This method is equivalent to calling itemRect() for every network
            item that is currently visible in the network editor. Getting these
            results in a single method call is significantly faster, and
            eliminates the need to test each item for visibility. This method is
            used for finding items to snap against when moving nodes. The
            ignore_items parameter is a tuple of hou.NetworkMovableItem objects
            that should not be returned in the result tuple.


        """
    def setAdjustments(self, items: Sequence[NetworkItem], adjustments: typing.Iterable[NetworkAnimValue], auto_remove: bool = False) -> None:
        """

        setAdjustments(self, items, adjustments, auto_remove=False)

            Configures temporary adjustments to the sizes and locations of
            network items in the editor. The items parameter is a tuple of
            hou.NetworkMovableItem objects. The adjustments parameter is a tuple
            of hou.NetworkAnimValue objects to associate with each network item
            in the items tuple. See the documentation of that class for more
            information about specifying adjustments.

            The auto_remove parameter may be set to True to indicate that the
            network editor should automatically delete the adjustments once the
            animation on them has completed. This is useful for animations
            performed at the end of a user action, where the following events do
            not relate to the changes being made, and so it is easier not to
            have to manage the reset of the adjustment values explicitly in the
            future.


        """
    def setShapes(self, shapes: Sequence[NetworkShape]) -> None:
        """

        setShapes(self, shapes)

            The shapes parameter specifies a tuple of hou.NetworkShape objects
            which will be drawn into the network editor. See documentation of
            the network shape class and its subclasses for more information.


        """
    def setOverlayShapes(self, shapes: Sequence[NetworkShape]) -> None:
        """

        setOverlayShapes(self, shapes)

            The shapes parameter specifies a tuple of hou.NetworkShape objects
            which will be drawn into the overlay layer of the network editor
            canvas. See documentation of the network shape class and its
            subclasses for more information.


        """
    def setTooltip(self, tooltip: str) -> None:
        """

        setTooltip(self, tooltip)

            Sets the tooltip string that should be shown under the mouse if it
            remains stationary for a short time. This string should generally be
            set to correspond to the network item currently under the mouse
            cursor. Because it appears after a delay, it is okay to make this
            text more verbose than the prompt text passed to setPromptText().


        """
    def tooltip(self) -> str:
        """

        tooltip(self) -> str

            Return the current tooltip string. This is the value that was last
            passed to the setTooltip() method.


        """
    def setPrompt(self, prompt: str) -> None:
        """

        setPrompt(self, prompt)

            Sets the prompt text that appears at the bottom of the network
            editor. This string should generally be set to correspond to the
            network item currently under the mouse cursor. This text should be
            fairly brief. More detailed information can be put into the tooltip
            through the setTooltip() method.


        """
    def prompt(self) -> str:
        """

        prompt(self) -> str

            Return the current prompt string. This is the value that was last
            passed to the setPromptText() method.


        """
    def flashMessage(self, image: str|None, message: str|None, duration: float) -> None:
        """

        flashMessage(self, image, message, duration)

            Causes a message to appear briefly in the upper left corner of the
            network editor, then fade away. The image parameter specifies an
            icon or image file that should be displayed along with the text
            specified in the message parameter. Either of these parameters may
            be None if only an image or only text is desired. The duration
            parameter specifies the time in seconds before the message should
            fade away.


        """
    def openTabMenu(self, key: str|None = ..., auto_place: bool = ..., branch: bool = ..., src_item: NetworkMovableItem|None = ..., src_connector_index: int = ..., dest_item: NetworkMovableItem|None = ..., dest_connector_index: int = ..., node_position: Vector2|None = ..., src_items: Sequence[NetworkMovableItem]|None = ..., src_indexes: Sequence[int]|None = ..., dest_items: Sequence[NetworkMovableItem]|None = ..., dest_indexes: Sequence[int]|None = ...) -> None:
        """

        openTabMenu(self, key=None, auto_place=False, branch=False,
        src_item=None, src_connector_index=-1, dest_item=None,
        dest_connector_index=-1, node_position=None, src_items=[],
        src_indexes=[], dest_items=[], dest_indexes=[])

            Opens the tab menu in the network editor. When the user chooses a
            tool from the tab menu, the parameters passed to this function
            determine the context information that will be sent to the tool
            script. Generally, most tools treat these parameters in a consistent
            way as described below.


            key
                The key used (if any) to open the menu. This same key pressed
                with the menu up will cause the menu to close.

            auto_place
                Set to True to make the tab menu turn on auto placement when a
                tool is chosen from the menu. The new node will be placed at a
                position determined automatically by the tab menu based on the
                source and destination nodes.

            branch
                Set to True to cause the new node to create a new branch instead
                of inserting the new node between the source and destination
                nodes.

            src_item
                The node, dot, or subnet indirect input that will be connected
                to the input of the new node created by the tab menu.

            src_item_connector_index
                The output index of the node that will be connected to the input
                of the new node created by the tab menu.

            dest_item
                The node or dot that will be connected to the output of the new
                node created by the tab menu.

            dest_connector_index
                The input index of the node or dot that will be connected to the
                output of the new node created by the tab menu.

            node_position
                The location to use for the new node created by the tab menu.

            src_items
                A list of nodes, dot, or subnet indirect inputs that will be
                connected to the input of the new node created by the tab menu.
                This parameter (and all other list-based source and destination
                paramaters) take precedence over the single item parameters if
                both are specified.

            src_item_connector_indexes
                A list of output indexes of the nodes that will be connected to
                the input of the new node created by the tab menu.

            dest_items
                A list of nodes or dots that will be connected to the output of
                the new node created by the tab menu.

            dest_connector_indexes
                A list of input indexes of the nodes or dots that will be
                connected to the output of the new node created by the tab menu.


        """
    def openNodeMenu(self, node: Node|None = ..., items: Sequence[NetworkMovableItem]|None = ...) -> None:
        """

        openNodeMenu(self, node = None, items = [])

            Brings up a node context menu under the current mouse position. The
            two parameters contol which node(s) will be affected by the menu
            option chosen by the user. If a hou.Node object is specified in the
            node parameter, the menu operation will affect that node, and, if
            that node is currently selected, all other selected network items
            will also be affected. If the items parameter is passed a non-empty
            list of hou.NetworkMovableItem objects, those items and only those
            items will be affected by the menu, regardless of the current
            selection.

            If the chosen menu item only operates on a single node, the original
            node parameter value or the last hou.Node object in the items list
            will be affected. If the selected menu item can affect multiple
            nodes, all nodes will be affected. And in the few cases where
            network items other than nodes may be altered by a menu item, all
            items (nodes or otherwise) will be affected.


        """
    def openVopEffectsMenu(self, node: VopNode, input_index: int) -> None:
        """

        openVopEffectsMenu(self, node, input_index)

            Brings up the VOP node effects menu for the hou.VopNode specified in
            the node parameter, at the input specified by the input_index
            parameter.


        """
    def openVopOutputInfoMenu(self, node: VopNode, output_index: int) -> None:
        """

        openVopOutputInfoMenu(self, node, output_index)

            Brings up the VOP node output info menu for the hou.VopNode
            specified in the node parameter, at the output specified by the
            output_index parameter. This menu is used to control the behavior of
            the VOP node when the Debug or Bypass flags are enabled.


        """
    def openFloatingParameterEditor(self, node: Node) -> None:
        """

        openFloatingParameterEditor(self, node)

            Opens a floating parameter dialog for the given node.


        """
    def openNameEditor(self, item: NetworkMovableItem, select_all: bool = False) -> int:
        """

        openNameEditor(self, item, select_all = False) -> int

            Opens an input field for editing the name of the node specified in
            the item parameter. Returns an integer id which is passed to the
            network editor as part of an event indicating when the user finishes
            editing the text.

            If select_all is set to True, the editor is opened with all text
            selected.


        """
    def openCommentEditor(self, item: NetworkMovableItem, select_all: bool = False) -> int:
        """

        openCommentEditor(self, item, select_all = False) -> int

            Opens an input field for editing the comment of the network box
            specified in the item parameter. Returns an integer id which is
            passed to the network editor as part of an event indicating when the
            user finishes editing the text.

            If select_all is set to True, the editor is opened with all text
            selected.


        """
    def openNoteEditor(self, stickynote: StickyNote, select_all: bool = False) -> int:
        """

        openNoteEditor(self, stickynote, select_all = False) -> int

            Opens an input field for editing the text of the sticky note
            specified in the stickynote parameter. Returns an integer id which
            is passed to the network editor as part of an event indicating when
            the user finishes editing the text.

            If select_all is set to True, the editor is opened with all text
            selected.


        """
    def closeTextEditor(self, id: int, apply_changes: bool = True) -> None:
        """

        closeTextEditor(self, id, apply_changes = True)

            Immediately closes and commits any changes made to input fields
            opened with the openNameEditor(), openCommentEditor(), or
            openNoteEditor() methods. The id parameter is the value returned by
            the method that opened the editor. Set the apply_changes parameter
            to False if the changes made to the input field should not be
            applied.


        """
    def runShelfTool(self, tool_name: str) -> None:
        """

        runShelfTool(self, tool_name)

            Run the named shelf tool in the network editor.


        """
    def scheduleTimerEvent(self, seconds: float) -> int:
        """

        scheduleTimerEvent(self, seconds) -> int

            Requests that a timer event be sent to the network editor after
            seconds has elapsed. The returned integer id is included in the
            triggered event to differentiate between timers if more than one is
            scheduled at a time.


        """
    def handleCurrentKeyboardEvent(self, resend: bool = False) -> None:
        """

        handleCurrentKeyboardEvent(self, resend=False)

            Requests that the network editor handle the current keyboard event.
            This method only makes sense when handling a keyboard event.

            If the resend parameter is set to True, the keyboard event is sent
            to the network editor's python handling code a second time rather
            than the network editor handling the keyboard event itself. This is
            useful if the network editor is in a state or mode that does not
            know how to handle a key, but which the state recognizes as one that
            should exit the current state, and possibly trigger some other
            python event handling code. This parameter is used in the state for
            selecting the position of a new node if the Tab key is pressed
            (which exits the positions selection state, and triggers a new Tab
            menu instead).

            If this method is not called when handling a keyboard event, the
            network editor assumes that the python event handling code has
            handled the keyboard event.


        """
    def setVolatileHotkeys(self, hotkey_symbols: Sequence[str]) -> None:
        '''

        setVolatileHotkeys(self, hotkey_symbols)

            The hotkey_symbols parameter specifies a tuple of hotkey symbols
            whose bound keys should be processed as volatile keys. This means
            they generate a \\"keydown\\" event when the key is pressed, and a
            \\"keyup\\" event when the key is released. All other keys simply send a
            \\"keyhit\\" event after the key is released, with no notification when
            the key is first pressed.


        '''
    def isVolatileHotkeyDown(self, hotkey_symbol: str) -> bool:
        '''

        isVolatileHotkeyDown(self, hotkey_symbol) -> bool

            Return True if a key bound to the specified hotkey symbol is
            currently pressed. This allows the current state of a volatile key
            to be tested without seeing the \\"keydown\\" event triggered when the
            user pressed the key. Calling this method with a hotkey symbol that
            has not been registered through the setVolatileHotkeys method will
            always return False even if a key bound to the hotkey symbol is
            currently pressed.


        '''
    def hotkeyAssignments(self, hotkey_symbols: Sequence[str]) -> Tuple[Tuple[str, ...], ...]:
        '''

        hotkeyAssignments(self, hotkey_symbols) -> tuple of tuple of str`

            Return a tuple of strings that represent the hotkeys currently
            assigned to each action associated with a tuple hotkey symbols. The
            key strings are of the form returned by the hou.ui.hotkeys method,
            which is a combination of the symbol on the key, and any modifier
            keys involved, such as \\"Ctrl+Shift+G\\".


        '''
    def setPref(self, pref: str, value: str) -> None:
        """

        setPref(self, pref, value)

            Sets the preference named pref to value. The value is always a
            string, and must be converted to or from a number, enum, or other
            format as appropriate. If the preference specified by pref is a
            global preference, all network editors will automatically update
            with the new value. Otherwise the change will only affect this
            network editor.


        """
    def getPref(self, pref: str) -> str:
        """

        getPref(self, pref) -> str

            Return the value of the preference named pref. This preference may
            be a global or local preference. The returned value is always a
            string which can be interpreted as a number or other data structure
            as appropriate for the specific preference.


        """
    def setPrefs(self, prefs: dict[str, str]) -> None:
        """

        setPrefs(self, prefs)

            Sets a number of preference values with a single method call. The
            prefs parameter must be a python dictionary mapping preference name
            strings to value strings. The preferences may be local or global,
            but this method is most often used for saving and loading the local
            preferences for a single network editor.


        """
    def getPrefs(self) -> dict[str, str]:
        """

        getPrefs(self) -> dict of str to str

            Return all global and local preferences for this network editor as a
            python dictionary mapping preference name strings to value strings.


        """
    def registerPref(self, pref: str, value: str, _global: bool) -> None:
        """

        registerPref(self, pref, value, global)

            Registers a preference with the name pref, and default value value.
            If global is True, this preference is treated as a global preference
            that is applied to all network editors and saved in
            $HOUDINI_USER_PREF_DIR/networkeditor.pref. Otherwise the preference
            is considered local to each network editor, and will be saved to the
            desk file with each network editor instance.

            Registering a preference is required to ensure the preference is
            saved when it is not a preference used internally by the network
            editor. The preference that enables snapping, or the one to enable
            dropping a node onto an existing wire are examples of preferences
            that are only used by the python event handling code, and so must be
            explicitly registered. This registration should be done in response
            to the network editor initialization event which is sent once to
            each network editor when it is first created.


        """
    def badges(self) -> Tuple[Tuple[str, ...], ...]:
        """

        badges(self) -> tuple of tuple of str

            Return descriptions of the optional node badges that can be shown in
            the network editor. Each tuple contained in the returned value
            contains three strings describing the badge. The first is the
            preference value that controls whether the badge is hidden, or
            appears as a small or large icon. The second string is a description
            of the badge. The third string is the name of the badge icon. These
            values can be used to present an interface for configuring the
            badges.


        """
    def textBadges(self) -> Tuple[Tuple[str, ...], ...]:
        """

        textBadges(self) -> tuple of tuple of str

            Return descriptions of the optional node text that can be shown in
            the network editor. Each tuple contained in the returned value
            contains three strings describing the text. The first is the
            preference value that controls whether the text is hidden, or
            appears as truncated or full text. The second string is a
            description of the text. The third string is the name of an icon
            that can be used to represent the meaning of the text. These values
            can be used to present an interface for configuring the text.


        """
    def nodeShapes(self) -> Tuple[str, ...]:
        """

        nodeShapes(self) -> tuple of str

            Return a list of all valid node shape names. These are the values
            that can be set into the user data of a node to control the shape of
            a specific node. They are also the shape names that can be used as
            defaults for node types.

            This code sets a node to a random shape:

          > >>> import random
          > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
          > >>> shapes = editor.nodeShapes()
          > >>> hou.node('/obj/geo1').setUserData('nodeshape', random.choice(shapes))

        """
    def reloadNodeShapes(self) -> Tuple[str, ...]:
        """

        reloadNodeShapes(self) -> tuple of str

            Forces all node shape files to be reloaded. This may cause new
            shapes to become available, or existing shapes to be removed.
            Returns a tuple of strings that indicate the name of each loaded
            node shape, and any error messages generated while parsing each
            shape. Use nodeShapes() to get a simple list of all successfully
            loaded shapes after calling this method.


        """
    def redraw(self) -> None:
        """

        redraw(self)

            Forces the network editor to redraw. This may be necessary in cases
            where your code updates aspects of your Houdini session which
            indirectly affect the drawing of the network editor (such as
            changing default node shapes and colors). Direct changes to the
            network (such as changing the shape or color of a specific node)
            should automatically cause the network editor to redraw. Only use
            this function when you see that a redraw is not being triggered
            automatically by the your code.


        """
    def setDragSourceData(self, items: Sequence[NetworkMovableItem]) -> None:
        """

        setDragSourceData(self, items)

            Controls the network items that are put into the drag and drop
            buffer. The values in this buffer are only used when dragging items
            out of the network editor (such as when the user drags a node from
            the network editor onto a textport, or a parameter dialog.


        """
    def setDragSourceWorkItem(self, item_id: int) -> None:
        """

        setDragSourceWorkItem(self, work_item_id)

            Controls the Id of the pdg.WorkItem that is stored into the drag and
            drop buffer. The work item ID in the buffer is used when when
            dragging an item from a TOP node into a textport, Python shell, etc.


        """
    def popEventContext(self) -> None: ...
    def parmScrollPosition(self) -> Vector2:
        """

        parmScrollPosition(self) -> hou.Vector2

            Return the Parameter Editor scroll bars position as percentages.


        """
    def setParmScrollPosition(self, position: Vector2) -> None:
        """

        setParmScrollPosition(self,pos)

            Set Parameter Editor scroll bars position as hou.Vector2
            percentages.


        """
    def setParmFilterEnabled(self, on: bool, keyboard_lock: bool = False) -> None:
        """

        setParmFilterEnabled(self,on,keyboard_lock)

            Enable Parameter Editor filtering. If keyboard_lock is True and on
            is True, the filter field will be selected allowing you to use the
            keyboard right away. keyboard_lock is False by default.
            hou.parmFilterCriteria.


        """
    def parmFilterEnabled(self) -> bool:
        """

        parmFilterEnabled(self) -> bool

            Return True if Parameter Editor filtering is enabled.


        """
    def setParmFilterExactMatch(self, on: bool) -> None:
        """

        setParmFilterExactMatch(self,on)

            Set Parameter Editor filtering to use exact pattern matching.


        """
    def parmFilterExactMatch(self) -> bool:
        """

        parmFilterExactMatch(self) -> bool

            Return True if Parameter Editor filtering uses exact pattern
            matching.


        """
    def setParmFilterPattern(self, filter: str) -> None:
        """

        setParmFilterPattern(self,pattern)

            Set the Parameter Editor filter pattern. The filter pattern is
            applied on a hou.parmFilterCriteria string from parameters that
            match the hou.parmFilterMode. The pattern matching can use exact
            name matching or find the pattern within the string. The filter
            pattern can be a list of pattern separated by commas and can also
            contain wildcard * character.


        """
    def parmFilterPattern(self) -> str:
        """

        parmFilterPattern(self) -> str

            Return the Parameter Editor filter pattern.


        """
    def setParmFilterMode(self, mode: EnumValue) -> None:
        """

        setParmFilterMode(self,mode)

            Set the Parameter Editor filter mode. The hou.parmFilterMode defines
            on which parameters to apply the filter pattern.


        """
    def parmFilterMode(self) -> EnumValue:
        """

        parmFilterMode(self) -> hou.parmFilterMode

            Return the Parameter Editor hou.parmFilterMode.


        """
    def setParmFilterCriteria(self, mode: EnumValue) -> None:
        """

        setParmFilterCriteria(self,criteria)

            Set the Parameter Editor filter criteria. The hou.parmFilterCriteria
            defines how the filter pattern is applied to parameters.


        """
    def parmFilterCriteria(self) -> EnumValue:
        """

        parmFilterCriteria(self) -> hou.parmFilterCriteria

            Return the Parameter Editor hou.parmFilterCriteria.


        """
    def setMultiParmTab(self, parm: str, index: int) -> None:
        """

        setMultiParmTab(self,parm, tab_index)

            Switch a Multi Parameter Tab to a given tab using a parameter name.


        """
    def multiParmTab(self, parm: str) -> int:
        """

        multiParmTab(self,parm) -> int

            Returns the currently visible tab index using a parameter name.


        """
    def pushEventContext(self, module: str, data: Any) -> bool:
        """

        eventContextData(self) -> dict

            Accesses the context data passed into the most recent call to the
            hou.NetworkEditor.pushEventContext method. If no calls have been
            made to this method, there is still a python dict available to store
            any global information that may be used by the network editor event
            handling code. As an example, the current view bounds for each
            network visited by the editor are stored as part of this context
            data dictionary.


        """
    def eventContextData(self) -> Any: ...

class NetworkAnimValue:
    """

    hou.NetworkAnimValue

    A value to adjust the appearance of a network editor without changing
    the underlying node data.

    The hou.NetworkEditor pane allows network items to be moved or resized
    by user interactions without actually changing the node positions or
    sizes. This is accomplished by associating each NetworkAnimValue with a
    network item through the hou.NetworkEditor.setAdjustments method.
    NetworkAnimValues can either represent a single value, or they can
    represent an animation from one value to another. The actual animation
    is displayed automatically by the network editor.

    For example, to following code would animate the position of a couple of
    nodes:

    > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > >>> n1 = hou.node('/obj/geo1')
    > >>> pos1 = n1.position()
    > >>> newpos1 = pos1 + hou.Vector2(5, 5)
    > >>> anim1 = hou.NetworkAnimValue(1.0, pos1, newpos1)
    > >>> n2 = hou.node('/obj/geo2')
    > >>> pos2 = n2.position()
    > >>> newpos2 = pos2 + hou.Vector2(5, 5)
    > >>> anim2 = hou.NetworkAnimValue(1.0, pos2, newpos2)
    > >>> editor.setAdjustments([n1, n2], [anim1, anim2], auto_remove=True)
    > >>> n1.setPosition(newpos1)
    > >>> n2.setPosition(newpos2)

    Note that the new positions are set on the nodes immediately. But the
    animation starts them at their original positions, and makes it look
    like they move slowly to their new positions. Also note that the
    auto_remove parameter in the call to setAdjustments() has been set to
    True. This is because we are using the adjustments only to animate the
    nodes to their new positions, which have already been set. Once the
    animation is complete, the adjustments can be thrown away. Without this
    parameter, the adjustments would remain on the network editor until the
    next call the setAdjustments.


    """
    thisown: Incomplete
    def __init__(self, duration: float|Vector2|Vector3|Vector4|NetworkAnimValue, value_start: float|Vector2|Vector3|Vector4 = ..., value_end: float|Vector2|Vector3|Vector4 = ...) -> None:
        """

        __init__(self, duration, value_start, value_end)

            Construct a new adjustment value that does change over time. The
            value can be a float, hou.Vector2, hou.Vector3, or hou.Vector4. To
            animate a node or other item's position, use a hou.Vector2 value. To
            animate a size and position (such as for a hou.NetworkBox) use a
            hou.Vector4, where the values within the vector are
            hou.Vector4(x_position, y_position, width, height).

            The duration value is expressed in the number of seconds to get from
            the value_start to value_end. The values are interpolated linearly
            over time. The values provided are absolute values, not offsets.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class NetworkFootprint:
    """

    hou.NetworkFootprint

    Describes the conditions under which a footprint ring should be
    displayed for a node in a network editor pane.

    A footprint in the network editor is a ring drawn behind the node in the
    network editor, such as the blue display flag ring around the wave1 node
    and the orange output flag ring around the wave2 node:


    This class describes to the network editor which nodes should be drawn
    with a footprint, and the color and position of that footprint. A tuple
    of these objects is passed to the hou.NetworkEditor.setFootprints
    method. This tuple should be updated every time the current network
    changes to a new node type category.

    The default footprint setup for SOP nodes is the following:

    > >>> editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > >>> editor.setFootprints([
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Display,
    >             hou.ui.colorFromName('GraphDisplayHighlight'), 1, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Render,
    >             hou.ui.colorFromName('GraphRenderHighlight'), 0, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Template,
    >             hou.ui.colorFromName('GraphTemplateHighlight'), 2, True
    >         ),
    >         hou.NetworkFootprint(
    >             hou.nodeFlag.Footprint,
    >             hou.ui.colorFromName('GraphTemplateHighlight'), 2, True
    >         ),
    >         hou.NetworkFootprint(
    >             'output',
    >             hou.ui.colorFromName('GraphOutputHighlight'), 1, True
    >         )
    >     ])

    """
    thisown: Incomplete
    def __init__(self, condition: EnumValue|str, color: Color, ring: int, use_minimum_size: bool) -> None:
        """

        __init__(self, condition, color, ring, use_minimum_size)

            Construct a new footprint descriptor.


            condition
                Can be a hou.nodeFlag enum value, in which case any node with
                this flag set will be drawn with a footprint. Alternatively, a
                hou.nodeFootprint enum value, indicating an embedded network
                editor behavior that can be enabled to support the footprinting
                of node(s) according to a hard-coded rule set. Finally, a string
                value indicates a node type name, in which case any node of this
                type will be drawn with a footprint.

            color
                The color used to draw the ring expressed as a hou.Color.

            ring
                An integer value from 0 to 4 indicating which ring is being
                described. Ring 0 is a circle that extends from the center of
                the node. Each subsequent ring is thinner and further from the
                center of the node.

            use_minimum_size
                A boolean value. Set to True to indicate that the footprint
                should maintain a minimum visual size regardless of the network
                zoom level. Set to False if the footprint should scale with the
                network zoom level, even if that means the footprint becomes
                very small.


        """
    __swig_destroy__: Incomplete

class NetworkImage:
    """

    hou.NetworkImage

    Describes a background image that can be displayed in a network editor
    pane.

    The network editor pane can display any number of images in the
    background behind the nodes of the network. These background images are
    described using this class, and set in the network editor using the
    hou.NetworkEditor.setBackgroundImages method.

    This code sets a single background image in the network editor:

    > 
    > editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
    > image = hou.NetworkImage()
    > image.setPath('$HFS/houdini/pic/Mandril.pic')
    > image.setRect(hou.BoundingRect(0, 0, 5, 5))
    > editor.setBackgroundImages([image])

    The network editor pane provides a mode for creating and editing
    background images directly in the pane. The resulting image layout is
    saved into the user data for the current network so that the image
    arrangement is automatically saved and restored with the hip file.


    """
    thisown: Incomplete
    def __init__(self, path: str, rect: BoundingRect) -> None:
        """

        __init__(self, path, rect)

            Construct a new image descriptor. The path parameter is a string
            containing the path to the image file. The rect parameter is a
            hou.BoundingRect that specifies the location and size for drawing
            the image in the network.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def setPath(self, path: str) -> None:
        """

        setPath(self, path)

            Sets the path to the image file.


        """
    def path(self) -> str:
        """

        path(self) -> str

            Return the path to the image file.


        """
    def setRelativeToPath(self, path: str) -> None:
        """

        setRelativeToPath(self, path)

            Images can be tied to network items such as nodes, network boxes, or
            sticky notes. This method sets the path to the network item to which
            this image is tied. Passing in an empty string indicates the
            location is not relative to any network item.


        """
    def relativeToPath(self) -> str:
        """

        relativeToPath(self) -> str

            Images can be tied to network items such as nodes, network boxes, or
            sticky notes. This method returns the path to the network item to
            which this image is tied (or an empty string if its location is not
            relative to any network item).


        """
    def setRect(self, rect: BoundingRect) -> None:
        """

        setRect(self, rect)

            Sets the bounding rectangle that defines the size and position of
            the image within the network. If the relativeToPath() value is set,
            then the rectangle will be translated by the position of the network
            item to which this image is tied.


        """
    def rect(self) -> BoundingRect:
        """

        rect(self) -> hou.BoundingRect

            Returns the bounding rectangle that defines the size and position of
            the image within the network. If the relativeToPath() value is set,
            then the rectangle is translated by the position of the network item
            to which this image is tied.


        """
    def setBrightness(self, brightness: float) -> None:
        """

        setBrightness(self, brightness)

            Sets the brightness adjustment for displaying this image in the
            network editor. This value should range from 0 to 1. Values less
            than 1 cause the image to be blended with the background of the
            network editor. An image with a brightness of 0 will appear as the
            background color, not black as is normally indicated by a brightness
            value of 0.


        """
    def brightness(self) -> float:
        """

        brightness(self) -> float

            Return the brightness adjustment for displaying this image in the
            network editor. This value should range from 0 to 1. Values less
            than 1 cause the image to be blended with the background of the
            network editor. An image with a brightness of 0 will appear as the
            background color, not black as is normally indicated by a brightness
            value of 0.


        """

class NetworkShape:
    """

    hou.NetworkShape

    The base class for extra shapes that can be drawn into a network editor.

    The network editor pane can be instructed to draw additional shapes to
    either the main canvas, or to the overlay area of the pane (drawn on top
    of the actual network). Each element that is drawn is described as a
    subclass of this NetworkShape base class, then passed to the network
    editor through either the hou.NetworkEditor.setShapes or
    hou.NetworkEditor.setOverlayShapes methods.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete

class NetworkShapeLine(NetworkShape):
    """

    hou.NetworkShapeLine

    Describes a line that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a line that can be drawn
    into a network editor pane.


    """
    thisown: Incomplete
    def __init__(self, start: Vector2, end: Vector2, color: Color = ..., alpha: float = ..., width: float = ..., screen_space: bool = ..., smooth: bool = ..., dashed: bool = ...) -> None:
        """

        __init__(self, start, end, color = hou.Color((1.0, 1.0, 1.0)), alpha =
        1.0, width = 1.0, screen_space = True, smooth = True, dashed = False)

            Constructs a new line descriptor.


            start
                A hou.Vector2 indicating the starting point of the line. May be
                in screen space or network units depending on the value of the
                screen_space parameter.

            end
                A hou.Vector2 indicating the ending point of the line. May be in
                screen space or network units depending on the value of the
                screen_space parameter.

            color
                The color of the line, expressed as a hou.Color.

            alpha
                The alpha used when drawing the line, expressed as a float value
                between 0 and 1.

            width
                A float value indicating the width of the line. This value is
                always expressed in pixels, regardless of the value of the
                screen_space parameter.

            screen_space
                A boolean value indicating whether the start and end parameters
                are expressed in screen space or network layout space. If set to
                True, the positions are expressed as pixels relative to the
                lower left corner of the pane. If False, the positions are
                expressed in network units.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line.

            dashed
                A boolean value indicating whether lines should be drawn as a
                series of dashes rather than as solid lines.


        """
    __swig_destroy__: Incomplete

class NetworkShapeBox(NetworkShape):
    """

    hou.NetworkShapeBox

    Describes a rectangular area that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a rectangle that can be
    drawn into a network editor pane.


    """
    thisown: Incomplete
    def __init__(self, rect: BoundingRect, color: Color = ..., alpha: float = ..., fill: bool = ..., screen_space: bool = ..., smooth: bool = ...) -> None:
        """

        __init__(self, rect, color = hou.Color((1.0, 1.0, 1.0)), alpha = 1.0,
        fill = True, screen_space = True, smooth = True)

            Constructs a new box shape descriptor.


            rect
                A hou.BoundingRect object which describes the size and position
                of the box. It may describe the box in screen space or in the
                network layout space, depending on the value of the screen_space
                parameter. This is the only required parameter.

            color
                The color of the box, expressed as a hou.Color.

            alpha
                The alpha used when drawing the box, expressed as a float value
                between 0 and 1.

            fill
                A boolean value indicating whether the box should be filled, or
                just drawn as an outline.

            screen_space
                A boolean value indicating whether the rect parameter describes
                the box size and position in screen space or network layout
                space. If set to True, the rectangle is expressed as pixels
                relative to the lower left corner of the pane. If False, the
                rectangle is expressed in network units.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line. This parameter has no effect if fill is
                True.


        """
    __swig_destroy__: Incomplete

class NetworkShapeNodeShape(NetworkShape):
    """

    hou.NetworkShapeNodeShape

    Describes a node shape that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a node shape that can be
    drawn into a network editor pane. This can draw any of the node shapes
    available to the nodes in the network through the Shape Palette.


    """
    thisown: Incomplete
    def __init__(self, rect: BoundingRect, shape: str, color: Color = ..., alpha: float = ..., fill: bool = ..., screen_space: bool = ..., smooth: bool = ...) -> None:
        """

        __init__(self, rect, shape, color = hou.Color((1.0, 1.0, 1.0)), alpha =
        1.0, fill = True, screen_space = True, smooth = True)

            Constructs a new node shape descriptor.


            rect
                A hou.BoundingRect object which describes the size and position
                of the box. It may describe the box in screen space or in the
                network layout space, depending on the value of the screen_space
                parameter. This is the only required parameter.

            shape
                A string holding the name of the node shape to draw. The list of
                available node shapes can be retrieved with the
                hou.NetworkEditor.nodeShapes method.

            color
                The color of the node shape, expressed as a hou.Color.

            alpha
                The alpha used when drawing the node shape, expressed as a float
                value between 0 and 1.

            fill
                A boolean value indicating whether the node shape should be
                filled, or just drawn as an outline.

            screen_space
                A boolean value indicating whether the rect parameter describes
                the node shape size and position in screen space or network
                layout space. If set to True, the bounds are expressed as pixels
                relative to the lower left corner of the pane. If False, the
                bounds are expressed in network units.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line. This parameter has no effect if fill is
                True.


        """
    __swig_destroy__: Incomplete

class NetworkShapeConnection(NetworkShape):
    """

    hou.NetworkShapeConnection

    Describes a wire that can be drawn into a network editor.

    This subclass of hou.NetworkShape describes a wire that can be drawn
    into a network editor pane. This wire is drawn using the same wire style
    set on the current network.


    """
    thisown: Incomplete
    def __init__(self, input_pos: Vector2, input_dir: Vector2, output_pos: Vector2, output_dir: Vector2, color: Color = ..., alpha: float = ..., fade_factor: float = ..., smooth: bool = ..., dashed: bool = ...) -> None:
        """

        __init__(self, input_pos, input_dir, output_pos, output_dir, color =
        hou.Color((1.0, 1.0, 1.0)), alpha = 1.0, fade_factor = 0.0, smooth =
        True, dashed = False)

            Constructs a new connection descriptor. This is different from a
            hou.NetworkShapeLine because it is drawn using the same algorithm as
            a wire connecting two nodes, rather than always using a straight
            line.


            input_pos
                A hou.Vector2 indicating the starting point of the connection,
                expressed in network coordinates.

            input_dir
                A hou.Vector2 expressing the starting direction of the wire.

            output_pos
                A hou.Vector2 indicating the end point of the connection,
                expressed in network coordinates.

            output_dir
                A hou.Vector2 expressing the ending direction of the wire.

            color
                The color of the connection, expressed as a hou.Color.

            alpha
                The alpha used when drawing the connection, expressed as a float
                value between 0 and 1.

            fade_factor
                A float value indicating the amount of fading that should be
                applied to this connection if it exceeds the fade length. By
                setting this value to 0.0, all fading logic is disabled.

            smooth
                A boolean value indicating whether lines should be drawn with
                smoothing turned on. Smoothing lines is a form of anti-aliasing
                which can make curved lines look better, but doing so may affect
                the color of the line.

            dashed
                A boolean value indicating whether lines should be drawn as a
                series of dashes rather than as solid lines.


        """
    __swig_destroy__: Incomplete

class Bundle:
    '''

    hou.NodeBundle

    A named set of nodes whose contents can be from different networks. A
    bundle\'s contents may be fixed or may be determined from a pattern, and
    the contents may be filtered by node type.

    Unlike node groups, the nodes in a bundle may be from different node
    networks. For example, the same bundle may contain /obj/geo1 and
    /obj/subnet1/geo2. Node groups are primarily used to organize and
    display very large networks, while node bundles are normally used to
    track which objects are lit by a light, which objects are visible in a
    scene, etc.

    There are two types of node bundles: regular and smart. You can add and
    remove individual nodes to and from a regular bundle. The nodes in a
    smart bundle, on the other hand, are determined from a pattern stored in
    the bundle. As nodes matching the pattern are created or deleted in
    Houdini, the contents of the bundle will update automatically. You can
    use hou.NodeBundle.pattern to determine if the bundle is a smart bundle
    or a regular one.

    When a node matches the pattern in a smart bundle, that node and its
    children will be added to the bundle. For example, if the pattern in
    \\"/obj/*\\" and /obj/box_object1 is a geometry object, all the nodes inside
    /obj/box_object1 will be added to the bundle, recursively. Carets (^) in
    the pattern can be used to remove nodes; for example, \\"/obj/*
    ^/obj/geo1\\" will match everything in /obj except for /obj/geo1.

    A bundle may also have a filter to specify what types of nodes may be in
    the bundle. See hou.nodeTypeFilter for the possible filters. If you try
    to add a node to a regular bundle but the node does not match the
    filter, Houdini will fail to add the node. For smart bundles, the filter
    is applied after doing any pattern matching. For example, if the pattern
    is \\"/obj/*\\" and the filter is hou.nodeTypeFilter.Obj, the bundle will
    contain only the objects in /obj, without any SOPs, etc. inside them.
    Because the pattern is applied recursively, however, any objects inside
    object subnets will also be in the bundle.

    To specify a bundle in a node parameter that expects a list of nodes,
    prefix the bundle name with @. For example, you can enter @bundle1 in
    the light mask parameter of an object so it is lit by the nodes inside
    the bundle named bundle1.

    You can view and edit node bundles in Houdini\'s Bundle List pane. Use
    hou.nodeBundle_ and hou.nodeBundles to access existing node bundles, and
    hou.addNodeBundle to create a new bundle.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this bundle.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of the bundle.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Change the name of the bundle.

            Raises hou.OperationFailed if the name contains non-alphanumeric
            characters other than _, or if a bundle with that name already
            exists.


        """
    def findBestFilter(self) -> EnumValue:
        """

        findBestFilter(self) -> hou.nodeTypeFilter enum value

            Return the most restrictive bundle filter that matches all the nodes
            in the bundle.

            See hou.nodeTypeFilter for the possible filters.
            hou.nodeTypeFilter.NoFilter is a special value to indicate that
            there is no filtering.


        """
    def filter(self) -> EnumValue:
        """

        filter(self) -> hou.nodeTypeFilter enum value

            Return the bundle's filter. For smart bundles, the filter is applied
            after matching nodes to the pattern, and nodes whose types do not
            match the filter are removed from the bundle.

            See hou.nodeTypeFilter for the possible filters.
            hou.nodeTypeFilter.NoFilter is a special value to indicate that
            there is no filtering.

            See the class documentation for more information about filtering.


        """
    def setFilter(self, filter: EnumValue) -> None:
        """

        setFilter(self, node_type_filter)

            Set this bundle's filter to a hou.nodeTypeFilter enumerated value.
            Use hou.nodeTypeFilter.NoFilter to clear the filter.

            See hou.NodeBundle.filter and the class documentation for more
            information.


        """
    def pattern(self) -> str | None:
        '''

        pattern(self) -> str or None

            Return None if this bundle is a regular bundle, or a string pattern
            if the bundle is a smart bundle.

            See the class documentation for more information on smart bundles.
            Note that if a node matches the pattern, all its subchildren will be
            in the bundle, as long as they match the filter. For example, if the
            pattern is \\"/obj/*\\" and the filter is hou.nodeTypeFilter.NoFilter,
            the bundle will contain all nodes under /obj, recursively.


        '''
    def setPattern(self, pattern_or_none: str) -> None:
        """

        setPattern(self, pattern_or_none)

            Change the pattern of this bundle.

            Setting the pattern to None changes the bundle into a regular
            bundle. In this case, the bundle's contents are unchanged, but
            Houdini will no longer do pattern matching to determine the bundle's
            contents.

            If the pattern is a string, the bundle becomes a smart bundle and
            its contents immediately change to match the pattern. The bundle's
            contents will update as nodes are created and deleted in Houdini.

            See hou.NodeBundle.pattern and the class documentation for more
            information.


        """
    def nodes(self) -> Tuple[Node, ...]:
        """

        nodes(self) -> tuple of hou.OpNode

            Return a tuple of the nodes in this bundle.


        """
    def containsNode(self, node: Node) -> bool:
        """

        containsNode(self, node) -> bool

            Return True if the node is in the bundle and False otherwise. node
            must be a hou.OpNode object.

            This method is a shortcut for node in bundle.nodes(). For bundles
            with many nodes, this method will be slightly faster.


        """
    def addNode(self, node: Node) -> None:
        """

        addNode(self, node)

            Add a node to the bundle.

            Raises hou.OperationFailed if this bundle is a smart bundle, since
            the contents of smart bundles are automatically determined by their
            pattern.


        """
    def removeNode(self, base_node: Node) -> None:
        """

        removeNode(self, node)

            Remove a node from the bundle.

            Raises hou.OperationFailed if this bundle is a smart bundle, since
            the contents of smart bundles are automatically determined by their
            pattern.


        """
    def clear(self) -> None:
        """

        clear(self)

            Remove all nodes from the bundle.

            Raises hou.OperationFailed if this bundle is a smart bundle, since
            the contents of smart bundles are automatically determined by their
            pattern.


        """
    def isSelected(self) -> bool:
        """

        isSelected(self) -> bool

            Return True if the bundle is selected in the bundle list pane and
            False otherwise.


        """
    def setSelected(self, on: bool, clear_all_selected: bool = False) -> None:
        """

        setSelected(self, on, clear_all_selected=false)

            Select this bundle in the bundle list pane. If clear_all_selected is
            True, only this bundle will remain selected. Otherwise, this bundle
            will be added to the existing selection.


        """
    def convertToNormalBundle(self) -> None:
        """

        convertToNormalBundle(self)

            Convert the bundle into a normal bundle. The smart bundle pattern is
            removed.

            Do nothing if the bundle is already a normal bundle.


        """
    def convertToSmartBundle(self) -> None:
        """

        convertToSmartBundle(self)

            Convert the bundle into a smart bundle. A regular expression is
            constructed from the contents of the bundle and then set as the
            bundle pattern.

            Do nothing if the bundle is already a smart bundle.


        """

class NodeConnection(NetworkItem):
    """

    hou.NodeConnection

    Represents a connection (wire) between two Nodes.

    OVERVIEW

        You can get a list of NodeConnection objects from a hou.Node
        instance using hou.Node.inputConnections and
        hou.Node.outputConnections.


        NOTE
            It is probably easier to use the hou.Node.inputs and
            hou.Node.outputs methods (which return the endpoints of a node's
            connections) to traverse the network, rather than dealing with
            the connections themselves.

        This object is read-only. To create or edit connections, use methods
        on the node, such as hou.Node.setNamedInput, hou.Node.setInput,
        hou.Node.setFirstInput, hou.Node.setNextInput,
        hou.Node.createInputNode, and hou.Node.createOutputNode.

    INPUT AND OUTPUT MEANING

        The hou.NodeConnection.outputNode and hou.NodeConnection.inputNode
        are named in relation to the input and output ends of the connector.
        So, outputNode() returns the node at the output end of this
        connection, in relation to the flow of data through the network.
        inputNode() returns the node that provides data to the output node.

        For the other methods on this object, if the method name starts with
        input, it is referring to data on the inputNode(). If the method
        name starts with output, it is referring to data from the
        outputNode(). There is one exception to this: inputIndex() refers to
        the input number on the outputNode(), and outputIndex() refers to
        the output number of the inputNode().


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def outputNode(self) -> Optional[Node]:
        """

        outputNode(self) -> hou.Node

            Return the node on the output side of this connection. This is the
            node that the connection goes to, in the direction of data flow. If
            this connection has a network dot as its output, this method returns
            None.


        """
    def inputIndex(self) -> int:
        """

        inputIndex(self) -> int

            Returns the index of the input connection on the node that the
            output side of this connections connects to.


        """
    def outputItem(self) -> NetworkMovableItem:
        """

        outputItem(self) -> hou.NetworkMovableItem

            Return the node or network dot on the output side of this
            connection. This is the node or dot that the connection goes to, in
            the direction of data flow. This method should never return None.


        """
    def inputNode(self) -> Optional[Node]:
        """

        inputNode(self) -> hou.Node

            Return the node on the input side of this connection. This is the
            node that the connection comes from, in the direction of data flow.
            If this connection goes through an indirect input, this will return
            the node connected to the parent node (or None if nothing is
            connected).


        """
    def outputIndex(self) -> int:
        """

        outputIndex(self) -> int

            Returns the index of the output connection on the node that the
            input side of this connections connects to. If this connection goes
            through an indirect input, this will return the index of the output
            connected to the parent node (or 0 if nothing is connected).


        """
    def subnetIndirectInput(self) -> Optional[SubnetIndirectInput]:
        """

        subnetIndirectInput(self) -> hou.SubnetIndirectInput

            If this connection has a subnet indirect input connected to it
            instead of a node, return the corresponding object. Otherwise,
            return None. See hou.SubnetIndirectInput for information on subnet
            indirect inputs.


        """
    def inputItem(self) -> Optional[NetworkMovableItem]:
        """

        inputItem(self) -> hou.NetworkMovableItem

            If this connection has a subnet indirect input connected to it,
            return the corresponding hou.SubnetIndirectInput object. If this
            connection has a node connected to it, return the corresponding
            hou.Node object. Otherwise, return None. This method is essentially
            equivalent to the following:

          > def getInputItem(node_connection):
          >     if node_connection.subnetIndirectInput() is not None:
          >         return node_connection.subnetIndirectInput()
          >     return node_connection.inputNode()

        """
    def inputItemOutputIndex(self) -> int:
        """

        inputItemOutputIndex(self) -> int

            Returns zero if this connection has a subnet indirect input
            connected to it. Otherwise return the index of the output connection
            on the node that the input side of this connections connects to. In
            combination with the inputItem method, node and subnet indirect
            inputs can be processed through a common code path for many use
            cases.


        """
    def isSelected(self) -> bool:
        """

        isSelected(self) -> bool

            Return True if this connection is selected.


        """
    def setSelected(self, selected: bool, clear_all_selected: bool = False) -> None:
        """

        setSelected(self, selected, clear_all_selected = False)

            Selects or de-selects this connection. If the clear_all_selected
            parameter is set to True, all other selections (both connections,
            and nodes, network boxes, etc.) will be cleared before this
            connection is selected.


        """
    def inputName(self) -> str:
        """

        inputName(self) -> str

            Returns the name of the output connection on the node that the input
            side of this connections connects to.


        """
    def inputLabel(self) -> str:
        """

        inputLabel(self) -> str

            Returns the label of the output connection on the node that the
            input side of this connections connects to.


        """
    def inputDataType(self) -> str: ...
    def outputName(self) -> str:
        """

        outputName(self) -> str

            Returns the name of the input connection on the node that the output
            side of this connections connects to.


        """
    def outputLabel(self) -> str:
        """

        outputLabel(self) -> str

            Returns the label of the input connection on the node that the
            output side of this connections connects to.


        """
    def outputDataType(self) -> str: ...

class ApexNodeConnection(NodeConnection):
    """

    hou.ApexNodeConnection

    Represents a connection (wire) between two APEX Nodes.

    This class represents an APEX wire connection between two ports of the
    APEX nodes.

    RELATED

      * hou.apexNodeConnectionBySessionId


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...
    def sessionId(self) -> int:
        """

        sessionId(self)

            Returns an integer value that uniquely identifies this item in a
            given Houdini session. This id is only guaranteed to be unique in a
            single Houdini process.


        """

class OpNodeConnection(NodeConnection):
    """

    hou.OpNodeConnection

    Represents a connection (wire) between two OP Nodes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class NodeInfoTree:
    """

    hou.NodeInfoTree

    A tree structure designed to contain information about nodes and the
    data they generate.

    This class represents a tree structure, where each branch of the tree
    can have any number of named sub-trees, as well as a two dimensional
    grid of strings. Most often this grid has two columns (Property and
    Value), with some number of rows to represent arbitrary key/value pairs.
    But the grid can also contain more complex data (such as the volume
    information in geometry data).


    """
    thisown: Incomplete
    def __init__(self, tree_root: Any, tree: Any) -> None:
        """

        hou.NodeInfoTree

        A tree structure designed to contain information about nodes and the
        data they generate.

        This class represents a tree structure, where each branch of the tree
        can have any number of named sub-trees, as well as a two dimensional
        grid of strings. Most often this grid has two columns (Property and
        Value), with some number of rows to represent arbitrary key/value pairs.
        But the grid can also contain more complex data (such as the volume
        information in geometry data).


        """
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of this branch of the tree.


        """
    def infoType(self) -> str:
        '''

        infoType(self) -> str

            Returns a string that can be used to describe the type of data
            stored in this tree. For example, a tree holding geometry
            information (generated either by a SOP node or a DOP node) will
            return \\"Geometry\\" from this method.


        '''
    def branchOrder(self) -> Tuple[str, ...]:
        """

        branchOrder(self) -> tuple of str

            Returns the natural order of the child branches in the dictionary
            returned by branches(). This ordering is often not very important,
            but in situations where there are a large number of branches that do
            have some sort of natural order (such as the branches for each DOP
            object returned by a DOP node) this method can help organize the
            information.

            This code iterates through all child branches of a node's info tree
            in their natural order, assuming an RBD simulation created from a
            default sphere and torus object:

          > >>> nodeinfo = hou.node('/obj/AutoDopNetwork/output').infoTree()
          > >>> dopinfo = nodeinfo.branches()['DOP Info']
          > >>> objinfo = dopinfo.branches()['Objects']
          > >>> objbranches = objinfo.branches()
          > >>> for objname in objinfo.branchOrder():
          > ...   obj = objbranches[objname]
          > ...   print objname, ':', obj.branches()
          > ...
          > torus_object1 : {'Geometry': <hou.NodeInfoTree>}
          > sphere_object1 : {'Geometry': <hou.NodeInfoTree>}

        """
    def branches(self) -> dict[str, NodeInfoTree]:
        """

        branches(self) -> dict of str to hou.NodeInfoTree

            Return a dictionary of all child branches. Each branch has a name,
            and is a full tree, which may have it's own branches, and so on.


        """
    def headings(self) -> Tuple[str, ...]:
        """

        headings(self) -> tuple of str

            Returns the titles of the columns for the data returned by the
            rows() method. Usually this will be simply ('Property', 'Value'),
            for rows that are simply key/value pairs. But in some cases the
            headings can help interpret the returned information.


        """
    def rows(self) -> Tuple[Tuple[str, ...], ...]:
        """

        rows(self) -> tuple of tuple of str

            Return a two dimensional grid of strings. The returned tuple
            represents the rows of the grid. The contained tuples each represent
            one row. All contained tuples will be the same length, which will be
            the length of the tuple returned by the headings() method.


        """

class OrboltURLHandler:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def updateProgressBar(self, percentage: float) -> None: ...
    def closeSplashScreen(self, immediate: bool = False) -> None: ...

class OrientedBoundingBox:
    """

    hou.OrientedBoundingBox

    An oriented 3D rectangular region.

    Computes an oriented bounding box for a set of points.


    """
    thisown: Incomplete
    def __init__(self, oriented_bbox: OrientedBoundingBox = ...) -> None:
        """

        __init__(self)

            Constructs an empty bounding box.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, other: OrientedBoundingBox, tol: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, bbox, tolerance=0.00001) -> bool

            Returns whether this bounding box is equal to another, subject to
            numerical tolerances.


        """
    def __hash__(self) -> int: ...
    def __mul__(self, matrix4: Matrix4) -> OrientedBoundingBox:
        """

        __mul__(self, matrix4) -> OrientedBoundingBox

            Return a copy of this bounding box transformed by the given matrix.


        """
    def center(self) -> Vector3:
        """

        center(self) -> hou.Vector3

            Returns the position of the center of the bounding box.


        """
    def rotation(self) -> Matrix3: ...
    def sizevec(self) -> Vector3:
        """

        sizevec(self) -> hou.Vector3

            Returns a vector describing the size of the box in each of the x, y
            and z axes relative to its rotated coordinate system (that is, where
            the x axis is the first row of rotation).


        """
    def contains(self, point: Sequence[float]) -> bool:
        """

        contains(self, point) -> bool

            Given a sequence of 3 floats (such as a hou.Vector3) describing a
            position, return whether the position is inside the box.


        """
    def isValid(self) -> bool:
        """

        isValid(self) -> bool

            Returns whether this bounding box is valid.


        """

class OrientedBoundingRect:
    """

    hou.OrientedBoundingRect

    An oriented 2D rectangular region.

    Computes an oriented bounding rectangle for a set of points.


    """
    thisown: Incomplete
    def __init__(self, points: typing.Iterable[Vector2]) -> None:
        """

        __init__(self, points)

            Constructs the minimum area oriented bounding rectangle for the
            given points (a sequence of hou.Vector2).


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, brect: OrientedBoundingRect, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, brect, tolerance=0.00001) -> bool

            Returns whether this bounding rectangle is equal to another, subject
            to numerical tolerances.


        """
    def __hash__(self) -> int: ...
    def sizevec(self) -> Vector2:
        """

        sizevec(self) -> hou.Vector2

            Returns a vector describing the size of the box in the x and y axes.


        """
    def center(self) -> Vector2:
        """

        center(self) -> hou.Vector2

            Returns the position of the center of the bounding rectangle.


        """
    def orientation(self) -> Matrix2:
        """

        orientation(self) -> hou.Matrix2

            Returns a hou.Matrix2 that defines the orientation of the bounding
            rectangle.


        """

class PackedFragment(PackedPrim):
    """

    hou.PackedFragment

    A packed fragment primitive.

    See packed primitives for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def setEmbeddedGeometry(self, geometry: Geometry, attrib: str, name: str) -> None:
        """

        setEmbeddedGeometry(self, geo, attrib, name)

            Embeds into this primitive all primitives from geo with the value
            name for the primitive attribute attrib. Use read-only frozen
            geometry to share geometry between multiple packed fragment
            primitives. See hou.Geometry.freeze for more information.


        """

class PackedGeometry(PackedPrim):
    """

    hou.PackedGeometry

    A packed geometry primitive.

    See packed primitives for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def getEmbeddedGeometry(self) -> Geometry:
        """

        getEmbeddedGeometry(self) -> hou.Geometry

            Returns the geometry of this primitive.


        """
    def setEmbeddedGeometry(self, geometry: Geometry) -> None:
        """

        setEmbeddedGeometry(self, geo)

            Embeds the provided geometry into this primitive. Use read-only
            frozen geometry to share geometry between multiple packed geometry
            primitives. See hou.Geometry.freeze for more information.


        """

class Parm:
    """

    hou.Parm

    A parameter in a node. Each parameter has a unique name within its node
    and exists inside a parameter tuple.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def node(self) -> OpNode:
        """

        node(self) -> hou.OpNode

            Returns the node on which this parameter exists.


        """
    def tuple(self) -> ParmTuple:
        """

        tuple(self) -> hou.ParmTuple

            Returns the hou.ParmTuple associated with this parameter.

            For example, calling this method on the Parm object for the
            translation parameter tx, would return a ParmTuple that contains
            Parm objects for the three translation parameters tx, ty and tz. If
            no tuple is associated with the parameter, then the parameter itself
            is returned in a tuple of size 1.


        """
    def parmTemplate(self) -> ParmTemplate:
        """

        parmTemplate(self) -> hou.ParmTemplate

            Returns the template for this parameter.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns this parameter's name.


        """
    def path(self) -> str:
        """

        path(self) -> str

            Returns the full path to this parameter.


        """
    def description(self) -> str:
        """

        description(self) -> str

            Returns this parameter's label.


        """
    def componentIndex(self) -> int:
        """

        componentIndex(self) -> int

            Returns the component index of this parameter.

            For example, the translation parameter along the x-axis, tx, would
            return a component index of 0, while the translation parameter along
            the y-axis, ty would return a component index of 1.


        """
    def menuContents(self) -> Tuple[str, ...]:
        """

        menuContents(self) -> tuple of str

            Returns a list of the tokens and labels for all possible menu items
            (for a menu parameter). This format is suitable for use in a
            parameter menu script. Raises hou.OperationFailed if this parameter
            is not a menu.


        """
    def menuLabels(self) -> Tuple[str, ...]:
        """

        menuLabels(self) -> tuple of str

            Returns a list of labels for all possible menu items (for a menu
            parameter). Raises hou.OperationFailed if this parameter is not a
            menu.


        """
    def menuItems(self) -> Tuple[str, ...]:
        """

        menuItems(self) -> tuple of str

            Returns a list of all possible menu items (for a menu parameter).
            Raises hou.OperationFailed if this parameter is not a menu.


        """
    def isDynamicMenu(self) -> bool:
        """

        isDynamicMenu(self) -> bool

            Returns True if the parameter's menu item list is specified using
            custom logic defined in the Houdini source code. Returns False if
            the parameter's menu items are specified with a script or item list,
            or if the parameter is not a menu.


        """
    def pressButton(self, arguments: Mapping[str, int|bool|float|str] = ...) -> None:
        """

        pressButton(self, arguments={})

            Emulates clicking a button parameter to trigger its callback script.
            Raises hou.OperationFailed if the callback script could not be run.
            An optional dictionary of arguments can be passed to the callback
            script. Raises TypeError if a n argument value type is unsupported.


            NOTE
                This can be called on any type parameter to trigger its callback
                script, it is not limited to only button parameters.


            arguments
                An optional dictionary of arguments for the callback script. The
                dictionary is merged with the keyword values passed to the
                callback. The arguments values are single values of the
                following types: int, bool, float, str.


        """
    def referenceExpression(self, to_base_parm: Parm, language: Optional[EnumValue] = None, follow_parm_reference: bool = True) -> str:
        """

        referenceExpression(self, parm, language=None,
        follow_parm_reference=True) -> str

            Returns an expression string that contains a channel reference from
            this parameter to the specified parm.


        """
    def setFromParm(self, src: Parm) -> None:
        """

        setFromParm(self, src)

            Copies the value of an entire parameter, including channels, from
            the provided src parameter.


        """
    def setFromParmDefaults(self, src: Parm) -> None: ...
    def overwriteDefaults(self) -> None:
        """

        overwriteDefaults(self)

            Overwrite the default values with the current parameter tuple
            values.


        """
    def revertToDefaults(self) -> None:
        """

        revertToDefaults(self)

            Change the value back to the default(s). See also the
            revertToAndRestoreFactoryDefaults() method.


        """
    def revertToAndRestorePermanentDefaults(self) -> None:
        """

        revertToAndRestorePermanentDefaults(self)

            Changes the value back to the default that ships with Houdini, and
            restores that default.

            See also the revertToDefaults() method, and
            hou.ParmTuple.revertToAndRestorePermanentDefaults


        """
    def revertToRampDefaults(self) -> None:
        """

        revertToRampDefaults(self)

            Change the value back to the default(s), removing all the non-
            default control points from the ramp.

            Raises TypeError if the parameter is not a ramp.


        """
    def hasTemporaryDefaults(self) -> bool:
        """

        hasTemporaryDefaults(self) -> bool

            Returns whether a default has been explicitly set on the parameter.

            See also the revertToDefaults() and
            revertToAndRestorePermanentDefaults()methods.


        """
    def isAtDefault(self, compare_temporary_defaults: bool = True, compare_expressions: bool = True) -> bool:
        """

        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool

            Returns whether the parameter is currently at its default.

            compare_temporary_defaults: When <compare_temporary_defaults> is
            True, isAtDefault also checks

            compare_expressions: When <compare_Expressions> is True, isAtDefault
            compares the actual

            See also the revertToDefaults() and
            revertToAndRestorePermanentDefaults()methods.


        """
    def isAtRampDefault(self) -> bool:
        """

        isAtRampDefault(self) -> bool

            Returns whether the ramp parameter is currently at its default.

            This tests all of the multiparm parameters associated with the ramp
            by comparing to the special ramp default spare paramater data. Ramps
            with no default spare data will never be at default.


        """
    def setExpression(self, expression: str, language: Optional[EnumValue] = None, replace_expression: bool = True) -> None:
        """

        setExpression(self, expression, language=None, replace_expression=True)

            Sets this parameter's expression.

            expression: A string containing the expression that will go inside
            the parameter.

            language: Either a hou.exprLanguage enumeration value or None.

            If language is None and the parameter does not already contain an
            expression, the language will be the node's expression language.
            (See hou.OpNode.expressionLanguage.) Otherwise, if language is None
            and the parameter already has an expression, the expression language
            will not change.

            replace_expression: This parameter only has effect if the parameter
            already contains keyframes. If it is True, Houdini will replace the
            keyframe before the current time with one containing the new
            expression. Otherwise, it will always add a keyframe at the current
            time. Note that this behavior matches what happens when you edit an
            expression from Houdini's parameter dialog.

            Unlike hou.Parm.set, this method does not follow channel references.
            That is, if this parameter is referencing another parameter and you
            call setExpression(), it change the channel reference expression
            into the specified expression.

            If the parameter does not already contain any keyframes, this method
            is roughly equivalent to setting a keyframe at frame 1, where the
            keyframe's expression and language are the ones specified.

            This method can be approximately implemented as follows:

          > def setExpression(self, expression, language=None, replace_expression=None)
          > if self.template().type() == hou.parmTemplateType.String:
          >     k = hou.StringKeyframe()
          > else:
          >     k = hou.Keyframe()
          > 
          > k.setExpression(expression, language)
          > 
          > if len(self.keyframes()):
          >     if replace_expression:
          >     k.setTime(self.effectiveKeyframeAtFrame(hou.frame()).time())
          >     else:
          >     k.setTime(hou.time())
          > else
          >     k.setTime(0.0)
          > 
          > self.setKeyframe(k)

            See also the expression, expressionLanguage, and setKeyframe
            methods, hou.OpNode.expressionLanguage, and
            hou.OpNode.setExpressions.


        """
    def expression(self) -> str:
        """

        expression(self) -> str

            Returns this parameter's expression.

            For example, a parameter might contain the Python expression frame()
            * 2. In this case hou.Parm.eval at frame 2 would return the value 4,
            while calling expression() would return the string frame() * 2.

            If the parameter does not contain an expression, this method will
            raise hou.OperationFailed. Also, if the parameter contains more than
            one keyframe then it could contain multiple different expressions,
            so it also raises hou.OperationFailed in that case.

            This method is roughly equivalent to...

          > parm.keyframes()[0].expression()

            See also the setExpression(), expressionLanguage(), keyframes(), and
            eval() methods.


        """
    def expressionLanguage(self) -> EnumValue:
        """

        expressionLanguage(self) -> hou.exprLanguage enum value

            Returns the parameter's expression's language.

            If the parameter does not contain an expression, this method will
            raise hou.OperationFailed. Also, if the parameter contains more than
            one keyframe then it could contain multiple different expressions,
            so it also raises hou.OperationFailed in that case.

            To change the expression language, use hou.Parm.setExpression and
            explicitly specify the language:
            parm.setExpression(parm.expression(), language).

            This method is roughly equivalent to...

          > parm.keyframes()[0].expressionLanguage()

            See also the expression(), setExpression(), keyframes(), and
            setExpressionLanguage() methods.


        """
    def rawValue(self) -> str:
        """

        rawValue(self) -> str

            Returns the parameter's raw text value without evaluation or
            expansion. If the parameter has an expression then the expression is
            returned otherwise the parameter's plain text value is returned.


        """
    def isShowingExpression(self) -> bool:
        """

        isShowingExpression(self) -> bool

            Return whether this parameter is shown as an expression or as the

            See also the showExpression() method.


        """
    def showExpression(self, value: bool) -> None: ...
    def setKeyframe(self, keyframe: BaseKeyframe) -> None:
        """

        setKeyframe(self, keyframe)

            Sets a keyframe on this parameter.

            Raises TypeError if keyframe is not of type hou.BaseKeyframe. Raises
            hou.PermissionError if this parameter is not writable.


        """
    def setKeyframes(self, keyframes: Sequence[BaseKeyframe]) -> None:
        """

        setKeyframes(self, keyframes)

            Sets multiple keyframe on this parameter. Calling this method is
            more efficient than calling hou.Parm.setKeyframe several times
            because it sends out only one update event to Houdini for the entire
            batch of keyframes that are set.

            keyframes must be a tuple or list of hou.BaseKeyframe objects.

            Raises hou.PermissionError if this parameter is not writable.


        """
    def keyframes(self) -> Tuple[BaseKeyframe, ...]:
        """

        keyframes(self) -> tuple of hou.BaseKeyframe

            Returns the keyframes on this parameter.


        """
    def keyframesInRange(self, start_frame: float, end_frame: float) -> Tuple[BaseKeyframe, ...]:
        """

        keyframesInRange(self, start_frame, end_frame) -> tuple of
        hou.BaseKeyframe

            Returns a tuple of keyframes on this parameter that fall in the
            range start_frame to end_frame, inclusive. If no keyframes are found
            an empty tuple is returned.


        """
    def keyframesBefore(self, frame: float) -> Tuple[BaseKeyframe, ...]:
        """

        keyframesBefore(self, frame) -> tuple of hou.BaseKeyframe

            Returns a tuple of keyframes on this parameter that occur at or
            before frame. If no keyframes are found an empty tuple is returned.


        """
    def keyframesAfter(self, frame: float) -> Tuple[BaseKeyframe, ...]: ...
    def evalAsFloat(self) -> float:
        """

        evalAsFloat(self) -> float

            Evaluates this parameter at the current frame and returns the result
            as a float.

            Raises TypeError if the value cannot be converted to a float.


        """
    def evalAsFloatAtFrame(self, frame: float) -> float:
        """

        evalAsFloatAtFrame(self, frame) -> float

            Evaluates this parameter at a certain frame and returns the result
            as a float.

            Raises TypeError if the value cannot be converted to a float.


        """
    def evalAsInt(self) -> int:
        """

        evalAsInt(self) -> int

            Evaluates this parameter at the current frame and returns the result
            as an integer.

            Raises TypeError if the value cannot be converted to an integer.


        """
    def evalAsIntAtFrame(self, frame: float) -> int:
        """

        evalAsIntAtFrame(self, frame) -> int

            Evaluates this parameter at a certain frame and returns the result
            as an integer.

            Raises TypeError if the value cannot be converted to an integer.


        """
    def evalAsString(self) -> str:
        """

        evalAsString(self) -> str

            Evaluates this parameter at the current frame and returns the result
            as a string.

            If you want the string contents of the parameter before variable
            expansion and expression evaluation then call
            hou.Parm.unexpandedString.

            Raises TypeError if the value cannot be converted to a string.


        """
    def evalAsStringAtFrame(self, frame: float) -> str:
        """

        evalAsStringAtFrame(self, frame) -> str

            Evaluates this parameter at a certain frame and returns the result
            as a string.

            If you want the string contents of the parameter before variable
            expansion and expression evaluation then call
            hou.Parm.unexpandedString.

            Raises TypeError if the value cannot be converted to a string.


        """
    def evalAsGeometry(self) -> Optional[Geometry]:
        """

        evalAsGeometry(self) -> hou.Geometry

            Evaluates this parameter at the current frame and returns the result
            as a geometry.

            Raises TypeError if the parameter is not a geometry.


        """
    def evalAsGeometryAtFrame(self, frame: float) -> Optional[Geometry]:
        """

        evalAsGeometryAtFrame(self, frame) -> hou.Geometry

            Evaluates this parameter at a certain frame and returns the result
            as a geometry.

            Raises TypeError if the parameter is not a geometry.


        """
    def evalAsImageLayer(self) -> Optional[ImageLayer]:
        """

        evalAsImageLayer(self) -> hou.ImageLayer

            Evaluates this parameter at the current frame and returns the result
            as a layer.

            Raises TypeError if the parameter is not a layer.


        """
    def evalAsImageLayerAtFrame(self, frame: float) -> Optional[ImageLayer]:
        """

        evalAsImageLayerAtFrame(self, frame) -> hou.ImageLayer

            Evaluates this parameter at a certain frame and returns the result
            as a layer.

            Raises TypeError if the parameter is not a layer.


        """
    def evalAsNanoVDB(self) -> Optional[NanoVDB]:
        """

        evalAsNanoVDB(self) -> hou.NanoVDB

            Evaluates this parameter at the current frame and returns the result
            as a VDB.

            Raises TypeError if the parameter is not a VDB.


        """
    def evalAsNanoVDBAtFrame(self, frame: float) -> Optional[NanoVDB]:
        """

        evalAsNanoVDBAtFrame(self, frame) -> hou.NanoVDB

            Evaluates this parameter at a certain frame and returns the result
            as a VDB.

            Raises TypeError if the parameter is not a VDB.


        """
    def evalAsJSONMap(self) -> dict[str, str]:
        """

        evalAsJSONMap(self) -> dict of str to str

            Evaluates this parameter at the current frame and returns the result
            as a JSON map structure (i.e. Python dictionary).

            Raises TypeError or hou.OperationFailed if the parameter is not a
            JSON map data parameter.


        """
    def evalAsJSONMapAtFrame(self, frame: float) -> dict[str, str]:
        """

        evalAsJSONMapAtFrame(self, frame) -> dict of str to str

            Evaluates this parameter at a certain frame and returns the result
            as a JSON map structure (i.e. Python dictionary).

            Raises TypeError or hou.OperationFailed if the parameter is not a
            JSON map data parameter.


        """
    def evalAsRamp(self) -> Ramp:
        """

        evalAsRamp(self) -> hou.Ramp

            Evaluates this parameter at the current frame and returns the result
            as a ramp.

            Raises TypeError if the parameter is not a ramp.


        """
    def evalAsRampAtFrame(self, frame: float) -> Ramp:
        """

        evalAsRampAtFrame(self, frame) -> hou.Ramp

            Evaluates this parameter at a certain frame and returns the result
            as a ramp.

            Raises TypeError if the parameter is not a ramp.


        """
    def evalAsNode(self) -> OpNode | None:
        """

        evalAsNode(self) -> hou.OpNode

            Evaluates this parameter at the current frame and returns the result
            as a hou.OpNode.

            If the parameter resolves to multiple node paths, None will be
            returned. See evalAsNodes for this.

            Raises TypeError if the value cannot be converted to a hou.OpNode.


        """
    def evalAsNodeAtFrame(self, frame: float) -> OpNode | None:
        """

        evalAsNodeAtFrame(self, frame) -> hou.OpNode

            Evaluates this parameter at a certain frame and returns the result
            as a hou.OpNode.

            If the parameter resolves to multiple node paths, None will be
            returned. See evalAsNodesAtFrame for this.

            Raises TypeError if the value cannot be converted to a hou.OpNode.


        """
    def evalAsNodes(self) -> Tuple[Node, ...]:
        """

        evalAsNodes(self) -> tuple of hou.OpNode

            Evaluates this parameter at the current frame and returns the result
            as a tuple of hou.OpNode.

            Raises TypeError if the value cannot be converted to a hou.OpNode.


        """
    def evalAsNodesAtFrame(self, frame: float) -> Tuple[Node, ...]:
        """

        evalAsNodesAtFrame(self, frame) -> tuple of hou.OpNode

            Evaluates this parameter at a certain frame and returns the result
            as a tuple of hou.OpNode.

            Raises TypeError if the value cannot be converted to a hou.OpNode.


        """
    def evalAsNodePath(self) -> str:
        """

        evalAsNodePath(self) -> str

            Evaluates this parameter at the current frame and returns the result
            as an absolute node path.

            If the parameter resolves to multiple node paths, an empty string
            will be returned. See evalAsNodePaths for this.


        """
    def evalAsNodePathAtFrame(self, frame: float) -> str:
        """

        evalAsNodePathAtFrame(self, frame) -> str

            Evaluates this parameter at a certain frame and returns the result
            as an absolute node path.

            If the parameter resolves to multiple node paths, an empty string
            will be returned. See evalAsNodePathsAtFrame for this.


        """
    def evalAsNodePaths(self) -> Tuple[str, ...]:
        """

        evalAsNodePaths(self) -> tuple of str

            Evaluates this parameter at the current frame and returns the result
            as a tuple of strings where each is an absolute node path.


        """
    def evalAsNodePathsAtFrame(self, frame: float) -> Tuple[str, ...]:
        """

        evalAsNodePathsAtFrame(self, frame) -> tuple of str

            Evaluates this parameter at a certain frame and returns the result
            as a tuple of strings where each is an absolute node path.


        """
    def unexpandedString(self) -> str:
        """

        unexpandedString(self) -> str

            Returns the contents of the parameter before dollar sign and back-
            tick expansion.

            Examples of unexpanded strings would be image$F.pic, $HIP/split.hda,
            or chs('../font1/text'). If you were to call eval() on them, Houdini
            would perform variable expansion and back-tick expression
            evaluation, so you would get back something like image1.pic instead
            of image$F.pic.

            Because only string parameters will attempt to do dollar sign and
            string expansion, this method will raise hou.OperationFailed if
            called from a non-string parameter.

            Suppose a string parameter contains keyframes. In this situation,
            Houdini will not attempt to do string expansion on the parameter's
            value, so calling this method will raise hou.OperationFailed.
            Instead of calling this method, you can call expression() to access
            the first Keyframe's expression. If there are multiple keyframes,
            you can call keyframes() to get a list of hou.StringKeyframe objects
            and call expression() on those objects to retrieve the expression.


        """
    def deleteKeyframeAtFrame(self, frame: float) -> None:
        """

        deleteKeyframeAtFrame(self, frame)

            Removes a keyframe from this parameter at the given frame.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.OperationFailed exception the
            parameter doesn't have a keyframe at the given frame.

            See also hou.Parm.deleteAllKeyframes.


        """
    def deleteAllKeyframes(self) -> None:
        """

        deleteAllKeyframes(self)

            Removes all keyframes from this parameter.

            This has no effect if there are no keyframes to delete. The value of
            the parameter after all keyframes are removed will be the one it
            evaluated to at the current frame.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            See also hou.Parm.deleteKeyframeAtFrame and
            hou.ParmTuple.deleteAllKeyframes.


        """
    def getReferencedParm(self) -> Parm:
        """

        getReferencedParm(self) -> hou.Parm

            Returns the referenced parameter. If no parameter is referenced,
            returns this parameter.


        """
    def parmsReferencingThis(self) -> Tuple[Parm, ...]:
        """

        parmsReferencingThis(self) -> tuple of hou.Parm

            Return a tuple of all the parameters in the scene that have channel
            references to this parameter.


        """
    def isLocked(self) -> bool:
        """

        isLocked(self) -> bool

            Returns whether this parameter is locked (uneditable).


        """
    def lock(self, on: bool) -> None:
        """

        lock(self, on)

            Locks (lock(True)) or unlocks (lock(False)) this parameter (this is,
            makes the value uneditable).

            Raises hou.PermissionError if this parameter is part of a locked
            digital asset.


        """
    def isAutoscoped(self) -> bool:
        """

        isAutoscoped(self) -> bool

            Returns whether this parameter's autoscope property is on.


        """
    def setAutoscope(self, on: bool) -> None:
        """

        setAutoscope(self, on)

            Changes the autoscope property of the parameter. If this property is
            on, this parameter is automatically scoped when the object is
            selected.


        """
    def isScoped(self) -> bool:
        """

        isScoped(self) -> bool

            Returns whether this parameter's channel is scoped. If it is scoped,
            then it is loaded in the animation editor.


        """
    def setScope(self, on: bool) -> None:
        """

        setScope(self, on)

            Changes the scope property of this parameter's channel, which
            affects whether it is loaded in the animation editor.


        """
    def isAutoSelected(self) -> bool:
        """

        isAutoSelected(self) -> bool

            Returns whether this parameter's autoselect property is on.


        """
    def setAutoSelect(self, on: bool) -> None:
        """

        setAutoSelect(self, on)

            Changes the autoselect property of the parameter. If this property
            is on, this parameter defines the default selection state when it is
            displayed in the animation editor.


        """
    def isSelected(self) -> bool:
        """

        isSelected(self) -> bool

            Returns whether this parameter's channel is selected. If it is
            selected, then it is selected in the animation editor.


        """
    def setSelect(self, on: bool) -> None:
        """

        setSelect(self, on)

            Changes the select property of this parameter's channel, which
            affects whether it is selected in the animation editor.


        """
    def alias(self) -> str:
        """

        alias(self) -> str

            Returns the parameter's channel alias name. Returns an empty string
            if no such name exists.


        """
    def setAlias(self, alias_name: str) -> None:
        """

        setAlias(self, alias_name)

            Gives the parameter another name by which it can be referenced in
            channels. You can pass in an empty string to remove an existing
            alias name.


        """
    def isSpare(self) -> bool:
        """

        isSpare(self) -> bool

            Returns whether this parameter is a spare (user-defined) parameter.


        """
    def isTimeDependent(self) -> bool:
        """

        isTimeDependent(self) -> bool

            Returns whether this parameter is time dependent, that is, its value
            changes depending on the point on the timeline at which it's
            evaluated. For example the parameter has an expression containing
            the $F (current frame number) variable.


        """
    def isMultiParmInstance(self) -> bool:
        """

        isMultiParmInstance(self) -> bool

            Return whether this parameter is an instance of a multi parm. For
            example, the pt0x, pt1x, pt2x, etc. parameters in an add SOP are
            instances of a multiparm.


        """
    def isMultiParmParent(self) -> bool:
        """

        isMultiParmParent(self) -> bool

            Return whether this parameter is a parent multi parm, ie: the number
            of instances parameter.


        """
    def parentMultiParm(self) -> Optional[Parm]:
        """

        parentMultiParm(self) -> hou.Parm

            Return the parent multi-parameter if this parameter is a multi-
            parameter instance and None otherwise.


        """
    def multiParmInstanceIndices(self) -> Tuple[int, ...]:
        """

        multiParmInstanceIndices(self) -> tuple of int

            If this parameter is a multi-parameter instance, then return a tuple
            of indices of where the parameter appears in the multi-parameter
            block and any nested blocks. Indices for outer multi-parameter
            blocks are listed first.

            For example if this parameter appears as the fourth instance in the
            multi-parameter block then (3,) is returned.

            As another example if this parameter appears as the third instance
            in the multi-parameter block and the block itself appears as the
            first instance of an outer multi-parameter block then (0, 2) is
            returned.


        """
    def multiParmInstancesPerItem(self) -> int:
        """

        multiParmInstancesPerItem(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
    def multiParmInstancesCount(self) -> int:
        """

        multiParmInstancesCount(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
    def multiParmStartOffset(self) -> int:
        """

        multiParmStartOffset(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return the starting index used when building multi
            parameter names. The default value is 1.

            Returns 0 if this parameter is not for a multiparm.


        """
    def multiParmInstances(self) -> Tuple[Parm, ...]:
        """

        multiParmInstances(self) -> tuple of hou.Parm

            If this parameter corresponds to the number of instances for a
            multiparm, return all the parameters corresponding to all instances
            of this multiparm.

            Returns an empty tuple if this parameter is not for a multiparm.


        """
    def insertMultiParmInstance(self, inst_index: int) -> None:
        """

        insertMultiParmInstance(self, index)

            Insert a new multi parm instance before the given index. To append a
            new multi parm instance, set the index to be the current number of
            instances. The current number can be queried by calling evalAsInt on
            the this parameter.


        """
    def removeMultiParmInstance(self, inst_index: int) -> None:
        """

        removeMultiParmInstance(self, index)

            Removes the multi parm instance at the given index.


        """
    def moveMultiParmInstances(self, moves: Sequence[int]) -> None:
        """

        moveMultiParmInstances(self, moves)

            Perform a sequence of move operations on Multi Parm Instances. The
            'moves' argument must be an array of integers containing an even
            number of entries. Entries at the odd-numbered array positions
            represent a 'from' multi parm index. Entries at the even-numbered
            array positions represent the associated 'to' multi parm index.

          * To move the instance at index 2 up, 'moves' should be [2,3].

          * To move the instance at index 2 down, 'moves' should be [2,1].

          * To move the instance at index 0 to position 2, 'moves' should be
            [0,2].

            You can move multiple parm instances in one operation:

          * To move the first 2 instances at index 0 and 1 up to index 1,
            'moves' should be [0,1, 1,2].

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.Error exception with descriptive text
            if the 'moves' argument doesn't have an even number of entries or if
            an index is invalid.


        """
    def moveUpMultiParmInstance(self, inst_index: int) -> None:
        """

        moveUpMultiParmInstance(self, index)

            Perform a move up operation on a Multi Parm Instance at the given
            index.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.Error exception if the index is
            invalid or is the last index or the only index.


        """
    def moveDownMultiParmInstance(self, inst_index: int) -> None:
        """

        moveDownMultiParmInstance(self, index)

            Perform a move down operation on a Multi Parm Instance at the given
            index.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.Error exception if the index is
            invalid or is the first index or the only index.


        """
    def containingFolders(self) -> Tuple[str, ...]:
        """

        containingFolders(self) -> tuple of str

            Returns a tuple of strings corresponding to the names of the folders
            containing this parameter.

            For example, if this parameter is in the Shading folder and the
            Shading folder is inside the Render folder, this method will return
            (Render, Shading). Note that by folder name, we mean the label used
            in the parameter dialog, not the internal parameter name.

            Returns an empty tuple if this parameter is not inside a folder.

            Note that calling this method on many parameters may be slow. For a
            faster alternative, see hou.OpNode.parmsInFolder.

            See also the containingFolderSetParmTuples method, and
            hou.OpNode.parmTuplesInFolder.


        """
    def containingFolderIndices(self) -> Tuple[int, ...]:
        """

        containingFolderIndices(self) -> tuple of int

            Return a tuple of indices corresponding to the folders containing
            this parameter. Each index refers to a folder in the corresponding
            folder set parameter.

            This method can be implemented as follows:

          > def containingFolderIndices(self):
          > return tuple(
          >     list(folder_set_parm_tuple.parmTemplate().folderNames()).index(
          >     folder_name)
          >     for folder_set_parm_tuple, folder_name in zip(
          >     parm.containingFolderSetParmTuples(), parm.containingFolders()))

            This example makes a parameter visible in the parameter pane by
            opening all the folders containing it.

          > def makeParmVisible(parm):
          > for folder_set_parm_tuple, folder_index in zip(
          >     parm.containingFolderSetParmTuples(),
          >     parm.containingFolderIndices()):
          >     folder_set_parm_tuple[0].set(folder_index)

        """
    def containingFolderSetParmTuples(self) -> Tuple[ParmTuple, ...]:
        """

        containingFolderSetParmTuples(self) -> tuple of hou.ParmTuple

            Return a tuple of ParmTuples corresponding to the folders containing
            this parameter.

            For example, if this parameter is in the Shading folder and the
            Shading folder is inside the Render folder, this method will return
            a tuple containing the Render parm tuple and the Shading parm tuple.
            Any parm tuples returned will be folder sets.

            If this parameter is not inside a folder, an empty tuple is
            returned.

            See also the containingFolders() method, and
            hou.OpNode.parmsInFolder and hou.OpNode.parmTuplesInFolder.


        """
    def asCode(self, brief: bool = False, save_values: bool = True, save_keyframes: bool = True, save_keys_in_frames: bool = False, save_flag_values: bool = True, save_aliases: bool = True, function_name: Optional[str] = None) -> str:
        '''

        asCode(self, brief=False, save_values=True, save_keyframes=True,
        save_keys_in_frames=False, save_flag_values=True, save_aliases=True,
        function_name=None) -> str

            Returns a script of Python statements that can be executed to set
            the parameter tuple\'s values, flags and other properties. To run the
            script, use either Python\'s exec or execfile functions.


            brief
                When <brief> is True, the output script omits commands for
                setting values and flags that are set to the factory defaults.
                The script also omits keyframe commands that set unused values,
                slopes and accelerations. The value of <brief> must be either
                True or False. save_values: When <save_values> is True, asCode
                outputs commands for setting the parameter tuple\'s values. The
                value of <save_values> must be either True or False.

            save_keyframes
                When <save_keyframes> is True, asCode outputs commands for
                creating the parameter tuple\'s keyframes (if any). The value of
                <save_keyframes> must be either True or False.

            save_keys_in_frames
                When <save_keys_in_frames> is True, asCode outputs commands for
                setting channel and key times in samples (frames) instead of
                seconds. This parameter has no effect if <save_keyframes> is set
                to False. The value of <save_keys_in_frames> must be either True
                or False.

            save_flag_values
                When <save_flag_values> is True, asCode outputs commands for
                setting the parameter tuple\'s flag values. The value of
                <save_flag_values> must be either True or False.

            save_aliases
                When <save_aliases> is True, asCode outputs commands for setting
                the parameter tuple\'s channel aliases. The value of
                <save_aliases> must be either True or False.

            function_name
                If <function_name> is specified, then the output script is
                wrapped in a Python function definition with the given name.
                <function_name> must be a non-zero length string consisting of
                only alphanumeric and underscore characters. Any invalid
                characters are internally converted to underscores.

            The wrapper function takes in a single argument which must be a
            reference to an existing node parameter tuple. For symmetry, the
            function also returns the parameter tuple reference.

            Here is an example of saving the output to a file and then loading
            it back into Houdini:

          > # Get a reference to the target parameter tuple.
          > pt = hou.parmTuple(\\"/obj/geo1/t\\")
          > 
          > # Execute asCode and write the output script to file.
          > script = pt.asCode()
          > f = open(\\"set_parm_tuple_properties.py\\", \\"w\\")
          > f.write(script)
          > f.close()
          > 
          > # Execute the script.  This will set the values, flag values
          > # and other properties on /obj/geo1\'s t parameter tuple.  It will
          > # also store a reference to the t parameter tuple into a variable
          > # named \'hou_parm_tuple\'.
          > execfile(\\"set_parm_tuple_properties.py\\")

            Here is an example of saving the output into a function and then
            calling it in Houdini:

          > # Get a reference to the target parameter tuple.
          > node = hou.parmTuple(\\"/obj/geo1/t\\")
          > 
          > # Execute asCode and write the function definition to file.
          > func = p.asCode(function_name=\\"setParmTupleProperties\\")
          > f = open(\\"parmtuplelib.py\\", \\"w\\")
          > f.write(func)
          > f.close()
          > 
          > # Call the function definition to set the properties on another
          > # parameter tuple.
          > import parmtuplelib
          > hou_parm_tuple = parmtuplelib.setParmTupleProperties(node.parm(\\"t\\"))

        '''
    def createClip(self, parent_node: Node, name: str, create_new: bool, apply_immediately: bool, current_value_only: bool = False, create_locked: bool = False, set_value_to_default: bool = False) -> ChopNode:
        """

        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only, create_locked, set_value_to_default) -> hou.ChopNode

            Creates a Channel CHOP representing this parameter. The Channel CHOP
            is created with the given name as a child of the given parent node.
            The parent_node is typically created via
            hou.OpNode.findOrCreateMotionEffectsNetwork.

            create_new: Always create a new Channel CHOP. If set to False, then
            if a Channel CHOP already exists with the same name, it will be re-
            used. If the parameter already exists on the Channel CHOP, the older
            parameter will be removed first.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation

            See also hou.OpNode.findOrCreateMotionEffectsNetwork.


        """
    def appendClip(self, chop_node: Node, apply_immediately: bool, current_value_only: bool = False, create_locked: bool = False, set_value_to_default: bool = False) -> None:
        """

        appendClip(self, chop_node, apply_immediately, current_value_only,
        create_locked, set_value_to_default)

            Appends this parameter to the specified Channel CHOP.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation


        """
    def overrideTrack(self) -> Optional[Track]:
        """

        overrideTrack(self) -> hou.Track or None

            Returns the CHOP track overriding this parameter, if any.


        """
    def isOverrideTrackActive(self) -> bool:
        """

        isOverrideTrackActive(self) -> bool

            Returns True if the CHOP track overriding this parameter is active.


        """
    def copyToParmClipboard(self) -> None:
        """

        copyToParmClipboard(self)

            Copies this to the parameter clipboard. See also
            hou.parmClipboardContents.


        """
    def isDisabled(self) -> bool:
        """

        isDisabled(self) -> bool

            Returns the disable state of the parameter, ignoring the lock state.
            This can be used to read the result of a disable-when conditional.

            It is recommended that hou.OpNode.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
    def disable(self, on: bool) -> None:
        """

        disable(self, on)

            Sets the UI disable state of this parameter in its node. This is not
            the same as locking a parameter, as the underlying value can still
            be modified. It's closer to what a disable-when conditional does,
            when a parameter is disabled automatically by it.


        """
    def isHidden(self) -> bool:
        """

        isHidden(self) -> bool

            Returns the hidden state of the parameter. This can be used to read
            the result of a hide-when conditional.

            It is recommended that hou.OpNode.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
    def hide(self, on: bool) -> None:
        """

        hide(self, on)

            Sets the UI hidden state of this parameter in its node. Calling this
            method has the same effect as changing the Invisible checkbox on the
            Edit Parameter Interface dialog, or hiding the parameter with a
            hide-when conditional.

            However, changing the UI state with this function is transient and
            does not affect node parameter templates, which means that the new
            state is not saved to .hip file and can be restored when refreshing
            the node to its spare parameter templates.

            To permanently change the UI state of a parameter on a node, please
            use hou.ParmTemplate.hide instead:

          > parms = hou.node('/obj/node').parmTemplateGroup()
          > p = parms.find('lookatpath')
          > p.hide(True)
          > parms.replace('lookatpath', p)
          > hou.node('/obj/node').setParmTemplateGroup(parms)

        """
    def isVisible(self) -> bool:
        """

        isVisible(self) -> bool

            Returns whether or not this parameter would be visible in the
            parameter dialog for this node. It checks both the parameter's
            template, and the hidden state of the parameter. This is equivalent
            to the following code (but runs faster because it avoids creating
            the hou.ParmTemplate):

          > >>> p = hou.parm('/obj/geo1/tx')
          > >>> not p.isHidden() and not p.parmTemplate().isHidden()
          > True

        """
    def isConstrained(self) -> bool:
        """

        isConstrained(self) -> bool

            Returns True if the Parm's parent node is an OBJ that is cooked and
            has constraints.


        """
    def isPending(self) -> bool:
        """

        isPending(self) -> bool

            Returns whether this keyed parameter has been changed, but hasn't
            been explicitly keyed.


        """
    def keyframeExtrapolation(self, before: bool) -> EnumValue: ...
    def setKeyframeExtrapolation(self, before: bool, e: EnumValue) -> None:
        """

        setKeyframeExtrapolation(self, before, extrapol)

            Sets a extrapolation on this parameter for time before the first
            keyframe or after the last keyframe. Extrapolation defines how a
            parm value is evaluated outside the keyframe range.


            before
                If set to true, the extrapolation for evaluations before the
                first keyframe will be set. If set to false, the extrapolation
                for evaluations after the last keyframe will be set.

            extrapol
                A hou.parmExtrapolate enumeration value.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.OperationFailed exception the
            parameter doesn't have a valid animation channel.


        """
    def keyframesRefit(self, refit: bool, refit_tol: float, refit_preserve_extrema: bool, refit_bezier: bool, resample: bool, resample_rate: float, resample_tol: float, range_: bool, range_start: float, range_end: bool, bake_chop: EnumValue, refit_smooth: bool) -> None:
        """

        keyframesRefit(self, refit, refit_tol, refit_preserve_extrema,
        refit_bezier, resample, resample_rate, resample_tol, range, range_start,
        range_end, bake_chop)

            Performs a refitting operation with resampling and range controls.


            refit
                If set to true, a cubic refitting will be performed with the
                supplied refit options. If set to false, the refitting is
                skipped and only the resampling or range operation will be
                performed.

            refit_tol
                Refit Tolerance in absolute value.

            refit_preserve_extrema
                Preserves the keys that are local minima or maxima.

            refit_bezier
                If True, the new keyframes will be set to use bezier() segments.
                If False, the new keyframes will be set to use cubic() segments.

            resample
                If True, a resampling operation is performed prior to the
                refitting. If False, the channel is used as is.

            resample_rate
                Resample rate in frames. If set to 1.0, a keyframe will be added
                at every frame.

            resample_tol
                Resample Tolerance in frames. If set to 1.0, the resampling
                won't happen if a frame exists within one frame.

            range
                If True, the range_start and range_end arguments are used. It's
                useful when baking cycles when using cycle/cycle offset or
                oscillate channel extrapolation. If False, the channel range
                will be used based on the first and last keyframes.

            range_start
                Start frame of the range.

            range_end
                End frame of the range.

            bake_chop
                A hou.parmBakeChop enumeration value.

            refit_smooth
                If True, the new keyframes will have auto slopes applied to
                them. If False, the new keyframes use slopes chosen by the
                refitting algorithm.


        """
    def uiBackgroundColor(self) -> Color:
        """

        uiBackgroundColor(self) -> hou.Color

            Returns the background color used to indicate the state of this parm
            in parm dialogs. Raises hou.NotAvailable if there is no UI.


        """
    def eval(self) -> int|float|str:
        """

        eval(self) -> int, float, or str

            Evaluates this parameter at the current frame and returns the
            result. See also the evalAtFrame and evalAtTime methods.


        """
    def evalAtFrame(self, frame: float) -> int|float|str:
        """

        evalAtFrame(self, frame) -> int, float, or str

            Evaluate this parameter at a given frame and return the result as an
            integer, float or string.

            See also evalAtTime.


        """
    def evalAtTime(self, frame: float) -> int|float|str:
        """

        evalAtTime(self, time) -> int, float, or str

            Evaluate this parameter at a given time and return the result as an
            integer, float or string.

            See also evalAtFrame.


        """

    # Missing methods added by stubgen
    def appendMultiParmInstancesFromData(self, data: Sequence[dict[str, Any]]) -> None: ...
    def asData(self, value: bool=True, evaluate_value=False, locked: bool=True, brief: bool=True, multiparm_instances: bool=True, metadata: bool=False, verbose: bool=False, default_values: bool=...) -> dict[str, Any]: ...
    def clipData(self, start:float|None=None, end:float|None=None, binary:bool=True, use_blosc_compression: bool=True, sample_rate:float=0) -> bytes: ...
    def insertMultiParmInstancesFromData(self, data: Sequence[dict[str, Any]], index: int=0) -> None: ...
    def insertTemplatesFromData(self, data: dict[str, Any], operation: str=..., rename_conflicts:bool=True) -> None: ...
    def multiParmInstancesAsData(self, start_index: int=0, end_index: int=-1, value: bool = True, evaluate_value: bool = False, links: bool = True, locked: bool = True, brief: bool = True, metadata: bool = False, verbose: bool = False) -> Sequence[dict[str, Any]]: ...
    def rampPointsAsData(self, evaluate: bool = True, metadata: bool = False, verbose: bool = False) -> Sequence[dict[str, Any]]: ...
    def saveClip(self, file_name:str, start:float|None=None, end:float|None=None, sample_rate: float=0) -> None: ...
    def set(self, value: int | float | str | dict[str, str] | Parm | Ramp | Geometry, language: EnumValue | None = None, follow_parm_reference: bool = True) -> None: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...
    def setMultiParmInstancesFromData(self, data: Sequence[dict[str, Any]]) -> None: ...
    def setRampPointsFromData(self, data: Sequence[dict[str, Any]]) -> None: ...
    def setValueFromData(self, data: int | str | float | dict[str, Any] | Sequence[int] | Sequence[float] | Sequence[str]) -> None: ...
    def templateAsData(self, children: bool = True) -> dict[str, Any]: ...
    def templateChildrenAsData(self, parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def valueAsData(self, evaluate: bool = True, verbose: bool = True) -> int | str | float | dict[str, Any] | list[int] | list[float] | list[str]: ...

class ParameterEditor(PathBasedPaneTab):
    """

    hou.ParameterEditor

    Represents a Parameter Editor panetab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def scrollPosition(self) -> Vector2:
        """

        scrollPosition(self) -> hou.Vector2

            Return the Parameter Editor scroll bars position as percentages.


        """
    def setScrollPosition(self, position: Vector2) -> None:
        """

        setScrollPosition(self,pos)

            Set Parameter Editor scroll bars position as hou.Vector2
            percentages.


        """
    def setFilterEnabled(self, on: bool, keyboard_lock: bool = False) -> None:
        """

        setFilterEnabled(self,on,keyboard_lock)

            Enable Parameter Editor filtering. If keyboard_lock is True and on
            is True, the filter field will be selected allowing you to use the
            keyboard right away. keyboard_lock is False by default.
            hou.parmFilterCriteria.


        """
    def filterEnabled(self) -> bool:
        """

        filterEnabled(self) -> bool

            Return True if Parameter Editor filtering is enabled.


        """
    def setFilterPattern(self, filter: str) -> None:
        """

        setFilterPattern(self,pattern)

            Set the Parameter Editor filter pattern. The filter pattern is
            applied on a hou.parmFilterCriteria string from parameters that
            match the hou.parmFilterMode. The pattern matching can use exact
            name matching or find the pattern within the string. The filter
            pattern can be a list of pattern separated by commas and can also
            contain wildcard '*' character.


        """
    def filterPattern(self) -> str:
        """

        filterPattern(self) -> str

            Return the Parameter Editor filter pattern.


        """
    def setFilterExactMatch(self, on: bool) -> None:
        """

        setFilterExactMatch(self,on)

            Set Parameter Editor filtering to use exact pattern matching.


        """
    def filterExactMatch(self) -> bool:
        """

        filterExactMatch(self) -> bool

            Return True if Parameter Editor filtering uses exact pattern
            matching.


        """
    def setFilterMode(self, mode: EnumValue) -> None:
        """

        setFilterMode(self,mode)

            Set the Parameter Editor filter mode. The hou.parmFilterMode defines
            on which parameters to apply the filter pattern.


        """
    def filterMode(self) -> EnumValue:
        """

        filterMode(self) -> hou.parmFilterMode

            Return the Parameter Editor hou.parmFilterMode.


        """
    def setFilterCriteria(self, criteria: EnumValue) -> None:
        """

        setFilterCriteria(self,criteria)

            Set the Parameter Editor filter criteria. The hou.parmFilterCriteria
            defines how the filter pattern is applied to parameters.


        """
    def filterCriteria(self) -> EnumValue:
        """

        filterCriteria(self) -> hou.parmFilterCriteria

            Return the Parameter Editor hou.parmFilterCriteria.


        """
    def isShowingParmDialog(self) -> bool:
        """

        isShowingParmDialog(self) -> bool

            Return True if the Parameter Editor is currently displaying a
            parameter dialog (as opposed to, for example, a Python Panel).


        """
    def setShowParmDialog(self, show: bool) -> None:
        """

        setShowParmDialog(self,show)

            Set the Parameter Editor to display a parameter dialog if show is
            True, and switch to a Python Panel if show is False.

            Raise hou.OperationFailed if the Parameter Editor's current node has
            no corresponding Python Panel interface and show is set to False.


        """
    def setMultiParmTab(self, parm: str, index: int) -> None:
        """

        setMultiParmTab(self,parm, tab_index)

            Switch a Multi Parameter Tab to a given tab using a parameter name.


        """
    def multiParmTab(self, parm: str) -> int:
        """

        multiParmTab(self,parm) -> int

            Returns the currently visible tab index using a parameter name.


        """
    def visibleParms(self) -> Tuple[ParmTuple, ...]:
        """

        visibleParms(self) -> tuple of hou.ParmTuple

            Returns the currently visible parameters.


        """

class ParmTuple:
    '''

    hou.ParmTuple

    A tuple of one or more node parameters. Each parameter tuple has a
    unique name within its node.

    The ParmTuple class behaves like a Python sequence, so you can index
    into it using square brackets, iterate over it, call len on it, etc. The
    elements inside the parameter tuple are hou.Parm objects.

    A parameter tuple\'s name may only contain letters, numbers, and
    underscores. For example, objects contain a parameter tuple named \\"t\\"
    that contains three integer parameters. The names of the parameters
    inside the tuple are determined from the parameter tuple\'s name and its
    naming scheme. For example, the \\"t\\" parameter uses the XYZW naming
    scheme, so the three parameters inside it are named \\"tx\\", \\"ty\\", and
    \\"tz\\". Note that if the parameter tuple only contains one parameter, the
    tuple and the parameter inside it may have the same name.

    In addition to a name, a parameter tuple also has a label that is
    displayed to the user in the parameter dialog. For example, the \\"t\\"
    parameter\'s label is \\"Translate\\". The label may contain spaces and
    punctuation characters.

    Each parameter in a tuple stores a value. Different instances of parm
    tuples in different nodes will store their own set of parameter values.
    The value in a parameter may be animated, in which case the parameter
    evaluates to a different result depending on the current time on the
    playbar. See hou.Keyframe for more information about animated
    parameters.

    Each hou.NodeType has a set of parameter tuple descriptions associated
    with it, and each instance of a hou.OpNode has a corresponding set of
    parameter tuple instances. The parameter tuples store specific values
    that are saved with the node. The descriptions of the parameter tuples,
    however, are represented by a hou.ParmTemplate. A parameter template
    describes the type, default values, ranges, etc. of a parameter tuple.

    See also hou.parmTuple_ and hou.OpNode.parmTuple.


    '''
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def node(self) -> OpNode:
        """

        node(self) -> hou.OpNode

            Return the node containing this parameter tuple.


        """
    def parmTemplate(self) -> ParmTemplate:
        """

        parmTemplate(self) -> hou.ParmTemplate

            Return this parameter tuple's template.

            Note that a folder parameter will have a hou.FolderSetParmTemplate
            template and a multiparm parameter will have a
            hou.FolderParmTemplate template.


        """
    def name(self) -> str:
        '''

        name(self) -> str

            Return the name of this parameter tuple. Note that the parameter
            tuple\'s name and its naming scheme determine the names of the
            parameters inside it.

          > >>> node = hou.node(\\"/obj\\").createNode(\\"geo\\")
          > >>> node.parmTuple(\\"t\\").parmTemplate().namingScheme()
          > parmNamingScheme.XYZW
          > >>> [parm.name() for parm in node.parmTuple(\\"t\\")]
          > [\'tx\', \'ty\', \'tz\']
          > 
          > >>> parm_tuple = node.parent().createNode(\\"cam\\").parmTuple(\\"dcolor\\")
          > >>> parm_tuple.parmTemplate().namingScheme()
          > parmNamingScheme.RGBA
          > >>> [parm.name() for parm in parm_tuple]
          > [\'dcolorr\', \'dcolorg\', \'dcolorb\']

        '''
    def description(self) -> str:
        """

        description(self) -> str

            Return this parameter tuple's label that is displayed in the
            parameter dialog.


        """
    def setPending(self, values: Sequence[float|str]) -> None:
        """

        setPending(self, values)

            Sets the value of a parameter in the tuple at the current frame and
            marks it as pending if the parameter is keyed.


            values
                A sequence of floats or strings, corresponding to the components
                of this parameter tuple.

            For example, the parameter tuple for translation contains Parm
            objects for translation along each of the axes, tx, ty and tz. If
            set is called with following tuple of floats, (2.5, 4.0, 5.5), then
            the parameter tx with be set to 2.5, ty will be set to 4.0 and tz
            will be set to 5.5.

            Raises hou.InvalidSize if values has a different length than this
            parameter tuple. Raises hou.PermissionError if any of the parameters
            in this parameter tuple are not writable.


        """
    def overwriteDefaults(self) -> None: ...
    def revertToDefaults(self) -> None:
        """

        revertToDefaults(self)

            Changes the value back to the default(s). See also the
            revertToAndRestoreFactoryDefaults() method.


        """
    def revertToAndRestorePermanentDefaults(self) -> None:
        """

        revertToAndRestorePermanentDefaults(self)

            Changes the value back to the defaults that ship with Houdini, and
            restore those defaults.

            See also the revertToDefaults() method.


        """
    def isAtDefault(self, compare_temporary_defaults: bool = True, compare_expressions: bool = True) -> bool:
        """

        isAtDefault(self, compare_temporary_defaults=True,
        compare_expressions=False) -> bool

            Returns whether the parameter tuple is currently at its defaults.

            compare_temporary_defaults: When <compare_temporary_defaults> is
            True, isDefault also checks

            compare_expressions: When <compare_Expressions> is True, isDefault
            compares the actual

            See also the revertToDefaults() and
            revertToAndRestorePermanentDefaults()methods.


        """
    def isAtRampDefault(self) -> bool:
        """

        isAtRampDefault(self) -> bool

            Returns whether the ramp parameter is currently at its default.

            This tests all of the multiparm parameters associated with the ramp
            by comparing to the special ramp default spare paramater data. Ramps
            with no default spare data will never be at default.


        """
    def evalAsFloats(self) -> Tuple[float, ...]:
        """

        evalAsFloats(self) -> tuple of float

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple of floats.

            Raises TypeError if a value cannot be converted to a float.


        """
    def evalAsFloatsAtFrame(self, frame: float) -> Tuple[float, ...]:
        """

        evalAsFloatsAtFrame(self, frame) -> tuple of float

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple of floats.

            Raises TypeError if a value cannot be converted to a float.


        """
    def evalAsInts(self) -> Tuple[int, ...]:
        """

        evalAsInts(self) -> tuple of int

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple of integers.

            Raises TypeError if a value cannot be converted to an integer.


        """
    def evalAsIntsAtFrame(self, frame: float) -> Tuple[int, ...]:
        """

        evalAsIntsAtFrame(self, frame) -> tuple of int

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple of integers.

            Raises TypeError if a value cannot be converted to an integer.


        """
    def evalAsStrings(self) -> Tuple[str, ...]:
        """

        evalAsStrings(self) -> tuple of str

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple of strings.

            Raises TypeError if a value cannot be converted to a string.


        """
    def evalAsStringsAtFrame(self, frame: float) -> Tuple[str, ...]:
        """

        evalAsStringsAtFrame(self, frame) -> tuple of str

            Evaluates the parameter tuple at a frame and returns the result as a
            tuple of strings.

            Raises TypeError if a value cannot be converted to a string.


        """
    def evalAsRamps(self) -> Tuple[Ramp, ...]:
        """

        evalAsRamps(self) -> hou.Ramp

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing a hou.Ramp object.

            Raises TypeError if this is not a ramp parameter.


        """
    def evalAsRampsAtFrame(self, frame: float) -> Tuple[Ramp, ...]:
        """

        evalAsRampsAtFrame(self, frame) -> hou.Ramp

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple containing a hou.Ramp object.

            Raises TypeError if this is not a ramp parameter.


        """
    def evalAsGeometries(self) -> Tuple[Geometry, ...]:
        """

        evalAsGeometries(self) -> tuple of hou.Geometry

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing a hou.Geometry object.

            Raises TypeError if a value cannot be converted to a hou.Geometry.


        """
    def evalAsGeometriesAtFrame(self, frame: float) -> Tuple[Geometry, ...]:
        """

        evalAsGeometriesAtFrame(self, frame) -> tuple of hou.Geometry

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple containing a hou.Geometry object.

            Raises TypeError if a value cannot be converted to a hou.Geometry.


        """
    def evalAsImageLayers(self) -> Tuple[ImageLayer, ...]:
        """

        evalAsImageLayers(self) -> tuple of hou.ImageLayer

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing a hou.ImageLayer object.

            Raises TypeError if a value cannot be converted to a hou.ImageLayer.


        """
    def evalAsImageLayersAtFrame(self, frame: float) -> Tuple[ImageLayer, ...]:
        """

        evalAsImageLayersAtFrame(self, frame) -> tuple of hou.ImageLayer

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple containing a hou.ImageLayer object.

            Raises TypeError if a value cannot be converted to a hou.ImageLayer.


        """
    def evalAsNanoVDBs(self) -> Tuple[NanoVDB, ...]:
        """

        evalAsNanoVDBs(self) -> tuple of hou.NanoVDB

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing a hou.NanoVDB object.

            Raises TypeError if a value cannot be converted to a hou.NanoVDB.


        """
    def evalAsNanoVDBsAtFrame(self, frame: float) -> Tuple[NanoVDB, ...]:
        """

        evalAsNanoVDBsAtFrame(self, frame) -> tuple of hou.NanoVDB

            Evaluates this parameter tuple at a certain frame and returns the
            result as a tuple containing a hou.NanoVDB object.

            Raises TypeError if a value cannot be converted to a hou.NanoVDB.


        """
    def evalAsJSONMaps(self) -> Tuple[dict[str, str], ...]:
        """

        evalAsJSONMaps(self) -> tuple of dict of str to str

            Evaluates this parameter tuple at the current frame and returns the
            result as a tuple containing JSON map structures (i.e. Python
            dictionary).

            Raises TypeError or hou.OperationFailed if the parameter tuple is
            not a JSON map data parameter tuple.


        """
    def evalAsJSONMapsAtFrame(self, frame: float) -> Tuple[dict[str, str], ...]:
        """

        evalAsJSONMapsAtFrame(self, frame) -> tuple of dict of str to str

            Evaluates this parameter tuple at a certain frame and returns the
            result as a a tuple containing JSON map structures (i.e. Python
            dictionary).

            Raises TypeError or hou.OperationFailed if the parameter tuple is
            not a JSON map data parameter tuple.


        """
    def lock(self, bool_values: bool|Sequence[bool]) -> None:
        """

        lock(self, bool_values)

            Lock or unlock all the parameters in this tuple. Houdini displays
            locked parameters as disabled and does not let you change their
            values.


            bool_values
                Either a single True or False value to be applied to all
                components of this parameter or a sequence of them where each
                value corresponds to a single component. Where an element of
                bool_values is True, that component will be locked (uneditable),
                and where an element is False, the corresponding component will
                be unlocked (editable).

            For example, the parameter tuple for translation contains Parm
            objects for translation along each of the axes, tx, ty and tz. If
            lock is called with the following tuple of boolean values, (True,
            True, False), then the parameter tx and ty will be locked and made
            non-editable, while tz will be unlocked and made editable.

            Raises hou.InvalidSize if bool_values has a different length than
            this parameter tuple. Raises hou.PermissionError if any of the
            parameters in this parameter tuple are not writable.


        """
    def setAutoscope(self, bool_values: Sequence[bool]) -> None:
        """

        setAutoscope(self, bool_values)

            Changes the autoscope property of components of this parameter
            tuple.


            bool_values
                A sequence of True or False values, where each value corresponds
                to a component of this parameter. Where an element of
                bool_values is True, that component will be autoscope.

            For example, the parameter tuple for translation contains Parm
            objects for translation along each of the axes, tx, ty and tz. If
            setAutoscope is called with the following tuple of boolean values,
            (True, True, False), then the parameter tx and ty will be
            automatically scoped, while tz will not.

            Raises hou.InvalidSize if values has a different length than this
            parameter tuple. Raises hou.PermissionError if any of the parameters
            in this parameter tuple are not writable.


        """
    def isSpare(self) -> bool:
        """

        isSpare(self) -> bool

            Returns whether the parameter is a spare (user-defined) parameter.


        """
    def isTimeDependent(self) -> bool:
        """

        isTimeDependent(self) -> bool

            Returns whether any of the parameters in the tuple are time
            dependent, that is, a parameter's value changes depending on the
            point on the timeline at which it's evaluated. For example the
            parameter has an expression containing the $F (current frame number)
            variable.


        """
    def isMultiParmInstance(self) -> bool:
        """

        isMultiParmInstance(self) -> bool

            Return whether this parameter is an instance of a multi parm. For
            example, the pt0, pt1, pt2, etc. parameter tuples in an add SOP are
            instances of a multiparm.


        """
    def isMultiParmParent(self) -> bool:
        """

        isMultiParmParent(self) -> bool

            Return whether this parameter is a parent multi parm, the number of
            instances parameter or returns None otherwise


        """
    def parentMultiParm(self) -> Optional[Parm]:
        """

        parentMultiParm(self) -> hou.Parm

            Return the parent multi-parameter if this parameter is a multi-
            parameter instance and None otherwise.


        """
    def multiParmInstanceIndices(self) -> Tuple[int, ...]:
        """

        multiParmInstanceIndices(self) -> tuple of int

            If this parameter is a multi-parameter instance, then return a tuple
            of indices of where the parameter appears in the multi-parameter
            block and any nested blocks. Indices for outer multi-parameter
            blocks are listed first.

            For example if this parameter appears as the fourth instance in the
            multi-parameter block then (3,) is returned.

            As another example if this parameter appears as the third instance
            in the multi-parameter block and the block itself appears as the
            first instance of an outer multi-parameter block then (0, 2) is
            returned.


        """
    def multiParmInstancesPerItem(self) -> int:
        """

        multiParmInstancesPerItem(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
    def multiParmInstancesCount(self) -> int:
        """

        multiParmInstancesCount(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return number of parameters per instance.

            Returns 0 if this parameter is not for a multiparm.


        """
    def multiParmStartOffset(self) -> int:
        """

        multiParmStartOffset(self) -> int

            If this parameter corresponds to the number of instances for a
            multiparm, return the starting index used when building multi
            parameter names. The default value is 1.

            Returns 0 if this parameter is not for a multiparm.


        """
    def multiParmInstances(self) -> Tuple[ParmTuple, ...]:
        """

        multiParmInstances(self) -> tuple of hou.ParmTuple

            If this parameter corresponds to the number of instances for a
            multiparm, return all the parameter tuples corresponding to all
            instances of this multiparm.

            Returns an empty tuple if this parameter is not for a multiparm.


        """
    def containingFolders(self) -> Tuple[str, ...]: ...
    def containingFolderIndices(self) -> Tuple[int, ...]: ...
    def containingFolderSetParmTuples(self) -> Tuple[ParmTuple, ...]: ...
    def setKeyframe(self, keyframes: Sequence[BaseKeyframe]) -> None:
        """

        setKeyframe(self, keyframe_vector)

            Sets a keyframe on this parameter.


            keyframe_vector
                A sequence of keyframes for each component of the parameter
                tuple.

            Raises TypeError if keyframe is not of type hou.BaseKeyframe. Raises
            hou.PermissionError if this parameter is not writable. Raises
            hou.InvalidSize if keyframe_vector has a different length than this
            parameter tuple.


        """
    def deleteKeyframeAtFrame(self, frame: float) -> None:
        """

        deleteKeyframeAtFrame(self, frame)

            Removes a keyframe from this parameter tuple at the given frame.

            This function will raise a hou.ObjectWasDeleted exception if it is
            invoked on a parameter that does not exist in Houdini.

            This function will raise a hou.PermissionError exception if writing
            to the specified parameter is impossible.

            This function will raise a hou.OperationFailed exception the
            parameter doesn't have a keyframe at the given frame.

            See also hou.ParmTuple.deleteAllKeyframes.


        """
    def deleteAllKeyframes(self) -> None:
        """

        deleteAllKeyframes(self)

            Remove all the keyframes from this parameter tuple.

            This method be approximately implemented as follows:

          > def deleteAllKeyframes(self):
          > for parm in self:
          >     parm.deleteAllKeyframes()

            See also hou.Parm.deleteAllKeyframes.


        """
    def __getitem__(self, index: int) -> Parm:
        '''

        __getitem__(self, index) -> hou.Parm

            Return the Parm object for the specified component of this parameter
            tuple. Negative indices will index from the end.

            This method makes instances of this class appear like a tuple, and
            lets you iterate over the parms in a ParmTuple.

            Raises IndexError if the index is not valid.

          > >>> parm_tuple = hou.node(\\"/obj\\").createNode(\\"geo\\").parmTuple(\\"t\\")
          > >>> for parm in parm_tuple:
          > ...     print parm.name(),
          > tx ty tz
          > >>> tuple(parm_tuple)
          > (<hou.Parm tx in /obj/geo1>, <hou.Parm ty in /obj/geo1>, <hou.Parm tz in /obj/geo1>)

        '''
    def __len__(self) -> int:
        """

        __len__(self) -> int

            Return the number of hou.Parms in this parameter tuple.


        """
    def __bool__(self) -> bool: ...
    def createClip(self, parent_node: Node, name: str, create_new: bool, apply_immediately: bool, current_value_only: bool = False, create_locked: bool = False, set_value_to_default: bool = False) -> ChopNode:
        """

        createClip(self, parent_node, name, create_new, apply_immediately,
        current_value_only, create_locked, set_value_to_default) -> hou.ChopNode

            Creates a Channel CHOP representing this parameter. The Channel CHOP
            is created with the given name as a child of the given parent node.
            The parent_node is typically created via
            hou.OpNode.findOrCreateMotionEffectsNetwork.

            create_new: Always create a new Channel CHOP. If set to False, then
            if a Channel CHOP already exists with the same name, it will be re-
            used. If the parameter already exists on the Channel CHOP, the older
            parameter will be removed first.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation

            See also hou.OpNode.findOrCreateMotionEffectsNetwork.


        """
    def appendClip(self, chop_node: Node, apply_immediately: bool, current_value_only: bool = False, create_locked: bool = False, set_value_to_default: bool = False) -> None:
        """

        appendClip(self, chop_node, apply_immediately, current_value_only,
        create_locked, set_value_to_default)

            Appends this parameter to the specified Channel CHOP.

            apply_immediately: If set to True, then the export flag on the
            Channel CHOP will be set.

            current_value_only: If set to True, then only the current value of
            the parameter will be stored.

            create_locked: If set to True, then the parameters are locked on
            creation.

            set_value_to_default: If set to True, then the parameters are
            reverted to their default values on creation


        """
    def copyToParmClipboard(self) -> None:
        """

        copyToParmClipboard(self)

            Copies this to the parameter clipboard. See also
            hou.parmClipboardContents.


        """
    def asCode(self, brief: bool = False, save_values: bool = True, save_keyframes: bool = True, save_keys_in_frames: bool = False, save_flag_values: bool = True, save_aliases: bool = True, function_name: Optional[str] = None) -> str: ...
    def help(self) -> str: ...
    def helpUrl(self) -> str: ...
    def isDisabled(self) -> bool:
        """

        isDisabled(self) -> bool

            Returns the disable state of the parameter tuple, ignoring the lock
            state. This can be used to read the result of a disable-when
            conditional.

            It is recommended that hou.OpNode.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
    def disable(self, on: bool) -> None:
        """

        disable(self, on)

            Sets the UI disable state of this parameter tuple in its node. This
            is not the same as locking a parameter, as the underlying value can
            still be modified. It's closer to what a disable-when conditional
            does, when a parameter is disabled automatically by it.


        """
    def isHidden(self) -> bool:
        """

        isHidden(self) -> bool

            Returns the hidden state of the parameter tuple. This can be used to
            read the result of a hide-when conditional.

            It is recommended that hou.OpNode.updateParmStates is called before
            executing this method either in non-graphical Houdini or when the
            owner node has not yet been loaded into the Parameter Pane.


        """
    def hide(self, on: bool) -> None:
        """

        hide(self, on)

            Sets the UI hidden state of this parameter tuple in its node.
            Calling this method is equivalent to changing the Invisible checkbox
            on the Edit Parameter Interface dialog, or hiding the parameter with
            a hide-when conditional.

            To hide a folder, use hou.OpNode.setParmTemplateGroup. This method
            cannot be used to hide a folder because a parm tuple corresponds to
            a set of folders, not an individual folder.

            To change the visibility of all new instances of the node type
            defined by a digital asset, use
            hou.HDADefinition.setParmTemplateGroup as in the following example:

          > def showParmTupleInDefinition(parm_tuple, visible):
          >     '''parm_tuple is a hou.ParmTuple on an instance of the digital asset.'''
          >     definition = parm_tuple.node().type().definition()
          >     parm_template_group = definition.parmTemplateGroup()
          >     parm_template = parm_template_group.find(parm_tuple.name())
          >     parm_template.hide(not visible)
          >     parm_template_group.replace(parm_tuple.name(), parm_template)
          >     definition.setParmTemplateGroup(parm_template_group)

        """
    def isConstrained(self) -> bool: ...
    def isShowingExpression(self) -> bool: ...
    def showExpression(self, value: bool) -> None: ...
    def eval(self) -> Tuple[int,...]|Tuple[float,...]|Tuple[str,...]|Ramp:
        """

        eval(self) -> tuple of int, float, str, or hou.Ramp

            Evalute this parameter tuple at the current frame and returns the
            result as a tuple of integers, floats or strings, or a hou.Ramp
            object, depending on the type of the parameter.

            See also the evalAtFrame and evalAtTime methods.


        """
    def evalAtFrame(self, frame: float) -> Tuple[int,...]|Tuple[float,...]|Tuple[str,...]|Ramp:
        """

        evalAtFrame(self, frame) -> tuple of int, float, str, or hou.Ramp

            Evalute the parameter tuple at a given frame and return the result
            as a tuple of integers, floats, strings, or a Ramp object, depending
            on the type of the parameter.

            See also evalAtTime.


        """
    def evalAtTime(self, frame: float) -> Tuple[int,...]|Tuple[float,...]|Tuple[str,...]|Ramp:
        """

        evalAtTime(self, time) -> tuple of int, float, str, or hou.Ramp

            Evalute the parameter tuple at a given time and return the result as
            a tuple of integers, floats, strings, or a Ramp object, depending on
            the type of the parameter.

            See also evalAtFrame.


        """

    # Missing methods added by stubgen
    def __iter__(self) -> Iterator[Parm]: ...
    def asData(self, value: bool=True, evaluate_value=False, locked: bool=True, brief: bool=True, multiparm_instances: bool=True, metadata: bool=False, verbose: bool=False, default_values: bool=...) -> dict[str, Any]: ...
    def clipData(self, start:float|None=None, end:float|None=None, binary:bool=True, use_blosc_compression: bool=True, sample_rate:float=0) -> bytes: ...
    def insertMultiParmInstancesFromData(self, data: Sequence[dict[str, Any]], index: int=0) -> None: ...
    def insertTemplatesFromData(self, data: dict[str, Any], operation: str = ..., rename_conflicts: bool = True) -> None: ...
    def multiParmInstancesAsData(self, start_index: int=0, end_index: int=-1, value: bool = True, evaluate_value: bool = False, links: bool = True, locked: bool = True, brief: bool = True, metadata: bool = False, verbose: bool = False) -> Sequence[dict[str, Any]]: ...
    def rampPointsAsData(self, evaluate: bool = True, metadata: bool = False, verbose: bool = False) -> Sequence[dict[str, Any]]: ...
    def saveClip(self, file_name:str, start:float|None=None, end:float|None=None, sample_rate: float=0) -> None: ...
    def set(self, value: Sequence[int] | Sequence[float] | Sequence[str] | Sequence[Parm] | ParmTuple, language: EnumValue | None = None, follow_parm_reference: bool = True) -> None: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...
    def setMultiParmInstancesFromData(self, data: Sequence[dict[str, Any]]) -> None: ...
    def setRampPointsFromData(self, data: Sequence[dict[str, Any]]) -> None: ...
    def setValueFromData(self, data: int | str | float | dict[str, Any] | Sequence[int] | Sequence[float] | Sequence[str]) -> None: ...
    def templateAsData(self, children: bool = True, parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def templateChildrenAsData(self, parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def valueAsData(self, evaluate: bool = True, verbose: bool = True) -> int | str | float | dict[str, Any] | list[int] | list[float] | list[str]: ...

class perfMon:
    """

    hou.perfMon

    Module containing performance monitor related functions.


    NOTE
        HOM performance monitor submodules, classes and methods report time
        and memory statistics in milliseconds and bytes respectively.

    RELATED

      * hou.PerfMonProfile

      * hou.PerfMonEvent

      * hou.PerfMonRecordOptions

      * Performance monitor pane


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def startProfile(title: str, options: Optional[PerfMonRecordOptions] = None) -> PerfMonProfile:
        """

        startProfile(title, options=None) -> hou.PerfMonProfile

            Create a new profile and start it so that it can record events. When
            the profile is stopped, it will generate statistics for the events
            that it recorded.


            options
                A hou.PerfMonRecordOptions object that specifies the types of
                Houdini events and statistics to record. If None is passed in or
                if the options argument is not specified, then the profile will
                record all events and statistics.


        """
    @staticmethod
    def loadProfile(file_path: str) -> PerfMonProfile:
        """

        loadProfile(file_path) -> hou.PerfMonProfile

            Load a profile from disk and return the loaded profile.

            Raises hou.OperationFailed if file_path points to a file that does
            not exist or is not a valid Houdini performance monitor profile
            file.


        """
    @staticmethod
    def saveProfile(profile: PerfMonProfile, file_path: str) -> None:
        """

        saveProfile(profile, file_path)

            Save the profile to disk.

            Raises hou.OperationFailed if the profile is still active or if the
            file could not be written to disk (i.e. permission problems).


        """
    @staticmethod
    def activeProfile() -> Optional[PerfMonProfile]:
        """

        activeProfile() -> hou.PerfMonProfile or None

            Return the profile currently visible in the performance monitor
            pane, or


        """
    @staticmethod
    def startTimedEvent(description: str, auto_nest_events: bool = True) -> PerfMonEvent:
        """

        startTimedEvent(description, auto_nest_events=True) -> hou.PerfMonEvent

            This method is deprecated in favor of startEvent.


        """
    @staticmethod
    def startEvent(description: str, auto_nest_events: bool = True) -> PerfMonEvent:
        """

        startEvent(description, auto_nest_events=True) -> hou.PerfMonEvent

            Create a generic event and start it. When the event is stopped, it
            will be logged by the performance monitor and added to any profiles
            that are recording script or memory statistics.

            Use this function to time and measure memory growth in generic
            scripts, functions or code blocks.

            Return the new event.


            description
                The description of the event that you are starting. For example,
                this can be a function name or a script name or a description of
                a code block.

            auto_nest_events
                If set to True, the event will automatically 'nest' other events
                that are started and stopped while this event is running. When
                the event is stopped, it will decrement the times and memory of
                its nested events from its total time and memory. That way, the
                event's total time and memory will reflect the work performed in
                the event itself and not in any of its nested events.

            Raises hou.OperationFailed if description is an empty string.


        """
    @staticmethod
    def startTimedCookEvent(description: str, node: Node) -> PerfMonEvent:
        """

        startTimedCookEvent(description, node) -> hou.PerfMonEvent

            This method is deprecated in favor of startCookEvent.


        """
    @staticmethod
    def startCookEvent(description: str, node: Node) -> PerfMonEvent:
        """

        startCookEvent(description, node) -> hou.PerfMonEvent

            Create an event that is related to node cooking and start it. When
            the event is stopped, it will be logged by the performance monitor
            and added to any profiles that are recording cook or memory
            statistics.

            Use this function to time code blocks and measure memory growth in
            the Code section of Python operators.

            Return the cook event.


            description
                The description of the event that you are timing. For example,
                this can be a function name or a description of a code block.

            node
                The node that the timed event applies to. This must be a
                hou.OpNode object. When calling startCookEvent() from within the
                Code section of a Python operator, set node to the current node
                (i.e. hou.pwd()).

            Raises hou.OperationFailed if description is an empty string or if
            node does not exist.


        """
    @staticmethod
    def startPaneEvent(panetype: str, operation: str) -> PerfMonEvent:
        """

        startPaneEvent(panetype, operation) -> hou.PerfMonEvent

            Create an event that is related to the operation of a scriped pane
            and start it. When the event is stopped, it will be logged by the
            performance monitor and added to any profiles that are recording
            cook or memory statistics.

            Use this function to time code blocks and measure memory growth in
            the code for python panels.

            Return the cook event.


            panetype
                A description of the python panel running this code.

            operation
                The specific operation being timed by this event.

            Raises hou.OperationFailed if either panetype or operation are empty
            strings.


        """
    @staticmethod
    def isRecording() -> bool:
        """

        isRecording() -> bool

            Return True if the performance monitor is recording Houdini events.


        """

class PerfMonEvent:
    """

    hou.PerfMonEvent

    Represents an event that is recorded by the performance monitor and used
    to generate time and memory growth statistics for profiles.

    Note that all methods in this class may raise an hou.OperationFailed
    exception if the event was not actually recorded in the Performance
    Monitor. This can happen if hou.perfMon.startEvent or
    hou.perfMon.startCookEvent was called when the Performance Monitor was
    not recording.


    NOTE
        HOM performance monitor submodules, classes and methods report time
        and memory statistics in milliseconds and bytes respectively.

    NOTE
        The stopTime(), memory() and time() methods have been removed.
        Memory and time values are now returned by the stop() method.

    RELATED

      * hou.perfMon

      * hou.PerfMonProfile

      * hou.PerfMonRecordOptions

      * Performance monitor pane


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def id(self) -> int:
        """

        id(self) -> int

            Return the event's unique identifier which is used internally by the
            performance monitor.

            This method is deprecated.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Return the event name.

            This method is deprecated.


        """
    def object(self) -> str:
        """

        object(self) -> str

            Return the object that the event applies to. Return None if the
            event is not associated with an object.


        """
    def isAutoNestEnabled(self) -> bool:
        """

        isAutoNestEnabled(self) -> bool

            Return True if the event will automatically 'nest' other events that
            are started and stopped while this event is running. When the event
            is stopped, it will decrement the times and memory of its nested
            events from its total time and memory. That way, the event's total
            time and memory will reflect the work performed in the event itself
            and not in any of its nested events.


        """
    def stop(self) -> Tuple[float, ...]:
        """

        stop(self)

            Stop the event timer and return a 2-tuple, (<time>, <memory>),
            containing the event's elapsed time and memory growth.

            The elapsed time is the number of milliseconds that the event was
            timing for. The memory growth is the increase in memory usage by
            Houdini (in bytes) from when the event started and when it stopped.

            If the event was not recording memory, then the returned memory
            value is 0.0. Likewise, if the event was not recording time, then
            the returned time value is 0.0.

            Raises hou.OperationFailed if the event is already stopped.


        """
    def isTiming(self) -> bool:
        """

        isTiming(self) -> bool

            This method is deprecated in favor of isRunning.


        """
    def isRunning(self) -> bool:
        """

        isRunning(self) -> bool

            Return true if the event is running, that is, if the event has been
            started but not stopped.


        """
    def startTime(self) -> float:
        """

        startTime(self) -> float

            Return the start time of the event in milliseconds since the epoch
            date.

            Raises hou.OperationFailed if the event does not contain any time
            data. This can happen if the event was started when the Performance
            Monitor was not recording any time statistics.


        """
    def __enter__(self) -> PerfMonEvent: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class PerfMonProfile:
    """

    hou.PerfMonProfile

    Represents a performance monitor profile.


    NOTE
        HOM performance monitor submodules, classes and methods report time
        and memory statistics in milliseconds and bytes respectively.

    RELATED

      * hou.perfMon

      * hou.PerfMonEvent

      * hou.PerfMonRecordOptions

      * Performance monitor pane


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def id(self) -> int:
        """

        id(self) -> int

            Return the profile's unique identifier which is used internally by
            the performance monitor.


        """
    def title(self) -> str:
        """

        title(self) -> str

            Return the profile title.


        """
    def isActive(self) -> bool:
        """

        isActive(self) -> bool

            Return True if the profile is either recording events or is paused.


        """
    def isPaused(self) -> bool:
        """

        isPaused(self) -> bool

            Return True if the profile is paused from recording.


        """
    def isRecordingCookStats(self) -> bool:
        """

        isRecordingCookStats(self) -> bool

            Return True if the profile is recording cook events and statistics.


        """
    def isRecordingPDGCookStats(self) -> bool:
        """

        isRecordingPDGCookStats(self) -> bool

            Return True if the profile is recording PDG node cook events and
            statistics.


        """
    def isRecordingSolveStats(self) -> bool:
        """

        isRecordingSolveStats(self) -> bool

            Return True if the profile is recording simulation solver events and
            statistics.


        """
    def isRecordingDrawStats(self) -> bool:
        """

        isRecordingDrawStats(self) -> bool

            Return True if the profile is recording draw events and statistics.


        """
    def isRecordingGPUDrawStats(self) -> bool:
        """

        isRecordingGPUDrawStats(self) -> bool

            Return True if the profile is recording GPU draw events and
            statistics.


        """
    def isRecordingViewportStats(self) -> bool:
        """

        isRecordingViewportStats(self) -> bool

            Return True if the profile is recording viewport events and
            statistics.


        """
    def isRecordingScriptStats(self) -> bool:
        """

        isRecordingScriptStats(self) -> bool

            Return True if the profile is recording script events and
            statistics.


        """
    def isRecordingRenderStats(self) -> bool:
        """

        isRecordingRenderStats(self) -> bool

            Return True if the profile is recording statistics related to
            rendering.


        """
    def isRecordingThreadStats(self) -> bool:
        """

        isRecordingThreadStats(self) -> bool

            Return True if the profile is recording thread statistics.


        """
    def isRecordingFrameStats(self) -> bool:
        """

        isRecordingFrameStats(self) -> bool

            Return True if the profile is recording frame events and statistics.


        """
    def isRecordingMemoryStats(self) -> bool: ...
    def isRecordingErrors(self) -> bool:
        """

        isRecordingErrors(self) -> bool

            Return True if the profile is recording errors.


        """
    def stop(self) -> None:
        """

        stop(self)

            Stop the profile from recording and generate statistics for the
            events that it has already recorded.

            Raises hou.OperationFailed if the profile is not active.


        """
    def cancel(self) -> None:
        """

        cancel(self)

            Stop the profile from recording timed events and remove it from the
            performance monitor.

            Raises hou.OperationFailed if the profile is not active, that is,
            the profile is neither recording nor paused.


        """
    def pause(self) -> None:
        """

        pause(self)

            Pause the profile from recording events and statistics.

            Raises hou.OperationFailed if the profile is stopped or already
            paused.


        """
    def resume(self) -> None:
        """

        resume(self)

            Unpause the profile so that it can record events and statistics.

            Raises hou.OperationFailed if the profile is stopped or is already
            recording (i.e. not paused).


        """
    def exportAsCSV(self, file_path: str) -> None:
        """

        exportAsCSV(self, file_path)

            Export the profile statistics to disk using a comma-separated (CSV)
            format. The exported .csv file can be loaded into a spreadsheet
            application such as Microsoft Excel and used to generate graphs.

            Raises hou.OperationFailed if the profile is still active or if the
            .csv file could not be written to disk (i.e. permission problems).


        """

class PerfMonRecordOptions:
    """

    hou.PerfMonRecordOptions

    Represents the set of options used by the Performance Monitor and
    specifies the type of statistics to be recorded in a profile.

    RELATED

      * hou.perfMon

      * hou.PerfMonProfile

      * Performance monitor pane


    """
    thisown: Incomplete
    def __init__(self, cook_stats: bool = True, pdg_cook_stats: bool = True, solve_stats: bool = True, draw_stats: bool = True, gpu_draw_stats: bool = False, viewport_stats: bool = True, script_stats: bool = True, render_stats: bool = True, thread_stats: bool = False, frame_stats: bool = True, memory_stats: bool = False, errors: bool = True, pane_stats: bool = True) -> None:
        """

        hou.PerfMonRecordOptions

        Represents the set of options used by the Performance Monitor and
        specifies the type of statistics to be recorded in a profile.

        RELATED

          * hou.perfMon

          * hou.PerfMonProfile

          * Performance monitor pane


        """
    __swig_destroy__: Incomplete
    def recordCookStats(self) -> bool:
        """

        recordCookStats(self) -> bool

            Return True if cook statistics should be recorded.


        """
    def recordPDGCookStats(self) -> bool:
        """

        recordPDGCookStats(self) -> bool

            Return True if PDG node and work item cook statistics should be
            recorded.


        """
    def recordSolveStats(self) -> bool:
        """

        recordSolveStats(self) -> bool

            Return True if DOP solver statistics should be recorded.


        """
    def recordDrawStats(self) -> bool:
        """

        recordDrawStats(self) -> bool

            Return True if node draw statistics should be recorded.


        """
    def recordGPUDrawStats(self) -> bool:
        """

        recordGPUDrawStats(self) -> bool

            Return True if node GPU draw statistics should be recorded.


        """
    def recordViewportStats(self) -> bool:
        """

        recordViewportStats(self) -> bool

            Return True if viewport statistics should be recorded.


        """
    def recordPaneStats(self) -> bool:
        """

        recordPaneStats(self) -> bool

            Return True if non-viewport pane statistics should be recorded.


        """
    def recordScriptStats(self) -> bool:
        """

        recordScriptStats(self) -> bool

            Return True if hscript and Python script statistics should be
            recorded.


        """
    def recordRenderStats(self) -> bool:
        """

        recordRenderStats(self) -> bool

            Return True if Mantra render statistics should be recorded.


        """
    def recordThreadStats(self) -> bool:
        """

        recordThreadStats(self) -> bool

            Return True if thread statistics should be recorded.


        """
    def recordFrameStats(self) -> bool:
        """

        recordFrameStats(self) -> bool

            Return True if frame statistics should be recorded.


        """
    def recordMemoryStats(self) -> bool:
        """

        recordMemoryStats(self) -> bool

            Return True if memory statistics should be recorded.


        """
    def recordErrors(self) -> bool:
        """

        recordErrors(self) -> bool

            Return True if warnings and errors should be recorded.


        """
    def setRecordCookStats(self, record: bool) -> None:
        """

        setRecordCookStats(self, record)

            Turn the recording of cook statistics on or off.


        """
    def setRecordPDGCookStats(self, record: bool) -> None:
        """

        setRecordPDGCookStats(self, record)

            Turn the recording of PDG node cook statistics on or off.


        """
    def setRecordSolveStats(self, record: bool) -> None:
        """

        setRecordSolveStats(self, record)

            Turn the recording of DOP solver statistics on or off.


        """
    def setRecordDrawStats(self, record: bool) -> None:
        """

        setRecordDrawStats(self, record)

            Turn the recording of node draw statistics on or off.


        """
    def setRecordGPUDrawStats(self, record: bool) -> None:
        """

        setRecordGPUDrawStats(self, record)

            Turn the recording of node GPU draw statistics on or off.


        """
    def setRecordViewportStats(self, record: bool) -> None:
        """

        setRecordViewportStats(self, record)

            Turn the recording of viewport statistics on or off.


        """
    def setRecordPaneStats(self, record: bool) -> None:
        """

        setRecordPaneStats(self, record)

            Turn the recording of non-viewport pane statistics on or off.


        """
    def setRecordScriptStats(self, record: bool) -> None:
        """

        setRecordScriptStats(self, record)

            Turn the recording of hscript and Python statistics on or off.


        """
    def setRecordRenderStats(self, record: bool) -> None:
        """

        setRecordRenderStats(self, record)

            Turn the recording of Mantra render statistics on or off.


        """
    def setRecordThreadStats(self, record: bool) -> None:
        """

        setRecordThreadStats(self, record)

            Turn the recording of thread statistics on or off.


        """
    def setRecordFrameStats(self, record: bool) -> None:
        """

        setRecordFrameStats(self, record)

            Turn the recording of frame statistics on or off.


        """
    def setRecordMemoryStats(self, record: bool) -> None:
        """

        setRecordMemoryStats(self, record)

            Turn the recording of memory statistics on or off.


        """
    def setRecordErrors(self, record: bool) -> None:
        """

        setRecordErrors(self, record)

            Turn the recording of warnings and errors on or off.


        """

class PerformanceMonitor(PaneTab):
    """

    hou.PerformanceMonitor

    Represents a Performance Monitor panetab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isLiveUpdatesEnabled(self) -> bool:
        """

        isLiveUpdatesEnabled(self) -> bool

            Return whether live updates is enabled.


        """
    def enableLiveUpdates(self, on: bool) -> None:
        """

        enableLiveUpdates(self, on)

            Enable or disable live updates for recordings. If live updates is
            enabled, then statistics are displayed in the statistics viewer and
            are periodically updated while the performance monitor is recording.


        """
    def isRecording(self) -> bool:
        """

        isRecording(self) -> bool

            Return whether the performance monitor is recording.


        """
    def startRecording(self) -> None:
        """

        startRecording(self)

            Start recording in the performance monitor.

            Raises hou.OperationFailed if the performance monitor is already
            recording.


        """
    def stopRecording(self) -> None:
        """

        stopRecording(self)

            Stop recording in the performance monitor.

            Raises hou.OperationFailed if the performance monitor is already
            stopped.


        """
    def isSamplingCookStats(self) -> bool:
        """

        isSamplingCookStats(self) -> bool

            Return whether the sampling of cook statistics is turned on.


        """
    def isSamplingPDGCookStats(self) -> bool:
        """

        isSamplingPDGCookStats(self) -> bool

            Return whether the sampling of PDG node cook statistics is turned
            on.


        """
    def isSamplingErrors(self) -> bool:
        """

        isSamplingErrors(self) -> bool

            Return whether the sampling of warnings and errors is turned on.


        """
    def isSamplingFrameStats(self) -> bool:
        """

        isSamplingFrameStats(self) -> bool

            Return whether the sampling of frame statistics is turned on.


        """
    def isSamplingMemoryStats(self) -> bool: ...
    def isSamplingObjectDrawStats(self) -> bool:
        """

        isSamplingObjectDrawStats(self) -> bool

            Return whether the sampling of object drawing statistics is turned
            on.


        """
    def isSamplingObjectGPUDrawStats(self) -> bool:
        """

        isSamplingObjectGPUDrawStats(self) -> bool

            Return whether the sampling of object GPU drawing statistics is
            turned on.


        """
    def isSamplingScriptStats(self) -> bool:
        """

        isSamplingScriptStats(self) -> bool

            Return whether the sampling of script statistics is turned on.


        """
    def isSamplingSolveStats(self) -> bool:
        """

        isSamplingSolveStats(self) -> bool

            Return whether the sampling of DOP solve statistics is turned on.


        """
    def isSamplingThreadStats(self) -> bool:
        """

        isSamplingThreadStats(self) -> bool

            Return whether the sampling of thread statistics is turned on.


        """
    def isSamplingViewportStats(self) -> bool:
        """

        isSamplingViewportStats(self) -> bool

            Return whether the sampling of viewport statistics is turned on.


        """
    def sampleCookStats(self, on: bool) -> None:
        """

        sampleCookStats(self, on)

            Turn sampling of cook statistics on or off.


        """
    def samplePDGCookStats(self, on: bool) -> None:
        """

        samplePDGCookStats(self, on)

            Turn sampling of PDG node cook statistics on or off.


        """
    def sampleErrors(self, on: bool) -> None:
        """

        sampleErrors(self, on)

            Turn sampling of warnings and errors on or off.


        """
    def sampleFrameStats(self, on: bool) -> None:
        """

        sampleFrameStats(self, on)

            Turn sampling of frame statistics on or off.


        """
    def sampleMemoryStats(self, on: bool) -> None: ...
    def sampleObjectDrawStats(self, on: bool) -> None:
        """

        sampleObjectDrawStats(self, on)

            Turn sampling of object drawing statistics on or off.


        """
    def sampleObjectGPUDrawStats(self, on: bool) -> None:
        """

        sampleObjectGPUDrawStats(self, on)

            Turn sampling of object GPU drawing statistics on or off.


        """
    def sampleScriptStats(self, on: bool) -> None:
        """

        sampleScriptStats(self, on)

            Turn sampling of script statistics on or off.


        """
    def sampleSolveStats(self, on: bool) -> None:
        """

        sampleSolveStats(self, on)

            Turn sampling of DOP solve statistics on or off.


        """
    def sampleThreadStats(self, on: bool) -> None:
        """

        sampleThreadStats(self, on)

            Turn sampling of thread statistics on or off. Note that turning on
            thread sampling can add overhead to the processing times (i.e. cook
            times, solve times, etc.) in the scene.


        """
    def sampleViewportStats(self, on: bool) -> None:
        """

        sampleViewportStats(self, on)

            Turn sampling of object-drawing statistics on or off.


        """
    def showProfile(self, profile: PerfMonProfile) -> None:
        """

        showProfile(self, profile)

            View the given profile in the performance monitor.


        """
    def objectView(self) -> EnumValue:
        """

        objectView(self) -> hou.perfMonObjectView enum value

            Return the structure type that is used to view objects in the
            statistics viewer.


        """
    def setObjectView(self, structure: EnumValue) -> None:
        """

        setObjectView(self, view)

            Set the structure type to use when viewing objects in the statistics
            viewer.


        """
    def timeFormat(self) -> EnumValue:
        """

        timeFormat(self) -> hou.perfMonTimeFormat enum value

            Return the format that is used to view times in the statistics
            viewer.


        """
    def setTimeFormat(self, format: EnumValue) -> None:
        """

        setTimeFormat(self, format)

            Set the format to use when viewing times in the statistics viewer.


        """
    def timeUnit(self) -> EnumValue:
        """

        timeUnit(self) -> hou.perfMonTimeUnit enum value

            Return the unit that is used to view times in the statistics viewer.


        """
    def setTimeUnit(self, unit: EnumValue) -> None:
        """

        setTimeUnit(self, unit)

            Set the unit to use when viewing times in the statistics viewer.


        """

class playbar:
    """

    hou.playbar

    The animation playbar module.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def isPlaying() -> bool:
        """

        isPlaying(self) -> bool

            Return True if the playbar is playing. Return False otherwise.


        """
    @staticmethod
    def play() -> None:
        """

        play(self)

            Play in the forward direction.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def stop() -> None:
        """

        stop(self)

            Stop playing.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def reverse() -> None:
        """

        reverse(self)

            Play in the reverse direction.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def jumpToNextKeyframe() -> None: ...
    @staticmethod
    def jumpToPreviousKeyframe() -> None: ...
    @staticmethod
    def playMode() -> EnumValue:
        """

        playMode(self) -> hou.playMode

            Return the playbar's play mode.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def setPlayMode(mode: EnumValue) -> None:
        """

        setPlayMode(self, mode)

            Set the play mode to one of the following: hou.playMode.Loop - Loop
            to the start of the range when the playback slider reaches the end
            of the range. hou.playMode.Once - Stop playback when the slider
            reaches the end of the range. hou.playMode.Zigzag - Play in the
            forward direction until reaching the end of the playback range, then
            play in the reverse direction.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def frameIncrement() -> float:
        """

        frameIncrement(self) -> float

            Return the frame increment step size.


        """
    @staticmethod
    def setFrameIncrement(increment: float) -> None:
        """

        setFrameIncrement(self, increment)

            Set the frame increment step size. This value is ignored when
            playing with realtime playback turned on.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def playbackRange() -> Vector2:
        """

        playbackRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end frame of the playback
            range.


        """
    @staticmethod
    def setPlaybackRange(start: float, end: float) -> None:
        """

        setPlaybackRange(self, start, end)

            Set the playback range.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def isRangeRestricted() -> bool:
        """

        isRangeRestricted(self) -> bool

            Return true if playback is restricted to within the playbar's start
            frame and end frame.


        """
    @staticmethod
    def setRestrictRange(on: bool) -> None:
        """

        setRestrictRange(self, on)

            Turn restriction on the playback range on or off. When the
            restriction is turned on, playback will remain with the start and
            end frames of the playback range.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def usesIntegerFrames() -> bool:
        """

        usesIntegerFrames(self) -> bool

            Return True if playback uses integer frame values. Return False
            otherwise.


        """
    @staticmethod
    def setUseIntegerFrames(on: bool) -> None:
        """

        setUseIntegerFrames(self, on)

            Turn integer frame values on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def isRealTime() -> bool:
        """

        isRealTime(self) -> bool

            Return True if realtime playback is turned on. Return False
            otherwise.


        """
    @staticmethod
    def setRealTime(on: bool) -> None:
        """

        setRealTime(self, on)

            Turn realtime playback either on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def realTimeFactor() -> float:
        """

        realTimeFactor(self) -> float

            Return the multiplier factor used when playing with realtime
            playback turned on.


        """
    @staticmethod
    def setRealTimeFactor(factor: float) -> None:
        """

        setRealTimeFactor(self, factor)

            Set the realtime playback multiplier. A multiplier value of less
            than 1 slows down the playback. A multiplier value of greater than 1
            speeds up the playback. A multiplier value equal to 1 maintains
            realtime playback. The multiplier has no effect if realtime playback
            is turned off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def isRealTimeSkipping() -> bool:
        """

        isRealTimeSkipping(self) -> bool

            Return True if realtime playback skipping is turned on. Return False
            otherwise.


        """
    @staticmethod
    def setRealTimeSkipping(on: bool) -> None:
        """

        setRealTimeSkipping(self, on)

            Turn realtime playback skipping either on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def isAudioShown() -> bool:
        """

        isAudioShown(self) -> bool

            Return True if the display of audio in the playbar is turned on.
            Return False otherwise.


        """
    @staticmethod
    def showAudio(on: bool) -> None:
        """

        showAudio(self, on)

            Turn display of audio on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def areKeysShown() -> bool:
        """

        areKeysShown(self) -> bool

            Return True if the display of keyframes in the playbar is turned on.
            Return False otherwise.


        """
    @staticmethod
    def showKeys(on: bool) -> None:
        """

        showKeys(self, on)

            Turn display of keyframes on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def isSimCacheShown() -> bool: ...
    @staticmethod
    def showSimCache(on: bool) -> None: ...
    @staticmethod
    def isRangeSliderShown() -> bool:
        """

        isRangeSliderShown(self) -> bool

            Return True if the display of the range slider in the playbar is
            turned on. Return False otherwise.


        """
    @staticmethod
    def showRangeSlider(on: bool) -> None:
        """

        showRangeSlider(self, on)

            Turn display of the range slider on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def areTicksShown() -> bool:
        """

        areTicksShown(self) -> bool

            Return True if the display of frame ticks in the playbar is turned
            on. Return False otherwise.


        """
    @staticmethod
    def showTicks(on: bool) -> None:
        """

        showTicks(self, on)

            Turn display of the frame ticks on the playbar on or off.

            Raises hou.NotAvailable if the playbar is not available.


        """
    @staticmethod
    def moveToBottom() -> None:
        """

        moveToBottom(self)

            Move the playbar to the bottom of the desktop.

            Raises hou.NotAvailable if the user interface is not available.


        """
    @staticmethod
    def moveToPane(pane: Pane) -> None:
        """

        moveToPane(self, pane)

            Move the playbar to the bottom of the specified pane.

            Raises hou.ObjectWasDeleted if pane does not point to a valid pane.
            Raises hou.NotAvailable if the user interface is not available.


        """
    @staticmethod
    def isContinuousCook() -> bool:
        """

        isContinuousCook(self, enable) -> bool

            Returns if continuous cook nodes are currently engaged.


        """
    @staticmethod
    def setContinuousCook(on: bool) -> None:
        """

        setContinuousCook(self, enable)

            Enables the continuous cooking of nodes that are flagged to do so.
            This allows nodes to continuously generate new results independent
            of the playbar, allowing for sandbox-like setups.


        """
    @staticmethod
    def addEventCallback(callback: Callable[[EnumValue, float], None]) -> None:
        '''

        addEventCallback(self, callback)

            Register a Python callback to be called whenever a playbar event
            occurs (i.e. frame change, playback stopped).


            callback
                Any callable Python object that expects two arguments. The first
                argument is a hou.playbarEvent enum value and the second
                argument is a float storing the frame number of when the event
                took place.

          > def outputPlaybarEvent(event_type, frame):
          >     print \\"Playbar event\\", event_type, \\"at frame\\", frame
          > 
          > hou.playbar.addEventCallback(outputPlaybarEvent)

        '''
    @staticmethod
    def removeEventCallback(callback: Callable[[EnumValue, float], None]) -> None:
        """

        removeEventCallback(callback)

            Remove a Python callback that was previously registered with
            hou.playbar.addEventCallback. See hou.playbar.addEventCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
    @staticmethod
    def clearEventCallbacks() -> None:
        """

        clearEventCallbacks()

            Remove all Python callbacks that have been registered with
            hou.playbar.addEventCallback.


        """
    @staticmethod
    def eventCallbacks() -> Tuple[Callable[[EnumValue, float], None],...]:
        """

        eventCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.playbar.addEventCallback.


        """
    @staticmethod
    def selectedKeyframes() -> dict[Parm, Tuple[BaseKeyframe, ...]]: ...
    @staticmethod
    def selectionRange() -> Vector2:
        """

        selectionRange(self) -> hou.Vector2 or None

            This function exists for backwards compatibility.

            Returns a 2-tuple containing the start and end frame of the
            selection range. If there are multiple selections, the returned
            2-tuple contains the start and end frame of the selection that
            occurs first on the playbar. If there is no selection, then None is
            returned.


        """
    @staticmethod
    def selectionRanges() -> Tuple[Vector2, ...]:
        """

        selectionRanges(self) -> tuple of hou.Vector2

            Returns a list of 2-tuples containing the start and end frame of
            each selection range.


        """
    @staticmethod
    def timelineRange() -> Vector2:
        """

        timelineRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end frames of the global
            frame range.


        """
    @staticmethod
    def timeRange() -> Vector2:
        """

        timeRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end times of the global
            time range.


        """
    @staticmethod
    def setTimeRange(start: float, end: float) -> None:
        """

        setTimeRange(self, start, end)

            Set the global time range using time in seconds.


        """
    @staticmethod
    def frameRange() -> Vector2:
        """

        frameRange(self) -> hou.Vector2

            Return a 2-tuple containing the start and end frame of the global
            time range.


        """
    @staticmethod
    def setFrameRange(start: float, end: float) -> None:
        """

        setFrameRange(self, start, end)

            Set the global time range using frame numbers.


        """
    @staticmethod
    def frameBookmark(bookmark: Bookmark) -> None:
        """

        frameBookmark(self, bookmark)

            Frames the given bookmark by setting the playback range to the start
            and end time of that bookmark.


        """
    @staticmethod
    def channelList() -> ChannelList:
        """

        channelList(self) -> hou.ChannelList

            Return a copy of the current channel list.


        """
    @staticmethod
    def setChannelList(arg: ChannelList) -> None:
        """

        setChannelList(self, [Hom:hou.ChannelList])

            Set the current channel list.


        """
    @staticmethod
    def channelListFromSelection() -> ChannelList:
        """

        channelListFromSelection(self) -> hou.ChannelList

            Return a channel list from the selected nodes. This relies on the
            auto-add to channel list flags.


        """
    @staticmethod
    def channelListFromNodes(nodes: Sequence[Node]) -> ChannelList:
        """

        channelListFromNodes(self,nodes) -> hou.ChannelList

            Return a channel list from the a list of nodes. This relies on the
            auto-add to channel list flags.


        """
    @staticmethod
    def channelListFromParms(parms: Sequence[Parm]) -> ChannelList:
        """

        channelListFromParms(self,parms) -> hou.ChannelList

            Return a channel list from the a list of parameters. This relies on
            the auto-add to channel list flags.


        """
    @staticmethod
    def channelListFromParmTuples(parms: Sequence[ParmTuple]) -> ChannelList:
        """

        channelListFromParmTuples(self,parms) -> hou.ChannelList

            Return a channel list from the a list of parameter tuples. This
            relies on the auto-add to channel list flags.


        """
    @staticmethod
    def isAnimBarShown() -> bool:
        """

        isAnimBarShown(self) -> bool

            Return whether or not the Animation Toolbar is currently displayed.


        """
    @staticmethod
    def showAnimBar(show: bool) -> None:
        """

        showAnimBar(self, show: bool)

            Shows or hides the Animation Toolbar.


        """
    @staticmethod
    def animBar() -> AnimBar:
        """

        animBar(self): -> hou.AnimBar

            Return a hou.AnimBar, which provides control over the playbar's
            Animation Toolbar.


        """

class PluginHotkeyDefinitions:
    """

    hou.PluginHotkeyDefinitions

    Defines the hotkey commands, contexts, and default bindings used by
    plugins like python states and handles.

    OVERVIEW

        The PluginHotkeyDefinitions class lets you build a set of hotkey
        definitions for a viewer state and its menu.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Creates a hou.PluginHotkeyDefinitions object.

          > definitions = hou.PluginHotkeyDefinitions()

        """
    __swig_destroy__: Incomplete
    def addCommandCategory(self, symbol: str, label: str, description: str) -> None:
        """

        addCommandCategory(self, symbol, label, description)

            Adds a command category under which new commands will be added.
            Command categories define a tree structure for organizing commands.
            In Houdini 20, the hotkey context and command category are one and
            the same.


            symbol
                A string containing a full dotted hotkey symbol representing the
                category. For example:

              > h.pane.gview.state.sop.my_state

            label
                A human readable title for the category. For example, Demo State
                Operation.

            description
                A human readable description of the category. This should
                generally be one to three sentences of help text for the
                category.


        """
    def addCommand(self, symbol: str, label: str, description: str) -> None:
        """

        addCommand(self, symbol, label, description)

            Adds a hotkey symbol that represents an action or command.


            symbol
                A string containing a full dotted hotkey symbol.

            label
                A human readable title for the action. For example, Delete
                Selected.

            description
                A human readable description of the action. This should
                generally be one to three sentences of help text for the action.


        """
    def addContext(self, symbol: str, label: str, description: str) -> None:
        """

        addContext(self, symbol, label, description)

            Adds a context to contain bindings of keys to actions. In Houdini
            20, this is unused as key bindings are associated solely with the
            command.


            symbol
                A string containing a full dotted hotkey symbol representing the
                context. For example:

              > h.pane.gview.state.sop.my_state

            label
                A human readable title for the context. For example, Demo State
                Operation.

            description
                A human readable description of the context. This should
                generally be one to three sentences of help text for the
                context.


        """
    def addDefaultBinding(self, context: str, command: str, assignments: Sequence[str], apply_platform_modifier_mappings: bool = ...) -> None:
        """

        addDefaultBinding(self, context, command, assignments, bool
        apply_platform_modifier_mappings = True)

            Adds a default binding assigning keys to a given command in a given
            context. In Houdini 20, where key bindings are associated solely
            with the command, only the bindings where the parent command
            category is specified as the context are used.


            context
                A string containing a full dotted context symbol representing
                the contextin which to create the binding. For example:

              > h.pane.gview.state.sop.my_state

            command
                A string containing a full dotted hotkey symbol representing the
                command for the binding. For example:

              > h.pane.gview.state.sop.my_state.do_something

            assignments
                An optional list of shortcut strings to be used as the default
                assignments for this command in this context.

            apply_platform_modifier_mappings
                When True, performs any modifier mappings that apply to the
                current platform.

                On OSX, this replaces Ctrl+ with Cmd+.


        """
    def containsCommandCategory(self, symbol: str) -> bool:
        """

        containsCommandCategory(self, symbol) -> bool

            Returns whether this hotkey definitions object contains the
            specified command category.


            symbol
                A string containing a full dotted hotkey symbol representing the
                category. For example:

              > h.pane.gview.state.sop.my_state

        """
    def containsCommand(self, symbol: str) -> bool:
        """

        containsCommand(self, symbol) -> bool

            Returns whether this hotkey definitions object contains the
            specified command.


            symbol
                A string containing a full dotted hotkey symbol representing the
                command. For example:

              > h.pane.gview.state.sop.my_state.do_something

        """
    def containsContext(self, symbol: str) -> bool:
        """

        containsContext(self, symbol) -> bool

            Returns whether this hotkey definitions object contains the
            specified context.


            symbol
                A string containing a full dotted hotkey symbol representing the
                context. For example:

              > h.pane.gview.state.sop.my_state

        """
    def containsDefaultBinding(self, context: str, command: str) -> bool:
        """

        containsDefaultBinding(self, context, command) -> bool

            Returns whether this hotkey definitions object contains a default
            binding for the specified command in the specified context.


            context
                A string containing a full dotted hotkey symbol representing the
                context. For example:

              > h.pane.gview.state.sop.my_state

            command
                A string containing a full dotted hotkey symbol representing the
                command for the binding. For example:

              > h.pane.gview.state.sop.my_state.do_something

        """

class Point:
    """

    hou.Point

    Represents a point on a geometry primitive, such as a polygon or NURBS
    surface.

    Each Point object resides inside a Geometry object and stores a 3D
    position. Points may be shared between primitives (such as polygons),
    and the set of points and primitives describes a 3D shape.

    Each point can store arbitrary values in named attributes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Returns the hou.Geometry object containing this point.


        """
    def number(self) -> int:
        """

        number(self) -> int

            Returns the point number of this point. Points are numbered
            sequentially across the entire Geometry starting from 0, and the
            points returned by hou.Geometry.points are in point number order.


        """
    def position(self) -> Vector3:
        '''

        position(self) -> hou.Vector3

            Return the position of this point as a hou.Vector3 containing the
            (X, Y, Z) values.

            You can transform the Vector3 using a hou.Matrix4:

          > xform = hou.node(\\"/obj/geo1\\").worldTransform()  # Matrix4
          > new_pos = point.position() * xform

            This method is a shortcut for accessing the P attribute of the
            point. However, it is not equivalent, because point.attribValue(\\"P\\")
            returns a 3-tuple of floats, not a Vector3 object:

          > point.position()
          > # is equivalent to
          > hou.Vector3(point.attribValue(\\"P\\"))

        '''
    def setPosition(self, position: Sequence[float]) -> None:
        '''

        setPosition(self, position)

            Changes the point\'s location. You would typically call this method
            from the code of a Python-defined SOP.

            position is any sequence of floats, such has a hou.Vector3 or a
            tuple or list of floats, of length 3 or 4. The fourth coordinate
            corresponds to the weight, and is usually 1. The weight is typically
            used by NURBS curves and sequences. If the sequence is of size 3,
            the weight will be unchanged.

            This method is a shortcut for calling hou.Point.setAttribValue on
            the P attribute.

          > point.setPosition((x, y, z))
          > # is the same as
          > point.setAttribValue(\\"P\\", (x, y, z))

            Raises hou.GeometryPermissionError if the geometry is not
            modifiable. Raises hou.InvalidSize if the length of position is not
            3 or 4.


        '''
    def weight(self) -> float:
        '''

        weight(self) -> float

            Return the weight of this point. Point weights are displayed in
            Houdini\'s geometry spreadsheet as the fourth component of the
            position. Point weights are used by NURBS.

            Usually, the weight is 1.0.

            This method is an alternative for accessing the Pw attribute of the
            point that will still work even when the Pw attribute does not
            exist.

          > point.weight()
          > # is equivalent to
          > point.attribValue(\\"Pw\\")
          > # if the \\"Pw\\" attribute exists, and otherwise returns 1.0

            You can build a hou.Vector4 containing both the position and weight:

          > hou.Vector4(tuple(point.position()) + (point.weight(),))

            See also hou.Point.position.


        '''
    def setWeight(self, weight: float) -> None:
        """

        setWeight(self, weight)

            Change the point's weight. You would typically call this method from
            the code of a Python-defined SOP.

            This method is an alternative for calling hou.Point.setAttribValue
            on the Pw attribute that will create the attribute if necessary.

            See hou.Point.weight for more information about a point's weight.
            See also hou.Point.setPosition.


        """
    def attribType(self) -> EnumValue:
        """

        attribType(self) -> hou.attribType enum value

            Always returns hou.attribType.Point.

            This is only useful if you want to write generic code that works
            whether the input objects are hou.Prim, hou.Point, or hou.Vertex.
            They all have an attribType() method that returns the right
            attribType value for the given object.


        """
    def floatAttribValue(self, name_or_attrib: str|Attrib) -> float:
        """

        floatAttribValue(self, name_or_attrib) -> float

            Return the point attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not float of size 1.

            In most cases, you'll just use hou.Point.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
    def floatListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[float,...]:
        """

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the point attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Point.attribValue.


        """
    def intAttribValue(self, name_or_attrib: str|Attrib) -> int:
        """

        intAttribValue(self, name_or_attrib) -> int

            Return the point attribute value for a particular integer attribute
            of size 1. The attribute may be specified by name or by hou.Attrib
            object. See hou.Point.floatAttribValue for more information.


        """
    def intListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[int,...]:
        """

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the point attribute value for a particular integer attribute.
            The attribute may be specified by name or by hou.Attrib object. The
            return value is a tuple of ints. See hou.Point.floatListAttribValue
            for more information.


        """
    def stringAttribValue(self, name_or_attrib: str|Attrib) -> str:
        """

        stringAttribValue(self, name_or_attrib) -> str

            Return the point attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. See
            hou.Point.floatAttribValue for more information.


        """
    def stringListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[str,...]:
        """

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the point attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. The
            return value is a tuple of strings.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Point.floatAttribValue for more information.


        """
    def dictAttribValue(self, name_or_attrib: str|Attrib) -> AttribDictReturnType:
        """

        dictAttribValue(self, name_or_attrib) -> dict

            Return the point attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Point.floatAttribValue for more information.


        """
    def dictListAttribValue(self, name_or_attrib: str|Attrib) -> Sequence[AttribDictReturnType]:
        """

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the point attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Point.floatAttribValue for more information.


        """
    def setAttribValue(self, name_or_attrib: str|Attrib, attrib_value: AttribArgType|AttribDictArgType) -> None:
        """

        setAttribValue(self, name_or_attrib, attrib_value)

            Store an attribute value in this point. The attribute may be
            specified by name or by hou.Attrib object, and must be an existing
            point attribute in the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute's data type does not match the value passed in. If
            the attribute's size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute's size.

            If the attribute is an array, the seqeunce must be a flat array, not
            an array of tuples. If the attribute is float, ensure the python
            objects are float, and not integer (1.0, not 1).

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See hou.Geometry.addAttrib for an example.

            See also:

          * hou.Prim.setAttribValue

          * hou.Vertex.setAttribValue

          * hou.Geometry.setGlobalAttribValue


        """
    def attribValue(self, attrib: Attrib|str) -> AttribReturnType|AttribDictReturnType:
        '''

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return value stored in this point for a particular attribute. The
            attribute may be specified by name or by hou.Attrib object.

            Looking up an attribute value using a hou.Attrib object is slightly
            faster than looking it up by name. When looking up attribute values
            inside a loop, look up the hou.Attrib object outside the loop, and
            pass it into this method.

            Note that the point position attribute is named P and is 4 floats in
            size. This attribute always exists.

            When looking up the attribute values of all points, it is faster to
            call hou.Geometry.pointFloatAttribValues or
            hou.Geometry.pointFloatAttribValuesAsString than to call this method
            for each point in the geometry.

            Raises hou.OperationFailed if no attribute exists with this name.

          > # Create an object containing two SOPs: a box SOP wired into a color SOP.
          > geo_node = hou.node(\\"/obj\\").createNode(\\"geo\\")
          > box = geo_node.createNode(\\"box\\")
          > color = geo_node.createNode(\\"color\\")
          > color.setFirstInput(box)
          > 
          > # Grab the color SOP\'s geometry, get its first point, and print out the
          > # value of the Cd attribute.
          > geo = color.geometry()
          > point = geo.iterPoints()[0]
          > print point.attribValue(\\"Cd\\")
          > 
          > # Look up the Cd attribute and illustrate how to access the attribute
          > # value using the attribute object.
          > cd_attribute = geo.findPointAttrib(\\"Cd\\")
          > print point.attribValue(cd_attribute)

        '''
    def vertices(self) -> Tuple[Vertex, ...]:
        """

        vertices(self) -> tuple of hou.Vertex

            Returns a tuple of the vertices that reference this point.

            This requires a search through a primitive's vertices, so the cost
            grows with the total number of vertices across this point's
            primitives.


        """
    def prims(self) -> Tuple[Prim, ...]:
        """

        prims(self) -> tuple of hou.Prim

            Returns a tuple of the primitives that reference this point.


        """

class PointGroup:
    """

    hou.PointGroup

    A named group of points inside a Geometry object.

    Point groups reside inside the geometry, and each point group has a
    unique name.

    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing point number). When creating a group using the group SOP, use
    the <Create Ordered> checkbox to create an ordered group. When creating
    one from Python, Use the is_ordered parameter of
    hou.Geometry.createPointGroup to control whether a group is ordered.

    See hou.Point for more information about points. See also hou.PrimGroup,
    hou.VertexGroup, and hou.EdgeGroup.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Optional[Geometry]:
        """

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
    def name(self) -> str:
        """

        name(self)

            Return the name of the group. Each point group has a unique name.


        """
    def iterPoints(self) -> _PointTupleGenerator:
        """

        iterPoints(self) -> generator of hou.Point

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.PointGroup.points allocates and returns a tuple of all
            the points in the group, this method returns a generator object that
            will yield hou.Point objects on demand.


        """
    def points(self) -> Tuple[Point, ...]:
        """

        points(self) -> tuple of hou.Point

            Return the contents of this group.

            See also hou.PointGroup.iterPoints.


        """
    def contains(self, point: Point) -> bool:
        """

        contains(self, point) -> bool

            Return whether or not a point is in this group.

            Raises hou.OperationFailed if the point belongs to a different
            geometry object than this group.


        """
    def isOrdered(self) -> bool:
        """

        isOrdered(self) -> bool

            Returns whether or not this group is ordered.


        """
    def add(self, point_or_list_or_point_group: Point|Sequence[Point]|PointGroup) -> None:
        """

        add(self, point_or_list_or_point_group)

            If given a hou.Point or a list of hou.Point's, add the point(s) to
            the group. If given a hou.PointGroup, merge the contents of the
            other point group with this group (the other group is unaffected).
            You would typically call this method from the code of a Python-
            defined SOP.

            It is ok to add points to the group that were already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the point or point group belong to a
            different geometry object than this group.


        """
    def remove(self, point_or_list_or_point_group: Point|Sequence[Point]|PointGroup) -> None:
        """

        remove(self, point_or_list_or_point_group)

            If given a hou.Point or a list of hou.Point's, remove the point from
            the group. If given a hou.PointGroup, remove all points in the other
            group from this group (the other group is unaffected). You would
            typically call this method from the code of a Python-defined SOP.

            It is not an error to try to remove a point from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the point belongs to a different
            geometry object than this group.


        """
    def clear(self) -> None:
        """

        clear(self)

            Remove all points from this group. You would typically call this
            method from the code of a Python-defined SOP.

            The points remain in the geometry; only the group is affected.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def pointCount(self) -> int:
        """

        pointCount(self) -> int

            Returns the number of points in this group.


        """
    def optionType(self, option_name: str) -> EnumValue:
        """

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
    def setOption(self, name: str, value: OptionMultiArgType, type_hint: EnumValue = ...) -> None:
        """

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See
            hou.PointGroup.options for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
    def removeOption(self, name: str) -> None:
        """

        removeOption(self, name)

            Remove an entry in the dictionary of options. See
            hou.PointGroup.options for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
    def dataId(self) -> AttribDataId:
        """

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
    def incrementDataId(self) -> None:
        """

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
    def options(self) -> dict[str, OptionMultiReturnType]:
        """

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.PointGroup.options, hou.PointGroup.setOption and
            hou.PointGroup.removeOption.


        """
    def option(self, option_name: str) -> OptionMultiReturnType: ...

class Polygon(Face):
    """

    hou.Polygon

    A Polygon is a kind of Face whose vertices are connected via straight
    lines.

    Currently, hou.Face, and its base class hou.Prim contain all the
    necessary methods for polygon inspection and manipulation.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete

class PrimGroup:
    """

    hou.PrimGroup

    A named group of primitives inside a Geometry object.

    Primitive groups reside inside the geometry, and each primitive group
    has a unique name.

    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing primitive number). When creating a group using the group SOP,
    use the <Create Ordered> checkbox to create an ordered group. When
    creating one from Python, Use the is_ordered parameter of
    hou.Geometry.createPrimGroup to control whether a group is ordered.

    See hou.Prim for more information about primitives. See also
    hou.PointGroup, hou.VertexGroup, and hou.EdgeGroup.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Optional[Geometry]:
        """

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
    def name(self) -> str:
        """

        name(self)

            Return the name of the group. Each primitive group has a unique
            name.


        """
    def iterPrims(self) -> _PrimTupleGenerator:
        """

        iterPrims(self) -> generator of hou.Prim

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.PrimGroup.prims allocates and returns a tuple of all the
            primitives in the group, this method returns a generator object that
            will yield hou.Prim objects on demand.


        """
    def prims(self) -> Tuple[Prim, ...]:
        """

        prims(self) -> tuple of hou.Prim

            Return the contents of this group.

            See also hou.PrimGroup.iterPrims.


        """
    def contains(self, prim: Prim) -> bool:
        """

        contains(self, prim) -> bool

            Return whether or not a primitive is in this group.

            Raises hou.OperationFailed if the primitive belongs to a different
            geometry object than this group.


        """
    def isOrdered(self) -> bool:
        """

        isOrdered(self) -> bool

            Returns whether or not this group is ordered.


        """
    def add(self, prim_or_list_or_prim_group: Prim|Sequence[Prim]|PrimGroup) -> None:
        """

        add(self, prim_or_list_or_prim_group)

            If given a hou.Prim or a list of hou.Prim's, add the primitive(s) to
            the group. If given a hou.PrimGroup, merge the contents of the other
            primitive group with this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is okay to add primitives to the group that were already in the
            group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the primitive or primitive group
            belong to a different geometry object than this group.


        """
    def remove(self, prim_or_list_or_prim_group: Prim|Sequence[Prim]|PrimGroup) -> None:
        """

        remove(self, prim_or_list_or_prim_group)

            If given a hou.Prim or a list of hou.Prim's, remove the primitive(s)
            from the group. If given a hou.PrimGroup, remove all primitives in
            the other group from this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is not an error to try to remove a primitive from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the primitive belongs to a different
            geometry object than this group.


        """
    def clear(self) -> None:
        """

        clear(self)

            Remove all primitives from this group. You would typically call this
            method from the code of a Python-defined SOP.

            The primitives remain in the geometry; only the group is affected.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def primCount(self) -> int:
        """

        primCount(self) -> int

            Returns the number of primitives in this group.


        """
    def optionType(self, option_name: str) -> EnumValue:
        """

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
    def setOption(self, name: str, value: OptionMultiArgType, type_hint: EnumValue = ...) -> None:
        """

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See hou.PrimGroup.options
            for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
    def removeOption(self, name: str) -> None:
        """

        removeOption(self, name)

            Remove an entry in the dictionary of options. See
            hou.PrimGroup.options for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
    def dataId(self) -> AttribDataId:
        """

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
    def incrementDataId(self) -> None:
        """

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
    def options(self) -> dict[str, OptionMultiReturnType]:
        """

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.PrimGroup.options, hou.PrimGroup.setOption and
            hou.PrimGroup.removeOption.


        """
    def option(self, option_name: str) -> OptionMultiReturnType: ...

class properties:
    """

    hou.properties

    A module for accessing standard render properties.

    This module provides functions for querying the set of standard
    properties that appear under the Render Properties tab when editing the
    parameters of a node or node type. This can make it easier to add these
    render properties programmatically to your nodes or assets.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def classes(tags: Sequence[str]|None = ...) -> Tuple[str,...]:
        """

        classes(tags=None) -> tuple of str

            Returns a list of render property classes. If the tags argument is
            provided, only those classes that match the provided tag expression
            will be returned.


        """
    @staticmethod
    def classLabel(class_name: str) -> str:
        """

        classLabel(class_name) -> str

            Returns the descriptive label for the provided render property
            class.


        """
    @staticmethod
    def categories(class_name: str) -> Tuple[str, ...]:
        """

        categories(class_name) -> tuple of str

            Returns the property categories in the provided render property
            class.


        """
    @staticmethod
    def parameters(class_name: str, category_name: str) -> Tuple[str, ...]:
        """

        parameters(class_name, category_name) -> tuple of str

            Returns the names of all parameters under the category within the
            provided render property class.


        """
    @staticmethod
    def parmTemplate(class_name: str, parm_name: str) -> ParmTemplate:
        """

        parmTemplate(class_name, parm_name) -> hou.ParmTemplate

            Returns an object that represents the template for the specified
            render property parameter. This parameter may be a folder parameter
            if several parameters are intended to be added as a group.


        """

class PythonPanel(PathBasedPaneTab):
    """

    hou.PythonPanel

    Class representing a pane tab that can display an embedded PySide or
    PyQt interface.

    See also hou.pypanel and hou.PythonPanelInterface.


    NOTE
        PySide and PyQt interfaces can only be created from the main Houdini
        application thread. You cannot call any method in this class from a
        separate thread (i.e. do not call from a Python Shell).


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def activeInterface(self) -> Optional[PythonPanelInterface]:
        """

        activeInterface(self) -> hou.PythonPanelInterface

            Return the interface currently assigned to the Python Panel, or None
            if no interface has been assigned.


        """
    def setActiveInterface(self, interface: PythonPanelInterface) -> None:
        """

        setActiveInterface(self, interface)

            Show the specified interface in the Python Panel. interface is a
            hou.PythonPanelInterface object.

            Raises hou.OperationFailed if interface is not an installed Python
            Panel interface.


        """
    def reloadActiveInterface(self) -> None:
        """

        reloadActiveInterface(self)

            Reload the current interface in the Python Panel.

            Reloading destroys the old generated interface, reloads the Python
            Panel's script, and then runs the script to generate a new
            interface.


        """
    def showToolbar(self, show: bool) -> None:
        """

        showToolbar(self, show)

            Show or hide the toolbar. show must be either True or False.


        """
    def isToolbarShown(self) -> bool:
        """

        isToolbarShown(self) -> bool

            Return True if the toolbar is shown and False otherwise.


        """
    def expandToolbar(self, expand: bool) -> None: ...
    def isToolbarExpanded(self) -> bool:
        """

        isToolbarExpanded(self) -> bool

            Return True if the toolbar is expanded and False otherwise.


        """
    def label(self) -> str:
        """

        label(self) -> str

            Return the label that appears in the Python Panel's pane tab button.
            If the Python Panel is not contained in a pane tab but is in a
            floating window then the label appearing in the window title bar is
            returned.


        """
    def setLabel(self, label: str) -> None:
        '''

        setLabel(self, label)

            Set the Python Panel\'s label. The label appears in the tab button of
            the pane tab containing the Python Panel or in the window title bar
            if the Python Panel is not contained in a pane tab but in a floating
            window.

            You can set a custom label through one of the Python Panel
            interface\'s hook functions. For example, to set the label when the
            interface is first created:

          > def onCreateInterface():
          >     # Set a custom label on the containing pane tab.
          >     pane_tab = kwargs[\\"paneTab\\"]
          >     pane_tab.setLabel(\\"My Custom Label\\")
          > 
          >     widget = QWidget()
          >     return widget

        '''
    def activeInterfaceScriptErrors(self) -> str:
        """

        activeInterfaceScriptErrors(self) -> str

            Return any errors that were raised when executing the active
            interface's script. Return an empty string if there were no errors.


        """
    def activeInterfaceRootWidget(self) -> QtWidgets.QWidget:
        """

        activeInterfaceRootWidget(self) -> Qt.QtWidgets.QWidget subclass

            Return a reference to the user-defined root widget created by the
            active interface in the Python Panel. Return None if there is no
            active interface, if the active interface raised an exception when
            creating the root widget or if the active interface has not yet
            finished creating the root widget.


        """

class pypanel:
    """

    hou.pypanel

    Module containing functions related to Python panels.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def installFile(file_path: str) -> None:
        """

        installFile(file_path)

            Install all the Python Panel interfaces defined in the given
            .pypanel file into the current Houdini session.


            file_path
                The .pypanel file to load.


        """
    @staticmethod
    def interfacesInFile(file_path: str) -> Tuple[PythonPanelInterface, ...]:
        """

        interfacesInFile(file_path) -> tuple of hou.PythonPanelInterface

            Return all the Python Panel interface definitions inside the given
            .pypanel file. See hou.PythonPanelInterface for more information.

            Raises hou.OperationFailed if file_path does not refer to a valid
            .pypanel file.


        """
    @staticmethod
    def interfaces() -> dict[str, PythonPanelInterface]:
        """

        interfaces() -> dict of str to hou.PythonPanelInterface

            Return all the Python Panel interface definitions currently
            installed. Returns a dictionary mapping interface names to
            corresponding hou.PythonPanelInterface instances.

            See hou.PythonPanelInterface for more information.


        """
    @staticmethod
    def interfaceByName(name: str) -> Optional[PythonPanelInterface]:
        """

        interfaceByName(name) -> hou.PythonPanelInterface

            Return the Python Panel interface definition that corresponds to the
            given interface name.

            Return None if no such interface definition exists.


        """
    @staticmethod
    def setMenuInterfaces(names: Sequence[str]) -> None:
        """

        setMenuInterfaces(names)

            Set the Python Panel drop-down menu to the list of interface names.
            Note that __separator__ is a valid name to indicate a separator in
            the list.

            Raises hou.OperationFailed if names contains interfaces that are not
            installed


        """
    @staticmethod
    def menuInterfaces() -> Tuple[str, ...]:
        """

        menuInterfaces() -> tuple of str

            Return a tuple of the names of the interfaces currently shown in the
            Python Panel drop-down menu.


        """

class PythonPanelInterface:
    """

    hou.PythonPanelInterface

    Represents the definition of a Python panel interface.

    RELATED

      * hou.pypanel

      * hou.PythonPanel


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def id(self) -> int:
        """

        id(self) -> int

            Returns the id for this interface.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name for this interface.


        """
    def setName(self, name: str) -> None:
        """

        setName(self,name)

            Sets the name for this interface.


        """
    def label(self) -> str:
        """

        label(self) -> str

            Returns the label for this interface.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self,label)

            Sets the label for this interface.


        """
    def icon(self) -> str:
        """

        icon(self) -> str

            Returns the icon for this interface.


        """
    def setIcon(self, icon: str) -> None:
        """

        setIcon(self,icon)

            Sets the icon for this interface.


        """
    def script(self) -> str:
        """

        script(self) -> str

            Returns the script for this interface.


        """
    def setScript(self, script: str) -> None:
        """

        setScript(self,script)

            Sets the script for this interface.


        """
    def help(self) -> str: ...
    def setHelp(self, script: str) -> None: ...
    def helpURL(self) -> str: ...
    def setHelpURL(self, script: str) -> None: ...
    def filePath(self) -> str:
        """

        filePath(self) -> str

            Returns the file path for this interface.


        """
    def setFilePath(self, filePath: str) -> None:
        """

        setFilePath(self,script)

            Sets the file path for this interface.


        """

class Quadric(Prim):
    """

    hou.Quadric

    A Quadric is a kind of geometry primitive (Prim object) that represents
    a 3-dimensional surface defined by a quadratic polynomial equation (e.g.
    a sphere or tube).


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def transform(self) -> Matrix3:
        """

        transform(self) -> hou.Matrix3

            Return the 3x3 matrix associated with this quadric. This matrix
            determines what type of quadric it is.

            See Wikipedia's Quadric page for more information.


        """
    def getTransform(self) -> Matrix3: ...
    def vertex(self, index: int) -> Vertex:
        """

        vertex(self, index) -> hou.Vertex

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """

class Quaternion:
    """

    hou.Quaternion

    A representation of a 3D rotation (or orientation). You can smoothly
    interpolate between two rotation values by interpolating between two
    quaternions.

    Quaternions provide an easy way to nicely interpolate between two
    rotation values, and avoid the gimbal lock and direction changes caused
    by interpolating Euler angles. They can easily be converted to and from
    rotation matrices, Euler angles, and angle-axis rotations.

    A quaternion is represented by a vector of 4 floats (x, y, z, and w).
    Any rotation in three dimensions is a rotation by some angle about some
    axis, and you can think of the (x, y, z) portion of the quaternion as
    storing the axis and the w portion as storing a (representation of) the
    angle.

    See Wikipedia's Quaternion page and its Quaternions and space rotation
    page for more information.


    """
    thisown: Incomplete
    def __init__(self, x: Sequence[float]|float|'Quaternion'|Matrix3|Matrix4, y: Sequence[float]|float, z: float = ..., w: float = ...) -> None:
        '''

        __init__(self)

            You can construct a quaternion from a 3x3 rotation matrix, a 4x4
            rotation matrix, a rotation about an axis, Euler angles, or an (x,
            y, z, w) tuple. Note that rotations are represented as unit
            quaternions (i.e. quaternions of length 1), so constructing a
            quaternion from an arbitrary (x, y, z, w) tuple will not necessarily
            give a unit quaternion.

          > # Construct a quaternion from a rotation matrix.
          > hou.Quaternion(matrix3)
          > hou.Quaternion(matrix4)
          > 
          > # Construct a quaternion from a rotation about an arbitrary axis.
          > hou.Quaternion(90, (1, 1, 0))
          > 
          > # Construct a quaternion from Euler angles.
          > quaternion = hou.Quaternion()
          > quaternion.setToEulerRotates((rx, ry, rz), rotate_order=\\"xyz\\")
          > 
          > # Another way to construct a quaternion from Euler angles by first
          > # constructing a matrix.
          > hou.Quaternion(hou.hmath.buildRotate((rx, ry, rz), \\"xyz\\"))
          > 
          > # Construct a quaternion with specific x, y, z, and w values.
          > hou.Quaternion(x, y, z, w)
          > 
          > # Construct a quaternion with x, y, z, set to zero and w set to one.
          > # This quaternion corresponds to the identity quaternion (i.e. no
          > # rotation).
          > hou.Quaternion()

            See also hou.hmath.buildRotate, hou.hmath.buildRotateAboutAxis, and
            hou.Matrix4.extractRotationMatrix3.


        '''
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, quaternion: Quaternion, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, quaternion, tolerance=0.00001) -> bool

            Returns whether this quaternion is equal to another, within a
            numerical tolerance.


        """
    def almostEqual(self, quaternion: Quaternion, tolerance: float = 1e-05) -> bool:
        """

        almostEqual(self, quaternion, tolerance=0.00001) -> bool

            Deprecated. Use Quaternion.isAlmostEqual instead.


        """
    def __hash__(self) -> int: ...
    def __getitem__(self, index: int) -> float:
        """

        __getitem__(self, index) -> float

            Return one of the four float values stored in the quaternion. This
            method, along with hou.Quaternion.__setitem__ and
            hou.Quaternion.__len__, make quaternions behave like sequences of 4
            floats so you can use Python's square bracket notation, sequence
            iteration, etc.

          > >>> q = hou.Quaternion(1, 2, 3, 4)
          > >>> for value in q:
          > ...     print value
          > 1
          > 2
          > 3
          > 4
          > >>> q[2]
          > 3
          > >>> len(q)
          > 4

        """
    def __setitem__(self, index: int, value: float) -> None:
        """

        __setitem__(self, index, value)

            Set one of the four float values stored in the quaternion. See
            hou.Quaternion.__getitem__ for more information.


        """
    def __len__(self) -> int:
        """

        __len__(self) -> int

            Return 4, the number of float elements in the quaternion. See
            hou.Quaternion.__getitem__ for more information.


        """
    def setTo(self, tuple: Sequence[float]) -> None:
        """

        setTo(self, tuple)

            Set the quaternion's 4 float values (x, y, z, and w). tuple must be
            a sequence of 4 floats.

            This method will modify an existing quaternion object. Use
            hou.Quaternion.__init__ to construct a new quaternion from these
            four values.

            See also hou.Quaternion.__setitem__.


        """
    def setToRotationMatrix(self, matrix3_or_matrix4: Matrix3|Matrix4) -> None:
        """

        setToRotationMatrix(self, matrix3_or_matrix4)

            Set this quaternion to contain the rotation component of the
            transformation in a hou.Matrix3 or hou.Matrix4.

            See also hou.Quaternion.extractRotationMatrix3.


        """
    def setToAngleAxis(self, angle_in_deg: float, axis: Sequence[float]) -> None:
        """

        setToAngleAxis(self, angle_in_deg, axis)

            Set this quaternion to contain the rotation about an axis by the
            given angle. angle_in_deg is in degrees and axis is a sequence of 3
            floats.

            This method can also be implemented as follows:

          > def setToAngleAxis(self, angle_in_deg, axis):
          >     self.setToRotationMatrix(
          >         hou.hmath.buildRotateAboutAxis(axis, angle_in_deg))

            See also hou.Quaternion.extractAngleAxis.


        """
    def setToVectors(self, v1: Vector3, v2: Vector3) -> None:
        """

        setToVectors(self, a, b)

            Sets this quaternion to the quaternion which rotates the hou.Vector3
            a onto the vector b.


        """
    def setToEulerRotates(self, angles_in_deg: float, rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ...) -> None:
        '''

        setToEulerRotates(self, angles_in_deg, rotate_order=\\"xyz\\")

            Set this quaternion to contain the rotation specified by Euler
            rotations about the x, y, and z coordinate axes.

            This method can also be implemented as follows:

          > def setToEulerRotates(self, angles_in_deg, rotate_order=\\"xyz\\"):
          >     self.setToRotationMatrix(
          >         hou.hmath.buildRotate(angles_in_deg, rotate_order))

            See also hou.Quaternion.extractEulerRotates and
            hou.hmath.buildRotate.


        '''
    def conjugate(self) -> Quaternion:
        """

        conjugate(self) -> hou.Quaternion

            Return a quaternion containing the opposite rotation of that stored
            in this quaternion. Intuitively, for unit length quaternions, the
            quaternion returned contains a rotation by the same angle about an
            axis pointing in the opposite direction.


        """
    def inverse(self) -> Quaternion:
        """

        inverse(self) -> hou.Quaternion

            Return a quaternion containing the multiplicative inverse of this
            quaternion. For unit quaternions, the inverse is the same as the
            conjugate.

            See also hou.Quaternion.conjugate.


        """
    def dot(self, quaternion: Quaternion) -> float:
        """

        dot(self, other) -> float

            Return the dot product of this quaternion with another one.


        """
    def __add__(self, quaternion: Quaternion) -> Quaternion:
        """

        __add__(self, quaternion) -> hou.Quaternion

            Return a new quaternion containing the sum of this quaternion and
            another. This method lets you write quaternion1 + quaternion2.

            The sum of two quaternions is defined to be the vector containing
            the pairwise sum of their elements.


        """
    def __sub__(self, quaternion: Quaternion) -> Quaternion:
        """

        __sub__(self, quaternion) -> hou.Quaternion

            Return a new quaternion containing the result of subtracting another
            quaternion from this one. This method lets you write quaternion1 -
            quaternion2.


        """
    def __mul__(self, quaternion_or_scalar: Quaternion|float) -> Quaternion:
        """

        __mul__(self, quaternion_or_scalar) -> hou.Quaternion

            Multiply this quaternion by either another quaternion or a scalar.
            This method lets you write quaternion1 * quaternion2 and quaternion
            * scalar. This method returns a new hou.Quaternion and does not
            change this object's value.

            The product of two quaternions is defined to be the vector
            containing the pairwise product of their elements. Multiplying a
            quaternion by a scalar multiplies each of the elements by that
            scalar.


        """
    def slerp(self, other: Quaternion, fraction: float) -> Quaternion:
        '''

        slerp(self, other, fraction) -> hou.Quaternion

            Perform spherical linear interpolation between this quaternion and
            another, returning a new quaternion. fraction is a float from 0.0 to
            1.0, where 0.0 gives this quaternion and 1.0 gives the other
            quaternion. This method is very useful to smoothly interpolate
            between two different rotations.

            See Wikipedia\'s Slerp page for more information.

            The following example will nicely interpolate between two sets of
            Euler rotations.

          > def interpolateEulerRotations(rotation1, rotation2, fraction, rotate_order=\\"xyz\\"):
          >     quaternion1 = hou.Quaternion()
          >     quaternion1.setToEulerRotates(rotation1, rotate_order)
          >     quaternion2 = hou.Quaternion()
          >     quaternion2.setToEulerRotates(rotation2, rotate_order)
          > 
          >     return quaternion1.slerp(quaternion2, fraction).extractEulerRotates(rotate_order)

        '''
    def normalized(self) -> Quaternion:
        """

        normalized(self) -> hou.Quaternion

            Return a normalized version of this quaternion (i.e. a version of
            this quaternion whose length is one). Quaternions that represent
            rotations are always normalized.

            Normalizing a quaternion whose length is zero or near zero will
            return a new quaternion with the same values.

            This method can be implemented as follows (for non-zero length
            quaternions):

          > def normalized(self):
          >     return self * (1.0 / self.length())

        """
    def length(self) -> float:
        """

        length(self) -> float

            Return the length of the quaternion. When quaternions represent
            rotations, their length is one.

            A quaternion's length is compute the same as a Vector4's:
            hou.Vector4(self).length()


        """
    def extractRotationMatrix3(self) -> Matrix3:
        """

        extractRotationMatrix3(self) -> hou.Matrix3

            Return a 3x3 rotation matrix corresponding to the rotation in the
            quaternion.

            To create a hou.Matrix4 instead of a hou.Matrix3, you can easily
            create a Matrix4 from the Matrix3:

          > hou.Matrix4(quaternion.extractRotationMatrix3())

            If the quaternion is the zero quaternion, this method does not raise
            an exception. Instead, it returns the identity matrix.

            See also hou.Quaternion.setToRotationMatrix.


        """
    def extractAngleAxis(self) -> Tuple[float, Vector3]:
        """

        extractAngleAxis(self) -> (float, hou.Vector3)

            Return an axis and a rotation about that axis corresponding to the
            rotation in the quaternion. The return value is a 2-tuple containing
            a float and a hou.Vector3. The returned axis vector is normalized.

            If this quaternion is the zero quaternion, the angle returned is
            zero and the vector is the zero vector. Otherwise, if it is not
            normalized, the return values will correspond to the rotation
            represented by the normalized quaternion.

            See also hou.Quaternion.setToAngleAxis.


        """
    def extractEulerRotates(self, rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ...) -> Vector3:
        '''

        extractEulerRotates(self, rotate_order=\\"xyz\\") -> hou.Vector3

            Return the Euler rotations (the x, y, and z rotation values, in
            degrees, about the coordinate axes) corresponding to the rotation in
            the quaternion.

            This method can also be implemented as follows:

          > def extractEulerRotates(self, rotate_order=\\"xyz\\"):
          >     return hou.Matrix4(self.extractRotationMatrix3()).explode(rotate_order=rotate_order)[\\"rotate\\"]

            See also hou.Quaternion.setToEulerRotates.


        '''
    def rotate(self, v: Vector3) -> Vector3:
        """

        rotate(self, vec) -> hou.Vector3

            Rotates the given hou.Vector3 by this quaternion and returns the
            result.


        """

class qt:
    """

    hou.qt

    Module containing Qt related functions.

    CLASSES



    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def canCreateIcon(icon_name: str) -> bool:
        """

        hou.qt.canCreateIcon

        Return true if a valid (non-empty) icon can be created from the supplied
        icon name.

        USAGE
          canCreateIcon(name) -> bool

        This functon can be used before using hou.qt.Icon to create a new icon.
        If this function returns False, the generated icon, while valid, will be
        blank because no source data will be found using the given name.


        """
    @staticmethod
    def styleSheet(file_path: Optional[str] = None) -> str:
        '''

        hou.qt.styleSheet

        Return the Houdini style sheet.

        USAGE
          styleSheet(file_path=None) -> str

        If file_path is not None, then return the style sheet stored in the
        given file rather than the Houdini style sheet. Style placeholders, such
        as color placeholders (i.e. @MenuBG@) and scaled size placeholders (i.e.
        @14px@), are evaluated and expanded in the returned style sheet.

        Return an empty string if the specified file path does not exist or if
        there is a syntax error in the style sheet.

        The returned style sheet can be applied to Qt widgets. Note that child
        widgets automatically inherit the parent widget\'s style sheet.

        > import Qt.QtWidgets as QtWidgets
        > 
        > # Get the Houdini style sheet.
        > stylesheet = hou.qt.styleSheet()
        > 
        > # Apply the Houdini style to a widget.
        > parent_widget = QtWidgets.QWidget()
        > parent_widget.setStyleSheet(stylesheet)
        > 
        > child_button = QtWidgets.QPushButton()
        > child_button.setText(\\"Hello World\\")
        > 
        > # Parenting the child button inherits the parent\'s Houdini style sheet.
        > child_button.setParent(parent_widget)

        '''
    @staticmethod
    def inchesToPixels(inches: float) -> float:
        """

        hou.qt.inchesToPixels

        Converts inches to pixels, accounting for both Qt and Houdini's dpi
        settings.

        USAGE
          inchesToPixels(inches) -> float


        """
    @staticmethod
    def pixelsToInches(pixels: float) -> float:
        """

        hou.qt.pixelsToInches

        Converts pixels to inches, accounting for both Qt and Houdini's dpi
        settings.

        USAGE
          pixelsToInches(pixels) -> float


        """
    @staticmethod
    def skipClosingMenusForCurrentButtonPress() -> None:
        """

        hou.qt.skipClosingMenusForCurrentButtonPress

        Disable automatic closing of menus for the current mouse button event.

        USAGE
          skipClosingMenusForCurrentButtonPress()

        Normally a mouse button event sent to any Qt widget in the Houdini
        process will cause all open Houdini menus to close. However if a mouse
        button event to a Qt widget is what causes a Houdini menu to open (such
        as through a call to hou.NetworkEditor.openNodeMenu), it is necessary to
        disable this automatic menu closing temporarily. Otherwise the menu that
        was just opened would be immediately closed. This method does exactly
        this, disabling the automatic menu closing until the next mouse button
        release event, at which time the automatic menu closing is re-enabled.


        """

    # Missing methods added by stubgen
    @staticmethod
    def mainWindow() -> QtWidgets.QMainWindow: ...

    # Missing classes added by stubgen

    class ColorField(QtWidgets.QWidget):
        """Class added by stubgen"""
        def __init__(self, label: str ='', include_alpha: bool = False) -> None: ...
        def color(self) -> QtGui.QColor: ...
        def setColor(self, color: QtGui.QColor) -> None: ...

    class ColorPalette(QtWidgets.QFrame):
        """Class added by stubgen"""
        paletteChanged: QtCore.Signal  # QtCore.Signal()
        colorEdited: QtCore.Signal  # QtCore.Signal(int, QtGui.QColor, QtGui.QColor)
        colorSelected: QtCore.Signal  # QtCore.Signal(int, QtGui.QColor)
        colorAccepted: QtCore.Signal  # QtCore.Signal(int, QtGui.QColor)
        colorCancelled: QtCore.Signal  # QtCore.Signal()
        def __init__(self, colors: Sequence[QtGui.QColor] | None =None, size: int = 32, by_column: bool = False, show_at_pointer: bool = True, columns: int | None =None, rows: int | None =None, allow_editing:bool=True, selected_index: int=-1, bg_color: QtGui.QColor | QtGui.QBrush | None=None, empty_color: QtGui.QColor | QtGui.QBrush | None = None, parent: QtWidgets.QWidget | None =None) -> None: ...
        def color(self, index: int) -> None: ...
        def colorCount(self) -> int: ...
        def colorList(self) -> list[QtGui.QColor]: ...
        def isEditingAllowed(self) -> bool: ...
        def selectedColor(self) -> QtGui.QColor: ...
        def selectedIndex(self) -> int: ...
        def setColor(self, index: int, color: QtGui.QColor) -> None: ...
        def setColorList(self, colors: Sequence[QtGui.QColor]) -> None: ...
        def setEditingAllowed(self, allowed: bool) -> None: ...
        def setSelectedIndex(self, index: int) -> None: ...
        def setSwatchSize(self, size: int) -> None: ...
        def swatchSize(self) -> int: ...

    class ColorSwatchButton(QtWidgets.QPushButton):
        """Class added by stubgen"""
        PositionOff: int
        PositionTop: int
        PositionBottom: int
        PositionLeft: int
        PositionRight: int
        PositionAll: int
        colorChanged: QtCore.Signal  # QtCore.Signal(QtGui.QColor)
        def __init__(self, include_alpha: bool=False) -> None: ...
        def color(self) -> QtGui.QColor: ...
        def hasAlpha(self) -> bool: ...
        def secondaryColor(self) -> QtGui.QColor: ...
        def secondaryColorPosition(self) -> int: ...
        def setColor(self, color: QtGui.QColor) -> None: ...
        def setSecondaryColor(self, color: QtGui.QColor) -> None: ...
        def setSecondaryColorPosition(self, position: int) -> None: ...

    class ComboBox(QtWidgets.QComboBox):
        """Class added by stubgen"""
        def __init__(self) -> None: ...

    class Dialog(QtWidgets.QDialog):
        """Class added by stubgen"""
        def __init__(self) -> None: ...

    class FieldLabel(QtWidgets.QLabel):
        """Class added by stubgen"""
        def __init__(self, label: str) -> None: ...

    class FileChooserButton(QtWidgets.QToolButton):
        """Class added by stubgen"""
        fileSelected: QtCore.Signal  # QtCore.Signal(str)
        def __init__(self) -> None: ...
        def setFileChooserDefaultValue(self, default_value: str) -> None: ...
        def setFileChooserFilter(self, file_filter: EnumValue) -> None: ...
        def setFileChooserIsImageChooser(self, is_image_chooser: bool) -> None: ...
        def setFileChooserMode(self, chooser_mode: EnumValue) -> None: ...
        def setFileChooserMultipleSelect(self, multiple_select: bool) -> None: ...
        def setFileChooserPattern(self, file_pattern: str) -> None: ...
        def setFileChooserStartDirectory(self, start_dir: str) -> None: ...
        def setFileChooserTitle(self, title: str) -> None: ...

    class FileLineEdit(QtWidgets.QLineEdit):
        """Class added by stubgen"""
        def __init__(self, icon: QtGui.QIcon | str | None = None, parent: QtWidgets.QWidget | None = None) -> None: ...

    class GridLayout(QtWidgets.QGridLayout):
        """Class added by stubgen"""
        def __init__(self) -> None: ...

    class HelpButton(QtWidgets.QToolButton):
        """Class added by stubgen"""
        def __init__(self, help_path: str, tooltip: str = ...) -> None: ...

    class Icon(QtGui.QIcon):
        """Class added by stubgen"""
        def __init__(self, icon_name: str, width: int | None = None, height: int | None = None) -> None: ...

    class InputField(QtWidgets.QWidget):
        """Class added by stubgen"""
        IntegerType: int
        FloatType: int
        StringType: int
        valueChanged: QtCore.Signal  # QtCore.Signal()
        hotkeyInvoked: QtCore.Signal  # QtCore.Signal(str)
        editingFinished: QtCore.Signal  # QtCore.Signal(list)
        ladderChanged: QtCore.Signal  # QtCore.Signal()
        def __init__(self, data_type: int, num_components: int, label: str | None=..., mouse_hotkeys: Any | None = None, size_policy: QtWidgets.QSizePolicy | None=None, notify_pending_changes: bool=True, parent: QtWidgets.QWidget | None=None) -> None: ...
        def menu(self) -> QtWidgets.QMenu: ...
        def onContextMenuEvent(self, event: QtGui.QContextMenuEvent, context_menu: QtWidgets.QMenu) -> None: ...
        def onMousePressEvent(self, event: QtGui.QMouseEvent) -> None: ...
        def onMouseWheelEvent(self, event: QtGui.QWheelEvent) -> None: ...
        def setAlignment(self, a: QtCore.Qt.Alignment | QtCore.Qt.AlignmentFlag) -> None: ...
        def setMenu(self, menu: QtWidgets.QMenu) -> None: ...
        def setState(self, state_name: str, state_value: bool, index: int = 0) -> None: ...
        def setValidator(self, validator: QtGui.QValidator) -> None: ...
        def setValue(self, value: int | float | str | None, index: int = 0) -> None: ...
        def setValues(self, values: Sequence[int] | Sequence[float] | Sequence[str]) -> None: ...
        def setWidth(self, width: float) -> None: ...
        def state(self, state_name: str, index: int = 0) -> bool: ...
        def value(self, index: int = 0) -> int | float | str: ...
        def values(self) -> list[int] | list[float] | list[str]: ...

    class ListEditor(QtWidgets.QFrame):
        """Class added by stubgen"""
        listChanged: QtCore.Signal  # QtCore.Signal()
        checkChanged: QtCore.Signal  # QtCore.Signal(int, str, bool)
        itemEdited: QtCore.Signal  # QtCore.Signal(int, str)
        def __init__(self, strings: Sequence[str]=..., top_message: str | None=None, bottom_message: str | None=None, allow_editing: bool=True, allow_add_remove: bool=True, allow_reorder: bool=True, allow_empty_string: bool =True, show_checkboxes: bool=False, keep_sorted: bool = False, initial_string: str = '', initial_check: bool = True, exclusive_check: bool = False, allow_empty_list: bool = True, parent: QtWidgets.QWidget | None = None) -> None: ...
        def addListItem(self, text: str, checked: bool | None=None, insert_at: int=-1) -> None: ...
        def bottomMessage(self) -> str: ...
        def checkedRow(self) -> int | None: ...
        def checkedRows(self) -> list[int]: ...
        def checkedString(self) -> str | None: ...
        def checkedStrings(self) -> list[str]: ...
        def clear(self) -> None: ...
        def initialCheck(self) -> bool: ...
        def initialString(self) -> str: ...
        def isAddRemoveAllowed(self) -> bool: ...
        def isEditingAllowed(self) -> bool: ...
        def isEmptyListAllowed(self) -> bool: ...
        def isEmptyStringAllowed(self) -> bool: ...
        def isReorderAllowed(self) -> bool: ...
        def itemCount(self) -> int: ...
        def keepSorted(self) -> bool: ...
        def removeRow(self, row_num: int) -> None: ...
        def rowIsChecked(self, row_num: int) -> bool: ...
        def rowString(self, row_num: int) -> str: ...
        def setAllowAddRemove(self, allow: bool) -> None: ...
        def setAllowEditing(self, allow: bool) -> None: ...
        def setAllowEmptyList(self, allow: bool) -> None: ...
        def setAllowEmptyString(self, allow: bool) -> None: ...
        def setAllowReorder(self, allow: bool) -> None: ...
        def setBottomMessage(self, text: str) -> None: ...
        def setInitialCheck(self, checked: bool) -> None: ...
        def setInitialString(self, text: str) -> None: ...
        def setKeepSorted(self, keep_sorted: bool) -> None: ...
        def setRowChecked(self, row_num: int, checked: bool) -> None: ...
        def setShowCheckboxes(self, show: bool) -> None: ...
        def setStrings(self, strings: Sequence[str]) -> None: ...
        def setStringsAndChecks(self, strings_and_checks: Sequence[tuple[str, bool]]) -> None: ...
        def setTopMessage(self, text: str) -> None: ...
        def showCheckboxes(self) -> bool: ...
        def strings(self) -> list[str]: ...
        def stringsAndChecks(self) -> list[tuple[str, bool]]: ...
        def topMessage(self) -> str: ...

    class ListEditorDialog(QtWidgets.QDialog):
        """Class added by stubgen"""
        def __init__(self, parent: QtWidgets.QWidget | None = None, window_type: QtCore.Qt.WindowType = ..., strings: Sequence[str]=..., top_message: str | None=None, bottom_message: str | None=None, allow_editing: bool=True, allow_add_remove: bool=True, allow_reorder: bool=True, allow_empty_string: bool =True, show_checkboxes: bool=False, keep_sorted: bool = False, initial_string: str = '', initial_check: bool = True, exclusive_check: bool = False, allow_empty_list: bool = True) -> None: ...
        def editor(self) -> qt.ListEditor: ...

    class Menu(QtWidgets.QMenu):
        """Class added by stubgen"""
        def __init__(self) -> None: ...

    class MenuBar(QtWidgets.QMenuBar):
        """Class added by stubgen"""
        def __init__(self, parent: QtWidgets.QWidget | None=None) -> None: ...

    class MenuButton(QtWidgets.QPushButton):
        """Class added by stubgen"""
        def __init__(self, menu: QtWidgets.QMenu) -> None: ...

    class MixerFilterProxyModel(QtCore.QSortFilterProxyModel):
        """Class added by stubgen"""

    class NodeChooserButton(QtWidgets.QToolButton):
        """Class added by stubgen"""
        nodeSelected: QtCore.Signal  # QtCore.Signal(object)
        nodePathsSelected: QtCore.Signal  # QtCore.Signal(str)
        chooserStarted: QtCore.Signal  # QtCore.Signal()
        def __init__(self) -> None: ...
        def setNodeChooserFilter(self, node_filter: EnumValue) -> None: ...
        def setNodeChooserInitialNode(self, initial_node: OpNode) -> None: ...
        def setNodeChooserRelativeToNode(self, relative_to_node: OpNode) -> None: ...
        def setSelectMultiple(self, value: bool) -> None: ...

    class ParmChooserButton(QtWidgets.QToolButton):
        """Class added by stubgen"""
        parmSelected: QtCore.Signal  # QtCore.Signal(object)
        def __init__(self) -> None: ...
        def setCategoryFilter(self, category_filter: EnumValue) -> None: ...
        def setInitialSelection(self, initial_selection: OpNode) -> None: ...
        def setRelativeToNode(self, relative_to_node: OpNode) -> None: ...
        def setSelectMultiple(self, value: bool) -> None: ...

    class ParmDialog(QtWidgets.QWidget):
        """Class added by stubgen"""
        def __init__(self, node: OpNode | None, showTitleBar: bool = False, compact: bool = False, labelsize: float = -1.0) -> None: ...
        def multiParmTab(self, parm: str) -> None: ...
        def node(self) -> OpNode: ...
        def scrollPosition(self) -> Vector2: ...
        def setMultiParmTab(self, parm: str, index) -> None: ...
        def setNode(self, node: OpNode | None) -> None: ...
        def setScrollPosition(self, pos: Vector2) -> None: ...
        def visibleParms(self) -> tuple[ParmTuple, ...]: ...

    class ParmTupleChooserButton(QtWidgets.QToolButton):
        """Class added by stubgen"""
        parmTupleSelected: QtCore.Signal  # QtCore.Signal(object)
        def __init__(self) -> None: ...
        def setCategoryFilter(self, category_filter: EnumValue) -> None: ...
        def setInitialSelection(self, initial_selection: OpNode) -> None: ...
        def setRelativeToNode(self, relative_to_node: OpNode) -> None: ...
        def setSelectMultiple(self, value: bool) -> None: ...

    class SearchLineEdit(QtWidgets.QLineEdit):
        """Class added by stubgen"""
        searchBackward: QtCore.Signal  # QtCore.Signal()
        def __init__(self, icon: QtGui.QIcon | str | None = None, parent: QtWidgets.QWidget | None = None) -> None: ...
        def allowSearchBackward(self) -> bool: ...
        def setAllowSearchBackward(self, on: bool) -> None: ...

    class Separator(QtWidgets.QFrame):
        """Class added by stubgen"""
        def __init__(self) -> None: ...

    class ToolTip(QtWidgets.QWidget):
        """Class added by stubgen"""
        def __init__(self) -> None: ...
        def setHelpUrl(self, help_url: str) -> None: ...
        def setHotkey(self, hotkey: str) -> None: ...
        def setTargetWidget(self, widget: QtWidgets.QWidget) -> None: ...
        def setText(self, text: str) -> None: ...
        def setTitle(self, title: str) -> None: ...

    class TrackChooserButton(QtWidgets.QToolButton):
        """Class added by stubgen"""
        trackSelected: QtCore.Signal  # QtCore.Signal(object)
        def __init__(self) -> None: ...
        def setInitialSelection(self, initial_track: Track) -> None: ...
        def setNodeChooserFilter(self, node_filter: EnumValue) -> None: ...
        def setSelectMultiple(self, value: bool) -> None: ...

    class WindowOverlay(QtWidgets.QWidget):
        """Class added by stubgen"""
        def __init__(self, parent: qt.Window, win_floating_panel: QtWidgets.QWidget | None) -> None: ...
        def onContainerWindowEvent(self, event: QtCore.QEvent) -> None: ...
        def onInitWindow(self) -> None: ...
        def onParentWindowEvent(self, event: QtCore.QEvent) -> None: ...
        def windowContainer(self) -> QtWidgets.QWidget: ...

    class Window(QtWidgets.QWidget):
        """Class added by stubgen"""
        def __init__(self) -> None: ...

    class ViewerOverlay(WindowOverlay):
        """Class added by stubgen"""
        def __init__(self, scene_viewer: SceneViewer) -> None: ...
        def moveBy(self, delta: QtCore.QPoint) -> None: ...
        def moveTo(self, pos: QtCore.QPoint) -> None: ...
        def onBeginResize(self) -> None: ...
        def onColorSchemeChanged(self) -> None: ...
        def onEndResize(self) -> None: ...
        def onInitWindow(self) -> None: ...
        def onLayoutChanged(self) -> None: ...
        def onMoveContainerWindow(self, new_pos: QtCore.QPoint, old_pos: QtCore.QPoint) -> None: ...
        def onResizing(self) -> None: ...
        def onSizeChanged(self) -> None: ...
        def onViewerActivated(self) -> None: ...
        def onViewerDeactivated(self) -> None: ...
        def onWindowPlacement(self) -> None: ...
        def sceneViewer(self) -> SceneViewer: ...

    class XMLMenuParser(object):
        """Class added by stubgen"""
        def __init__(self, context: str ='', kwargs: dict[str, Any] | None=None, kwargsfunc=Callable, xmlfilename: Path | str | None=None, xmlstring: str | None=None) -> None: ...
        def generateMenu(self, kwargs: dict[str, Any], menu:qt.Menu | None=None, actionitem_callback: Callable[[str], None] | None=None) -> None: ...
        def handleKeyPress(self, keystring: str, kwargs: dict[str, Any], actionitem_callback: Callable | None=None, hotkey_context: str | None=None) -> None: ...
        def hotkeyContext(self) -> str: ...
        def parseFile(self, xmlfile: Path | str) -> None: ...
        def parseFiles(self, xmlfilename: str) -> None: ...
        def parseString(self, xmlstring: str) -> None: ...
        def setHotkeyContext(self, hotkey_context) -> None: ...

class RadialItem:
    """

    hou.RadialItem

    RELATED

      * hou.ui.RadialMenu

      * hou.ui.RadialScriptItem

      * hou.ui.RadialSubmenu


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def destroy(self) -> None:
        """

        destroy(self)

            This method is deprecated, and it has no effect. To remove an item
            from a submenu, use hou.ui.RadialSubmenu.remove instead. To
            unregister a top-level menu, use hou.ui.RadialMenu.destroy.


        """
    def type(self) -> EnumValue:
        """

        type(self) -> hou.radialItemType

            Returns this radial menu item's type.


        """

class RadialScriptItem(RadialItem):
    """

    hou.RadialScriptItem

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isSubmenu(self) -> bool:
        """

        isSubmenu(self) -> bool

            Returns whether this item is a submenu or action.


        """
    def label(self) -> str:
        """

        label(self) -> str

            Returns this radial menu item's label.


        """
    def setLabel(self, s: str) -> None:
        """

        setLabel(self)

            Sets this radial menu item's label.


        """
    def icon(self) -> str:
        """

        icon(self) -> str

            Returns this radial menu item's icon.


        """
    def setIcon(self, s: str) -> None:
        """

        setIcon(self)

            Sets this radial menu item's icon.


        """
    def check(self) -> str:
        """

        check(self) -> str

            Returns a Python expression used to determine the radial menu item's
            checked state.


        """
    def setCheck(self, s: str) -> None:
        """

        setCheck(self)

            Sets the Python expression used to determine the radial menu item's
            checked state.


        """
    def script(self) -> str:
        """

        script(self) -> str

            Returns Python code that will be run when the radial menu item is
            activated.


        """
    def setScript(self, s: str) -> None:
        """

        setScript(self)

            Sets the Python code that will be run when the radial menu item is
            activated.


        """
    def shortcut(self) -> str:
        """

        shortcut(self) -> str

            Returns a string description of the shortcut for selecting this
            radial menu item.


        """
    def setShortcut(self, s: str) -> None:
        """

        setShortcut(self)

            Sets the shortcut for selecting this radial menu item.


        """
    def setActionCallback(self, callback: Callable) -> None:
        """

        setActionCallback(self)

            Sets the callback that will be used this menu item is selected.

            For dynamic menus (i.e., self.isSubmenu() must be True),
            radialmenu.setRadialMenu() may be called in side the function.
            Alternatively, either hou.ui.injectRadialItem or
            hou.ui.injectRadialMenu should be called to dynamically populate the
            menu.

            Note that this is only applicable to temporary items created via
            hou.ui.createRadialItem. For registered menu items, the script text
            will be used.


        """
    def setCheckCallback(self, callback: Callable) -> None:
        """

        setCheckCallback(self)

            Sets the callback to determine the item's checked state. This is
            only used if the item is an action (i.e., self.isSubmenu() returns
            False).

            Note that this is only applicable to temporary items created via
            hou.ui.createRadialItem. For registered menu items, the script text
            will be used.


        """

class RadialSubmenu(RadialItem):
    """

    hou.RadialSubmenu

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def label(self) -> str:
        """

        label(self) -> str

            Returns this submenu's label.


        """
    def setLabel(self, s: str) -> None:
        """

        setLabel(self)

            Sets this submenu's label.


        """
    def shortcut(self) -> str:
        """

        shortcut(self) -> str

            Returns a string description of the shortcut for selecting this
            submenu.


        """
    def setShortcut(self, s: str) -> None:
        """

        setShortcut(self)

            Sets the shortcut for selecting this submenu.


        """
    def remove(self, location: EnumValue) -> None: ...
    def item(self, location: EnumValue) -> Optional[RadialItem]:
        """

        item(self, [Hom:hou.radialItemLocation]) -> hou.RadialItem

            Returns the radial menu item at the specified location. Returns None
            if no radial menu item exists at the specified location.


        """
    def items(self) -> dict[EnumValue, RadialItem]:
        """

        items(self) -> dict of hou.radialItemLocation to hou.RadialItem

            Returns a dict mapping radial item locations to radial menu items.


        """
    def createSubmenu(self, location: EnumValue, label: Optional[str] = None, shortcut: Optional[str] = None) -> RadialSubmenu:
        """

        createSubmenu(self, [Hom:hou.radialItemLocation], label=None) ->
        hou.RadialSubmenu

            Creates a submenu at the specified location (replacing any existing
            radial menu item) and initializing the submenu's label. The new
            submenu is returned.


        """
    def createScriptItem(self, location: EnumValue, label: Optional[str] = None, icon: Optional[str] = None, check: Optional[str] = None, script: Optional[str] = None, shortcut: Optional[str] = None) -> RadialScriptItem:
        """

        createScriptItem(self, [Hom:hou.radialItemLocation], label=None,
        icon=None, check=None, script=None) -> hou.RadialScriptItem

            Creates a script item at the specified location (replacing any
            existing radial menu item) and initializing the script item's label,
            icon, expression specifying the checked state, and script executed
            when the item is activated. The new script item is returned.


        """

class RadialMenu:
    """

    hou.RadialMenu
      * Use hou.ui.radialMenus or hou.ui.radialMenu to get a reference to an
        existing menu.

      * Use hou.ui.createRadialMenu to create a new menu.

    RELATED

      * hou.ui.radialMenu

      * hou.ui.radialMenus

      * hou.ui.createRadialMenu

      * hou.RadialItem

      * hou.RadialSubmenu

      * hou.RadialScriptItem


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def destroy(self) -> None:
        """

        destroy(self)

            Deletes this radial menu. The menu will be unregistered.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns this radial menu's name.


        """
    def categories(self) -> str:
        """

        categories(self) -> str

            Returns a comma separated list of this radial menu's categories.


        """
    def setCategories(self, s: str) -> None:
        """

        setCategories(self, categories)

            Sets this radial menu's categories (specified as a comma separated
            list).


        """
    def sourceFile(self) -> str:
        """

        sourceFile(self) -> str

            Returns the name of the file from which this radial menu was loaded
            or saved.


        """
    def save(self, s: str) -> None:
        """

        save(self, filename)

            Saves this radial menu to the specified file.


        """
    def root(self) -> RadialItem:
        """

        root(self) -> hou.RadialItem

            Returns the root menu item. For regular menus, hou.ui.RadialSubmenu
            will be returned. For script menus, hou.ui.RadialScriptItem will be
            returned.


        """
    def label(self) -> str:
        """

        label(self) -> str

            This method is deprecated. Use root().label() instead


        """
    def setLabel(self, s: str) -> None:
        """

        setLabel(self)

            This method is deprecated. Use root().setLabel() instead


        """
    def shortcut(self) -> str:
        """

        shortcut(self) -> str

            This method is deprecated. Use root().shortcut() instead


        """
    def setShortcut(self, s: str) -> None:
        """

        setShortcut(self)

            This method is deprecated. Use root().setShortcut() instead


        """
    def item(self, location: EnumValue) -> RadialItem:
        """

        item(self, [Hom:hou.radialItemLocation]) -> hou.RadialItem

            This method is deprecated. Use root().item() instead. Raises
            hou.NotAvailable if the root is a script menu.


        """
    def items(self) -> dict[EnumValue, RadialItem]:
        """

        items(self) -> dict of hou.radialItemLocation to hou.RadialItem

            This method is deprecated. Use root().items() instead Raises
            hou.NotAvailable if the root is a script menu.


        """
    def createSubmenu(self, location: EnumValue, label: Optional[str] = None, shortcut: Optional[str] = None) -> RadialSubmenu:
        """

        createSubmenu(self, [Hom:hou.radialItemLocation], label=None) ->
        hou.RadialSubmenu

            This method is deprecated. Use root().createSubmenu() instead.
            Raises hou.NotAvailable if the root is a script menu.


        """
    def createScriptItem(self, location: EnumValue, label: Optional[str] = None, icon: Optional[str] = None, check: Optional[str] = None, script: Optional[str] = None, shortcut: Optional[str] = None) -> RadialScriptItem:
        """

        createScriptItem(self, [Hom:hou.radialItemLocation], label=None,
        icon=None, check=None, script=None) -> hou.RadialScriptItem

            This method is deprecated. Use root().createScriptItem() instead.
            Raises hou.NotAvailable if the root is a script menu.


        """

class Ramp:
    """

    hou.Ramp

    A Ramp represents a function that yields either floating point values or
    colors. You can evaluate this function between 0.0 and 1.0, and the
    function's shape is determined by a sequence of values at key positions
    between 0.0 and 1.0.

    If you evaluate a ramp parameter on a node, Houdini will return a Ramp
    object.

    You can check the curve basis of a ramp you get from a parameter by
    calling the hou.Ramp.basis method,which returns a hou.rampBasis value.

    In the Hermite basis, the curve passes through the odd control points,
    and the even control points control the tangent at the previous point.
    See the Wikipedia article on Hermite spline curves for more information.

    To get a smooth curve, you should evenly space the control points.

    RELATED

      * spline()


    """
    thisown: Incomplete
    def __init__(self, basis: Sequence[EnumValue], keys: Sequence[float], values: Sequence[float]|Sequence[Tuple[float, float, float]]) -> None:
        """

        __init__(self, basis, keys, values) -> float


            basis
                A sequence of hou.rampBasis values, one for each key. The ramp
                basis for a key determines how Houdini interpolates from the key
                up until the next key. If there is no next key, Houdini will
                hold the value constant until the end of the [0,1] domain,
                regardless of the ramp basis.

            keys
                A sequence of floats, one for each key, each between 0.0 and
                1.0, inclusive. Each key represents the location in the [0,1]
                domain of its corresponding value.

            values
                A sequence of values, where each value corresponds to a key.
                When asked to evaluate at a value where there is no key, Houdini
                will interpolate between adjacent values using the basis
                function for the key on the left.

                This sequence is either a sequence of floats or a sequence of
                triples of floats. In the former case, the newly-created ramp
                will evaluate to a single floating-point value. In the latter
                case, it will evaluate to a color.

            Raises hou.InvalidSize if the keys and values sequences are not not
            same size, or if values contains subsequences of floats that are not
            3 elements long.

          > >>> lin = hou.rampBasis.Linear
          > 
          > # Create a ramp that linearly interpolates between 2.5 and 4.5.
          > >>> r = hou.Ramp((lin, lin), (0, 1), (2.5, 4.5))
          > >>> r
          > <hou.Ramp is_color=False num_keys=2 data=((t=0, 2.5), (t=1, 4.5))>
          > >>> r.lookup(0.0)
          > 2.5
          > >>> r.lookup(0.5)
          > 3.5
          > >>> r.lookup(1.0)
          > 4.5
          > 
          > # Create a color ramp that linearly interpolates from black to red.
          > >>> hou.Ramp((lin, lin), (0, 1), ((0.0, 0.0, 0.0), (1.0, 0.0, 0.2)))
          > <hou.Ramp is_color=True num_keys=2 data=((t=0, rgb=(0, 0, 0)), (t=1, rgb=(1, 1, 1)))>

        """
    __swig_destroy__: Incomplete
    def isColor(self) -> bool:
        """

        isColor(self) -> bool

            Return True if this is a color ramp, and False if it is a single
            float ramp.


        """
    def colorType(self) -> EnumValue:
        """

        colorType(self) -> colorType

            If this is a color ramp, return the color space that is used during
            interpolation. The default is hou.colorType.RGB.

            Raises hou.OperationFailed if this ramp is not a color ramp.


        """
    def setColorType(self, enum_value: EnumValue) -> None:
        """

        setColorType(self, hou.colorType)

            If this is a color ramp, set the color space that is used during
            interpolation. The default is hou.colorType.RGB.

            To obtain a more perceptually uniform interpolation, use
            hou.colorType.LAB. To obtain a ramp that matches the rainbow, use
            hou.colorType.HSV.

            Raises hou.OperationFailed if this ramp is not a color ramp.


        """
    def basis(self) -> Tuple[EnumValue, ...]:
        """

        basis(self) -> tuple of hou.rampBasis enum values

            Return a tuple of hou.rampBasis enumeration values that determine
            how Houdini interpolates between the keys in the ramp. See
            hou.Ramp.__init__ for more information.


        """
    def keys(self) -> Tuple[float, ...]:
        """

        keys(self) -> tuple of float

            Return a tuple of floats between 0.0 and 1.0 containing the ramp key
            positions. See hou.Ramp.__init__ for more information.


        """
    def lookup(self, pos: float) -> float|Tuple[float, float, float]:
        """

        lookup(self, position) -> float or tuple

            Return the value of the ramp at a specified position in the interval
            [0.0, 1.0). position will be clamped if outside this interval.

            Returns a float (for floating-point value ramps) or a tuple of 3
            floats (for color ramps).


        """
    def values(self) -> Tuple[float|Tuple[float, float, float],...]:
        """

        values(self) -> tuple of float or tuple of tuple of float

            Return a tuple of floats (for a float ramp) or a tuple of tuples of
            3 floats (for a color ramp) corresponding to the values in the ramp
            stored at each key. See hou.Ramp.__init__ for more information.


        """

class RampParmTemplate(ParmTemplate):
    """

    hou.RampParmTemplate

    Parameter template for a ramp parameter.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, ramp_parm_type: EnumValue, default_value: int = ..., default_basis: EnumValue|None = ..., show_controls: bool = ..., color_type: EnumValue|None = ..., disable_when: str|None = ..., is_hidden: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ..., default_expression_language: EnumValue = ...) -> None:
        '''

        __init__(self, name, label, ramp_parm_type, default_value=2,
        default_basis=None, show_controls=True, color_type=None,
        disable_when=None, is_hidden=False, help=None, script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression_language=hou.scriptLanguage.Hscript)

            Construct a new RampParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            ramp_parm_type
                See the parmType method for more information.

            default_value
                The default number of ramp keys in new ramp parameter instances.
                See the defaultValue method for more information.

            default_basis
                See the defaultBasis method for more information. If this
                parameter is not specified it defaults to hou.rampBasis.Linear.

                The following example uses a Catmull-Rom basis:

              > r = hou.RampParmTemplate(
              >     \\"myRamp\\", \\"My Ramp\\", hou.rampParmType.Color,
              >     default_basis=hou.rampBasis.CatmullRom)

            show_controls
                See the showsControls method for more information.

            color_type
                See the colorType method for more information. If this parameter
                is not specified it defaults to hou.colorType.RGB.

                The following example uses an L*a*b* color space:

              > r = hou.RampParmTemplate(
              >     \\"myRamp\\", \\"My Ramp\\", hou.rampParmType.Color,
              >     color_type=hou.colorType.LAB)

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        '''
    __swig_destroy__: Incomplete
    def defaultValue(self) -> int:
        """

        defaultValue(self) -> int

            Return this is the default number of ramp keys in new ramp parameter
            instances.


        """
    def setDefaultValue(self, default_value: int) -> None:
        """

        setDefaultValue(self, default_value)

            Set the default number of ramp keys to be used in new ramp parameter
            instances.


        """
    def defaultExpression(self) -> str:
        """

        defaultExpression(self) -> string

            Return the expression, which when evaluated, returns the number of
            ramp keys to be used in new ramp parameter instances.

            The default expression takes precedence over the default value. If
            the default expression is not set (i.e. an empty string), then the
            default value is used instead.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
    def setDefaultExpression(self, default_expression: str) -> None:
        """

        setDefaultExpression(self, default_expression)

            Set the default expression, which when evaluated, returns the number
            of ramp keys to be used in new ramp parameter instances.

            If default_expression is the empty string, then the default
            expression is unset.


        """
    def defaultExpressionLanguage(self) -> EnumValue:
        """

        defaultExpressionLanguage(self) -> hou.scriptLanguage

            Return the default expression language.

            The default expression language only applies if the default
            expression is set. If the default expression is not set, then the
            expression language is set to hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: EnumValue) -> None:
        """

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language.

            See the defaultExpressionLanguage method for more information.


        """
    def parmType(self) -> EnumValue: ...
    def setParmType(self, ramp_parm_type: EnumValue) -> None:
        """

        setParmType(self, ramp_parm_type)

            Set the type of this ramp to a hou.rampParmType enum value.


        """
    def defaultBasis(self) -> EnumValue:
        """

        defaultBasis(self) -> hou.rampBasis enum value

            The basis function used to control how values are interpolated
            between ramp keys. This value may be None to denote
            hou.rampBasis.Linear. This is merely a convenience wrapper for the
            ramp parameter specific tag and a value of None means that the tag
            does not exist.

            See hou.rampBasis for more information.


        """
    def setDefaultBasis(self, default_basis: EnumValue) -> None:
        """

        setDefaultBasis(self, ramp_basis)

            Set the basis function used to control how values are interpolated
            between ramp keys. ramp_basis is a hou.rampBasis enum value. This is
            a convenience wrapper for the creating ramp parameter specific tag.


        """
    def colorType(self) -> EnumValue:
        """

        colorType(self) -> hou.colorType enum value

            The color space in which to interpolate color ramp keys.

            See hou.colorType for more information on color spaces.


        """
    def setColorType(self, color_type: EnumValue) -> None:
        """

        setColorType(self, color_type)

            Set the color space in which to interpolate color ramp keys to a
            hou.colorType enum value.


        """
    def showsControls(self) -> bool:
        """

        showsControls(self) -> bool

            Return whether new instances of this ramp parameter have the
            controls expanded by default. The user may later expand or collapse
            the ramp controls on the parameter.


        """
    def setShowsControls(self, on: bool) -> None:
        """

        setShowsControls(self, on)

            Set whether new instances of this ramp parameter have the controls
            expanded by default.


        """
    def parmTemplates(self) -> Tuple[ParmTemplate, ...]:
        """

        parmTemplates(self) -> tuple of hou.ParmTemplate

            Return a tuple of copies of the ramp instance parm templates.


        """

class RedrawBlock:
    """

    hou.RedrawBlock

    Use this class to collect multiple redraws for any Python code block and
    only redraw once.


    """
    thisown: Incomplete
    def __init__(self) -> None:
        """

        __init__(self)

            Construct a new RedrawBlock.

            The constructor should only be called from within a with statement.
            For example:

          > with hou.RedrawBlock() as redrawblock:
          >     #
          >     # Perform tasks
          >     #

            All tasks within the code block will have their redraw requests
            collected and deferred until after the code in the block is
            complete. Once the code block is complete (or an exception causes a
            jump out of the block), a single redraw per window with redraw
            requests will be performed. This cuts down on redraw flickering for
            a long set of commands.


            WARNING
                Use care with Redraw Blocks. If an operation requires user
                interaction it should not be within a Redraw Block, otherwise
                the user will not see any prompts or the results of their
                actions.


        """
    __swig_destroy__: Incomplete
    def __enter__(self) -> RedrawBlock: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class ReferencePlane:
    """

    hou.ReferencePlane

    The reference grid (a.k.a. reference plane) in the scene viewer pane
    tab.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def sceneViewer(self) -> SceneViewer:
        """

        sceneViewer(self) -> hou.SceneViewer

            Return the scene viewer containing this plane.


        """
    def isVisible(self) -> bool:
        """

        isVisible(self) -> bool

            Return whether the grid is visible in the viewer.


        """
    def setIsVisible(self, on: bool) -> None:
        """

        setIsVisible(self, on)

            Make this grid visible or invisible in the viewer.


        """
    def transform(self) -> Matrix4:
        """

        transform(self) -> hou.Matrix4

            Return the transformation matrix for this plane.

            When the transformation matrix is the identity matrix, the plane's
            bottom-left corner is at the origin and it sits in the XY plane. In
            this orientation, increasing the number of cells in x or the size of
            a cell in x grows the plane outward from the origin along the
            x-axis. Similarly, increasing the number of cells or size of a cell
            in y grows the plane along the y-axis.

            Note that the transformation matrix does not contain any scale
            information. The reference plane extends to infinity.

            The following function will return the normal of the plane:

          > def normal(reference_plane):
          >     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()

        """
    def setTransform(self, matrix: Matrix4) -> None:
        """

        setTransform(self, matrix)

            Set the transformation matrix for this plane to a hou.Matrix4.

            This matrix is used to translate and rotate the plane. See the
            transform method for more information.

            Note that scale information inside the transformation matrix is
            ignored.

            The following function will change the position of the origin of the
            plane:

          > def set_origin(reference_plane, new_origin):
          >     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(reference_plane))
          >     reference_plane.setTransform(reference_plane.transform() * translation)
          > 
          > def origin(reference_plane):
          >     return hou.Vector3(0, 0, 0) * reference_plane.transform()

            The following function will change the normal of the plane:

          > def set_normal(reference_plane, normal_vector):
          >     existing_rotation = hou.Matrix4(reference_plane.transform().extractRotationMatrix3())
          >     rotation = existing_rotation * normal(reference_plane).matrixToRotateTo(normal_vector)
          >     translation = hou.hmath.buildTranslate(origin(reference_plane))
          >     reference_plane.setTransform(rotation * translation)
          > 
          > def normal(reference_plane):
          >     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()
          > 
          > def origin(reference_plane):
          >     return hou.Vector3(0, 0, 0) * reference_plane.transform()

        """
    def cellSize(self) -> Tuple[float, ...]:
        """

        cellSize(self) -> tuple of float

            Return the x and y sizes (width and height) of one cell in the grid
            of cells. The return value is a tuple of two floats.


        """
    def setCellSize(self, size: Sequence[float]) -> None:
        """

        setCellSize(self, size)

            Change the x and y sizes (width and height) of each cell in the grid
            of cells. size is a sequence of two floats.

            Changing the size of each cell will change the total size of the
            grid.


        """
    def numberOfCellsPerRulerLine(self) -> Tuple[int, ...]:
        """

        numberOfCellsPerRulerLine(self) -> tuple of int

            Return the number of cells in the x and y directions between ruler
            lines. Ruler lines are darker than the normal lines drawn between
            grid cells.


        """
    def setNumberOfCellsPerRulerLine(self, number: Sequence[int]) -> None: ...

class RenderGallery(PathBasedPaneTab):
    """

    hou.RenderGallery

    Class representing a render gallery pane.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete

class RopNode(OpNode):
    """

    hou.RopNode

    Represents a render output node.

    RELATED

      * render


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns whether this node's bypass flag is on.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turns the node's bypass flag on or off, making this node have no
            effect.


        """
    def isLocked(self) -> bool:
        """

        isLocked(self) -> bool

            Returns whether this node's lock flag is on.


        """
    def setLocked(self, on: bool) -> None:
        """

        setLocked(self, on)

            Sets this node's lock flag on or off. The lock flag caches the
            node's data and the data from its inputs and prevents them from
            being recalculated during cooking.


        """
    def inputDependencies(self) -> Tuple[Tuple[Node, Tuple[float, ...]], ...]:
        """

        inputDependencies(self) -> (tuple of hou.RopNode, tuple of tuples of
        float)

            Returns the input dependencies of the ROP node, consisting of ROPs,
            and the frames that need to be be rendered prior to rendering the
            ROP.

            This method returns a tuple of two elements:

          * The first element is a sequence of the hou.RopNode objects
            representing the input dependencies.

          * The second element is a sequence, where each element corresponds to
            the RopNode object at the same position in the first sequence, and
            is a sequence of floats representing the frames that must be
            rendered for the corresponding RopNode.


        """
    def render(self, frame_range: Sequence[float]|None = ..., res: Sequence[int]|None = ..., output_file: str|None = ..., output_format: str = ..., to_flipbook: bool = ..., quality: int = ..., ignore_inputs: bool = ..., method=..., ignore_bypass_flags: bool = ..., ignore_lock_flags: bool = ..., verbose: bool = ..., output_progress: bool = ...) -> None:
        """

        render(self, frame_range=(), res=(), output_file=None,
        output_format=None, to_flipbook=False, quality=2, ignore_inputs=False,
        method=RopByRop, ignore_bypass_flags=False, ignore_lock_flags=False,
        verbose=False, output_progress=False)

            Renders this node and optionally any of its inputs. Inputs are
            recursively processed (unless ignore_inputs is True), so that all
            descendants are rendered in the proper order before this node is
            rendered.


            frame_range
                Sequence of 2 or 3 values, overrides the frame range and frame
                increment to render. The first two values specify the start and
                end frames, and the third value (if given) specifies the frame
                increment. If no frame increment is given and the ROP node
                doesn't specify a frame increment, then a value of 1 will be
                used. If no frame range is given, and the ROP node doesn't
                specify a frame range, then the current frame will be rendered.

            res
                Sequence of two scaling factors that will be used to scale the
                resolution of the image, along the x- and y-axes. The scaling
                factors will be applied to the node and all dependencies that
                are also rendered.

            output_file
                Overrides the location to which the image is written.

            output_format
                Overrides the format of the image.

            to_flipbook
                If True, renders this node to a flipbook.

            quality
                Overrides the render quality.

            ignore_inputs
                If True, renders only this node (does not render any of its
                dependencies).

            method
                Either hou.renderMethod.RopByRop or
                hou.renderMethod.FrameByFrame. The default is ROP by ROP: each
                ROP will render its entire sequence before proceeding to the
                next ROP. If you specify FrameByFrame, all ROPs will render the
                first frame, then the second, etc.

                This parameter is only relevant when rendering ROPs in a
                dependency network.

            ignore_bypass_flags
                If True, renders this node even if its bypass flag is on.

            ignore_lock_flags
                If True, ignores any lock flags on this node and its
                dependencies.

            verbose
                If True, then the method will print messages during the render.
                For example, a message is printed when each frame starts
                rendering.

            output_progress
                If True, then the method will print Alfred-style progress
                messages. This argument does not apply if the verbose argument
                is set to False.


        """
    def removeAllRenderEventCallbacks(self) -> None:
        """

        removeAllRenderEventCallbacks(self)

            Remove all render event callbacks added to this node.

            See hou.OpNode.addRenderEventCallback for more information.


        """
    def addRenderEventCallback(self, callback: Callable[[RopNode, EnumValue, float], None], run_before_script: bool = ...) -> None:
        '''

        addRenderEventCallback(self, callback, run_before_script = False)

            Registers a Python callback that Houdini call whenever a render
            event occurs on this particular node instance. The event callback is
            run immediately before or after the correspoding script callback on
            the ROP node, such as the Pre Frame or Post Frame script, depending
            on the value of run_before_script.

            Callbacks only persist for the current session -- they\'re not saved
            to the .hip file. If you want persistent callbacks in every session,
            you can add them in code in 456.py (runs when the user opens a .hip
            file). See where to add Python scripting for more information.
            Alternatively, you can add your callback to the script hook
            parameters on the ROP node parameter interface.


            callback
                A callable Python object, such as a function or bound method.
                The callback is invoked with the hou.RopNode instance that it
                was added to, the hou.ropRenderEventType that indicates the type
                of event that occurred, and the time at which the event occured.

            run_before_script
                A boolean value that indicates whether or not the callback
                should be inovked before the correpsonding script callback on
                the ROP node. By default, callbacks are invoked after the script
                has completed.


            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to a render event.

            The following example shows to set up a function that\'s called
            whenever a ROP node finishes rendering a frame

          > 
          > def frame_completed(rop_node, render_event_type, time):
          >     if render_event_type = hou.ropRenderEventType.PostFrame:
          >         print(\\"{} finished rendering frame at t={}\\", node.name(), time)
          > 
          > hou.node(\\"/out/geometry1\\").addRenderEventCallback(frame_completed)

            See also hou.RopNode.removeRenderEventCallback and
            hou.RopNode.removeAllRenderEventCallbacks.


        '''
    def removeRenderEventCallback(self, callback: Callable[[RopNode, EnumValue, float], None]) -> None:
        """

        removeRenderEventCallback(self, callback)

            Removes a render event callback that was previously added on this
            node.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.RopNode.addRenderEventCallback for more information.


        """

class SceneGraphTree(PathBasedPaneTab):
    """

    hou.SceneGraphTree

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def showInactivePrimitives(self) -> bool:
        """

        showInactivePrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether inactive USD primitives appear in the tree.


        """
    def setShowInactivePrimitives(self, show: bool) -> None:
        """

        setShowInactivePrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether inactive USD primitives appear in the tree.


        """
    def showInvisiblePrimitives(self) -> bool:
        """

        showInvisiblePrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether invisible USD primitives appear in the tree.


        """
    def setShowInvisiblePrimitives(self, show: bool) -> None:
        """

        setShowInvisiblePrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether invisible USD primitives appear in the tree.


        """
    def showOverPrimitives(self) -> bool:
        """

        showOverPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether pure override USD primitives appear in the tree.


        """
    def setShowOverPrimitives(self, show: bool) -> None:
        """

        setShowOverPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether pure override USD primitives appear in the tree.


        """
    def showClassPrimitives(self) -> bool:
        """

        showClassPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether class specifier USD primitives appear in the tree.


        """
    def setShowClassPrimitives(self, show: bool) -> None:
        """

        setShowClassPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether class specifier USD primitives appear in the tree.


        """
    def showPrototypePrimitives(self) -> bool:
        """

        showPrototypePrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether implicit prototype primitives appear in the tree.


        """
    def setShowPrototypePrimitives(self, show: bool) -> None:
        """

        setShowPrototypePrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether implicit prototype primitives appear in the tree.


        """
    def showLayerInfoPrimitives(self) -> bool:
        """

        showLayerInfoPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether Houdini Layer Info primitives appear in the tree.


        """
    def setShowLayerInfoPrimitives(self, show: bool) -> None:
        """

        setShowLayerInfoPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether Houdini Layer Info primitives appear in the tree.


        """
    def showHiddenInUiPrimitives(self) -> bool:
        """

        showHiddenInUiPrimitives(self) -> bool

            Return the state of the toggle on the Scene Graph Tree toolbar that
            controls whether primitives configured to be hidden in the UI should
            appear in the tree.


        """
    def setShowHiddenInUiPrimitives(self, show: bool) -> None:
        """

        setShowHiddenInUiPrimitives(self, show)

            Set the state of the toggle on the Scene Graph Tree toolbar that
            controls whether primitives configured to be hidden in the UI appear
            in the tree.


        """
    def allColumns(self) -> Tuple[str, ...]:
        """

        allColumns(self) -> tuple of str

            Return a tuple of strings with the symbolic names of all the columns
            that can be enabled in the scene graph tree. This corresponds to the
            set of all columns listed under the scene graph tree settings menu.


        """
    def visibleColumns(self) -> Tuple[str, ...]:
        """

        visibleColumns(self) -> tuple of str

            Return a tuple of strings with the symbolic names of all the columns
            that are currently enabled in the scene graph tree. This corresponds
            to the set of columns listed under the scene graph tree settings
            menu that are checked.


        """
    def setVisibleColumns(self, columns: Sequence[str]) -> None:
        """

        setVisibleColumns(self, columns)

            Return a tuple of strings with the symbolic names of all the columns
            that are currently enabled in the scene graph tree. This corresponds
            to the set of columns listed under the scene graph tree settings
            menu that are checked.


        """
    def filterPattern(self) -> str:
        """

        filterPattern(self) -> str

            Return the current value set in the scene graph tree filter field.
            Only primitives that match this pattern (and their ancestor
            primitives) appear in the scene graph tree. This pattern supports
            all the standard primitive pattern matching capabilities described
            in Primitive matching patterns.


        """
    def setFilterPattern(self, pattern: str) -> None:
        """

        setFilterPattern(self, pattern)

            Set the pattern string in the scene graph tree filter field.


        """
    def splitPosition(self) -> float:
        """

        splitPosition(self) -> float

            Return a number indicating the position of the splitter bar that
            separates the scene graph tree from the collection tree. The value
            will between -1.0 and 2.0. Any value between 0.0 and 1.0 indicates
            that both panes are visible, and the value indicates the proportion
            of the space taken up by the collection tree (i.e. the value
            reflects the distance of the splitter bar from the bottom of the
            pane).

            A value greater than 1.0 indicates that the splitter bar is at the
            top of the pane, hiding the scene graph tree. Subtracting 1.0 from
            the value indicates the position of the splitter bar before the
            scene graph tree was collapsed.

            A value less than 0.0 indicates that the splitter bar is at the
            bottom of the pane, hiding the collection tree. Adding 1.0 to the
            value indicates the position of the splitter bar before the
            collection tree was collapsed.


        """
    def setSplitPosition(self, position: float) -> None:
        """

        setSplitPosition(self, position)

            Set the position of the splitter bar that separates the scene graph
            tree from the collection tree. This value must be between -1.0 and
            2.0. See splitPosition for a description of the meaning of the
            position value.


        """
    def collectionPrimitives(self) -> str:
        """

        collectionPrimitives(self) -> str

            Return the string pattern that controls which USD primitives are
            searched to populate the collection panel at the bottom of the scene
            graph tree.


        """
    def setCollectionPrimitives(self, pattern: str) -> None:
        """

        setCollectionPrimitives(self, pattern)

            Set the string pattern that controls which USD primitive are
            searched to populate the collection panel at the bottom of the scene
            graph tree.


        """
    def collectionFilterPattern(self) -> str:
        """

        collectionFilterPattern(self) -> str

            Return the current value set in the collection tree filter field.
            Only collections and selection rules that match this pattern (and
            their ancestors) appear in the collection tree. This pattern uses
            standard Houdini string matching techniques to test each entry in
            the tree.


        """
    def setCollectionFilterPattern(self, pattern: str) -> None:
        """

        setCollectionFilterPattern(self, pattern)

            Set the pattern string in the collection tree filter field.


        """
    def collapsePrimitives(self, prims: Sequence[str|pxr.Sdf.Path]) -> None:
        """

        collapsePrimitives(self, paths)

            Collapse the scene graph tree locations indicated by the strings or
            pxr.Sdf.Path objects in the iterable paths parameter. Descendants of
            these primitives will no longer be visible in the tree. If a
            primitive in paths is not currently visible or is already collapsed,
            the tree will not change.


        """
    def expandPrimitives(self, prims: Sequence[str|pxr.Sdf.Path], collapse_others: bool = ..., expand_leaf_primitives: bool = ...) -> None:
        """

        expandPrimitives(self, paths, collapse_others=False,
        expand_leaf_primitives=False)

            Expand the scene graph tree such that the locations indicated by the
            strings or pxr.Sdf.Path objects in the iterable paths parameter are
            visible. If collapse_others is True, all scene graph tree locations
            will be collapsed before expanding any primitives, leaving the tree
            in a state where exactly the provided list of scene graph locations
            will be visible. If expand_leaf_primitives is True, then the tree
            will be expanded such that all the primitives in the paths object
            will not just be made visible, but will be expanded, making all of
            their children visible as well.


        """
    def expandedPrimitives(self, include_leaf_primitives: bool = ...) -> Tuple[pxr.Sdf.Path,...]:
        """

        expandedPrimitives(self, include_leaf_primitives=False) -> list of
        pxr.Sdf.Path

            Return a list of scene graph locations that are expanded in the
            scene graph tree. If include_leaf_primitives is True, all children
            of expanded primitives will also be returned in the list,
            effectively returning a list of all visible primitives in the tree.
            Otherwise only primitives that are actually expanded are returned,
            meaning that no leaf primitives (which have no children) will ever
            be returned in this mode.


        """

class SceneViewer(PathBasedPaneTab):
    """

    hou.SceneViewer

    Pane tab type dedicated to displaying the current scene. This is usually
    the biggest pane in the center of the pane layout.

    OVERVIEW

        A viewer is a type of pane that shows the scene. The viewer's
        contents is conceptually divided into viewports. By default, the
        scene viewer shows a single viewport, the Perspective view. However,
        you can use the view layout controls to, for example, split the view
        into four viewports (Perspective, Top, Front, and Right views).
        Viewports are the parts of the interface that actually display the
        scene to the user.

        To get a reference to a scene viewer, see the following methods:


        hou.ui.paneTabOfType
            Use hou.ui.paneTabOfType(hou.paneTabType.SceneViewer) to get a
            Scene Viewer pane tab in the current pane layout. If the current
            layout has no Scene Viewer pane tab, this returns None.

            To be more precise about which viewer you grab in a possible
            multi-viewer layout, see also hou.ui.curDesktop to get a
            hou.Desktop object representing the current pane layout, and
            hou.Desktop.sceneViewers to get a list of scene viewer pane tabs
            in the current layout.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def viewerType(self) -> EnumValue:
        """

        viewerType(self) -> hou.stateViewerType enum value

            Returns the type of the viewer, either Scene for a viewer looking at
            Objects, SOPs, or DOPs; or SceneGraph for a viewer looking at LOPs.


        """
    def viewports(self) -> Tuple[GeometryViewport, ...]:
        """

        viewports(self) -> tuple of hou.GeometryViewports


        """
    def findViewport(self, name: str) -> Optional[GeometryViewport]:
        """

        findViewport(self, name) -> hou.GeometryViewport


        """
    def curViewport(self) -> GeometryViewport:
        """

        curViewport(self) -> hou.GeometryViewport

            Returns this viewer's current viewport. The current viewport is the
            one containing the mouse cursor. If the cursor is not in a viewport,
            then the selected, or active, viewport is returned.


        """
    def selectedViewport(self) -> GeometryViewport:
        """

        selectedViewport(self) -> hou.GeometryViewport

            Returns this viewer's selected viewport. Viewports can be selected
            by holding [Space] and pressing the [N] key.


        """
    def currentState(self) -> str:
        """

        currentState(self) -> string

            Returns the name of the viewer's current tool state.


        """
    def enterViewState(self, wait_for_exit: bool = False) -> None:
        """

        enterViewState(self, wait_for_exit=False)

            Enters the viewer into view tool state. If wait_for_exit is True,
            then the function will not return until the viewer exits the tool.


        """
    def enterCurrentNodeState(self, wait_for_exit: bool = False) -> None:
        """

        enterCurrentNodeState(self, wait_for_exit=False)

            Enters the viewer into the node-specific tool state of the last
            selected node. If wait_for_exit is True, then the function will not
            return until the viewer exits the tool.


        """
    def enterTranslateToolState(self, wait_for_exit: bool = False) -> None:
        """

        enterTranslateToolState(self, wait_for_exit=False)

            Enters the viewer into translate tool state. This is available only
            for the node contexts that support the move tools. If wait_for_exit
            is True, then the function will not return until the viewer exits
            the tool.


        """
    def enterRotateToolState(self, wait_for_exit: bool = False) -> None:
        """

        enterRotateToolState(self, wait_for_exit=False)

            Enters the viewer into rotate tool state. This is available only for
            the node contexts that support the move tools. If wait_for_exit is
            True, then the function will not return until the viewer exits the
            tool.


        """
    def enterScaleToolState(self, wait_for_exit: bool = False) -> None:
        """

        enterScaleToolState(self, wait_for_exit=False)

            Enters the viewer into scale tool state. This is available only for
            the node contexts that support the move tools. If wait_for_exit is
            True, then the function will not return until the viewer exits the
            tool.


        """
    def setCurrentState(self, state: EnumValue, wait_for_exit: bool = ..., generate: EnumValue = ..., request_new_on_generate: bool = ..., ex_situ_generate: bool = ...) -> None:
        """

        setCurrentState(self, state, wait_for_exit=False,
        generate=hou.stateGenerateMode.Insert, request_new_on_generate=True,
        ex_situ_generate=False)

            Sets the current tool state of the viewer. If wait_for_exit is True,
            then the function will not return until the viewer exits the tool.


            generate
                A hou.stateGenerateMode enumeration value to specify how a new
                node should be generated, inserted inline or into a new branch.


                NOTE
                    Python states do not support node generation, but they do
                    support nodeless states.

                  * Use hou.stateGenerateMode.Enter to enter a node's Python
                    state.

                  * Use hou.stateGenerateMode.Insert to enter a nodeless Python
                    state.

                    See Nodeless Python states for more details.

            request_new_on_generate
                Some states reuse the current node whenever possible. Setting
                this argument to True requests that such states generate a new
                node.

            ex_situ_generate
                Some states do things like initialize their selectors from
                stashed temporary selections or cook selections during
                generation. Such actions make sense when the state is launched
                in situ, but are not desired if the script first changed network
                levels or displayed nodes so that the viewer context the state
                starts with differs from the one the user sees when triggering
                the script. Setting this argument to True tells the state not to
                assume that the viewer context at the time of generation matches
                what the user expects.


        """
    def isCreateInContext(self) -> bool:
        """

        isCreateInContext(self) -> bool


        """
    def isWorldSpaceLocal(self) -> bool:
        """

        isWorldSpaceLocal(self) -> bool

            Returns true if values that would normally be in world space are
            actually in the local space of the current object. This includes
            things like the return values of selectPositions(),
            hou.GeometryViewport::mapToScreen(),
            hou.GeometryViewport::mapToWorld(),
            hou.GeometryViewport().viewPivot(), etc.


        """
    def viewportLayout(self) -> EnumValue:
        """

        viewportLayout(self) -> hou.geometryViewportLayout

            Returns the current viewport layout as a hou.geometryViewportLayout
            value.


        """
    def setViewportLayout(self, layout: EnumValue, single: int = -1) -> None:
        """

        setViewportLayout(self, layout, single=-1)

            Sets the viewer's viewport layout.


            layout
                A hou.geometryViewportLayout value. For example, to set the
                viewer to show four viewports at the corners:

              > viewer_pane.setViewportLayout(hou.geometryViewportLayout.Quad)

            single
                If you specify the layout, this argument lets you specify which
                of the four viewports from the quad view to show as the single

                -1

                Use the current viewport (the viewport the mouse is/was over).

                0

                Use the top-left viewport from the quad layout (usually the Top
                view).

                1

                Use the top-right viewport from the quad layout (usually the
                Perspective view).

                2

                Use the bottom-left viewport from the quad layout (usually the
                Front view).

                3

                Use the bottom-right viewport from the quad layout (usually the
                Right view).


        """
    def selectObjects(self, prompt: str = ..., sel_index: int = ..., allow_drag: bool = ..., quick_select: bool = ..., use_existing_selection: bool = ..., allow_multisel: bool = ..., allowed_types: Sequence[str] = ..., icon: str|None = ..., label: str|None = ..., prior_selection_paths: Sequence[str]|None = ..., prior_selection_ids: int|None = ..., prior_selections: Sequence[str] = ..., toolbox_templategroup: str|None = ..., toolbox1_templategroup: str|None = ..., select_parm: str = ...) -> Tuple[Node,...]:
        '''

        selectObjects(self, prompt=\'Select objects\', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        allow_multisel=True, allowed_types=(\'*\',), icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[],
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\\"\\")
        -> tuple of Nodes


        '''
    def selectGeometry(self, prompt: str = ..., sel_index: int = ..., allow_drag: bool = ..., quick_select: bool = ..., use_existing_selection: bool = ..., initial_selection: str|None = ..., initial_selection_type: EnumValue|None = ..., ordered: bool = ..., geometry_types: Sequence[EnumValue] = ..., primitive_types: Sequence[EnumValue] = ..., allow_obj_sel: bool = ..., icon: str|None = ..., label: str|None = ..., prior_selection_paths: list = ..., prior_selection_ids: list = ..., prior_selections: list = ..., allow_other_sops: bool = ..., consume_selections: bool = ...) -> GeometrySelection:
        '''

        selectGeometry(self, prompt=\'Select geometry\', sel_index=0,
        allow_drag=False, quick_select=False, use_existing_selection=True,
        initial_selection = None, initial_selection_type = None, ordered=False,
        geometry_types=(), primitive_types=(), allow_obj_sel=True, icon=None,
        label=None, prior_selection_paths=[], prior_selection_ids=[],
        prior_selections=[], allow_other_sops=True, consume_selections=True,
        toolbox_templategroup=None, toolbox1_templategroup=None,
        confirm_existing=False, pick_at_obj_level=False, select_parm=\\"\\") ->
        GeometrySelection


        '''
    def selectDynamics(self, prompt: str = ..., sel_index: int = ..., allow_objects: bool = ..., allow_modifiers: bool = ..., quick_select: bool = ..., use_existing_selection: bool = ..., allow_multisel: bool = ..., icon: str|None = ..., label: str|None = ..., prior_selection_paths: Sequence[str]|None = ..., prior_selection_ids: int|None = ..., prior_selections: Sequence[str] = ..., toolbox_templategroup: str|None = ..., toolbox1_templategroup: str|None = ..., select_parm: str = ...) -> Tuple[DopData,...]:
        '''

        selectDynamics(self, prompt=\'Select dynamics objects\', sel_index=0,
        allow_objects=True, allow_modifiers=False, quick_select=False,
        use_existing_selection=True, allow_multisel=True, icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[],
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\\"\\")
        -> tuple of hou.DopData


        '''
    def selectDynamicsPoints(self, prompt: str = ..., sel_index: int = ..., quick_select: bool = ..., use_existing_selection: bool = ..., allow_multisel: bool = ..., only_select_points: bool = ..., object_based_point_selection: bool = ..., use_last_selected_object: bool = ..., icon: str|None = ..., label: str|None = ..., prior_selection_paths: Sequence[str]|None = ..., prior_selection_ids: int|None = ..., prior_selections: Sequence[str] = ..., toolbox_templategroup: str|None = ..., toolbox1_templategroup: str|None = ..., select_parm: str = ...) -> Sequence[Tuple[DopData, GeometrySelection]]:
        '''

        selectDynamicsPoints(self, prompt=\'Select dynamics points\', sel_index=0,
        quick_select=False, use_existing_selection=True, allow_multisel=True,
        only_select_points=True, object_based_point_selection=False,
        use_last_selected_object=False, icon=None, label=None,
        prior_selection_paths=[], prior_selection_ids=[], prior_selections=[],
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\\"\\")
        -> tuple of (hou.DopData, hou.GeometrySelection)


        '''
    def selectDynamicsPolygons(self, prompt: str = ..., sel_index: int = ..., quick_select: bool = ..., use_existing_selection: bool = ..., object_based_point_selection: bool = ..., use_last_selected_object: bool = ..., icon: str|None = ..., label: str|None = ..., prior_selection_paths: Sequence[str]|None = ..., prior_selection_ids: int|None = ..., prior_selections: Sequence[str] = ..., toolbox_templategroup: str|None = ..., toolbox1_templategroup: str|None = ..., select_parm: str = ...) -> Sequence[Tuple[DopData, GeometrySelection]]:
        '''

        selectDynamicsPolygons(self, prompt=\'Select dynamics polygons\',
        sel_index=0, quick_select=False, use_existing_selection=True,
        object_based_point_selection=False, use_last_selected_object=False,
        icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[],
        prior_selections=[], toolbox_templategroup=None,
        toolbox1_templategroup=None, select_parm=\\"\\") -> tuple of (hou.DopData,
        hou.GeometrySelection)


        '''
    def selectSceneGraph(self, prompt: str = ..., preselection: Sequence[str] = ..., prim_mask: EnumValue = ..., quick_select: bool = ..., use_existing_selection: bool = ..., confirm_existing: bool = ..., allow_multisel: bool = ..., allow_drag: bool = ..., propagate_selection: bool = ..., path_prefix_mask: str = ..., prim_kind: str = ..., validate_selection_for_node: Incomplete = ..., select_parm: str = ..., allow_kind_mismatch: EnumValue = ..., allow_instance_proxies: EnumValue = ..., fix_preselection_paths=...) -> Tuple[str,...]:
        """

        selectSceneGraph(self, prompt='Select primitives', preselection=[],
        prim_mask=hou.scenePrimMask.ViewerSetting, quick_select=False,
        use_existing_selection=True, confirm_existing=False,
        allow_multisel=True, allow_drag=True, propagate_selection=True,
        path_prefix_mask='', prim_kind='', validate_selection_for_node=None,
        select_parm='', allow_kind_mismatch=hou.optionalBool.NoOpinion,
        allow_instance_proxies=hou.optionalBool.NoOpinion,
        fix_preselection_paths=True) -> tuple of string


        """
    def selectSceneGraphInstances(self, prompt: str = ..., preselection: Sequence[str] = ..., quick_select: bool = ..., use_existing_selection: bool = ..., confirm_existing: bool = ..., allow_multisel: bool = ..., allow_drag: bool = ..., path_prefix_mask: str = ..., instance_level: int = ..., instance_indices_only: bool = ..., validate_selection_for_node: Incomplete = ..., select_parm: str = ...) -> Tuple[str,...]:
        '''

        selectSceneGraphInstances(self, prompt=\'Select point instances\',
        preselection=[], quick_select=False, use_existing_selection=True,
        confirm_existing=False, allow_multisel=True, allow_drag=True,
        path_prefix_mask=\\"\\", instance_level=0, instance_indices_only=False,
        validate_selection_for_node=None, select_parm=\\"\\") -> tuple of string


        '''
    def selectPositions(self, prompt: str = ..., number_of_positions: int = ..., min_number_of_positions: int = ..., connect_positions: bool = ..., show_coordinates: bool = ..., bbox: BoundingBox = ..., position_type: EnumValue = ..., icon: str|None = ..., label: str|None = ..., toolbox_templategroup: str|None = ..., toolbox1_templategroup: str|None = ..., select_parm: str = ...) -> Sequence[Vector3]:
        '''

        selectPositions(self, prompt=\'Click to specify a position\',
        number_of_positions=1, min_number_of_positions=-1,
        connect_positions=True, show_coordinates=True, bbox=BoundingBox(),
        position_type=positionType.WorldSpace, icon=None, label=None,
        toolbox_templategroup=None, toolbox1_templategroup=None, select_parm=\\"\\")
        -> tuple of Vector3s


        '''
    def selectOrientedPositions(self, prompt: str = ..., number_of_positions: int = ..., min_number_of_positions: int = ..., connect_positions: bool = ..., show_coordinates: bool = ..., bbox: BoundingBox = ..., icon: str|None = ..., label: str|None = ..., toolbox_templategroup: str|None = ..., toolbox1_templategroup: str|None = ..., select_parm: str = ...) -> Sequence[Tuple[Vector3, Matrix3]]:
        '''

        selectOrientedPositions(self, prompt=\'Click to specify a position\',
        number_of_positions=1, min_number_of_positions=-1,
        connect_positions=True, show_coordinates=True,
        bbox=BoundingBox(),icon=None, label=None, toolbox_templategroup=None,
        toolbox1_templategroup=None, select_parm=\\"\\") -> tuple of (Vector3,
        Matrix3) tuples

            This method is very similar to hou.SceneViewer.selectPositions,
            except the position type is always world space, and instead of a
            tuple of positions this returns a tuple of (position, orientation)
            pairs, with the position a hou.Vector3 and the orientation a
            hou.Matrix3. This allows you to prompt the user for oriented
            position, respecting possible orientation aids such as the
            construction plane and alignment.


        '''
    def selectDrawableGeometry(self, drawable_selection: Mapping[str, Incomplete], selection_modifier: EnumValue = ...) -> None:
        """

        selectDrawableGeometry(self, drawable_selection,
        selection_modifier=hou.pickModifier.Replace)

            Performs a drawable geometry selection. This method works only when
            a drawable selector is running, it can be called either from the
            python state implementing the selector or from a regular python
            script. Calling this method will trigger the python state's
            onSelection handler.

            Raises hou.OperationFailed if no drawable selector is running or
            hou.InvalidInput if the input arguments are invalid.


            drawable_selection
                A dictionary describing the drawable elements to select, the
                content of the dictionary is described here.

            selection_modifier
                The selection modifier for the selection. Defaults to
                hou.pickModifier.Replace.


        """
    def currentGeometrySelection(self) -> Optional[GeometrySelection]:
        """

        currentGeometrySelection(self) -> hou.GeometrySelection

            Returns the current geometry selection if the viewer is in a
            geometry select mode and otherwise returns None.


        """
    def currentGeometrySelectionParm(self) -> str:
        """

        currentGeometrySelectionParm(self) -> string

            Returns the current geometry selection parameter string if the
            viewer is doing a scripted selection. This holds the select_parm
            argument given to methods such as selectGeometry.


        """
    def setCurrentGeometrySelection(self, geometry_type: EnumValue, nodes: Sequence[Node], selections: Sequence[Selection]) -> None:
        """

        setCurrentGeometrySelection(self, geometry_type, nodes, selections)

            Replaces a current geometry selection if the viewer is in a geometry
            select mode and otherwise raises hou.NotAvailable. Any of the
            specified selections not matching geometry_type will be
            automatically converted to that type where possible.


        """
    def currentSceneGraphSelection(self) -> Tuple[str, ...]:
        """

        currentSceneGraphSelection(self) -> tuple of string

            Returns a tuple of scene graph paths for primitives selection in the
            scene viewer.


        """
    def setCurrentSceneGraphSelection(self, selection: Sequence[str], fix_selection_paths: bool = True) -> None:
        """

        setCurrentSceneGraphSelection(selection, fix_selection_paths=True)

            Set the current scene graph primitive selection. Set
            fix_selection_paths to True to automatically fix empty or invalid
            paths in the selection. Otherwise invalid paths raise
            hou.ValueError.


        """
    def sceneGraphHighlight(self) -> Tuple[str, ...]:
        """

        sceneGraphHighlight(self) -> tuple of string

            Returns which prims in the viewport are highlighted.


        """
    def setSceneGraphHighlight(self, highlight: Sequence[str]) -> None:
        """

        setSceneGraphHighlight(selection)

            Highlight the named prims in the viewport. Passing an empty list
            will clear the highlight. This does not affect selection.


        """
    def locateSceneGraphPrim(self, x: int, y: int) -> Tuple[float, str]:
        """

        locateSceneGraphPrim(self, x, y) -> (float, string)

            Find the primitive located at at the specified pixel coordinates.
            Returns a tuple of screen depth at the hit location and primitive
            path. Returns (-1, ) when no primitive is found.


        """
    def sceneGraphStageLocked(self) -> bool:
        """

        sceneGraphStageLocked(self) -> bool

            Return True if the viewer's USD stage is locked to its current
            state, so that it does not update when changes are made to the LOP
            Network. This is similar to the Manual Update Mode, but only affects
            this viewer pane. All other Houdini panes, such as the Scene Graph
            Tree or Scene Graph Details will continue to update with new stage
            contents from the LOP network.


        """
    def setSceneGraphStageLocked(self, locked: bool) -> None:
        """

        setSceneGraphStageLocked(self, locked)

            Set the flag indicating that this viewer should not update its stage
            contents in response to changes in the LOP Network.


        """
    def snappingMode(self) -> EnumValue:
        """

        snappingMode(self)


        """
    def setSnappingMode(self, snapping_mode: EnumValue) -> None:
        """

        setSnappingMode(self, snapping_mode)


        """
    def isSnappingToCurrentGeometry(self) -> bool:
        """

        isSnappingToCurrentGeometry(self)

            Returns whether snapping to current geometry is enabled for the
            current snapping mode.


        """
    def setSnapToCurrentGeometry(self, on: bool) -> None:
        """

        setSnapToCurrentGeometry(self, on)

            Sets whether or not snapping to current geometry is enabled for the
            current snapping mode.


        """
    def isSnappingToTemplates(self) -> bool:
        """

        isSnappingToTemplates(self)


        """
    def setSnapToTemplates(self, on: bool) -> None:
        """

        setSnapToTemplates(self, on)


        """
    def isSnappingToOtherObjects(self) -> bool:
        """

        isSnappingToOtherObjects(self)


        """
    def setSnapToOtherObjects(self, on: bool) -> None:
        """

        setSnapToOtherObjects(self, on)


        """
    def isSnappingToGuides(self) -> bool:
        """

        isSnappingToGuides(self) -> bool

            Returns whether snapping to guides is enabled for the current
            snapping mode.


        """
    def setSnapToGuides(self, on: bool) -> None:
        """

        setSnapToGuides(self, on)

            Sets whether or not snapping to guides is enabled for the current
            snapping mode.


        """
    def isDepthSnapping(self) -> bool:
        """

        isDepthSnapping(self)


        """
    def setDepthSnapping(self, on: bool) -> None:
        """

        setDepthSnapping(self, on)


        """
    def isOrientingOnSnap(self) -> bool:
        """

        isOrientingOnSnap(self)


        """
    def setOrientOnSnap(self, on: bool) -> None:
        """

        setOrientOnSnap(self, on)


        """
    def snappingGravity(self) -> float:
        """

        snappingGravity(self): -> float

            Returns the gravity value for the current snapping mode.


        """
    def snappingPriorities(self) -> Tuple[EnumValue, ...]:
        """

        snappingPriorities(self): -> tuple of hou.snappingPriority values

            Returns a tuple of hou.snappingPriority values for the current
            snapping mode. The values are sorted in order of priority
            (descending) as set in the Snap options window. Returns an empty
            tuple if the mode has no priorities.


        """
    def isPickingVisibleGeometry(self) -> bool:
        """

        isPickingVisibleGeometry(self)

            Returns true if the viewer is configured to only pick visible
            components when performing an area-based selection. This option
            corresponds to the matching check box in the component selection
            button's context menu.


        """
    def setPickingVisibleGeometry(self, on: bool) -> None:
        """

        setPickingVisibleGeometry(self, on)

            Turns on or off the option to select only visible components when
            performing area-based selections such as box or brush picking.


        """
    def isPickingContainedGeometry(self) -> bool:
        """

        isPickingContainedGeometry(self)

            Returns true if the viewer is configured to only pick fully
            contained components when performing an area-based selection. This
            option corresponds to the matching check box in the component
            selection button's context menu.


        """
    def setPickingContainedGeometry(self, on: bool) -> None:
        """

        setPickingContainedGeometry(self, on)

            Turns on or off the option to select only fully contained components
            when performing area-based selections such as box or brush picking.


        """
    def isGroupPicking(self) -> bool:
        """

        isGroupPicking(self)

            Returns true if group, attribute, or connectivity information will
            be used to automatically expand selections made in this viewer. This
            option corresponds to the matching check box in the component
            selection button's context menu.


        """
    def setGroupPicking(self, on: bool) -> None:
        """

        setGroupPicking(self, on)

            Turns on or off the group, attribute, or connectivity based picking.
            When turned on, the group list gadget is automatically made visible.


        """
    def isWholeGeometryPicking(self) -> bool:
        """

        isWholeGeometryPicking(self)

            Returns true if selections made in this viewer will automatically
            expand to include the whole geometry. This option corresponds to the
            matching check box in the component selection button's context menu.


        """
    def setWholeGeometryPicking(self, on: bool) -> None:
        """

        setWholeGeometryPicking(self, on)

            Turns on or off the option to expand selections made in this viewer
            to include the entire geometry.


        """
    def isSecureSelection(self) -> bool:
        """

        isSecureSelection(self)

            Returns true if secure selection is turned on in this viewer. This
            option corresponds to the secure selection option in the select
            tool's context menu.


        """
    def setSecureSelection(self, on: bool) -> None:
        """

        setSecureSelection(self, on)

            Turns on or off the secure selection option in this viewer.


        """
    def isPickingCurrentNode(self) -> bool:
        """

        isPickingCurrentNode(self)

            Returns true if selections made in this viewer will pick from the
            Current SOP. If not, the pick occurs on the Display SOP. This option
            corresponds to the current/display option in the component selection
            button's context menu.


        """
    def setPickingCurrentNode(self, on: bool) -> None:
        """

        setPickingCurrentNode(self, on)

            Tells this viewer whether picks should be made on the Current SOP or
            on the Display SOP.


        """
    def pickGeometryType(self) -> EnumValue:
        """

        pickGeometryType(self)

            Returns the type of geometry that will be picked in this viewer.
            This option corresponds to the component types selectable in the
            component selection button's context menu.


        """
    def setPickGeometryType(self, geometry_type: EnumValue) -> None:
        """

        setPickGeometryType(self, geometry_type)

            Sets the type of geometry that will be picked in this viewer. This
            value can be changed at any time by the user, or when a selector is
            invoked.


        """
    def selectionMode(self) -> EnumValue:
        """

        selectionMode(self)

            Returns the selection mode of the viewer of type hou.selectionMode.


        """
    def setSelectionMode(self, style: EnumValue) -> None:
        """

        setSelectionMode(self, selection_mode)

            Sets the selection mode of this view. The value for 'selection_mode'
            must be from hou.selectionMode.


        """
    def pickStyle(self) -> EnumValue:
        """

        pickStyle(self)

            Returns the style of area picking currently being used by this
            viewer. This option corresponds to the picking style specified in
            the select tool's context menu.


        """
    def setPickStyle(self, style: EnumValue) -> None:
        """

        setPickStyle(self, style)

            Sets the style of area picking to be used by this viewer.


        """
    def pickModifier(self) -> EnumValue:
        """

        pickModifier(self)

            Returns the manner in which additional selection are combined with
            the existing selection. Consider using
            hou.SceneViewer.toolPickModifier instead if you want the pick
            modifer as selected in the select tool menu.


        """
    def setPickModifier(self, modifier: EnumValue) -> None:
        """

        setPickModifier(self, modifier)

            Sets the method used to modify the existing selection when a new
            selection is made. Modifier keys can still be used to alter this
            behavior. Only the default operation (with no modifier keys) is
            affected by this setting. Note that the select state will revert to
            the default pick modifier upon termination, so to make your change
            persist beyond this you will also need to change this default using
            setDefaultPickModifier().


        """
    def defaultPickModifier(self) -> EnumValue:
        """

        defaultPickModifier(self)

            Returns the default pick modifier to which Houdini will revert after
            a select state terminates.


        """
    def setDefaultPickModifier(self, modifier: EnumValue) -> None:
        """

        setDefaultPickModifier(self, modifier)

            Sets the default pick modifier to which Houdini will revert after a
            select state terminates.


        """
    def pickFacing(self) -> EnumValue:
        """

        pickFacing(self)

            Returns a value indicating whether the user is able to pick front
            facing components, back facing components, or both. This option
            corresponds to the front and back facing options in the component
            selection button's context menu.


        """
    def setPickFacing(self, facing: EnumValue) -> None:
        """

        setPickFacing(self, facing)

            Sets the option of whether to restrict selection to front facing,
            back facing, or either type of components.


        """
    def activePickModifier(self) -> EnumValue:
        """

        activePickModifier(self)

            This method is similar to hou.SceneViewer.pickModifier but returns
            the pick modifier as selected in the select tool menu.


        """
    def isGroupListVisible(self) -> bool:
        """

        isGroupListVisible(self)

            Returns true if the group list gadget has been turned on for this
            viewer. This function only refers to the option to show the group
            list when not selecting groups in the viewer. In that case the group
            list will be visible, but this function may still return False.


        """
    def setGroupListVisible(self, on: bool) -> None:
        """

        setGroupListVisible(self, on)

            Turns on or off the group list gadget for this viewer.


        """
    def isGroupListColoringGeometry(self) -> bool:
        """

        isGroupListColoringGeometry(self)

            Returns true if the group list gadget is configured to color
            geometry in the viewer based on group membership or attribute value.


        """
    def setGroupListColoringGeometry(self, on: bool) -> None:
        """

        setGroupListColoringGeometry(self, on)

            Turns on or off the group list gadget to coloring of geometry in the
            viewer based on group membership or attribute value.


        """
    def isGroupListShowingEmptyGroups(self) -> bool:
        """

        isGroupListShowingEmptyGroups(self)

            Returns true if the group list gadget is including empty groups in
            its list.


        """
    def setGroupListShowingEmptyGroups(self, on: bool) -> None:
        """

        setGroupListShowingEmptyGroups(self, on)

            Turns on or off the display of empty groups in the group list
            gadget.


        """
    def isGroupListShowingOnlyPreSelectedGroups(self) -> bool:
        """

        isGroupListShowingOnlyPreSelectedGroups(self)

            Returns true if the group list is showing only groups that contain
            one or more selected or pre-selected components.


        """
    def setGroupListShowingOnlyPreSelectedGroups(self, on: bool) -> None:
        """

        setGroupListShowingOnlyPreSelectedGroups(self, on)

            Turns on or off the trimming of the group list to show only groups
            that contain one or more selected or pre-selected components.


        """
    def isGroupListCondensingPathHierarchies(self) -> bool:
        """

        isGroupListCondensingPathHierarchies(self)

            Returns true if the group list will condense the hierarchy of groups
            defined by a string attribute representing a path.


        """
    def setGroupListCondensingPathHierarchies(self, on: bool) -> None:
        """

        setGroupListCondensingPathHierarchies(self, on)

            Turns on or off the condensing of the hierarchy in the group list.
            This applies to components grouped by string attributes representing
            a path. Turning this option on can fit more information into the
            list, but can make it harder to distinguish levels in the hierarchy.


        """
    def groupListSize(self) -> Vector2:
        """

        groupListSize(self)

            Returns the width and height in inches of the group list gadget.


        """
    def setGroupListSize(self, width: float, height: float) -> None:
        """

        setGroupListSize(self, width, height)

            Sets the size in inches of the group list gadget.


        """
    def groupListType(self) -> EnumValue:
        """

        groupListType(self)

            Returns the type of component listed in the group list gadget.


        """
    def setGroupListType(self, group_list_type: EnumValue) -> None:
        """

        setGroupListType(self, group_list_type)

            Sets the type of component listed in the group list gadget. This can
            be set to a specific component type or to follow the current
            component selection type.


        """
    def groupListMask(self) -> str:
        """

        groupListMask(self)

            Returns true if the group list gadget has been turned on for this
            viewer.


        """
    def setGroupListMask(self, mask: str) -> None:
        """

        setGroupListMask(self, mask)

            Sets the mask value in the group list gadget for this viewer. This
            can be a filter applied to the component groups, or an attribute
            name (starting with an @ character), or a connectivity type.


        """
    def constructionPlane(self) -> ConstructionPlane:
        """

        constructionPlane(self) -> hou.ConstructionPlane

            Return the construction plane (or grid) in the perspective viewport
            of this viewer.

            See hou.ConstructionPlane for more information.


        """
    def referencePlane(self) -> ReferencePlane:
        """

        referencePlane(self) -> hou.ReferencePlane

            Return the reference plane (or grid) in the perspective viewport of
            this viewer.

            See hou.ReferencePlane for more information.


        """
    def flipbookSettings(self) -> FlipbookSettings:
        """

        flipbookSettings(self) -> hou.FlipbookSettings

            Access to the flipbook dialog settings, which can be queried, set,
            or copied.


        """
    def flipbook(self, viewport: Optional[GeometryViewport] = None, settings: Optional[FlipbookSettings] = None, open_dialog: bool = False) -> None:
        """

        flipbook(self, viewport=None, settings=None, open_dialog=False)

            Capture a flipbook. A flipbook creates a quick preview animation by
            taking consecutive screenshots of a viewport at each frame.

            Launch a flipbook for viewport if specified or the current viewport
            if viewport is not. Optionally a hou.FlipbookSettings object can be
            passed to settings which will override the current settings. This
            override will only affect the current flipbook and not change the
            dialog settings. If open_dialog is True, the flipbook dialog is
            presented to the user, otherwise a flipbook is launched immediately.


        """
    def runShelfTool(self, tool_name: str) -> None:
        """

        runShelfTool(self, tool_name)

            Run the named shelf tool in the current viewport.


        """
    def beginStateUndo(self, label: str) -> None:
        '''

        beginStateUndo(self, label)

            Opens an undo block to perform undoable operations with the current
            viewer state. All operations performed after the opening will appear
            as one single operation on the undo stack. Use
            hou.SceneViewer.endStateUndo to close an open block.

            beginStateUndo and endStateUndo can be used for managing an undo
            block that begins in one function but ends in another one. Only one
            undo block is supported for a sequence of undoable operations.
            Exceptions will be raised if a call to a second beginStateUndo is
            detected before the undo block is closed by endStateUndo.

            Python state example of a valid undo block:

          > def onMouseEvent(self, kwargs):
          >     ui_event = kwargs[\\"ui_event\\"]
          >     node = kwargs[\\"node\\"]
          >     if ui_event.reason() == hou.uiEventReason.Start:
          >         # left mouse button pressed
          >         self.scale = node.parent().parm(\\"scale\\").evalAsFloat()
          >         self.scene_viewer.beginStateUndo(\'scale\')
          > 
          >     if ui_event.reason() == hou.uiEventReason.Active:
          >         # left mouse button down while the mouse is moving
          >         self.scale *= 1.01
          >         node.parent().parm(\\"scale\\").set(self.scale)
          > 
          >     if ui_event.reason() == hou.uiEventReason.Changed:
          >         # left mouse button released
          >         self.scene_viewer.endStateUndo()

            Example of a non-valid undo block that raises an exception:

          > def onMouseEvent(self, kwargs):
          >     ui_event = kwargs[\\"ui_event\\"]
          >     node = kwargs[\\"node\\"]
          >     if ui_event.reason() == hou.uiEventReason.Start:
          >         # left mouse button pressed
          >         self.tx = node.parent().parm(\\"tx\\").evalAsFloat()
          >         self.scale = node.parent().parm(\\"scale\\").evalAsFloat()
          >         self.scene_viewer.beginStateUndo(\'scale\')
          > 
          >     if ui_event.reason() == hou.uiEventReason.Active:
          >         # left mouse button down while the mouse is moving
          >         self.scale *= 1.01
          >         node.parent().parm(\\"scale\\").set(self.scale)
          > 
          >         self.scene_viewer.beginStateUndo(\'move x\')
          >         self.tx += 0.2
          >         node.parent().parm(\\"tx\\").set(self.tx)
          >         self.scene_viewer.endStateUndo()
          > 
          >     if ui_event.reason() == hou.uiEventReason.Changed:
          >         # left mouse button released
          >         self.scene_viewer.endStateUndo()

            label
                The label of the undo block used for displaying the undo
                operation in the Edit menu. An exception is raised if the label
                is empty.


        '''
    def endStateUndo(self) -> None:
        """

        endStateUndo(self)

            Closes an undo block previously opened with
            hou.SceneViewer.beginStateUndo.

            endStateUndo will raise an exception if called before
            beginStateUndo.


        """
    def setPromptMessage(self, msg: str, msg_type: EnumValue = ...) -> None:
        """

        setPromptMessage(self, msg, msg_type=promptMessageType.Prompt)

            Sets the viewport to display a message at the bottom of the screen.


            msg
                Text message to display.

            msg_type
                A hou.promptMessageType value representing the type of message
                to display. Defaults to hou.promptMessageType.Prompt.


        """
    def clearPromptMessage(self) -> None:
        """

        clearPromptMessage(self)

            Clear the prompt message previously set with
            hou.SceneViewer.setPromptMessage.


        """
    def flashMessage(self, image: str, msg: str, duration: float = 1.0, viewport: Optional[GeometryViewport] = None) -> None: ...
    def hotkeyAssignments(self, hotkey_symbols: Sequence[str]) -> Tuple[Tuple[str, ...], ...]:
        '''

        hotkeyAssignments(self, hotkey_symbols) -> tuple of tuple of str

            Return a tuple of strings that represent the hotkeys currently
            assigned to each action associated with a tuple of hotkey symbols.
            The key strings are of the form returned by the hou.ui.hotkeys
            method, which is a combination of the symbol on the key, and any
            modifier keys involved, such as \\"Ctrl+Shift+G\\".


        '''
    def showHandle(self, name: str, value: bool) -> None:
        """

        showHandle(self, name, value)

            Shows or hides a display handle linked to the current tool state.
            This API is typically used with Python states and can be called from
            any python state callbacks -- with one small caveat. Avoid calling
            showHandle from the python state constructor, doing so will lead to
            a runtime error.

            See also hou.Handle.show.


            name
                The name of the handle as specified with
                hou.ViewerStateTemplate.bindHandle

            value
                Bool value, True to show the handle, False to hide it.


        """
    def openVisualizerEditor(self, vis: ViewportVisualizer) -> None:
        """

        openVisualizerEditor(self, visualizer)

            If the provided ViewportVisualizer exists, open the interactive
            visualizer editor dialog for that visualizer.


        """
    def openOptionDialog(self, path: str, label: str) -> None:
        """

        openOptionDialog(self, path, label)

            Opens Display Options dialog and highlight the specified label.


            path
                A colon-separated string that specifies the tab and group(s) the
                label belongs to. E.g, Geometry:Volume Quality.

            label
                The label to be highlighted.


        """
    def triggerStateSelector(self, action: EnumValue, name: str|None = ...) -> None:
        """

        triggerStateSelector(self, action, name=None)

            Triggers an action on a selector of the current state. The state
            must be a Python state type or an exception is thrown.


            action
                The type of action to trigger as specified with
                hou.triggerSelectorAction.

            name
                The name of a selector to trigger, should match the name used
                for registering the selector, see
                hou.ViewerStateTemplate.bindGeometrySelector or
                hou.ViewerStateTemplate.bindObjectSelector for details.

                The value can be empty (default) in which case the state first
                registered selector is triggered. An exception is thrown if name
                is not a known selector.


        """
    def currentStateSelector(self) -> str:
        """

        currentStateSelector(self) -> string

            Returns the name of the current state selector. If no selector is
            active, an empty string is returned. The state must be a Python
            state type or an exception is thrown.


        """
    def showCurrentSopGeometry(self, value: bool) -> None:
        """

        showCurrentSopGeometry(self, value)

            Set the geometry display flag, on or off, on the current SOP node.
            When the flag is on, the viewport displays the geometry attached to
            the node, or hides when it's off. The flag is on by default when a
            SOP state enters.

            Consider this scenario, the display flag is set to true on a
            downstream node, but an upstream node is selected. When you enter
            the node's state, normally the viewport will show the upstream
            node's geometry in wireframe, but the display node in shaded. In
            some cases, the state wants to set parameters on the selected node
            whose result is best visualized in the downstream node. In this
            case, showCurrentSopGeometry can be used to turn off the display of
            the upstream node's geometry.


            NOTE
                For SOP Python states, Houdini remembers the current node's
                geometry display flag when the state enters and will set it back
                to its original value when the state exits.

            See hou.SceneViewer.isShowingCurrentSopGeometry.


        """
    def isShowingCurrentSopGeometry(self) -> bool:
        """

        isShowingCurrentSopGeometry(self, value) -> bool

            Returns the current node's geometry display flag. See
            hou.SceneViewer.showCurrentSopGeometry.


        """
    def showOperationBar(self, on: bool) -> None:
        """

        isShowingOperationBar(self) -> bool

            Return True if the Operation Toolbar is shown at the top of the
            viewport.


        """
    def isShowingOperationBar(self) -> bool: ...
    def showColorCorrectionBar(self, on: bool) -> None:
        """

        showColorCorrectionBar(self,show)

            Show or hide the Color Correct Toolbar at the bottom of the
            viewport.


        """
    def isShowingColorCorrectionBar(self) -> bool:
        """

        isShowingColorCorrectionBar(self) -> bool

            Return True if the Color Correction Toolbar is shown at the bottom
            of the viewport.


        """
    def showMemoryBar(self, on: bool) -> None:
        """

        showMemoryBar(self,show)

            Show or hide the Memory Toolbar at the bottom of the viewport.


        """
    def isShowingMemoryBar(self) -> bool:
        """

        isShowingMemoryBar(self) -> bool

            Return True if the Memory Toolbar is shown at the bottom of the
            viewport.


        """
    def showDisplayOptionsBar(self, on: bool) -> None:
        """

        showDisplayOptionsBar(self,show)

            Show or hide the Display Options Toolbar to the right side of the
            viewport.


        """
    def isShowingDisplayOptionsBar(self) -> bool:
        """

        isShowingDisplayOptionsBar(self) -> bool

            Return True if the Display Options Toolbar is shown to the right
            side of the viewport.


        """
    def showSelectionBar(self, on: bool) -> None:
        """

        showSelectionBar(self,show)

            Show or hide the Selection Toolbar to the left side of the viewport.


        """
    def isShowingSelectionBar(self) -> bool:
        """

        isShowingSelectionBar(self) -> bool

            Return True if the Selection Toolbar is shown to the left side of
            the viewport.


        """
    def setIncludeColorCorrectionBar(self, on: bool) -> None:
        """

        setIncludeColorCorrectionBar(self,on)

            Include the optional Color Correction Toolbar at the bottom of the
            viewport.


        """
    def includeColorCorrectionBar(self) -> bool:
        """

        includeColorCorrectionBar(self) -> bool

            Return True if optional Color Correction Toolbar is included at the
            bottom of the viewport.


        """
    def setIncludeMemoryBar(self, on: bool) -> None:
        """

        setIncludeMemoryBar(self,on)

            Include the optional Memory Toolbar at the bottom of the viewport.


        """
    def includeMemoryBar(self) -> bool:
        """

        includeMemoryBar(self) -> bool

            Return True if optional Memory Toolbar is included at the bottom of
            the viewport.


        """
    def setGeometryVisibility(self, sop: SopNode, on: bool) -> None:
        """

        setGeometryVisibility(self, sop_node, on)

            Control a viewport visibility override for a given geometry node.
            This can be used by a Python State to temporary hide the viewport
            geometry when a state draws an alternate visualization using
            drawables. The viewport geometry visibility doesn't persist and is
            reverted to True when switching the display flag or reselecting
            nodes. Raises hou.InvalidInput if the geometry isn't in the current
            viewport.


        """
    def geometryVisibility(self, sop: SopNode) -> bool:
        """

        geometryVisibility(self, sop_node)

            Return False if setGeometryVisibility was called to hide the
            geometry or True otherwise. Raises hou.InvalidInput if the geometry
            isn't in the current viewport.


        """
    def usingOCIO(self) -> bool:
        """

        usingOCIO(self) -> bool

            Query if OpenColorIO is being used for color correction in the
            viewer.


        """
    def setUsingOCIO(self, enable: bool) -> None:
        """

        setUsingOCIO(self, enable)

            Enable or disable OpenColorIO for color correction in the viewer.


        """
    def setOCIODisplayView(self, display: Optional[str] = None, view: Optional[str] = None) -> None:
        '''

        setOCIODisplayView(self, display=\\"\\", view=\\"\\")

            Set the OpenColorIO display name, view name, or both. The display
            and view together define the output colorspace for the viewer, and
            any number of color transforms (Looks) to be performed on the linear
            viewport image.


        '''
    def getOCIODisplay(self) -> str:
        """

        getOCIODisplay(self) -> str

            Return the current OpenColorIO display used for color correction.


        """
    def getOCIOView(self) -> str:
        """

        getOCIOView(self) -> str

            Return the current OpenColorIO view used for color correction.


        """
    def geometry(self) -> Tuple[int, ...]:
        """

        geometry(self) -> tuple of int

            Returns the position and size of the viewer in the UI space. The
            tuple elements are returned in viewport coordinates, relative to the
            lower-left corner position of the main window.

             1. X position (lower left)

             2. Y position (lower left)

             3. Width dimension

             4. Height dimension


        """
    def createFloatingViewport(self, size: Sequence[int], pos: Sequence[int]) -> Optional[GeometryViewport]:
        """

        createFloatingViewport(self, size, pos) -> hou.GeometryViewport

            Creates a floating window with a new viewport inside it. If size (a
            tuple of 2 ints) is two positive values, set the size of the window,
            in pixels. If pos (a tuple of 2 ints) is not , set the position of
            the window on the screen, in screen coordinates. The returned
            viewport can be used to set other options on the new viewport.


        """
    def runStateCommand(self, name: str, args: Mapping[str, Any]|None = ...) -> None:
        '''

        runStateCommand(self, name, args=None)

            Executes a command implemented by the active python state. A state
            command can be invoked by specifying a name identifier along with
            input arguments.

            An exception is thrown if the state is not a Python state type or
            the state is not running.


            name
                The command name identifier.

            args
                The command arguments. args can be any Python type, including
                built-in types, containers, sets, or dictionaries. A dictionary
                is commonly used to pass arguments to a command, as it
                simplifies the command\'s implementation and allows output values
                to be returned by the command. args defaults to None is omitted.

            An implementation example of a state command.

          > import hou
          > import viewerstate.utils as su
          > 
          > class State(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer    
          >         self.text_size = 5
          >         self.text_color = \'yellow\'
          > 
          >         # drawable for drawing a text string in the viewport
          >         self.text_drawable = hou.TextDrawable(self.scene_viewer, \'text_drawable_name\',
          >             params = {\'margins\': (10.0,-10.0), 
          >                 \'origin\' : hou.drawableTextOrigin.UpperLeft,
          >                 \'multi_line\' : True} )
          >         self.text_drawable.show(True)
          > 
          >     def onCommand( self, kwargs ):        
          >         # Command to update the viewport text 
          >         name = kwargs[\'command\']
          >         args = kwargs[\'command_args\']
          >         state_parms = kwargs[\'state_parms\']
          > 
          >         if name == \'update_text\':
          >             # update settings
          >             state_parms[\'text\'][\'value\'] = args[\'text\'];
          >             self.text_color = args[\'color\']
          >             self.text_size = args[\'size\']
          >             # force a viewport redraw
          >             self.scene_viewer.curViewport().draw()
          > 
          >     def onDraw( self, kwargs ):
          >         # Draw the text in the viewport upper left
          >         handle = kwargs[\'draw_handle\']
          >         state_parms = kwargs[\'state_parms\']
          > 
          >         (x,y,width,height) = self.scene_viewer.curViewport().size()
          >         text = \'<font color=\\"%s\\", size=%d>%s</font>\' % (self.text_color, 
          >             self.text_size, state_parms[\'text\'][\'value\'])        
          >         self.text_drawable.draw( handle, params = {\'text\': text, \'translate\': (0.0, height, 0.0)} )
          > 
          > 
          > def registerState():
          >     state_typename = kwargs[\'type\'].definition().sections()[\'DefaultState\'].contents() 
          >     state_label = \\"State command demo\\"
          >     state_cat = hou.objNodeTypeCategory()
          > 
          >     template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
          > 
          >     template.bindFactory(State)
          > 
          >     template.bindParameter( hou.parmTemplateType.String, name=\\"text\\", label=\\"Text\\",
          >         default_value=\\"Lorem ipsum dolor sit amet.\\" )
          > 
          >     hou.ui.registerViewerState(template)    
          > 
          > 
          > def unregisterState():
          >     state_typename = kwargs[\'type\'].definition().sections()[\'DefaultState\'].contents() 
          >     try:
          >         hou.ui.unregisterViewerState(state_typename)
          >     except hou.StateNotRegistered:
          >         pass
          >     except:
          >         raise

            Here\'s how to invoke the command.

          > import toolutils
          > 
          > args = { \'text\': text, \'color\': color, \'size\': size }
          > toolutils.sceneViewer().runStateCommand( \'update_text\', args = args )

        '''
    def isViewingSceneGraph(self) -> bool:
        """

        isViewingSceneGraph(self) -> bool

            Returns True if the scene viewer is viewing a USD stage in LOPs.


        """
    def stage(self) -> pxr.Usd.Stage:
        """

        stage(self) -> Usd.Stage

            Returns the USD stage being displayed, if the scene viewer is
            viewing LOPs.


        """
    def stageSerial(self) -> int:
        """

        stageSerial(self) -> int

            Integer that is increased every time the Scene Graph View data is
            modified. Only count on this number to be bigger when changes occur,
            and not necessarily incremented by 1.


        """
    def setShowGeometry(self, show: bool) -> None:
        """

        setShowGeometry(self, show)

            Show or hide the scene geometry when viewing LOPs.


        """
    def showGeometry(self) -> bool:
        """

        showGeometry(self) -> bool

            Query if the scene geometry is displayed when viewing LOPs.


        """
    def setShowCameras(self, show: bool) -> None:
        """

        setShowCameras(self, show)

            Show or hide the camera guides when viewing LOPs.


        """
    def showCameras(self) -> bool:
        """

        showCameras(self) -> bool

            Query if the camera guides are displayed when viewing LOPs.


        """
    def setShowLights(self, show: bool) -> None:
        """

        setShowLights(self, show)

            Show or hide the light guides when viewing LOPs.


        """
    def showLights(self) -> bool:
        """

        showLights(self) -> bool

            Query if the light guides are displayed when viewing LOPs.


        """
    def setShowSelection(self, show: bool) -> None:
        """

        setShowSelection(self, show)

            Show the selection highlight when viewing LOPs.


        """
    def showSelection(self) -> bool:
        """

        showSelection(self) -> bool

            Query if the selection highlight is displayed when viewing LOPs.


        """
    def setShowRenderTime(self, show: bool) -> None: ...
    def showRenderTime(self) -> bool:
        """

        showRenderTime(self) -> bool

            Query if the render time and progress is shown when viewing LOPs.
            Not all renderers may provide this information.


        """
    def setShowRenderStats(self, show: bool) -> None: ...
    def showRenderStats(self) -> bool:
        """

        showRenderStats(self, show)

            Query if the renderer time and progress are shown when viewing LOPs.


        """
    def setSelectionKind(self, kind: str) -> None:
        """

        setSelectionKind(self, kind)

            Set the kind of primitive selection to be performed. 'kind' can be
            one of the USD primitive kinds (component, subcomponent, model,
            group, assembly, leaf primitive) or a custom kind. An exception is
            thrown if kind is not recognized. Case sensitivity is ignored. This
            will set the selection mode to primitive selection if point instance
            selection was active.


        """
    def setSelectionPointInstances(self, topmost: bool) -> None:
        """

        setSelectionPointInstances(self, topmost)

            Switches to point instance selection mode. If 'topmost' is 'True',
            the topmost point instance will be selected when selecting nested
            instances. Otherwise the bottommost point instance (leaf instance)
            will be selected. If point instances are not nested, 'topmost' has
            no effect.


        """
    def selectionKind(self) -> str:
        """

        selectionKind(self) -> str

            Query the current primitive kind that would be selected if the user
            entered the select state. This will return a null string if leaf
            primitives would be selected.


        """
    def isSelectingPointInstances(self) -> bool:
        """

        isSelectingPointInstances(self) -> bool

            Return True if the current selection state is selecting point
            instances, or False if it is selecting primitives.


        """
    def isSelectingTopmostInstance(self) -> bool:
        """

        isSelectingTopmostInstance(self) -> bool

            Query if the instance selection mode is selecting the topmost
            instance level (True) or the leaf instance level (False).


        """
    def setSelectionAllowKindMismatch(self, allow: bool) -> None:
        """

        setSelectionAllowKindMismatch(self, allow)

            Allow selection operations to return primitives that do not match
            the current selectionKind. When set to False, primitives returned
            from a selection will always be of the requested kind, even if this
            means that a user selection returns no results. For example, if the
            selectionKind is assembly, and the user click on a mesh that is part
            of a component model, but that component is not inside an assembly,
            nothing will be selected. When set to True, the selectionKind is
            treated as a hint rather than a requirement. In this mode, the
            user's selection will always return something, even if that means
            violating the requested selectionKind. In the previously given
            example, the selection operation would return the group primitive
            closest to the root of the hierarchy. Or if the component is not in
            a group, the component prim would be returned. Or if the user
            clicked on a primitive that is not part of a USD model hierarchy at
            all (such as a Camera primitive), the leaf primitive would be
            returned.


        """
    def selectionAllowKindMismatch(self) -> bool:
        """

        selectionAllowKindMismatch(self)

            Query the current state of the flag indicating whether selection
            operations can return primitives that do not match the current
            selectionKind.


        """
    def setSelectionAllowInstanceProxies(self, allow: bool) -> None:
        """

        setSelectionAllowInstanceProxies(self, allow)

            Allow selection operations to return instance proxy primitives. If
            set to True, instance proxy primitives are selected and returned
            from a selection operation exactly like any other primitive. If
            False, then before applying the selectionKind requirement each leaf
            primitive in a selection operation is traversed upwards through the
            hierarchy until a non-instance proxy primitive is found. Then the
            selectionKind requirement is enforced starting from this instance
            root primitive.

            Many LOP operations are not allowed on instance proxy primitives
            (since opinions expressed on such primitives are ignored by the USD
            composition system). So it is often useful to prevent the user from
            selecting such unsupported primitives in the first place.


        """
    def selectionAllowInstanceProxies(self) -> bool:
        """

        selectionAllowInstanceProxies(self)

            Query the state of the flag indicating if selections may return
            instance proxy primitives.


        """
    def setSelectionAllowHiddenPrims(self, allow: bool) -> None:
        """

        setSelectionAllowHiddenPrims(self, allow)

            Allow selection operations to return hidden primitives. If set to
            True, hidden primitives can be selected and returned from a
            selection operation. If False, then before applying the
            selectionKind requirement each leaf primitive in a selection
            operation is traversed upwards through the hierarchy until a non-
            hidden primitive is found. Then the selectionKind requirement is
            enforced.

            A hidden primitive is one that has been marked with special metadata
            in the scene graph tree. Hidden primitives are not normally
            displayed in the scene graph tree, and so it is usually desirable to
            also prevent them from being directly selected in the viewer. The
            hidden flag is often used specifically to control primitive
            selection to ensure that transforms and other edits occur only at
            desirable locations in the scene graph hierarchy, acoording to the
            conventions of your pipeline.


        """
    def selectionAllowHiddenPrims(self) -> bool:
        """

        selectionAllowHiddenPrims(self)

            Query the state of the flag indicating if selections may return
            hidden primitives.


        """
    def setStageControlsPlaybar(self, controls_playbar: bool) -> None:
        """

        setStageControlsPlaybar(self, controls_playbar)

            Specify whether the metadata from the stage shown in this viewer
            should be used to set the playbar range and playback rate. Only one
            viewer may have this option enabled at a time. Turning it on for one
            viewer will turn it off for all other viewers.

            If enabled, the stage's StartTimeCode, EndTimeCode, and
            TimeCodesPerSecond values are used to set the start frame, and
            frame, and FPS options of the playbar respectively. The playbar step
            option is set to a value of TimeCodesPerSecond/FramesPerSecond from
            the stage metadata.

            The Houdini playbar more closely corresponds to the USD concept of
            timecodes than frames. This makes it much easier to author animated
            USD data.


        """
    def stageControlsPlaybar(self) -> bool:
        """

        stageControlsPlaybar(self) -> bool

            Return True if the metadata from the stage shown in this viewer is
            used to control the playbar range and playback rate. Otherwise
            return False.


        """
    def hydraRenderers(self) -> Tuple[str, ...]:
        """

        hydraRenderers(self) -> tuple of str

            Query the list of renderers that are available to LOPs.


        """
    def setHydraRenderer(self, ren_name: str) -> None:
        """

        setHydraRenderer(self, ren_name)

            Set the current renderer in LOPs.


        """
    def currentHydraRenderer(self) -> str:
        """

        currentHydraRenderer(self) -> str

            Query the current renderer in LOPs.


        """
    def isRendererPaused(self) -> bool:
        """

        isRendererPaused(self) -> bool

            Return True if the active LOP render delegate has been paused.


        """
    def setRendererPaused(self, paused: bool) -> None:
        """

        setRendererPaused(self, paused)

            Pauses or resumes the active LOPs render delegate. This is
            equivalent to choosing the Pause Render or Resume Render menu items
            in the viewport's renderer menu.


        """
    def restartRenderer(self) -> None:
        """

        restartRenderer(self)

            Restart the current renderer in LOPs, which causes the scene to be
            rebuilt from scratch.


        """
    def resetViewportCamera(self) -> None:
        """

        resetViewportCamera(self)

            Reset the native viewport camera to a default state. This clears any
            camera settings inherited from the most recently chosen USD camera.

            This method is equivalent to selecting Reset Native Viewport Camera
            in the viewport's camera menu.


        """
    def showProxyPurpose(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        showProxyPurpose(self, show_proxy, renderer = None)

            Show (True) or hide prims tagged with the Proxy purpose in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showGuidePurpose(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        showGuidePurpose(self, show_guide, renderer = None)

            Show (True) or hide prims tagged with the Guide purpose in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showRenderPurpose(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        showRenderPurpose(self, show_render, renderer = None)

            Show (True) or hide prims tagged with the Render purpose in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def useViewportOverrides(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        useViewportOverrides(self, use_overrides, renderer = None)

            Control whether the viewer should apply overrides (such as draw mode
            and visibility) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def useViewportLoadMasks(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        useViewportLoadMasks(self, use_loadmasks, renderer = None)

            Control whether the viewer should apply load masks (such as payload
            loading) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def usePostLayers(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        usePostLayers(self, use_postlayers, renderer = None)

            Control whether the viewer should apply post-layers from the LOP
            Network.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showMaterials(self, enable: bool, renderer: Optional[str] = None) -> None:
        """

        showMaterials(self, show_materials, renderer = None)

            Enable or disable the display of materials in the viewport in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showingProxyPurpose(self, renderer: Optional[str] = None) -> bool:
        """

        showingProxyPurpose(self, renderer = None) -> bool

            Return True if prims with the Proxy purpose are being shown in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showingGuidePurpose(self, renderer: Optional[str] = None) -> bool:
        """

        showingGuidePurpose(self, renderer = None) -> bool

            Return True if prims with the Guide purpose are being shown in LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showingRenderPurpose(self, renderer: Optional[str] = None) -> bool:
        """

        showingRenderPurpose(self, renderer = None) -> bool

            Return True if prims with the Render purpose are being shown in
            LOPs.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def usingViewportOverrides(self, renderer: Optional[str] = None) -> bool:
        """

        usingViewportOverrides(self, renderer = None) -> bool

            Return True if the viewer is applying overrides (such as draw mode
            and visibility) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def usingViewportLoadMasks(self, renderer: Optional[str] = None) -> bool:
        """

        usingViewportLoadMasks(self, renderer = None) -> bool

            Return True if the viewer is applying load masks (such as payload
            loading) set in the scene graph tree.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def usingPostLayers(self, renderer: Optional[str] = None) -> bool:
        """

        usingPostLayers(self, renderer = None) -> bool

            Return True if the viewer is applying post-layers set on the LOP
            Network.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is returned.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def showingMaterials(self, renderer: Optional[str] = None) -> bool:
        """

        showingMaterials(self, renderer = None) -> bool

            Return True if the display of materials in LOP viewport is enabled.

            This value is stored separately for each renderer. If renderer is
            None, the value for the currently selected renderer is set.
            Otherwise renderer is a string indicating the name of the renderer.


        """
    def addEventCallback(self, callback: Callable) -> None:
        '''

        addEventCallback(self, callback)

            Register a Python callback to be called whenever viewer and geometry
            viewport events occur.


            callback
                Any callable Python object that expects keyworded arguments
                specific to an event type. A single callback can listen to all
                viewer events.

            The callback is called with a dictionary containing these items:

          * event_type: The viewer event.

          * desktop: The desktop object holding the scene viewer.

          * viewer: The scene viewer object listening to this event.

            Extra items are available for specific events:

            viewport
            The selected viewport object

            hou.sceneViewerEvent.SelectedViewportChanged

            state_name
            The state name

            hou.sceneViewerEvent.BeginResize, hou.sceneViewerEvent.EndResize,
            hou.sceneViewerEvent.Resizing, hou.sceneViewerEvent.SizeChanged,
            hou.sceneViewerEvent.LayoutChanged,
            hou.sceneViewerEvent.ColorSchemeChanged,
            hou.sceneViewerEvent.ViewerActivated,
            hou.sceneViewerEvent.ViewerDeactivated,
            hou.sceneViewerEvent.ViewerTerminated,
            hou.sceneViewerEvent.StateInterrupted,
            hou.sceneViewerEvent.StateResumed,
            hou.sceneViewerEvent.StateEntered, hou.sceneViewerEvent.StateExited

            volatile_state_name
            The state name which is interrupting the current state or resuming
            the interrupted state.

            hou.sceneViewerEvent.StateInterrupted,
            hou.sceneViewerEvent.StateResumed

            pref_name
            Preference name

            hou.sceneViewerEvent.PrefChanged

            pref_registry_name
            The registry name containing the preference.

            hou.sceneViewerEvent.PrefChanged

          > def onViewerCB(**kwargs):
          >         event_type=kwargs[\'event_type\']
          >         desktop=kwargs[\'desktop\']
          >         viewer=kwargs[\'viewer\']
          > 
          >         print( \\"event type=\\",event_type )
          >         print( \\"desktop=\\",desktop )
          >         print( \\"viewer=\\",viewer )
          > 
          > curSceneViewer = [item for item in hou.ui.curDesktop().currentPaneTabs() if item.type() == hou.paneTabType.SceneViewer][0]
          > curSceneViewer.addEventCallback(onViewerCB)

        '''
    def removeEventCallback(self, callback: Callable) -> None:
        """

        removeEventCallback(self,callback)

            Remove a specific Python callback that have been registered with
            hou.sceneViewerEvent.addEventCallback.


        """
    def clearEventCallbacks(self) -> None:
        """

        clearEventCallbacks(self)

            Remove all Python callbacks that have been registered with
            hou.sceneViewerEvent.addEventCallback.


        """
    def eventCallbacks(self) -> Tuple[Callable,...]:
        """

        eventCallbacks(self) -> tuple of callbacks

            Return a tuple of all the Python callbacks that have been registered
            with hou.sceneViewerEvent.addEventCallback.


        """
    def qtWindow(self) -> QtWidgets.QWidget:
        """

        qtWindow(self) -> QtWidgets.QWidget

            Create and return a new Qt Window for the scene viewer.


            The returned window is parented to the main Qt window and can be
            used for parenting a Qt widget like a dialog or a window.


        """
    def bindViewerHandle(self, handle_type: str, name: str, settings: str|None = ..., cache_previous_parms: bool = ..., handle_parms: Sequence[str]|None = ...) -> None:
        """

        bindViewerHandle(self, handle_type, name, settings=None,
        cache_previous_parms=False, handle_parms=None)

            Binds a dynamic viewer handle to the current viewer state similarly
            to hou.ViewerStateTemplate.bindHandle. Unlike bindHandle though,
            this method creates and initializes the handle in a dynamic fashion,
            there is no need to register in advance the handle with the viewer
            state. You can call bindViewerHandle from almost anywhere in Houdini
            (from the viewer state handlers, from a python script, etc...),
            however it can only be called while the viewer state is running.

            To remove the viewer handles added with bindViewerHandle, use
            hou.SceneViewer.unbindViewerHandle. Houdini will take care of
            removing automatically all viewer handles added with
            bindViewerHandle when the state exits.

            This method works only with python states, an exception is raised if
            the state is not a python state.



                handle_type
                    A string naming the type of handle. See State handle types
                    for a list of handle types to choose from.

                name
                    A string to use to identify the handle. Each binding's name
                    must be unique within this state. Trying to bind the same
                    name more than once will raise an exception.

                settings
                    A string containing specific settings of the handle.
                    Multiple settings must be space separated.

                cache_previous_parms
                    If True, the handle retains a record of previous values.
                    This can be useful if you want your code to calculate deltas
                    as the user moves the handle, for example to know how fast
                    the user is dragging the handle.

                handle_parms
                    An array of handle parm names to specify the parms to
                    enable, only the parms contained in the array will be
                    available to the python state callbacks. All handle parms
                    are enabled when handle_parms is empty (default).


        """
    def bindViewerHandleStatic(self, handle_type: str, name: str, bindings: Sequence[str], settings: str|None = ...) -> None:
        '''

        bindViewerHandleStatic(self, handle_type, name, bindings, settings=None)

            Binds a static viewer handle to the current viewer state similarly
            to hou.ViewerStateTemplate.bindHandleStatic. Unlike bindHandleStatic
            though, this method creates and initializes the handle in a dynamic
            fashion, there is no need to register in advance the handle with the
            viewer state. You can call bindViewerHandleStatic from almost
            anywhere in Houdini (from the viewer state handlers, from a python
            script, etc...), however it can only be called while the viewer
            state is running.

            To remove the viewer handles added with bindViewerHandleStatic, use
            hou.SceneViewer.unbindViewerHandle. Houdini will take care of
            removing automatically all viewer handles added with
            bindViewerHandleStatic when the state exits.

            This method works only with python states, an exception is raised if
            the state is not a python state.



                handle_type
                    A string naming the type of handle.

                name
                    A unique string to use to identify the handle. Each
                    binding\'s name must be unique within this state. Trying to
                    bind the same name more than once will raise an exception.

                bindings
                    A list of (\\"node_parm_name\\", \\"handle_parm_name\\") tuples.
                    This binds the parts of the handle to individual parameters
                    on the node.

                settings
                    A string containing specific settings of a handle. Multiple
                    settings must be space separated.


        '''
    def unbindViewerHandle(self, handle_instance_name: str) -> None:
        """

        unbindViewerHandle(self, name)

            Removes a viewer handle from the current python state.
            unbindViewerHandle can only unbind the viewer handles that were
            dynamically added with hou.SceneViewer.bindViewerHandle or
            hou.SceneViewer.bindViewerHandleStatic. An exception is raised if
            the viewer handle to unbind is a state registered viewer handle.

            This method works only with python states, an exception is raised if
            the state is not a python state.


            name
                The viewer handle name to unbind. This is the name used when
                binding the handle with bindViewerHandle or
                bindViewerHandleStatic.


        """
    def fullName(self) -> str:
        """

        fullName(self) -> str

            Returns the full name of the viewer formatted as
            desktop.name.category

          > # Full name of a viewer in the technical desktop looking at Objects, SOPs or DOPs 
          > Technical.panetab2.world
          > 
          > # Full name of a viewer in the technical desktop looking at LOPs 
          > Technical.panetab2.solaris

        """

class ScriptEvalContext:
    """

    hou.ScriptEvalContext

    Use this to temporarily change the scripting evaluation context within a
    Python code block.


    """
    thisown: Incomplete
    def __init__(self, node_or_parm: OpNode|Parm) -> None:
        '''

        __init__(self, node_or_parm)

            Constructs a new ScriptEvalContext context manager. When used inside
            a with code block, node and parameter evaluations will use the
            argument to resolve relative paths and for adding data dependencies.
            The code block will also have its hou.pwd() modified accordingly.

            When constructed with a node, it behaves the same as calling
            hou.setPwd() and then restoring it to the old node when the code
            block ends. For example,

          > with hou.scriptEvalContext(some_node):
          >     print hou.pwd() # prints path for some_node

            is equivalent to,

          > old_node = hou.pwd()
          > hou.setPwd(some_node)
          > print hou.pwd() # prints path for some_node
          > hou.setPwd(old_node)

            When constructed with a parameter, relative node and parameter paths
            inside the code block will be resolved using the parameter\'s owner
            node. Data dependencies will be added from the referenced parameter
            or node to this parameter. This changes what hou.evaluatingParm will
            return. Here\'s an example:

          > with hou.scriptEvalContext(some_parameter):
          >     # prints path for some_parameter\'s owner node
          >     print hou.pwd()
          >     # prints path for some_parameter
          >     print hou.evaluatingParm()
          >     # adds data dependency from the sibling test to some_parameter
          >     x = ch(\\"test\\")

        '''
    __swig_destroy__: Incomplete
    def node(self) -> OpNode | None:
        """

        node(self)

            Return the hou.OpNode for this context.


        """
    def parm(self) -> Optional[Parm]:
        """

        parm(self)

            Return the hou.Parm for this context. Returns None if this context
            was created from a hou.OpNode.

            RELATED

              * hou.evaluatingParm


        """
    def __enter__(self) -> ScriptEvalContext: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class Selection:
    """

    hou.Selection

    A class that represents a geometry component selection.

    Component selections are not tied to any specific hou.Geometry.
    Therefore most method on this class must be passed a Geometry object to
    look up information about individual components. This explicit
    separation allows the selection class to be used as a utility class for
    processing geometry topology (growing the set of components, shrinking
    it, finding the boundary, etc.). This separation also avoids any
    expectations that changing the contents of a selection object might be
    expected to update the selection visible on some geometry in the
    viewport. Setting the visible viewport selection must always be an
    explicit operation on a hou.SopNode in order for Houdini to be able to
    track changes properly.

    If a selection object is returned from a call to hou.Geometry.selection,
    hou.GeometrySelection.selections, or a hou.SopNode.selection, the
    selection cannot be modified. A copy of the selection must be made first
    with the freeze() method. This new selection can be modified, and passed
    back into a hou.SopNode.setSelection if desired. Because each SOP has a
    selection for each component type, when you set a new selection it will
    replace the existing selection of that component type. Note that this
    may not result in the visible selection in the viewport changing if the
    viewport is not currently configured to select that component type. The
    viewport selection type can be controlled with the hou.SceneViewer
    class. A selection created by calling any of the hou.Selection()
    initializer methods are created in a modifiable state, so a call to
    freeze() is not required.

    A selection returned from a hou.Geometry or a hou.SopNode is a reference
    to the source selection, and so will change if the selection on the
    source geometry is changed. This seems like a departure from the
    separation of selection objects from any particular geometry, however it
    matches the behavior of the hou.Geometry class returned from a SOP node.
    This is because the underlying selection data is shared with the SOP
    rather than copied. The freeze() method can be used to force a copy of
    the selection data that is disconnected from any particular SOP (as well
    as allowing the selection contents to be modified).


    """
    thisown: Incomplete
    def __init__(self, selection: EnumValue|Geometry|Sequence[Prim]|Sequence[Point]|Sequence[Vertex]|Sequence[Edge], geometry_type: EnumValue|Sequence[EnumValue] = ..., selection_string: str = ...) -> None:
        """

        __init__(self, edges)

            Creates a new edge component selection from the passed in sequence
            of hou.Edge objects.


        """
    __swig_destroy__: Incomplete
    def freeze(self) -> Selection:
        """

        freeze(self) -> hou.Selection

            Returns a copy of the Selection object. This copy can be modified
            with any of the functions that alter the selection.


        """
    def invert(self, geo: Geometry) -> None:
        """

        invert(self, geo)

            Using the supplied hou.Geometry object for reference, inverts the
            current selection. The selection will contain only those components
            that were not in the selection before this method call.


        """
    def convert(self, geo: Geometry, selection_type: EnumValue, select_only_whole: bool = False) -> None:
        """

        convert(self, geo, selection_type, select_only_whole=False)

            Using the supplied hou.Geometry object for reference, converts the
            current selection to the new hou.geometryType. If select_only_whole
            is True, select only the edges or primitives that have all their
            points selected.


        """
    def boundary(self, geo: Geometry, uv_connectivity: bool = False) -> None:
        """

        boundary(self, geo, uv_connectivity = False)

            Using the supplied hou.Geometry object for reference, changes the
            selection to contain those components on the boundary of the current
            selection. The uv_connectivity parameter controls whether to use
            topology or uv attribute values to determine whether components are
            connected.


        """
    def grow(self, geo: Geometry, uv_connectivity: bool = False) -> None:
        """

        grow(self, geo, uv_connectivity = False)

            Using the supplied hou.Geometry object for reference, adds to the
            selection any components connected to the current selection. The
            uv_connectivity parameter controls whether to use topology or uv
            attribute values to determine whether components are connected.


        """
    def shrink(self, geo: Geometry, uv_connectivity: bool = False) -> None:
        """

        shrink(self, geo, uv_connectivity = False)

            Using the supplied hou.Geometry object for reference, removes from
            the selection any components on the boundary of the current
            selection. The uv_connectivity parameter controls whether to use
            topology or uv attribute values to determine whether components are
            connected.


        """
    def combine(self, geo: Geometry, selection: Selection, modifier: EnumValue) -> None:
        """

        combine(self, geo, selection, modifier)

            Using the supplied hou.Geometry object for reference, combines this
            selection with another.


            geo
                A hou.Geometry object that is used when doing any selection
                conversions.

            selection
                A hou.Selection object that will be combined with the current
                selection. If this selection does not have the same component
                type as the current selection, an implicit conversion to the
                current component type is performed before combining the
                selections.

            modifier
                A hou.pickModifier value that controls how the selections will
                be combined. This lets you perform a union, intersection, or
                other operation on a pairs of selections.


        """
    def clear(self) -> None:
        """

        clear(self)

            Removes all components from the current selection.


        """
    def selectionType(self) -> EnumValue:
        """

        selectionType(self)

            Returns a hou.geometryType value indicating the type of component
            referenced by this selection.


        """
    def numSelected(self) -> int:
        """

        numSelected(self)

            Returns the number of components in the selection.


        """
    def prims(self, geo: Geometry) -> Tuple[Prim, ...]:
        """

        prims(self, geo) -> tuple of hou.Prim

            Returns a tuple of all primitives in the selection. If the selection
            does not contain primitives, an implicit conversion to primitives is
            performed to generate the return value.


        """
    def points(self, geo: Geometry) -> Tuple[Point, ...]:
        """

        points(self, geo) -> tuple of hou.Point

            Returns a tuple of all points in the selection. If the selection
            does not contain points, an implicit conversion to points is
            performed to generate the return value.


        """
    def vertices(self, geo: Geometry) -> Tuple[Vertex, ...]:
        """

        vertices(self, geo) -> tuple of hou.Vertex

            Returns a tuple of all vertices in the selection. If the selection
            does not contain vertices, an implicit conversion to vertices is
            performed to generate the return value.


        """
    def edges(self, geo: Geometry) -> Tuple[Edge, ...]:
        """

        edges(self, geo) -> tuple of hou.Edge

            Returns a tuple of all edges in the selection. If the selection does
            not contain edges, an implicit conversion to edges is performed to
            generate the return value.


        """
    def selectionString(self, geo: Geometry, force_numeric: bool = False, collapse_where_possible: bool = True, asterisk_to_select_all: bool = False) -> str:
        """

        selectionString(self, geo, force_numeric = False,
        collapse_where_possible = True, asterisk_to_select_all = False) -> str

            Returns a string that specifies the selected components. The format
            of this string is appropriate for use in SOP Group parameter fields.


            geo
                A hou.Geometry object that is used when generating the selection
                string (such as determining if all components are selected).

            force_numeric
                Set this to True to force the generated string to contain only
                numeric ranges, even if the selection was constructed with group
                or attribute based selection.

            collapse_where_possible
                Set this to True to cause numeric ranges to be collapsed as much
                as possible, regardless of the selection order. So for example
                if the user selected primitive 3, then 2, then 1, the generated
                selection string would either be '3 2 1' or '1-3' depending on
                this parameter.

            asterisk_to_select_all
                When this parameter is set to False, if a selection contains all
                components in the supplied geometry, the resulting value is an
                empty string. This is appropriate when using the resulting
                string in a SOP node Group parameter. If this parameter is set
                to True, a full selection will return a value of '*' instead.


        """

class Selector:
    """

    hou.Selector

    Describes how Houdini should prompt the user to choose geometry in the
    viewport when creating a new SOP node instance.

    Use hou.SopNodeType.addSelector to create a selector and add it to a SOP
    node type. When the user creates a new instance of a node type in the
    viewer, Houdini will invoke all of its selectors sequentially. Each
    selector prompts the user to select geometry. When all selectors have
    been invoked, Houdini creates the new node and each selector connects
    its input nodes and fills in any group parameters on the node to match
    what was selected.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Return the name of this selector. The name is unique within the node
            type it is attached to.


        """
    def nodeType(self) -> NodeType:
        """

        nodeType(self) -> hou.NodeType

            Return the node type that this selector is attached to.


        """
    def selectorType(self) -> str:
        """

        selectorType(self) -> str

            Return the name of the type of selector to use. Different selectors
            have different behaviors. For example prims will select only
            primitives and is used, for example, by the cookie SOP. points will
            select only points, and is used by SOPs like the point SOP.
            everything will select any geometry, and is used for SOPs like xform
            and blast.

            See hou.SopNodeType.selectors for example code that returns all the
            available selector types.


        """
    def geometryTypes(self) -> Tuple[EnumValue, ...]:
        '''

        geometryTypes(self) -> tuple of hou.geometryType enum values

            Return a tuple of hou.geometryType enumeration values. This tuple
            describes which geometry entities (e.g. points, primitives, edges,
            etc.) the selector allows. Note that this list is a property of the
            selector type and you cannot specify it when creating a new
            selector. Instead, you must choose a selector type with the desired
            geometry types.

            See hou.SopNodeType.selectors for a function that returns a list of
            all the selector types. The following function will return the
            geometry types for a particular selector type.

          > def geometryTypesForSelectorType(selector_type):
          >     \'\'\'Given a selector type name, return the tuple of geometry types it
          >        will select.\'\'\'
          >     # First find a node type that uses this selector.
          >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
          >         # Skip manager nodes, like shopnets, ropnets, etc.
          >         if not isinstance(node_type, hou.SopNodeType):
          >             continue
          > 
          >         for selector in node_type.selectors():
          >             if selector_type == selector.selectorType():
          >                 return selector.geometryTypes()
          > 
          >     # The selector type name is invalid.
          >     raise hou.OperationFailed(\\"Invalid selector type\\")

        '''
    def groupTypeParmValues(self) -> Tuple[int, ...]:
        """

        groupTypeParmValues(self) -> tuple of int

            Return a tuple of indices mapping geometry types to indices on the
            geometry type parameter menu.

            Whether or not a selector is ordered is a property of the selector
            type, and you cannot specify it when creating a new selector.
            Instead, you must choose the appropriate selector type. For example,
            the everything selector can select primitives, primitive groups,
            points, point groups, edges, and breakpoints. It sets a group type
            menu parameter to match the type of selection, and this menu must
            have the entries Guess from Group, Breakpoints, Edges, Points, and
            Primitives. For an everything selector, this method returns (4, 4,
            3, 3, 2, 1), mapping the geometry element types to 0-based entries
            in the menu. For example, if the user selects edges, the selector
            will look up the fifth element (2) and set the menu parameter to the
            item at index 2 (Edges).

            The length of the tuple of ints is the same as
            len(self.geometryTypes). If this selector is not intended to work
            with a menu parameter, each value in the tuple will be -1.

            See also hou.Selector.geometryTypes.


        """
    def ordered(self) -> bool:
        '''

        ordered(self) -> bool

            Return whether or not this selector preserves the order in which the
            user selected the geometry.

            For example, the selector is for points and the user clicks on
            points 1, 0, and 2, in that order, an ordered selector will set the
            SOP\'s group parameter to \\"1 0 2\\", while an unordered selector will
            set it to \\"0-2\\". For SOPs where the order of the group selector
            matters, use ordered selectors.

            Whether or not a selector is ordered is a property of the selector
            type, and you cannot specify it when creating a new selector.
            Instead, you must choose the appropriate selector type. For example,
            prims is an unordered selector type, but ordered_prims is ordered.
            See hou.Selector.geometryTypes for a function that can be adapted to
            determine if a selector is ordered, and see
            hou.SopNodeType.selectors for a function to list all the selector
            types.


        '''
    def prompt(self) -> str:
        """

        prompt(self) -> str

            A string to display at the bottom of the viewer to instruct the user
            what to select.


        """
    def primitiveTypes(self) -> Tuple[EnumValue, ...]:
        """

        primitiveTypes(self) -> tuple of hou.primType enum values

            Return a sequence of hou.primType enumeration values to specify what
            primitive types are allowed.

            Note that if you pass an empty sequence for the primitive_types
            parameter in hou.SopNodeType.addSelector and then call this method
            on the newly-created selector, this method will return a tuple of
            all primitive types.


        """
    def groupParmName(self) -> str:
        """

        groupParmName(self) -> str

            Return the name of the SOP node parameter containing the group
            field. The selector will set this parameter to the string
            representing the points, primitives, edges, etc. chosen by the user
            in the viewer. It is typically named group.


        """
    def groupTypeParmName(self) -> str:
        """

        groupTypeParmName(self) -> str

            Return the name of the SOP node parameter containing the menu of
            geometry types. If the selector can select multiple geometry types
            (e.g. points or primitives), it will set this parameter to match the
            type of geometry the user chose. The transform SOP, for example, has
            a Group Type parameter that tells it how to interpret the string in
            the Group parameter. For such selectors, the parameter is typically
            named grouptype. For selectors that do not allow multiple geometry
            types, this parameter is usually .


        """
    def inputIndex(self) -> int:
        """

        inputIndex(self) -> int

            Return the index of the input connector on the SOP node where the
            selector should wire input SOPs. A cookie SOP, for example, has two
            input connectors and one selector for each input connector.


        """
    def inputRequired(self) -> bool:
        """

        inputRequired(self) -> bool

            Return whether or not this input is required or optional. If the
            user does not select any geometry and the input is not required, the
            selector will not connect anything to its input connector.


        """
    def allowDragging(self) -> bool:
        """

        allowDragging(self) -> bool

            Return whether the user is allowed to select the geometry and begin
            manipulating the handles with a single mouse click. A transform SOP,
            for example, lets you select the geometry and drag it right away.
            Dragging the geometry forces the selector to finish immediately, the
            selector connects the input and sets the group parameter, and
            subsequent mouse movements are passed to the handle which translates
            the geometry by changing parameter values.


        """
    def emptyStringSelectsAll(self) -> bool:
        """

        emptyStringSelectsAll(self) -> bool

            Return whether or not use an empty string in the group parameter if
            the user selects all the geometry. If False, Houdini will place an
            asterisk (*) in the group parameter when the user selects all the
            geometry. Most SOPs use an empty string.


        """
    def extraInfo(self) -> str:
        """

        extraInfo(self) -> str

            Returns an optional extra info string that contains additional
            settings.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this selector from its node type.

            See also hou.SopNodeType.addSelector.


        """

class SeparatorParmTemplate(ParmTemplate):
    """

    hou.SeparatorParmTemplate

    Template for a separator parameter. Separators are just lines between
    parameters and do not store any parameter values.


    """
    thisown: Incomplete
    def __init__(self, name: str, is_hidden: bool = ..., tags: Mapping[str, str] = ...) -> None:
        """

        __init__(self, name, is_hidden=False, tags={})

            Creates a new SeparatorParmTemplate instance.


            name
                See hou.ParmTemplate.name for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            tags
                See hou.ParmTemplate.tags for more information.


        """
    __swig_destroy__: Incomplete

class Shelf(ShelfElement):
    """

    hou.Shelf

    Represents a tab of shelf tools.

    You can't instantiate this object directly, call hou.shelves.newShelf
    instead.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def tools(self) -> Tuple[Tool, ...]:
        """

        tools(self) -> tuple of hou.Tool

            Returns the tools on this shelf tab.


        """
    def setTools(self, tools: Sequence[Tool]) -> None:
        """

        setTools(self, tools)

            Replaces the current contents of the shelf with the given list of
            hou.Tool objects.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Removes this shelf tab from Houdini and deletes it from the shelf
            defintion file.


        """

class ShelfDock:
    """

    hou.ShelfDock

    Represents the shelf area at the top of the screen, within which shelf
    sets and shelf tabs exist.

    The shelf docking area on any given desktop has space for any number of
    shelf sets, each of which may contain shelf tabs.

    RELATED

      * hou.Desktop


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def shelfSets(self) -> Tuple[ShelfSet, ...]:
        """

        shelfSets(self) -> tuple of hou.ShelfSet

            Returns a list of the shelf sets in the current shelf dock.


        """
    def iconsize(self) -> Tuple[int, ...]:
        """

        iconsize(self) -> (int, int)

            Returns the height and width, in pixels, of the icons in the shelf
            at the current Display Tools As setting.


        """
    def show(self, on: bool) -> None:
        """

        show(self, on)

            Show or hide the shelf dock by uncollapsing or collapsing its stow
            bar.


        """

class ShelfSet(ShelfElement):
    """

    hou.ShelfSet

    Represents a collection of shelf tabs.

    You can't instantiate this object directly, call hou.shelves.newShelfSet
    instead.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def shelves(self) -> Tuple[Shelf, ...]:
        """

        shelves(self) -> tuple of hou.Shelf

            Returns the shelf tabs in this shelf set.


        """
    def setShelves(self, shelves: Sequence[Shelf]) -> None:
        """

        setShelves(self, shelves)

            Replaces the current contents of the shelf with the given list of
            hou.Shelf objects.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Removes this shelf set from Houdini and deletes it from the shelf
            definition file.


        """

class ShellIO:
    """

    hou.ShellIO

    A proxy object that replaces Python's stdin, stdout, and stderr streams
    within Houdini.

    This class is mostly an implementation detail of how Houdini replaces
    Python's standard streams with versions that allow Python input and
    output in Houdini windows and pane tabs.

    The methods that might be useful outside of internal SideFX scripts are
    addCloseCallback(), removeCloseCallback(), and callbacks(). These let
    you register functions that Houdini calls when the Python shell window
    or pane tab is closed (the equivalent of atexit() scripts in regular
    Python).

    The other methods should be considered internal implementation details,
    and you should not use them.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def readline(self, size: int = ...) -> str:
        """

        readline(self, size=-1) -> string

            Implemented as part of the file-like object interface.


        """
    def addCloseCallback(self, callback: Callable[[], None]) -> None:
        """

        addCloseCallback(callback)

            Register a Python callback to be called whenever the last Houdini
            Python Shell is closed.

            The argument is a callable object that expects no parameters.

          > def cleanup():
          >     # Here is where you would run your cleanup code when
          >     # the Python shell has closed.
          >     pass
          > 
          > hou.ui.shellIO().addCloseCallback(cleanup)

            You might use this function to cleanly terminate any mechanisms that
            are dependent on the Python shell. For example, you can register a
            callback which disables an object from logging output messages to
            the shell.


        """
    def removeCloseCallback(self, callback: Callable[[], None]) -> None:
        """

        removeCloseCallback(callback)

            Remove a Python callback that was previously registered with
            hou.ShellIO.addCloseCallback. See hou.ShellIO.addCloseCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
    def closeCallbacks(self) -> Tuple[Callable[[], None],...]:
        """

        closeCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.ShellIO.addCloseCallback.


        """
    def CloseCallbacks(self) -> Tuple[Callable[[], None],...]: ...
    def addExitCallback(self, callback: Callable[[], None]) -> None: ...
    def removeExitCallback(self, callback: Callable[[], None]) -> None: ...
    def exitCallbacks(self) -> Tuple[Callable[[], None],...]: ...
    def write(self, data: str) -> None:
        """

        write(self, data)

            Implemented as part of the file-like object interface.


        """
    def getAndClearWrittenData(self) -> str:
        """

        getAndClearWrittenData(self) -> string


        """
    def addDataForReading(self, data: str) -> None:
        """

        addDataForReading(self, data)


        """
    def addEOFForReading(self) -> None:
        """

        addEOFForReading(self)


        """
    def interruptShellThread(self) -> None:
        """

        interruptShellThread(self)


        """
    def isWaitingForCommand(self) -> bool:
        """

        isWaitingForCommand(self) -> bool


        """
    def setIsWaitingForCommand(self, on: bool) -> None:
        """

        setIsWaitingForCommand(self, on)


        """
    def isatty(self) -> bool:
        """

        isatty(self) -> bool

            Implemented as part of the file-like object interface.


        """
    def flush(self) -> None: ...

class shelves:
    """

    hou.shelves

    Contains functions for working with shelf tabs and shelf tools.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def shelfSets() -> dict[str, ShelfSet]:
        """

        shelfSets() -> dict of str to hou.ShelfSet

            Returns a dictionary mapping the internal name of every known shelf
            tab to a corresponding hou.Shelf object.


        """
    @staticmethod
    def shelves() -> dict[str, Shelf]:
        """

        shelves() -> dict of str to hou.Shelf

            Returns a dictionary mapping the internal name of every known shelf
            tab to a corresponding hou.Shelf object.


        """
    @staticmethod
    def tools() -> dict[str, Tool]:
        """

        tools() -> dict of str to hou.Tool

            Returns a dictionary mapping the internal name of every known tool
            to a corresponding hou.Tool object.


            NOTE
                If you only want to get a single tool by its internal name, use
                the tool function. Using shelves.tool(name) is much faster that
                constructing this dictionary and then pulling a single tool out
                of it.


        """
    @staticmethod
    def tool(tool_name: str) -> Optional[Tool]:
        '''

        tool(tool_name) -> hou.Tool or None

            Gets a reference to a hou.Tool by its internal name.

          > >>> hou.shelves.tool(\\"geometry_sphere\\")
          > <hou.Tool \'geometry_sphere\'>

        '''
    @staticmethod
    def isToolDeleted(tool_name: str) -> bool: ...
    @staticmethod
    def loadFile(file_path: str) -> None:
        """

        loadFile(file_path)

            Reads a shelf file and adds any shelves and tools defined in that
            file to Houdini.


        """
    @staticmethod
    def reloadShelfFiles() -> None:
        """

        reloadShelfFiles()

            Reloading the shelf files found in the search path and update the
            shelf UI with any changed information.


        """
    @staticmethod
    def runningTool() -> Optional[Tool]:
        """

        runningTool() -> hou.Tool or None


        """
    @staticmethod
    def beginChangeBlock() -> None:
        '''

        beginChangeBlock()

            Prevents Houdini from automatically rewriting shelf information
            files until endChangeBlock is called.

            Normally, many shelf editing functions and methods cause Houdini to
            rewrite the shelf definition files with the new information. If
            you\'re changing a lot of shelves/tools at once, it could be quite
            slow as each individual change is written separately.

            To speed up batch changes, call beginChangeBlock() first, then
            perform the edits, then call endChangeBlock(). This delays rewriting
            the shelf files until the end when all changes are written at once.


            WARNING
                Always use Python exception handling to ensure the change block
                is closed. Otherwise, subsequent edits in the entire Houdini
                session will not be saved to file, if an exception is thrown in
                the middle of the change block.

          > # Change the icon of every tool to MISC_angry_fruit_salad.
          > # DON\'T ACTUALLY DO THIS!
          > 
          > # First, turn off writing changes
          > hou.shelves.beginChangeBlock()
          > try:
          >     for shelf in hou.shelves.shelves().values():
          >         for tool in shelf.tools():
          >             tool.setIcon(\\"MISC/angry_fruit_salad\\")
          > finally:
          >     # Finish the change block and write all the changes to disk
          >     hou.shelves.endChangeBlock()

            Each call to beginChangeBlock must have a matching call to
            endChangeBlock or Houdini will never actually write your changes to
            disk.


        '''
    @staticmethod
    def endChangeBlock() -> None:
        """

        endChangeBlock()

            See beginChangeBlock above.


        """
    @staticmethod
    def newShelfSet(file_path: Optional[str] = None, name: Optional[str] = None, label: Optional[str] = None) -> ShelfSet:
        """

        newShelfSet(file_path=None, name=None, label=None) -> hou.ShelfSet

            Returns a new hou.ShelfSet object using the provided options. You
            must use this function to create new shelf sets, you can't
            instantiate the ShelfSet class directly.


        """
    @staticmethod
    def newShelf(file_path: Optional[str] = None, name: Optional[str] = None, label: Optional[str] = None) -> Shelf:
        """

        newShelf(file_path=None, name=None, label=None) -> hou.Shelf

            Returns a new hou.Shelf object using the provided options. You must
            use this function to create new shelf tabs, you can't instantiate
            the Shelf class directly.


        """
    @staticmethod
    def newTool(file_path: str|None = ..., name: str|None = ..., label: str|None = ..., script: str|None = ..., language: EnumValue = ..., icon: str|None = ..., help: str|None = ..., help_url: str|None = ..., network_categories: Sequence[NodeTypeCategory] = ..., viewer_categories: Sequence[NodeTypeCategory] = ..., cop_viewer_categories: Sequence[NodeTypeCategory] = ..., network_op_type: str|None = ..., viewer_op_type: str|None = ..., locations: Sequence[str] = ..., hda_definition: HDADefinition|None = ...) -> Tool:
        """

        newTool(file_path=None, name=None, label=None, script=None,
        language=hou.scriptLanguage.Python, icon=None, help=None, help_url=None,
        network_categories=(), viewer_categories=(), cop_viewer_categories=(),
        network_op_type=None, viewer_op_type=None, locations=(),
        hda_definition=None) -> hou.Tool

            Returns a new hou.Tool object using the provided options. You must
            use this function to create new shelf tabs, you can't instantiate
            the Tool class directly.


        """
    @staticmethod
    def defaultFilePath() -> str:
        """

        defaultFilePath() -> str


        """
    @staticmethod
    def defaultToolName(nodetype_category_name: str, nodetype_name: str) -> str: ...

class ShopNode(OpNode):
    """

    hou.ShopNode

    The base class for all SHOP nodes in Houdini. An instance of this class
    corresponds to exactly one instance of a node in Houdini.

    See hou.OpNode for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def shaderString(self, render_type: str|None = ...) -> str:
        '''

        shaderString(self, render_type=None) -> str

            Return the shader string generated by this shader for the given
            render type. This string is written to the file that is read in by
            the renderer.


            render_type
                A string representing the renderer. If this string is empty or
                is \\"*\\", Houdini uses the default render type for this shader.
                Possible render types include \\"VMantra\\" (Mantra), \\"RIB\\"
                (RenderMan), \\"OGL\\" (OpenGL), \\"OGL2\\" (OpenGL 2), and \\"I3D\\" (Image
                3D).

                You can use hou.ShopNodeType.renderMask to determine the render
                types supported by this SHOP\'s type. You can also use
                hou.shopNodeTypeCategory.renderers to get all the possible
                render types. Note that some SHOP types, like the properties
                SHOP or the switch SHOP, have a render mask of \\"*\\" to indicate
                that they will work with any shader type.

            If you pass in an unknown or unsupported render type, this method
            returns an empty string.

          > >>> for node_type_name in (\\"v_plastic\\", \\"ri_matte\\"):
          > ...     hou.node(\\"/shop\\").createNode(node_type_name)
          > 
          > <hou.ShopNode of type v_plastic at /shop/v_plastic1>
          > <hou.ShopNode of type ri_matte at /shop/ri_matte1>
          > 
          > >>> for shop in hou.node(\\"/shop\\").children():
          > ...     for render_type in shop.type().renderMask().split():
          > ...         print shop.name(), \\"supports\\", render_type
          > ...         print \\"    shader_string:\\", shop.shaderString(render_type)
          > ...         print
          > v_plastic1 supports VMantra
          >     shader_string: opdef:/Shop/v_plastic
          > 
          > v_plastic1 supports OGL
          >     shader_string: /shop/v_plastic1
          > 
          > ri_matte1 supports RIB
          >     shader_string: \\"matte\\"
          > 
          > ri_matte1 supports OGL
          >     shader_string: /shop/ri_matte1

        '''
    def shaderCode(self, shader_type: EnumValue|None = ...) -> str: ...
    def shaderName(self, as_otl_path: bool = True, shader_type_name: Optional[str] = None) -> str:
        """

        shaderName(self, as_otl_path=True, shader_type_name=None) -> str

            Return the name of the shader inside this SHOP. If as_otl_path is
            True, returns an opdef: path to the SHOP type. The shader_type_name
            is a string indicating the shader context type to use; some nodes
            may provide several shader types, and each may have a different
            name. This is applicable only to multi-context shader nodes, such as
            a vopnet material shop.


        """
    def supportedRenderers(self) -> Tuple[str, ...]:
        """

        supportedRenderers(self) -> tuple of str

            Returns a list of strings describing the renderers this shader
            supports.


        """
    def definingVopNetNode(self) -> Optional[Node]:
        """

        definingVopNetNode(self) -> hou.VopNetNode or None

            If this SHOP is defined by a VOP network, return the hou.VopNetNode
            that defines it. Otherwise, return None.


        """
    def shaderType(self) -> EnumValue:
        """

        shaderType(self) -> hou.shaderType enum value

            Returns a hou.shaderType indicating the type of this shader.

            Note that this method is a shortcut for self.type().shaderType(),
            which calls hou.ShopNodeType.shaderType.


        """
    def coshaderNodes(self, parm_name: str) -> Tuple[Node, ...]:
        """

        coshaderNodes(self, parm_name) -> tuple of hou.ShopNode

            If this SHOP has a co-shader parameter given by parm_name it may
            also have an input corresponding to that parameter. This function
            will return the tuple of hou.ShopNode assigned as co-shaders to this
            SHOP node either via connected input or the operator node path
            specified in that parameter.

            If the parameter represents a single co-shader, the array will
            contain at most one element, however if the parameter refers to a
            co-shader array then the tuple may contain more than one element.


            parm_name
                Co-shader parameter name specifying the co-shader shop to
                return.


        """

class ShopNodeType(OpNodeType):
    """

    hou.ShopNodeType

    This kind of NodeType contains extra attributes specific to SHOP nodes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def shaderType(self) -> EnumValue:
        """

        shaderType(self) -> [Hom:hou.shaderType] enum value

            Return the type of shader for this SHOP type. For example, this shop
            type might be a surface shader or a displacement shader. See
            hou.shaderType for the possible shader types.

            See also hou.ShopNode.shaderType.


        """
    def renderMask(self) -> str:
        '''

        renderMask(self) -> string

            Return a string with space-separated names of the renderers that
            this SHOP type supports. Note that some SHOP types, like the switch
            SHOP, return \\"*\\" to indicate that they support all renderers.

            See hou.ShopNode.shaderString for an example.


        '''

class SopNode(OpNode):
    """

    hou.SopNode

    Represents a surface node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def geometry(self, output_index: int = 0) -> Optional[Geometry]:
        """

        geometry(self, output_index=0) -> hou.Geometry

            Return the geometry computed by this SOP node. If the SOP has not
            already cooked, this method will cook the SOP.

            The returned Geometry object is not frozen. See hou.Geometry.freeze
            for more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node. This only applies
            to SOP nodes with multiple outputs. If there is no geometry for the
            specified output index then None is returned.


        """
    def geometryNoDep(self, output_index: int = 0) -> Optional[Geometry]:
        """

        geometryNoDep(self, output_index=0) -> hou.Geometry

            Return the geometry computed by this SOP node. If the SOP has not
            already cooked, this method will cook the SOP.

            The returned Geometry object is not frozen. See hou.Geometry.freeze
            for more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node. This only applies
            to SOP nodes with multiple outputs. If there is no geometry for the
            specified output index then None is returned.

            This method doesn't add a dependency on the node when called from a
            Python SOP.


        """
    def geometryDep(self, output_index: int = 0) -> None:
        """

        geometryDep(self, output_index=0)

            Add a geometry dependency without cooking the geometry.

            This method works only when called from a Python SOP.


        """
    def geometryAtFrame(self, frame: float, output_index: int = 0) -> Optional[Geometry]:
        """

        geometryAtFrame(self, frame, output_index=0) -> hou.Geometry

            Return the geometry computed by this SOP node cooked at the
            specified frame. If the SOP has not already cooked, this method will
            cook the SOP.

            The returned Geometry object is frozen. See hou.Geometry.freeze for
            more information on frozen Geometry objects.

            You can optionally specify the output_index argument to request the
            geometry attached to another output on the node. This only applies
            to SOP nodes with multiple outputs. If there is no geometry for the
            specified output index then None is returned.


        """
    def inputGeometry(self, index: int) -> Optional[Geometry]:
        """

        inputGeometry(self, index) -> hou.Geometry

            Return the geometry that is connected to the node input specified by
            index. If there is no geometry connected to the node input specified
            by index, then None is returned.

            The returned Geometry object is not frozen. See hou.Geometry.freeze
            for more information on frozen Geometry objects.


        """
    def inputGeometryAtFrame(self, frame: float, index: int) -> Optional[Geometry]:
        """

        inputGeometryAtFrame(self, frame, index) -> hou.Geometry

            Return the geometry that is connected to the node input specified by
            index and at the specified frame. If there is no geometry connected
            to the node input specified by index, then None is returned.

            The returned Geometry object is frozen. See hou.Geometry.freeze for
            more information on frozen Geometry objects.


        """
    def geometryDelta(self) -> Optional[GeometryDelta]:
        """

        geometryDelta(self) -> hou.GeometryDelta

            Return the geometry delta stored in this SOP node. If the SOP has no
            deltas then None is returned.

            If the SOP recooks, the geometry delta objects will update to the
            SOP's new geometry delta object. If the SOP is deleted, accessing
            the geometry delta object will raise a hou.ObjectWasDeleted
            exception.


        """
    def hasVerb(self) -> bool:
        """

        hasVerb(self) -> bool

            Returns if the node has a verb representation.


        """
    def verb(self) -> Optional[SopVerb]:
        """

        verb(self) -> hou.SopVerb

            Returns the verb associated with a specific node. This allows you to
            run the nodes operation on geometry independently of the node
            itself.


        """
    def selection(self, selection_type: EnumValue) -> Optional[Selection]:
        """

        selection(self, selection_type) -> hou.Selection

            Return the current component selection of the specified component
            type.

            This method is deprecated now that component selections are once
            again managed at the viewer level. See
            hou.SceneViewer.currentGeometrySelection.


        """
    def setSelection(self, selection: Selection) -> None:
        """

        setSelection(self, selection)

            Sets the current component selection to the supplied value. A
            separate selection object is stored for each component type, so
            changing the selection this way may not update the viewport if it is
            not currently set to show this type of selection.

            This method is deprecated now that component selections are once
            again managed at the viewer level. See
            hou.SceneViewer.setCurrentGeometrySelection.


        """
    def curPoint(self) -> Point:
        '''

        curPoint(self) -> Point

            Return this node\'s current point. You would typically call this
            method from an expression on a node that iterates over a set of
            points and re-evaluates the parameter for each point.

            This method lets you implement the Python equivalent of Hscript\'s
            local variables. Many of Houdini\'s SOPs iterate over a set of
            points, and for each point they store the current point and then
            evaluate a parameter. If the parameter contains a local variable,
            Houdini looks up the SOP\'s current point when evaluating that
            variable. For example, the point SOP evaluates the t parameter for
            each point, and sets that point\'s position according to the value of
            the parameter. If that parameter contains, say, the local variable
            $TX, it will evaluate to the x position of the current point.

            This method gives you access to the hou.Point representation of
            Houdini\'s current point. Using this point you could evaluate the
            position, an attribute value, or do more complex operations like
            compute the distance from the point to the origin.

            Raises hou.OperationFailed if you call this method from outside a
            SOP parameter expression, or if the SOP does not support local
            variables.

            The following lists Python equivalents for some point-related
            Hscript expression local variables. Note that you can also access
            local variables from Python using hou.lvar.

          > # $PT (Hscript expression) or lvar(\'PT\') (Python):
          > pwd().curPoint().number()
          > 
          > # $NPT (Hscript expression) or lvar(\'NPT\') (Python):
          > len(pwd().geometry().iterPoints())
          > 
          > # $TX (Hscript expression) or lvar(\'TX\') (Python):
          > pwd().curPoint().position()[0]
          > 
          > # $WEIGHT (Hscript expression) or lvar(\'WEIGHT`) (Python):
          > pwd().curPoint().position()[3]
          > 
          > # $CR (Hscript expression) or lvar(\'CR\') (Python):
          > pwd().curPoint().attribValue(\\"Cd\\")[0]
          > 
          > # $ID (Hscript expression) or lvar(\'ID\') (Python):
          > pwd().curPoint().attribValue(\\"id\\")
          > 
          > # $LIFE (Hscript expression) or lvar(\'LIFE\') (Python):
          > pwd().curPoint().attribValue(\\"life\\")
          > 
          > # $VX (Hscript expression) or lvar(\'VX\') (Python):
          > pwd().curPoint().attribValue(\\"v\\")[0]

        '''
    def setCurPoint(self, point_or_none: Point) -> None:
        """

        setCurPoint(self, point_or_none)

            Set this node's current point. You can only call this method from a
            Python-defined SOP.

            See hou.SopNode.curPoint for an explanation of a SOP's current
            point. You would use this method to set the current point from
            inside a SOP written in Python, before you evaluate a parameter
            containing a local variable referring to the current point. See
            hou.Geometry.globPoints for an example.

            Note that you can set the current point to None. In this case,
            subsequent calls to hou.SopNode.curPoint will raise
            hou.OperationFailed. After a Python SOP is done cooking, Houdini
            will automatically set the current point back to None.

            Raises hou.OperationFailed if called from outside a Python-defined
            SOP.


        """
    def curPrim(self) -> Prim:
        '''

        curPrim(self) -> Prim

            Return this node\'s current primitive. You would typically call this
            method from an expression on a node that iterates over a set of
            primitives and re-evaluates the parameter for each primitive.

            See hou.SopNode.curPoint for more information.

            The following lists Python equivalents for some primitive-related
            Hscript expression local variables. Note that you can also access
            local variables from Python using hou.lvar.

          > # $PR (Hscript expression) or lvar(\'PR\') (Python):
          > pwd().curPrim().number()
          > 
          > # $NPR (Hscript expression) or lvar(\'NPR\') (Python):
          > len(pwd().geometry().iterPrims())
          > 
          > # $NX (Hscript expression) or lvar(\'NX\') (Python):
          > pwd().curPrim().attribValue(\\"N\\")[0]
          > pwd().curPrim().normal()[0]
          > 
          > # $CR (Hscript expression) or lvar(\'CR\') (Python):
          > pwd().curPrim().attribValue(\\"Cd\\")[0]

        '''
    def setCurPrim(self, prim_or_none: Prim) -> None:
        """

        setCurPrim(self, prim_or_none)

            Set this node's current primitive. You can only call this method
            from a Python-defined SOP. See hou.SopNode.setCurPoint for more
            information.


        """
    def curVertex(self) -> Vertex:
        """

        curVertex(self) -> Vertex

            Return this node's current vertex. You would typically call this
            method from an expression on a node that iterates over a set of
            primitive vertices and re-evaluates the parameter for each vertex.

            See hou.SopNode.curPoint for more information.

            Note that hou.SopNode.curPrim returns the primitive containing this
            vertex returned by this method.

            The following lists Python equivalents for some vertex-related
            Hscript expression local variables. Note that you can also access
            local variables from Python using hou.lvar.

          > # $VTX (Hscript expression) or lvar('VTX') (Python):
          > pwd().curVertex().number()
          > 
          > # $NVTX (Hscript expression) or lvar('NVTX') (Python):
          > pwd().curPrim().numVertices()

        """
    def setCurVertex(self, vertex_or_none: Vertex) -> None:
        """

        setCurVertex(self, vertex_or_none)

            Set this node's current primitive. You can only call this method
            from a Python-defined SOP. See hou.SopNode.setCurPoint for more
            information.

            Note that setting the current vertex will also set the current
            primitive to the primitive containing the vertex.


        """
    def managesAttribDataIds(self) -> bool:
        """

        managesAttribDataIds(self) -> bool

            Returns whether this node manages attribute data ids. When true,
            then it is the responsibility of the cooking code to increment the
            appropriate data ids when changing any of the output geometry. This
            defaults to False.


        """
    def setManagesAttribDataIds(self, on: bool) -> None:
        """

        setManagesAttribDataIds(self, on)

            This method can only be called during the cook of the node itself.
            It declares responsibility for whether the cooking code for the node
            will increment the appropriate data ids when modifying its output
            geometry.

            When this property is False, all data ids on the output is
            automatically incremented after cooking. Setting this to True
            prevents this automatic incrementing from happening. The cooking
            code is then responsible for calling one of data id incrementing
            methods such as: hou.Geometry.incrementDataIdsForAddOrRemove,
            hou.Geometry.incrementPrimitiveIntrinsicsDataId,
            hou.Geometry.incrementTopologyDataId, hou.Attrib.incrementDataId,
            hou.PointGroup.incrementDataId, hou.PrimGroup.incrementDataId,
            hou.EdgeGroup.incrementDataId.

            When unsure, it is better to leave this to the default False or else
            there is a risk that users of the output geometry (eg. the viewport)
            will fail to update when the geometry has changed. When modifying
            geometry outside of cooking, then there is no automatic data id
            incrementing process. In that case, the most conservative action is
            to call hou.Geometry.incrementAllDataIds whenever modifying
            geometry.


            NOTE
                On the , the Maintain State parameter also needs to be enabled
                to perform these data id optimizations since one must record
                these values across different cooks of the node.


        """
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Return whether this node's bypass flag is on.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turn this node's bypass flag on or off, making this node have no
            effect.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Return whether this node's display flag is on.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turn this node's display flag on or off.


        """
    def isRenderFlagSet(self) -> bool:
        """

        isRenderFlagSet(self) -> bool

            Return whether this node's render flag is on.


        """
    def setRenderFlag(self, on: bool) -> None:
        """

        setRenderFlag(self, on)

            Turns this node's render flag on or off.


        """
    def isTemplateFlagSet(self) -> bool:
        """

        isTemplateFlagSet(self) -> bool

            Returns whether this node's template flag is on. Templated SOPs are
            display as wireframe in the viewport, and you cannot select geometry
            from them.


        """
    def setTemplateFlag(self, on: bool) -> None:
        """

        setTemplateFlag(self, on)

            Turns this node's template flag on or off.


        """
    def isSelectableTemplateFlagSet(self) -> bool:
        """

        isSelectableTemplateFlagSet(self) -> bool

            Return whether this node's selectable template flag is on. A
            selectable template displays like the display SOP in the viewport,
            and you can select it when choosing points, primitives, etc. Note
            that only the display SOP will be included in the containing
            geometry object or SOP subnet, however, so selectable templates are
            only visible while working inside their SOP network.


        """
    def setSelectableTemplateFlag(self, on: bool) -> None:
        """

        setSelectableTemplateFlag(self, on)

            Turn this node's selectable template flag on or off.


        """
    def isHighlightFlagSet(self) -> bool:
        """

        isHighlightFlagSet(self) -> bool

            Return whether this node's highlight flag is on. When this flag is
            turned on, Houdini displays portions of the geometry in yellow in
            the viewport, to indicate the operations performed by this SOP.


        """
    def setHighlightFlag(self, on: bool) -> None:
        """

        setHighlightFlag(self, on)

            Turn this node's highlight flag on or off.


        """
    def isSoftLocked(self) -> bool:
        """

        isSoftLocked(self) -> bool

            Return whether this node is soft-locked. A soft-locked node stores
            position delta information , preventing all but a small set of
            manual modeling changes from being made.


        """
    def setSoftLocked(self, on: bool) -> None:
        """

        setSoftLocked(self, on)

            Turns this node's soft-lock flag on or off, allowing a subset of
            manual modeling changes to be made to the locked node.


        """
    def isHardLocked(self) -> bool:
        """

        isHardLocked(self) -> bool

            Return whether this node is hard-locked. A hard-locked node stores
            its data inside the node, and no longer responds to parameter or
            input node changes.


        """
    def setHardLocked(self, on: bool) -> None:
        """

        setHardLocked(self, on)

            Turn this node's hard-lock flag on or off. Locking a node saves its
            current cooked geometry into the node. If you unlock a hard-locked
            node, it will discard its locked geometry data and recook, computing
            its geometry from its inputs and parameters.


        """
    def isUnloadFlagSet(self) -> bool:
        """

        isUnloadFlagSet(self) -> bool

            Returns whether this node's unload flag is on.


        """
    def setUnloadFlag(self, on: bool) -> None:
        """

        setUnloadFlag(self, on)

            Turns this node's unload flag on or off.


        """
    def copyNodeSelectionToUserSelection(self, force_cook: bool = False) -> None: ...
    def displayNode(self) -> Optional[Node]:
        """

        displayNode(self) -> Node

            If this is a subnet SOP, return the SOP inside the subnet with its
            display flag on. Otherwise, return None.


        """
    def renderNode(self) -> Optional[Node]:
        """

        renderNode(self) -> hou.OpNode

            If this is a subnet SOP, return the SOP inside the subnet with its
            render flag on. Otherwise, return None.


        """

class SopNodeType(OpNodeType):
    """

    hou.SopNodeType

    This kind of NodeType contains extra attributes specific to SOP nodes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def selectors(self, selector_indices: Sequence[int] = ...) -> Tuple[Selector,...]:
        """

        selectors(self, selector_indices=()) -> tuple of hou.Selector

            Return all the selectors for this node type. See
            hou.SopNodeType.addSelector and hou.Selector for more information.

          > def sopSelectorTypes():
          >     '''Return a list of all the SOP selector type names.'''
          >     selector_types = []
          >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
          >         # Skip manager nodes, like shopnets, ropnets, etc.
          >         if not isinstance(node_type, hou.SopNodeType):
          >             continue
          > 
          >         for selector in node_type.selectors():
          >             selector_type = selector.selectorType()
          >             if selector_type not in selector_types:
          >                 selector_types.append(selector_type)
          >     selector_types.sort()
          >     return selector_types
          > def sopTypeNamesUsingSelector(selector_type):
          >     '''Given the name of a selector type, return a list of all the SOP
          >        node types using that selector.'''
          >     node_types = []
          >     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
          >         # Skip manager nodes, like shopnets, ropnets, etc.
          >         if not isinstance(node_type, hou.SopNodeType):
          >             continue
          > 
          >         for selector in node_type.selectors():
          >             if selector.selectorType() == selector_type:
          >                 node_types.append(node_type)
          > 
          >     result = [node_type.name() for node_type in node_types]
          >     result.sort()
          >     return result

        """
    def addSelector(self, name: str, selector_type: str, prompt: str = ..., primitive_types: Sequence[EnumValue] = ..., group_parm_name: str|None = ..., group_type_parm_name: str|None = ..., input_index: int = ..., input_required: bool = ..., allow_dragging: bool = ..., empty_string_selects_all: bool = ...) -> Selector:
        '''

        addSelector(self, name, selector_type, prompt=\'Select components\',
        primitive_types=(), group_parm_name=None, group_type_parm_name=None,
        input_index=0, input_required=True, allow_dragging=False,
        empty_string_selects_all=True) -> hou.Selector

            Add a selector to this SOP node type. When the user creates a new
            instance of this SOP in the viewer, Houdini will invoke all the
            selectors, wait for the user to select geometry, and then connect
            input SOPs and fill in group parameters to match what was selected.


            name
                A name to give this selector. The name must be unique within
                this node type.

            selector_type
                The name of the type of selector to use. Different selectors
                have different behaviors. For example prims will select only
                primitives and is used, for example, by the cookie SOP. points
                will select only points, and is used by SOPs like the point SOP.
                everything will select any geometry, and is used for SOPs like
                xform and blast.

            prompt
                A string to display at the bottom of the viewer to instruct the
                user what to select.

            primitive_types
                A sequence of hou.primType enumeration values to specify what
                primitive types are allowed. This parameter has no effect if the
                selector does not select primitives. If this sequence is empty,
                all primitive types will be allowed.

            group_parm_name
                The name of the SOP node parameter containing the group field.
                The selector will set this parameter to the string representing
                the points, primitives, edges, etc. chosen by the user in the
                viewer. If None, the selector will look for a parameter named
                group.

            group_type_parm_name
                The name of the SOP node parameter containing the menu of
                geometry types. If the selector can select multiple geometry
                types (e.g. points or primitives), it will set this parameter to
                match the type of geometry the user chose. The transform SOP,
                for example, has a Group Type parameter that tells it how to
                interpret the string in the Group parameter. If None, the
                selector will look for a parameter named grouptype.

            input_index
                The index of the input connector on the SOP node where the
                selector should wire input SOPs. A cookie SOP, for example, has
                two input connectors. It has two selectors, one for each input
                connector.

            input_required
                Whether or not this input is required or optional. If the user
                does not select any geometry and the input is not required, the
                selector will not wire anything to its input connector.

            allow_dragging
                Whether the user is allowed to select the geometry and begin
                manipulating the handles with a single mouse drag. A transform
                SOP, for example, lets you select the geometry and drag it right
                away to transform it. Dragging the geometry forces the selector
                to finish immediately, the selector connects the input and sets
                the group parameter, and subsequent mouse movements are passed
                to the handle which translates the geometry by changing
                parameter values.

            empty_string_selects_all
                Whether or not to use an empty string in the group parameter if
                the user selects all the geometry. If False, Houdini will place
                an asterisk (*) in the group parameter when the user selects all
                the geometry. Most SOPs use an empty string.

            You would typically call this method from the shelf tool script of a
            digital asset. For example, you might put the following in the Tools
            script section of a Python sop that transforms points (having a
            parameter named group):

          > hou.sopNodeTypeCategory().nodeTypes()[\'$HDA_NAME\'].addSelector(
          >     \\"Points to Transform\\",
          >     \\"points\\",
          >     prompt=\\"Select the points to transform and press Enter to complete\\",
          >     group_parm_name=\\"group\\")

            See also hou.Geometry.globPoints and hou.Geometry.globPrims for
            information on how to parse the strings the selector puts in the
            group field.

            See also hou.Selector.


        '''

class SopVerb(OpVerb):
    """

    hou.SopVerb

    Represents the code of a surface node.

    See using a verb for more information.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def execute(self, dest: Geometry, inputs: Sequence[Geometry]) -> None:
        """

        execute(self, destgeo, inputgeolist)

            Applies the verb to the giving destination hou.Geometry. The input
            list is a list of hou.Geometry corresponding to the source node's
            inputs. The parameters used in execution are whatever was set with
            the setParms or loadParmsFromNode functions. The parameters are
            initialized with the node defaults.

            NOTE: Node defaults may change between versions.


        """
    def executeAtTime(self, dest: Geometry, inputs: Sequence[Geometry], time: float, add_time_dep: bool) -> None:
        """

        executeAtTime(self, destgeo, inputgeolist, time, add_time_dep)

            Applies the verb to the giving destination hou.Geometry at a given
            cooking time. The input list is a list of hou.Geometry corresponding
            to the source node's inputs. The parameters used in execution are
            whatever was set with the setParms or loadParmsFromNode functions.
            The parameters are initialized with the node defaults.

            NOTE: Node defaults may change between versions.


        """

class StringKeyframe(BaseKeyframe):
    """

    hou.StringKeyframe

    """
    thisown: Incomplete
    def __init__(self, expression: str|None = ..., time: float|None = ..., language: EnumValue|None = ...) -> None:
        """

        hou.StringKeyframe

        """
    __swig_destroy__: Incomplete
    def evaluatedType(self) -> EnumValue:
        """

        evaluatedType(self) -> hou.parmData enum value

            Return the data type of the keyframe's evaluated value. For string
            keyframes this method returns hou.parmData.String.


        """

class StringParmTemplate(ParmTemplate):
    """

    hou.StringParmTemplate

    Describes a parameter tuple containing string values. These values can
    be arbitrary strings or references to files or nodes

    Note that string parameters may also be menu parameters. String
    parameters with menus are different from hou.MenuParmTemplate objects
    because menu parm templates evaluate to integers.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, num_components: int, default_value: Sequence[str] = ..., naming_scheme: EnumValue = ..., string_type: EnumValue = ..., file_type: EnumValue = ..., menu_items: Sequence[str] = ..., menu_labels: Sequence[str] = ..., icon_names: Sequence[str] = ..., item_generator_script: str|None = ..., item_generator_script_language: EnumValue|None = ..., menu_type: EnumValue = ..., disable_when: str|None = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ..., default_expression: Sequence[str] = ..., default_expression_language: Sequence[EnumValue] = ...) -> None:
        """

        __init__(self, name, label, num_components, default_value=(),
        naming_scheme=hou.parmNamingScheme.Base1,
        string_type=hou.stringParmType.Regular, file_type=hou.fileType.Any,
        menu_items=(), menu_labels=(), icon_names=(),
        item_generator_script=None, item_generator_script_language=None,
        menu_type=hou.menuType.Normal, disable_when=None, is_hidden=False,
        is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=(), default_expression_language=())

            Construct a new StringParmTemplate.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information.

            num_components
                See hou.ParmTemplate.numComponents for more information.

            default_value
                See the defaultValue method for more information.

            string_type
                See the stringType method for more information. This parameter
                determines whether the parm template is for arbitrary strings,
                node references, or file references.

            file_type
                See the fileType method for more information. This parameter
                determines the file type when string_type is
                hou.stringParmType.FileReference.

            look
                See hou.ParmTemplate.look for more information.

            naming_scheme
                See hou.ParmTemplate.namingScheme for more information.

            menu_items
                See the menuItems method for more information. Note that
                num_components must be 1 if menu items are supplied.

            menu_labels
                See the menuLabels method for more information.

                If this parameter is not given, it defaults to the value of the
                menu_items parameter.

            icon_names
                See the iconNames method for more information.

                If this parameter is an empty tuple, the menu will not contain
                icons.

            item_generator_script
                See the itemGeneratorScript method for more information. for
                more information. Note that num_components must be 1 if a script
                is given.

            item_generator_script_language
                See the itemGeneratorScriptLanguage method for more information.
                If this parameter is None it defaults to
                hou.scriptLanguage.Python.

            menu_type
                See the menuType method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.


        """
    __swig_destroy__: Incomplete
    def stringType(self) -> EnumValue:
        """

        stringType(self) -> hou.stringParmType enum value

            Return the type of this string parameter. This type determines
            whether the parameter has special selection controls to choose a
            file path or the paths to one or more nodes.

            See hou.stringParmType for more information.


        """
    def setStringType(self, string_type: EnumValue) -> None:
        """

        setStringType(self, string_type)

            Set the type of this string parameter to a hou.stringParmType enum
            value.

            See the stringType method for more information.


        """
    def fileType(self) -> EnumValue:
        """

        fileType(self) -> hou.fileType enum value

            Return the file type of this string parameter. The file type applies
            only when stringType() == hou.stringParmType.FileReference. Only
            hou.fileType.Any, hou.fileType.Image, and hou.fileType.Geometry are
            supported by dialog scripts.

            See hou.fileType for more information.


        """
    def setFileType(self, file_type: EnumValue) -> None:
        """

        setFileType(self, file_type)

            Set the type of this string parameter to a hou.fileType enum value.

            See the fileType method for more information.


        """
    def defaultValue(self) -> Tuple[str, ...]:
        """

        defaultValue(self) -> tuple of str

            Return the default value for new parameter instances.

            The number of strings in the return value is the same as the number
            of components in the parm template.


        """
    def setDefaultValue(self, default_value: Sequence[str]) -> None:
        """

        setDefaultValue(self, tuple_of_default_values)

            Set the default value for new parameter instances to a sequence of
            strings.

            See the defaultValue method for more information. Note that if the
            number of strings in the sequence is different from the number of
            components in the parm template, any extra values will be discarded
            and any missing values will become the last value in the sequence or
            an empty string if the sequence is empty.


        """
    def defaultExpression(self) -> Tuple[str, ...]:
        """

        defaultExpression(self) -> tuple of strings

            Return the default expression for new parameter instances.

            The default expression takes precedence over the default value. If a
            component has no default expression (i.e. an empty string), then the
            default value is used for new parameter instances.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
    def setDefaultExpression(self, default_expression: Sequence[str]) -> None:
        """

        setDefaultExpression(self, tuple_of_default_expressions)

            Set the default expression for new parameter instances to a sequence
            of strings.

            See the hou.StringParmTemplate.defaultExpression method for more
            information. Note that if the number of strings in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expressions will
            become the empty string.


        """
    def defaultExpressionLanguage(self) -> Tuple[EnumValue, ...]:
        """

        defaultExpressionLanguage(self) -> tuple of hou.scriptLanguage

            Return the default expression language for new parameter instances.

            The default expression language only applies if the default
            expression is set. If the default expression of a component is not
            set, then the expression language is set to
            hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: Sequence[EnumValue]) -> None:
        """

        setDefaultExpressionLanguage(self,
        tuple_of_default_expression_languages)

            Set the default expression language for new parameter instances to a
            sequence of hou.scriptLanguage values.

            See the defaultExpressionLanguage method for more information. Note
            that if the number of hou.scriptLanguage values in the sequence is
            different from the number of components in the parm template, any
            extra values will be discarded and any missing expression languages
            will become hou.scriptLanguage.Hscript.


        """
    def menuItems(self) -> Tuple[str, ...]:
        """

        menuItems(self) -> tuple of str

            Return the tuple of internal menu names. If this string does not use
            a menu, returns an empty tuple.

            These internal menu names are not displayed in the UI, but they can
            be passed to hou.Parm.set and will be returned by
            hou.Parm.evalAsString for menu parameters.


        """
    def setMenuItems(self, menu_items: Sequence[str]) -> None:
        """

        setMenuItems(self, menu_items)

            Set the internal menu names to the given sequence of strings.

            See the menuItems method for more information.

            If the new number of menu items is less than the old number, the
            menu labels will be shortened and the default value will be modified
            if it is out of range.


        """
    def menuLabels(self) -> Tuple[str, ...]:
        """

        menuLabels(self) -> tuple of str

            Return the tuple of menu labels displayed in the UI. These labels
            are used when this parm template uses a menu.


        """
    def setMenuLabels(self, menu_labels: Sequence[str]) -> None:
        """

        setMenuLabels(self, menu_labels)

            Set the menu labels displayed in the UI to the given sequence of
            strings.

            If the number of menu labels is less than the number of menu items,
            Houdini uses the internal menu item names for the missing labels. If
            the number of labels is more than the number of menu items, Houdini
            discards the extra labels.

            If you want to change both the menu items and menu labels, be sure
            to change the menu items first.


        """
    def iconNames(self) -> Tuple[str, ...]:
        """

        iconNames(self) -> tuple of str

            Return the tuple of icons corresponding to the menu items. If there
            are no icons, returns a tuple of empty strings.

            These icons are used when this parm template uses a menu.


        """
    def setIconNames(self, icon_names: Sequence[str]) -> None:
        """

        setIconNames(self, icon_names)

            Set the icon names to the given sequence of strings.


        """
    def itemGeneratorScript(self) -> str:
        """

        itemGeneratorScriptLanguage(self) -> hou.scriptLanguage enum value

            Return the script used to generate menu items, or an empty string if
            there is no such script.


        """
    def setItemGeneratorScript(self, item_generator_script: str) -> None:
        """

        setItemGeneratorScript(self, item_generator_script)

            Set the script used to generate menu items.

            See the itemGeneratorScript method for more information.


        """
    def itemGeneratorScriptLanguage(self) -> EnumValue: ...
    def setItemGeneratorScriptLanguage(self, language: EnumValue) -> None:
        """

        setItemGeneratorScriptLanguage(self, language)

            Set the script language used to generate menu items to a
            hou.scriptLanguage enum value.

            See the itemGeneratorScriptLanguage method for more information.


        """
    def menuType(self) -> EnumValue:
        """

        menuType(self) -> hou.menuType enum value

            Return the type of menu. See hou.menuType for more information.


        """
    def setMenuType(self, menu_type: EnumValue) -> None:
        """

        setMenuType(self, menu_type)

            Set the type of menu to a hou.menuType enum value.

            See the menuType method for more information.


        """

class styles:
    """

    hou.styles

    A module for managing style sheets that are stored with the hip file.

    This module provides functions for accessing and managing style sheets
    that are stored in the hip file as text strings in JSON format. These
    style sheets can be saved into IFD files generated by the ROP.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def hasStyle(name: str) -> bool:
        """

        hasStyle(name) -> bool

            Returns true if there is a style with the specified name.


        """
    @staticmethod
    def styles(pattern: Optional[str] = None) -> Tuple[str, ...]:
        """

        styles() -> tuple of str

            Return a tuple containing the names of all styles in the style
            manager.


        """
    @staticmethod
    def description(style: str) -> str:
        """

        description(name) -> str

            Returns the description associated with the named style. If there is
            no style with the provided name, an empty string is returned.


        """
    @staticmethod
    def stylesheet(style: str) -> str:
        """

        stylesheet(name) -> str

            Returns the style sheet text associated with the named style. If
            there is no style with the provided name, an empty string is
            returned.


        """
    @staticmethod
    def errors(style: str) -> str:
        """

        errors(name) -> str

            Returns any error messages generated while parsing the named style.
            If there is no style with the provided name, an empty string is
            returned.


        """
    @staticmethod
    def addStyle(name: str, description: str, stylesheet: str) -> None:
        """

        addStyle(name, description, stylesheet)

            Create a new named style. If a style sheet with the supplied name
            already exists, it will be overwritten with the new values.


            name
                A unique name that will be used to identify the style sheet.
                Follows the same naming limitations as node names (no spaces, no
                slashes, etc).

            description
                An arbitrary string that can optionally be used to identify the
                purpose of this style sheet.

            stylesheet
                The style sheet definition expressed as a string in JSON format.


        """
    @staticmethod
    def renameStyle(old_name: str, new_name: str) -> None:
        """

        renameStyle(old_name, new_name)

            Changes the name of an existing style sheet. If there is no style
            with the provided old_name, or there is already a style with the
            provided new_name, an exception will be generated. References to
            this style sheet in the hip file will be automatically updated to
            refer to the new name.


        """
    @staticmethod
    def reorderStyles(names: Sequence[str]) -> None:
        """

        reorderStyles(names)

            Changes the order of the style sheets defined in the hip file. This
            order determines the order of the style names returned by the styles
            function. This in turn may affect the final material assignments in
            a mantra render, since priority is given to style sheets listed last
            in the Apply Style Sheets parameter of the ROP.


            names
                A tuple of strings which must contain exactly the same set of
                strings returned by the styles function, but in a different
                order. If the set of strings do not match, this function raises
                a ValueError.


        """
    @staticmethod
    def removeStyle(name: str) -> None:
        """

        removeStyle(name)

            Deletes an existing style sheet.


        """
    @staticmethod
    def removeAll() -> None:
        """

        removeAll()

            Deletes all existing style sheets.


        """

class StyleSheet:
    """

    hou.StyleSheet

    A class that represents a Houdini style sheet. It can be used to
    evaluate, test, and debug style sheet output.

    Unlike the hou.styles module, the style sheets represented by this class
    are not saved anywhere. They are parsed style sheets that can be
    evaluated for particular objects and geometry. This allows you to debug
    the operation of your style sheets outside of mantra. It also allows
    building SOPs which evaluate style information to apply it to a more
    specific target.


    """
    thisown: Incomplete
    def __init__(self, json_text: str = ...) -> None:
        """

        __init__(self, json_text)

            Creates a new StyleSheet from the provided string in JSON format.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def clone(self) -> StyleSheet:
        """

        clone(self) -> hou.StyleSheet

            Makes an identical copy of an existing style sheet object.


        """
    def cloneWithObject(self, obj: Node) -> StyleSheet:
        """

        cloneWithObject(self, object) -> hou.StyleSheet

            Makes a copy of an existing style sheet object which contains only
            the styling information that applies to the provided hou.ObjNode.


        """
    def cloneWithPrim(self, prim: Prim) -> StyleSheet:
        """

        cloneWithPrim(self, prim) -> hou.StyleSheet

            Makes a copy of an existing style sheet object which contains only
            the styling information that applies to the provided hou.Prim.


        """
    def cloneWithShape(self, shape_name: str, agent_prim: Prim) -> StyleSheet:
        """

        cloneWithShape(self, shape_name, prim) -> hou.StyleSheet

            Makes a copy of an existing style sheet object which contains only
            the styling information that applies to the named shape in the
            provided crowd agent hou.PackedPrim.


        """
    def cloneWithAddedStyleSheet(self, stylesheet: StyleSheet, target: str|None = ...) -> StyleSheet:
        """

        cloneWithAddedStyleSheet(self, stylesheet, target) -> hou.StyleSheet

            Makes a copy of an existing style sheet object combined with another
            style sheet object. The added styles are given a lower priority than
            the styles already in the style sheet. In addition, a target
            argument can be provided which is a JSON formatted string describing
            a target condition which must be satisfied in order for the added
            styles to be applied. This function can therefore be used to build
            an object level style sheet by combining per-primitive style sheets
            from the object's geometry.


        """
    def errors(self) -> str:
        """

        errors(self) -> str

            Returns any errors generated while parsing the style sheet. If there
            are no errors, an empty string is returned. For style sheet objects
            returned from any of the cloneWith methods, the returned string will
            always be empty.


        """
    def asJSON(self) -> str:
        """

        asJSON(self) -> str

            Returns a string containing the JSON that represents the style
            sheet. If the style sheet was constructed from a string argument,
            the original string will be returned even if there were parsing
            errors. If this style sheet was cloned with a specific target, the
            JSON string is generated from the style information that applies to
            that target.


        """

class SubnetIndirectInput(IndirectInput):
    """

    hou.SubnetIndirectInput

    A node-like item that appears inside subnets and corresponds to the node
    wired into the subnet.

    For example, suppose you have a font SOP, polyextrude SOP, and facet SOP
    connected together in a chain. If you collapse the polyextrude and facet
    SOPs into a subnet, you're left with a font SOP connected to a subnet
    SOP. Inside the subnet SOP is subnet indirect input #1 connected to a
    polyextrude SOP, which is connected to the facet SOP.

    Each subnet indirect input is numbered starting from 0 and corresponds
    to an input connector on the subnet. (See hou.NodeConnection for more
    information on input connectors.)

    The names of the subnet indirect inputs in the network pane correspond
    to the contents of the Input #n Label parameters on the subnet node,
    where n is the number.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def inputConnections(self) -> Tuple[NodeConnection, ...]:
        """

        inputConnections(self) -> tuple of hou.NodeConnection

            Returns an empty tuple. This method exists to mirror similar methods
            on hou.Node and hou.NetworkDot. This allows these network items to
            be treated in a more uniform way in Python code.


        """
    def number(self) -> int:
        """

        number(self) -> int

            Return the number of the corresponding input connector on the
            subnet. Note that input numbers are zero based, so the first input
            will return 0.


        """

class OpSubnetIndirectInput(OpIndirectInput, SubnetIndirectInput):
    """

    hou.OpSubnetIndirectInput

    A node-like item that appears inside OP subnets and corresponds to the
    node wired into the subnet.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __hash__(self) -> int: ...

class Surface(Prim):
    """

    hou.Surface

    A Surface is a kind of geometry primitive (Prim object) that contains a
    two dimensional grid of vertices (Vertex objects). How these vertices
    are used depends on the type of surface: meshes, for example, use the
    vertices to define a quadrilateral mesh, while NURBS surfaces use them
    as control points.

    A hou.Face, on the other hand, stores a sequence of vertices, and might
    be a polygon or NURBS curve.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def numRows(self) -> int:
        """

        numRows(self)

            Return the number of rows in the 2D array of vertices.


        """
    def numCols(self) -> int:
        """

        numCols(self)

            Return the number of columns in the 2D array of vertices.


        """
    def vertex(self, u_index: int, v_index: int) -> Vertex:
        '''

        vertex(self, u_index, v_index)

            Return an element in the 2D array of vertices, given the u (column)
            and v (row) indices into the array.

            Negative indices are allowed, in which case Houdini will index
            starting from the last vertex.

            For non-negative indices, this method is roughly equivalent to
            writing surf.vertices()[v_index * surf.numCols() + u_index].

            Raises hou.OperationFailed if the u or v indices are invalid.

          > # Use a grid SOP to create a NURBS grid with 3 rows and 2 columns.
          > geo = hou.node(\\"/obj\\").createNode(\\"geo\\").createNode(\\"grid\\").geometry()
          > grid_node = geo.sopNode()
          > grid_node.setDisplayFlag(True)
          > for name, value in (\\"type\\", \\"nurbs\\"), (\\"rows\\", 5), (\\"cols\\", 4):
          >     grid_node.parm(name).set(value)
          > 
          > # Print out the x positions of all the vertices in the surface.
          > surf = geo.iterPrims()[0]
          > for v_index in surf.numRows():
          >     for u_index in surf.numCols():
          >         print surf.vertex(u_index, v_index).point().position()[0],
          >     print

            See also:

          * hou.Prim.vertices

          * hou.Surface.verticesInCol

          * hou.Surface.verticesInRow

          * hou.Geometry.iterPrims


        '''
    def verticesInRow(self, v_index: int) -> Tuple[Vertex, ...]:
        """

        verticesInRow(self, v_index)

            Given a v (i.e. row) index, return a tuple containing all the
            vertices in that row.

            See also hou.Prim.vertices.


        """
    def verticesInCol(self, u_index: int) -> Tuple[Vertex, ...]: ...
    def isClosedInU(self) -> bool:
        """

        isClosedInU(self)

            Return whether the first and last columns of vertices are connected.

            A grid, for example, is open in both U and V. A tube is open in one
            of U or V and closed in the other. A torus is closed in both U and
            V.


        """
    def isClosedInV(self) -> bool:
        """

        isClosedInV(self)

            Return whether the first and last rows of vertices are connected.

            See hou.Surface.isClosedInU for more information.


        """
    def positionAt(self, u: float, v: float) -> Vector3:
        """

        positionAt(self, u, v) -> hou.Vector3

            Given normalized (i.e. from 0 to 1) u and v values, returns the
            position of the surface at that parametric location.

            See the surface_wires cookbook example for an example.


        """
    def normalAt(self, u: float, v: float) -> Vector3:
        """

        normalAt(self, u, v) -> Vector3

            Given normalized (i.e. from 0 to 1) u and v values, returns the
            normal of the surface at that parametric location. The normal is a
            vector that is perpendicular to the surface at that location.

            The normal vector is normalized (i.e. it is a unit vector, so its
            length is 1).

            See the surface_wires cookbook example for an example.


        """
    def attribValueAt(self, attrib_or_name: Attrib|str, u: float, v: float, du: float = ..., dv: float = ...) -> int|float|str|Tuple[int,...]|Tuple[float,...]:
        """

        attribValueAt(self, attrib_or_name, u, v, du=0, dv=0) -> int, float, str
        or tuple

            Return an attribute value at a normalized (u, v) parametric position
            on the surface. If du and dv are both 0, returns the interpolated
            attribute value; otherwise, returns the (partial) derivative of the
            attribute value.

            Raises hou.OperationFailed if the attribute is not a point or vertex
            attribute. If you want a primitive attribute value, it doesn't vary
            across the surface, so use hou.Prim.attribValue.


        """
    def addRow(self, after: int = -1) -> None:
        """

        addRow(self, after=-1)

            Add a row of vertices after the given v (i.e. row) index. The new
            vertices are located at the origin until you move them. You would
            typically call this method from the code of a Python-defined SOP.

            See hou.Surface.addCol for more information.


        """
    def addCol(self, after: int = -1) -> None:
        """

        addCol(self, after=-1)

            Add a column of vertices after the given u (i.e. column) index. You
            would typically call this method from the code of a Python-defined
            SOP.

            This method also adds one point per vertex added. The new points are
            located at the origin until you move them.

            The u (i.e. column) index after may be negative, in which case the
            indexing starts from the end. By default, after is -1, meaning that
            the new column will go after the last column. Raises
            hou.OperationFailed if the after index is invalid.

          > 
          > # This code will work from inside a Python SOP, but not from the Python
          > # shell.
          > def vertexPos(vertex):
          >     return hou.Vector3(vertex.point().position())
          > 
          > # Build a NURBS surface.
          > geo = hou.pwd().geometry()
          > surf = geo.createNURBSSurface(10, 10)
          > 
          > # Add a new column, and set the new point positions to the average of
          > # the adjacent point positions.
          > surf.addCol(after=7)
          > for v_index in range(surf.numRows()):
          >     vertex_before = surf.vertex(7, v_index)
          >     vertex_after = surf.vertex(9, v_index)
          >     surf.vertex(8, v_index).point().setPosition(
          >         (vertexPos(vertex_before) + vertexPos(vertex_after)) * 0.5)

        """

class Take:
    """

    hou.Take

    RELATED

      * hou.takes


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isCurrent(self) -> bool:
        """

        isCurrent(self) -> bool

            Return True if the take is the current take and False otherwise.


        """
    def name(self) -> str:
        """

        name(self)

            Return the name of the take.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Rename the take.


        """
    def parent(self) -> Optional[Take]:
        """

        parent(self) -> hou.Take

            Return the parent take or None if this take is the main (master)
            take.


        """
    def path(self) -> str:
        """

        path(self) -> str

            Return the path of the take. The take path consists of the name of
            this take as well as the names of its ancestor takes.


        """
    def addChildTake(self, name: Optional[str] = None) -> Take:
        """

        addChildTake(self, name) -> hou.Take

            Create a new take with the given name and add it as a child to this
            take.

            If no name is specified then the take will have a generated name
            based on the default take name.


        """
    def insertTakeAbove(self, name: Optional[str] = None) -> Take:
        """

        insertTakeAbove(self, name) -> hou.Take

            Create a new take with the given name and add it as a child of this
            take's parent. This take is reparented with the newly created take
            as the parent.

            Raise hou.OperationFailed if this take is the main (master) take.


        """
    def addNodeDisplayFlag(self, node: Node) -> None:
        """

        removeNodeDisplayFlag(self, node)

            Exclude the given node's display flag from this take making it
            uneditable in this take.

            This method does nothing if the node's display flag is not included
            in the take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def removeNodeDisplayFlag(self, node: Node) -> None: ...
    def addNodeBypassFlag(self, node: Node) -> None:
        """

        removeNodeBypassFlag(self, node)

            Exclude the given node's bypass flag from this take making it
            uneditable in this take.

            This method does nothing if the node's bypass flag is not included
            in the take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def removeNodeBypassFlag(self, node: Node) -> None: ...
    def addNodeRenderFlag(self, node: Node) -> None:
        """

        removeNodeRenderFlag(self, node)

            Exclude the given node's render flag from this take making it
            uneditable in this take.

            This method does nothing if the node's render flag is not included
            in the take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def removeNodeRenderFlag(self, node: Node) -> None: ...
    def hasParmTuple(self, parm_tuple: ParmTuple) -> bool:
        """

        hasParmTuple(self, parm_tuple) -> bool

            Return True if the given parameter is included in this take and
            False otherwise.

            Raise hou.OperationFailed if the parm_tuple argument is None.


        """
    def parmTuples(self) -> Tuple[ParmTuple, ...]:
        """

        parmTuples(self) -> tuple of hou.ParmTuple

            Return a tuple of node parameters that are included and editable in
            this take.


        """
    def addParmTuple(self, parm_tuple: ParmTuple) -> None:
        """

        addParmTuple(self, parm_tuple)

            Include the given parameter in this take making it editable in this
            take.

            This method does nothing if the parameter is already included in
            this take.

            Raise hou.OperationFailed if the parm_tuple argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def removeParmTuple(self, parm_tuple: ParmTuple) -> None:
        """

        removeParmTuple(self, parm_tuple)

            Exclude the given parameter from this take making it uneditable in
            this take.

            This method does nothing if the parameter is not included in this
            take.

            Raise hou.OperationFailed if the parm_tuple argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def addParmTuplesFromTake(self, take: Take, overwrite_existing: bool = True) -> None:
        """

        addParmTuplesFromTake(self, take, overwrite_existing=True)

            Include all the given take's parameters in this take making the
            parameters editable in this take.

            If overwrite_existing is True then parameters that are already
            included in this take will have their values overwritten by the same
            parameters found in the other take. Otherwise, parameters already
            included in this take will not be affected by the same parameters
            found in the other take.

            Raise hou.OperationFailed if the take argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def addParmTuplesFromNode(self, node: Node) -> None: ...
    def removeParmTuplesFromNode(self, node: Node) -> None:
        """

        removeParmTuplesFromNode(self, node)

            Exclude all the given node's parameters from this take making them
            uneditable in this take.

            Raise hou.OperationFailed if the node argument is None. Raise
            hou.OperationFailed if this take is not the current take.


        """
    def children(self) -> Tuple[Take, ...]:
        """

        children(self) -> tuple of hou.Take

            Return a tuple of the child takes.


        """
    def saveToFile(self, filename: str, recurse: bool = False) -> None:
        """

        saveToFile(self, filename, recurse=False)

            Save this take to a file on disk.

            If recurse is True then any child and descendent takes will also be
            saved to the file.

            Note that the saved file can only be loaded within the same .hip
            file session. If Houdini is restarted or if the .hip file is closed
            and re-opened then the saved file will fail to load.

            Raise hou.OperationFailed if the filename argument does not point to
            a valid location on disk.


        """
    def loadChildTakeFromFile(self, filename: str) -> Tuple[Take,...]:
        """

        loadChildTakeFromFile(self, filename) -> tuple of hou.Take

            Load a take from a file that is saved to disk and make it a child of
            this take. This will also load any child and descendent takes that
            are saved in the file.

            Return a tuple of takes that have been loaded from the file. The
            first take in the tuple is the direct child take of this take. All
            takes that follow are the children and descendants of the first
            take.

            Loaded takes will be renamed if there already exists takes with the
            same names.

            Note that you can only load files that have been saved from the same
            .hip file session. If Houdini is restarted or if the .hip file is
            closed and re-opened after the save then the file will fail to load.

            Raise hou.OperationFailed if the filename argument does not point to
            a valid file on disk.


        """
    def moveUnderTake(self, take: Take) -> None:
        """

        moveUnderTake(self, take)

            Reparent this take to the specified take.

            Raise hou.OperationFailed if the take argument is None. Raise
            hou.OperationFailed if this take is the main (master) take.


        """
    def destroy(self, recurse: bool = False) -> None:
        """

        destroy(self, recurse=False)

            Deletes the take.

            If recurse is True then all child and descendent takes will be
            deleted as well.


        """

class takes:
    """

    hou.takes

    RELATED

      * hou.Take


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def takes() -> Tuple[Take, ...]:
        """

        takes() -> tuple of hou.Take

            Return a tuple of all the takes in the scene.


        """
    @staticmethod
    def currentTake() -> Take:
        """

        currentTake() -> hou.Take

            Return the current take.


        """
    @staticmethod
    def setCurrentTake(take: Take) -> None:
        """

        setCurrentTake(take)

            Set the current take to the specified take.

            Raise hou.OperationFailed if the take argument is None.


        """
    @staticmethod
    def rootTake() -> Take:
        """

        rootTake() -> hou.Take

            Return the main (master) take.


        """
    @staticmethod
    def findTake(take_name: str) -> Optional[Take]:
        """

        findTake(take_name) -> hou.Take or None

            Return the take with the specified name or None if no such take
            exists.


        """
    @staticmethod
    def defaultTakeName() -> str:
        """

        defaultTakeName()

            Return the default take name used for new takes. The default name
            acts like a prefix since new takes will contain the default name
            plus a numerical suffix in their take names.


        """
    @staticmethod
    def setDefaultTakeName(default_name: str) -> None:
        """

        setDefaultTakeName()

            Sets the default take name. The default take name is used as a
            prefix for the names of new takes.


        """

class text:
    """

    hou.text

    Module containing Houdini-specific string manipulation methods.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def expandString(str: str, expand_tilde: bool = True) -> str:
        '''

        expandString(str, expand_tilde=True) -> str

            Expands global variables in the expression. For example, when
            Houdini is at frame 10:

          > >>> hou.text.expandStringAtFrame(\'$F\')
          > \'10\'

            Also expands HScript expressions in backticks, such as the channel
            reference in this example. This returns the value of the translate X
            parameter for geo1 at the current frame as a string:

          > hou.text.expandStringAtFrame(\'`ch(\\"/obj/geo1/tx\\")`\')

            The expand_tilde parameter can be set to False to prevent the
            expansion of ~ to your home directory path.

            This function evaluates the string as if it were the contents of a
            non-animated text parameter. To evaluate a straight HScript
            expression (without needing backticks), use hou.hscriptExpression.

            Raises hou.OperationFailed exception if the first argument is None.

          > >>> hou.text.expandString(\\"$HIP/file.geo\\")
          > \'/dir/containing/hip/file/file.geo\'
          > >>> hou.text.expandString(\\"file`$F+1`.pic\\")
          > \'file2.pic\'

        '''
    @staticmethod
    def expandStringAtFrame(str: str, frame: float, expand_tilde: bool = True) -> str:
        '''

        expandStringAtFrame(str, frame_number, expand_tilde=True) -> str

            Expands global variables in the expression. For example:

          > >>> hou.text.expandStringAtFrame(\'$F\', 10)
          > \'10\'

            Also expands HScript expressions in back-ticks, such as the channel
            reference in this example. This returns the value of the translate X
            parameter for geo1 at the current frame as a string:

          > hou.text.expandStringAtFrame(\'`ch(\\"/obj/geo1/tx\\")`\', hou.frame())

            The expand_tilde parameter can be set to False to prevent the
            expansion of ~ to your home directory path.

            This function evaluates the string as if it were the contents of a
            non-animated text parameter. To evaluate a straight HScript
            expression (without needing back-ticks), use hou.hscriptExpression.

            Raises hou.OperationFailed exception if the first argument is None.


        '''
    @staticmethod
    def expandHuskFilePath(str: str, frame_start: float = 1.0, frame_inc: float = 1.0, frame_idx: int = 0) -> str:
        """

        expandHuskFilePath(str, frame_start = 1.0, frame_inc = 1.0, frame_idx =
        0) -> str

            Expands global variables in the expression using the same formatting
            supported by husk to evaluate time varying file paths. The current
            frame number used for substitutions is calculated as frame_start +
            (frame_inc * frame_idx).

          > >>> hou.text.expandHuskFilePath('~/renders/output.<F4>.exr', 1, 1, 0)
          > 'D:/cygwin/home/mtucker/renders/output.0001.exr'

            Unlike the other string expansion functions, this method does not
            expand hscript expressions enclosed in backticks, because husk does
            not support this capability.

            Returns an empty string if the first argument is None.


        """
    @staticmethod
    def incrementNumberedString(str: str) -> str:
        """

        incrementNumberedString(str) -> str

            If the string ends with a number, that number is incremented, and
            the resulting new string is returned. If the string does not end
            with a number, a number is appended to the string. This is the
            algorithm used by Houdini to generate uniquely named child nodes
            inside a network.

          > >>> hou.text.incrementNumberedString('name1')
          > 'name2'
          > >>> hou.text.incrementNumberedString('name199')
          > 'name200'
          > >>> hou.text.incrementNumberedString('name')
          > 'name2'
          > >>> hou.text.incrementNumberedString('')
          > '2'

        """
    @staticmethod
    def encode(varname: str) -> str:
        """

        encode(str) -> str

            Houdini VEX variable names are only allowed to contain letters,
            numbers, and underscores, and must not begin with a number. This
            method takes any string, and encodes it into a string that obeys
            these restrictions. The original string can be recovered using the
            decode method. A string that already obeys the rules is returned
            unmodified.

            One exception to this rule is that a string starting with xn__ will
            be encoded even if it is already a valid attribute name. This is
            because xn__ is the prefix used to identify an encoded string. In
            this case, an additional xn__ prefix will be added. This means a
            string can be encoded any number of times, then decoded the same
            number of times to always return to the original string, regardless
            of its contents.

          > >>> hou.text.encode('foo:bar')
          > 'xn__foobar_rla'
          > >>> hou.text.encode('safe_name')
          > 'safe_name'

        """
    @staticmethod
    def decode(varname: str) -> str:
        """

        decode(str) -> str

            Houdini VEX variable names are only allowed to contain letters,
            numbers, and underscores, and must not begin with a number.
            Arbitrary strings can be passed through the encode method to
            generate a string that obeys these restriction. This method takes
            one of these encoded strings, and returns the original string. A
            string that has not been encoded will be returned unmodified.

          > >>> hou.text.decode('xn__foobar_rla')
          > 'foo:bar'
          > >>> hou.text.decode('safe_name')
          > 'safe_name'

        """
    @staticmethod
    def encodeAttrib(attribname: str) -> str:
        """

        encodeAttrib(str) -> str

            Houdini geometry attributes and group names are only allowed to
            contain letters, numbers, and underscores, and must not begin with a
            number. This method takes any string, and encodes it into a string
            that obeys these restrictions. The original string can be recovered
            using the decodeAttrib method. A string that already obeys the rules
            is returned unmodified.

            One exception to this rule is that a string starting with xn__ will
            be encoded even if it is already a valid attribute name. This is
            because xn__ is the prefix used to identify an encoded string. In
            this case, an additional xn__ prefix will be added. This means a
            string can be encoded any number of times, then decoded the same
            number of times to always return to the original string, regardless
            of its contents.

          > >>> hou.text.encodeAttrib('foo:bar')
          > 'xn__foobar_rla'
          > >>> hou.text.encodeAttrib('safe_name')
          > 'safe_name'

        """
    @staticmethod
    def decodeAttrib(attribname: str) -> str:
        """

        decodeAttrib(str) -> str

            Houdini geometry attributes and group names are only allowed to
            contain letters, numbers, and underscores, and must not begin with a
            number. Arbitrary strings can be passed through the encodeAttrib
            method to generate a string that obeys these restriction. This
            method takes one of these encoded strings, and returns the original
            string. A string that has not been encoded will be returned
            unmodified.

          > >>> hou.text.decodeAttrib('xn__foobar_rla')
          > 'foo:bar'
          > >>> hou.text.decodeAttrib('safe_name')
          > 'safe_name'

        """
    @staticmethod
    def encodeParm(parmname: str) -> str:
        """

        encodeParm(str) -> str

            Houdini parameter names are only allowed to contain letters,
            numbers, hash characters (for multiparms), and underscores, and must
            not begin with a number. This method takes any string, and encodes
            it into a string that obeys these restrictions. The original string
            can be recovered using the decodeParm method. A string that already
            obeys the rules is returned unmodified.

            One exception to this rule is that a string starting with xn__ will
            be encoded even if it is already a valid attribute name. This is
            because xn__ is the prefix used to identify an encoded string. In
            this case, an additional xn__ prefix will be added. This means a
            string can be encoded any number of times, then decoded the same
            number of times to always return to the original string, regardless
            of its contents.

          > >>> hou.text.encodeParm('foo:bar')
          > 'xn__foobar_rla'
          > >>> hou.text.encodeParm('safe_name')
          > 'safe_name'

        """
    @staticmethod
    def decodeParm(parmname: str) -> str:
        """

        decodeParm(str) -> str

            Houdini parameter names are only allowed to contain letters,
            numbers, hash characters (for multiparms), and underscores, and must
            not begin with a number. Arbitrary strings can be passed through the
            encodeParm method to generate a string that obeys these restriction.
            This method takes one of these encoded strings, and returns the
            original string. A string that has not been encoded will be returned
            unmodified.

          > >>> hou.text.decodeParm('xn__foobar_rla')
          > 'foo:bar'
          > >>> hou.text.decodeParm('safe_name')
          > 'safe_name'

        """
    @staticmethod
    def alphaNumeric(str: str) -> str:
        """

        alphaNumeric(str) -> str

            Return a string that consists of only numbers, letters, and
            underscores. Any other character in the string is replaced with an
            underscore. This provides an easy way to create strings that are
            safe for use as file names, and almost safe to use as node or
            variable names (variable names usually have the additional condition
            that they are not allowed to start with a number).
            hou.text.variableName can be used to produce a valid variable name.

            Unlike the encode method, the original string cannot be recovered
            from the result of this method. However the results of this method
            are more easily human readable than the result of an encode
            operation.


        """
    @staticmethod
    def variableName(str: str, safe_chars: Optional[str] = None) -> str:
        '''

        variableName(str, safe_chars=\\"\\") -> str

            Returns a string that is valid to use as a variable or node name.
            This behaves the same as hou.text.alphaNumeric, but also adds an
            underscore at the beginning of strings that begin with a number. The
            optional safe_chars argument specifies a string with any extra
            characters that should not be converted to underscores.

          > >>> hou.text.variableName(\'foo:bar\')
          > \'foo_bar\'
          > >>> hou.text.variableName(\'123\')
          > \'_123\'
          > >>> hou.text.variableName(\'foo:?bar\', safe_chars=\\":\\")
          > \'foo:_bar\'

        '''
    @staticmethod
    def compareVersionString(str1: str, str2: str) -> int:
        """

        compareVersionString(str1, str2) -> int

            Compares two version strings which have numbered components
            separated by dots (eg X.Y.Z). Assumes the components are ordered
            from most to least significant in left to right order.

            Returns a negative int when version str1 is less than version str2,
            a positive int when version str1 is greater than str2, and 0 when
            str1 is an equivalent version to str2.

          > >>> hou.text.compareVersionString('1.0', '2.0')
          > -1
          > >>> hou.text.compareVersionString('2.0', '1.0.0')
          > 1
          > >>> hou.text.compareVersionString('1', '1.0.0.0')
          > 0

        """
    @staticmethod
    def abspath(path: str, anchor_path: Optional[str] = None) -> str:
        """

        abspath(path, base_path = None) -> str

            Returns the supplied path converted to an absolute path. Relative
            paths are treated as relative to the directory specified by
            base_path. If the supplied path is already absolute, the path is
            returned unchanged. If the base_path is not provided, Houdini's
            current working directory is used for this value. The file does not
            need to exist.


        """
    @staticmethod
    def relpath(path: str, anchor_path: Optional[str] = None, allow_relative_path_from_root: bool = True) -> str:
        """

        relpath(path, base_path = None, allow_relative_path_from_root = True) ->
        str

            Returns the supplied path converted to a relative path, expressed as
            relative to the directory specified by base_path. If the base_path
            is not provided, Houdini's current working directory is used for
            this value. The file does not need to exist.

            If the base_path parameter ends with a /, it is treated as a
            directory rather than a file. See the examples which demonstrate the
            impact this has on the returned value.

            If allow_relative_path_from_root is False, instead of returning a
            relative path that marches all the way to the root of a volume, an
            absolute path will be returned instead:

          > >>> hou.text.relpath('/foo/bar/blah', '/foo/bar')
          > './bar/blah'
          > >>> hou.text.relpath('/foo/bar/blah', '/foo/bar/')
          > './blah'
          > >>> hou.text.relpath('/foo/bar/blah', '/a/b/c')
          > '../../foo/bar/blah'
          > >>> hou.text.relpath('/foo/bar/blah', '/a/b/c', allow_relative_path_from_root = False)
          > '/foo/bar/blah'

        """
    @staticmethod
    def normpath(path: str) -> str:
        """

        normpath(path) -> str

            Returns a normalized version of the supplied path. This means that
            all path separators are expressed as forward slashes (even on
            Windows). Any redundant slashes are replaced by a single slash. And
            any relative path components appearing in the middle of the path are
            collapsed.

          > >>> hou.text.normpath('http://foo/bar/..//something')
          > 'http://foo/something'
          > >>> hou.text.normpath('\\foo\\bar\\something\\')
          > '/foo/bar/something'
          > >>> hou.text.normpath('../../foo/../bar/../something')
          > '../../something'

        """
    @staticmethod
    def collapseCommonVars(path: str, vars: Sequence[str] = ...) -> str:
        """

        collapseCommonVars(path, vars = ['$HIP', '$JOB']) -> str

            Tests if the path starts with the expanded form of any variable
            passed in through the provided vars list. If it does, that prefix is
            replaced with the corresponding unexpanded variable. For example, if
            $HIP is /home/user/hips, and path is /home/user/hips/file.hip, the
            returned string will be $HIP/file.hip.


        """
    @staticmethod
    def oclExtractBindings(code: str) -> Tuple[dict[str, Any], ...]:
        """

        oclExtractBindings(code) -> tuple of dict

            Parses provided OpenCL code for #bind commands and returns the set
            of bindings specified.


        """
    @staticmethod
    def oclExtractRunOver(code: str) -> str:
        """

        oclExtractRunOver(code) -> str

            Parses provided OpenCL code for #runover commands and returns the
            runover specified.


        """
    @staticmethod
    def patternRename(str: str, find: str, replace: str) -> str:
        '''

        patternRename(input_string, pattern_find, pattern_replace) -> str

            This function finds the pattern given in pattern_find and replaces
            any occurrences with the pattern given in pattern_replace. For
            example:

          > >>> hou.patternRename(\\"foo_bar_baz\\", \\"*bar*\\", \\"*blah*\\")
          > foo_blah_baz
          > >>> hou.patternRename(\\"left_hand_01\\", \\"left*\\", \\"right*\\")
          > right_hand_01

        '''
    @staticmethod
    def patternMatch(pattern: str, str: str, ignore_case: bool = False, path_match: bool = False) -> bool:
        '''

        patternMatch(pattern_string, input_string, ignore_case = False,
        path_match = False) -> bool

            This function is case-sensitive. Set ignore_case to True for case-
            insensitive pattern matching.

            This function does not treat path separator characters specially.
            Set path_match to True for path-aware matching, where the multi-
            level wildcard () is required to cover multiple path components.

            Returns 1 if any patterns in the pattern string matches the input
            string, or 0 if no patterns match.

            In order to match, a pattern must match the input string from
            beginning to end. Use wildcards (*) to match substrings, e.g.

          > >>> hou.patternMatch(\\"bar\\", \\"foobarbaz\\")
          > False
          > >>> hou.patternMatch(\\"*bar*\\", \\"foobarbaz\\")
          > True

            pattern is a space-separated list of one or more patterns. This can
            cause unintuitive behavior of this function. For example:

          > >>> hou.patternMatch(\\"foo bar\\", \\"foo bar\\")
          > False

            ...will return 0, because the first argument consists of two
            patterns, foo and bar, and neither of those patterns match foo bar
            (since the pattern must match from beginning to end).

            Similarly,

          > >>> hou.patternMatch(\\"foo bar\\", \\"foo\\")
          > True

            ...will return 1, because the string matches the first of the two
            arguments in the pattern (foo and bar).

          > >>> hou.patternMatch(\\"/foo/*\\", \\"/foo/bar/blah\\", path_match = True)
          > False

            ...will return 0, because the wildcard only matches against the
            first path component (/bar), leaving the last path component (/blah)
            unmatched.

          > >>> hou.patternMatch(\\"/foo/**\\", \\"/foo/bar/blah\\", path_match = True)
          > True

            ...will return 1, because the multi-level wildcard will matches
            against any number of path components.


        '''

class TextDrawable(AdvancedDrawable):
    '''

    hou.TextDrawable

    A drawable object to render text in the viewport.

    OVERVIEW

        A text drawable is designed for custom Python states and is used for
        drawing text elements in the viewport in viewport coordinates. For
        instance, you can use a text drawable to display directives for
        guiding the user or for displaying technical information.

        hou.TextDrawable lets you translate, rotate and scale the text in 2D
        space with viewport coordinates. The lower left corner of the
        viewport is the base point coordinate (0,0).

        Here\'s an example for displaying text in the upper left corner of
        the viewport.

      > import hou
      > 
      > class State(object):       
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      > 
      >         # Create an empty text drawable
      >         self.text_drawable = hou.TextDrawable(self.scene_viewer, \'text_drawable_name\')
      > 
      >         # Display the text on the next viewport redraw
      >         self.text_drawable.show(True)
      > 
      >     def onDraw( self, kwargs ):
      >         # draw the text in the viewport upper left
      >         handle = kwargs[\'draw_handle\']
      > 
      >         (x,y,width,height) = self.scene_viewer.curViewport().size()
      >         margin = 10
      >         params = { 
      >             \'text\': \'First line<br>Second line<br>Third line\',
      >             \'multi_line\' : True,
      >             \'color1\' : hou.Color(1.0,0.0,0.0),
      >             \'translate\' : hou.Vector3(0, height, 0),
      >             \'origin\' : hou.drawableTextOrigin.UpperLeft,
      >             \'margins\': hou.Vector2(margin, -margin) }
      > 
      >         self.text_drawable.draw( handle, params )

        An example to display text at the cursor position.

      > import hou
      > 
      > class State(object):       
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      > 
      >         # Create the text drawable 
      >         self.text_cursor = hou.TextDrawable(self.scene_viewer, \'text_cursor\')
      > 
      >         # Display the text on the next viewport redraw
      >         self.text_cursor.show(True)
      > 
      >     def onMouseEvent(self, kwargs):
      >         # Compute the mouse position in screen coordinates
      >         ui_event = kwargs[\\"ui_event\\"]
      >         (origin, dir) = ui_event.ray()
      >         self.mouse_screen = self.scene_viewer.curViewport().mapToScreen(origin)   
      > 
      >     def onDraw( self, kwargs ):
      >         # draw the text in the viewport upper left
      >         handle = kwargs[\'draw_handle\']
      > 
      >         params = {
      >             \'text\': \'<font color=\\"yellow\\">x=%.2f, y=%.2f</font>\' % (self.mouse_screen[0], self.mouse_screen[1]),
      >             \'translate\' : hou.Vector3(self.mouse_screen[0],self.mouse_screen[1], 0.0) }
      > 
      >         self.text_cursor.draw( handle, params )

    RELATED

      * hou.GeometryDrawable

      * hou.GeometryDrawableGroup

      * hou.SimpleDrawable


    '''
    thisown: Incomplete
    def __init__(self, scene_viewer: SceneViewer, name: str, label: str|None = ..., params: Mapping[str, Any]|None = ...) -> None:
        """

        __init__(self, scene_viewer, name, label=None, params=None)

            Creates a text drawable object. The new drawable is hidden by
            default.


            scene_viewer
                A hou.SceneViewer reference to the viewer the text will appear
                in.

            name
                A string to identify this drawable object.

            label
                An optional string for the drawable label. Defaults to empty.

            params
                An optional parameter dictionary for setting the drawable
                parameters. These parameters are also be used with
                hou.AdvancedDrawable.draw or hou.AdvancedDrawable.setParams.

                Other drawable common parameters are documented here.

                color1
                hou.Color

                Default foreground color for drawing the text. This value can be
                overridden with the text <font> token. Defaults to hou.Color(1,
                1, 1).

                multi_line
                Bool

                Draws the text on multiple lines if formatted with line breaks
                <br>. Defaults to False.

                origin
                hou.drawableTextOrigin

                Origin point for placing the text within its bounding box.
                Defaults to hou.drawableTextOrigin.BottomLeft.

                text
                String

                The text to draw. A small subset of HTML 4.0 tokens is available
                for formatting the text:

              * <b> : Bold

              * <i> : Italic

              * <font [size] [color]> : Font change

              * <br> : Line break (equivalent to 
        )

              * <sub> : Subscript

              * <sup> : Superscript

                margins
                hou.Vector2 or sequence of 2 double values

                Specifies the x and y margins of the text 2D bounding box, in
                viewport coordinates. Defaults to 0.0.


        """
    __swig_destroy__: Incomplete
    def size(self, text: str) -> Tuple[float, ...]:
        """

        size(self, text) -> tuple of double

            Computes the width and height of a text string for the drawable font
            and returns the values in a tuple:

             1. Width (dimension in pixels).

             2. Height (dimension in pixels).


        """

class ToggleParmTemplate(ParmTemplate):
    """

    hou.ToggleParmTemplate

    Describes a parameter tuple containing a checkbox.


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, default_value: bool = ..., disable_when: str|None = ..., is_hidden: bool = ..., is_label_hidden: bool = ..., join_with_next: bool = ..., help: str|None = ..., script_callback: str|None = ..., script_callback_language: EnumValue = ..., tags: Mapping[str, str] = ..., default_expression: str = ..., default_expression_language: EnumValue = ...) -> None:
        '''

        __init__(self, name, label, default_value=False, disable_when=None,
        is_hidden=False, is_label_hidden=False, join_with_next=False, help=None,
        script_callback=None,
        script_callback_language=hou.scriptLanguage.Hscript, tags={},
        default_expression=\\"\\",
        default_expression_language=hou.scriptLanguage.Hscript)

            Creates a new ToggleParmTemplate instance.


            name
                See hou.ParmTemplate.name for more information.

            label
                See hou.ParmTemplate.label for more information. See the
                defaultValue method for more information.

            disable_when
                See hou.ParmTemplate.disableWhen for more information.

            is_hidden
                See hou.ParmTemplate.isHidden for more information.

            is_label_hidden
                See hou.ParmTemplate.isLabelHidden for more information.

            join_with_next
                See hou.ParmTemplate.joinsWithNext for more information.

            help
                See hou.ParmTemplate.help for more information.

            script_callback
                See hou.ParmTemplate.scriptCallback for more information.

            script_callback_language
                See hou.ParmTemplate.scriptCallbackLanguage for more
                information.

            tags
                See hou.ParmTemplate.tags for more information.

            default_expression
                See the defaultExpression method for more information.

            default_expression_language
                See the defaultExpressionLanguage method for more information.

            Note that ToggleParmTemplates have only one component. Unlike float,
            integer, and string parm templates, the default value is a single
            bool and not a tuple.


        '''
    __swig_destroy__: Incomplete
    def defaultValue(self) -> bool:
        """

        defaultValue(self) -> bool

            Returns the default value for new parameter instances.

            Note that ToggleParmTemplates have only one component. Unlike float,
            integer, and string parm templates, the default value is a single
            bool and not a tuple.


        """
    def setDefaultValue(self, default_value: bool) -> None:
        """

        setDefaultValue(self, default_value)

            Set the default value for new parameter instances. The default_value
            should be True or False.


        """
    def defaultExpression(self) -> str:
        """

        defaultExpression(self) -> string

            Return the expression, which when evaluated, returns the initial
            value of the toggle.

            The default expression takes precedence over the default value. If
            the default expression is not set (i.e. an empty string), then the
            default value is used instead.

            Note that the default expression language is needed to interpret the
            meaning of the default expression.


        """
    def setDefaultExpression(self, default_expression: str) -> None:
        """

        setDefaultExpression(self, default_expression)

            Set the default expression, which when evaluated, returns the
            initial value of the toggle.

            If default_expression is the empty string, then the default
            expression is unset.


        """
    def defaultExpressionLanguage(self) -> EnumValue:
        """

        defaultExpressionLanguage(self) -> hou.scriptLanguage

            Return the default expression language.

            The default expression language only applies if the default
            expression is set. If the default expression is not set, then the
            expression language is set to hou.scriptLanguage.Hscript.


        """
    def setDefaultExpressionLanguage(self, default_expression_language: EnumValue) -> None:
        """

        setDefaultExpressionLanguage(self, default_expression_language)

            Set the default expression language.

            See the defaultExpressionLanguage method for more information.


        """

class Tool(ShelfElement):
    """

    hou.Tool

    Represents a tool on the shelf, encapsulating a script as well as a
    label, help, and other information.

    You can't instantiate this object directly, call hou.shelves.newTool
    instead.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __lt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def script(self) -> str:
        """

        script(self) -> str

            Returns the text of the script that runs when the user clicks the
            tool.


        """
    def setScript(self, script: str) -> None:
        """

        setScript(self, script)

            Sets the text of the script to run when the user clicks the tool in
            the shelf. See how to write a tool script for information on the
            global variables available to the script and tips for common tasks.


        """
    def language(self) -> EnumValue:
        '''

        language(self) -> hou.scriptLanguage enum value

            Returns a value representing the language in which the tool script
            is written.

          > >>> t = shelves.tool(\\"geometry_sphere\\")
          > >>> t.language() == hou.scriptLanguage.Python
          > True

        '''
    def setLanguage(self, language: EnumValue) -> None:
        '''

        setLanguage(self, language)

            Sets a new language for the script, where <language> is a value from
            the hou.scriptLanguage module (usually hou.scriptLanguage.Python).

          > t = shelves.tool(\\"tool_1\\")
          > t.setLanguage(hou.scriptLanguage.Hscript)
          > t.setScript(\\"message hello\\")

            NOTE
                We highly recommend writing scripts in Python rather than
                Hscript.


        '''
    def icon(self) -> str:
        """

        icon(self) -> str

            Returns the tool's icon string.


        """
    def setIcon(self, icon: str) -> None:
        """

        setIcon(self, icon)

            Sets a new icon string for the tool. The string can contain a file
            path or URL pointing to an SVG file or an image file Houdini knows
            how to load. You can use an opdef: path to refer to an icon file
            inside an asset.


        """
    def help(self) -> str:
        """

        help(self) -> str

            Returns the tool's help text.


        """
    def setHelp(self, help: str) -> None:
        """

        setHelp(self, help)

            Sets the tool's help text. Houdini will parse this as wiki text and
            display it in the help viewer when the user requests help for this
            tool. To have the help viewer go to a URL instead, use setHelpURL.


        """
    def helpURL(self) -> str:
        """

        helpURL(self) -> str

            Returns the URL pointing to this tool's help.


        """
    def setHelpURL(self, help_url: str) -> None:
        """

        setHelpURL(self, help_url)

            Sets a URL the help viewer should go to when the user requests help
            for this tool. If this is not empty, Hoduini will open this URL in
            the help viewer instead of parsing and displaying the contents of
            Tool.help().


        """
    def toolMenuCategories(self, pane_type: EnumValue) -> Tuple[NodeTypeCategory, ...]:
        """

        toolMenuCategories(self, pane_type) -> tuple of hou.NodeTypeCategory

            Returns the categories specified for the tool.


        """
    def setToolMenuCategories(self, pane_type: EnumValue, categories: Sequence[NodeTypeCategory]) -> None:
        """

        setToolMenuCategories(self, pane_type, categories)

            Set the tool categories. The categories are used to further control
            the visibility of the tool. For example, some tools specify Mantra
            or RenderMan as keywords, and they show up in the TAB menu only if
            the specified renderer is configured as active in the preferences
            pane.


        """
    def toolMenuOpType(self, pane_type: EnumValue) -> str:
        """

        toolMenuOpType(self, pane_type) -> str

            Returns the operator type associated with this tool.


        """
    def setToolMenuOpType(self, pane_type: EnumValue, op_type: str) -> None:
        """

        setToolMenuOpType(self, pane_type, op_type)

            Sets the operator type to be associated with the tool. The tool will
            show up in the TAB menu only if the operator can be created. For
            example, some operator types are scoped only to a particular parent,
            thus the tool that creates nodes of this type makes sense only
            inside that parent.


        """
    def toolMenuLocations(self) -> Tuple[str, ...]:
        """

        toolMenuLocations(self) -> tuple of str

            Returns the submenus of the TAB menu in which the tool is included.


        """
    def setToolLocations(self, locations: Sequence[str]) -> None:
        """

        setToolLocations(self, locations)

            Sets the description of the places that the tool should show up in
            the UI. Eg, a tool could be configured to be included in the network
            pane's TAB menu but not in the viewport pane's TAB menu.


        """
    def keywords(self) -> Tuple[str, ...]:
        """

        keywords(self) -> Sequence[str]

            Returns the keywords associated with this tool. You can set the
            keywords for a tool using setKeywords(). Currently the keywords are
            not used by Houdini, but may be useful for scripted user/studio
            tools.


        """
    def setKeywords(self, keywords: Sequence[str]) -> None:
        """

        setKeywords(self, keywords: Sequence[str])

            The argument is a list or tuple of strings representing the keywords
            for this tool. Be careful not to pass a string because Python will
            interpret it as a list of single-character keywords. Houdini makes
            no effort to avoid duplicate keywords.

            These strings correspond to the Keywords field in the tool editing
            window. Internally, the keywords are stored as a list of strings.
            But if a user edits the Keyword field in the UI, Houdini splits the
            text at commas to get the keyword list. This means you can get
            strange results if you use this method to store keywords that
            contain commas. The commas will be preserved until the user edits
            the keywords in the UI, then any commas within keywords will be re-
            interpreted as separators, and the list of keywords will change.


        """
    def setData(self, script: str = ..., language: EnumValue = ..., icon: str = ..., help: str = ..., help_url: str = ..., network_categories: Sequence[NodeTypeCategory] = ..., viewer_categories: Sequence[NodeTypeCategory] = ..., cop_viewer_categories: Sequence[NodeTypeCategory] = ..., network_op_type: str = ..., viewer_op_type: str = ..., locations: Sequence[str] = ...) -> None:
        '''

        setData(self, script=\'\', language=hou.scriptLanguage.Python, icon=\'\',
        help=\'\', help_url=\'\', network_categories=(), viewer_categories=(),
        cop_viewer_categories=(), network_op_type=\'\', viewer_op_type=\'\',
        locations=())

            Convenience method for setting multiple options at once, rather than
            calling multiple set methods. Sets various options on the tool based
            on optional keyword arguments you pass.

          > # Get a tool
          > t = shelves.tool(\\"geometry_sphere\\")
          > # Set the tool\'s icon and help URL
          > t.setData(icon=\\"SOP_sphere\\", help_url=\\"tool:sphere\\")

        '''
    def destroy(self) -> None:
        """

        destroy(self)

            Deletes the tool from Houdini session and removes its definition
            from the file it's stored in.


        """

class TopNode(OpNode):
    """

    hou.TopNode

    Represents a task node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns whether this node's bypass flag is on.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turns this node's bypass flag on or off, making this node have no
            effect.


        """
    def isDisplayFlagSet(self) -> bool:
        """

        isDisplayFlagSet(self) -> bool

            Returns whether this node's display flag is on.


        """
    def setDisplayFlag(self, on: bool) -> None:
        """

        setDisplayFlag(self, on)

            Turn this node's display flag on or off.


        """
    def isRenderFlagSet(self) -> bool:
        """

        isRenderFlagSet(self) -> bool

            Returns whether this node's render flag is on.


        """
    def setRenderFlag(self, on: bool) -> None:
        """

        setRenderFlag(self, on)

            Turns this node's render flag on or off.


        """
    def displayNode(self) -> Optional[Node]:
        """

        displayNode(self) -> hou.OpNode

            If this is a subnet TOP, return the TOP node inside the subnet with
            its display flag on. Otherwise, return None.


        """
    def renderNode(self) -> Optional[Node]:
        """

        renderNode(self) -> hou.OpNode

            If this is a subnet TOP, return the TOP node inside the subnet with
            its render flag on. Otherwise, return None.


        """
    def outputNode(self) -> Optional[Node]:
        """

        outputNode(self) -> hou.OpNode

            If this is a subnet TOP, returns the first Output node in the
            network. Otherwise, if there are no Output nodes, the display node
            is returned instead.


        """
    def topParent(self) -> Optional[Node]: ...
    def cookWorkItems(self, block: bool = ..., generate_only: bool = ..., tops_only: bool = ..., save_prompt: bool = ..., nodes: Sequence[TopNode] = ...) -> None:
        """

        cookWorkItems(self, block=False, generate_only=False, tops_only=False,
        save_prompt=False, nodes=[])

            Generates and cook work items in the specified TOP nodes. All of the
            nodes must be from the same network. If the nodes list is empty,
            this method will cook the node this TOP node.


            block
                If the block argument is set to True the method will block the
                caller until the cook completes. Otherwise, the cook occurs in
                the background.

            generate_only
                If True work items in the specified nodes will only be generated
                and not cooked. If a node is dynamic, this means that the input
                nodes will be cooked.

            tops_only
                If True, TOP nodes will be cooked and schedulers will be
                initialized. This will create the underlying PDG Nodes and PDG
                Schedulers. No PDG cooking will occur, and no work items will be
                generated.

            save_prompt
                If True, TOPs will display a save prompt if the current scene
                has unsaved changes and any of the nodes in the network require
                access to the .hip file when cooking. If there are no
                modifications to the scene or none of the nodes create work item
                that use the scene file, then the dialog isn't displayed. If
                this method is called from a non-graphical Houdini session,
                passing save_prompt=True will silently save the scene if needed
                without displaying a confirmation dialog.


        """
    def cookOutputWorkItems(self, block: bool = False, generate_only: bool = False, tops_only: bool = False, save_prompt: bool = False) -> None:
        """

        cookAllOutputWorkItems(self, include_display_node, block=False,
        generate_only=False, tops_only=False)

            The same as hou.TopNode.cookWorkItems, except it cooks all Output
            nodes in the TOP Network. If include_display_node is True the
            Display node will also be included in the list of nodes that are
            cooked, even if it's not an Output node.


        """
    def cookAllOutputWorkItems(self, include_display_node: bool, block: bool = False, generate_only: bool = False, tops_only: bool = False, save_prompt: bool = False) -> None: ...
    def generateStaticWorkItems(self, block: bool = ..., nodes: Sequence[TopNode] = ...) -> None:
        """

        generateStaticWorkItems(self, block=False, nodes=[])

            Generates static work items on the PDG graph owned by the TOP
            Network. If a list of nodes is specified then static work items are
            only generate for the branches that contain those nodes. Otherwise,
            work items are generated for the entire graph.


            block
                If True, the call will not return until work item generation is
                complete.


        """
    def dirtyAllWorkItems(self, remove_outputs: bool) -> None:
        """

        dirtyAllWorkItems(self, remove_outputs)

            Deletes all work items in the PDG graph owned by the TOP Network.


            remove_outputs
                If True, then it will also delete all generated file results
                from disk.


        """
    def dirtyWorkItems(self, remove_outputs: bool) -> None:
        """

        dirtyWorkItems(self, remove_outputs)

            Deletes all work items in this node.


            remove_outputs
                If True, then it will also delete all generated file results
                from disk.


        """
    def generateStaticItems(self, block: bool = False) -> None:
        """

        generateStaticItems(self, block)

            This method is deprecated in favor of
            hou.TopNode.generateStaticWorkItems.


        """
    def dirtyAllTasks(self, remove_outputs: bool) -> None:
        """

        dirtyAllTasks(self, remove_outputs)

            This method is deprecated in favor of hou.TopNode.dirtyAllWorkItems.


        """
    def dirtyTasks(self, remove_outputs: bool) -> None:
        """

        dirtyTasks(self, remove_outputs)

            This method is deprecated in favor of hou.TopNode.dirtyWorkItems.


        """
    def executeGraph(self, filter_static: bool = False, block: bool = False, generate_only: bool = False, tops_only: bool = False) -> None:
        """

        executeGraph(self, filter_static=False, block=False,
        generate_only=False, tops_only=False)

            This method is deprecated in favor of hou.TopNode.cookWorkItems and
            hou.TopNode.cookOutputWorkItems.


        """
    def graphCommands(self) -> str:
        """

        graphCommands(self) -> str

            Returns a string containing python commands require to construct the
            PDG graph owned by the parent network of this node.


        """
    def taskGraphCommands(self) -> str:
        """

        taskGraphCommands(self) -> str

            Returns a string containing python commands require to construct the
            PDG task graph owned by the parent network of this node.


        """
    def setSelectedWorkItem(self, idx: int) -> bool:
        """

        setSelectedWorkItem(self, idx) -> bool

            Sets the selected work item in this TOP Network to be the work item
            with the given ID. Returns True if the selection was changed, else
            False.


        """
    def getSelectedWorkItem(self) -> int:
        """

        getSelectedWorkItem(self) -> int

            Returns the ID of the current selected work item in this TOP
            Network.


        """
    def getWorkItemName(self, idx: int) -> str:
        """

        getWorkItemName(self, idx) -> str

            Returns the name of the work item with the given ID.


        """
    def getPDGGraphContextName(self) -> str:
        """

        getPDGGraphContextName(self) -> str

            Returns a string containing the name of the graph context owned by
            the parent network of this node.

            If the TOP node has not been cooked yet by cookWorkItems() (thus
            generating the underlying PDG), then this method returns None.


        """
    def getPDGNodeName(self) -> str:
        """

        getPDGNodeName(self) -> str

            Returns the name of the PDG node owned by this node.

            If the TOP node has not been cooked yet by cookWorkItems() (thus
            generating the underlying PDG), then this method returns None.


        """
    def getPDGNodeId(self) -> int:
        """

        getPDGNodeId(self) -> int

            Returns the id of the PDG node owned by this node.

            If the TOP node has not been cooked yet by cookWorkItems() (thus
            generating the underlying PDG), then this method returns None.


        """
    def cancelCook(self) -> None:
        """

        cancelCook(self)

            Cancels the current cook


        """
    def pauseCook(self) -> None:
        """

        pauseCook(self)

            Pauses the current cook. This is the same as canceling the cook,
            except any work items that have already been scheduled are allowed
            to continue executing. No new work items will be run until the next
            cook is initiated, and work items that have not yet been scheduled
            will be canceled.


        """
    def addPDGFilter(self, idx: int) -> None:
        """

        isPDGFilter(self, idx) -> bool

            Returns true if the static work item with the given ID is part of
            the filter.


        """
    def removePDGFilter(self, idx: int) -> None: ...
    def isPDGFilter(self, idx: int) -> bool: ...
    def enablePDGFilter(self, filter_on: bool) -> None:
        """

        enablePDGFilter(self, filter_on)

            Sets the node's TOP network to use the current static task filter.


        """
    def workItemStates(self) -> Tuple[int, ...]:
        """

        workItemStates(self) -> list of int

            Returns the number of work items in the node that are each of the
            work item states. The values are returned as in a sequence that
            matches the order of the entries in the pdg.workItemState enum. The
            final value in the resulting list is the total number of work items.


        """
    def collapsedItems(self) -> Tuple[int, ...]:
        """

        collapsedItems(self) -> tuple of int

            Returns all collapsed items in TOP_Node


        """
    def collapsedItem(self, idx: int) -> int:
        """

        collapsedItem(self, idx) -> int

            Returns ID of collapsed item at index idx


            idx
                Index of collapsed item


        """
    def workItemsInCollapsedItemIds(self, id: int) -> Tuple[int, ...]:
        """

        workItemsInCollapsedItemIds(self, id) -> tuple of int

            Returns all work items that belong to collapsed item


            id
                ID of the collapsed item whose work items are being returned


        """
    def isProcessor(self) -> bool:
        """

        isProcessor(self) -> bool

            Returns true if the TOP node is a processor.


        """
    def isPartitioner(self) -> bool:
        """

        isPartitioner(self) -> bool

            Returns true if the TOP node is a partitioner.


        """
    def isMapper(self) -> bool:
        """

        isMapper(self) - > bool

            Returns true if the TOP node is a mapper.


        """
    def isScheduler(self) -> bool:
        """

        isScheduler(self) - > bool

            Returns true if the TOP node is a scheduler.


        """
    def isServiceCompatible(self, service_name: str) -> bool: ...
    def isFilterOn(self) -> bool:
        """

        isFilterOn(self) -> bool

            Returns true is this node is currently affected by a work item
            filter set on another node in the network.


        """
    def getFilterNodes(self) -> Tuple[Node, ...]:
        """

        getFilterNodes(self) -> tuple of hou.OpNode

            Returns a tuple of all nodes whose filters affect the node.


        """
    def outputDataTypes(self) -> Tuple[str, ...]:
        """

        outputDataTypes(self) -> tuple of str

            Returns a tuple of the data types for the output ports of this node.


        """
    def inputDataTypes(self) -> Tuple[str, ...]:
        """

        inputDataTypes(self) -> tuple of str

            Returns a tuple of the data types for the input ports of this node.


        """
    def getCookState(self, force: bool) -> EnumValue: ...
    def getDataLayerInterfaceId(self) -> int: ...

class Track:
    """

    hou.Track

    Each hou.ChopNode contains its data in one or more tracks. A track
    contains a sequence of floating point samples over time. Each track has
    a unique name in its containing CHOP.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def chopNode(self) -> Optional[ChopNode]:
        """

        chopNode(self) -> hou.ChopNode or None

            Returns the hou.ChopNode owner of this track. This may return None
            if the track belongs to a standalone hou.Clip.


        """
    def clip(self) -> Clip:
        """

        clip(self) -> hou.Clip

            Returns the clip that this track belongs to.


        """
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of this track (each track in a CHOP has a unique
            name).


        """
    def eval(self) -> float:
        """

        eval(self) -> double

            Returns the value of this track at the current time.


        """
    def evalAtTime(self, time: float) -> float:
        """

        evalAtTime(self, time) -> double

            Returns the value of this track at a given time.


        """
    def evalAtFrame(self, frame: float) -> float:
        """

        evalAtFrame(self, frame) -> double

            Returns the value of this track at a given frame.


        """
    def evalAtSample(self, sample: float) -> float:
        """

        evalAtSample(self, sample) -> double

            Returns the value of the track at a given sample value.


        """
    def evalAtTimeRange(self, start: float, end: float) -> Tuple[float, ...]:
        """

        evalAtTimeRange(self, start, end) -> tuple of double

            Returns the sample values of this track between a given start and
            end time.


        """
    def evalAtFrameRange(self, start: float, end: float) -> Tuple[float, ...]:
        """

        evalAtFrameRange(self, start, end) -> tuple of double

            Returns the sample values of this track between a given start and
            end frame.


        """
    def evalAtSampleRange(self, start: float, end: float) -> Tuple[float, ...]:
        """

        evalAtSampleRange(self, start, end) -> tuple of double

            Returns the sample values of this track between a given start and
            end sample index.


        """
    def numSamples(self) -> int:
        """

        numSamples(self) -> int

            Return the number of samples in this track.


        """
    def allSamples(self) -> Tuple[float, ...]:
        """

        allSamples(self) -> tuple of double

            Returns all the sample values in this track.


        """
    def evalAtSampleIndex(self, index: int) -> float:
        """

        evalAtSampleIndex(self, index) -> double

            This method is deprecated in favor of evalAtSample.


        """
    def extendLeft(self) -> EnumValue:
        """

        extendLeft(self) -> hou.trackExtend

            Returns the track left extend mode.


        """
    def extendRight(self) -> EnumValue:
        """

        extendRight(self) -> hou.trackExtend

            Returns the track right extend mode.


        """
    def overrideParm(self) -> Optional[Parm]:
        """

        overrideParm(self) -> hou.Parm or None

            Returns the parameter this CHOP track overrides, or returns None if
            no override is active or the override doesn't map to a valid
            parameter.


        """
    def isOverrideActive(self) -> bool:
        """

        isOverrideActive(self) -> bool

            Returns True if the parameter override is valid. Returns False
            otherwise.


        """
    def color(self) -> Color:
        """

        color(self) -> hou.Color

            Returns the track color used by the Motion FX UI.


        """

class ui:
    """

    hou.ui

    Module containing user interface related functions.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def shellIO() -> ShellIO:
        """

        shellIO() -> hou.ShellIO

            Return the hou.ShellIO object used to implement Houdini's graphical
            Python shell. This function is used internally by Houdini, and you
            shouldn't need to access the ShellIO directly.


        """
    @staticmethod
    def curDesktop() -> Desktop:
        """

        curDesktop() -> hou.Desktop

            Return the current desktop.


        """
    @staticmethod
    def desktop(name: str) -> Optional[Desktop]:
        """

        desktop(name) -> hou.Desktop

            Return the desktop with the specified name. Return None if no such
            desktop exists.


        """
    @staticmethod
    def desktops() -> Tuple[Desktop, ...]:
        """

        desktops() -> tuple of hou.Desktop

            Return all the desktops.

            See hou.Desktop.setAsCurrent for an example.


        """
    @staticmethod
    def radialMenu(name: str) -> Optional[RadialMenu]:
        """

        radialMenu(name) -> hou.RadialMenu

            Returns a hou.RadialMenu object representing the named menu, or None
            if the menu does not exist.


        """
    @staticmethod
    def radialMenus() -> Tuple[RadialMenu, ...]:
        """

        radialMenus() -> tuple of hou.RadialMenu

            Returns a tuple of hou.RadialMenu objects representing existing
            menus.


        """
    @staticmethod
    def createRadialMenu(name: str, label: str) -> RadialMenu:
        """

        createRadialMenu(name, label) -> hou.RadialMenu

            Creates a new radial menu object with the given name and label.


        """
    @staticmethod
    def createRadialItem(submenu: bool = False, callback: bool = False) -> RadialScriptItem:
        """

        createRadialItem(submenu=False, callback=false) -> hou.RadialScriptItem

            Creates a temporary radial menu item.


            submenu
                Whether this item is a submenu or action.

            callback
                Whether this item is uses python callback or script (text).


        """
    @staticmethod
    def injectRadialItem(location: int, item: RadialItem) -> None:
        """

        injectRadialMenu(name)

            Injects a registered menu and override the current menu.


            name
                The name of the menu.


        """
    @staticmethod
    def injectRadialMenu(name: str) -> None: ...
    @staticmethod
    def setDefaultRadialSubmenu(location: int) -> None:
        """

        setDefaultRadialSubmenu(location)

            Sets the top-level submenu that opens when the radial menu is
            opened. Setting it to -1 will default to the root menu.


            name
                The location of the submenu at the root level.


        """
    @staticmethod
    def updateMainMenuBar() -> None:
        """

        updateMainMenuBar()

            Forces label expressions to be re-evaluated for the main Houdini
            menu bar. These top level menu items are never automatically
            refreshed, so it is up to the creator of these menus to also install
            handlers that detect when a condition has changed that might affect
            the menu, and call this method to force a refresh.


        """
    @staticmethod
    def panes() -> Tuple[Pane, ...]:
        """

        panes(self) -> tuple of hou.Pane

            Return a tuple of all visible panes, including those in all floating
            windows.

            See also hou.Desktop.panes.


        """
    @staticmethod
    def paneTabs() -> Tuple[PaneTab, ...]:
        """

        paneTabs(self) -> tuple of hou.PaneTab

            Return a tuple of all visible pane tabs, including those in all
            floating windows.

            See also hou.Desktop.paneTabs.


        """
    @staticmethod
    def currentPaneTabs() -> Tuple[PaneTab, ...]:
        """

        currentPaneTabs(self) -> tuple of hou.PaneTab

            Return a tuple of all visible pane tabs that are selected in their
            containing panes, including those in all floating windows.

            See also hou.Desktop.currentPaneTabs.


        """
    @staticmethod
    def paneTabOfType(type: EnumValue, index: int = 0) -> Optional[PaneTab]:
        """

        paneTabOfType(self, type, index=0) -> hou.PaneTab or None

            Find and return the pane tab with the desired type. If no such tab
            exists, return None.


            type
                A hou.paneTabType enumerated variable.

            index
                If there are multiple tabs with the desired type, this parameter
                determines which one is returned. Use index=0 to return the
                first found tab, index=1 to return the second found tab, etc. By
                default, index is 0.

            See also hou.Desktop.paneTabOfType.


        """
    @staticmethod
    def findPane(pane_id: int) -> Optional[Pane]:
        """

        findPane(self, pane_id) -> hou.Pane or None

            Return the pane with the given unique id, or None if no such pane
            exists.

            See also hou.Desktop.findPane.


        """
    @staticmethod
    def findPaneTab(name: str) -> Optional[PaneTab]:
        """

        findPaneTab(self, name) -> hou.PaneTab or None

            Return the pane tab with the given name, or None if no such tab
            exists.

            The name may optionally be prefixed by the desktop name and a
            period.

            See also hou.Desktop.findPaneTab.


        """
    @staticmethod
    def floatingPaneTabs() -> Tuple[PaneTab, ...]:
        """

        floatingPaneTabs(self) -> tuple of hou.PaneTab

            Return all the pane tabs in floating panels.

            See also hou.Desktop.floatingPaneTabs.


        """
    @staticmethod
    def floatingPanels() -> Tuple[FloatingPanel, ...]:
        """

        floatingPanels(self) -> tuple of hou.FloatingPanel

            Return all the visible floating panels.

            See also hou.Desktop.floatingPanels.


        """
    @staticmethod
    def paneUnderCursor() -> Optional[Pane]:
        """

        paneUnderCursor(self)

            Return the hou.Pane object located under the mouse cursor. Return
            None if no pane is located under the mouse cursor.

            This method searches all visible panes including panes not attached
            to the current desktop.


        """
    @staticmethod
    def paneTabUnderCursor() -> Optional[PaneTab]:
        """

        paneTabUnderCursor(self)

            Similar to hou.ui.paneUnderCursor but return the hou.PaneTab object
            instead located under the mouse cursor. Return None if no pane tab
            is located under the mouse cursor.

            This method searches all visible pane tabs including pane tabs not
            attached to the current desktop.


        """
    @staticmethod
    def isUserInteracting() -> bool:
        """

        isUserInteracting()

            Return True if the user is currently interacting with the UI in a
            way that is likely to cause a stream of node or parameter changes.
            This includes scrubbing the playbar, and dragging a handle in the
            viewport. Testing this value can be useful to avoid performing
            expensive updates to UI components that can wait until the user
            interaction is complete before performing their update.


        """
    @staticmethod
    def setUserInteracting(interacting: bool) -> None:
        """

        setUserInteracting()

            Sets a flag checked by isUserInteracting(). That function will
            return True after setUserInteracting(True) is called, until you call
            setUserInteracting(False) to reset that flag.

            This can be used in python viewer states, or python panels to stop
            certain UI updates during viewport interaction or when using UI
            widgets.

            Set this to True when the interaction starts and False when it
            finishes.


        """
    @staticmethod
    def orientationUpAxis() -> EnumValue:
        """

        orientationUpAxis(self) -> hou.orientUpAxis enum value

            Return a hou.orientUpAxis indicating the current orientation mode's
            up axis.


        """
    @staticmethod
    def handleOrientToNormalAxis() -> EnumValue:
        """

        handleOrientToNormalAxis(self) -> hou.handleOrientToNormalAxis enum
        value

            Return a hou.handleOrientToNormalAxis indicating the handle axis
            that is to be aligned to component normals when orienting.


        """
    @staticmethod
    def displayConfirmation(text: str, severity: EnumValue = ..., help: str|None = ..., title: str|None = ..., details: str|None = ..., details_label: str|None = ..., details_expanded: bool = ..., suppress: EnumValue = ...) -> bool: ...
    @staticmethod
    def displayCustomConfirmation(text: str, buttons: Sequence[str] = ..., severity: EnumValue = ..., default_choice: int = ..., close_choice: int = ..., help: str|None = ..., title: str|None = ..., details: str|None = ..., details_label: str|None = ..., details_expanded: bool = ..., suppress: EnumValue = ...) -> int:
        '''

        displayCustomConfirmation(text, buttons=(),
        severity=hou.severityType.Message, default_choice=0, close_choice=-1,
        help=None, title=None, details=None, details_label=None,
        suppress=hou.confirmType.OverwriteFile) -> int

            This method is the same as displayConfirmation, except it also
            accepts a list of custom button labels and returns the selected
            button index instead of a boolean value. The button index
            corresponds to the entry in the label array that was selected in the
            pop up dialog. If fewer than two button labels are specified, the
            default labels OK and Cancel will be added as necessary to achieve
            the required length of at least two labels.


            text
                The message to display.

            buttons
                The labels for the buttons that appear in the dialog. If fewer
                than two labels are passed in, OK and Cancel will be added as
                needed. For example, if the method is called with
                buttons=(\\"Continue\\",) the dialog will display a Continue and
                Cancel button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                escape or closes the dialog.

            help
                Additional help information to display below the main message.

            title
                The window\'s title. If None, the title is Houdini.

            details
                A string containing extra messages that is not visible unless
                the user clicks Show Details.

            details_label
                A string containing the label for the expand/collapse button
                that controls whether or not the detail text is visible.


                suppress
                    Used to skip the display of this dialog if the user
                    requested not to be shown this confirmation dialog again.

          > \'\'\'Before cooking the TOP network, prompts the user to either save the .hip
          > file, cook without saving the file, or cancel the cook operation completely.\'\'\'
          > 
          > def save_and_cook(top_network):
          >     buttons = (\\"Save and Continue\\", \\"Continue Without Saving\\", \\"Cancel\\")
          >     selected_button = hou.ui.displayCustomConfirmation(\\"Save before cooking?\\", suppress=hou.confirmType.TopCookSave, buttons=buttons)
          > 
          >     if selected_button == 0:
          >         hou.hipFile.save()
          > 
          >     if selected_button != 2:
          >         top_network.cookWorkItems(block=True)

        '''
    @staticmethod
    def displayMessage(text: str, buttons: Sequence[str] = ..., severity: EnumValue = ..., default_choice: int = ..., close_choice: int = ..., help: str|None = ..., title: str|None = ..., details: str|None = ..., details_label: str|None = ..., details_expanded: bool = ..., suppress: EnumValue = ...) -> int:
        '''

        displayMessage(text, buttons=(\'OK\',), severity=hou.severityType.Message,
        default_choice=0, close_choice=-1, help=None, title=None, details=None,
        details_label=None, details_expanded=False,
        suppress=hou.confirmType.NoConfirmType) -> int

            Pop up a small window with a message and one or more buttons and
            wait for the user to press a button. Return the index of the button
            the user pressed.


            text
                The message to display.

            buttons
                A sequence of strings containing the names of the buttons. By
                default the message window contains a single OK button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                Escape or closes the dialog.

            help
                Additional help information to display below the main message.

            title
                The window\'s title. If None, the title is Houdini.

            details
                A string containing extra messages that is not visible unless
                the user clicks Show Details.

            details_label
                A string containing the label for the expand/collapse button
                that controls whether or not the detail text is visible. If
                details_expanded is set to true this parameter has no effect.

            details_expanded
                A boolean, if true then the text area where the detail messages
                appear is always shown and cannot be collapsed. If false, the
                detail message area is initially folded when the message box is
                popped up and the user can expand to read the details.

            suppress
                Include a checkbox in the dialog to enable users to request the
                non-display of this dialog in future occurrences. The dialog
                cannot be suppressed by default.

          > def saveIfNeeded():
          >         \'\'\'Prompt the user if they want to save, and save the hip file if they choose Yes.\'\'\'
          >         if hou.ui.displayMessage(\\"Save the current hip file?\\", buttons=(\\"Yes\\", \\"No\\")) == 0:
          >             hou.hipFile.save()

        '''
    @staticmethod
    def readInput(text: str, buttons: Sequence[str] = ..., severity_type: EnumValue = ..., default_choice: int = ..., close_choice: int = ..., help: str|None = ..., title: str|None = ..., initial_contents: str|None = ...) -> Tuple[int, str]:
        """

        readInput(message, buttons=('OK',), severity=hou.severityType.Message,
        default_choice=0, close_choice=-1, help=None, title=None,
        initial_contents=None) -> (int, str)

            Pop up a small window with a textbox and wait for the user to enter
            a line of text. Return a tuple containing an integer and the text
            they entered. The integer is the index of the pressed button. If
            close_choice is not None and the user closed the dialog by clicking
            on its close button or by pressing Escape, then the returned integer
            is set to close_choice.


            message
                The message to display above the text field.

            buttons
                A sequence of strings containing the names of the buttons. By
                default the message window contains a single OK button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                Escape or clicks on the dialog's close button. If there is more
                than one button and close_choice is -1, then the user cannot
                close the dialog with Escape or the dialog's close button. If
                there is only one button and close_choice is -1, then the user
                can close the dialog with Escape or the dialog's close button,
                and the button's index is returned.

            help
                Additional help information to display below the main message.

            title
                The window's title. If None, the title is Houdini.

            initial_contents
                The initial contents of the text field. If None, the text field
                is initially empty.

            See also hou.ui.readMultiInput


        """
    @staticmethod
    def readMultiInput(text: str, input_labels: Sequence[str], password_input_indices: Sequence[int] = ..., buttons: Sequence[str] = ..., severity_type: EnumValue = ..., default_choice: int = ..., close_choice: int = ..., help: str|None = ..., title: str|None = ..., initial_contents: Sequence[str] = ...) -> Tuple[int, Tuple[str,...]]:
        '''

        readMultiInput(message, input_labels, password_input_indices=(),
        buttons=(\'OK\',), severity=hou.severityType.Message, default_choice=0,
        close_choice=-1, help=None, title=None, initial_contents=(\\"\\",)) -> (int,
        tuple of str)

            Pop up a small window with a textbox and wait for the user to enter
            a text into several input fields. Return a tuple containing an
            integer and the tuple of strings they entered, one for each input
            field. The integer is the index of the pressed button. If
            close_choice is not -1 and the user closed the dialog by clicking on
            its close button or by pressing Escape, then the returned integer is
            set to close_choice.


            message
                The message to display above the text field.

            input_labels
                A sequence of labels to appear in front of each input field. The
                length of the sequence determines the number of input fields
                that will appear in the window.

            password_input_indices
                A sequence of indices of which input fields are password fields.
                Fields whose index is not in this sequence will not be password
                fields.

            buttons
                A sequence of strings containing the names of the buttons. By
                default the message window contains a single OK button.

            severity
                A hou.severityType value that determines which icon to display
                on the dialog. Note that using hou.severityType.Fatal will exit
                Houdini after the user closes the dialog.

            default_choice
                The index of the button that is selected if the user presses
                enter.

            close_choice
                The index of the button that is selected if the user presses
                Escape or clicks the dialog\'s close button. If there is more
                than one button and close_choice is -1, then the user cannot
                close the dialog with Escape or the dialog\'s close button. If
                there is only one button and close_choice is -1, then the user
                can close the dialog with Escape or the dialog\'s close button,
                and the button\'s index is returned.

            help
                Additional help information to display below the main message.

            title
                The window\'s title. If this is None, the title is \\"Houdini\\".

            initial_contents
                A sequence of strings specifying the initial value of each text
                box specified by the input_labels argument. If this sequence is
                shorter than input_labels, the rest of the fields are left
                blank. The default is to start with all fields blank.

            The initial_contents values must be strings. If you use another type
            (for example, integers), the function will raise a TypeError. If you
            want to prompt the user for integers, convert the initial values
            into strings, and convert the results back into integers. For
            example:

          > start_int, end_int = hou.playbar.frameRange()
          > button_idx, values = hou.ui.readMultiInput(
          >     \\"Set the new frame range\\", (\\"Start Frame\\", \\"End Frame\\"),
          >     initial_contents=(str(start_int), str(end_int)),
          >     title=\\"Frame Range\\",
          >     buttons=(\\"OK\\", \\"Cancel\\"),
          >     default_choice=0, close_choice=1,
          > )
          > new_start_int = int(values[0])
          > new_end_int = int(values[1])

            See also hou.ui.readInput


        '''
    @staticmethod
    def selectFromList(choices: Sequence[str], default_choices: Sequence[int] = ..., exclusive: bool = ..., message: str|None = ..., title: str|None = ..., column_header: str = ..., num_visible_rows: int = ..., clear_on_cancel: bool = ..., width: int = ..., height: int = ..., sort: bool = ..., condense_paths: bool = ...) -> Tuple[int,...]:
        '''

        selectFromList(choices, default_choices=(), exclusive=False,
        message=None, title=None, column_header=\\"Choices\\", num_visible_rows=10,
        clear_on_cancel=False, width=0, height=0, sort=False,
        condense_paths=False) -> tuple of int

            Pop up a window with a set of choices in a list box and prompt the
            user to choose zero or more of them. If selection is accepted then
            the list of selected row indices are returned. If selection is
            canceled then the initial selection (default choices) is returned.


            choices
                A sequence of strings containing the possible choices.

            default_choices
                A sequence of integers containing the indices of the choices
                that are initially selected.

            exclusive
                Whether or not the user must choose exactly one of the possible
                choices.

            message
                The message to display above the list box.

            title
                The window\'s title. If None, the title is Houdini.

            column_header
                The column header for the list of choices. Users can click this
                header label to sort the list. If None, then the header is
                removed. Note that the tuple of integers represents the original
                order of items, regardless of the displayed sort order.

            num_visible_rows
                The number of rows of entries that are visible at a time. If
                there are more possible choices than visible rows, Houdini will
                use a scrollbar.

            clear_on_cancel
                If set to True then an empty tuple is returned when selection is
                canceled. Otherwise the initial selection (default_choices) is
                returned when selection is canceled.

            width
                The chooser dialog\'s width. If 0, then the chooser dialog uses a
                default width.

            height
                The chooser dialog\'s height. If 0, then the chooser dialog uses
                a default height.

            sort
                Whether or not the chooser should sort the list immediately. If
                this flag is set to True the contents of the chooser will be
                sorted in ascending order, otherwise the order of the strings in
                choices will be used as-is.

            condense_paths
                Whether or not the chooser should convert absolute paths into
                paths containing variables like $HIP. when this flag is enabled,
                the chooser will also show a toggle to enable/disable it.


        '''
    @staticmethod
    def selectFromTree(choices: Sequence[str], picked: Sequence[int] = ..., exclusive: bool = ..., message: str|None = ..., title: str|None = ..., clear_on_cancel: bool = ..., width: int = ..., height: int = ...) -> Tuple[str,...]:
        """

        selectFromTree(choices, picked=(), exclusive=False, message=None,
        title=None, clear_on_cancel=False, width=0, height=0,
        allow_branch_selection=False, allow_compound_selection=True) -> tuple of
        str

            Pop up a window with a set of choices in a tree chooser and prompt
            the user to choose zero or more of them. The choices are arranged
            into a tree using a forward slash as a path separator. If selection
            is accepted then the list of selected paths are returned. If
            selection is canceled then the initial selection (picked) is
            returned.


            choices
                A sequence of strings containing the possible choices.

            picked
                A sequence of strings containing the items that should be
                initially selected.

            exclusive
                Whether or not the user must choose exactly one of the possible
                choices.

            message
                The message to display above the list box.

            title
                The window's title. If None, the title is Make Selection.

            clear_on_cancel
                If set to True then an empty tuple is returned when selection is
                canceled. Otherwise the initial selection (picked) is returned
                when selection is canceled.

            width
                The chooser dialog's width. If 0, then the chooser dialog uses a
                default width.

            height
                The chooser dialog's height. If 0, then the chooser dialog uses
                a default height.

            allow_branch_selection
                If set to True, a single parent entry will be returned if all
                the children are selected. If set to False, the child items are
                returned. Defaults to False.

            allow_compound_selection
                If set to True, makes the children selectable even their
                ancestor has been selected. Defaults to False.


        """
    @staticmethod
    def selectParmTag(width: int = 0, height: int = 0) -> Tuple[str, ...]:
        """

        selectParmTag(width=0, height=0) -> tuple of str

            Pop up a window with a tree view of recognized parameter tags and
            prompt the user to choose a tag. Parameter tags are metadata that
            can be attached to a parameter template with
            hou.ParmTemplate.setTags and queried with hou.ParmTemplate.tags.

            Tags listed in the window are recognized by Houdini. For example,
            choosing the GL Diffuse tag and assigning it to a parameter template
            causes the viewport to recognize the parameter as the diffuse color.

            This method returns a 2-tuple where the first element is the
            selected tag name and the second element is the selected tag value.
            If no tag is selected or if the selection operation is canceled,
            then a 2-tuple of empty strings is returned.


            width
                The chooser dialog's width. If 0, then the chooser dialog uses a
                default width.

            height
                The chooser dialog's height. If 0, then the chooser dialog uses
                a default height.


        """
    @staticmethod
    def selectParm(category: NodeTypeCategory = ..., bound_parms_only: bool = ..., relative_to_node: OpNode|None = ..., message: str|None = ..., title: str|None = ..., initial_parms: Sequence[Parm] = ..., multiple_select: bool = ..., width: int = ..., height: int = ...) -> Tuple[str,...]:
        """

        selectParm(category=None, bound_parms_only=False, relative_to_node=None,
        message=None, title=None, initial_parms=(), multiple_select=True,
        width=0, height=0) -> tuple of str

            Pop up a window with a parameter tree view and prompts the user to
            select parameters, populated initially with initial_parms. If
            selection is accepted then a list of selected parameter paths are
            returned. If selection is canceled then the initial selection
            (initial parameters) is returned.

            category: A hou.NodeTypeCategory if filtering by node type,
            otherwise None if all parameters should be shown

            bound_parms_only: True if the dialog should only display parameters
            that are bound to a default handle. False is all parameters should
            be shown.

            relative_to_node: A hou.OpNode that you want the selected parameters
            paths to be relative to.

            message: The message to display in the dialog.

            title: The title of the dialog.

            multiple_select: Whether the user may select multiple parameters.

            width: The chooser dialog's width. If 0, then the chooser dialog
            uses a default width.

            height: The chooser dialog's height. If 0, then the chooser dialog
            uses a default height.


        """
    @staticmethod
    def selectParmTuple(category: NodeTypeCategory = ..., bound_parms_only: bool = ..., relative_to_node: OpNode|None = ..., message: str|None = ..., title: str|None = ..., initial_parm_tuples: Sequence[ParmTuple] = ..., multiple_select: bool = ..., width: int = ..., height: int = ...) -> Tuple[str,...]:
        """

        selectParmTuple(category=None, bound_parms_only=False,
        relative_to_node=None, message=None, title=None, initial_parm_tuples=(),
        multiple_select=True, width=0, height=0) -> tuple of str

            Pop up a window with a parameter tree view and prompts the user to
            select parameter tuples, populated initially with
            initial_parm_tuples.

            See hou.ui.selectParm for documentation on the arguments.


        """
    @staticmethod
    def selectColor(initial_color: Color|None = ..., options: dict[str, Any]|None = ...) -> Optional[Color]:
        """

        selectColor(initial_color=None, options=None) -> hou.Color or None

            Pop up a window with a color chooser, and waits for the user to
            choose a color and hit the OK or Cancel button. If the user hits the
            OK button, this method returns the color chosen in the dialog. If
            the user hits Cancel, this method returns None.

            The initial_color parameter specifies a hou.Color that will appear
            in the dialog when it first opens. If not set, the initial color
            will be white.

            The optional options dictionary argument sets the color editor
            options for the operation. See hou.ui.colorEditorOptions for
            documentation on the dictionary entries.


        """
    @staticmethod
    def selectRawColor(initial_color: Optional[Color] = None) -> Optional[Color]:
        """

        selectRawColor(initial_color=None) -> hou.Color or None

            Pop up a window with a raw color chooser, and waits for the user to
            choose a color and hit the OK or Cancel button. If the user hits the
            OK button, this method returns the color chosen in the dialog. If
            the user hits Cancel, this method returns None.

            The initial_color parameter specifies a hou.Color that will appear
            in the dialog when it first opens. If not set, the initial color
            will be white.


        """
    @staticmethod
    def setColorEditorOptions(options: dict[str, Any]) -> None:
        """

        setColorEditorOptions(options=None)

            Sets one or more color editor options using a dictionary. This has
            the same effect as setting the values from the UI. The changes will
            persist only for the current Houdini session.

            See hou.ui.colorEditorOptions for documentation on the dictionary
            entries.

            Use hou.ui.selectColor and hou.ui.openColorEditor and their options
            argument to modify the color editor options only the current picking
            operation.


        """
    @staticmethod
    def colorEditorOptions() -> dict[str, Any]:
        """

        colorEditorOptions() -> dict

            Returns a dictionary containing all the current named options values
            for the color editor.

            apply_color_correction: The toggle icon button on the top toolbar to
            enable/disable the display color correction on the color editor UI
            controls.

            grayscale: A boolean toggle that puts the Color Editor in grayscale
            mode.

            show_alpha: A boolean toggle that displays an alpha slider.

            ocio_pick_raw: The Ignore Pick Color Space toggle menu.

            ocio_show_info: A boolean toggle showing and hiding the OCIO modes
            drop down menus.

            ocio_image_auto: A boolean toggle for the Auto Image Colorspace
            toggle menu.

            ocio_display: A string for the OCIO display color space drop down
            menu.

            ocio_display_values: A read-only list of strings of the values OCIO
            display color space drop down menu.

            ocio_pick: A string for the OCIO picking color space drop down menu.

            ocio_pick_values: A read-only list of strings of the values OCIO
            picking color space drop down menu.

            ocio_color: A string for the OCIO input color space drop down menu.

            ocio_color_values: A read-only list of strings of the values OCIO
            input color space drop down menu.

            ocio_image: A string for the OCIO image color space drop down menu.

            ocio_image_values: A read-only list of strings of the values OCIO
            image color space drop down menu.


        """
    @staticmethod
    def loadPaletteFile(file: str) -> Tuple[Color, ...]:
        """

        loadPaletteFile(self, file) -> tuple of hou.Color

            Load a palette file and return the colors listed in the palette. The
            file parameter can be a full path, or just a file name. In the
            latter case, the Houdini path is searched for the first instance of
            the named file under the config subdirectory.


        """
    @staticmethod
    def savePaletteFile(file: str, colors: typing.Iterable[Color]) -> None:
        """

        savePaletteFile(self, file, colors)

            Save a palette file with the contents of the colors parameter, a
            tuple of hou.Color objects. The file parameter must be a full path
            to the file where the palette should be saved.

            Raises hou.OperationFailed if the file could not be written.


        """
    @staticmethod
    def updateValueLadder(cursor_x: int, cursor_y: int, alt_key: bool, shift_key: bool) -> None:
        """

        updateValueLadder(cursor_x, cursor_y, alt_key, shift_key)

            Updates the value in the currently opened ladder value window based
            on the given cursor position and boolean arguments.

            This function only works if hou.ui.openValueLadder was previously
            called. Raises hou.OperationFailed if no value ladder window is
            currently open.


            cursor_x
                The horizontal coordinate of the current mouse cursor position.

            cursor_y
                The vertical coordinate of the current mouse cursor position.

            alt_key
                Whether the [Alt] modifier key is currently held. This scales
                the ladder value.

            shift_key
                Whether the [Shift] modifier key is currently held. This changes
                the ladder's active level.

            See hou.ui.openValueLadder for more information.


        """
    @staticmethod
    def closeValueLadder() -> None:
        """

        closeValueLadder()

            Closes the current value ladder window that was open by a previous
            call to hou.ui.openValueLadder.

            Raises hou.OperationFailed if no value ladder window is open.

            See hou.ui.openValueLadder for more information.


        """
    @staticmethod
    def displayFileDependencyDialog(rop_node: RopNode|None = ..., uploaded_files: Sequence[str] = ..., forced_unselected_patterns: Sequence[str] = ..., project_dir_variable: str = ..., is_standalone: bool = ...) -> Tuple[bool, Tuple[Tuple[Parm, str],...]]:
        """

        displayFileDependencyDialog(rop_node=None, uploaded_files=(),
        forced_unselected_patterns=(), project_dir_variable='HIP',
        is_standalone=true) -> (bool, tuple of Parm and string tuples)

            Open a dialog displaying the file dependencies in the current .hip
            file.

            Return a 2-tuple where the first element in the tuple is True if the
            dialog was closed with the OK button and False otherwise, and the
            second element is a tuple of the selected file patterns. Each
            selected file pattern is represented as a <hou.Parm, string> pair
            which stores the source parameter that contains the file pattern and
            the file pattern itself.


            NOTE
                If the source parameter is not None then it is recommended that
                file pattern expansion be performed by evaluating the
                parameter's value instead of calling hou.expandString.
                Evaluating the source parameter is far more accurate since it
                accounts for channel references and context-specific variables
                like $OS.


        """
    @staticmethod
    def displayNodeHelp(node_type: NodeType) -> None:
        """

        displayNodeHelp(node_type)

            Display the help for the specified node type. If no help browser is
            open, this function will create a new one.

            If you want to display the help for a node instance, it is easy to
            access the hou.NodeType from the node, as illustrated in this
            example:

          > def displayHelpForNode(node):
          > '''Given a hou.OpNode, display its help.'''
          > hou.ui.displayNodeHelp(node.type())

        """
    @staticmethod
    def openRenderDialog(rop: RopNode) -> None:
        """

        openRenderDialog(rop_node)

            Given a hou.RopNode instance, open the render control dialog for the
            node. This dialog can be used to override certain render parameters,
            and launch a render.


        """
    @staticmethod
    def openRenameSelectedDialog(network: Node) -> None:
        """

        openRenameSelectedDialog(node)

            Given a hou.OpNode which contains other nodes, open a dialog for
            renaming all selected children of the node. The dialog uses pattern
            matching to rename all the selected nodes in one operation.


        """
    @staticmethod
    def openParameterInterfaceDialog(node: Node, open_tab: Optional[EnumValue] = None, open_tab_tree_path: Optional[str] = None) -> None:
        """

        openParameterInterfaceDialog(node, open_tab = None, open_tab_tree_path =
        '')

            Given a hou.OpNode, open the parameter interface editor dialog. This
            dialog is can be used to add or remove spare parameters, or
            rearrange the parameter layout for a node.


            open_tab
                A hou.parameterInterfaceTabType enum value that causes the
                dialog to appear with a particular parameter source tab
                displayed.

            open_tab_tree_path
                If an open_tab is specified, this parameter can further control
                the state of the dialog when it opens. This string can specify a
                full path to a branch in the tree of the open tab which will be
                expanded and set as current.


        """
    @staticmethod
    def updateMode() -> EnumValue:
        """

        updateMode() -> hou.updateMode enum value

            This method is deprecated in favor of hou.updateModeSetting.


        """
    @staticmethod
    def setUpdateMode(mode: EnumValue) -> None:
        """

        setUpdateMode(mode)

            This method is deprecated in favor of hou.setUpdateMode.


        """
    @staticmethod
    def triggerUpdate() -> None:
        """

        triggerUpdate()

            Force the viewports to update and perform any cooks necessary. You
            might call this function when Houdini's Auto Update mode is on
            Manual.


        """
    @staticmethod
    def reloadViewportColorSchemes() -> None:
        """

        reloadViewportColorSchemes()

            Reloads all 3DSceneColors configuration files (in
            $HFS/houdini/config). You must cause the viewport to redraw (for
            example, by tumbling) to see the new colors.

            This function may be useful if you are implementing a new color
            scheme: you can map to a hotkey or call it in the Python console so
            you can check your changes.


        """
    @staticmethod
    def reloadColorScheme() -> None:
        """

        reloadColorScheme()

            Reloads all Houdini UI color settings from the configuration files
            (by default, in $HFS/houdini/config and
            $HOUDINI_USER_PREF_DIR/houdini/config).

            This function may be useful if you are implementing a new color
            scheme: you can map to a hotkey or call it in the Python console so
            you can check your changes.


        """
    @staticmethod
    def currentColorScheme() -> str:
        """

        currentColorScheme() -> str

            Return the currently applied Houdini color scheme name.


        """
    @staticmethod
    def isAutoKey() -> bool:
        """

        isAutoKey() -> bool`

            Returns if auto-key is currently enabled (changing an animated
            parameter will create a key at the current frame if it doesn't
            exist).


        """
    @staticmethod
    def removeAllSelectionCallbacks() -> None:
        """

        removeAllSelectionCallbacks()

            Remove all Python callbacks previously registered with
            hou.ui.addSelectionCallback. See hou.ui.addSelectionCallback for
            more information.


        """
    @staticmethod
    def postRedrawFence() -> None:
        """

        postRedrawFence()

            Puts a redraw fence on the event queue. This will ensure all draws
            repeat before the next event is processed. Used with care, this can
            guarantee updates of the viewer.


        """
    @staticmethod
    def createDialog(ui_file_name: str) -> Dialog:
        """

        createDialog(ui_file_name) -> hou.Dialog

            Parse the given .ui file and return the dialog defined in the file.

            The dialog must be written with Houdini's User Interface Script
            Language. An overview of the language can be found in the Houdini
            Development Kit (HDK) documentation, specifically in the Houdini
            User Interface -> The .ui Script Language section.

            ui_file_name is the basename of the .ui file. The file must be
            located in a directory registered with the HOUDINI_UI_APP_PATH
            search path. For a list of HOUDINI_UI_APP_PATH search directories,
            run hconfig -ap from a terminal.

            Raises hou.OperationFailed if the .ui file contains errors and the
            dialog could not be created. Raises TypeError if ui_file_name is
            None.


        """
    @staticmethod
    def findDialog(ui_file_name: str) -> Optional[Dialog]:
        """

        findDialog(ui_file_name) -> hou.Dialog

            Return the dialog defined by the given .ui file name and created by
            hou.ui.createDialog.

            Return None if no dialog has been created with hou.ui.createDialog
            for the specified .ui file.

            Raises TypeError if ui_file_name is None.


        """
    @staticmethod
    def dialogs() -> Tuple[Dialog, ...]:
        """

        dialogs() -> tuple of hou.Dialog

            Return all dialogs created by hou.ui.createDialog.


        """
    @staticmethod
    def writePythonShellHistoryFile(filename: Optional[str] = None) -> None:
        """

        writePythonShellHistoryFile(filename=None)

            Save the command history from the current Python Shell to disk. If
            filename is None, then the history is written to
            $HOME/houdiniX.Y/pyshell.history. If this function is invoked
            outside of a Python Shell, then the history is taken from the last
            active shell (i.e. the last shell that was opened or accepted
            input).

            Raises hou.OperationFailed if no Python Shell has been opened.
            Raises hou.OperationFailed if filename cannot be created.


        """
    @staticmethod
    def readPythonShellHistoryFile(filename: Optional[str] = None) -> None:
        """

        readPythonShellHistoryFile(filename=None)

            Load the contents from the specified file into the command history
            of the Python Shell. If filename is None, then the history is read
            from $HOME/houdiniX.Y/pyshell.history. If this function is invoked
            outside of a Python Shell, then the history is loaded into the the
            last active shell (i.e. the last shell that was opened or accepted
            input).

            Raises hou.OperationFailed if no Python Shell has been opened.
            Raises hou.OperationFailed if filename does not exist or cannot be
            read.


        """
    @staticmethod
    def setStatusMessage(message: str, severity: EnumValue = ...) -> None:
        '''

        setStatusMessage(message, severity=hou.severityType.Message)

            Display a message in Houdini\'s status bar.


            severity
                A hou.severityType enum value that determines the background
                color of the message.

            To clear the status bar, call hou.ui.setStatusMessage(\\"\\").


        '''
    @staticmethod
    def statusMessage() -> Tuple[str, EnumValue]:
        """

        statusMessage() -> (string, hou.severityType)

            Return the current message and severity from the status bar. This
            may not match the value most recently passed to setStatusMessage
            because Houdini itself often changes the message in the status bar.


        """
    @staticmethod
    def openAssetUploadDialog(uploading_node: Node, session_key: str, containing_node: Node) -> None: ...
    @staticmethod
    def openAssetDependenciesDialog(uploading_nodes: Sequence[Node], uploaded_nodes: Sequence[Node], session_key: str, containing_node: Node) -> None: ...
    @staticmethod
    def hasDragSourceData(label: str, index: int) -> bool:
        """

        getDragSourceData(label, index) -> data

            Query the current drag source to obtain the dragged data. Returns
            None when the specified data in unavailable (or unsupported by HOM).

            Raises hou.NotAvailable if no drag operation is currently active.


            label
                Specifies the type of the source event to query. See
                hou.ui.hasDragSourceData for the label types to use.

            index
                Index of the data in the source. Defaults to 0.


        """
    @staticmethod
    def getDragSourceData(label: str, index: int = ...) -> Any: ...
    @staticmethod
    def resourceValueFromName(name: str) -> str:
        """

        resourceValueFromName(self, name) -> str

            Return a string value from a symbolic resource name. The resource
            name should correspond to one of the entries in the $HH/config/*.hcs
            file for the currently selected color scheme.

            Raises: hou.ValueError if the provided symbolic name doesn't exist.


        """
    @staticmethod
    def colorFromName(name: str) -> Color:
        '''

        colorFromName(self, name) -> hou.Color

            Return a color value from a symbolic color name. The color name
            should correspond to one of the entries in the $HH/config/*.hcs file
            for the currently selected color scheme.

            Raises: hou.ValueError if the provided symbolic name doesn\'t exist.

            For example:

          > >>> hou.ui.colorFromName(\\"DisplayOnColor\\")
          > <hou.Color r=0.3, g=0.5, b=1>

            TIP
                You can use hou.qt.getColor to get a Qt color object instead of
                a HOM color object.


        '''
    @staticmethod
    def globalScaleFactor() -> float:
        """

        globalScaleFactor(self) -> float

            Return the scale factor that is set by Houdini's Global UI Size
            preference. For example, this function returns 1.0 when Houdini is
            set to the Normal UI size.

            The scale factor can be used to scale components in a PySide or PyQt
            built UI where hou.ui.scaledSize cannot be called. For example, the
            scale factor can be used to set the zoom factor of a QWebEngineView
            object so that the web contents match the Global UI Size:

          > web_view = QWebEngineWidgets.QWebEngineView()
          > web_view.setZoomFactor(hou.ui.globalScaleFactor())

        """
    @staticmethod
    def scaledSize(size: int) -> int:
        """

        scaledSize(self, size) -> int

            Scale the specified size by the global UI scale factor and return
            the scaled size. The scale factor is determined by Houdini's Global
            UI Size preference. For example, the factor is 1.0 when Houdini is
            set to the Normal UI size.

            This function is useful for scaling hard-coded sizes in PySide or
            PyQt code. Here is an example of using scaled sizes when setting a
            widget to a fixed size that is 640x480 with the Normal UI size:

          > widget = QtWidgets.QWidget()
          > widget.resize(hou.ui.scaledSize(640), hou.ui.scaledSize(480))

            Here is another example of creating a scaled icon using the
            hou.qt.createIcon function:

          > icon = hou.qt.createIcon(hou.ui.scaledSize(32), hou.ui.scaledSize(32))

        """
    @staticmethod
    def inchesToPixels(inches: float) -> float:
        """

        inchesToPixels(self, inches) -> float

            Return the supplied inches argument, expressing a distance on the
            screen, converted to a number of pixels. This calculation combines
            the number of dots per inch reported by the operating system, the
            Global UI Size setting accessible from Edit > Preferences > General
            User Interface, and the HOUDINI_UISCALE environment variable, if it
            has been set. As such, this value may not be accurate, but is
            consistent with the way the rest of Houdini converts distances from
            inches to pixels.


        """
    @staticmethod
    def pixelsToInches(pixels: float) -> float:
        """

        pixelsToInches(self, pixels) -> float

            Return the supplied pixels argument, expressing a number of pixels
            on the screen, converted to a distance in inches. This calculation
            combines the number of dots per inch reported by the operating
            system, the Global UI Size setting accessible from Edit >
            Preferences > General User Interface, and the HOUDINI_UISCALE
            environment variable, if it has been set. As such, this value may
            not be accurate, but is consistent with the way the rest of Houdini
            converts distances from pixels to inches.


        """
    @staticmethod
    def copyTextToClipboard(text: str) -> None:
        """

        copyTextToClipboard(self, text)

            Sets the supplied text into the system clipboard.


        """
    @staticmethod
    def getTextFromClipboard() -> str:
        """

        getTextFromClipboard(self) -> str

            Returns any text currently copied into the system clipboard. If the
            clipboard is empty or contains non-text data, an empty string is
            returned.


        """
    @staticmethod
    def hotkeys(hotkey_symbol: str) -> Tuple[str, ...]:
        '''

        hotkeys(self, hotkey_symbol) -> tuple of str

            Return a tuple of strings that represent the hotkeys currently
            assigned to the action associated with the hotkey symbol. The hotkey
            symbols can be found in the $HH/config/Hotkeys directory.

            Raises: hou.ValueError if the provided hotkey symbol doesn\'t exist.

            For example:

          > >>> hou.ui.hotkeys(\\"h.copy\\")
          > (\'Alt+C\', \'Ctrl+C\')
          > >>> hou.ui.hotkeys(\\"h.pane.copytab\\")
          > (\'Ctrl+T\',)

        '''
    @staticmethod
    def hotkeyDescription(hotkey_symbol: str) -> str:
        '''

        hotkeyDescription(self, hotkey_symbol) -> str

            Return a string that contains a description of the action associated
            with the hotkey symbol. The hotkey symbols can be found in the
            $HH/config/Hotkeys directory.

            Raises: hou.ValueError if the provided hotkey symbol doesn\'t exist.

            For example:

          > >>> hou.ui.hotkeyDescription(\\"h.pane.copytab\\")
          > \'Copy Tab\'

        '''
    @staticmethod
    def isKeyMatch(key: str, hotkey_symbol: str) -> bool:
        '''

        isKeyMatch(self, key, hotkey_symbol) -> bool

            Return True if the key described by the string key matches one of
            the hotkeys assigned to the provided hotkey symbol. The hotkey
            symbols can be found in the $HH/config/Hotkeys directory.

            Raises: hou.ValueError if the provided hotkey symbol doesn\'t exist,
            or the key string doesn\'t represent a valid hotkey.

            For example:

          > >>> hou.ui.isKeyMatch(\\"Ctrl+C\\", \\"h.copy\\")
          > True
          > >>> hou.ui.isKeyMatch(\\"Ctrl+C\\", \\"h.pane.copytab\\")
          > False

        '''
    @staticmethod
    def openCaptureWeightSpreadsheet(node: Node, pattern: Optional[str] = None) -> None:
        """

        openCaptureWeightSpreadsheet(node, pattern=None)

            Given an instance of a hou.SopNode that is a captureoverride type,
            open the edit capture weight spreadsheet for the node. If a string
            is passed for pattern, then only the points specified by the pattern
            will be shown, otherwise all the points for the node will be
            displayed in the spreadsheet.


        """
    @staticmethod
    def registerViewerState(vs_templ: ViewerStateTemplate) -> None:
        """

        registerViewerState(template)

            Registers a hou.ViewerStateTemplate object representing a custom
            viewer state. See installing viewer states for how to use this
            function.


            template
                The hou.ViewerStateTemplate object.

            Raises hou.NameConflict if the registration fails because a state
            with the same name is already registered. Raises hou.OperationFailed
            if the registration fails (for example, the state to register has no
            factory).


        """
    @staticmethod
    def registerViewerStateFile(state_file: str) -> None:
        """

        registerViewerStateFile(file_path)

            Registers a viewer state type implemented in a given python file.
            Any viewer state previously registered by this file will be
            unregistered first.

            See installing viewer states for more details about python state
            files.


            file_path
                A full path to the python file containing the viewer state.

            Raises hou.OperationFailed if the registration fails (for example,
            the state to register has no factory).


        """
    @staticmethod
    def registerViewerStates() -> None:
        """

        registerViewerStates()

            Scans the viewer state folders ($HH/viewer_states and
            $HOUDINI_USER_PREF_DIR/viewer_states) to register all viewer states
            they both contain. Viewer states already registered in Houdini are
            simply updated with the version on disk.


        """
    @staticmethod
    def unregisterViewerState(state_typename: str) -> None:
        """

        unregisterViewerState(state_name)

            Unregisters an existing viewer state type.

            See installing viewer states for how to use this function.


            state_name
                The name of the state to unregister.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no state with the given name is registered).


        """
    @staticmethod
    def unregisterViewerStateFile(state_file: str) -> None:
        """

        unregisterViewerStateFile(file_path)

            Unregisters a viewer state previously registered with a given python
            file. See installing viewer states for more details about python
            state files.


            file_path
                A full path to the python file referring to a viewer state.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no state was registered with this file).


        """
    @staticmethod
    def isRegisteredViewerState(state_name: str) -> bool:
        """

        isRegisteredViewerState(state_name) -> bool

            Returns True if state_name has previously been registered with
            hou.ui.registerViewerState. Returns False if not.


            state_name
                The name of the state to validate.


        """
    @staticmethod
    def reloadViewerState(state_typename: str) -> None:
        """

        reloadViewerStates(state_names=None)

            Reload multiple viewer states as specified in the state_names array.
            If the array is empty, all registered self-installed states in
            Houdini are reloaded. See hou.ui.reloadViewerState for more details
            on reloading a state.


            state_names
                Array of state names to reload. Empty by default.

            Raises hou.OperationFailed if the reload fails (for example, if no
            state with a given name is registered).


        """
    @staticmethod
    def reloadViewerStates(state_names: Sequence[str]|None = ...) -> None: ...
    @staticmethod
    def viewerStateInfo(state_names: Sequence[str] = ...) -> str:
        '''

        viewerStateInfo(state_names) -> str

            Return a JSON dictionary string describing all registered viewer
            states keyed by state type.


            state_names
                Array of state names to process. If the array is empty
                (default), all viewer states currently registered are processed.

          > import json
          > 
          > info_str = hou.ui.viewerStateInfo([\\"sidefx_stroke\\"])
          > info_dict = json.loads(info_str)
          > info = json.dumps(info_dict[\\"sidefx_stroke\\"], indent=3)
          > print(info)
          > 
          > {
          >    \\"Type\\": \\"sidefx_stroke\\",
          >    \\"Label\\": \\"Stroke\\",
          >    \\"Icon\\": \\"$HFS/houdini/pic/minimizedicon.pic\\",
          >    \\"Category\\": \\"Sop\\",
          >    \\"Source\\": \\"$HFS/houdini/viewer_states/sidefx_stroke.py\\",
          >    \\"Contexts\\": [
          >       \\"SOP\\"
          >    ],
          >    \\"Handles\\": {},
          >    \\"Gadgets\\": {},
          >    \\"Selectors\\": {
          >       \\"sidefx_default_selector\\": {
          >          \\"Name\\": \\"sidefx_default_selector\\",
          >          \\"Auto start\\": false,
          >          \\"Hotkey\\": {
          >             \\"Path\\": \\"\\",
          >             \\"Label\\": \\"\\",
          >             \\"Description\\": \\"\\",
          >             \\"Keys\\": []
          >          },
          >          \\"Secure selection\\": \\"obey\\",
          >          \\"Prompt\\": \\"default geometry selector\\",
          >          \\"Allow drag\\": false,
          >          \\"Quick select\\": true,
          >          \\"Use existing selection\\": true,
          >          \\"Initial selection\\": \\"\\",
          >          \\"Initial selection type\\": \\"\\",
          >          \\"Ordered\\": false,
          >          \\"Geometry types\\": [],
          >          \\"Allow other sops\\": true
          >       }
          >    },
          >    \\"Menus\\": {
          >       \\"Stroke\\": {
          >          \\"Type\\": \\"Menu\\",
          >          \\"Handle\\": \\"stroke_menu\\",
          >          \\"Draw realtime\\": {
          >             \\"Type\\": \\"Toggle\\",
          >             \\"Handle\\": \\"realtime_mode\\",
          >             \\"Hotkey\\": {
          >                \\"Path\\": \\"h.pane.gview.state.sop.sidefx_stroke.realtime_mode\\",
          >                \\"Label\\": \\"realtime\\",
          >                \\"Description\\": \\"Enable realtime mode\\",
          >                \\"Keys\\": [
          >                   48
          >                ]
          >             }
          >          },
          >          \\"Brush settings...\\": {
          >             \\"Type\\": \\"Menu\\",
          >             \\"Handle\\": \\"brush_menu\\",
          >             \\"Cycle brushes\\": {
          >                \\"Type\\": \\"Action\\",
          >                \\"Handle\\": \\"cycle_brushes\\",
          >                \\"Hotkey\\": {
          >                   \\"Path\\": \\"h.pane.gview.state.sop.sidefx_stroke.cycle_brushes\\",
          >                   \\"Label\\": \\"Cycle brushes\\",
          >                   \\"Description\\": \\"Cycle stroke tools\\",
          >                   \\"Keys\\": [
          >                      49
          >                   ]
          >                }
          >             },
          >             \\"Brush display mode\\": {
          >                \\"Type\\": \\"Radio strip\\",
          >                \\"Handle\\": \\"brush_display_mode\\",
          >                \\"Default\\": \\"brush_viewport_display\\",
          >                \\"Wireframe\\": {
          >                   \\"Type\\": \\"Radio strip item\\",
          >                   \\"Handle\\": \\"brush_wireframe_display\\",
          >                   \\"Hotkey\\": {
          >                      \\"Path\\": \\"h.pane.gview.state.sop.sidefx_stroke.set_wireframe_brush\\",
          >                      \\"Label\\": \\"Set wireframe brush\\",
          >                      \\"Description\\": \\"Set wireframe brush\\",
          >                      \\"Keys\\": [
          >                         50
          >                      ]
          >                   }
          >                },
          >                \\"Viewport\\": {
          >                   \\"Type\\": \\"Radio strip item\\",
          >                   \\"Handle\\": \\"brush_viewport_display\\",
          >                   \\"Hotkey\\": {
          >                      \\"Path\\": \\"h.pane.gview.state.sop.sidefx_stroke.set_viewport_brush\\",
          >                      \\"Label\\": \\"Set viewport brush\\",
          >                      \\"Description\\": \\"Set viewport brush\\",
          >                      \\"Keys\\": [
          >                         51
          >                      ]
          >                   }
          >                }
          >             }
          >          }
          >       }
          >    }
          > }

        '''
    @staticmethod
    def viewerStateInfoFromFile(state_file: str) -> Tuple[str, str]:
        '''

        viewerStateInfoFromFile(state_filepath) -> (str, str)

            Returns the viewer state information for a given python state file.
            The information is returned as a tuple containing the python state
            type name and a JSON dictionary string describing the registered
            viewer state information.


            state_filepath
                A python state file path. The method returns an empty tuple if
                the file path is not a python state file or the python state
                contained in the file is not registered.


            NOTE
                This method doesn\'t work with HDA python state files.

          > import json
          > 
          > (state_type, info_str) = hou.ui.viewerStateInfoFromFile(
          >     \\"$HFS/packages/viewer_state_demo/viewer_states/drawable_selector_sop.py\\"
          > )
          > info_dict = json.loads(info_str)
          > info = json.dumps(info_dict[state_type], indent=3)
          > print(info)
          > 
          > {
          >    \\"Type\\": \\"drawable_selector_sop\\",
          >    \\"Label\\": \\"State Drawable Selector Demo\\",
          >    \\"Icon\\": \\"DESKTOP_application_mac\\",
          >    \\"Category\\": \\"Sop\\",
          >    \\"Source\\": \\"$HFS/packages/viewer_state_demo/viewer_states/drawable_selector_sop.py\\",
          >    \\"Contexts\\": [
          >       \\"SOP\\"
          >    ],
          >    \\"Handles\\": {},
          >    \\"Gadgets\\": {},
          >    \\"Selectors\\": {
          >       \\"drawable_selector\\": {
          >          \\"Name\\": \\"drawable_selector\\",
          >          \\"Auto start\\": true,
          >          \\"Hotkey\\": {
          >             \\"Path\\": \\"h.pane.gview.state.sop.drawable_selector_sop.drawable selector\\",
          >             \\"Label\\": \\"drawable selector\\",
          >             \\"Description\\": \\"drawable selector\\",
          >             \\"Keys\\": [
          >                49
          >             ]
          >          },
          >          \\"Secure selection\\": \\"ignore\\",
          >          \\"Prompt\\": \\"Select a drawable component\\",
          >          \\"Allow drag\\": false,
          >          \\"Quick select\\": true,
          >          \\"Use existing selection\\": true,
          >          \\"Initial selection\\": \\"\\",
          >          \\"Initial selection type\\": \\"\\",
          >          \\"Ordered\\": false,
          >          \\"Geometry types\\": [
          >             \\"point\\",
          >             \\"edge\\",
          >             \\"prim\\"
          >          ],
          >          \\"Allow other sops\\": false
          >       },
          >       \\"primitive_selector\\": {
          >          \\"Name\\": \\"primitive_selector\\",
          >          \\"Auto start\\": false,
          >          \\"Hotkey\\": {
          >             \\"Path\\": \\"h.pane.gview.state.sop.drawable_selector_sop.primitive selector\\",
          >             \\"Label\\": \\"primitive selector\\",
          >             \\"Description\\": \\"primitive selector\\",
          >             \\"Keys\\": [
          >                50
          >             ]
          >          },
          >          \\"Secure selection\\": \\"ignore\\",
          >          \\"Prompt\\": \\"Select a primitive component\\",
          >          \\"Allow drag\\": true,
          >          \\"Quick select\\": true,
          >          \\"Use existing selection\\": true,
          >          \\"Initial selection\\": \\"\\",
          >          \\"Initial selection type\\": \\"\\",
          >          \\"Ordered\\": false,
          >          \\"Geometry types\\": [
          >             \\"prim\\"
          >          ],
          >          \\"Allow other sops\\": false
          >       },
          >       \\"sidefx_default_selector\\": {
          >          \\"Name\\": \\"sidefx_default_selector\\",
          >          \\"Auto start\\": false,
          >          \\"Hotkey\\": {
          >             \\"Path\\": \\"\\",
          >             \\"Label\\": \\"\\",
          >             \\"Description\\": \\"\\",
          >             \\"Keys\\": []
          >          },
          >          \\"Secure selection\\": \\"obey\\",
          >          \\"Prompt\\": \\"default geometry selector\\",
          >          \\"Allow drag\\": false,
          >          \\"Quick select\\": true,
          >          \\"Use existing selection\\": true,
          >          \\"Initial selection\\": \\"\\",
          >          \\"Initial selection type\\": \\"\\",
          >          \\"Ordered\\": false,
          >          \\"Geometry types\\": [],
          >          \\"Allow other sops\\": true
          >       }
          >    },
          >    \\"Menus\\": {
          >       \\"Drawable Selector Demo\\": {
          >          \\"Type\\": \\"Menu\\",
          >          \\"Handle\\": \\"drawable_selector_menu\\",
          >          \\"Log Info\\": {
          >             \\"Type\\": \\"Toggle\\",
          >             \\"Handle\\": \\"log_info\\",
          >             \\"Hotkey\\": {
          >                \\"Path\\": \\"\\",
          >                \\"Label\\": \\"\\",
          >                \\"Description\\": \\"\\",
          >                \\"Keys\\": []
          >             }
          >          },
          >          \\"Clear Console\\": {
          >             \\"Type\\": \\"Action\\",
          >             \\"Handle\\": \\"clear_console\\",
          >             \\"Hotkey\\": {
          >                \\"Path\\": \\"\\",
          >                \\"Label\\": \\"\\",
          >                \\"Description\\": \\"\\",
          >                \\"Keys\\": []
          >             }
          >          }
          >       }
          >    }
          > }

        '''
    @staticmethod
    def viewerHandleInfo(handle_names: Sequence[str] = ...) -> str:
        '''

        viewerHandleInfo(handle_names) -> string

            Return a JSON dictionary string describing all registered viewer
            handles in Houdini. The viewer handles can be queried by type name.


            handle_names
                Array of handle type names. The function returns a dictionary
                containing all registered handles specified in the array. If the
                array is empty (default), all registered viewer handles are
                returned.

          >     >>> import ast
          >     >>> viewer_handles = ast.literal_eval(hou.ui.viewerHandleInfo())
          >     >>> viewer_handles[\\"move_tool_handle\\"]
          > {
          >    \\"Gadgets\\":{
          >       \\"zdisc\\":{
          >          \\"Drawable\\":\\"Line\\",
          >          \\"Name\\":\\"zdisc\\",
          >          \\"Label\\":\\"Z\\"
          >       },
          >       \\"yscale\\":{
          >          \\"Drawable\\":\\"Face\\",
          >          \\"Name\\":\\"yscale\\",
          >          \\"Label\\":\\"Y\\"
          >       },
          >       \\"yaxis\\":{
          >          \\"Drawable\\":\\"Line\\",
          >          \\"Name\\":\\"yaxis\\",
          >          \\"Label\\":\\"Y\\"
          >       },
          >       \\"zscale\\":{
          >          \\"Drawable\\":\\"Face\\",
          >          \\"Name\\":\\"zscale\\",
          >          \\"Label\\":\\"Z\\"
          >       },
          >       \\"zaxis\\":{
          >          \\"Drawable\\":\\"Line\\",
          >          \\"Name\\":\\"zaxis\\",
          >          \\"Label\\":\\"Z\\"
          >       },
          >       \\"xaxis\\":{
          >          \\"Drawable\\":\\"Line\\",
          >          \\"Name\\":\\"xaxis\\",
          >          \\"Label\\":\\"X\\"
          >       },
          >       \\"xscale\\":{
          >          \\"Drawable\\":\\"Face\\",
          >          \\"Name\\":\\"xscale\\",
          >          \\"Label\\":\\"X\\"
          >       },
          >       \\"pivot\\":{
          >          \\"Drawable\\":\\"Face\\",
          >          \\"Name\\":\\"pivot\\",
          >          \\"Label\\":\\"XYZ\\"
          >       },
          >       \\"xdisc\\":{
          >          \\"Drawable\\":\\"Line\\",
          >          \\"Name\\":\\"xdisc\\",
          >          \\"Label\\":\\"X\\"
          >       },
          >       \\"ydisc\\":{
          >          \\"Drawable\\":\\"Line\\",
          >          \\"Name\\":\\"ydisc\\",
          >          \\"Label\\":\\"Y\\"
          >       }
          >    },
          >    \\"Parameters\\":{
          >       \\"Sz\\":{
          >          \\"Default\\":1,
          >          \\"Range\\":\\"(0.1, 10)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"sz\\",
          >          \\"Label\\":\\"Sz\\"
          >       },
          >       \\"Sy\\":{
          >          \\"Default\\":1,
          >          \\"Range\\":\\"(0.1, 10)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"sy\\",
          >          \\"Label\\":\\"Sy\\"
          >       },
          >       \\"Sx\\":{
          >          \\"Default\\":1,
          >          \\"Range\\":\\"(0.1, 10)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"sx\\",
          >          \\"Label\\":\\"Sx\\"
          >       },
          >       \\"Tz\\":{
          >          \\"Default\\":0,
          >          \\"Range\\":\\"(-10, 10)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"tz\\",
          >          \\"Label\\":\\"Tz\\"
          >       },
          >       \\"Tx\\":{
          >          \\"Default\\":0,
          >          \\"Range\\":\\"(-10, 10)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"tx\\",
          >          \\"Label\\":\\"Tx\\"
          >       },
          >       \\"Ty\\":{
          >          \\"Default\\":0,
          >          \\"Range\\":\\"(-10, 10)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"ty\\",
          >          \\"Label\\":\\"Ty\\"
          >       },
          >       \\"Rx\\":{
          >          \\"Default\\":0,
          >          \\"Range\\":\\"(0, 360)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"rx\\",
          >          \\"Label\\":\\"Rx\\"
          >       },
          >       \\"Ry\\":{
          >          \\"Default\\":0,
          >          \\"Range\\":\\"(0, 360)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"ry\\",
          >          \\"Label\\":\\"Ry\\"
          >       },
          >       \\"Rz\\":{
          >          \\"Default\\":0,
          >          \\"Range\\":\\"(0, 360)\\",
          >          \\"Type\\":\\"Float\\",
          >          \\"Name\\":\\"rz\\",
          >          \\"Label\\":\\"Rz\\"
          >       }
          >    },
          >    \\"Settings\\":{
          >       \\"\\":{
          >          \\"Type\\":\\"Separator\\",
          >          \\"Name\\":\\"separator0\\",
          >          \\"Label\\":\\"\\"
          >       },
          >       \\"Drag Along Plane\\":{
          >          \\"Default\\":\\"XZ\\",
          >          \\"Menu Items\\":[
          >             \\"(XZ, XZ)\\",
          >             \\"(XY, XY)\\",
          >             \\"(ZY, ZY)\\",
          >             \\"(XYZ, XYZ)\\"
          >          ],
          >          \\"Type\\":\\"Menu\\",
          >          \\"Name\\":\\"planes\\",
          >          \\"Label\\":\\"Drag Along Plane\\"
          >       },
          >       \\"Draw dimension lines\\":{
          >          \\"Default\\":1,
          >          \\"Type\\":\\"Toggle\\",
          >          \\"Name\\":\\"dimensions\\",
          >          \\"Label\\":\\"Draw dimension lines\\"
          >       }
          >    },
          >    \\"Menus\\":{
          >       \\"Move Tool Handle\\":{
          >          \\"Cycle Gadgets\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   89
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.cycle\\",
          >                \\"Description\\":\\"cycle\\",
          >                \\"Label\\":\\"cycle\\"
          >             },
          >             \\"Handle\\":\\"cycle\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"Handle\\":\\"move_tool_handle_menu\\",
          >          \\"Trace\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   51
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.trace_handle\\",
          >                \\"Description\\":\\"Enable handle trace\\",
          >                \\"Label\\":\\"Trace\\"
          >             },
          >             \\"Handle\\":\\"trace_handle\\",
          >             \\"Type\\":\\"Toggle\\"
          >          },
          >          \\"Edit\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   53
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.edit_handle\\",
          >                \\"Description\\":\\"Edit Handle\\",
          >                \\"Label\\":\\"Edit\\"
          >             },
          >             \\"Handle\\":\\"edit_handle\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"XYZ\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   65
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.XYZ\\",
          >                \\"Description\\":\\"XYZ\\",
          >                \\"Label\\":\\"XYZ\\"
          >             },
          >             \\"Handle\\":\\"XYZ\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"Inspect\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   50
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.inspect_handle\\",
          >                \\"Description\\":\\"Inspect Handle\\",
          >                \\"Label\\":\\"Inspect\\"
          >             },
          >             \\"Handle\\":\\"inspect_handle\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"XZ\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   70
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.XZ\\",
          >                \\"Description\\":\\"XZ\\",
          >                \\"Label\\":\\"XZ\\"
          >             },
          >             \\"Handle\\":\\"XZ\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"Reload\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   54
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.reload_handle\\",
          >                \\"Description\\":\\"Reload Handle\\",
          >                \\"Label\\":\\"Reload\\"
          >             },
          >             \\"Handle\\":\\"reload_handle\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"XY\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   71
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.XY\\",
          >                \\"Description\\":\\"XY\\",
          >                \\"Label\\":\\"XY\\"
          >             },
          >             \\"Handle\\":\\"XY\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"ZY\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   66
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.ZY\\",
          >                \\"Description\\":\\"ZY\\",
          >                \\"Label\\":\\"ZY\\"
          >             },
          >             \\"Handle\\":\\"ZY\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"Clear console\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   49
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.clear_console\\",
          >                \\"Description\\":\\"Clear console\\",
          >                \\"Label\\":\\"Clear\\"
          >             },
          >             \\"Handle\\":\\"clear_console\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"Marker\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   52
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.add_marker\\",
          >                \\"Description\\":\\"Add Marker\\",
          >                \\"Label\\":\\"Marker\\"
          >             },
          >             \\"Handle\\":\\"add_marker\\",
          >             \\"Type\\":\\"Action\\"
          >          },
          >          \\"Logging\\":{
          >             \\"Hotkey\\":{
          >                \\"Keys\\":[
          >                   48
          >                ],
          >                \\"Path\\":\\"h.pane.gview.handle.move_tool_handle.console_logging\\",
          >                \\"Description\\":\\"Enable or disable console logging\\",
          >                \\"Label\\":\\"Logging\\"
          >             },
          >             \\"Handle\\":\\"console_logging\\",
          >             \\"Type\\":\\"Toggle\\"
          >          },
          >          \\"Type\\":\\"Menu\\"
          >       }
          >    },
          >    \\"Label\\":\\"Move Tool Handle\\",
          >    \\"Exported Parameters\\":[
          >       \\"tx\\",
          >       \\"ty\\",
          >       \\"tz\\",
          >       \\"rx\\",
          >       \\"ry\\",
          >       \\"rz\\",
          >       \\"sx\\",
          >       \\"sy\\",
          >       \\"sz\\"
          >    ],
          >    \\"Source\\":\\"C:/Users/marcb/DEV/HOUDINI/dev/hfs/packages/viewer_handle_demo/viewer_handles/move_tool_handle.py\\",
          >    \\"Type\\":\\"move_tool_handle\\",
          >    \\"Categories\\":[
          >       \\"Sop\\"
          >    ],
          >    \\"Icon\\":\\"$HFS/houdini/pic/Mandril.pic\\"
          > }

        '''
    @staticmethod
    def printResourceMessage(resource_type: EnumValue, message: str, message_type: EnumValue = ...) -> None:
        """

        printResourceMessage(resource_type, message,
        message_type=hou.severityType.Message)

            Print a user message in the message window of a Viewer State Browser
            or Viewer Handle Browser. The
            hou.resourceEventMessage.OnPrintMessage event is sent when calling
            this function.


            resource_type
                A resource type to choose the browser console. Use
                hou.resourceType.ViewerState to print messages in the Viewer
                State Browser or hou.resourceType.ViewerHandle for the Viewer
                Handle Browser.

            message
                String message to print.

            message_type
                Type of message to print. Fatal and Important types are ignored
                and default to Message.


        """
    @staticmethod
    def fireResourceCustomEvent(resource_type: EnumValue, user_data: Mapping[str, bool|AttribBasicType], queue: bool = ...) -> None:
        """

        fireResourceCustomEvent(resource_type, user_data, queue=True)

            This function triggers a custom resource event which can be used for
            implementing specific workflows. Client callbacks registered with
            hou.ui.addResourceEventCallback will get notified with the input
            user_data argument. The event can be processed immediately or later
            when Houdini is idle, see the queue argument for details.


            resource_type
                The event resource type.

            user_data
                A dictionary mapping user-defined entries to values of type int,
                double, bool and string. An exception is raised if user_data is
                empty or contains unsupported value types.


                fireResourceCustomEvent will add the following entries to the
                dictionary
                    resource_type: The resource_type argument value. event_type:
                    OnCustomEvent event type.

            queue
                If True (default), the event is put on a queue and processed
                when Houdini is idle. If False, the event is processed
                immediately.

            Here's how a custom event can be used.

          > 
          > # Register a callback for viewer state events
          > hou.ui.addResourceEventCallback(myEventHandler)
          > 
          > def myEventHandler(**kwargs):
          >     import json
          >     if kwargs['event_type'] == hou.resourceEventMessage.OnCustomEvent:
          >         if 'load_file' in kwargs:
          >             # load a json file and store results 
          >             with open(kwargs['load_file']) as file:
          >                 json_values = json.load(file)                
          >         elif 'save_file' in kwargs:
          >             # save json_values to a json file
          >             with open(kwargs['save_file'], 'w') as file:
          >                 json.dump(json_values, file, indent=3)
          > 
          >     # process other non-custom viewer state events
          >     elif kwargs['event_type'] == hou.resourceEventMessage.OnEnter:        
          >         pass
          > 
          > ...
          > # load a json file via a custom event
          > hou.ui.fireResourceCustomEvent( hou.resourceType.ViewerState, { 'load_file': '/var/tmp/somefile.json'} )

        """
    @staticmethod
    def showInFileBrowser(file_path: str) -> None:
        """

        showInFileBrowser(file_path)

            Launch the system's file browser, navigating to the parent directory
            of the specified file and selecting it.


            file_path
                A string representing the full path to the file (or directory)
                to select.


                TIP
                    If you do not want any file selected, simply ensure the
                    filepath ends with a /.

                Examples:

              > # Launch the browser in /home/me/myDocs and select doc1.txt
              > hou.ui.showInFileBrowser('/home/me/myDocs/doc1.txt')
              > 
              > # Launch the browser in /home/me/myDocs and select nothing
              > hou.ui.showInFileBrowser('/home/me/myDocs/')
              > 
              > # Launch the browser in /home/me and select myDocs
              > hou.ui.showInFileBrowser('/home/me/myDocs')

        """
    @staticmethod
    def showFloatingParameterEditor(node: Node, reuse: bool = True) -> ParameterEditor:
        """

        showFloatingParameterEditor(node,reuse) -> hou.ParameterEditor

            Show a floating hou.ParameterEditor for a given hou.OpNode.


        """
    @staticmethod
    def openParameterExpressionEditor(parm: Parm) -> None:
        """

        openParameterExpressionEditor(parm)

            Open the expression editor to edit the expression of the given
            parameter.


            parm
                hou.Parm The parm whose expression to edit.


        """
    @staticmethod
    def openPreferences(page: str, label: str) -> None:
        """

        openPreferences(page)

            Open the preferences dialog and show the given page.


            page
                A string that specifies the preference page to open. When there
                are tabs under the page, page:tab notation is used.

                The following values are supported:

                ui

                General User Interface

                network

                Network Editor

                viewport

                3D Viewports

                shelves

                Shelf Tools and Tab Menu

                takes

                Takes

                anim

                Animation

                lighting

                Lighting

                rendering

                Rendering

                handles

                Handles

                hud

                HUD Info

                hud_handles

                HUD Handles

                states

                Interactive Tools

                objsops

                Objects and Geometry

                objsops:preferences

                Objects and Geometry > Preferences

                objsops:sop_cache

                Objects and Geometry > SOP Cache

                objsops:obj_cache

                Objects and Geometry > OBJ Cache

                chops

                Motion and Audio

                composites

                Compositing

                composites:cache

                Compositing > Cache

                composites:cooking

                Compositing > Cooking

                composites:interactive

                Compositing > Interactive

                composites:selectors

                Compositing > Selectors

                composites:names

                Compositing > Names

                composites:colors

                Compositing > Colors

                composites:cineon

                Compositing > Cineon

                scripting

                Scripting

                resmgr

                Desktops and Toolbars

                persistence

                Save and Load Options

                hipoptions

                Hip File Options

                warnings

                Warning Dialogs

                notifications

                Notifications

                perfmon

                Performance Options

                exttools

                External Tools

                misc

                Miscellaneous


        """
    @staticmethod
    def hideAllMinimizedStowbars() -> bool:
        """

        hideAllMinimizedStowbars(self) -> bool

            Return the value of a global flag that hides all the minimized
            stowbars and split panes.


        """
    @staticmethod
    def setHideAllMinimizedStowbars(hide: bool) -> None:
        """

        setHideAllMinimizedStowbars(self,on) -> bool

            Set the value of a global flag that hides all the minimized stowbars
            and split panes. When the flag is on, the minimized stowbars of all
            pane tabs ,menus , the shelf dock or toolbars will be hidden. It
            also affect the split bars of split panes, in which case, the split
            is rendered using a single pixel line.


        """
    @staticmethod
    def registerViewerHandle(tmpl: ViewerHandleTemplate) -> None:
        """

        registerViewerHandle(template)

            Registers a hou.ViewerHandleTemplate object representing a custom
            viewer handle. See installing viewer handle for how to use this
            function.


            template
                The hou.ViewerHandleTemplate object.

            Raises these exceptions if the registration fails:

          * hou.NameConflict if a handle with the same name is already
            registered.

          * hou.OperationFailed if the registration fails (for example, the
            handle to register has no factory).


        """
    @staticmethod
    def registerViewerHandles() -> None:
        """

        registerViewerHandles()

            Scans the viewer handle folders (e.g. $HH/viewer_handles and
            $HOUDINI_USER_PREF_DIR/viewer_handles) to register all viewer
            handles they both contain. Viewer handles already registered in
            Houdini are simply updated with the version on disk.


        """
    @staticmethod
    def registerViewerHandleFile(handle_file: str) -> None:
        """

        registerViewerHandleFile(handle_file)

            Registers a viewer handle type implemented in a given python file.
            Any viewer handle previously registered by this file will be
            unregistered first.

            See installing viewer handles for more details about python handle
            files.


            file_path
                A full path to the python file containing the viewer handle
                implementation.

            Raises hou.OperationFailed if the registration fails (for example,
            the handle to register has no factory).


        """
    @staticmethod
    def unregisterViewerHandle(handle_name: str) -> None:
        """

        unregisterViewerHandle(handle_name)

            Unregisters an existing viewer handle type.

            See installing viewer handles for how to use this function.


            handle_name
                The name of the handle to unregister.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no handle with the given name is registered).


        """
    @staticmethod
    def unregisterViewerHandleFile(handle_file: str) -> None:
        """

        unregisterViewerHandleFile(handle_file)

            Unregisters a viewer handle previously registered with a given
            python file. See installing viewer handles for more details about
            python handle files.


            file_path
                A full path to the python file referring to a viewer handle.

            Raises hou.OperationFailed if the unregistration fails (for example,
            if no handle was registered with this file).


        """
    @staticmethod
    def isRegisteredViewerHandle(handle_name: str) -> bool:
        """

        isRegisteredViewerHandle(handle_name) -> bool

            Returns True if handle_name has previously been registered with
            hou.ui.registerViewerHandle. Returns False if not.


            handle_name
                The type name of the viewer handle to validate.


        """
    @staticmethod
    def reloadViewerHandle(handle_name: str) -> None:
        """

        reloadViewerHandle(handle_name)

            Update a registered viewer handle by reloading its python module
            file from a viewer_handle folder. See installing handles in Houdini
            for more details.


            WARNING
                If you get an error message about a registration problem during
                a reload like the following,

                Error registering 'my_handle': factory not specified or invalid.

                Houdini will make its best to keep the broken viewer handle in
                the Viewer Handle Browser for editing the file. If not, the
                handle will be removed from Houdini and you will be forced to
                quit Houdini to fix the problem.


            handle_name
                The type name of the handle to reload.

            Raises hou.OperationFailed if the reload fails (for example, if no
            state with the given name is registered).


        """
    @staticmethod
    def loadPackage(package_filepath: str) -> None:
        """

        loadPackage(file_path, force_unload = False)

            Packages are normally loaded on startup by Houdini, this API loads
            packages at runtime. loadPackage loads regular package files to
            setup the Houdini environment variables but can also be used for
            loading resource files installed in a plugin folder. This can be
            achieved with a simple package file to set HOUDINI_PATH with the
            plugin folder path containing the plugin resource files. loadPackage
            will load and install the resources found in HOUDINI_PATH.

            See the Package Browser to learn about the structure of a package
            plugin folder and how to create a plugin folder.


            NOTE
                If already loaded, the package is first unloaded and loaded
                back.


            file_path
                A file path pointing to the package file to load.

            force_unload
                Force a locked package to unload if True. By default, locked
                packages cannot be unloaded.


        """
    @staticmethod
    def loadPackageArchive(file_path: str, extract_path: str|None = ...) -> Tuple[str,...]:
        """

        loadPackageArchive(file_path, extract_path=None) -> list of string

            Extracts the content of a package archive file on disk and load the
            embedded plugin resources and installation package. Package archives
            are typically used for packaging and installing plugins in Houdini.
            An exception is raised if the archive installation directory is
            read-only. The loaded package files installed from the archive are
            returned in a list.

            See the Package Browser to learn more about package archives.


            file_path
                A file path pointing to a package archive file.

            extract_path
                Optional folder path to extract the files. Defaults to the user
                folder if not provided.


        """
    @staticmethod
    def unloadPackage(package_filepath: str, force_unload: bool = False) -> None:
        """

        unloadPackage(file_path)

            Unloads the plugin resources previously loaded with
            hou.ui.loadPackage.


            file_path
                A full file path pointing to the package file to unload.


        """
    @staticmethod
    def reloadPackage(package_filepath: str) -> None:
        """

        reloadPackage(file_path)

            Update a package previously loaded. The package is first unloaded to
            uninstall the current resources and loaded back.


            file_path
                A full file path pointing to the package file to reload.


        """
    @staticmethod
    def activatePackage(package_filepath: str) -> None:
        """

        activatePackage(file_path)

            The API is typically used by the Package Browser to activate a
            loaded package previously deactivated with hou.ui.deactivatePackage.
            Activating a package will reload the package environment variables
            and resources.


            file_path
                A file path pointing to the package file to activate.


        """
    @staticmethod
    def deactivatePackage(package_filepath: str) -> None:
        """

        deactivatePackage(file_path)

            Deactivates a loaded package. Used by the Package Browser to unload
            a package while keeping the package listed in the browser tree.
            hou.ui.activatePackage can be used to activate the package again.


            file_path
                A file path pointing to the package file to deactivate.


        """
    @staticmethod
    def packageInfo(file_paths: Sequence[str]) -> str:
        """

        packageInfo(file_paths) -> string

            Return a JSON dictionary string describing one or multiple package
            plugins previously loaded in Houdini.


            file_paths
                Array of package file paths. If the array is empty (default),
                all packages currently loaded are added to the dictionary.

            This shows the content of the viewer handle demo package.

          > >>> import json
          > >>> print( json.loads(hou.ui.packageInfo()) )
          > {
          >     'viewer_handle_demo': {
          >         'File path': '$HFS/houdini/viewer_handles/viewer_handle_demo.json',
          >         'Load only once': False,
          >         'Name': 'viewer_handle_demo',
          >         'Resources': {
          >             'Shelf': [
          >                 '$HFS/packages/viewer_handle_demo/toolbar/viewer_handle_demo.shelf'],
          >             'Viewer Handle': [
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/move_tool_handle.py',
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/viewer_handle_intro1.py',
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/viewer_handle_intro2.py',
          >                 '$HFS/packages/viewer_handle_demo/viewer_handles/viewer_handle_intro3.py']
          >         },
          >         'Variables': {
          >             'HOUDINI_PATH': [
          >                 '$HFS/packages/viewer_handle_demo']
          >          }
          >     }
          > }

        """
    @staticmethod
    def sharedAssetGalleryDataSource(gallery_name: str) -> AssetGalleryDataSource:
        """

        sharedAssetGalleryDataSource(self, gallery_name) ->
        hou.AssetGalleryDataSource

            Return the hou.AssetGalleryDataSource object that is currently being
            used to populate the asset catalog browsers spcified by
            gallery_name. The built in shared galleries are 'layout' for Layout
            LOP and 'material' for Material LOP .


        """
    @staticmethod
    def setSharedAssetGalleryDataSource(data_source: AssetGalleryDataSource, gallery_name: str) -> None:
        """

        setSharedAssetGalleryDataSource(self, datasource)

            Set the hou.AssetGalleryDataSource object that should be used to
            populate the asset catalog browsers spcified by gallery_name. The
            built in shared galleries are 'layout' for Layout LOP and 'material'
            for Material LOP .


        """
    @staticmethod
    def reloadSharedAssetGalleryDataSource(gallery_name: str) -> None:
        """

        reloadSharedAssetGalleryDataSource(self)

            Forces all asset catalog browsers spcified by gallery_name to reload
            from the underlying shared hou.AssetGalleryDataSource. Call this
            method after manipulating the data source returned by
            hou.ui.sharedAssetGalleryDataSource to refresh the asset browsers.


        """
    @staticmethod
    def selectMultipleNodes(relative_to_node: Node|None = ..., initial_node: Node|None = ..., node_type_filter: EnumValue|None = ..., title: str|None = ..., width: int = ..., height: int = ..., custom_node_filter_callback: Callable[[Node], bool]|None = ...) -> Tuple[str,...]:
        """

        selectMultipleNodes(relative_to_node=None, initial_node=None,
        node_type_filter=None, title=None, width=0, height=0,
        custom_node_filter_callback=None) -> tuple of str or None

            This method is deprecated in favor of hou.ui.selectNode. Same
            behavior as selectNode however if the user holds 'Ctrl' they can
            select multiple nodes which are returned as a list of paths.


        """
    @staticmethod
    def openBookmarkEditor(bookmark: Optional[Bookmark] = None) -> None:
        """

        openBookmarkEditor(bookmark)

            Open the Houdini Bookmark Edit Dialog and return immediately.

            The bookmark parameter should be a hou.Bookmark object, returned by
            hou.anim.bookmarks() or hou.anim.bookmark().


        """
    @staticmethod
    def openColorEditor(color_changed_callback: Callable[[Color, float], None], include_alpha: bool = ..., initial_color: Color|None = ..., initial_alpha: float = ...) -> None:
        '''

        openColorEditor( color_change_callback, include_alpha=False,
        initial_color=None, initial_alpha=1.0, options=None)

            Open the Houdini color editor and return immediately.

            When a change is made in the editor then the color_change_callback
            function is invoked and passed the editor\'s current color and alpha
            value.

            If include_alpha is True then the color editor shows controls for
            editing the color\'s alpha value.

            The initial_color parameter specifies a hou.Color that will appear
            in the editor when it first opens. If not set, the initial color
            will be white.

            The initial_alpha parameter specifies an alpha value to use when the
            editor first opens. If not set, the initial alpha will be 1.0. Note
            that the initial_alpha parameter only applies if include_alpha is
            set to True.

            The color_change_callback argument must be a function that accepts
            two parameters -- a hou.Color object and an alpha value.

            The optional options dictionary argument sets the color editor
            options for the operation. The color editor options get reset when
            you start a new color selection by clicking on a color button in the
            parameter editor. See hou.ui.colorEditorOptions for documentation on
            the dictionary entries. Use hou.ui.setColorEditorOptions if you want
            to change and keep the color editor options for the duration of the
            Houdini session.

            Here is an example:

          > def handleColorChange(color, alpha):
          >     print \\"Current color in editor:\\", color, \\", alpha=\\", alpha
          > 
          > hou.ui.openColorEditor(handleColorChange)

        '''
    @staticmethod
    def openRawColorEditor(color_changed_callback: Any, include_alpha: bool = False, initial_color: Optional[Color] = None, initial_alpha: float = 1.0) -> None:
        '''

        openRawColorEditor( color_change_callback, include_alpha=False,
        initial_color=None, initial_alpha=1.0)

            Open the Houdini color editor without color correction and return
            immediately.

            When a change is made in the editor then the color_change_callback
            function is invoked and passed the editor\'s current color and alpha
            value.

            If include_alpha is True then the color editor shows controls for
            editing the color\'s alpha value.

            The initial_color parameter specifies a hou.Color that will appear
            in the editor when it first opens. If not set, the initial color
            will be white.

            The initial_alpha parameter specifies an alpha value to use when the
            editor first opens. If not set, the initial alpha will be 1.0. Note
            that the initial_alpha parameter only applies if include_alpha is
            set to True.

            The color_change_callback argument must be a function that accepts
            two parameters -- a hou.Color object and an alpha value.

            Here is an example:

          > def handleColorChange(color, alpha):
          >     print \\"Current color in editor:\\", color, \\", alpha=\\", alpha
          > 
          > hou.ui.openRawColorEditor(handleColorChange)

        '''
    @staticmethod
    def openValueLadder(initial_value: float, value_changed_callback: Callable[[float], None], type: EnumValue = ..., data_type: EnumValue = ...) -> None:
        """

        openValueLadder(initial_value, value_changed_callback,
        type=hou.valueLadderType.Generic,
        data_type=hou.valueLadderDataType.Float)

            Displays a value ladder control, the UI that typically appears when
            you press [MMB] on a field in Houdini. This lets you display ladder
            controls on your own custom UI, such as Qt edit fields.

            The typical workflow is:

             1. You should listen for [MMB] press and release events on your
                field.

             2. When the user presses [MMB] on the field, call this function to
                show the ladder. The function returns immediately but the ladder
                stays visible.

             3. As the user moves the mouse with [MMB] pressed down, you must
                call hou.ui.updateValueLadder with the mouse pointer
                coordinates.

             4. The ladder calls the value_changed_callback function you
                supplied as the user changes the value.

             5. When the user releases [MMB], call hou.ui.closeValueLadder.

            Only one value ladder window can be open at a time. This function
            raises hou.OperationFailed if another ladder window is currently
            open.


            initial_value
                The initial numeric value the ladder is set to when it opens.

            value_changed_callback
                A function that takes a single argument. As the user edits the
                number with the ladder, the ladder calls this function with each
                new value.

            type
                One of the values in hou.valueLadderType. The available types
                are Generic and Angle. This affects the increments on the
                ladder.

            data_type
                One of the values in hou.valueLadderDataType. Integer and Float
                ladders have different increments.

            This examples demonstrates how to add value ladder window support to
            an input field class that derives from Qt's QLineEdit class:

          > 
          > from PySide6 import QtWidgets
          > from PySide6.QtCore import Qt
          > import hou
          > 
          > 
          > class LineEditWithValueLadder(QtWidgets.QLineEdit):
          >     def __init__(self, parent=None):
          >         super(LineEditWithValueLadder, self).__init__(parent)
          >         self._pressed = False
          > 
          >     def mousePressEvent(self, event):
          >         # Show the value ladder window if MMB was pressed.
          >         if event.button() == Qt.MiddleButton:
          >             try:
          >                 hou.ui.openValueLadder(
          >                     float(self.text()),
          >                     self._ladderchange,
          >                     data_type=hou.valueLadderDataType.Float
          >                 )
          >             except hou.OperationFailed:
          >                 # A ladder is already open somewhere
          >                 return
          >             else:
          >                 self._pressed = True
          > 
          >     def mouseMoveEvent(self, event):
          >         if self._pressed:
          >             hou.ui.updateValueLadder(
          >                 event.globalX(),
          >                 event.globalY(),
          >                 bool(event.modifiers() & Qt.AltModifier),
          >                 bool(event.modifiers() & Qt.ShiftModifier)
          >             )
          > 
          >     def mouseReleaseEvent(self, event):
          >         if event.button() == Qt.MiddleButton and self._pressed:
          >             hou.ui.closeValueLadder()
          >             self._pressed = False
          > 
          >     def _ladderchange(self, new_value):
          >         self.setText(str(new_value))

        """
    @staticmethod
    def addEventLoopCallback(callback: Callable[[], None]) -> None:
        """

        addEventLoopCallback(callback)

            Register a Python callback to be called whenever Houdini's event
            loop is idle. This callback is called approximately every 50ms,
            unless Houdini is busy processing events.


            callback
                Any callable Python object that expects no parameters. It could
                be a Python function, a bound method, or any object implementing
                __call__.

          > def checkForAndProcessEvents():
          >     # Here is where you would check for and process any events.
          >     pass
          > 
          > hou.ui.addEventLoopCallback(checkForAndProcessEvents)

            You might use this function to integrate another user interface
            toolkit into Houdini's event loop. See the PyQt and wxPython
            cookbook examples for example usages.


        """
    @staticmethod
    def removeEventLoopCallback(callback: Callable[[], None]) -> None:
        """

        removeEventLoopCallback(callback)

            Remove a Python callback that was previously registered with
            hou.ui.addEventLoopCallback. See hou.ui.addEventLoopCallback for
            more information.

            Raises hou.OperationFailed if the callback was not previously
            registered.


        """
    @staticmethod
    def postEventCallback(callback: Callable[[], None]) -> None:
        """

        postEventCallback(callback)

            Register a Python callback to be called next in Houdini's event
            loop. This will be called only once.


            callback
                Any callable Python object that expects no parameters. It could
                be a Python function, a bound method, or any object implementing
                __call__.


        """
    @staticmethod
    def removePostedEventCallback(callback: Callable[[], None]) -> None:
        """

        removePostedEventCallback(callback)

            Remove a posted event callback from the queue if it is still there.

            If the callback is not present, nothing is done.


        """
    @staticmethod
    def eventLoopCallbacks() -> Tuple[Callable[[], None],...]:
        """

        eventLoopCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.ui.addEventLoopCallback.


        """
    @staticmethod
    def waitUntil(callback: Callable[[], bool]) -> None:
        '''

        waitUntil(condition_callback)

            Keep calling the supplied callback until it returns True. In the
            meantime, Houdini will continue to be responsive, allowing you to
            continue to interact with it.

            For example, start a blank Houdini session and put the following in
            a shelf tool. It will wait until you create an object node before
            finishing running the tool.

          > print \\"waiting until you create an object...\\"
          > hou.ui.waitUntil(lambda: len(hou.node(\\"/obj\\").children()) > 0)
          > print \\"you created\\", hou.node(\\"/obj\\").children()

            If you find that your callback function is too slow to be run
            frequently, you can try only making it do work every so often:

          > import time
          > 
          > def throttle(callback, delay=2.0):
          >     # Returns a wrapper function around `callback`, which only calls
          >     # `callback` every `delay` seconds (default 2.0), no matter
          >     # how often the wrapper function is called.
          > 
          >     # This can be useful if the condition function is expensive to run,
          >     # so you want to limit how often it is called.
          > 
          >     # Store in a list, since Python 2.x doesn\'t have full nonlocal keyword
          >     last_check = [0.0]
          > 
          >     def wrapper():
          >         now = time.time()
          >         if now < last_check[0] + delay:
          >             # Since we return False when we\'re inside the delay, Houdini
          >             # will continue to call the condition function
          >             return False
          >         else:
          >             last_check[0] = now
          >             return callback()
          > 
          >     return wrapper
          > 
          > 
          > # Then you could use this with hou.ui.waitUntil like this:
          > 
          > def my_callback():
          >     return len(hou.node(\\"/obj\\").children()) > 0
          > 
          > hou.ui.waitUntil(throttle(my_callback, delay=0.5))

        '''
    @staticmethod
    def addTriggerUpdateCallback(callback: Callable) -> None:
        """

        removeTriggerUpdateCallback(callback)

            Remove a callback previously added with the
            hou.ui.addTriggerUpdateCallback method.


        """
    @staticmethod
    def removeTriggerUpdateCallback(callback: Callable) -> None: ...
    @staticmethod
    def addSelectionCallback(callback: Callable[[Sequence[NetworkMovableItem]], None]) -> None:
        """

        addSelectionCallback(callback)

            Register a Python callback to be called whenever Houdini's global
            network item selection changes.


            callback
                Any callable Python object that expects a single parameter. This
                parameter will be a list of all selection hou.NetworkMovableItem
                objects that are now selected. It could be a Python function, a
                bound method, or any object implementing __call__.

          > def selectionCallback(selection):
          >     # Here is where you would respond to the selection change.
          >     pass
          > hou.ui.addSelectionCallback(selectionCallback)

        """
    @staticmethod
    def removeSelectionCallback(callback: Callable[[Sequence[NetworkMovableItem]], None]) -> None:
        """

        removeSelectionCallback(callback)

            Remove a Python callback that was previously registered with
            hou.ui.addSelectionCallback. See hou.ui.addSelectionCallback for
            more information.


        """
    @staticmethod
    def selectionCallbacks() -> Tuple[Callable[[Sequence[NetworkMovableItem]], None],...]:
        """

        selectionCallbacks() -> tuple of callback

            Return a tuple of all the Python callbacks that have been registered
            with hou.ui.addSelectionCallback.


        """
    @staticmethod
    def addResourceEventCallback(callback: Callable[[EnumValue, Any, str], None]) -> None:
        """

        addResourceEventCallback(self, callback)

            Register a Python callback to be called whenever a
            hou.resourceEventMessage event occurs.


            'callback'
                Any callable Python object that expects a keyworded argument.

                The keyworded argument contains the following:

              * event_type: hou.resourceEventMessage event.

              * resource_type: A resource type such as ViewerState and
                ViewerHandle.

              * type_name: The type name of the resource that triggered the
                event. If the resource is a ViewerState, the type name can be
                used for indexing the dictionary returned from
                hou.ui.viewerStateInfo.


        """
    @staticmethod
    def removeResourceEventCallback(callback: Callable[[EnumValue, Any, str], None]) -> None:
        """

        removeResourceEventCallback(self,callback)

            Remove a specific Python callback previously registered with
            hou.ui.addResourceEventCallback.


        """
    @staticmethod
    def openFileEditor(title: str, file_path: str, action_callback: Callable[[Mapping[str, int|float|bool|str]], None]|None = ..., params: Mapping[str, int|float|bool|str]|None = ...) -> None:
        """

        openFileEditor(title, file_path, action_callback=None, params=None)

            Open a window for editing and saving a text file.

            The editor buttons:

          * Apply: Save the file only if the source has changed.

          * Accept: Save the file if the source has changed and close the
            window.

          * Cancel: Close the window without saving the file and prompting the
            user.


            NOTE
                When applying unsaved changes, the editor prompts the user if
                the file being edited is not in sync with the file on disk. At
                this point the user is asked to load the new file (overriding
                its current changes) or save its current changes (overriding the
                file on disk) or cancel the operation.

            An optional callback and a dictionary of user-defined parameters can
            be specified to customize the Apply and Accept operations.


            title
                Name of the window title.

            file_path
                A string set with a full path to the file to edit. Exception is
                raised if the string is empty.

                The file extension determines the language settings used by the
                editor. The following file types are supported:

                .py

                Python

                .cmd

                hscript

                .txt/no extension

                Text document

            action_callback
                An optional callback triggered by the editor when either the
                Apply or Accept button is clicked. The callback can be used to
                perform a custom operation. The editor saves the file being
                edited, if required, before calling the callback.

                The callback name is user-defined and takes a dictionary
                argument as input:

              > def myApplyAction( **kwargs )

            params
                A dictionary mapping user-defined entries to values of type int,
                double, bool and string. The dictionary is passed as argument to
                the callback specified with action_callback.

            Example:

          > 
          > def myAction(**kwargs):
          >     hou.ui.printResourceMessage(kwargs['msg'] + ' saved.', kwargs['msg_type'])
          > 
          > file_path = '/var/tmp/main.py'
          > hou.ui.openFileEditor( 'My Editor Title', file_path, action_callback=myAction, 
          >     params={ 'msg' : file_path, 'msg_type' : hou.severityType.Message })

        """
    @staticmethod
    def openViewerStateCodeGenDialog(category: NodeTypeCategory, action_callback: Callable[[Mapping[str, int|float|bool|str]], None], operator_name: str|None = ...) -> None:
        """

        openViewerStateCodeGenDialog(category, action_callback,
        operator_name=None)

            Open a modal dialog window for generating a template implementation
            and registration code for a python viewer state. The input name of
            the viewer state is mandatory for generating the code. Other fields
            such as the state label and icon name are optional.

            The dialog Sample options can be selected to generate the viewer
            state code with predefined handlers and bindings. The Handler
            options can also be selected to generate the viewer state code with
            empty handlers.

            The dialog buttons:

          * Accept: Generate the code template with the input fields and
            selected options.

          * Cancel: Close the dialog and abort the code template generation.

            This dialog is used by the Viewer State Browser panel and the
            Digital Asset Viewer State editor.


            category
                A hou.NodeTypeCategory object to specify the type of viewer
                state to register.

            action_callback
                A mandatory callback required for handling the result when the
                Accept button is clicked.

                The callback name is user-defined and takes a dictionary
                argument as input:

              > def myAcceptAction( **kwargs )

                The kwargs dictionary contains the results of the code
                generation:

              * valid: Returns True if the operation succeeded, False otherwise.

              * state_type: The name of the new state.

              * state_type_expr: Expression representing the name of the new
                state: either a python

                    function call to get the HDA node's default state or a
                    string literal.

              * state_label: The state label.

              * state_description: The state description which is only displayed
                in the code header.

              * state_category: The name of the state category type.

              * state_code: The generated python code.

              * state_icon_name: The name of the icon selected. The name can be
                either a single icon name, a

                    file path or an opdef path to refer to an icon embedded in a
                    Digital Asset.

              * state_icon_filename: The icon file path if any.

              * state_icon_section_name: The section name of the icon used by
                the Digital Asset viewer state editor.

            operator_name
                The name of the operator if the viewer state to generate is
                embedded in a Digital Asset. This argument is optional and
                mostly used by the Digital Asset viewer state editor.


        """
    @staticmethod
    def openViewerHandleCodeGenDialog(category: NodeTypeCategory, action_callback: Callable[[Mapping[str, str|bool]], None]) -> None:
        """

        openViewerHandleCodeGenDialog(categories, action_callback)

            Open a modal dialog window for generating a template implementation
            and registration code for a python viewer handle. The input name of
            the viewer handle is mandatory for generating the code. Other fields
            such as the handle label and icon name are optional.

            The dialog Sample options can be selected to generate the viewer
            handle code with predefined handlers and bindings. The Handler
            options can also be selected to generate the viewer handle code with
            empty handlers.

            The dialog buttons:

          * Accept: Generate the code template with the input fields and
            selected options.

          * Cancel: Close the dialog and abort the code template generation.

            This dialog is available from Viewer Handle Browser panel under the
            File|New... menu.


            category
                A hou.NodeTypeCategory object to specify the type of viewer
                handle to register.

            action_callback
                A mandatory callback required for handling the result when the
                Accept button is clicked.

                The callback name is user-defined and takes a dictionary
                argument as input:

              > def myAcceptAction( **kwargs )

                The kwargs dictionary contains the results of the code
                generation:

              * handle_valid: Returns True if the operation succeeded, False
                otherwise.

              * handle_type: The type name of the new handle.

              * handle_type_expr: Expression representing the name of the new
                handle.

              * handle_label: The handle label.

              * handle_description: The handle description which is only
                displayed in the code header.

              * handle_category: The name of the handle category type.

              * handle_code: The generated python code.

              * handle_icon_name: The name of the icon selected. The name can be
                either a single icon name or a file path.

              * handle_icon_filename: The icon file path if any.


        """

    # Missing methods added by stubgen
    @staticmethod
    def selectFile(start_directory: str | None = None, title: str | None = None, collapse_sequences: bool = False, file_type: EnumValue = fileType.Any, pattern: str | None = None, default_value: str | None = None, multiple_select: bool = False, image_chooser: bool = False, chooser_mode: EnumValue = fileChooserMode.ReadAndWrite, width: int = 0, height: int = 0) -> str: ...
    @staticmethod
    def selectNode(relative_to_node: Node | None = None, initial_node: Node | None = None, node_type_filter: EnumValue | None = None, title: str | None = None, width: int = 0, height: int = 0, multiple_select: bool = False, custom_node_filter_callback: Callable[[Node], bool] | None = None) -> str | Tuple[str, ...] | None: ...
    @staticmethod
    def openTypePropertiesDialog(node_or_node_type: OpNode | OpNodeType, promote_spare_parms: bool=False, immediately_save: bool=False) -> None: ...

class UIEvent:
    """

    hou.UIEvent

    Represents a user interface event, such as a mouse press. You can access
    this object in an event handler to respond to user input.

    hou.UIEvent provides information to interact with user input and is used
    with Python states. You do not instantiate this type of object yourself.

    RELATED

        hou.ViewerEvent hou.CompositorViewerEvent


    """
    thisown: Incomplete
    def __init__(self, val: int, val2: int) -> None:
        """

        hou.UIEvent

        Represents a user interface event, such as a mouse press. You can access
        this object in an event handler to respond to user input.

        hou.UIEvent provides information to interact with user input and is used
        with Python states. You do not instantiate this type of object yourself.

        RELATED

            hou.ViewerEvent hou.CompositorViewerEvent


        """
    __swig_destroy__: Incomplete
    def device(self) -> Optional[UIEventDevice]:
        """

        device(self) -> hou.UIEventDevice

            Returns an object containing input-device-specific event data. For
            example, if this is a mouse click event, you can use
            event.device().mouseX() to get the X coordinate in screen space, and
            event.device().isLeftButton() to check whether the left mouse button
            was pressed.

          > if ui_event.device().isLeftButton():
          >     ...

        """
    def hasQueuedEvents(self) -> bool:
        """

        hasQueuedEvents(self) -> bool

            Returns true if this event contains queued device events.


        """
    def queuedEvents(self) -> Tuple[UIEventDevice, ...]:
        """

        queuedEvents(self) -> list of hou.UIEventDevice

            If hou.UIEvent.hasQueuedEvents returns True, this method returns the
            list of queued input device events.


        """
    def value(self) -> Any:
        """

        value(self) -> obj

            Returns the value payload of this event. You can tell the type of
            this value by calling hou.UIEvent.valueType.


        """
    def reason(self) -> EnumValue:
        """

        reason(self) -> hou.uiEventReason

            For events related to state changes, returns an enum value
            representing the type of state change that triggered the event.


        """
    def valueType(self) -> EnumValue: ...

class UIEventDevice:
    """

    hou.UIEventDevice

    Object containing methods for testing input-device-specific information
    on a UI event, such as which mouse button was pressed.

    Do not instantiate this object yourself. You can get a UIEventDevice
    object from a hou.UIEvent using hou.UIEvent.device. For more information
    see Python state UI events.


    """
    thisown: Incomplete
    def __init__(self, val: int, val2: int, val3: int) -> None:
        """

        hou.UIEventDevice

        Object containing methods for testing input-device-specific information
        on a UI event, such as which mouse button was pressed.

        Do not instantiate this object yourself. You can get a UIEventDevice
        object from a hou.UIEvent using hou.UIEvent.device. For more information
        see Python state UI events.


        """
    __swig_destroy__: Incomplete
    def isAltKey(self) -> bool:
        """

        isAltKey(self) -> bool

            Returns True if an Alt/Option key was pressed.


        """
    def isAutoRepeat(self) -> bool:
        """

        isAutoRepeat(self) -> bool

            Returns True if the held key was auto-repeating.


        """
    def isCapsLock(self) -> bool:
        """

        isCapsLock(self) -> bool

            Returns True if the Caps Lock key was pressed.


        """
    def isCtrlKey(self) -> bool:
        """

        isCtrlKey(self) -> bool

            Returns True if the Control key was pressed.


        """
    def isKeyPad(self) -> bool:
        """

        isKeyPad(self) -> bool

            Returns True if the pressed key was on the number pad.


        """
    def isShiftKey(self) -> bool:
        """

        isShiftKey(self) -> bool

            Returns True if the a Shift key was pressed.


        """
    def isArrowDown(self) -> bool:
        """

        isArrowDown(self) -> bool

            Returns True if the Down arrow key was pressed.


        """
    def isArrowLeft(self) -> bool:
        """

        isArrowLeft(self) -> bool

            Returns True if the Left arrow key was pressed.


        """
    def isArrowRight(self) -> bool:
        """

        isArrowRight(self) -> bool

            Returns True if the Right arrow key was pressed.


        """
    def isArrowUp(self) -> bool:
        """

        isArrowUp(self) -> bool

            Returns True if the Up arrow key was pressed.


        """
    def isKeyPressed(self) -> bool:
        """

        isKeyPressed(self) -> bool

            Returns True if any key was pressed.


        """
    def isFunctionKey(self) -> bool:
        """

        isFunctionKey(self) -> bool

            Returns True if a function key was pressed.


        """
    def keyValue(self) -> int:
        """

        keyValue(self) -> int

            Returns the ascii code for the key being pressed. If modifiers, such
            as shift and ctrl, are pressed with a key, keyValue returns only the
            ascii code of the key, unlike hou.UIEvent.value which returns the
            encoded value of the keys combination.


        """
    def keyString(self) -> str:
        """

        keyString(self) -> string

            Returns the string representation of the key being pressed. The
            return value can also contain modifier symbols, joined with the plus
            character.

            Few examples:

            a

            a

            <carriage return>

            Enter

            <tab space>

            Tab

            <back space>

            Backspace

            <esc>

            Esc

            <Ctrl Space>

            Ctrl+Space

            <Shift a>

            Shift+a

            <Ctrl Shift a>

            Ctrl+Shift+a

            <Alt Ctrl a>

            Alt+Ctrl+a


        """
    def modifierString(self) -> str:
        """

        modifierString(self) -> string

            Returns the string representation of the modifier keys being
            pressed.

            The return value contains only modifier symbols. The key pressed, if
            not itself a modifier, is ignored.

            Few examples:

            <Shift>

            shift

            <Ctrl Shift>

            Ctrl+Shift

            <Alt Shift>

            Alt+Shift


        """
    def isKeyUp(self) -> bool:
        """

        isKeyUp(self) -> bool

            Returns True if a pressed key was released. This method is used to
            detect a key up transition with a Python state's onKeyTransitEvent
            method.


        """
    def isKeyDown(self) -> bool:
        """

        isKeyDown(self) -> bool

            Returns True if a key was pressed. This method is used to detect a
            key down transition with a with a Python state's onKeyTransitEvent
            method.


        """
    def isLeftButton(self) -> bool:
        """

        isLeftButton(self) -> bool

            Returns True if the [LMB] left mouse button was pressed.


        """
    def isMiddleButton(self) -> bool:
        """

        isMiddleButton(self) -> bool

            Returns True if the [MMB] middle mouse button was pressed.


        """
    def isRightButton(self) -> bool:
        """

        isRightButton(self) -> bool

            Returns True if the [RMB] right mouse button was pressed.


        """
    def isLeftButtonReleased(self) -> bool:
        """

        isLeftButtonReleased(self) -> bool

            Returns True if the [LMB] left mouse button was released.


        """
    def isMiddleButtonReleased(self) -> bool:
        """

        isMiddleButtonReleased(self) -> bool

            Returns True if the [MMB] middle mouse button was released.


        """
    def isRightButtonReleased(self) -> bool:
        """

        isRightButtonReleased(self) -> bool

            Returns True if the [RMB] right mouse button was released.


            NOTE
                The method returns False if a custom menu is defined by the
                python state even if the button was released.


        """
    def mouseWheel(self) -> float:
        """

        mouseWheel(self) -> int

            The result is negative if the wheel was rotated up and positive if
            it was rotated down.

            Different mice will produce different outputs:

          * Mice with clicky wheels will generally output a -1 or +1 event for
            each click (at least that is the intention).

          * Mice with free spinning wheels, or touch sensitive surfaces (such as
            the Apple Magic Mouse), will produce a wider range of values.
            Small/slow scrolling might trigger a mouse wheel event but this
            method returns 0, whereas big/fast scrolling can produce higher
            numbers for each event, up to around 7, with the numbers increasing
            as the user throws the wheel and decreasing as it slows.


        """
    def mouseX(self) -> float:
        """

        mouseX(self) -> int

            Returns the horizontal mouse position in screen coordinates,
            counting from the left edge of the view. The position is relative to
            the view, not relative to the viewport under the mouse.


        """
    def mouseY(self) -> float:
        """

        mouseY(self) -> int

            Returns the vertical mouse position in screen coordinates, counting
            from the bottom edge of the view. The position is relative to the
            view, not relative to the viewport under the mouse.


        """
    def isTablet(self) -> bool:
        """

        isTablet(self) -> bool

            Returns False, even if the event was generated by a tablet stylus.
            Future versions may be able to distinguish tablet and non-tablet
            events.


        """
    def tabletAngle(self) -> float:
        """

        tabletAngle(self) -> double

            Returns tablet stylus angle value.


        """
    def tabletPressure(self) -> float:
        """

        tabletPressure(self) -> double

            Returns the tablet pressure value.


        """
    def tabletRoll(self) -> float:
        """

        tabletRoll(self) -> double

            Returns the tablet stylus roll value.


        """
    def tabletTilt(self) -> float:
        """

        tabletTilt(self) -> double

            Returns the tablet stylus tilt value.


        """
    def time(self) -> float:
        """

        time(self): -> double

            Returns the time in seconds relative to the event.


        """

class undos:
    """

    hou.undos

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def areEnabled() -> bool:
        """

        areEnabled() -> bool

            Returns True is undos are currently enabled.


        """
    @staticmethod
    def disabler() -> UndosDisabler:
        '''

        disabler() -> hou.UndosDisabler

            Returns a context manager, within which changes to Houdini will not
            be added to the undo stack.

            For example:

          > with hou.undos.disabler():
          >     # Move all object nodes 1 unit to the left.
          >     # This cannot be undone!
          >     for n in hou.node(\\"/obj\\").children():
          >         n.move(hou.Vector2(-1, 0))

        '''
    @staticmethod
    def group(label: str, editor: Optional[NetworkEditor] = None) -> UndosGroup:
        '''

        group(label, editor=None) -> hou.UndosGroup

            Returns a context manager, within which all changes to Houdini are
            recorded as a single action on the undo stack.

            For example:

          > with hou.undos.group(\\"Move all nodes to the left\\"):
          >     # Move all object nodes 1 unit to the left.
          >     # This is 
          >     for n in hou.node(\\"/obj\\").children():
          >         n.move(hou.Vector2(-1, 0))

            This has no effect when run inside parameter callback scripts
            because they are already executed within an undo group.

            The optional editor argument is a hou.NetworkEditor object should be
            used when the undo group is being created as part of executing an
            action inside a Network View pane that might contain APEX Nodes.
            This ensures that edits to the APEX graph are only saved to the
            current SOP when all operations inside the undo group have been
            completed.


        '''
    @staticmethod
    def removeUndos(tag: str) -> None:
        '''

        removeUndos(tag)

            Invalidates and removes all undo and redo events that are tagged
            with tag.

          > # Removes all undos with the tag \\"myTag\\"
          > hou.undos.removeUndos(\\"myTag\\")

        '''
    @staticmethod
    def clear() -> None:
        """

        clear()

            Clear all undo and redo information.


        """
    @staticmethod
    def memoryUsage() -> int:
        """

        memoryUsage() -> int

            The current memory used (in bytes) for undos.


        """
    @staticmethod
    def memoryUsageLimit() -> int:
        """

        memoryUsageLimit() -> int

            The maximum allowed memory usage size (in bytes) for undos.


        """
    @staticmethod
    def performUndo() -> bool:
        """

        performUndo()

            Undo the last action.


        """
    @staticmethod
    def performRedo() -> bool:
        """

        performRedo()

            Redo the last undoed action.


        """
    @staticmethod
    def undoLabels() -> Tuple[str, ...]:
        """

        undoLabels() -> tuple of str

            Provides a tuple of the undo operations currently on the stack. Note
            that the first item (ie. undoLabels()) is the next operation that
            will be undone.


        """
    @staticmethod
    def redoLabels() -> Tuple[str, ...]:
        """

        redoLabels() -> tuple of str

            Provides a tuple of the redo operations currently on the stack. Note
            that the first item (ie. redoLabels()) is the next operation that
            will be redone.


        """
    @staticmethod
    def add(undo: Any, label: str, tag: Optional[str] = None) -> None:
        '''

        add(undo, label, tag=None)

            Add an undo operation to the undo history. undo must be an object
            with undo() and redo() methods. The undo() method is executed when
            the operation is undone and the redo() method is executed when the
            operation is redone.

            label is a description of the undo operation as it appears in the
            undo history.

            A hou.OperationFailed is raised if the undo object passed in does
            not have an undo() method or a redo() method.

            For example, a valid python object passed to this function would
            look like:

          > class MyUndoClass():
          > 
          >     def __init__(self):
          >         # ... Initialization ...
          >         pass
          > 
          >     def undo(self):
          >         # Add in what needs to be done on undo
          >         pass
          > 
          >     def redo(self):
          >         # Add in what needs to be done on redo
          >         pass

            Using the above class, a call to this function would look like:

          > foo = MyUndoClass()
          > hou.undos.add(foo, \\"My Undo\\")

            An optional string tag can also be set for this undo object, which
            will allow it to be removed from the undo stack using
            hou.undos.removeUndos.

          > foo = MyUndoClass()
          > hou.undos.add(foo, \\"My Undo\\", \\"myTag\\")

        '''

class UndosDisabler:
    """

    hou.UndosDisabler

    Use this class to disable undos within a Python code block.

    This object cannot be instantiated directly. See hou.undos.disabler.

    This object is a context manager. You can create one using
    hou.undos.disabler. Changes inside the with block will not add actions
    to the undo stack.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __enter__(self) -> UndosDisabler: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class UndosGroup:
    """

    hou.UndosGroup

    Used to group all undos within a Python code block into a single action.

    This object is a context manager. You can create one using
    hou.undos.group. Changes inside the with block appear as a single action
    in the undo stack.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def label(self) -> str:
        """

        label(self)

            Returns the group label.


        """
    def __enter__(self) -> UndosGroup: ...
    def __exit__(self, type: type[BaseException], value: BaseException, traceback: TracebackType) -> None: ...

class VDB(Prim):
    """

    hou.VDB

    A VDB is a kind geometry primitive (Prim object) that stores data in a
    three dimensional grid of voxels.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def sample(self, position: Sequence[float]) -> float:
        """

        sample(self, position) -> float

            Given a sequence of three floats containing a 3D position, return
            the value of the volume at that position. If the position is not in
            the middle of a voxel, Houdini will interpolate using values from
            surrounding voxels.

            See also hou.VDB.voxel and hou.VDB.posToIndex.


        """
    def samplev(self, position: Sequence[float]) -> Vector3:
        """

        samplev(self, position) -> hou.Vector3

            Given a sequence of three floats containing a 3D position, return
            the value of the vector valued volume at that position. If the
            position is not in the middle of a voxel, Houdini will interpolate
            using values from surrounding voxels.

            See also hou.VDB.voxel and hou.VDB.posToIndex.


        """
    def gradient(self, position: Sequence[float]) -> Vector3:
        """

        gradient(self, position) -> hou.Vector3

            Given a sequence of three floats containing a 3D position, return a
            vector which points in the direction of the greatest rate of
            increase of the volume's value.

            See Wikipedia's gradient page for more information.


        """
    def voxel(self, index: Sequence[int]) -> float:
        """

        voxel(self, index) -> float

            Given a sequence of three integers containing a voxel index, return
            the value of the corresponding voxel.


        """
    def resolution(self) -> Tuple[int, ...]:
        """

        resolution(self) -> hou.Vector3

            Return the x, y, and z dimensions of hou.VDB.activeVoxelBoundingBox.
            Since VDB volumes are sparse, this represents the virtual resolution
            of all the voxels which have data (or are active).


        """
    def indexToPos(self, index: Sequence[int]) -> Vector3:
        """

        indexToPos(self, index) -> hou.Vector3

            Given a sequence of three ints containing an index into the voxel
            array, return the corresponding 3D position of the middle of that
            voxel.


        """
    def posToIndex(self, position: Sequence[float]) -> Tuple[int, ...]:
        """

        posToIndex(self, position) -> tuple of int

            Given a sequence of three floats containing a 3D position, return a
            tuple of three ints containing the corresponding index into the
            voxel array.


        """
    def isSDF(self) -> bool:
        """

        isSDF(self) -> bool

            Return whether or not the volume should be semantically treated as a
            signed distance field. If true, the volume can be thought of as
            representing a closed surface, where the negative voxel values are
            inside, the positive voxel values are outside, and voxels on the
            surface are zero.

            For VDB volumes, there is typically only a 3 voxel radius around the
            surface where there exists data.


        """
    def isHeightField(self) -> bool:
        """

        isHeightField(self) -> bool

            Return whether or not the volume is flagged as a heightfield. While
            VDBs are never heightfields, this allows for volumes and VDBs to be
            treated interchangeably.


        """
    def volumeMax(self) -> float:
        """

        volumeMax(self) -> float

            Return the maximum value of all active voxels.


        """
    def volumeMin(self) -> float:
        """

        volumeMin(self) -> float

            Return the minimum value of all active voxels.


        """
    def volumeAverage(self) -> float:
        """

        volumeAverage(self) -> float

            Return the average value of all active voxels.


        """
    def transform(self) -> Matrix3:
        """

        transform(self) -> hou.Matrix3

            Return a 3x3 matrix containing the scale and rotation
            transformations for this volume.

            Note that the position information for the volume can be obtained by
            calling volume.vertex(0).point().position().

            The following function returns a 4x4 transformation matrix for the
            volume that includes the translation:

          > def fullTransform(volume):
          >     return (hou.Matrix4(volume.transform()) *
          >         hou.hmath.buildTranslate(volume.vertex(0).point().position()))

            NOTE
                You need to get the object node's transform to get to
                worldspace.


        """
    def taper(self) -> float:
        """

        taper(self) -> int

            Returns the taper value of the volume's transform. For untapered
            transforms, this value will be 1.


        """
    def vertex(self, index: int) -> Vertex:
        """

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
    def isEmpty(self) -> bool:
        """

        isEmpty(self) -> bool

            Returns whether the VDB volume has no data.


        """
    def activeVoxelCount(self) -> int:
        """

        activeVoxelCount(self) -> int

            Returns the number of active voxels in the volume.


        """
    def activeVoxelBoundingBox(self) -> BoundingBox:
        """

        activeVoxelBoundingBox(self) -> hou.BoundingBox

            Returns the smallest exclusive bounding box within the VDB volume
            that has active voxels.


        """
    def voxelSize(self) -> Vector3:
        """

        voxelSize(self) -> hou.Vector3

            Returns the size of voxels within the VDB volume. All voxels will be
            of this size for untapered volumes. For tapered volumes, this size
            represents the size of voxel at the origin of the frustum.


        """
    def dataType(self) -> EnumValue:
        """

        dataType(self) -> hou.vdbData

            Returns the voxel data type within the VDB volume.


        """
    def vdbType(self) -> EnumValue:
        """

        vdbType(self) -> hou.EnumValue

            Returns the vdb's vdb type, which consists of its precision, float
            vs integer, and vector size.


        """
    def visualization(self) -> EnumValue:
        """

        visualization(self) -> hou.volumeVisualization enum value

            Returns the vdb's visualization mode. This is used by the viewport
            to determine how display the vdb.


        """
    def voxelRangeAsBool(self, range: BoundingBox) -> Tuple[bool, ...]: ...
    def voxelRangeAsFloat(self, range: BoundingBox) -> Tuple[float, ...]: ...
    def voxelRangeAsInt(self, range: BoundingBox) -> Tuple[int, ...]: ...
    def voxelRangeAsVector3(self, range: BoundingBox) -> Tuple[Vector3, ...]: ...
    def voxelRange(self, range: BoundingBox) -> Tuple[bool, ...] | Tuple[int, ...] | Tuple[float, ...] | Tuple[Vector3, ...]:
        """

        voxelRangeAsVector3(self, range) -> tuple of hou.Vector3

            Return a tuple containing the values of all voxels withing a
            bounding box range. It is faster to call this method to retrieve all
            the voxels than it is to loop through the voxel array in Python.

            See help for hou.VDB.voxelRange for implementation details.


        """

class Vector2:
    """

    hou.Vector2

    A sequence of 2 floating point values, with associated mathematical
    operations.

    A Vector2 might be used to represent a position in 2D space, a 2D
    direction and length, or the size of a rectangle. For example,
    hou.Node.position returns a position and hou.Node.size returns the size
    of a rectangle.

    See also hou.Vector3 and hou.Vector4.


    """
    thisown: Incomplete
    def __init__(self, x: Sequence[float]|'Vector2'|float = ..., y: float = ...) -> None:
        """

        __init__(self, values=(0.0, 0.0))

            Return a new Vector2 from a sequence of floats. If this method is
            called without parameters, the resulting vector contains the values
            (0.0, 0.0).

            Raises InvalidSize if values is not 2 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, vector2: Vector2, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, vector2, tolerance=0.00001) -> bool

            Return whether this vector is equal to another, within a tolerance.
            Verifies that the difference between each component of this vector
            and the corresponding component of the other vector is within the
            tolerance.


        """
    def almostEqual(self, vector2: Vector2, tolerance: float = 1e-05) -> bool:
        """

        almostEqual(self, vector2, tolerance=0.00001) -> bool

            Deprecated. Use Vector2.isAlmostEqual instead.


        """
    def __hash__(self) -> int: ...
    def __getitem__(self, index: int) -> float:
        """

        __getitem__(self, index) -> float

            Return the float component at the specified index. This method makes
            vectors behave as sequences (so you can, for example, use a for loop
            on the elements of a vector, convert a vector to a tuple of floats,
            etc.) and lets you use square brackets to index into a vector.

          > >>> v = hou.Vector2((1.0, 2.0))
          > >>> v[-1]
          > 2.0

        """
    def __setitem__(self, index: int, value: float) -> None:
        """

        __setitem__(self, index, value)

            This method lets you use square brackets to set a value on a vector.

          > >>> v = hou.Vector2((1.5, 2.5))
          > >>> v[0] = 0.5
          > >>> print v
          > [0.5, 2.5]

        """
    def __len__(self) -> int:
        """

        __len__(self) -> int

            Returns 2. This method lets you call len() on a Vector2.


        """
    def setTo(self, sequence: Sequence[float]) -> None:
        """

        setTo(self, sequence)

            Set the contents of this vector to a sequence of floats.

            Raises InvalidSize if values is not 2 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
    def __add__(self, vector2: Vector2) -> Vector2:
        """

        __add__(self, vector2) -> hou.Vector2

            Add two vectors, returning a new vector with each component equal to
            the sum of the corresponding components in the two vectors. This
            method lets you write v1 + v2, where v1 and v2 are Vector2 objects.

            This method is equivalent to hou.Vector2(self[0] + vector2[0],
            self[1] + vector2[1]).


        """
    def __sub__(self, vector2: Vector2) -> Vector2:
        """

        __sub__(self, vector2) -> hou.Vector2

            Subtract a vector from another, returning a new vector with each
            component equal to the first vector's corresponding component minus
            the second vector's. This method lets you write v1 - v2, where v1
            and v2 are Vector2 objects.

            This method is equivalent to hou.Vector2(self[0] - vector2[0],
            self[1] - vector2[1]).


        """
    def __neg__(self) -> Vector2:
        """

        __neg__(self) -> hou.Vector2

            Return a vector whose components contain the negative values of this
            vector's components. This method lets you write -v, where v is a
            Vector2 object.

            This method is equivalent to hou.Vector2(-self[0], -self[1]).


        """
    def __rmul__(self, scalar: float) -> Vector2:
        """

        __rmul__(self, scalar) -> hou.Vector2

            Multiply a vector with a float scalar, returning a new vector. This
            method lets you write s * v where v is a vector and s is a float.

            This method is equivalent to hou.Vector2(self[0] * scalar, self[1] *
            scalar).


        """
    def __mul__(self, scalar_or_matrix2: float|Matrix2) -> Vector2:
        """

        __mul__(self, scalar_or_matrix2) -> hou.Vector2

            Multiply a vector with a float scalar or with a hou.Matrix2,
            returning a new vector. This method lets you write v * s where v is
            a vector and s is a float, or v * m where v is a vector and m is a
            hou.Matrix2.

            This method is equivalent to hou.Vector2(self[0] * scalar, self[1] *
            scalar).


        """
    def __div__(self, scalar: float) -> Vector2:
        """

        __div__(self, scalar) -> hou.Vector2

            Divide a vector by a float scalar, returning a new vector. This
            method lets you write v / s where v is a vector and s is a float.

            This method is equivalent to hou.Vector2(self[0] / scalar, self[1] /
            scalar).


        """
    def __truediv__(self, scalar: float) -> Vector2: ...
    def normalized(self) -> Vector2:
        """

        normalized(self) -> hou.Vector2

            Interpreting this vector as a direction, return a vector with the
            same direction but with a length of 1.

            If the vector's length is 0 (or close to it), the result is the
            original vector.

            For vector's with non-zero lengths, this method is equivalent to
            self * (1.0/self.length()).


        """
    def length(self) -> float:
        """

        length(self) -> float

            Interpret this vector as a direction vector and return its length.
            The result is the same as math.sqrt(self[0]**2 + self[1]**2).


        """
    def lengthSquared(self) -> float:
        """

        lengthSquared(self) -> float

            Interpret this vector as a direction vector and return the square of
            its length. The result is the same as self[0]**2 + self[1]**2.


        """
    def distanceTo(self, vector2: Vector2) -> float:
        """

        distanceTo(self, vector2) -> float

            Interpret this vector and the argument as 2D positions, and return
            the distance between them. The return value is equivalent to (self -
            vector2).length().


        """
    def dot(self, vector2: Vector2) -> float:
        """

        dot(self, vector2) -> float

            Return the dot product between this vector and the one in the
            parameter.

            See Wikipedia's dot product page.


        """
    def x(self) -> float:
        """

        x(self) -> float

            Return the first component of the vector. Equivalent to v.


        """
    def y(self) -> float:
        """

        y(self) -> float

            Return the second component of the vector. Equivalent to v.


        """

    # Missing methods added by stubgen
    def __contains__(self, other: float) -> bool: ...
    def __iter__(self) -> Iterator[float]: ...
    def __reversed__(self) -> Iterator[float]: ...

class Vector3:
    """

    hou.Vector3

    A sequence of 3 floating point values, with associated mathematical
    operations.

    A Vector3 might be used to represent a position in 3D space, or a 3D
    direction with a length.

    See also hou.Vector2 and hou.Vector4.


    """
    thisown: Incomplete
    def __init__(self, x: Sequence[float]|'Vector3'|float = ..., y: float = ..., z: float = ...) -> None:
        """

        __init__(self, values=(0.0, 0.0, 0.0))

            Return a new Vector3 from a sequence of floats. If this method is
            called without parameters, the resulting vector contains the values
            (0.0, 0.0, 0.0).

            You can also construct a Vector3 from a hou.Vector4. The result
            contains the first 3 values in the Vector4.

            Raises InvalidSize if values is not 3 elements long, or TypeError if
            values is not a sequence of floats.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, vector3: Vector3, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, vector3, tolerance=0.00001) -> bool

            Return whether this vector is equal to another, within a tolerance.
            Verifies that the difference between each component of this vector
            and the corresponding component of the other vector is within the
            tolerance.


        """
    def almostEqual(self, vector3: Vector3, tolerance: float = 1e-05) -> bool:
        """

        almostEqual(self, vector3, tolerance=0.00001) -> bool

            Deprecated. Use Vector3.isAlmostEqual instead.


        """
    def __hash__(self) -> int: ...
    def __getitem__(self, index: int) -> float:
        """

        __getitem__(self, index) -> float

            Return the float component at the specified index. This method makes
            vectors behave as sequences (so you can, for example, use a for loop
            on the elements of a vector, convert a vector to a tuple of floats,
            etc.) and lets you use square brackets to index into a vector.

          > >>> v = hou.Vector3((1.0, 2.0, 3.0))
          > >>> v[-1]
          > 3.0

        """
    def __setitem__(self, index: int, value: float) -> None:
        """

        __setitem__(self, index, value)

            This method lets you use square brackets to set a value on a vector.

          > >>> v = hou.Vector3((1.5, 2.5, 3.5))
          > >>> v[1] = 0.5
          > >>> print v
          > [1.5, 0.5, 3.5]

        """
    def __len__(self) -> int:
        """

        __len__(self) -> int

            Returns 3. This method lets you call len() on a Vector3.


        """
    def setTo(self, sequence: Sequence[float]) -> None:
        """

        setTo(self, sequence)

            Set the contents of this vector to a sequence of floats.

            Raises InvalidSize if values is not 3 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
    def __add__(self, vector3: Vector3) -> Vector3:
        """

        __add__(self, vector3) -> hou.Vector3

            Add two vectors, returning a new vector with each component equal to
            the sum of the corresponding components in the two vectors. This
            method lets you write v1 + v2, where v1 and v2 are Vector3 objects.

            This method is equivalent to hou.Vector3(self[0] + vector3[0],
            self[1] + vector3[1], self[2] + vector3[2]).


        """
    def __sub__(self, vector3: Vector3) -> Vector3:
        """

        __sub__(self, vector3) -> hou.Vector3

            Subtract a vector from another, returning a new vector with each
            component equal to the first vector's corresponding component minus
            the second vector's. This method lets you write v1 - v2, where v1
            and v2 are Vector3 objects.

            This method is equivalent to hou.Vector3(self[0] - vector3[0],
            self[1] - vector3[1], self[2] - vector3[2]).


        """
    def __neg__(self) -> Vector3:
        """

        __neg__(self) -> hou.Vector3

            Return a vector whose components contain the negative values of this
            vector's components. This method lets you write -v, where v is a
            Vector3 object.

            This method is equivalent to hou.Vector3(-self[0], -self[1],
            -self[2]).


        """
    def __rmul__(self, scalar: float) -> Vector3:
        """

        __rmul__(self, scalar) -> hou.Vector3

            Multiply this vector with a scalar, returning a new vector. This
            method lets you write s * v, where v is a vector and s is a float
            scalar. See also hou.Vector3.__mul__, which lets you write v * s.

          > >>> v = hou.Vector3(1, 2, 3)
          > >>> v * 2
          > <hou.Vector3 [2, 4, 6]>
          > >>> 2 * v
          > <hou.Vector3 [2, 4, 6]>

        """
    def __mul__(self, scalar_or_matrix3_or_matrix4: float|Matrix3|Matrix4) -> Vector3:
        """

        __mul__(self, scalar_or_matrix3_or_matrix4) -> hou.Vector3

            Multiply this vector with a scalar or with a matrix, returning a new
            vector. This method lets you write v * s or v * m where v is a
            vector, s is a float scalar, and m is a hou.Matrix3 or a
            hou.Matrix4.

            When the parameter is a float scalar s, this method is equivalent to
            hou.Vector3(self[0] * s, self[1] * s, self[2] * s).

            In order to multiply the Vector3 by a Matrix4, the Vector3 is
            converted to a Vector4 with the fourth component set to 1.0. The
            effect is that the vector is treated as a position, so if the
            transformation matrix contains a translation component, the return
            value will be translated. If you would like to transform a vector
            (so translations are ignored but rotations, for example, apply),
            you'll need to transform a corresponding hou.Vector4 with the fourth
            component set to zero:

          > # Build a transformation matrix that rotates 180 degrees about z and then translates by 1 in x.
          > >>> matrix = hou.hmath.buildRotateAboutAxis((0, 0, 1), 180) * hou.hmath.buildTranslate((1, 0, 0))
          > >>> position = hou.Vector3(0.0, 1.0, 0.0)
          > 
          > # Rotate the point (0,1,0) to (0,-1,0), then translate to (1,-1,0).
          > >>> position * matrix
          > <hou.Vector3 [1, -1, 0]>
          > 
          > # Rotate the vector (0,1,0) to (0,-1,0), ignoring the translation.
          > >>> vector = hou.Vector4(tuple(position) + (0.0,))
          > >>> vector
          > <hou.Vector4 [0, 1, 0, 0]>
          > >>> vector * matrix
          > <hou.Vector4 [0, -1, 0, 0]>
          > >>> hou.Vector3(vector * matrix)
          > <hou.Vector3 [0, -1, 0]>
          > 
          > # We could have wrapped the above in a function:
          > >>> def transformAsVector(vector3):
          > ...     return hou.Vector3(hou.Vector4(tuple(vector3) + (0.0,)) * matrix)
          > >>> transformAsVector(position)
          > <hou.Vector3 [0, -1, 0]>
          > 
          > # Change the Vector4's last component to 1 to illustrate that it's transformed as a point again.
          > >>> vector[-1] = 1.0
          > >>> vector
          > <hou.Vector4 [0, 1, 0, 1]>
          > >>> vector * matrix
          > <hou.Vector4 [1, -1, 0, 1]>

            See also hou.Matrix4.


        """
    def __div__(self, scalar: float) -> Vector3:
        """

        __div__(self, scalar) -> hou.Vector3

            Divide a vector by a float scalar, returning a new vector. This
            method lets you write v / s where v is a vector and s is a float.

            This method is equivalent to hou.Vector3(self[0] / scalar, self[1] /
            scalar, self[2] / scalar).


        """
    def __truediv__(self, scalar: float) -> Vector3: ...
    def normalized(self) -> Vector3:
        """

        normalized(self) -> hou.Vector3

            Interpret this vector as a direction and return a vector with the
            same direction but with a length of 1.

            If the vector's length is 0 (or close to it), the result is the
            original vector.

            For vectors with non-zero lengths, this method is equivalent to self
            * (1.0/self.length()).


        """
    def multiplyAsDir(self, matrix4: Matrix4) -> Vector3:
        """

        multiplyAsDir(self, matrix4) -> hou.Vector3

            Interpret this vector as a direction and returns a transformed
            direction that has been rotated and scaled (not translated) by the
            matrix4


        """
    def length(self) -> float:
        """

        length(self) -> float

            Interpret this vector as a direction vector and return its length.
            The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
            self[2]**2).


        """
    def lengthSquared(self) -> float:
        """

        lengthSquared(self) -> float

            Interpret this vector as a direction vector and return the square of
            its length. The result is the same as self[0]**2 + self[1]**2 +
            self[2]**2.


        """
    def matrixToRotateTo(self, vector3: Vector3) -> Matrix4:
        """

        matrixToRotateTo(self, vector3) -> hou.Matrix4

            Return a matrix that rotates this vector onto vector3, rotating
            about the axis perpendicular to the two vectors. If the two vectors
            have the same direction, return the identity matrix.


        """
    def smoothRotation(self, reference: Vector3, rotate_order: Literal['xyz','xzy','yxz','yzx','zxy','zyx'] = ...) -> Vector3:
        '''

        smoothRotation(self, reference, rotate_order=\\"xyz\\") -> hou.Vector3

            Returns the Euler rotations (in degrees) that have the closest
            values to reference while still describing the same orientation as
            this vector.


            reference
                A hou.Vector3 of Euler angles, in degrees. Typically, this will
                be the rotations from the previous sample or frame.

            rotate_order
                A string containing a permutation of the letters x, y, and z
                that determines the order in which rotations are performed about
                the coordinate axes.


        '''
    def distanceTo(self, vector3: Vector3) -> float:
        """

        distanceTo(self, vector3) -> float

            Interpret this vector and the argument as 3D positions, and return
            the distance between them. The return value is equivalent to (self -
            vector3).length().


        """
    def angleTo(self, vector3: Vector3) -> float:
        """

        angleTo(self, vector3) -> float

            Interprets this Vector3 and the parameter as directions and returns
            the angle (in degrees) formed between the two vectors when you place
            the origins at the same location.


        """
    def dot(self, vector3: Vector3) -> float:
        """

        dot(self, vector3) -> float

            Return the dot product between this vector and the one in the
            parameter. This value is equal to self[0]*vector3[0] +
            self[1]*vector3[1] + self[2]*vector3[2], which is also equal to
            self.length() * vector3.length() *
            math.cos(hou.hmath.degToRad(self.angleTo(vector3)))

            See Wikipedia's dot product page.


        """
    def cross(self, vector3: Vector3) -> Vector3:
        """

        cross(self, vector3) -> hou.Vector3

            Return the cross product of this vector with another vector. The
            return value is a vector that is perpendicular to both vectors,
            pointing in the direction defined by the right-hand rule, with
            length self.length() * vector3.length() *
            math.sin(hou.hmath.degToRad(self.angleTo(vector3))).

            See Wikipedia's cross product page.


        """
    def ocio_transform(self, src_space: str, dest_space: str) -> Vector3:
        """

        ocio_transform(self, src_space, dest_space) -> hou.Vector3

            Use Open Color IO to transform the color from the source space to
            the destination space.


        """
    def x(self) -> float:
        """

        x(self) -> float

            Return the first component of the vector. Equivalent to v.


        """
    def y(self) -> float:
        """

        y(self) -> float

            Return the second component of the vector. Equivalent to v.


        """
    def z(self) -> float:
        """

        z(self) -> float

            Return the third component of the vector. Equivalent to v.


        """
    def distanceToSegment(self, point1: Vector3, point2: Vector3) -> float:
        """

        pointOnSegment(self, point1, point2) -> hou.Vector3

            Project the underlying vector onto the line segment defined by
            point1 to point2. The returned point will lie on the line segment.


            `point1'
                The first hou.Vector3 of the line segment.

            `point2'
                The second hou.Vector3 of the line segment.


        """
    def distance2ToSegment(self, point1: Vector3, point2: Vector3) -> float: ...
    def pointOnSegment(self, point1: Vector3, point2: Vector3) -> Vector3: ...

    # Missing methods added by stubgen
    def __contains__(self, other: float) -> bool: ...
    def __iter__(self) -> Iterator[float]: ...
    def __reversed__(self) -> Iterator[float]: ...

class Vector4:
    """

    hou.Vector4

    A sequence of 4 floating point values, with associated mathematical
    operations.

    A Vector4 could be used to represent a position or direction in 4D
    space. In 3D math, however, it is more commonly used to represent either
    a position or a vector, depending on the value of the fourth component.
    Positions have a fourth component of 1.0, and vectors have a fourth
    component of 0.0. Subtracting a position from another yields a vector,
    adding two vectors together yields a vector, and adding a point and a
    vector yields a point. Operations that yield a fourth component value
    other than 0 or 1, like adding two points together, are not valid.
    Similarly, is makes sense to speak about a vector's length but not a
    position's length. The fourth component also affects how the
    position/vector is transformed; see hou.Vector3.__mul__ for more
    information.

    See also hou.Vector2 and hou.Vector3.


    """
    thisown: Incomplete
    def __init__(self, x: Sequence[float]|'Vector4'|float = ..., y: float = ..., z: float = ..., w: float = ...) -> None:
        """

        __init__(self, values=(0.0, 0.0, 0.0, 0.0))

            Return a new Vector4 from a sequence of floats. If this method is
            called without parameters, the resulting vector contains the values
            (0.0, 0.0, 0.0, 0.0).

            You can also construct a Vector4 from a hou.Vector3. The new vector
            has its fourth component set to 1.0.

            Raises InvalidSize if values is not 4 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def isAlmostEqual(self, vector4: Vector4, tolerance: float = 1e-05) -> bool:
        """

        isAlmostEqual(self, vector4, tolerance=0.00001) -> bool

            Return whether this vector is equal to another, within a tolerance.
            Verifies that the difference between each component of this vector
            and the corresponding component of the other vector is within the
            tolerance.


        """
    def almostEqual(self, vector4: Vector4, tolerance: float = 1e-05) -> bool:
        """

        almostEqual(self, vector4, tolerance=0.00001) -> bool

            Deprecated. Use Vector4.isAlmostEqual instead.


        """
    def __hash__(self) -> int: ...
    def __getitem__(self, index: int) -> float:
        """

        __getitem__(self, index) -> float

            Return the float component at the specified index. This method makes
            vectors behave as sequences (so you can, for example, use a for loop
            on the elements of a vector, convert a vector to a tuple of floats,
            etc.) and lets you use square brackets to index into a vector.


        """
    def __setitem__(self, index: int, value: float) -> None:
        """

        __setitem__(self, index, value)

            This method lets you use square brackets to set a value on a vector.


        """
    def __len__(self) -> int:
        """

        __len__(self) -> int

            Returns 4. This method lets you call len() on a Vector4.


        """
    def setTo(self, sequence: Sequence[float]) -> None:
        """

        setTo(self, sequence)

            Set the contents of this vector to a sequence of floats.

            Raises InvalidSize if values is not 4 elements long, or TypeError if
            values is not a sequence of floats or ints.


        """
    def __add__(self, vector4: Vector4) -> Vector4:
        """

        __add__(self, vector4) -> hou.Vector4

            Add two vectors, returning a new vector with each component
            (including the last one) equal to the sum of the corresponding
            components in the two vectors. This method lets you write v1 + v2,
            where v1 and v2 are Vector4 objects.

            This method is equivalent to hou.Vector4(self[0] + vector4[0],
            self[1] + vector4[1], self[2] + vector4[2], self[3] + vector4[3]).


        """
    def __sub__(self, vector4: Vector4) -> Vector4:
        """

        __sub__(self, vector4) -> hou.Vector4

            Subtract a vector from another, returning a new vector with each
            component (including the last one) equal to the first vector's
            corresponding component minus the second vector's. This method lets
            you write v1 - v2, where v1 and v2 are Vector4 objects.

            This method is equivalent to hou.Vector4(self[0] - vector4[0],
            self[1] - vector4[1], self[2] - vector4[2], self[3] - vector4[3]).


        """
    def __rmul__(self, scalar: float) -> Vector4:
        """

        __rmul__(self, scalar) -> hou.Vector4

            Multiply this vector with a scalar, returning a new vector. This
            method lets you write s * v, where v is a vector and s is a float
            scalar. See also hou.Vector4.__mul__, which lets you write v * s.

          > >>> v = hou.Vector4(1, 2, 3, 4)
          > >>> v * 2
          > <hou.Vector4 [2, 4, 6, 8]>
          > >>> 2 * v
          > <hou.Vector4 [2, 4, 6, 8]>

        """
    def __mul__(self, scalar_or_matrix4: float|Matrix4) -> Vector4:
        """

        __mul__(self, scalar_or_matrix4) -> hou.Vector4

            Multiply a vector with a scalar or with a matrix, returning a new
            vector. This method lets you write v * s or v * m where v is a
            vector, s is a float scalar, and m is a hou.Matrix4.

            See hou.Vector3.__mul__ for more information.


        """
    def __div__(self, scalar: float) -> Vector4:
        """

        __div__(self, scalar) -> hou.Vector4

            Divide a vector by a float scalar, returning a new vector. This
            method lets you write v / s where v is a vector and s is a float.

            This method is equivalent to hou.Vector4(self[0] / scalar, self[1] /
            scalar, self[2] / scalar, self[3] / scalar).


        """
    def __truediv__(self, scalar: float) -> Vector4: ...
    def normalized(self) -> Vector4:
        """

        normalized(self) -> Vector4

            Interpret this vector as a 4D direction and return a vector with the
            same direction but with a length of 1. If this vector being used to
            represent a 3D direction (so the fourth component is 0), the result
            is still meaningful, and represents the corresponding 3D direction.

            If the vector's length is 0 (or close to it), the result is the
            original vector.

            For vectors with non-zero lengths, this method is equivalent to self
            * (1.0/self.length()).


        """
    def length(self) -> float:
        """

        length(self) -> float

            Interpret this vector as a 4D direction vector and return its
            length. If this vector is representing a 3D direction (so the fourth
            component is 0), the result is the 3D length.

            The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
            self[2]**2 + self[3]**2).


        """
    def lengthSquared(self) -> float:
        """

        lengthSquared(self) -> float

            Return the result of self.length()**2. The result is the same as
            self[0]**2 + self[1]**2 + self[2]**2 + self[3]**2.


        """
    def dot(self, vector4: Vector4) -> float:
        """

        dot(self, vector4) -> float

            Return the dot product between this 4D vector and the one in the
            parameter. This value is equal to self[0]*vector4[0] +
            self[1]*vector4[1] + self[2]*vector4[2] + self[3]*vector4[3].


        """
    def ocio_transform(self, src_space: str, dest_space: str) -> Vector4:
        """

        ocio_transform(self, src_space, dest_space) -> hou.Vector4

            Use Open Color IO to transform the color from the source space to
            the destination space.


        """
    def x(self) -> float:
        """

        x(self) -> float

            Return the first component of the vector. Equivalent to v.


        """
    def y(self) -> float:
        """

        y(self) -> float

            Return the second component of the vector. Equivalent to v.


        """
    def z(self) -> float:
        """

        z(self) -> float

            Return the third component of the vector. Equivalent to v.


        """
    def w(self) -> float:
        """

        w(self) -> float

            Return the fourth component of the vector. Equivalent to v.


        """

    # Missing methods added by stubgen
    def __contains__(self, other: float) -> bool: ...
    def __iter__(self) -> Iterator[float]: ...
    def __reversed__(self) -> Iterator[float]: ...

class Vertex:
    """

    hou.Vertex

    Existing inside a Geometry object, a Vertex object is contained in
    exactly one Prim, and references exactly one Point.

    This setup allows points to be shared between primitives. For example, a
    polygon contains its own list of vertices that are not shared with other
    primitives, but vertices in different polygons may refer to the same
    point. When that point moves, the corresponding vertices on all adjacent
    polygons will also move, preventing polygon edges from separating.

    Note that you can use hou.Vertex.point to retrieve a point from a
    vertex, but there is no method to retrieve all the vertices referring to
    a point. Houdini does not store this information internally, but you can
    derive it. The best way to quickly retrieve this information is to build
    a dictionary mapping all points to sets of vertices, and then reuse this
    dictionary in your algorithm.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Geometry:
        """

        geometry(self) -> Geometry

            Return the hou.Geometry object containing this vertex.


        """
    def prim(self) -> Prim:
        """

        prim(self) -> hou.Prim

            Return the hou.Prim object containing this vertex.

            If the primitive is a face, use hou.Prim.vertices to access the
            other vertices in the primitive. If it is a surface, use
            hou.Surface.vertex, hou.Surface.numRows, and hou.Surface.numCols.


        """
    def point(self) -> Point:
        """

        point(self) -> hou.Point

            Return the hou.Point object that this vertex refers to. Each vertex
            refers to exactly one point.


        """
    def number(self) -> int:
        """

        number(self) -> int

            Return the number of this vertex within its primitive. Vertices in
            the same primitive are numbered sequentially starting from 0, and
            the vertices returned by hou.Prim.vertices are in order by their
            number.


        """
    def linearNumber(self) -> int:
        """

        linearNumber(self) -> int

            Return the number of this vertex within its whole detail. Vertices
            in the detail are sometimes in the same order as they occur in
            primitives, but this is often not true. Linear vertex numbers in a
            detail are sequential, starting from 0, and ending with one less
            than the total number of vertices in the detail. This can be useful
            so that a function that can be applied to point, vertex, primitive,
            or detail attributes doesn't have to take two numbers just to handle
            the vertex case.


        """
    def attribType(self) -> EnumValue:
        """

        attribType(self) -> hou.attribType enum value

            Return the enumerated value hou.attribType.Vertex. Points,
            primitives, vertices, and geometry support the same set of methods
            for querying their attributes, and this method is one of them.

            See also:

          * hou.Point.attribType

          * hou.Prim.attribType

          * hou.Geometry.attribType

          * hou.attribType


        """
    def floatAttribValue(self, name_or_attrib: str|Attrib) -> float:
        """

        floatAttribValue(self, name_or_attrib) -> float

            Return the vertex attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object.

            Raises hou.OperationFailed if no attribute exists with this name or
            the attribute is not float of size 1.

            In most cases, you'll just use hou.Vertex.attribValue to access
            attribute values. Houdini uses this method internally to implement
            attribValue.


        """
    def floatListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[float,...]:
        """

        floatListAttribValue(self, name_or_attrib) -> tuple of float

            Return the vertex attribute value for a particular floating point
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of floats.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Vertex.attribValue.


        """
    def intAttribValue(self, name_or_attrib: str|Attrib) -> int:
        """

        intAttribValue(self, name_or_attrib) -> int

            Return the vertex attribute value for a particular integer attribute
            of size 1. The attribute may be specified by name or by hou.Attrib
            object. See hou.Vertex.floatAttribValue for more information.


        """
    def intListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[int,...]:
        """

        intListAttribValue(self, name_or_attrib) -> tuple of int

            Return the vertex attribute value for a particular integer
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of ints. See
            hou.Vertex.floatListAttribValue for more information.


        """
    def stringAttribValue(self, name_or_attrib: str|Attrib) -> str:
        """

        stringAttribValue(self, name_or_attrib) -> str

            Return the vertex attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. See
            hou.Vertex.floatAttribValue for more information.


        """
    def stringListAttribValue(self, name_or_attrib: str|Attrib) -> Tuple[str,...]:
        """

        stringListAttribValue(self, name_or_attrib) -> tuple of str

            Return the vertex attribute value for a particular string attribute.
            The attribute may be specified by name or by hou.Attrib object. The
            return value is a tuple of strings.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned.

            See also hou.Vertex.attribValue.


        """
    def dictAttribValue(self, name_or_attrib: str|Attrib) -> AttribDictReturnType:
        """

        dictAttribValue(self, name_or_attrib) -> dict

            Return the vertex attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. See hou.Vertex.floatAttribValue for more information.


        """
    def dictListAttribValue(self, name_or_attrib: str|Attrib) -> Sequence[AttribDictReturnType]:
        """

        dictListAttribValue(self, name_or_attrib) -> tuple of str

            Return the vertex attribute value for a particular dictionary
            attribute. The attribute may be specified by name or by hou.Attrib
            object. The return value is a tuple of dictionaries.

            It is valid to call this method when the attribute's size is 1. In
            this case, a tuple with one element is returned. See
            hou.Vertex.floatAttribValue for more information.


        """
    def setAttribValue(self, name_or_attrib: str|Attrib, attrib_value: AttribArgType|AttribDictArgType) -> None:
        """

        setAttribValue(self, name_or_attrib, attrib_value)

            Store an attribute value in this vertex. The attribute may be
            specified by name or by hou.Attrib object, and must be an existing
            vertex attribute in the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if no attribute exists with this name or
            if the attribute's data type does not match the value passed in. If
            the attribute's size is more than 1, the attribute value must be a
            sequence of integers/floats, and the size of the sequence must match
            the attribute's size.

            If the attribute is an array, the seqeunce must be a flat array, not
            an array of tuples. If the attribute is float, ensure the python
            objects are float, and not integer (1.0, not 1).

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def attribValue(self, attrib: Attrib|str) -> AttribReturnType|AttribDictReturnType:
        """

        attribValue(self, name_or_attrib) -> int, float, str, tuple or dict

            Return the value store in this vertex for a particular attribute.
            The attribute may be specified by name or by hou.Attrib object.

            Looking an attribute value using a hou.Attrib object is slightly
            faster than looking it up by name. When looking up attribute values
            inside a loop, look up the hou.Attrib object outside the loop, and
            pass it into this method.

            Raises hou.OperationFailed if no attribute exists with this name.


        """

class VertexGroup:
    """

    hou.VertexGroup

    A named group of vertices inside a Geometry object.

    Vertex groups reside inside the geometry, and each vertex group has a
    unique name.

    Groups are either ordered or unordered. When asking for the contents of
    an ordered group, the results will be returned in the order they were
    added to to the group. For an unordered group, the results will be
    returned in an arbitrary order (though it is normally arranged by
    increasing vertex number). When creating a group using the group SOP,
    use the <Create Ordered> checkbox to create an ordered group. When
    creating one from Python, Use the is_ordered parameter of
    hou.Geometry.createVertexGroup to control whether a group is ordered.

    See hou.Vertex for more information about vertices. See also
    hou.PrimGroup, hou.PointGroup, and hou.EdgeGroup.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def geometry(self) -> Geometry:
        """

        geometry(self) -> hou.Geometry

            Return the geometry object containing this group.


        """
    def name(self) -> str:
        """

        name(self)

            Return the name of the group. Each vertex group has a unique name.


        """
    def iterVertices(self) -> _VertexTupleGenerator:
        """

        iterVertices(self) -> generator of hou.Vertex

            Return a generator that iterates through all the contents of this
            group.

            Whereas hou.VertexGroup.vertices allocates and returns a tuple of
            all the vertices in the group, this method returns a generator
            object that will yield hou.Vertex objects on demand.


        """
    def vertices(self) -> Tuple[Vertex, ...]:
        """

        vertices(self) -> tuple of hou.Vertex

            Return the contents of this group.

            See also hou.VertexGroup.iterVertices.


        """
    def contains(self, vertex: Vertex) -> bool:
        """

        contains(self, vertex) -> bool

            Return whether or not a vertex is in this group.

            Raises hou.OperationFailed if the vertex belongs to a different
            geometry object than this group.


        """
    def isOrdered(self) -> bool:
        """

        isOrdered(self) -> bool

            Returns whether or not this group is ordered.


        """
    def add(self, vertex_or_list_or_vertex_group: Vertex|Sequence[Vertex]|VertexGroup) -> None:
        """

        add(self, vertex_or_list_or_vertex_group)

            If given a hou.Vertex or a list of hou.Vertex's, add the vertex
            (vertices) to the group. If given a hou.VertexGroup, merge the
            contents of the other vertex group with this group (the other group
            is unaffected). You would typically call this method from the code
            of a Python-defined SOP.

            It is ok to add vertices to the group that were already in the
            group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the vertex or vertex group belong to a
            different geometry object than this group.


        """
    def remove(self, vertex_or_list_or_vertex_group: Vertex|Sequence[Vertex]|VertexGroup) -> None:
        """

        remove(self, vertex_or_list_or_vertex_group)

            If given a hou.Vertex or a list of hou.Vertex's, remove the vertex
            from the group. If given a hou.VertexGroup, remove all vertices in
            the other group from this group (the other group is unaffected). You
            would typically call this method from the code of a Python-defined
            SOP.

            It is not an error to try to remove a vertex from the group that
            wasn't already in the group.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            Raises hou.OperationFailed if the vertex belongs to a different
            geometry object than this group.


        """
    def clear(self) -> None:
        """

        clear(self)

            Remove all vertices from this group. You would typically call this
            method from the code of a Python-defined SOP.

            The vertices remain in the geometry; only the group is affected.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Remove this group from the geometry. You would typically call this
            method from the code of a Python-defined SOP.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def vertexCount(self) -> int:
        """

        vertexCount(self) -> int

            Returns the number of vertices in this group.


        """
    def optionType(self, option_name: str) -> EnumValue:
        """

        optionType(self, name) -> hou.fieldType enum value

            Return a hou.fieldType enumerated value that describes the type of
            data stored in an option. Returns hou.fieldType.NoSuchField if no
            field exists with that name.


        """
    def setOption(self, name: str, value: OptionMultiArgType, type_hint: EnumValue = ...) -> None:
        """

        setOption(self, name, value, type_hint = hou.fieldType::NoSuchField)

            Set an entry in the dictionary of options. See
            hou.VertexGroup.options for more information.


            name
                The name of the option to set.

            value
                An integer, float, string, hou.Vector2, hou.Vector3,
                hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
                sequence of numbers.

            type_hint
                Used to determine the exact hou.fieldType desired when the
                specified value type is not enough to unambiguously determine
                it.


        """
    def removeOption(self, name: str) -> None:
        """

        removeOption(self, name)

            Remove an entry in the dictionary of options. See
            hou.VertexGroup.options for more information.

            Raises hou.OperationFailed if there is no entry in the dictionary
            with this name.


        """
    def dataId(self) -> AttribDataId:
        """

        dataId(self)

            Returns the data id that represents the contents of this group.


        """
    def incrementDataId(self) -> None:
        """

        incrementDataId(self)

            Increment the data id to indicate that the contents of this group
            has changed.


        """
    def options(self) -> dict[str, OptionMultiReturnType]:
        """

        option(self, name) -> bool, int, float, str, hou.Vector2, hou.Vector3,
        hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
        tuple of float

            Return the value of an individual option, on None if no such option
            exists.

            See also hou.VertexGroup.options, hou.VertexGroup.setOption and
            hou.VertexGroup.removeOption.


        """
    def option(self, option_name: str) -> OptionMultiReturnType: ...

class VexContext:
    """

    hou.VexContext

    Represents a VEX/VOP context. Different contexts allow the use of
    different functions/VOPs.


    NOTE
        This class is for internal use by Houdini and isn't usually
        necessary for scripting Houdini or creating tools.

    This object is returned by hou.vexContextForNodeTypeCategory and
    hou.vexContextForShaderType. You can get a list of all VEX context
    objects using hou.vexContexts.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of this context as a string. For example, 'Sop' or
            'surface'.


        """
    def nodeTypeCategory(self) -> NodeTypeCategory:
        '''

        nodeTypeCategory(self) -> hou.NodeTypeCategory

            Returns the hou.NodeTypeCategory object associated with this VEX
            context.

          > >>> # Get a reference to a SOP node
          > >>> n = hou.node(\\"/obj/geo1/pointvop1\\")
          > >>> # Get its type category (SOPs)
          > >>> sops = n.type().category()
          > >>> # Get the context associated with the SOPs category
          > >>> ctx = hou.vexContextForNodeTypeCategory(sops)
          > >>> # Get the node type category associated with the Sop context
          > >>> ctx.nodeTypeCategory()
          > <hou.NodeTypeCategory for Sop>

        '''
    def shaderType(self) -> EnumValue:
        """

        shaderType(self) -> hou.shaderType enum value or None

            Returns a hou.shaderType value representing the shader type
            associated with this VEX context.


        """
    def pathsToLoadedVexFunctions(self) -> dict[str, str]:
        """

        pathsToLoadedVexFunctions(self) -> dict mapping names to paths


        """

class ViewerDragger:
    """

    hou.ViewerDragger

    A mechanism to support interactive dragging operations.

    The hou.ViewerDragger class provides various methods to help
    implementing mouse dragging functionality without worrying about many
    details like constraining the mouse movement or making sure drag
    coordinates are computed relative to a specific origin.

    hou.ViewerDragger is an abstract base class for hou.ViewerHandleDragger
    and hou.ViewerStateDragger, these are the classes you must use to
    instantiate a dragger.

    A dragger operation can be divided in three parts:

     1. start: This step configures the dragger for a specific drag
        operation.

     2. drag: This actually executes the drag operation interactively as
        configured in step #1.

     3. end: Ends the operation and cleanup the dragger.

    Drag operations like translating a geometry along a plane, along a line
    or rotating a geometry around an axis can all be accomplished with a
    dragger.

    RELATED

        hou.ViewerHandleDragger hou.ViewerStateDragger


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> str

            Returns the name of the dragger.


        """
    def valid(self) -> bool:
        """

        valid(self) -> bool

            Returns True if the dragger is ready to use or False otherwise. One
            of the dragger start methods must be called first to make a dragger
            usable.


        """
    def startDrag(self, event: ViewerEvent, start_pos: Vector3) -> None:
        """

        startDrag(self, ui_event, start_pos)

            Enables the dragger for moving the mouse anywhere in the viewport
            from a specific position.


            NOTE
                When invoking startDrag from onMouseIndirectEvent with [MMB],
                the dragger computes the handle position relative to the world-
                space position under the mouse.

            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                typically the object Houdini passes to a python handle or python
                state's onMouseEvent.

            start_pos
                A hou.Vector3 object describing the start position of the drag
                operation. For instance, this could be a python handle pivot.


        """
    def startDragAcrossFloor(self, event: ViewerEvent, start_pos: Vector3) -> None:
        """

        startDragAcrossFloor(self, ui_event, start_pos, mouse_offset)

            This method enables the dragger to move the mouse along the
            construction plane or the viewport reference plane grid.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            start_pos
                A hou.Vector3 object describing the start position of the drag
                operation.


        """
    def startDragAlongLine(self, event: ViewerEvent, line_start: Vector3, line_dir: Vector3) -> None:
        """

        startDragAlongLine(self, ui_event, line_origin, line_dir)

            Configures the dragger to move the mouse along a line defined with a
            start point and a direction vector. When the line is picked and the
            mouse is moving, the dragger will constrain the mouse movement in
            the direction of the line.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            line_origin
                A hou.Vector3 object to define the start position of the line.

            line_dir
                A hou.Vector3 object to define the direction the line is
                pointing.


        """
    def startDragAlongPlane(self, event: ViewerEvent, plane_point: Vector3, plane_normal: Vector3) -> None:
        """

        startDragAlongPlane(self, ui_event, plane_point, plane_normal)

            Configures the dragger to move the mouse along a plane defined with
            an origin point and a normal vector. When the LMB is down and the
            mouse is moving, the dragger will constrain the mouse position to
            the plane.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            plane_point
                A hou.Vector3 object defining a point on the plane.

            plane_normal
                A hou.Vector3 object to define the plane normal.


        """
    def startDragRotate(self, event: ViewerEvent, center_pos: Vector3, radius: float, rotate_axis: Vector3, orient: Matrix3) -> None:
        """

        startDragRotate(self, ui_event, center_pos, radius, rotate_axis, orient)

            Configures the dragger to drag a ring around an axis.


            ui_event
                A hou.ViewerEvent object holding UI event information. This is
                the object Houdini passes to the python handle onMouseEvent
                handler.

            center_pos
                A hou.Vector3 object representing the center of the rotation.

            radius
                The radius of the rotation ring.

            rotate_axis
                A hou.Vector3 vector representing the axis of rotation. This is
                typically a normalized vector used as the rotation plane normal.

            orient
                A hou.Matrix3 object representing the orientation matrix of the
                axis.


        """
    def drag(self, event: ViewerEvent) -> dict[str, Any]:
        """

        drag(self, ui_event) -> (dictionary)

            Performs a drag operation based on the start method previously
            called. Raises hou.OperationFailed if the dragger was not
            initialized with a start method.

            Call this method when the mouse is being dragged. All dragger
            operations are done in world space and can perform snapping (except
            for rotation) if the dialog has the option enabled.

            The method returns a dictionary containing the resulting values for
            these operations: XYZ Drag, Drag Across Floor, Drag Along Line, Drag
            Along Plane:

            delta_position

            A hou.Vector3 vector representing the delta mouse position related
            to the drag start position.

            position

            A hou.Vector3 vector representing the absolute mouse position in
            world coordinates.

            This dictionary is returned for the Drag Rotate operation:

            delta_angle

            A hou.Vector3 vector representing the delta angle in radians related
            to the rotation start position.

            angle

            A hou.Vector3 vector representing the total angle in radians related
            to the rotation start position.

            rotate_position

            A hou.Vector3 vector representing the rotation ring absolute
            position related to the rotation start position.

            delta_rotate_matrix

            A hou.Matrix3 matrix representing the delta rotation matrix related
            to the orient matrix.


        """
    def endDrag(self) -> None:
        """

        endDrag(self)

            Ends the current drag operation by releasing any drag cache and
            other settings performed by the dragger.


        """
    def position(self) -> Vector3:
        """

        position(self) -> hou.Vector3

            Returns the absolute mouse position of the current drag operation.
            The returned value is relevant for these operations: XYZ Drag, Drag
            Across Floor, Drag Along Line, Drag Along Plane.


        """
    def startPosition(self) -> Vector3:
        """

        startPosition(self) -> hou.Vector3

            Returns the start position used for configuring the current drag
            operation. For the Drag Rotate operation, the returned value refers
            to the center of rotation.


        """
    def startDirection(self) -> Vector3:
        """

        startDirection(self) -> hou.Vector3

            Returns the start direction used for configuring the current drag
            operation.

            For the Drag Rotate operation, the returned value refers to the
            direction vector pointing ray corresponding to the hou.ViewerEvent's
            mouse coordinates in screen space.


        """
    def startRotatePosition(self) -> Vector3:
        """

        startRotatePosition(self) -> hou.Vector3

            Returns the start position on the rotation ring for the Drag Rotate
            operation.


        """
    def viewport(self) -> GeometryViewport:
        """

        viewport(self) -> hou.GeometryViewport

            Returns the current viewport.


        """
    def enableModifierKeys(self, allow: bool) -> None:
        """

        enableModifierKeys(self, enable)

            Set whether this dragger uses modifier keys to change the dragging
            behavior. When enabled, the Ctrl+Shift modifier key combo will
            restrict the XYZ drag to 45 degree axes in screen space, and if a
            construction plane is active, the Shift modifier key is used to
            change the distance from the dragger to the contruction plane.


        """
    def setSnapToCookSelection(self, on: bool) -> None:
        """

        setSnapToCookSelection(self, enable)

            Set whether to allow snapping to the cook selection of the current
            geometry in the viewport. If disabled, the cook selection geometry
            will be ignored when geometry is snapped to while dragging.


        """

class ViewerEvent(UIEvent):
    """

    hou.ViewerEvent

    Represents a user interface event specific to viewers.

    hou.ViewerEvent objects are used with Python states. Houdini will call
    event handlers with a dictionary containing various useful data,
    including a ui_event key containing a ViewerEvent object. You do not
    instantiate this type of object yourself. See Python states for more
    information.

    hou.ViewerEvent is a specialized hou.UIEvent class that you can used for
    accessing ray coordinates in a viewer.

    RELATED

        hou.ViewerHandleDragger hou.ViewerStateDragger
        hou.CompositorViewerEvent


    """
    thisown: Incomplete
    def __init__(self, sceneViewer: SceneViewer, val: int, val2: int) -> None:
        """

        hou.ViewerEvent

        Represents a user interface event specific to viewers.

        hou.ViewerEvent objects are used with Python states. Houdini will call
        event handlers with a dictionary containing various useful data,
        including a ui_event key containing a ViewerEvent object. You do not
        instantiate this type of object yourself. See Python states for more
        information.

        hou.ViewerEvent is a specialized hou.UIEvent class that you can used for
        accessing ray coordinates in a viewer.

        RELATED

            hou.ViewerHandleDragger hou.ViewerStateDragger
            hou.CompositorViewerEvent


        """
    __swig_destroy__: Incomplete
    def ray(self) -> Tuple[Vector3, Vector3]:
        """

        ray(self) -> (origin_point, direction)

            Returns a tuple of two hou.Vector3 objects representing the origin
            point and a direction vector of a pointing ray in 3D world space
            corresponding to the underlying hou.UIEventDevice's mouse
            coordinates in screen space.

            The resulting ray can be used to shoot into the scene that passes
            through whatever is under the mouse. The method puts the ray origin
            at the mouse screen coordinates on the near plane and then maps the
            camera space position to world space. For a perspective projection,
            the near plane part of the frustum is usually small in world space,
            so the origin point will be pretty close to the camera position.


        """
    def snappingRay(self) -> dict[str, Any]:
        """

        snappingRay(self) -> dict

            Same as hou.ViewerEvent.ray, but the returned original point may be
            snapped with respect to scene geometry, the Houdini construction or
            the reference plane. Snapping is performed using the settings from
            the snapping options window available on the left side of the
            viewport. The dictionary contains the following key/value pairs:

            snapped
            Bool

            True if the user snapped to scene geometry, to the Houdini
            construction plane, or to the reference plane in the viewport.

            origin_point
            hou.Vector3

            The origin of a pointing ray in 3D world space corresponding to the
            mouse coordinates in screen space. If snapped is True, the
            origin_point is the position on the camera plane such that if you
            sent a pointing ray through that point, it would hit the component
            that was snapped to. This may not necessarily be the position
            directly under the mouse cursor.

            direction
            hou.Vector3

            The direction vector of a pointing ray in 3D world space
            corresponding to the mouse coordinates in screen space. It may be
            moved from the actual mouse position if snapped is True.

            snap_pos
            hou.Vector3

            The position that was snapped to, in 3D world space. This key is
            only included if snapped is True.

            geo_type
            hou.snappingPriority

            The type of geometry which was snapped to. This key is only included
            if snapped is True. Note that only geometry types that are set in
            the Snapping Options Window can be snapped to.

            node_id
            int

            The session node id of the node whose geometry has been snapped to.
            The node itself can be retrieved by calling hou.nodebySessionId().

            prim_index
            int

            The primitive number corresponding to the snapped geometry. This is
            only included in the dictionary if geo_type is one of GeoPrim,
            BreakPoint, PrimGuidePoint, or PrimGuideEdge.

            point_index
            int

            The point number corresponding to the snapped geometry. This is only
            included in the dictionary if geo_type is GeoPoint.

            edge_point_index1
            int

            The first endpoint of the snapped edge. This is only included in the
            dictionary if geo_type is one of GeoEdge or Midpoint.

            edge_point_index2
            int

            The second endpoint of the snapped edge. This is only included in
            the dictionary if geo_type is one of GeoEdge or Midpoint.

            breakpoint_u
            int

            The first coordinate of the snapped breakpoint. This is only
            included in the dictionary if geo_type is BreakPoint.

            breakpoint_v
            int

            The second coordinate of the snapped breakpoint. This is only
            included in the dictionary if geo_type is BreakPoint.

            guide_index
            int

            The index of the guide corresponding to the snapped geometry. This
            is only included in the dictionary if geo_type is one of
            PrimGuidePoint or PrimGuideEdge.

            grid_pos
            hou.Vector3

            The position on the grid of the snapped geometry. This is only
            included in the dictionary if geo_type is either GridPoint or
            GridEdge.

            start_pos
            hou.Vector3

            The position on the grid of the first endpoint of the snapped edge.
            This is only included in the dictionary if geo_type is GridEdge.

            end_pos
            hou.Vector3

            The position on the grid of the second endpoint of the snapped edge.
            This is only included in the dictionary if geo_type is GridEdge.


            Note
                snapped will always be False if snapping is not enabled in the
                viewport. See hou.SceneViewer.setSnappingMode to change the
                current snapping mode.


        """
    def screenToRay(self, scrx: float, scry: float) -> Tuple[Vector3, Vector3]:
        """

        screenToRay(self, screen_x, screen_y) -> (origin_point, direction)

            Returns a tuple of two hou.Vector3 objects: the origin point and a
            direction vector of a picking ray in 3D world space corresponding to
            the given screen-space mouse coordinates. The coordinates must be
            relative to the viewer, not to the viewport.


            screen_x
                X coordinate in screen space relative to the view.

            screen_y
                Y coordinate in screen space relative to the view.


        """
    def curViewport(self) -> Optional[GeometryViewport]:
        """

        curViewport(self) -> hou.GeometryViewport

            Returns the viewport this event occurred within.


        """
    def mousePos(self, relative_to_viewport: bool = False) -> Vector2:
        """

        mousePos(self, relative_to_viewport=False) -> hou.Vector2

            Return the mouse position for this event in screen coordinates. By
            default, the position is relative to the scene viewer window.


            relative_to_viewport
                If False (default), the position is relative to the scene viewer
                window. If True, the position is relative to the viewport under
                the mouse.


        """

class ViewerStateContext(GadgetContext):
    """

    hou.ViewerStateContext

    Represents the execution context of a Python viewer state.

    OVERVIEW

        A hou.ViewerStateContext holds the contextual information related to
        the running viewer state such as the gadget drawable bindings.

    RELATED

        hou.ViewerStateTemplate.bindGadget hou.ViewerHandleContext


    """
    thisown: Incomplete
    def __init__(self, val: int) -> None:
        """

        hou.ViewerStateContext

        Represents the execution context of a Python viewer state.

        OVERVIEW

            A hou.ViewerStateContext holds the contextual information related to
            the running viewer state such as the gadget drawable bindings.

        RELATED

            hou.ViewerStateTemplate.bindGadget hou.ViewerHandleContext


        """
    __swig_destroy__: Incomplete

class ViewerHandleDragger(ViewerDragger):
    '''

    hou.ViewerHandleDragger

    Represents a dragger usable with Python viewer handles.

    You will typically implement drag operations in the viewer handle
    onMouseEvent handler. The example below demonstrates how to translate
    the geometry bound to a viewer handle by dragging the handle\'s pivot.


    NOTE
        The hou.ViewerHandleDragger class is not compatible with COP Python
        handles. For creating interactive mouse-based manipulations within
        the 2D image space of COP Python handles, use the
        drawable2d.Dragger2D class instead.

    > import hou
    > 
    > def __init__(self, **kwargs):
    >     self.__dict__.update(kwargs)
    > 
    >     #creates the handle dragger
    >     self.handle_dragger = hou.ViewerHandleDragger(\\"dragger\\")
    > 
    > def onMouseEvent( self, kwargs ):
    >     \\"\\"\\" Called when a gadget is being picked and dragged.
    >     \\"\\"\\"
    > 
    >     # The handle context containing pick/locate info on the active gadget
    >     hcontext = self.handle_context
    > 
    >     # The handle parameters
    >     hparms = kwargs[\\"handle_parms\\"]
    > 
    >     # Tegular mouse event info
    >     ui_event = kwargs[\\"ui_event\\"]
    >     reason = ui_event.reason()
    > 
    >     if hcontext.gadget() == Handle.GADGET_PIVOT:
    >         # The pivot is used by the user to move the handle.
    >         if reason == hou.uiEventReason.Start:
    >             # Get the current translation values from the handle 
    >             # parameters
    >             handle_pos = hou.Vector3(hparms[\\"tx\\"][\\"value\\"], hparms[\\"ty\\"][\\"value\\"],
    >                 hparms[\\"tz\\"][\\"value\\"])
    > 
    >             # Start the handle translate from the current handle pivot position. 
    >             self.handle_dragger.startDrag(ui_event, handle_pos)
    > 
    >         elif reason == hou.uiEventReason.Changed or reason == hou.uiEventReason.Active:            
    >             # drag the bound geometry interactively (while the LMB is down).
    >             drag_values = self.handle_dragger.drag(ui_event)
    > 
    >             # Update the handle parameters with the delta position returned by 
    >             # the dragger.
    >             hparms[\\"tx\\"][\\"value\\"] += drag_values[\\"delta_position\\"][0]
    >             hparms[\\"ty\\"][\\"value\\"] += drag_values[\\"delta_position\\"][1]
    >             hparms[\\"tz\\"][\\"value\\"] += drag_values[\\"delta_position\\"][2]
    > 
    >             # Set the handle transform matrix
    >             self.xform = hu.updateTransform(self.xform, t=[hparms[\\"tx\\"][\\"value\\"], 
    >                 hparms[\\"ty\\"][\\"value\\"], hparms[\\"tz\\"][\\"value\\"]])
    > 
    >             if reason == hou.uiEventReason.Changed:
    >                 # We are done, exit the drag.
    >                 self.handle_dragger.endDrag()                   
    > 
    >         # Consume the event
    >         return True
    > 
    >     return False

    RELATED

        hou.ViewerHandleContext hou.ViewerStateDragger


    '''
    thisown: Incomplete
    def __init__(self, name: str) -> None:
        """

        __init__(self, name)

            Creates a viewer handle dragger object.


            name
                A name to identify the dragger.


        """
    __swig_destroy__: Incomplete

class ViewerHandleContext(GadgetContext):
    """

    hou.ViewerHandleContext

    Represents the execution context of a Python viewer handle.

    OVERVIEW

        A hou.ViewerHandleContext stores the state associated with a running
        viewer handle. It contains information about the handle's gadgets
        (see hou.GadgetContext) as well as the handle itself, including its
        parameters. Viewer handle implementations can access their context
        instance through the handle_context data member.

        The context also manages the drawable objects used by 2D viewer
        handles (for example, the sidefx_transform2d handle). This allows
        the context to render drawables and provide picking services on
        them.

    RELATED

        hou.ViewerHandleTemplate


    """
    thisown: Incomplete
    def __init__(self, val: int) -> None:
        """

        hou.ViewerHandleContext

        Represents the execution context of a Python viewer handle.

        OVERVIEW

            A hou.ViewerHandleContext stores the state associated with a running
            viewer handle. It contains information about the handle's gadgets
            (see hou.GadgetContext) as well as the handle itself, including its
            parameters. Viewer handle implementations can access their context
            instance through the handle_context data member.

            The context also manages the drawable objects used by 2D viewer
            handles (for example, the sidefx_transform2d handle). This allows
            the context to render drawables and provide picking services on
            them.

        RELATED

            hou.ViewerHandleTemplate


        """
    __swig_destroy__: Incomplete
    def isParameterEnabled(self, parm_name: str) -> bool:
        """

        isParameterEnabled(parm_name) -> bool


            parm_name
                Returns True if a given parm name is enabled. The returned value
                is typically used in the handle implementation for enabling or
                disabling (hide) the functionality that may depend on this parm.


        """
    def scaleFactor(self, ref_position: Sequence[float]|Vector3 = ...) -> float:
        """

        scaleFactor(ref_position) -> double

            This method returns a scale factor that can be used to maintain a
            fixed scale size of the handle gadgets when zooming in or out.
            scaleFactor is normally used in onDrawSetup.


            ref_position
                A reference position (related to the handle) used for computing
                the scale factor. This could be the handle's pivot position (if
                one exists) or any other relevant position. If omitted, the
                reference position is (0,0,0).


        """
    def scaleValue(self) -> float:
        """

        scaleValue() -> double

            Returns the handle scale preference value. The handle scale is
            computed proportionally to the current viewport size and can be used
            to scale up handle gadgets to a preferred size. You would normally
            call scaleValue from onDrawSetup.


        """
    def handleScaleValue(self, *args) -> float:
        '''

        handleScaleValue(ref_position=None) -> double

            Returns the computed scaling factor for the current handle within
            the active Houdini viewport. Although Houdini automatically scales
            drawables to maintain a consistent display size across different
            zoom levels, this value is crucial for COP Python handle
            implementations. It allows for adjusting the display size of
            drawables, particularly to compensate for the handle\'s own scaling
            when interactively dragging elements.


            ref_position
                A reference position (related to the handle) used for computing
                the scale value. This is likely a drawable position or any other
                relevant position. If omitted, the reference position is
                (0,0,0).

            This code snippet demonstrates how to use handleScaleValue() in a
            COP python handle.

          > import hou
          > import drawable2d as d2d
          > 
          > MY_LINE_DRAWABLE = \\"line\\"
          > MY_MARKER_DRAWABLE = \\"marker\\"
          > 
          > TX = \\"tx\\"
          > TY = \\"ty\\"
          > 
          > def __init__(self, **kwargs):
          >     self.__dict__.update(kwargs)
          > 
          >     self._line = None
          >     self._marker = None
          > 
          >     # handle dragger
          >     self._dragger = d2d.Dragger2D(self.scene_viewer)
          > 
          > def onActivate(self, kwargs):
          >     # Drawables creation omitted for brievity
          >     pass
          > 
          > def onMouseEvent(self, kwargs):
          >     \\"\\"\\" Drags a marker position and update the line point #2
          >         with the new position.
          >     \\"\\"\\"
          >     ui_event = kwargs[\\"ui_event\\"]
          >     reason = ui_event.reason()
          > 
          >     if reason == hou.uiEventReason.Changed:
          >         # End the current drag operation on mouse up
          >         self._dragger.endDrag()
          >         return True
          > 
          >     if not self._dragger.update(kwargs, self._marker):
          >         return False
          > 
          >     drawable_name = self.handle_context.name()
          > 
          >     consumed = True
          >     if reason == hou.uiEventReason.Start:
          >         if drawable_name == MY_MARKER_DRAWABLE:
          >             self._dragger.startDrag(p1=self.handle_parms[TX], p2=self.handle_parms[TY], 
          >                 transform_mode=d2d.Drawable2D.TransformMode.PARAMS)
          > 
          >     elif reason in [hou.uiEventReason.Active, hou.uiEventReason.Changed]:
          >         if drawable_name == MY_MARKER_DRAWABLE:
          >             # Drag the drawable
          >             self._dragger.dragXY()
          > 
          >             # Change the drawable positions  
          >             dx, dy = self._dragger.delta()
          >             delta = hou.Vector3(dx,dy,0)
          > 
          >             # Adjust the delta with the handle scaling factor
          >             handle_scale = self.handle_context.handleScaleValue(delta)
          >             delta /= handle_scale
          > 
          >             dx = delta[0]
          >             dy = delta[1]
          > 
          >             su.addToDrawablePos(self._marker, dx, dy)                                
          >             su.addToDrawablePoint(self._line, 1, dx, dy)
          > 
          >     return consumed
          > 
          >     ...

        '''
    def objectWorldTransform(self) -> Matrix4:
        """

        objectWorldTransform() -> [Hom:hou.Matrix4]

            Returns the world space transform of the handle's parent object.


        """
    def objectLocalTransform(self) -> Matrix4:
        """

        objectLocalTransform() -> [Hom:hou.Matrix4]

            Returns the local space transform of the handle's parent object.


        """
    def setDrawOrder(self, drawable_names: Sequence[str]) -> None:
        """

        setDrawOrder(drawable_names)

            Defines the draw order for the handle's drawables. The same order is
            applied when picking, but iterated front to back so the visually
            topmost drawable is tested first.


            NOTE
                This method is currently supported only for 2D viewer handles.


            drawable_names
                A partial or complete list of drawable names specifying the
                order from back to front (the first name is drawn first,
                farthest back; the last name is drawn last, on top).

                Any drawables not included in the list are drawn in their
                creation order and placed behind all listed drawables.


        """
    def draw(self, handle: Handle) -> None:
        """

        draw(self, draw_handle)

            Render the handle's drawables in the viewport. This method is
            invoked during the Python Handle's onDraw event to draw all
            registered drawables.


            NOTE
                This method is currently supported only for 2D viewer handles.


            draw_handle
                An opaque identifier provided by Houdini for rendering. The
                value is passed to the Python Handle's onDraw callback and must
                be forwarded unchanged to this draw method.


        """

class ViewerHandleTemplate:
    """

    hou.ViewerHandleTemplate

    Class for registering a python viewer handle in Houdini.

    This class is used for defining a python viewer handle template. Use
    this class to set the configuration and create the handle bindings like
    gadgets, parameters and context menu in order to create the template.
    Houdini uses this template for registering the viewer handle and to
    create instances of the viewer handle.

    See Python handles for more details on how to create your python viewer
    handles.

    RELATED

        hou.ViewerHandleContext hou.ViewerHandleDragger


    """
    thisown: Incomplete
    def __init__(self, name: str, label: str, categories: Sequence[EnumValue]) -> None:
        """

        __init__(self, name, label, categories)

            Creates a new instance of ViewerHandleTemplate representing a viewer
            handle type.

            A viewer handle is identified by a name and a list of categories
            such as SOP and OBJ. The name is the custom type of the viewer
            handle and must be unique. The list of categories specifies in which
            context(s) the viewer handle can be used.


            name
                A unique name to define the handle type.

            label
                A string representing the handle descriptive name.

            categories
                A list of hou.NodeTypeCategory objects to describe the
                context(s) supported by the handle.

                Here's the list of the supported contexts:

              * hou.copNodeTypeCategory

              * hou.lopNodeTypeCategory

              * hou.dopNodeTypeCategory

              * hou.objNodeTypeCategory

              * hou.sopNodeTypeCategory

                Use the functions below for adding the contexts to the
                categories list.

                For SOP states use:

              > hou.sopNodeTypeCategory()

                For OBJ states use:

              > hou.objNodeTypeCategory()

                For LOP states use:

              > hou.lopNodeTypeCategory()

                For DOP states use:

              > hou.dopNodeTypeCategory()

                For COP states use:

              > hou.copNodeTypeCategory()

        """
    __swig_destroy__: Incomplete
    def typeName(self) -> str:
        """

        typeName(self) -> str

            Returns the handle type name.


        """
    def categories(self) -> Tuple[NodeTypeCategory, ...]:
        """

        categories(self) -> list of hou.NodeTypeCategory

            Returns the list of supported contexts for this template.


        """
    def bindMenu(self, menu: ViewerStateMenu) -> None:
        """

        bindMenu(self, menu)

            Attaches a context menu to this viewer handle. You can only bind one
            single context menu per template.


            menu
                The hou.ViewerStateMenu object to add.


        """
    def bindIcon(self, name: str) -> None:
        '''

        bindIcon(self, icon_name)

            Sets the icon image of this viewer handle.


            icon_name
                The name of the icon. Defaults to MISC_python. The icon name can
                be specified as follows:

              * As a single name.

              * As a path to the image icon file on disk. There is no convention
                for where to put icon files on disk.

                    eg.

                  > template.bindIcon(\\"$HOUDINI_USER_PREF_DIR/config/Icons/myicon.pic\\")

        '''
    def bindGadget(self, drawable_type: EnumValue, gadget_name: str, gadget_label: str|None = ..., parms: Sequence[str]|None = ...) -> None:
        """

        bindGadget(self, drawable_type, gadget_name, gadget_label=None,
        parms=None)

            Binds a gadget drawable to a viewer handle. A gadget is a special
            geometry drawable which provides visual interaction support to
            viewer handles with picking and locating capabilities. Gadget
            drawable instances are created by Houdini, you don't create objects
            of this type by yourself. See hou.ViewerHandleTemplate.bindFactory
            for details on how to access the gadgets in a viewer handle class.


            NOTE
                This method is not compatible with COP Python handles.


            geometry_drawable_type
                The gadget geometry type. The following types are supported:

              * hou.drawableGeometryType.Face

              * hou.drawableGeometryType.Line

              * hou.drawableGeometryType.Point

            gadget_name
                The gadget name string identifier.

            gadget_label
                An optional description name. Defaults to None.

            parms
                A list of handle parameter names the gadget requires for visual
                interaction. Houdini will make the gadget available to the
                python handle's handle_gadgets dictionary only when all its
                required parameters are bound to an asset. For instance, if the
                gadget requires parms X and Y and all of them are bound, the
                gadget will be made available when the handle is activated.
                However, if only parm X is bound, the gadget will not be
                available at all. This means the gadget will not be part of
                handle_gadgets. In this case, the python handle implementation
                should make sure to not access an unbound gadget.

                Defaults to None.


        """
    def bindParameter(self, param_type: EnumValue, name: str, label: str|None = ..., default_value: int|float|str|None = ..., num_components: int = ..., min_limit: int = ..., max_limit: int = ..., visible: bool = ...) -> None:
        """

        bindParameter(self, param_type, name, label=None, default_value=None,
        num_components=1, min_limit=0, max_limit=1, visible=True)

            Defines a viewer handle visual parameter. A viewer handle
            implementation can expose these parameters to Houdini so users can
            change them visually through its gadgets. You can also change these
            parameters from the Handle dialog (with the 'P' hotkey or from the
            viewport context menu). This workflow however is mostly used for
            debugging purposes.

            A viewer handle should implement the onParmChangeEvent handler to
            react to parameter changes. See viewer handle event handlers for
            details.


            name
                The parameter name identifier. The name cannot be empty and must
                be unique within the handle.

            default_value
                The default value of the parameter. This is the value Houdini
                uses to initialize the parameter. The value type should ideally
                match param_type but Houdini will do its best to convert the
                type appropriately. Defaults to None.

            label
                The parameter label. If sets to None (default), the label is set
                with the parameter name.

            min_limit
                Describes the minimum value the parameter can be set with.
                Defaults to 0. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            max_limit
                Describes the maximum value the parameter can be set with.
                Defaults to 1. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            num_components
                Specifies the number of components to create for the parameter
                template. A maximum of 3 components is allowed, the default
                number of component is 1. Exceptions are raised if the value is
                invalid.

                num_components > 1 is supported for the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            param_type
                The viewer handle parameter type. These types are supported:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

                An exception is raised for other types.

            visible
                Controls whether the parameter is visible or not in the Handle
                Parameter Dialog. Defaults to True.


                NOTE
                    If the parameter is not exported, Houdini will mark it as
                    invisible regardless of the visible argument setting.


        """
    def exportParameters(self, params: Sequence[str]) -> None:
        """

        exportParameters(self, params)

            Exposes specific viewer handle parameters to Houdini. Exported
            parameters can be used by viewer states for binding dynamically or
            statically viewer handles.


            params
                List of parameters defined with
                hou.ViewerHandleTemplate.bindParameter.


        """
    def bindSetting(self, param_type: EnumValue, name: str, label: str|None = ..., menu_as_button_strip: bool = ..., menu_items: Sequence[Tuple[str, str]|Tuple[str, str, str]]|None = ..., num_components: int = ..., default_value: int|float|str|None = ..., min_limit: int = ..., max_limit: int = ..., align: bool = ...) -> None:
        """

        bindSetting(self, param_type, name, label=None,
        menu_as_button_strip=False, menu_items=None, num_components=1,
        default_value=None, min_limit=0, max_limit=1, align=False)

            Binds a setting parameter to a viewer handle. A setting is a non-
            visual parameter typically used for configuring or setting a viewer
            handle workflow. They are accessible from the Handle dialog.

            A viewer handle should implement the onParmChangeEvent handler to
            react to setting parameter changes. See viewer handle event handlers
            for details.


            align
                Specifies how the parameter is aligned in the Handle Dialog. If
                True, the parameter is aligned horizontally with the next bound
                parameter. If False, the parameter is displayed below the
                previous one. Defaults to False.

            default_value
                The default value of the parameter. This is the value Houdini
                uses to initialize the parameter. The value type should ideally
                match param_type but Houdini will do its best to convert the
                type appropriately. Defaults to None.

                Parameter type

                Value type

                hou.parmTemplateType.Button

                The value is ignored.

                hou.parmTemplateType.Menu

                Menu item identifier as defined with menu_items.

                hou.parmTemplateType.Toggle

                Toggle state as a bool or int.

            name
                The parameter string identifier. The name cannot be empty and
                must be unique in the handle template or an exception is raised.

            label
                The parameter label. If sets to None (default), the label is set
                with the parameter name.

            menu_as_button_strip
                If True, the hou.parmTemplateType.Menu parameter is set to use a
                button strip widget to display the menu items. Buttons are
                displayed with the menu item icons, if any, or with the menu
                item labels otherwise. menu_as_button_strip defaults to False
                and is ignored for other types.

            menu_items
                A list of string tuples for defining the items of a
                hou.parmTemplateType.Menu parameter. menu_items is ignored for
                other parameter types.

                The tuple can contain 2 or 3 elements:

              * Item 0: the menu item identifier.

              * Item 1: the menu item label.

              * Item 2: the menu item icon name (optional).

            min_limit
                Describes the minimum value the parameter can be set in the UI
                dialog. Defaults to 0. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            max_limit
                Describes the maximum value the parameter can be set in the UI
                dialog. Defaults to 1. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            num_components
                Specifies the number of components to create for the parameter
                template. Defaults to 1. Exceptions are raised if the value is
                invalid.

                num_components > 1 is supported for the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.String

            param_type
                The type of parameter to bind. The following types are
                supported:

              * hou.parmTemplateType.Button

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.Menu

              * hou.parmTemplateType.Separator

              * hou.parmTemplateType.String

              * hou.parmTemplateType.Toggle

                An exception is raised for other types.


        """
    def bindHotkeyDefinitions(self, definitions: PluginHotkeyDefinitions) -> None:
        """

        bindHotkeyDefinitions(self, definitions)

            Binds a hotkey definitions object to this viewer handle that defines
            the hotkey commands and contexts implemented by the handle. You can
            only bind one such definitions object per template.


            definitions
                The hou.PluginHotkeyDefinitions object to add.


        """
    def bindFactory(self, callback: Callable[[SceneViewer, str], Handle]) -> Any:
        """

        bindFactory(self, callable)

            Takes a callable object (such as a class or function) that returns
            the viewer handle class.


        """

class ViewerState:
    """

    hou.ViewerState

    Describes an interactive state for a viewer pane.

    Viewer panes such as a Scene Viewer or Compositor Viewer can enter
    specific states. A state controls the available handles, mouse
    interactions, and in some cases node creation or deletion based on user
    interaction with the viewer pane. This class does not represent a
    running state in a viewer, but instead describes a state that can be
    entered with methods such as hou.SceneViewer.setCurrentState or
    hou.CompositorViewer.setCurrentState.

    Each node type that can be displayed in a viewer pane will have an
    associated viewer state (though not all viewer states need to be
    associated with a node type). This node type specific viewer state is
    used to create new instances or edit existing instances of the node type
    in a viewer pane.

    The list of viewer states associated with a given node type category is
    returned from the hou.NodeTypeCategory.viewerStates method.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> string

            Return the internal name of this state, which is the string that
            must be passed to the setCurrentState() method of the viewer pane to
            enter this state.


        """
    def description(self) -> str:
        """

        description(self) -> string

            Return the brief name of the state that appears in the upper left
            corner of the viewer pane when this state is active.


        """
    def icon(self) -> str:
        """

        icon(self) -> string

            Return the icon for the state that appears in the upper left corner
            of the viewer pane when this state is active.


        """
    def categories(self) -> Tuple[NodeTypeCategory, ...]:
        """

        categories(self) -> tuple of hou.NodeTypeCategory

            Return the node type category for the nodes that are associated with
            this state.


        """
    def nodeType(self) -> NodeType:
        """

        nodeType(self) -> hou.NodeType or None

            Return the node type associated with this state. May return None if
            this state is not associated with a particular node type, such as
            the SOP or Object View states which are used for panning and
            tumbling in a scene viewer pane.


        """
    def isHidden(self) -> bool: ...
    def hotkey(self) -> str:
        """

        hotkey(self) -> string

            Return the hotkey associated with this state.


        """
    def parmTemplates(self) -> ParmTemplateGroup:
        """

        parmTemplates(self) -> hou.ParmTemplateGroup

            Return the parameter templates associated with this state.


        """

class ViewerStateDragger(ViewerDragger):
    """

    hou.ViewerStateDragger

    Represents a dragger usable with Python viewer states.

    RELATED

        hou.ViewerStateContext hou.ViewerHandleDragger


    """
    thisown: Incomplete
    def __init__(self, name: str, xform: Matrix4 = ..., inv_xform: Matrix4 = ...) -> None:
        """

        __init__(self, name, xform=hou.Matrix4(1.0), inv_xform=hou.Matrix4(1.0))

            Creates a python state dragger object. The dragger can be set with
            transforms to correctly deal with coordinate space changes. See
            hou.ViewerDragger for more details on viewer draggers.


            name
                A name to identify the dragger.

            xform
                An optional transform used by the dragger to convert local
                coordinates to world space. Defaults to identity matrix.

            inv_xform
                An optional inverse transform used by the dragger to convert
                world coordinates to local space. Defaults to identity matrix.


        """
    __swig_destroy__: Incomplete
    def setTransform(self, xform: Matrix4) -> None:
        """

        setTransform(self, xform)

            Sets the transform matrix for this dragger.


            xform
                A hou.Matrix4 transformation matrix.


        """
    def setInverseTransform(self, inv_xform: Matrix4) -> None:
        """

        setInverseTransform(self, inv_xform)

            Sets the inverse transform matrix for this dragger.


            inv_xform
                A hou.Matrix4 transformation matrix.


        """
    def transform(self) -> Matrix4:
        """

        transform(self): -> hou.Matrix4

            Returns the transform matrix of the dragger.


        """
    def inverseTransform(self) -> Matrix4:
        """

        inverseTransform(self): -> hou.Matrix4

            Returns the inverse transform matrix of the dragger.


        """

class ViewerStateMenu:
    '''

    hou.ViewerStateMenu

    Builds a context menu for a viewer state.

    OVERVIEW

        The ViewerStateMenu class lets you build a context menu for a viewer
        state. This class is also represents sub-menus of the top-level
        context menu.

        Currently you can add the following items to the menu

      * Toggle (checkbox) item: represents a setting you can turn on or off

      * Radio strip: represents a choice of several mutually exclusive
        items.

      * Action item: represents an action to preform. You implement the
        action in the state\'s onMenuAction method.

      * Separator item: creates a visual separation between groups of items
        in the menu.

        Hotkeys, registered using a hou.PluginHotkeyDefinitions object, can
        be added to toggle, action and radio strip menu items.

        See setting up viewer state context menus for more information.

        The following example shows how to implement and bind a menu to a
        sop viewer state.

      > import hou
      > 
      > 
      > class ExampleState(object):
      >     def __init__(self, state_name, scene_viewer):
      >         self.state_name = state_name
      >         self.scene_viewer = scene_viewer
      > 
      >     # the menu callback
      >     def onMenuAction(self, kwargs):
      >         action = kwargs[\\"menu_item\\"]
      >         if action == \'toggle1\':
      >             print(\\"Set toggle 1 to\\", kwargs[\\"toggle1\\"])
      > 
      >         elif action == \'toggle2\':
      >             print(\\"Set toggle 2 to\\", kwargs[\\"toggle2\\"])
      > 
      >         elif action == \'action\':
      >             print(\\"Chose action 1\\")
      > 
      >         elif action == \'radio_strip\':
      >             print(\\"Set the radio strip to\\", kwargs[\\"radio_strip\\"])
      > 
      >         elif action == \'submenu_toggle1\':
      >             print(\\"Set the submenu toggle to\\", kwargs[\\"submenu_toggle1\\"])
      > 
      > 
      > def createViewerStateTemplate(state_type, state_label):     
      >     template = hou.ViewerStateTemplate(
      >         state_type, state_label, hou.sopNodeTypeCategory()
      >     )
      >     template.bindFactory(ExampleState)
      > 
      >     # add some hotkey definitions
      >     hotkey_definitions = hou.PluginHotkeyDefinitions()
      > 
      >     example_context = \\"h.pane.gview.state.sop.example\\"
      >     hotkey_definitions.addContext(example_context, \\"Example Operation\\", \\"These keys apply to the Example operations\\")
      >     example_category = \\"h.pane.gview.state.sop.example\\"
      >     hotkey_definitions.addCommandCategory(example_category, \\"Example Operation\\", \\"These commands apply to the Example operations\\")
      > 
      >     h1 = example_category + \'h1\'
      >     hotkey_definitions.addCommand(h1, \'example 1\', \'example 1\')
      >     hotkey_definitions.addDefaultBinding(example_context, h1, [\'1\'])
      > 
      >     h2 = example_category + \'h2\'
      >     hotkey_definitions.addCommand(h2, \'example 2\', \'example 2\')
      >     hotkey_definition.addDefaultBinding(example_context, h2, [\'2\'])
      > 
      >     h3 = example_category + \'h3\'
      >     hotkey_definitions.addCommand(h3, \'example 3\', \'example 3\')
      >     hotkey_definitions.addDefaultBinding(example_context, h3, [\'3\'])
      > 
      >     h4 = example_category + \'h3\'
      >     hotkey_definitions.addCommand(h4, \'example 4\', \'example 4\')
      >     hotkey_definitions.addDefaultBinding(example_context, h4, [\'4\'])
      > 
      >     # define the state popupmenu
      >     m = hou.ViewerStateMenu(\'menu\', \'Example\')
      > 
      >     m.addSeparator()
      >     m.addToggleItem( \'toggle1\', \'Toggle1\', True, hotkey=h1 )
      >     m.addToggleItem( \'toggle2\', \'Toggle2\', False )
      >     m.addSeparator()
      >     m.addActionItem( \'action\', \'Action1\', hotkey=h2 )
      >     m.addSeparator()
      >     m.addRadioStrip( \'radio_strip\', \'Radio\', \\"radio_item1\\" )
      >     m.addRadioStripItem( \'radio_strip\', \'radio_item1\', \'Radio1\', hotkey=h3 )
      >     m.addRadioStripItem( \'radio_strip\', \'radio_item2\', \'Radio2\', hotkey=h4 )
      >     m.addSeparator()
      >     subm = hou.ViewerStateMenu(\'submenu\', \'More Example...\')
      >     subm.addToggleItem( \'submenu_toggle1\', \'Sub toggle1\', True )
      >     m.addMenu( subm )
      >     m.addSeparator()
      > 
      >     # attach popupmenu to state
      >     template.bindMenu(m)
      > 
      >     # attach the hotkey definitions to state
      >     template.bindHotkeyDefinitions(hotkey_definitions)
      > 
      >     return t


    '''
    thisown: Incomplete
    def __init__(self, handle: str, label: str) -> None:
        '''

        __init__(self, id, label)

            Creates a hou.ViewerStateMenu object.


            id
                A unique string ID for the menu. This is not currently used for
                the top level state context menu.

            label
                The menu name as it will appear in the interface. This is not
                currently used for the top level state context menu.

          > # The ID and label for the top menu are not used, but you should give
          > # them meaningful values anyway
          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")

        '''
    __swig_destroy__: Incomplete
    def addToggleItem(self, id, default: bool, hotkey: str = ...) -> None:
        '''

        addToggleItem(self, id, label, default, hotkey=\'\' )

            Adds a toggle menu item to this menu.


            id
                A unique string ID for this item.

            label
                The menu item text as it will appear in the menu.

            default
                Whether the item is on or off by default when the menu is
                created.

            hotkey
                An optional hotkey ID string to associate with this menu item.
                You can use hou.hotkeys.addCommand to create a custom hotkey.

          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")
          > menu.addToggleItem(\\"show_points\\", \\"Show Points\\", True)
          > menu.addToggleItem(\\"show_point_nums\\", \\"Show Point Numbers\\", False

        '''
    def addActionItem(self, id, hotkey: str = ...) -> None:
        '''

        addActionItem(self, id, label, hotkey=\'\')

            Adds an action item to this menu.


            id
                A unique name to identify the menu item. When this item is
                chosen by the user, this ID will be passed to the onMenuAction
                method in the arguments dictionary as kwargs[\\"menu_item\\"].

            label
                Menu item label displayed in the menu.

            hotkey
                An optional hotkey ID string to associate with this menu item.
                You can use hou.hotkeys.addCommand to create a custom hotkey.

          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")
          > menu.addActionItem(\\"delete\\", \\"Delete\\")

        '''
    def addSeparator(self) -> None:
        '''

        addSeparator(self)

            Adds a separator menu item.

          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")
          > menu.addActionItem(\\"delete\\", \\"Delete\\")
          > menu.addSeparator()
          > menu.addToggleItem(\\"show_points\\", \\"Show Points\\", True)
          > menu.addToggleItem(\\"show_point_nums\\", \\"Show Point Numbers\\", False)

        '''
    def addRadioStrip(self, handle: str, label: str, default_value: str) -> None:
        '''

        addRadioStrip(self, id, label, default)

            Prepares the menu to accept a group of mutually exclusive radio
            button items.


            id
                A unique string ID for the strip. All menu items added to the
                group with addRadioStripItem() will have this string as their
                first argument.

            label
                A title displayed above the group in the menu.

            default
                A radio item id as specified with
                hou.ViewerStateMenu.addRadioStripItem representing the default
                choice when the menu is created.

          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")
          > menu.addRadioStrip(\\"deform_type\\", \\"Deformation\\", \\"bend\\")
          > menu.addRadioStripItem(\\"deform_type\\", \\"bend\\", \\"Bend\\")
          > menu.addRadioStripItem(\\"deform_type\\", \\"squash\\", \\"Squash\\")

        '''
    def addRadioStripItem(self, strip_id: str, id, hotkey: str = ...) -> None:
        '''

        addRadioStripItem(self, strip_id, id, label, hotkey=\'\')

            Adds an menu item to a radio strip menu.


            strip_id
                The string ID of the radio strip (created with addRadioStrip()).
                All items that share the same strip_id are mutually exclusive.

            id
                A unique string ID for this item.

            label
                The menu item text as it will appear in the menu.

            hotkey
                An optional hotkey ID string to associate with this menu item.
                You can use hou.hotkeys.addCommand to create a custom hotkey.

          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")
          > menu.addRadioStrip(\\"deform_type\\", \\"Deformation\\", \\"bend\\")
          > menu.addRadioStripItem(\\"deform_type\\", \\"bend\\", \\"Bend\\")
          > menu.addRadioStripItem(\\"deform_type\\", \\"squash\\", \\"Squash\\")

        '''
    def addMenu(self, sub_menu: ViewerStateMenu) -> None:
        '''

        addMenu(self, submenu)

            Adds a ViewerStateMenu object as a submenu.

          > menu = hou.ViewerStateMenu(\\"menu\\", \\"State Menu\\")
          > menu.addActionItem(\\"delete\\", \\"Delete\\")
          > menu.addSeparator()
          > submenu = hou.ViewerStateMenu(\\"options\\", \\"Options\\")
          > submenu.addToggleItem(\\"show_points\\", \\"Show Points\\", True)
          > submenu.addToggleItem(\\"show_point_nums\\", \\"Show Point Numbers\\", False)
          > menu.addMenu(submenu)

        '''

class ViewerStateTemplate:
    '''

    hou.ViewerStateTemplate

    Contains attributes describing a custom viewer state (tool).

    Viewer states control interaction in the viewport. For example, the
    Rotate tool is a view state. The Handles tool allows access to the state
    associated with the current node. Houdini lets you create and register
    your own custom view states in Python.

    This object describes a custom state, including its implementation class
    and bindings (e.g. menus, handles, hotkeys, selectors, etc...). You
    supply an instance of this object when registering a custom state, and
    Houdini uses it to create concrete instances of the state.

    > import hou
    > 
    > # Create a class implementing the state callbacks
    > class MyState(object):
    >     def __init__(self, state_name, scene_viewer):
    >         self.state_name = state_name
    >         self.scene_viewer = scene_viewer
    > 
    > 
    > # Create a template to describe the state and its bindings
    > template = hou.ViewerStateTemplate(
    >     \\"mystate\\", \\"My Custom State\\",
    >     hou.sopNodeTypeCategory()
    > )
    > template.bindFactory(MyState)
    > template.bindHandleStatic(
    >     \\"rotate\\", \\"rot\\",
    >     [(\\"rx\\", \\"x\\"), (\\"ry\\", \\"y\\"), (\\"rz\\", \\"z\\")]
    > )
    > 
    > # Register the template with Houdini
    > hou.ui.registerViewerState(my_template)

    For information on how to create your own custom view states, see Python
    states.


    '''
    thisown: Incomplete
    def __init__(self, state_name: str, state_label: str, node_type_category: NodeTypeCategory, contexts: Sequence[NodeTypeCategory]|None = ...) -> None:
        '''

        __init__(self, state_name, state_label, node_type_category,
        contexts=None)

            Creates a new instance of ViewerStateTemplate representing a unique
            custom state type.

            ViewerStateTemplate is identified by a name and a category type. The
            name is the custom type of the state. The category specifies the
            context-level that Houdini uses to run the state. If you want your
            state to run across multiple context-levels, additional contexts can
            be added with the contexts parameter. Therefore, when the state is
            active and the user switches to a new context, Houdini will reuse
            the current state instance, provided the new context matches one of
            the state contexts.

            This example demonstrates how to register an OBJ state which can run
            in the SOP and CHOP contexts as well:

          > import hou
          > 
          > # Create a class implementing the state callbacks
          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          > 
          > # Create a template to describe the state and its bindings
          > state_name = \\"mystate\\"
          > state_label = \\"My Custom State\\"
          > node_type_category = hou.objNodeTypeCategory()
          > extra_contexts = [hou.sopNodeTypeCategory(), hou.chopNodeTypeCategory()]
          > template = hou.ViewerStateTemplate(
          >     state_name, state_label, node_type_category, contexts=extra_contexts )
          > template.bindFactory(MyState)
          > 
          > # Register the template with Houdini
          > hou.ui.registerViewerState(my_template)

            state_name
                A unique string to identify the viewer state.

            state_label
                A human-readable name for the state, for display in the user
                interface.

            node_type_category
                An instance of hou.NodeTypeCategory. For SOPs use the result of:

              > hou.sopNodeTypeCategory()

                For OBJ states use:

              > hou.objNodeTypeCategory()

                For LOP states use:

              > hou.lopNodeTypeCategory()

                For DOP states use:

              > hou.dopNodeTypeCategory()

            contexts
                A list of hou.NodeTypeCategory objects to specify additional
                context-levels for the state.

                Choose any of the following types to add to contexts:

              * hou.chopNodeTypeCategory

              * hou.copNodeTypeCategory

              * hou.cop2NodeTypeCategory

              * hou.dopNodeTypeCategory

              * hou.objNodeTypeCategory

              * hou.sopNodeTypeCategory

              * hou.topNodeTypeCategory

                Note: An exception will be thrown if unsupported types are used.
                Note: hou.lopNodeTypeCategory doesn\'t support extra contexts and
                cannot be used as such.


        '''
    __swig_destroy__: Incomplete
    def typeName(self) -> str:
        """

        typeName(self) -> str

            Returns a unique string used to identify the viewer state.


        """
    def categoryName(self) -> str:
        """

        categoryName(self) -> str

            Returns the name of the node type category of the state which you
            can use for creating the proper category object.


        """
    def contexts(self) -> Tuple[NodeTypeCategory, ...]:
        """

        contexts(self) -> list of hou.NodeTypeCategory

            Returns the list of contexts in which the state can be used.


        """
    def bindParameter(self, param_type: EnumValue, name: str|None = ..., label: str|None = ..., menu_as_button_strip: bool = ..., menu_items: Sequence[Tuple[str, str]|Tuple[str, str, str]]|None = ..., num_components: int = ..., default_value: ParmArgType|None = ..., min_limit: int = ..., max_limit: int = ..., align: bool = ..., toolbox: bool = ...) -> None:
        """

        bindParameter(self, param_type, name=None, label=None,
        menu_as_button_strip=False, menu_items=[], num_components=1,
        default_value=None, min_limit=0, max_limit=1, align=False, toolbox=True,
        hide_label=False, button_icon=None)

            Creates a parameter template for a viewer state. The template
            describes a parameter with settings such as the name or the data it
            holds. See state parameters for more details on how to use them.


            align
                Specifies how the parameter is aligned in the Parameter Dialog.
                If True, the parameter is aligned horizontally with the next
                bound parameter. if False, the parameter is displayed below the
                previous one. Defaults to False.

            button_icon
                The name of an icon to display for a
                (Hom:hou.parmTemplateType#Button). This parameter is ignored for
                other parameter template types. The parameter is empty by
                default.

            default_value
                The default value of the parameter. This is the value Houdini
                uses to initialize the parameter. The value type should ideally
                match param_type but Houdini will do its best to convert the
                type appropriately. Defaults to None.

                Parameter type

                Value type

                hou.parmTemplateType.Button

                The value is ignored.

                hou.parmTemplateType.Menu

                Menu item identifier as defined with menu_items.

                hou.parmTemplateType.Toggle

                Toggle state as a bool or int.

            hide_label
                A boolean value. If True, the label associated with this
                parameter template will be hidden in the user interface.
                Defaults to False.

            name
                The parameter string identifier. The name cannot be empty and
                must be unique within the state or an exception is raised.

            label
                The parameter label. If sets to None (default), the label is set
                with the parameter name.

            menu_as_button_strip
                If True, the hou.parmTemplateType.Menu parameter is set to use a
                button strip widget to display the menu items. Buttons are
                displayed with the menu item icons, if any, or with the menu
                item labels otherwise. menu_as_button_strip defaults to False
                and is ignored for other types.

            menu_items
                A list of string tuples for defining the items of a
                hou.parmTemplateType.Menu parameter. menu_items is ignored for
                other parameter types.

                The tuple can contain 2 or 3 elements:

              * Item 0: the menu item identifier.

              * Item 1: the menu item label.

              * Item 2: the menu item icon name (optional).

            min_limit
                Describes the minimum value the parameter can be set in the UI
                dialog. Defaults to 0. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            max_limit
                Describes the maximum value the parameter can be set in the UI
                dialog. Defaults to 1. Used with the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

            num_components
                Specifies the number of components to create for the parameter
                template. Defaults to 1. Exceptions are raised if the value is
                invalid.

                num_components > 1 is supported for the following types:

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.String

            param_type
                The type of parameter to bind. The following types are
                supported:

              * hou.parmTemplateType.Button

              * hou.parmTemplateType.Int

              * hou.parmTemplateType.Float

              * hou.parmTemplateType.Menu

              * hou.parmTemplateType.Separator

              * hou.parmTemplateType.String

              * hou.parmTemplateType.Toggle

                An exception is raised for other types.

            toolbox
                The parameter is always displayed in the Parameter Dialog but
                you can set this flag to display the parameter in the Operation
                Toolbox as well.


        """
    def bindHandle(self, handle_type: str, name: str, settings: str|None = ...) -> None:
        '''

        bindHandleStatic(self, handle_type, name, bindings, settings=None)

            Binds a handle to the node parameters driven by the viewer state.
            Dragging the handle will automatically update the bound
            parameter(s). See also bindHandle() and
            hou.SceneViewer.bindViewerHandleStatic.

          > t = hou.ViewerStateTemplate(\'my_state\', \'my_state_label\', hou.sopNodeTypeCategory())
          > ...
          > t.bindHandleStatic( \'vector\', \'Up Direction\', 
          >     [
          >                     (\'group\', \'input\'),
          >                     (\'originx\', \'tx\'),
          >                     (\'originy\', \'ty\'),
          >                     (\'originz\', \'tz\'),
          >                     (\'upx\', \'vx\'),
          >                     (\'upy\', \'vy\'),
          >                     (\'upz\', \'vz\')
          >     ]
          > )


                handle_type
                    A string naming the type of handle.

                name
                    A unique string to use to identify the handle. Each
                    binding\'s name must be unique within this state. Trying to
                    bind the same name more than once will raise an exception.

                bindings
                    A list of (\\"node_parm_name\\", \\"handle_parm_name\\") tuples.
                    This binds the parts of the handle to individual parameters
                    on the node.

                settings
                    A string containing specific settings of a handle. Multiple
                    settings must be space separated.


        '''
    def bindHandleStatic(self, handle_type: str, name: str, bindings: Sequence[str], settings: str|None = ...) -> None: ...
    def bindGadget(self, drawable_type: EnumValue, gadget_name: str, gadget_label: str|None = ...) -> None:
        '''

        bindGadget(self, drawable_type, gadget_name, gadget_label=None)

            Lets you bind a gadget drawable to a viewer state. A gadget is a
            special geometry drawable which provides visual interaction support
            for picking and locating the underlying gadget\'s geometry.

            Houdini uses the binding info to create the gadget drawable
            instances, you don\'t create objects of this type by yourself. The
            gadget instances are stored in a dictionary, accessible with the
            state_gadgets class attribute. Use the gadget name to query
            self.state_gadgets for a specific gadget.


            NOTE
                self.state_gadgets cannot not be accessed from the class
                __init__ method, but you can use it however from any other class
                methods.

            Houdini provides the picking and locating support, you don\'t have to
            implement anything specific to locate or pick a gadget component.
            hou.ViewerStateContext is used by Houdini to store the active gadget
            picking and locating information, this context is created by Houdini
            and accessible with the state_context class attribute.

          > import viewerstate.utils as su
          > 
          > def createViewerStateTemplate():
          > 
          >     state_typename = \\"state gadgets\\"
          >     state_label = \\"State gadgets\\"
          >     state_cat = hou.sopNodeTypeCategory()
          > 
          >     template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
          >     template.bindFactory(State)
          >     template.bindIcon(kwargs[\\"type\\"].icon())
          > 
          >     template.bindGadget( hou.drawableGeometryType.Line, \\"line_gadget\\", label=\\"Line\\" )
          >     template.bindGadget( hou.drawableGeometryType.Face, \\"face_gadget\\", label=\\"Face\\" )
          >     template.bindGadget( hou.drawableGeometryType.Point, \\"point_gadget\\", label=\\"Point\\" )
          > 
          >     return template
          > 
          > class State(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          >         self.cursor = su.CursorLabel(scene_viewer)        
          > 
          > def onEnter(self, kwargs):
          >     \\"\\"\\" Initializes the gadget drawables and assign them to class 
          >         attributes.
          >     \\"\\"\\"
          >     node = kwargs[\\"node\\"]
          >     self.geometry = node.geometry()
          > 
          >     self.line_gadget = self.state_gadgets[\\"line_gadget\\"]
          >     self.line_gadget.setGeometry(self.geometry)
          >     self.line_gadget.setParams({\\"draw_color\\":[.3,0,0,1], \\"locate_color\\":[1,0,0,1], \\"pick_color\\":[1,1,0,1], 
          >         \\"line_width\\":2.0})
          >     self.line_gadget.show(True)            
          > 
          >     self.face_gadget = self.state_gadgets[\\"face_gadget\\"]
          >     self.face_gadget.setGeometry(self.geometry)
          >     self.face_gadget.setParams({\\"draw_color\\":[0,.3,0,1], \\"locate_color\\":[1,0,0,1],\\"pick_color\\":[1,1,0,1]})
          >     self.face_gadget.show(True)            
          > 
          >     self.point_gadget = self.state_gadgets[\\"point_gadget\\"]
          >     self.point_gadget.setGeometry(self.geometry)
          >     self.point_gadget.setParams({\\"draw_color\\":[0,0,.3,1], \\"locate_color\\":[0,0,1,1], \\"pick_color\\":[1,1,0,1], 
          >         \\"radius\\":15.0})
          >     self.point_gadget.show(True)            
          > 
          > def onMouseEvent(self, kwargs):
          >     \\"\\"\\" Computes the cursor text position and drawable geometry
          >     \\"\\"\\"
          >     # init the cursor with the mouse kwargs
          >     self.cursor.setParams(kwargs)
          > 
          >     # Use the active gadget information to set the cursor label.
          >     gadget_name = self.state_context.gadget()
          >     if gadget_name in [\\"line_gadget\\", \\"face_gadget\\", \\"point_gadget\\"]:
          >         gadget = self.state_gadgets[gadget_name]
          > 
          >         label = self.state_context.gadgetLabel()
          >         c1 = self.state_context.component1()
          >         c2 = self.state_context.component2()
          > 
          >         self.cursor.setLabel(\\"{} : {} {}\\".format(label, c1, c2 if c2 > -1 else \\"\\"))
          >         self.cursor.show(True)            
          >     else:
          >         self.cursor.show(False)
          > 
          >     return True        
          > 
          > def onDraw( self, kwargs ):
          >     handle = kwargs[\\"draw_handle\\"]
          >     self.line_gadget.draw(handle) 
          >     self.face_gadget.draw(handle) 
          >     self.point_gadget.draw(handle)

            geometry_drawable_type
                The gadget geometry type. The following types are supported:

              * hou.drawableGeometryType.Face

              * hou.drawableGeometryType.Line

              * hou.drawableGeometryType.Point

            gadget_name
                The gadget name string identifier.

            gadget_label
                An optional description name. Defaults to None.


        '''
    def bindGeometrySelector(self, prompt: str, allow_drag: bool = ..., quick_select: bool = ..., auto_start: bool = ..., toolbox: bool = ..., use_existing_selection: bool = ..., consume_selection: bool = ..., secure_selection: EnumValue = ..., initial_selection: str = ..., initial_selection_type: EnumValue = ..., ordered: bool = ..., geometry_types: Sequence[EnumValue] = ..., primitive_types: Sequence[EnumValue] = ..., allow_other_sops: bool = ..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindGeometrySelector(self, prompt, allow_drag=False, quick_select=True,
        auto_start=True, toolbox=True, use_existing_selection=True,
        consume_selection=True, secure_selection=hou.secureSelectionOption.Obey,
        initial_selection=\\"\\",
        initial_selection_type=hou.geometryType.Primitives, ordered=False,
        geometry_types=[], primitive_types=[], allow_other_sops=False,
        hotkey=\\"\\", name=\\"\\")

            Binds a geometry selector to a SOP viewer state. This selector is
            used for selecting geometry elements when the underlying viewer
            state is active. This selector can only be used in a scene viewer,
            exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple geometry selectors can be bound to a viewer state. However,
            other selector types cannot be mixed, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a
            hou.GeometrySelection stored in the selection entry of the input
            kwargs dictionary. The return value can be True to stop the
            selection tool or False to keep it running. Pressing [Enter] also
            terminates the selector.


            allow_drag
                Determines whether selecting a component with a single mouse
                click completes the selection. This is typically used to prevent
                a multiple component selection. Defaults to False.

            allow_other_sops
                Allow selecting components on geometry from other geometry nodes
                visible in the viewport. Defaults to False.

            auto_start
                If True (the default), starts the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            consume_selection
                If True (default), clears the current selection when the
                selector is deactivated.

            geometry_types
                An array of hou.geometryType values representing the component
                types the user can select. The default is an empty list, the
                selector follows the Geometry Select Mode.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is an empty string.

                The hotkey value must be a hotkey symbol as shown in this viewer
                state template example:

              > import hou
              > import viewerstate.utils as su
              > 
              > class State(object):
              >     def __init__(self, state_name, scene_viewer):
              >             self.state_name = state_name
              >             self.scene_viewer = scene_viewer
              > 
              >     def createViewerStateTemplate():
              >             state_typename = kwargs[\\"type\\"].definition().sections()[\\"DefaultState\\"].contents()
              >             state_label = \\"Viewer State Example\\"
              >             state_category = hou.sopNodeTypeCategory()
              > 
              >             template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
              >             template.bindFactory(State)
              >             template.bindIcon(kwargs[\\"type\\"].icon())
              > 
              >             hotkey_definitions = hou.PluginHotkeyDefinitions()
              > 
              >             hotkey = \\"1\\"
              >             hotkey_name = \\"selector1\\"
              >             hotkey_label = \\"Select Geometry\\"
              >             hotkey_symbol = su.defineHotkey(hotkey_definitions,
              >                                     state_typename, hotkey_name, hotkey,
              >                                     hotkey_label, state_cat=state_category)
              > 
              >             template.bindHotkeyDefinitions(hotkey_definitions)
              > 
              >             template.bindGeometrySelector(
              >                     \\"Testing the Selector\\",
              >                     name=\\"TestSelector\\",
              >                     allow_drag=True,
              >                     auto_start=False,
              >                     hotkey=hotkey_symbol,
              >                     secure_selection=hou.secureSelectionOption.Off
              >             )

            initial_selection
                When use_existing_selection is False, this is a string of
                component group syntax representing what to set the selection to
                when the state is activated. The default is no selection.

            initial_selection_type
                A hou.geometryType value, representing the type of components
                specified by the initial_selection argument. The default is
                None, the selector follows the Geometry Select Mode.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            ordered
                If this is True, Houdini returns the components in the selection
                in the order the user selected them. The default is False,
                meaning the order of the components you get is unrelated to the
                order they were selected.

                Only set this to True if for some reason you need to
                distinguish, for example, the first primitive the user clicked,
                or the last, or that kind of thing.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            primitive_types
                A list of hou.primType values representing the primitive types
                the user can select. An empty list (default) allows selecting
                all types.

            quick_select
                If this is True, the state\'s selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer\'s secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.


        '''
    def bindObjectSelector(self, prompt: str, quick_select: bool = ..., auto_start: bool = ..., toolbox: bool = ..., use_existing_selection: bool = ..., allow_multisel: bool = ..., secure_selection: EnumValue = ..., allowed_types: Sequence[str] = ..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindObjectSelector(self, prompt, quick_select=True, auto_start=True,
        toolbox=True, use_existing_selection=True, allow_multisel=True,
        secure_selection=hou.secureSelectionOption.Obey, allowed_types=(\'*\',),
        hotkey=\\"\\", name=\\"\\")

            Binds an object selector to a OBJ viewer state. This selector is
            used for selecting objects when the underlying viewer state is
            active. This selector can only be used in a scene viewer, exception
            is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple object selectors can be bound to a viewer state. However,
            other selector types cannot be mixed with OBJ selectors, exception
            is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of hou.OpNode objects stored in the selection entry of the input
            kwargs dictionary. The return value can be True to stop the
            selection tool or False to keep it running. Pressing [Enter] also
            terminates the selector.


            allowed_types
                A list of strings to specify one or multiple object types the
                user can select. For instance, add geo to allowed_types to
                select geometry objects only. Patterns such as * can be used to
                select any objects or more restrictive patterns such as *cam*
                for selecting any camera objects. All available object types can
                be obtained with hou.objNodeTypeCategory.nodeTypes. Defaults to
                *.

            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is None. See
                hou.ViewerStateTemplate.bindGeometrySelector for an example on
                how to create an hotkey symbol.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state\'s selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection. Defaults to True.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer\'s secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection. Defaults to True.


        '''
    def bindSceneGraphSelector(self, prompt: str, allow_drag: bool = ..., quick_select: bool = ..., auto_start: bool = ..., toolbox: bool = ..., use_existing_selection: bool = ..., secure_selection: EnumValue = ..., consume_selection: bool = ..., allow_multisel: bool = ..., prior_selection_paths: Sequence[str]|None = ..., prim_mask: str|None = ..., path_prefix_mask: str|None = ..., prim_kind: str|None = ..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindSceneGraphSelector(self, prompt, allow_drag=True, quick_select=True,
        auto_start=True, toolbox=True, use_existing_selection=True,
        secure_selection=hou.secureSelectionOption.Obey,
        consume_selection=False, allow_multisel=True,
        prior_selection_paths=None, prim_mask=None, path_prefix_mask=None,
        prim_kind=None, hotkey=\\"\\", name=\\"\\")

            Binds a scene graph selector to a SOP viewer state. This selector is
            used for selecting scene graph elements when the underlying viewer
            state is active. This selector can only be bound used in a scene
            graph viewer, exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple scene graph selectors can be bound to a viewer state.
            However, other selector types cannot be mixed with scene graph
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of element paths stored in the selection entry of the input kwargs
            dictionary. The return value can be True to keep running the
            selection tool or False to stop it. Pressing [Enter] also terminates
            the selector.


            allow_drag
                Allows the selection to be completed with a single mouse click.
                Defaults to True.

            allow_multisel
                Allows the tool to select multiple elements. Defaults to True.

            auto_start
                Start the selector when the viewer state is activated. True by
                default.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            consume_selection
                If True, clears the current selection when the selector is
                deactivated. Defaults to False.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is None. See
                hou.ViewerStateTemplate.bindGeometrySelector for an example on
                how to create an hotkey symbol.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            path_prefix_mask
                Filter out selectable elements by a name prefix. Empty by
                default.

            prim_kind
                Primitive kind to highlight. Empty by default.

            prim_mask
                Filter mask for the selection (hou.scenePrimMask). Defaults to
                hou.scenePrimMask.ViewerSetting

            prior_selection_paths
                Array of element paths to pre-select.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                Configure the selector to use quick selections. When True the
                selection callback is called automatically for each selection,
                if False the user must hit \'enter\' to complete the selection.
                Defaults to True.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer\'s secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If True, the selector uses the existing selection. Defaults to
                True.


        '''
    def bindDynamicsSelector(self, prompt: str, allow_objects: bool = ..., allow_modifiers: bool = ..., quick_select: bool = ..., auto_start: bool = ..., toolbox: bool = ..., use_existing_selection: bool = ..., secure_selection: EnumValue = ..., allow_multisel: bool = ..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindDynamicsSelector(self, prompt, allow_objects=True,
        allow_modifiers=False, quick_select=True, auto_start=True, toolbox=True,
        use_existing_selection=True,
        secure_selection=hou.secureSelectionOption.Obey, allow_multisel=True,
        hotkey=\\"\\", name=\\"\\")

            Binds a dynamics selector to a DOP viewer state. This selector is
            used for selecting dynamics objects and modifiers when the
            underlying viewer state is active. This selector can only be used in
            a scene viewer, exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple dynamics, point and polygon selectors can be bound to a
            viewer state. However, other selector types cannot be mixed with DOP
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of hou.DopData objects stored in the selection entry of the input
            kwargs dictionary. The return value can be True to stop the
            selection tool or False to keep it running. Pressing [Enter] also
            terminates the selector.


            allow_modifiers
                Allows the tool to select simulation modifiers. Exception is
                thrown if allow_modifiers and allow_objects are both set to
                False. Default to False.

            allow_multisel
                Allows the tool to select multiple elements. Defaults to True.

            allow_objects
                Allows object selection. Exception is thrown if allow_modifiers
                and allow_objects are both set to False. Defaults to True.

            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is None. See
                hou.ViewerStateTemplate.bindGeometrySelector for an example on
                how to create an hotkey symbol.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state\'s selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer\'s secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.


        '''
    def bindDynamicsPointSelector(self, prompt: str, allow_objects: bool = ..., allow_modifiers: bool = ..., quick_select: bool = ..., auto_start: bool = ..., toolbox: bool = ..., use_existing_selection: bool = ..., secure_selection: EnumValue = ..., allow_multisel: bool = ..., only_select_points: bool = ..., object_based_point_selection: bool = ..., use_last_selected_object: bool = ..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindDynamicsPointSelector(self, prompt, allow_objects=True,
        allow_modifiers=False, quick_select=True, auto_start=True, toolbox=True,
        use_existing_selection=True,
        secure_selection=hou.secureSelectionOption.Obey, allow_multisel=True,
        only_select_points=True, object_based_point_selection=False,
        use_last_selected_object=False, hotkey=\\"\\", name=\\"\\")

            Binds a dynamics point selector to a DOP viewer state. This selector
            is used for selecting point elements when the underlying viewer
            state is active. This selector can only be used in a scene viewer,
            exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple dynamics, polygon and point selectors can be bound to a
            viewer state. However, other selector types cannot be mixed with DOP
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of (hou.DopData,hou.GeometrySelection) tuples stored in the
            selection entry of the input kwargs dictionary. The return value can
            be True to stop the selection tool or False to keep it running.
            Pressing [Enter] also terminates the selector.


            allow_modifiers
                Allows the tool to select simulation modifiers. Default to
                False.

            allow_multisel
                Allows the tool to select multiple elements. Defaults to True.

            allow_objects
                Allows object selection. Defaults to True.

            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is None. See
                hou.ViewerStateTemplate.bindGeometrySelector for an example on
                how to create an hotkey symbol.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            object_based_point_selection
                Force selection of points on the currently selected object
                instead of the default selection of points on the closest
                object. Default to False.

            only_select_points
                Default to True.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state\'s selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer\'s secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.

            use_last_selected_object
                Force point selection to only be possible on the specified
                object and do not allow selection of a different object. Default
                to False.


        '''
    def bindDynamicsPolygonSelector(self, prompt: str, quick_select: bool = ..., auto_start: bool = ..., toolbox: bool = ..., use_existing_selection: bool = ..., object_based_point_selection: bool = ..., secure_selection: EnumValue = ..., use_last_selected_object: bool = ..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindDynamicsPolygonSelector(self, prompt, quick_select=True,
        auto_start=True, toolbox=True, use_existing_selection=True,
        object_based_point_selection=False,
        secure_selection=hou.secureSelectionOption.Obey,
        use_last_selected_object=False, hotkey=\\"\\", name=\\"\\")

            Binds a dynamics polygon selector to a DOP viewer state. This
            selector is used for selecting polygon elements when the underlying
            viewer state is active. This selector can only be used in a scene
            viewer, exception is thrown otherwise at registration
            (hou.ui.registerViewerStateTemplate).

            Multiple dynamics, point and polygon selectors can be bound to a
            viewer state. However, other selector types cannot be mixed with DOP
            selectors, exception is thrown otherwise.

            The viewer state plug-in can implement the onSelection method to
            receive new selections. onSelection gets the new selection as a list
            of (hou.DopData,hou.GeometrySelection) tuples stored in the
            selection entry of the input kwargs dictionary. The return value can
            be True to stop the selection tool or False to keep it running.
            Pressing [Enter] also terminates the selector.


            auto_start
                If True (the default), start the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is None. See
                hou.ViewerStateTemplate.bindGeometrySelector for an example on
                how to create an hotkey symbol.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            object_based_point_selection
                Force selection of points on the currently selected object
                instead of the default selection of points on the closest
                object. Default to False.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.

            quick_select
                If this is True, the state\'s selection event is called whenever
                the selection changes. If this is False, Houdini waits for the
                user to finish selection by pressing [Enter] before it notifies
                the state about the new selection.

            secure_selection
                This option is used to configure the selector for secure
                selection. By default, the selector always obey the current
                viewer\'s secure selection setting. For more details see Secure
                selection support and hou.secureSelectionOption.

            use_existing_selection
                If this is True, and a component selection exists when the user
                activates the state, Houdini will call onSelection with that
                selection. If this is False, Houdini will clear any existing
                selection and ask for a new selection.

            use_last_selected_object
                Force polygon selection to only be possible on the specified
                object and do not allow selection of a different object. Default
                to False.


        '''
    def bindDrawableSelector(self, prompt: str, auto_start: bool = ..., toolbox: bool = ..., drawable_mask=..., hotkey: str = ..., name: str = ...) -> None:
        '''

        bindDrawableSelector(self, prompt, auto_start=True, toolbox=True,
        drawable_mask=[], hotkey=\\"\\", name=\\"\\")

            Binds a drawable selector to a viewer state to select drawable
            components such as points, faces and lines. Drawable selectors are
            supported for the SOP, OBJ and LOP contexts. The selector selects
            components of drawables created by the viewer state, a mask can be
            used to make specific drawables selectable. Drawables created by the
            viewer state not in the mask are ignored by the selector.

            A selection event is triggered whenever the selection changes, the
            onSelection handler can be implemented by the viewer state plug-in
            to receive new selections. The locate information is sent to the
            viewer state whenever the mouse is positioned over drawable
            components, the onLocateSelection handler can be implemented by the
            viewer state plug-in to receive new drawable locate information. The
            viewer state typically uses these handlers for drawing the located
            and selected drawable components. See Binding a drawable selector
            for more details.


            auto_start
                If True (the default), starts the selector when the viewer state
                is activated. If False, you must specify a hotkey argument that
                activates the selector.

            toolbox
                If True (the default), the selector toolbox is displayed when
                the selector is activated. If False, the selector toolbox will
                be hidden.

            hotkey
                An optional hotkey symbol which acts as a switch for starting or
                stopping the selector. The default is None. See
                hou.ViewerStateTemplate.bindGeometrySelector for an example on
                how to create an hotkey symbol.

            name
                Optional name identifier (None by default) for the selector,
                must be unique within the viewer state. The name is used for
                triggering selector operations.

            drawable_mask
                A list of drawable names representing selectable drawables. By
                default (empty list) all drawables created by a python state are
                selectable.

            prompt
                Prompt displayed in the viewport when the selector is active.
                The prompt is mandatory.


        '''
    def bindSelector(self, name, selector_type, prompt: str, primitive_types: Sequence[EnumValue] = ..., group_parm_name: str = ..., input_index=..., input_required: bool = ..., allow_dragging: bool = ...) -> None:
        """

        bindSelector(self, name, selector_type, prompt, primitive_types=None,
        group_parm_name=None, input_index=0, input_required=True,
        allow_dragging=True)

            Binds a selector to the digital asset tied to this viewer state. You
            can bind multiple selectors to the same viewer state.

            These selectors are typically used by the shelf tool of the digital
            asset to create new instances of the SOP nodes. Houdini will invoke
            all bounded selectors, wait for the user to select geometries, and
            then connect the input SOPs and fill in group parameters to match
            what was selected.

            This kind of selector is different from the ones created with
            hou.ViewerStateTemplate.bindGeometrySelector or
            hou.ViewerStateTemplate.bindObjectSelector. They are strictly used
            by Houdini and cannot be triggered with
            hou.SceneViewer.triggerStateSelector.


            name
                A unique selector name identifier.

            selector_type
                The type of the selector to bind. The following types are
                supported:

                prims

                Select only primitives.

                points

                Select only points.

                edges

                Select only edges.

                everything

                Select any geometries.

            prompt
                Prompt displayed in the viewport to instruct the user what to
                select. The prompt is mandatory.

            primitive_types
                Specify the type of selectable primitives (hou.primType).
                Defaults to all types.

            group_parm_name
                The name of the SOP node parameter containing the group field.
                The selector will set this parameter to the string representing
                the points, primitives, edges, etc. chosen by the user in the
                viewer. If None, the selector will look for a parameter named
                group.

            input_index
                The index of the input connector on the SOP node where the
                selector should wire input SOPs. A cookie SOP, for example, has
                two input connectors. It has two selectors, one for each input
                connector. Defaults to 0.

            input_required
                Specify if an input is required or not. If the user does not
                select any geometry and the input is not required, the selector
                will not wire anything to its input connector. Defaults to True.

            allow_dragging
                Determines if click-and-drag operations are allowed. Click-and-
                drag operations select the geometry and begin manipulating the
                handles with a single mouse drag. Dragging the geometry forces
                the selector to finish immediately, the selector connects the
                input and sets the group parameter, and subsequent mouse
                movements are passed to the handle which translates the geometry
                by changing parameter values. Defaults to True.


        """
    def bindMenu(self, menu: ViewerStateMenu) -> None: ...
    def bindIcon(self, name: str) -> None:
        '''

        bindIcon(self, icon_name)

            Sets the icon image of this viewer state.


            icon_name
                The name of the icon. Defaults to MISC_python. The icon name can
                be specified as follows:

              * As a single name.

              * As a path to the image icon file on disk. There is no convention
                for where to put icon files on disk.

                    eg.

                  > template.bindIcon(\\"$HOUDINI_USER_PREF_DIR/config/Icons/myicon.pic\\")

              * As an opdef path if the viewer state is implemented in a Digital
                Asset.

                    eg.

                  > template.bindIcon(\\"opdef:/Object/myop?myicon.pic\\")

        '''
    def bindSupportsSelectionChange(self, supports_change: bool) -> None:
        """

        bindSupportsSelectionChange(self, supports_change)

            Indicates to the LOP Viewer pane that this state can handle USD
            primitive selection changes. The state for the Edit LOP is a good
            example of such a state. Changing the primitive selection in the
            scene graph tree causes this node to move the handle to the new
            selection's centroid and start manipulating the newly selected
            primitives.


        """
    def bindSupportsMoveTool(self, supports_movetool: bool) -> None:
        """

        bindSupportsMoveTool(self, supports_movetool)

            Obsolete. This method has no effect, and has no replacement.


        """
    def bindPlaybackChangeEvent(self) -> None:
        """

        bindPlaybackChangeEvent(self)

            Binds an event handler to the state for listening to playbar events
            such as hou.playbarEvent.Started and hou.playbarEvent.FrameChanged.
            The state must implement onPlaybackChangeEvent to respond to
            playback events. bindPlaybackChangeEvent is similar to
            hou.playbar.addEventCallback` but you don't need to provide a
            callback or to remove it when the state exits, Houdini takes care of
            it for you.


        """
    def bindNodeChangeEvent(self, event_types: Sequence[EnumValue]) -> None:
        """

        bindNodeChangeEvent(self, event_types)

            Binds an event handler to the state for listening to a particular
            event that occurs on the state's node instance. onNodeChangeEvent
            must be implemented by the state to respond to events.

            Binding a node event is similar to hou.OpNode.addEventCallback, but
            there is no need to provide a callback or to remove it by yourself
            when the state exits, Houdini takes care of it for you.


            event_types
                A list of hou.nodeEventType enumeration values describing the
                event types to listen to.

                An error is raised if the list is empty.


        """
    def bindNodeParmChangeEvent(self, parm_names: Sequence[str]) -> None:
        """

        bindNodeParmChangeEvent(self, parm_names)

            Binds an event handler to the state for listening to parm changes
            occuring on the state's node. onNodeChangeEvent must be implemented
            by the state to respond to parm events. This method is similar to
            hou.OpNode.addParmCallback, it's considered more efficient than
            bindNodeChangeEvent as Houdini will trigger onNodeChangeEvent only
            for the changes that occurs for the parms you want to track.


            parm_names
                A list of node parm names used by Houdini for filtering out the
                parm changes that occur on the state's node. Only the changes
                that match the parms specified in parm_names are sent to
                onNodeChangeEvent.

                An error is raised if the list is empty.


        """
    def bindHotkeyDefinitions(self, definitions: PluginHotkeyDefinitions) -> None:
        """

        bindHotkeyDefinitions(self, definitions)

            Binds a hotkey definitions object to this viewer state that defines
            the hotkey commands and contexts implemented by the state. You can
            only bind one such definitions object per template.


            definitions
                The hou.PluginHotkeyDefinitions object to add.


        """
    def serializeParameters(self, value: bool) -> None:
        """

        serializeParameters(self, value)

            Enables or disables the serialization of state parameters. When
            enabled, parameters are stored on the state's node when the state
            exits. Upon re-entry, the state is initialized with the serialized
            parameters instead of the default parameter values. Since the
            state's node is saved with the HIP file, the serialized parameters
            are restored when the HIP file is loaded.

            Node-less states are also supported. In this case, the parameters
            are serialized to a file located in the user's viewer state folder.
            The filename follows this format:

          > $HOUDINI_USER_PREF_DIR/viewer_states/<viewer state type name>_cache.json

            NOTE
                State parameters are not serialized by default.


            value
                Enables the serialization mechanism if True or disables it if
                False.


        """
    def bindFactory(self, callback: Callable[[str, SceneViewer], Any]) -> Any:
        '''

        bindFactory(self, callable)

            Takes a callable object (such as a class or function) that returns
            an implementation of the state interface. Usually this will be a
            class (a Python class is a callable object which returns an instance
            of the class). The callable should accept two arguments: a string
            containing the name of the state, and a hou.SceneViewer object
            representing the current viewer.

          > class MyState(object):
          >     def __init__(self, state_name, scene_viewer):
          >         self.state_name = state_name
          >         self.scene_viewer = scene_viewer
          > 
          >     def onMouseEvent(sefl, kwargs):
          >         ui_event = kwargs[\\"ui_event\\"]
          > 
          > 
          > def createViewerTemplate(*args):
          >     template = hou.ViewerStateTemplate(\\"mystate\\", \\"My State\\", hou.sopNodeTypeCategory())
          >     template.bindFactory(MyState)
          >     return template

        '''

class Viewport2D:
    """

    hou.Viewport2D

    Represents a viewport for viewing COP images within a 2D viewer, such as
    the Compositor Viewer.

    This class models a viewport in the Compositor View that displays
    elements in an XY orientation.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def name(self) -> str:
        """

        name(self) -> string

            Return the display name of the viewport.


        """
    def draw(self) -> None:
        """

        draw(self)

            Requests the viewport to redraw its contents. Multiple calls to
            draw() within the same script execution will be coalesced into a
            single redraw operation for efficiency.


        """
    def cameraToModelTransform(self) -> Matrix4:
        """

        cameraToModelTransform(self) -> hou.Matrix4

            Returns the transformation matrix that converts coordinates from the
            viewport's camera space into the local model space of the displayed
            elements.


        """
    def mapToScreen(self, pos: Vector3) -> Vector2:
        """

        mapToScreen(self, position) -> hou.Vector2

            Converts a world-space position to Compositor screen space
            coordinates as a hou.Vector2 object.


            position
                A hou.Vector3 representing the world-space position to convert.


        """
    def mapToBuffer(self, pos: Vector2, clamp: bool = True) -> Vector2:
        """

        mapToBuffer(self, mouse_position) -> hou.Vector2

            Converts a mouse position to buffer coordinates as a hou.Vector2
            object.


            position
                A hou.Vector2 representing cursor position.


        """
    def mapToWorld(self, x: float, y: float) -> Tuple[Vector3, Vector3]:
        """

        mapToWorld(self, x, y) -> tuple of (hou.Vector3, hou.Vector3)

            Converts Compositor screen space position to world-space position.
            Returns a ray direction vector and a world position. The direction
            vector is computed from center view to world position.


            x
                The world-space X-position to convert.

            y
                The world-space Y-position to convert.


        """
    def geometry(self) -> Tuple[int, ...]:
        """

        geometry(self) -> tuple of int

            Returns the position and dimensions of this viewport within the UI
            space. The tuple elements represent viewport coordinates relative to
            the lower-left corner of the Compositor Viewer.

            Returned tuple:

             1. X-coordinate of the lower-left corner.

             2. Y-coordinate of the lower-left corner.

             3. Width of the viewport.

             4. Height of the viewport.


        """

class ViewportVisualizer:
    """

    hou.ViewportVisualizer

    Represents a viewport visualizer.

    You can create a new visualizer by calling
    hou.viewportVisualizers.createVisualizer. You can get a list of
    registered visualizers by calling hou.viewportVisualizers.visualizers.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def name(self) -> str:
        """

        name(self) -> string

            Return the visualizer's unique identifier.


        """
    def setName(self, name: str) -> None:
        """

        setName(self, name)

            Set the visualizer's unique identifier.


        """
    def label(self) -> str:
        """

        label(self) -> string

            Return the visualizer's user-friendly label.


        """
    def setLabel(self, label: str) -> None:
        """

        setLabel(self, label)

            Set the visualizer's user-friendly label.


        """
    def icon(self) -> str:
        """

        icon(self) -> string

            Return the name of the visualizer's icon.


        """
    def setIcon(self, icon: str) -> None:
        """

        setIcon(self, icon)

            Set the visualizer's icon. icon must be the icon name.


        """
    def isActive(self, viewport: Optional[GeometryViewport] = None) -> bool:
        """

        isActive(self, viewport=None) -> bool

            If this is a Common or Scene visualizer then return True if it is
            active for the specified viewport or False otherwise. The viewport
            argument must be a hou.GeometryViewport object.

            If this is a Node visualizer then return True if it is active for
            all viewports and False otherwise.

            Raise TypeError if this is a Node visualizer and the viewport
            argument is not None. Node visualizers are either active in all
            viewports or none of them. They cannot be activated for a specific
            viewport.

            Raise TypeError if this is either a Common or Scene visualizer and
            the viewport argument is None.


        """
    def setIsActive(self, on: bool, viewport: Optional[GeometryViewport] = None) -> None:
        """

        setIsActive(self, on, viewport=None)

            If this is a Common or Scene visualizer then set whether it is
            active or not for a specified viewport. The viewport argument must
            be a hou.GeometryViewport object.

            If this is a Node visualizer then set whether it is active or not
            for all viewports.

            Raise TypeError if this is a Node visualizer and the viewport
            argument is not None. Node visualizers are either active in all
            viewports or none of them. They cannot be activated for a specific
            viewport.

            Raise TypeError if this is either a Common or Scene visualizer and
            the viewport argument is None.


        """
    def type(self) -> ViewportVisualizerType:
        """

        type(self) -> hou.ViewportVisualizerType

            Return the visualizer's type.


        """
    def setType(self, type: ViewportVisualizerType) -> None:
        """

        setType(self, type)

            Sets the visualizer's type. This essentially recreates the
            visualizer and rebuilds its customizable parameters. Call
            hou.ViewportVisualizer.parmNames to get a list of the parameters.


        """
    def category(self) -> EnumValue:
        """

        category(self) -> hou.viewportVisualizerCategory

            Return the category that the visualizer belongs to.


        """
    def categoryNode(self) -> Optional[Node]:
        """

        categoryNode(self) -> hou.OpNode

            Return the node that the visualizer is installed on. This only
            applies if the visualizer belongs to the Node category.

            Return None if the visualizer belongs to either the Common or Scene
            category.


        """
    def scope(self) -> EnumValue:
        """

        scope(self) -> hou.viewportVisualizerScope

            Return the scope of geometries that the visualizer affects.


        """
    def setScope(self, scope: EnumValue) -> None:
        """

        setScope(self, scope)

            Set the scope of geometries that the visualizer affects.

            This method does nothing if the visualizer belongs to the Common or
            Scene because the scope is always global.


        """
    def isShownInToolbar(self) -> bool:
        """

        isShownInToolbar(self) -> bool

            Return True if the visualizer appears in the viewer pane's toolbar.
            Return False otherwise.


        """
    def showInToolbar(self, on: bool) -> None:
        """

        showInToolbar(self, on)

            Set whether the visualizer appears in the viewer pane's toolbar.


        """
    def isActiveWhenUnselected(self) -> bool:
        """

        isActiveWhenUnselected(self) -> bool

            Return True if the visualizer is applied when the geometry is
            unselected. Return False otherwise.


        """
    def setIsActiveWhenUnselected(self, on: bool) -> None:
        """

        setIsActiveWhenUnselected(self, on)

            Set whether the visualizer is applied when the geometry is
            unselected.


        """
    def isActiveWhenSelected(self) -> bool:
        """

        isActiveWhenSelected(self) -> bool

            Return True if the visualizer is applied when the geometry is
            selected. Return False otherwise.


        """
    def setIsActiveWhenSelected(self, on: bool) -> None:
        """

        setIsActiveWhenSelected(self, on)

            Set whether the visualizer is applied when the geometry is selected.


        """
    def isActiveWhenGhosted(self) -> bool:
        """

        isActiveWhenGhosted(self) -> bool

            Return True if the visualizer is applied when the geometry is
            ghosted. Return False otherwise.


        """
    def setIsActiveWhenGhosted(self, on: bool) -> None:
        """

        setIsActiveWhenGhosted(self, on)

            Set whether the visualizer is applied when the geometry is ghosted.


        """
    def isActiveWhenDisplayed(self) -> bool:
        """

        isActiveWhenDisplayed(self) -> bool

            Return True if the visualizer is applied when the geometry is
            displayed. Return False otherwise.


        """
    def setIsActiveWhenDisplayed(self, on: bool) -> None:
        """

        setIsActiveWhenDisplayed(self, on)

            Set whether the visualizer is applied when the geometry is
            displayed.


        """
    def isActiveWhenCurrent(self) -> bool:
        """

        isActiveWhenCurrent(self) -> bool

            Return True if the visualizer is applied when the geometry is the
            current geometry. Return False otherwise.


        """
    def setIsActiveWhenCurrent(self, on: bool) -> None:
        """

        setIsActiveWhenCurrent(self, on)

            Set whether the visualizer is applied when the geometry is the
            current geometry.


        """
    def isActiveWhenTemplated(self) -> bool:
        """

        isActiveWhenTemplated(self) -> bool

            Return True if the visualizer is applied when the geometry is
            templated.


        """
    def setIsActiveWhenTemplated(self, on: bool) -> None:
        """

        setIsActiveWhenTemplated(self, on)

            Set whether the visualizer is applied when the geometry is
            templated.


        """
    def parmNames(self) -> Tuple[str, ...]:
        """

        parmNames(self) -> tuple of string

            Return a tuple of the visualizer's customizable parameters. Note
            that the parameters can change when either the visualizer's type
            changes or one of the parameters changes (for example changing the
            Color Type parameter on a color visualizer).


        """
    def evalParmAsFloat(self, parm_name: str) -> float:
        """

        evalParmAsFloat(self, parm_name) -> float

            Evaluate the specified parameter and return the result as a float.

            Raise TypeError if the value cannot be converted to a float.


        """
    def evalParmAsInt(self, parm_name: str) -> int:
        """

        evalParmAsInt(self, parm_name) -> int

            Evaluate the specified parameter and return the result as an
            integer.

            Raise TypeError if the value cannot be converted to a integer.


        """
    def evalParmAsString(self, parm_name: str) -> str:
        """

        evalParmAsString(self, parm_name) -> int

            Evaluate the specified parameter and return the result as a string.

            Raise TypeError if the value cannot be converted to a string.


        """
    def evalParmAsRamp(self, parm_name: str) -> Ramp:
        """

        evalParmAsRamp(self) -> hou.Ramp

            Evalute the specified parameter and return the result as a ramp.

            Raises TypeError if the parameter is not a ramp.


        """
    def evalParm(self, parm_name: str) -> int | float | str:
        """

        evalParm(self, parm_name) -> int, float, or str

            Evaluate the specified parameter and return the result.


        """
    def setParm(self, parm_name: str, value: int|float|str) -> None:
        """

        setParm(self, parm_name, value)

            Set the specified parameter's value.

            Pass in a hou.Ramp object, as the parameter value, to set the value
            of a ramp parameter. The ramp object's type needs to match the
            target ramp's type.

            Raise TypeError if the type of value does not match the type of the
            specified parameter.


        """
    def destroy(self) -> None:
        """

        destroy(self)

            Delete this viewport visualizer.

            If you call methods on a visualizer instance after it has been
            destroyed, Houdini will raise hou.ObjectWasDeleted.


        """

class viewportVisualizers:
    """

    hou.viewportVisualizers

    Module containing viewport visualizer functionality.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    @staticmethod
    def visualizers(category: EnumValue = ..., node: Node|None = ...) -> Tuple[ViewportVisualizer,...]:
        """

        visualizers(category=hou.viewportVisualizerCategory.Common, node=None)
        -> tuple of hou.ViewportVisualizer

            Return a tuple of viewport visualizers registered with Houdini for
            the given category.

            The category argument must be a hou.viewportVisualizerCategory enum
            value. If the category is set to Node, then the node argument must
            be specified.

            Raise TypeError if the category is set to Common or Scene and the
            node argument is also set. Raise TypeError if the category is set to
            Node and the node argument is set to None.


        """
    @staticmethod
    def createVisualizer(type: EnumValue, category: EnumValue = ..., node: Node|None = ...) -> ViewportVisualizer:
        """

        createVisualizer(type, category=hou.viewportVisualizerCategory.Common,
        node=None) -> hou.ViewportVisualizer

            Create a new viewport visualizer for the specified type.

            The type argument must be a hou.ViewportVisualizerType. You can
            retrieve a visualizer type by calling hou.viewportVisualizers.types
            or hou.viewportVisualizers.type.

            The category argument must be a hou.viewportVisualizerCategory enum
            value. If the category is set to Node, then the node argument must
            be specified.

            Raise TypeError if the category is set to Common or Scene and the
            node argument is also set. Raise TypeError if the category is set to
            Node and the node argument is set to None.


        """
    @staticmethod
    def copyVisualizer(source: ViewportVisualizer) -> Optional[ViewportVisualizer]:
        """

        copyVisualizer(source) -> hou.ViewportVisualizer

            Create a duplicate of the specified source visualizer.


        """
    @staticmethod
    def types() -> Tuple[ViewportVisualizerType, ...]:
        """

        types() -> tuple of hou.ViewportVisualizerType

            Return a tuple of visualizer types registered with Houdini.


        """
    @staticmethod
    def type(name: str) -> Optional[ViewportVisualizerType]:
        """

        type(name) -> hou.ViewportVisualizerType

            Return the visualizer type registered with the specified name.
            Return None if no such type exists.


        """
    @staticmethod
    def isCategoryActive(category: EnumValue, node: Optional[Node] = None, viewport: Optional[GeometryViewport] = None) -> bool:
        """

        isCategoryActive(category, node=None, viewport=None) -> bool

            Return True if the visualizer category is active and False
            otherwise. For Common and Scene categories return True if it is
            active for the specified viewport. The viewport argument must be a
            hou.GeometryViewport.

            Raise TypeError if category is set to Common or Scene and the node
            argument is also set. Raise TypeError if category is set to Node and
            the node argument is set to None. Raise TypeError if both the node
            and viewport arguments are set. Node visualizers are either active
            in all viewports or none of them. They cannot be activated for a
            specific viewport.


        """
    @staticmethod
    def setIsCategoryActive(on: bool, category: EnumValue, node: Optional[Node] = None, viewport: Optional[GeometryViewport] = None) -> None:
        """

        setIsCategoryActive(on, category, node=None, viewport=None) -> bool

            Set the activation state of the specified visualizer category. For
            Common and Scene categories the activation state must be set for a
            specific viewport. The viewport argument must be a
            hou.GeometryViewport.

            Raise TypeError if category is set to Common or Scene and the node
            argument is also set. Raise TypeError if category is set to Node and
            the node argument is set to None. Raise TypeError if both the node
            and viewport arguments are set. Node visualizers are either active
            in all viewports or none of them. They cannot be activated for a
            specific viewport.


        """
    @staticmethod
    def visualizerBySessionId(session_id: int) -> Optional[ViewportVisualizer]:
        """

        visualizerBySessionId(session_id) -> hou.ViewportVisualizer

            Given a visualizer's session id, return a ViewportVisualizer object.
            Return None if the id does not correspond to a valid visualizer.


            NOTE
                This function is for internal use by Houdini and isn't usually
                necessary for scripting Houdini or creating tools.


        """
    @staticmethod
    def removeAllEventCallbacks(self, category: EnumValue = ..., node: Node|None = ...) -> None:
        """

        removeAllEventCallbacks(self,
        category=hou.viewportVisualizerCategory.Common, node=None)

            Remove all event callbacks for all event types from this category.

            See hou.viewportVisualizers.addEventCallback for more information.


        """
    @staticmethod
    def addEventCallback(self, event_types: EnumValue, callback: Callable, category: EnumValue = ..., node: Node|None = ...) -> None:
        '''

        addEventCallback(self, event_types, callback,
        category=hou.viewportVisualizerCategory.Common, node=None)

            Register a Python callback that Houdini will call whenever a
            particular action, or event, occurs related to a particular
            visualizer category.


            event_types
                A sequence of hou.viewportVisualizerEventType enumeration values
                describing the event types that will cause Houdini to call the
                callback function.

            callback
                A callable Python object, such as a function or bound method.
                Houdini will call this function whenever one of the event types
                in event_types occurs.

                Houdini calls the function with an event_type keyword argument
                containing the hou.nodeEventType value corresponding to the
                event that triggered the callback.

                Houdini will pass additional keyword arguments depending on the
                event type. For example, in a callback for the
                VisualizerParmsChanged event, Houdini will pass a visualizer
                keyword argument containing a hou.ViewportVisualizer reference
                to the visualizer that changed. See
                hou.viewportVisualizerEventType for the extra arguments (if any)
                passed for each event type.

                You can add **kwargs to the argument list to accept all keyword
                arguments, to allow the same callback to be used for different
                events, or to be safe from future changes:

              > def event_callback(event_type, **kwargs):
              >     ...

            NOTE
                If you try to add the exact same callback function more than
                once, Houdini will still only call the function only once in
                response to an event. However, it may be useful to add the same
                function if you want to register it with different event_types.

            Raises hou.OperationFailed if the event_types list argument is
            empty.

            The following example shows to set up a function that\'s called
            whenever any parameter on a visualizer in the Common category
            changes:

          > 
          > def parm_changed(event_type, **kwargs):
          >     print(\\"The parms have changed on \\", kwargs[\'visualizer\'])
          > 
          > hou.viewportVisualizers.addEventCallback((hou.viewportVisualizerEventType.VisualizeParmsChanged.NameChanged, ), parm_changed)

            See also hou.viewportVisualizers.removeEventCallback and
            hou.viewportVisualizers.removeAllEventCallbacks.


        '''
    @staticmethod
    def removeEventCallback(self, event_types: Sequence[EnumValue], callback: Callable, category: EnumValue = ..., node: Node|None = ...) -> None:
        """

        removeEventCallback(self, event_types, callback,
        category=hou.viewportVisualizerCategory.Common, node=None)

            Given a callback that was previously added on this category and a
            sequence of hou.viewportVisualizerEventType enumerated values,
            remove those event types from the set of event types for the
            callback. If the remaining set of event types is empty, the callback
            will be removed entirely from this node.

            Raises hou.OperationFailed if the callback had not been previously
            added.

            See hou.viewportVisualizers.addEventCallback for more information.


        """
    @staticmethod
    def eventCallbacks(category: EnumValue = ..., node: Node|None = ...) -> Sequence[Tuple[Sequence[EnumValue], Callable]]:
        """

        eventCallbacks(category=hou.viewportVisualizerCategory.Common,
        node=None) -> tuple of (tuple of hou.viewportVisualizersEvent, callback)

            Return a tuple of all the Python callbacks that have been registered
            with this category with calls to
            hou.viewportVisualizers.addEventCallback.


        """

class ViewportVisualizerType:
    """

    hou.ViewportVisualizerType

    Represents a viewport visualizer type.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def name(self) -> str:
        """

        name(self) -> string

            Return the visualizer type's unique identifier.


        """
    def description(self) -> str:
        """

        description(self) -> string

            Return a brief description of the visualizer type.


        """
    def icon(self) -> str:
        """

        icon(self) -> string

            Return the name of the type's icon.


        """

class Volume(Prim):
    """

    hou.Volume

    A Volume is a kind geometry primitive (Prim object) storing a three
    dimensional array of voxels.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def storageType(self) -> EnumValue:
        """

        storageType(self) -> hou.volumeStorageType enum value

            Returns the volume's storage type, which consists of its precision
            and float vs integer type.


        """
    def channelCount(self) -> int:
        """

        channelCount(self) -> int

            Returns the number of components, or channels, in the volume.


        """
    def visualization(self) -> EnumValue:
        """

        visualization(self) -> hou.volumeVisualization enum value

            Returns the volume's visualization mode. This is used by the
            viewport to determine how display the volume.


        """
    def sample(self, position: Sequence[float]) -> float:
        """

        sample(self, position) -> float

            Given a sequence of three floats containing a 3D position, return
            the value of the volume at that position. If the position is not in
            the middle of a voxel, Houdini will interpolate using values from
            surrounding voxels.

            See also hou.Volume.voxel and hou.Volume.posToIndex.


        """
    def gradient(self, position: Sequence[float]) -> Vector3:
        """

        gradient(self, position) -> hou.Vector3

            Given a sequence of three floats containing a 3D position, return a
            vector which points in the direction of the greatest rate of
            increase of the volume's value.

            See Wikipedia's gradient page for more information.


        """
    def voxel(self, index: Sequence[int]) -> float:
        '''

        voxel(self, index) -> float

            Given a sequence of three integers containing a voxel index, return
            the value of the corresponding voxel.

          > >>> volume_sop = hou.node(\\"/obj\\").createNode(\\"geo\\").createNode(\\"volume\\")
          > >>> volume_sop.parm(\\"initialval1\\").set(0.3)
          > >>> volume = volume_sop.geometry().prims()[0]
          > >>> volume.resolution()
          > (10, 10, 10)
          > >>> volume.voxel((0, 0, 0))
          > 0.3

        '''
    def setVoxel(self, index: Sequence[int], value: float) -> None:
        """

        setVoxel(self, index, value)

            Set the value of a voxel. You would typically call this method from
            the code of a Python-defined SOP.


            index
                A sequence of three integers containing a voxel index. Raises
                hou.OperationFailed if any of the values in index are out of
                range.

            value
                A float containing the voxel's new value.

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.


        """
    def allVoxels(self) -> Tuple[float, ...]:
        """

        allVoxels(self) -> tuple of float

            Return a tuple of floats containing the values of all voxels. It is
            faster to call this method to retrieve all the voxels than it is to
            loop through the voxel array in Python.

            You can, for example, use Python's Numpy library to perform
            operations on the voxel data and then store the result back into the
            volume from a Python SOP using hou.Volume.setAllVoxels. Note that
            Numpy allows you to reshape the flat tuple of floats to behave like
            a 3D matrix of floats.

            This method can be approximately implemented as follows (though this
            Python implementation is much slower):

          > def allVoxels(self):
          >     result = []
          >     xres, yres, zres = self.resolution()
          >     for z in range(zres):
          >         for y in range(yres):
          >             for x in range(xres):
          >                 result.append(self.voxel((x, y, z)))
          >     return tuple(result)

            See also hou.Volume.allVoxelsAsString,
            hou.Geometry.pointFloatAttribValues, and
            hou.Geometry.primFloatAttribValues.


        """
    def allVoxelsAsString(self) -> bytes:
        '''

        allVoxelsAsString(self) -> str for Python 2, bytes for Python 3

            Return a binary string representation of the floats containing all
            the values of all voxels. This method is faster than
            hou.Volume.allVoxels, and you can use the array module to convert
            the string into a Python sequence.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            This method provides a faster implementation of the following:

          > import array
          > def allVoxelsAsString(self):
          >     return array.array(\\"f\\", self.allVoxels()).tostring()

            For scalar volumes, you can convert the return value from this
            method to an array using the following method:

          > import array
          > def allVoxelsAsArray(volume):
          >     a = array.array(\\"f\\")
          >     a.fromstring(volume.allVoxelsAsString())
          >     return a

            Multi-channel volumes will interleave the channels and be
            correspondingly longer. Integer volumes output the integer values as
            64-bit integers.

            See hou.Volume.allVoxels for more information.


        '''
    def setAllVoxels(self, values: Sequence[float]) -> None:
        """

        setAllVoxels(self, values)

            Set the value of all voxels in this volume. You would typically call
            this method from the code of a Python-defined SOP.

            Raises hou.OperationFailed if the sequence of values is not exactly
            the same as self.resolution()[0] * self.resolution()[1] *
            self.resolution()[2].

            Raises hou.GeometryPermissionError if this geometry is not
            modifiable.

            See also hou.Volume.allVoxels.


        """
    def setAllVoxelsFromString(self, values: bytes) -> None:
        '''

        setAllVoxelsFromString(self, values)

            Set the value of all voxels in this volume from a string
            representation of a sequence of single precision float values. This
            method is faster than hou.Volume.setAllVoxels.

            Note that this method can accept more types that just a string: it
            can receive any Python object that supports the buffer interface. In
            particular, arrays from the array and numpy Python modules are
            supported, so there is no need to first construct strings from those
            arrays.

            Raises hou.OperationFailed if the length of the string is not
            exactly the same as self.resolution()[0] * self.resolution()[1] *
            self.resolution()[2] * 4.

            See hou.Volume.setAllVoxels and hou.Volume.allVoxelsAsString for
            more information.

            The following example function accepts an array.array(\\"f\\") and sets
            the voxels to its contents, provided volume is a scalar volume:

          > def setAllVoxelsFromArray(volume, arr):
          >     assert(arr.typecode == \\"f\\")
          >     volume.setAllVoxelsFromString(arr)

            Multi-channel volumes will require the channels to be interleaved
            and be correspondingly longer. Integer volumes require the integer
            values as 64-bit integers.


        '''
    def voxelSlice(self, plane: str, index: int) -> Tuple[float, ...]:
        '''

        voxelSlice(plane, index) -> tuple of float

            Return a tuple of floats containing the values of all voxels in a
            particular slice. It is faster to call this method to retrieve a
            slice than it is to loop through the voxel array in Python.


            plane
                The plane corresponding to this slice. This value must be either
                xy, xz, or yz.

            index
                The index of this slice in the array. For example, if the plane
                is xy, this index is the z value and the result will contain all
                values in the voxel with this particular z value.

            This method can be approximately implemented as follows (though this
            Python implementation is much slower):

          > def voxelSlice(self, plane, index):
          >     result = []
          > 
          >     start = [0] * 3
          >     stop = list(self.resolution())
          > 
          >     slice_axis = {\\"xy\\": 2, \\"xz\\": 1, \\"yz\\": 0}[plane]
          >     start[slice_axis] = index
          >     stop[slice_axis] = index + 1
          > 
          >     for z in range(start[2], stop[2]):
          >         for y in range(start[1], stop[1]):
          >             for x in range(start[0], stop[0]):
          >                 result.append(self.voxel((x, y, z)))
          >     return tuple(result)

            See also hou.Volume.voxelSliceAsString and hou.Volume.allVoxels.


        '''
    def voxelSliceAsString(self, plane: str, index: int) -> bytes:
        """

        voxelSliceAsString(plane, index) -> str

            Return a binary string representation of the floats containing all
            the values of voxels in a particular slice.

            The returned binary string is a bytes object in Python 3 and a str
            object in Python 2. See HOM binary data for more information.

            See hou.Volume.voxelSlice and hou.Volume.allVoxelsAsString for more
            information.


        """
    def setVoxelSlice(self, values: Sequence[float], plane: str, index: int) -> None:
        '''

        setVoxelSliceFromString(self, values, plane, index)

            Set the value of the voxels in a particular slice of this volume.
            You would typically call this method from the code of a Python-
            defined SOP.


            values
                A binary string representing of a sequence of floats containing
                the new values for the slice.

                Note that this method can accept more types that just a string:
                it can receive any Python object that supports the buffer
                interface. In particular, arrays from the array and numpy Python
                modules are supported, so there is no need to first construct
                strings from those arrays.

            plane
                The plane corresponding to this slice. This value must be either
                xy, xz, or yz.

            index
                The index of this slice in the array.

            See hou.Volume.setVoxelSlice for more information.

            The following example builds a volume from an compositing network
            sequence:

          > def buildVolumeFromCopSequence(
          >         cop_node, geo, voxel_depth, plane=\\"C\\", component=\\"r\\"):
          >     zres = int(cop_node.sequenceFrameLength())
          >     volume_bbox = hou.BoundingBox(*(
          >         0, 0, 0,
          >         cop_node.xRes(), cop_node.yRes(), zres) * voxel_depth)
          >     volume = geo.createVolume(
          >         cop_node.xRes(), cop_node.yRes(), zres, volume_bbox)
          > 
          >     for z in range(zres):
          >         pixels = cop_node.allPixelsAsString(
          >             plane, component,
          >             time=hou.frameToTime(z + cop_node.sequenceStartFrame()))
          >         volume.setVoxelSliceFromString(pixels, \\"xy\\", z)

        '''
    def setVoxelSliceFromString(self, values: bytes, plane: str, index: int) -> None: ...
    def resolution(self) -> Tuple[int, ...]:
        """

        resolution(self) -> hou.Vector3

            Return the x, y, and z dimensions of the volume. For example, a
            resolution of (10, 20, 30) means the volume is 10 voxels in x by 20
            voxels in y by 30 voxels in z.


        """
    def indexToPos(self, index: Sequence[int]) -> Vector3:
        """

        indexToPos(self, index) -> hou.Vector3

            Given a sequence of three ints containing an index into the voxel
            array, return the corresponding 3D position of the middle of that
            voxel.


        """
    def posToIndex(self, position: Sequence[float]) -> Tuple[int, ...]:
        """

        posToIndex(self, position) -> tuple of int

            Given a sequence of three floats containing a 3D position, return a
            tuple of three ints containing the corresponding index into the
            voxel array.

            Note that the returned index will be invalid if the position is
            outside the volume. Use hou.Volume.isValidIndex to determine if the
            index is valid.


        """
    def isValidIndex(self, index: Sequence[int]) -> bool:
        """

        isValidIndex(self, index) -> bool

            Return whether or not a sequence of three ints containing an index
            into the voxel array is valid, ie, within the bounds of the array.

            This method can approximately be implemented as follows:

          > def isValidIndex(self, index):
          >     for i, maximum in zip(index, self.resolution()):
          >         if i < 0 or i >= maximum:
          >             return False
          >     return True

        """
    def isSDF(self) -> bool:
        """

        isSDF(self) -> bool

            Return whether or not the volume is flagged as a signed distance
            field. Such volumes have a special border condition where out of
            bound reads will add the distance to the bounding box to the
            streaked boundary condition. They are also best to be semantically
            treated as signed distance fields.


        """
    def isHeightField(self) -> bool:
        """

        isHeightField(self) -> bool

            Return whether or not the volume is flagged as a heightfield. Such
            volumes are two dimensional and have the heightfield visualization
            set.


        """
    def volumeMax(self) -> float:
        """

        volumeMax(self) -> float

            Return the maximum value of all voxels.


        """
    def volumeMin(self) -> float:
        """

        volumeMin(self) -> float

            Return the minimum value of all voxels.


        """
    def volumeAverage(self) -> float:
        """

        volumeAverage(self) -> float

            Return the average value of all voxels.


        """
    def transform(self) -> Matrix3:
        """

        transform(self) -> hou.Matrix3

            Return a 3x3 matrix containing the scale and rotation
            transformations for this volume.

            Note that the position information for the volume can be obtained by
            calling volume.vertex(0).point().position().

            The following function returns a 4x4 transformation matrix for the
            volume that includes the translation:

          > def fullTransform(volume):
          >     return (hou.Matrix4(volume.transform()) *
          >         hou.hmath.buildTranslate(volume.vertex(0).point().position()))

            NOTE
                You need to get the node transform to get to worldspace.


        """
    def setTransform(self, transform: Matrix4) -> None:
        """

        setTransform(self, matrix4)

            Given a 4x4 matrix, set the position, rotation, and scale of this
            volume.

            Note that if you want to just set the translate portion of a volume
            to a hou.Vector3, you could just call
            volume.vertex(0).point().setPosition(position).


        """
    def taperX(self) -> float: ...
    def taperY(self) -> float: ...
    def vertex(self, index: int) -> Vertex:
        """

        vertex(self, index)

            A shortcut for self.vertices()[index]. You probably don't need to
            call this method.

            This method supports negative indices to index from the end, just
            like self.vertices()[index] would. Also, like Python's indexing
            operator, it will raise IndexError when the index is out of range.


        """
    def voxelSize(self) -> Vector3:
        """

        voxelSize(self) -> hou.Vector3

            Returns the size of voxels within the volume. All voxels will be of
            this size for untapered volumes.


        """

class VopNetNode(OpNode):
    """

    hou.VopNetNode

    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def definedType(self) -> NodeType:
        """

        definedType(self) -> NodeType


        """
    def vexContext(self) -> VexContext:
        """

        vexContext(self) -> VexContext


        """
    def shaderType(self) -> EnumValue:
        """

        shaderType(self) -> hou.shaderType enum value or None


        """

class VopNode(OpNode):
    """

    hou.VopNode

    Represents a VOP (VEX Operator) node.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def insertParmGenerator(self, input_name: str, parm_gen_type: EnumValue, reference_input_defaults: bool) -> VopNode:
        """

        insertParmGenerator(self, input_name, parm_gen_type,
        reference_input_defaults) -> hou.VopNode

            Creates a parameter or a constant node and wires it into an input
            specified by input_name on this node. parm_gen_type must be a value
            of hou.vopParmGenType. If reference_input_defaults is True, this
            node will reference the defaults of the newly created node.

            A resultant parameter or constant node is returned.


        """
    def insertParmGeneratorsForAllInputs(self, parm_gen_type: EnumValue, reference_input_defaults: bool) -> dict[str, Node]:
        """

        insertParmGeneratorsForAllInputs(self, parm_gen_type,
        reference_input_defaults) -> dict of str to hou.VopNode

            Creates parameter or constant nodes and wires them into unconnected
            inputs on this node. parm_gen_type must be a value of
            hou.vopParmGenType. If reference_input_defaults is True, then this
            node will reference the defaults of the newly created nodes.

            A dictionary is returned with input names for keys and hou.VopNode
            objects for values.


        """
    def parmDefinerNode(self) -> Optional[VopNode]:
        """

        parmDefinerNode(self) -> hou.VopNode

            Return the Parameter VOP node that defines the parameter that this
            node is bound to. This method only applies to Parameter VOP nodes.

            Return None if this node is not a Parameter VOP or if this node is
            the definer node.


        """
    def deleteIndependentInputNodes(self, input_index: int) -> bool:
        """

        deleteIndependentInputNodes(self, input_index):, make_parm_node,
        reference_input_defaults) -> bool

            Deletes a chain of nodes wired into a particular input if and only
            if they are wired only into the specified input on this node.
            Returns true if nodes were deleted, false otherwise.


        """
    def dependsOnlyOn(self, other_node: VopNode, max_connections: int, recurse: bool) -> bool: ...
    def setIsInputVisible(self, input_name: str, is_visible: bool) -> None:
        """

        setIsInputVisible(self, input_name, is_visible)

            Shows or hides an input connector of this node. The input is
            specified by input_name. The connector is shown if is_visible is
            True, and hidden otherwise.


        """
    def isInputVisible(self, input_name: str) -> bool:
        """

        isInputVisible(self, input_name) -> bool

            Returns True if the input connector specified by input_name on this
            node is visible, False otherwise.


        """
    def inputDataTypes(self) -> Tuple[str, ...]:
        """

        inputDataTypes(self) -> tuple of str

            Returns a tuple of all input data types for this node. Data types
            for input connectors that are hidden are also included.

            The strings returned by this method can be used to set the Type
            parameter on a Parameter or Constant VOP.


        """
    def outputDataTypes(self) -> Tuple[str, ...]:
        """

        outputDataTypes(self) -> tuple of str

            Returns a tuple of all output data types for this node. Data types
            for output connectors that are hidden are also included.

            The strings returned by this method can be used to set the Type
            parameter on a Parameter or Constant VOP.


        """
    def inputParmTypes(self) -> Tuple[str, ...]: ...
    def isInputCompatible(self, idx: int, other: VopNode, other_idx: int, allow_conversions: bool = False) -> bool:
        """

        isInputCompatible(self, idx, other, other_idx, allow_conversions =
        False) -> bool`

            Return True if input idx of this object can be connected to output
            other_idx of node other. Two inputs can be connected if they are of
            the same data type. If the allow_conversions parameter is set to
            True, a more permissive check is done which accepts an input
            connection if the output data type can be automatically converted to
            the input data type without an explicit conversion node (such as a
            float output to a vector input).


        """
    def code(self) -> str:
        """

        code(self) -> str

            Returns the VEX or RSL code that defines this node.


        """
    def outerCode(self) -> str:
        """

        outerCode(self) -> str

            Returns the outer code associated with this node.


        """
    def isBypassed(self) -> bool:
        """

        isBypassed(self) -> bool

            Returns True if the node's bypass flag is turned on. Returns False
            otherwise.


        """
    def bypass(self, on: bool) -> None:
        """

        bypass(self, on)

            Turns the node's bypass flag on or off. When the bypass flag is on,
            the node will have no effect on the scene. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isDebugFlagSet(self) -> bool:
        """

        isDebugFlagSet(self) -> bool

            Returns True if the node's debug flag is turned on. Returns False
            otherwise.


        """
    def setDebugFlag(self, on: bool) -> None:
        """

        setDebugFlag(self, on)

            Turns the node's debug flag on or off. The value of the on argument
            must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isDetailLowFlagSet(self) -> bool:
        """

        isDetailLowFlagSet(self) -> bool

            Returns True if the node's low detail flag is turned on. Returns
            False otherwise.


        """
    def setDetailLowFlag(self, on: bool) -> None:
        """

        setDetailLowFlag(self, on)

            Turns on or off the low detail flag for this node's inputs and
            outputs. With this flag turned on, all inputs and outputs to this
            node will appear in the network view as connecting to a single
            location on the node. This flag does not affect the operation of
            this node, only its appearance in the network view. The value of the
            on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isDetailMediumFlagSet(self) -> bool:
        """

        isDetailMediumFlagSet(self) -> bool

            Returns True if the node's medium detail flag is turned on. Returns
            False otherwise.


        """
    def setDetailMediumFlag(self, on: bool) -> None:
        """

        setDetailMediumFlag(self, on)

            Turns on or off the medium detail flag for this node's inputs and
            outputs. With this flag turned on, only connected inputs and outputs
            to this node will be visible in the network view. This flag does not
            affect the operation of this node, only its appearance in the
            network view. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isDetailHighFlagSet(self) -> bool:
        """

        isDetailHighFlagSet(self) -> bool

            Returns True if the node's high detail flag is turned on. Returns
            False otherwise.


        """
    def setDetailHighFlag(self, on: bool) -> None:
        """

        setDetailHighFlag(self, on)

            Turns on or off the high detail flag for this node's inputs and
            outputs. With this flag turned on, all inputs and outputs to this
            node will appear in the network view, whether they are connected to
            another node or not. This flag does not affect the operation of this
            node, only its appearance in the network view. The value of the on
            argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isCompressFlagSet(self) -> bool:
        """

        isCompressFlagSet(self) -> bool

            Returns True if the node's compress flag is turned on. Returns False
            otherwise. The compress flag controls whether or not a preview image
            is shown for this node in the Network View.


        """
    def setCompressFlag(self, on: bool) -> None:
        """

        setCompressFlag(self, on)

            Turns the node's compress flag on or off. If the compress flag is
            True, this node will not show a preview image in the Network View.
            If the compress flag is False, a preview image will be shown in the
            Network View. The value of the on argument must be True or False.

            Raises hou.PermissionError if the node is unwritable.


        """
    def isMaterialFlagSet(self) -> bool:
        """

        isMaterialFlagSet(self) -> bool

            Returns True if the node's material flag is turned on. Returns False
            otherwise. The material flag indicates whether this node is intended
            for use as a material to be assigned to objects or geometry.


        """
    def setMaterialFlag(self, on: bool) -> None:
        """

        setMaterialFlag(self, on)

            Turns the node's material flag on or off. If the material flag is
            True, it indicates that this node is meant to be used as a material
            to be assigned to objects or geometry. It will appear in material
            node choosers and be saved to IFDs generated with the option to save
            all materials turned on.

            Raises hou.PermissionError if the node is unwritable.


        """
    def setInputGroupExpanded(self, group: str, expanded: bool) -> None:
        """

        setInputGroupExpanded(self, group, expanded)

            Sets the expanded state of the input group with the name specified
            by the group parameter. This controls the appearance of this input
            group in the Network View. Pass a group value of None to expand or
            collapse all input groups.


        """
    def isInputGroupExpanded(self, group: str) -> bool:
        """

        isInputGroupExpanded(self, group) -> bool

            Returns True if the group with the name specified by group is
            expanded in the Network View. The group parameter should be a value
            returned by the hou.VopNode.inputGroupName method. Returns the
            current expanded state of the group even if the group is not
            currently visible due to the setting of the input/output detail
            flags. Returns True if the group name is not valid.


        """
    def inputsInGroup(self, group: str) -> Tuple[int, ...]:
        """

        inputsInGroup(self, group) -> tuple of int

            Returns the input index values of all inputs that appear in the
            group with the name specified in group. This parameter should be a
            value returned by the hou.VopNode.inputGroupName method. This method
            returns the same set of inputs whether the group is expanded or
            collapsed. Returns an empty tuple if the group name contains no
            inputs or is not a recognized group name.


        """
    def inputGroupNames(self) -> Tuple[str, ...]:
        """

        inputGroupNames(self) -> tuple of str

            Returns the names of the input groups on this VOP Node. Note that
            not all groups will contain any inputs, and so not all groups will
            be visible in the Network View. Use the hou.VopNode.inputsInGroup
            method to determine which inputs are part of a particular group.


        """
    def inputIndexOrder(self) -> Tuple[int, ...]:
        """

        inputIndexOrder(self) -> tuple of int

            Return a tuple of integers which represent input index numbers that
            can be passed to hou.Node.setInput and related functions. The order
            of the index numbers represents the order in which those inputs
            appear in the network view tile for this object. This ordering is
            affected by the way inputs are grouped together on the parameter
            pane for this node.


        """
    def findBypassInputName(self, output_name: str) -> str:
        """

        findBypassInputName(self, output_name) -> str

            Returns the name of an input to which the given output pipes thru
            when the node's bypass flag is turned on.


        """
    def renderMask(self) -> str:
        """

        renderMask(self) -> str

            Returns the mask for renderers for which the node represents a valid
            shader.


        """
    def shaderString(self, render_type: str|None = ..., shader_type: EnumValue = ..., as_encapsulated: bool = ...) -> str:
        """

        shaderString(self, render_type=None, shader_type=hou.shaderType.Surface,
        as_encapsulated=False) -> str

            Returns the string that encodes the shader name and parameter values
            suitable for specifying as a shader assignment in an input stream
            acceptable by the renderer of a given type. If the VOP is material
            that provides a few shader contexts (eg, surface and displacement),
            it is necessary to provide the shader type explicitly. If
            as_encapsulated is true, the returned shader string will encode the
            shader as embedded in the parent shader with parameters referencing
            the parent, if needed.


        """
    def shaderCode(self, shader_type: EnumValue|None = ...) -> str:
        """

        shaderCode(self, shader_type=hou.shaderType.Surface) -> str

            Returns the generated VEX or RSL code for this VOP, using the given
            shader type to control output context. If the VOP is a subnet that
            can be packaged up as an encapsulated shader, then the specific code
            to define an encapsulated shader is output. Otherwise, the code
            generated for the entire VOP network is output.


        """
    def shaderName(self, as_otl_path: bool = True, shader_type_name: Optional[str] = None) -> str:
        """

        shaderName(self, as_otl_path=True, shader_type_name=None) -> str

            Returns the name of the shader defined by this VOP (if it is an
            embedded shader) or the shader name defined by the shop in which
            this VOP resides. If as_otl_path is True, returns an opdef: path to
            the SHOP type. The shader_type_name is a string indicating the
            shader context type to use; some nodes may provide several shader
            types, and each may have a different name. This is applicable only
            to multi-context shader nodes, such as a vopnet material shop.


        """
    def shaderNameForSignature(self, signature: Optional[str] = None) -> str:
        """

        shaderNameForSignature(self, signature=None) -> str

            Returns the name of the shader given the node's signature.

            Different VOP signatures may have different shader function names,
            so this method will return the shader name for the signature given
            in the parameter. If the signature is not provided, the current
            signature of the node is used.


        """
    def shaderType(self) -> EnumValue: ...
    def shaderLanguageName(self) -> str:
        """

        shaderLanguageName(self) -> str

            Returns the name of the language the shader is written in.


        """
    def setShaderLanguageName(self, language_name: str) -> bool:
        """

        setShaderLanguageName(self, language_name) -> bool

            Sets the shader language for this node. Returns true on success, but
            false if the given language was not found and could be set for the
            node.

            In the majority of cases, VOP nodes deduce their language from the
            operator render mask, shader generator, or the parent, so this
            function is not called too often. However, occasionally, it is
            necessary to override the implicit deduction, usually for built-in
            operators such as a subnet or a parameter VOP.


        """
    def currentSignatureName(self) -> str:
        """

        currentSignatureName(self) -> str

            Returns the current signature name of this node. The HDA nodes may
            provide several valid signatures, and this function returns the name
            of the currently used signature. A signature is defined by a set of
            input types and each set is assigned a name.


        """
    def coshaderNodes(self, parm_name: str) -> Tuple[Node, ...]: ...
    def coshaderNodesOutputNames(self, parm_name: str) -> Tuple[str, ...]: ...
    def subnetTerminalChild(self, subnet_output_name: str) -> Tuple[Node, str]:
        """

        subnetTerminalChild(self, output_name) -> tuple of houNode and str

            Returns a tuple of a node and its input name that corresponds to the
            subnet output connector by the given name.


        """
    def extraBindings(self) -> Tuple[str, ...]:
        """

        extraBindings(self) -> tuple of str

            Returns the list of extra bindings the VOP node would add to the
            generated code. Implemented specifically for Snippet VOPs, this
            allows one to determine what bindings will be created by any adhoc @
            references.


        """
    def usdShaderParms(self, force_parms_at_default: bool = False) -> Tuple[str, ...]:
        """

        usdShaderParms(self, force_parms_at_default=False) -> tuple of str

            Returns the list of shader parameter names whose values need to be
            authored on the USD shader primitive. This list includes node
            parameters that are designated as shader parameters and are active,
            but are not at default values (unless they have a tag forcing it to
            be translated).

            If force_parms_at_default is True, returns shader parameters that
            are at default values too; excludes them otherwise, which is a
            default behaviour.


        """
    def usdPreviewShaderParms(self) -> Tuple[str, ...]:
        """

        usdPreviewShaderParms(self) -> tuple of str

            Returns the list of shader parameter names whose values are used to
            author a standard USD preview shader. Usually, these parameters are
            tagged with a special ogl_* spare data.


        """

class VopNodeType(OpNodeType):
    """

    hou.VopNodeType

    This kind of NodeType contains extra attributes specific to VOP nodes.


    """
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __swig_destroy__: Incomplete
    def shaderType(self) -> EnumValue:
        """

        shaderType(self) -> hou.shaderType enum value

            Returns the type of shader for this VOP type. For example, this vop
            type might be a surface shader or a displacement shader. See
            hou.shaderType for the possible shader types.

            See also hou.VopNode.shaderType.


        """
    def renderMask(self) -> str:
        '''

        renderMask(self) -> str

            Returns a string with space-separated names of the renderers that
            this VOP type supports. Note that some VOP types, like the switch
            VOP, return \\"*\\" to indicate that they support all renderers, while
            others return an empty string to indicate they are not real shaders.

            See hou.VopNode.shaderString for an example.


        '''
    def vopnetMask(self) -> str:
        """

        vopnetMask(self) -> str

            Returns a glob pattern that matches the network parents in which
            this VOP node can appear.

            See hou.VopNode.shaderString for an example.


        """
    def inputTags(self, input_name: str) -> dict[str, str]:
        """

        inputTags(self, input_name) -> dict of str to string

            Returns a dictionary of key-value pairs associated with the given
            input. This dictionary allows attaching arbitrary data to node
            inputs.


        """
    def outputTags(self, output_name: str) -> dict[str, str]:
        """

        outputTags(self, output_name) -> dict of str to str

            Returns a dictionary of key-value pairs associated with the given
            output. This dictionary allows attaching arbitrary data to node
            outputs.


        """

class CompositorViewerEvent(UIEvent):
    """

    hou.CompositorViewerEvent

    Represents a user interface event specific to compositor viewers.

    hou.CompositorViewerEvent objects are used with COPs Python states.
    Houdini calls event handlers with a dictionary that includes useful
    data, such as a ui_event key containing a CompositorViewerEvent object.

    You do not instantiate this type of object yourself. See Python states
    for more information.

    hou.CompositorViewerEvent is a specialized hou.UIEvent subclass that you
    can use to access ray coordinates and other event data within a
    compositor viewer.

    RELATED

        hou.ViewerEvent


    """
    thisown: Incomplete
    def __init__(self, viewer: CompositorViewer, val: int, val2: int) -> None:
        """

        hou.CompositorViewerEvent

        Represents a user interface event specific to compositor viewers.

        hou.CompositorViewerEvent objects are used with COPs Python states.
        Houdini calls event handlers with a dictionary that includes useful
        data, such as a ui_event key containing a CompositorViewerEvent object.

        You do not instantiate this type of object yourself. See Python states
        for more information.

        hou.CompositorViewerEvent is a specialized hou.UIEvent subclass that you
        can use to access ray coordinates and other event data within a
        compositor viewer.

        RELATED

            hou.ViewerEvent


        """
    __swig_destroy__: Incomplete
    def curViewport(self) -> Optional[Viewport2D]:
        """

        curViewport(self) -> hou.Viewport2D

            Returns the viewport this event occurred within.


        """
    def mousePos(self, relative_to_viewport: bool = False) -> Vector2:
        """

        mousePos(self, relative_to_viewport=False) -> hou.Vector2

            Return the mouse position for this event in screen coordinates. By
            default, the position is relative to the compositor view window.


            relative_to_viewport
                If False (default), the position is relative to the view window.
                If True, the position is relative to the viewport under the
                mouse.


        """

def isUIAvailable() -> bool:
    """

    hou.isUIAvailable

    Return whether or not the hou.ui module is available.

    USAGE
      isUIAvailable() -> bool

    The hou.ui module is not available in the command-line interpreter or in
    MPlay, and this function helps you to write scripts that will run in
    Houdini and command-line and/or MPlay.

    RELATED

      * hou.ui


    """
def exit(exit_code: int = 0, suppress_save_prompt: bool = False) -> None:
    """

    hou.exit

    Exits Houdini, returning the exit code to the operating system. If
    suppress_save_prompt is false, this function asks the user if he/she
    wants to save. If the user presses Cancel, the exit will be canceled and
    the next statement will execute.

    USAGE
      exit(exit_code=0, suppress_save_prompt=False)

    The exit confirmation prompt only appears if the session has unsaved
    changes. This function will not return until after the user has made a
    choice from the prompt. If this function is called from outside Houdini
    (e.g. MPlay or a non-graphical Python shell), the dialog is not
    displayed and suppress_save_prompt==True is implied.

    Note that if the user chose to exit, this function will raise a Python
    SystemExit exception to ensure the executing Python script terminates.
    This approach ensures that the next Python statement will not be
    executed, since Houdini may add events to its event queue that carry out
    the actual shutdown, or hou.exit() may be called from a different thread
    than the one executing the shutdown.

    Note that if you call sys.exit() from within the interactive Houdini
    Python shell, it will call hou.exit() with suppress_save_prompt=True.
    The Houdini Python shell does this by intercepting the SystemExit
    exception raised by sys.exit() and calling hou.exit(). Since both
    sys.exit() and hou.exit() both raise SystemExit exceptions, the shell
    calls hou._isExiting() to differentiate between the two.

    Avoid calling sys.exit() from any place other than the interactive
    Houdini Python shell, such as non-graphical Python shells, and instead
    call hou.exit(). Using hou.exit() ensures that Houdini shuts down
    cleanly.


    """
def applicationName() -> str:
    """

    hou.applicationName

    Returns the application name.

    USAGE
      applicationName() -> string

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationPlatformInfo

      * hou.licenseCategory

      * hou.isApprentice


    """
def applicationVersion(include_patch: bool = ...) -> Tuple[int, int, int]:
    """

    hou.vdbVersionInfo

    Returns a dictionary about the version of VDB built into Houdini.

    USAGE
      vdbVersionInfo() -> dict of str to str

    Returns a dictionary holding information about the USD library built
    into Houdini.


    vdbversion
        The VDB version number converted to a string. This is usually of the
        form Major.Minor.Patch

    abiversion
        The VDB version number with the ABI it was built against. It is most
        important that the ABI match with external libraries to ensure VDBs
        can be passed between plugins.

    packageurl
        The URL of the git repository from which the VDB library was built.

    packagerevision
        The git commit hash code for the specific branch used to build the
        VDB library.

    RELATED

      * hou.lop.usdVersionInfo

      * hou.thirdPartyLibraryVersions


    """
def applicationVersionString() -> str:
    """

    hou.applicationVersionString

    Returns the application's version number as a string.

    USAGE
      applicationVersionString() -> string

    The format of the string is 'major_version.minor_version.build_version'.
    If this method is executed in python, then it returns the hou module's
    version number.

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationPlatformInfo

      * hou.licenseCategory

      * hou.isApprentice


    """
def applicationCompilationDate() -> str:
    """

    hou.applicationCompilationDate

    Returns the application's compilation date.

    USAGE
      applicationCompilationDate() -> string

    If this method is executed in python, then it returns the date which the
    hou module was compiled on.

    RELATED

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationPlatformInfo

      * hou.licenseCategory

      * hou.isApprentice


    """
def applicationPlatformInfo() -> str:
    """

    hou.applicationPlatformInfo

    Returns a string containing information about the system that compiled
    this version of Houdini.

    USAGE
      applicationPlatformInfo() -> string

    Most of the time you can use Python's platform module to get information
    about the current operating system, processor type, etc. However, this
    function can provide information not available through the platform
    module, such as the version of the compiler that compiled Houdini.

    > >>> hou.applicationPlatformInfo()
    > linux-x86_64-gcc4.4

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationName

      * hou.licenseCategory

      * hou.isApprentice


    """
def vdbVersionInfo() -> dict[str, str]: ...
def hdkAPIVersion() -> int:
    """

    hou.hdkAPIVersion

    Returns the HDK API version number.

    USAGE
      hdkAPIVersion() -> int

    Returns the HDK API version number.

    This monotonically increasing value is updated to the last Houdini
    version with known ABI incompatibilities. Typically, this will be set on
    every major release and only occasionally on releases within a X.Y
    version. If this version number has changed, plugins should be
    recompiled.

    RELATED

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.applicationPlatformInfo

      * hou.thirdPartyLibraryVersions


    """
def licenseCategory() -> EnumValue:
    """

    hou.licenseCategory

    Return the category of license (Commercial, Apprentice, ApprenticeHD,
    etc.) in use.

    USAGE
      licenseCategory() -> hou.licenseCategoryType enum value

    RELATED

      * hou.licenseCategoryType

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString

      * hou.isApprentice


    """
def isApprentice() -> bool:
    """

    hou.isApprentice

    Return whether the application is an apprentice (non-commercial)
    version.

    USAGE
      isApprentice() -> bool

    Return whether the hou module is using an Apprentice license. Note that
    this function returns True for both Apprentice and Apprentice HD.

    RELATED

      * hou.licenseCategory

      * hou.applicationCompilationDate

      * hou.applicationName

      * hou.applicationVersion

      * hou.applicationVersionString


    """
def releaseLicense() -> None:
    """

    hou.releaseLicense

    Release the currently held Houdini license.

    USAGE
      releaseLicense()

    When you import the hou module into a Python shell, it will acquire a
    Houdini license. This function exists so you can release that license
    when you're done using the hou module. This way, you can have a long
    running Python script that periodically uses Houdini without having to
    hold a Houdini license for the entire duration of the script.

    After you release the license, it will automatically be reacquired when
    you access functions and objects from the hou module.


    """
def maxThreads() -> int:
    """

    hou.maxThreads

    Returns the number of threads used for processing.

    USAGE
      maxThreads() -> int

    When Houdini/hython is started, it uses all available processors on the
    machine for multi-threaded processing, unless overridden by the -j
    command line option or the hou.setMaxThreads function.

    This function returns that maximum number of threads that Houdini/hython
    will use.

    RELATED

      * hou.setMaxThreads


    """
def setMaxThreads(max_threads: int) -> None:
    """

    hou.setMaxThreads

    Sets the maximum number of threads to use for multi-processing.

    USAGE
      setMaxThreads(max_threads)

    When Houdini/hython is started, it uses all available processors on the
    machine for multi-threaded processing, unless overridden by the -j
    command line option.

    This function allows dynamically adjusting this setting at run-time.

    Note that this function may only be called from the main thread. If
    called from an expression that gets evaluated in a multi-threaded
    context, or during other processing, it will throw an exception.


    WARNING
        The effectiveness of this function differs on different platforms.
        Prefer using the -j command line option setting the
        HOUDINI_MAXTHREADS environment variable instead.

    WARNING
        This function will have no effect if an CPU OpenCL driver is
        installed, and possibly other situations as well.

    RELATED

      * hou.maxThreads


    """
def root() -> Node:
    '''

    hou.root

    Return the root node (i.e. /).

    USAGE
      root() -> hou.OpNode

    This function is a shortcut for writing hou.node(\\"/\\").

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.node_


    '''
def pwd() -> Node:
    '''

    hou.pwd

    If called from an evaluating parm, return the node containing the parm.
    Otherwise, return Houdini\'s global current node. You can change this
    current node with hou.cd

    USAGE
      pwd() -> hou.OpNode

    This function is a shortcut for writing hou.node(\\".\\").

    Note that Python and hscript both share the same global current node.
    So, if you change that node in hscript, the return value of pwd() will
    reflect that change, and vice versa.

    Note that if this function is called from an expression inside a node\'s
    parameter, Houdini will return the node containing the expression, not
    Houdini\'s current node. This behavior permits relative parameter and
    node references from both Hscript and Python parameter expressions,
    since functions like hou.ch, ch(), hou.evalParm, hou.parm_, and
    hou.node_ are relative to the result of hou.pwd().

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.cd

      * hou.parent


    '''
def parent() -> Optional[Node]:
    '''

    hou.parent

    Return the parent of the current node.

    USAGE
      parent() -> hou.OpNode or None

    This function is a shortcut for writing hou.node(\\"..\\"). It returns the
    parent of the current node (i.e. the node returned by hou.pwd).

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.node_


    '''
def setPwd(node: Node) -> None:
    """

    hou.setPwd

    Make the given node Houdini's current node. This function is equivalent
    to hou.cd(node.path()).

    USAGE
      setPwd(node)

    This function will raise hou.ObjectWasDeleted if the parameter refers to
    a node that no longer exists in Houdini.

    This function will raise hou.NotAvailable if you call it from mplay.

    RELATED

      * hou.pwd

      * hou.cd

      * hou.ScriptEvalContext


    """
def cd(path: str) -> None:
    """

    hou.cd

    Change the current node. Houdini has one current node, analogous to a
    current directory in a file system. If a relative path is given, it is
    relative to the node returned by hou.pwd().

    USAGE
      cd(path)

    If no node exists at the path, this function raises hou.OperationFailed.

    Even though, when called from a parameter's expression, hou.pwd()
    returns the node containing the parameter and not Houdini's current
    node, hou.cd() will always change the current node.

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.pwd

      * hou.setPwd


    """
def phm() -> HDAModule:
    """

    hou.phm

    A shortcut for hou.pwd().hdaModule().

    USAGE
      phm() -> hou.HDAModule

    This shortcut lets you write hou.phm() instead of hou.pwd().hdaModule().
    You are most likely to use this shortcut from event handlers, button
    callbacks, and menu generation scripts in digital assets.

    See hou.pwd and hou.OpNode.hdaModule for more information.


    """
def currentDopNet() -> Node:
    """

    hou.currentDopNet

    Returns the DOP Network node set as the current simulation in the UI.

    USAGE
      currentDopNet() -> hou.OpNode

    The current DOP network is the network the shelf tools put new nodes
    into. The user can change this using the simulation menu in the bottom
    right corner of the main window.

    This is always a writeable dopnetwork, so not necessarily point to the
    network used for the blue cache line display. Instead, it will point to
    the last current dopnetwork that was also writeable.

    If you're building a shelf tool that creates simulation nodes, you
    should use this function to know where to put them.

    Call hou.setCurrentDopNet to set the current simulation network
    programmatically.

    RELATED

      * hou.setCurrentDopNet


    """
def setCurrentDopNet(dopnet: Node) -> None:
    """

    hou.setCurrentDopNet

    USAGE
      setCurrentDopNet(dopnet)

    The current DOP network is the network the shelf tools put new nodes
    into. The user can change this using the simulation menu in the bottom
    right corner of the main window. This method lets you programmatically
    set the current simulation network.

    Because the current dopentwork must always be writeable, setting this to
    a non-writeable dopnetwork will not cause hou.currentDopNet to change.
    However, it will update the current dopnetwork for the purpose of other
    UI, such as the blue cache bar, provided the node is a valid dopnetwork.

    Call hou.currentDopNet to get a hou.OpNode object representing the
    current DOP Network node.

    RELATED

      * hou.currentDopNet


    """
def simulationEnabled() -> bool:
    """

    hou.simulationEnabled

    USAGE
      simulationEnabled() -> bool

    Returns True if Houdini is currently set to update simulations. The user
    can choose to disable simulation updates to improve interactivity using
    the simulation menu in the bottom right corner of the main window. Use
    hou.setSimulationEnabled to enable or disable simulation updates
    programmatically.

    RELATED

      * hou.setSimulationEnabled


    """
def setSimulationEnabled(enabled: bool) -> None:
    """

    hou.setSimulationEnabled

    USAGE
      setSimulationEnabled(enabled)

    Call hou.setSimulationEnabled(True) to enable simulation updates or
    hou.setSimulationEnabled(False) to disable them. The user can choose to
    disable simulation updates to improve interactivity using the simulation
    menu in the bottom right corner of the main window. This function lets
    you set the state of that menu item programmatically. Use
    hou.simulationEnabled to check whether simulation updates are currently
    enabled.

    RELATED

      * hou.simulationEnabled


    """
def node(path: str) -> Optional[Node]:
    '''

    hou.node

    Given a path string, return a Node object. Return None if the path does
    not refer to a node.

    USAGE
      node(path) -> hou.OpNode or None

    If the path starts with a /, Houdini will look for a node with that
    exact path. Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini\'s current path. For
    each occurrence of .. in the path, Houdini will move up one node from
    the current location.

    Raises hou.NotAvailable if you call it from MPlay.

    Be careful not to confuse this function with the class hou.OpNode.

    > >>> hou.node(\\"/obj\\")
    > <hou.OpNode at /obj>
    > >>> hou.node(\\"/obj\\").createNode(\\"geo\\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.node(\\"/obj\\").createNode(\\"geo\\")
    > <hou.ObjNode of type geo at /obj/geo2>
    > >>> hou.node(\\"/obj/geo1\\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.cd(\\"/obj\\")
    > >>> hou.node(\\"geo1\\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> hou.cd(\\"/obj/geo2\\")
    > >>> hou.node(\\"../geo1\\")
    > <hou.ObjNode of type geo at /obj/geo1>
    > >>> print hou.node(\\"../geo3\\")
    > None

    RELATED

      * hou.item

      * hou.items

      * hou.nodes

      * hou.pwd

      * hou.parent

      * hou.root


    '''
def item(path: str) -> Optional[NetworkMovableItem]:
    '''

    hou.item

    Given a path string, return a NetworkMovableItem object. Return None if
    the path does not refer to an item.

    USAGE
      item(path) -> hou.NetworkMovableItem or None

    If the path starts with a /, Houdini will look for an item with that
    exact path. Otherwise, the Houdini searches relative to the current
    path. See hou.pwd for more information about Houdini\'s current path. For
    each occurrence of .. in the path, Houdini will move up one item from
    the current location.

    This method is a more general form of the hou.node_ method, which will
    only return hou.OpNode objects. But some network item types
    (hou.SubnetIndirectInput and hou.NetworkDot) do not have names, and so
    will never be returned by this method.

    Raises hou.NotAvailable if you call it from MPlay.

    > >>> hou.item(\\"/obj\\")
    > <hou.OpNode at /obj>
    > >>> hou.item(\\"/obj\\").createNetworkBox()
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> hou.item(\\"/obj/__netbox1\\")
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> hou.cd(\\"/obj\\")
    > >>> hou.item(\\"__netbox1\\")
    > <hou.NetworkBox at /obj/__netbox1>
    > >>> print hou.item(\\"__netbox2\\")
    > None

    RELATED

      * hou.node_

      * hou.nodes

      * hou.items

      * hou.pwd

      * hou.parent

      * hou.root


    '''
def nodes(paths: Sequence[str]) -> Tuple[Node, ...]:
    '''

    hou.nodes

    Takes a sequence of node path strings and returns a tuple of Node
    objects.

    USAGE
      nodes(path_tuple) -> tuple of hou.OpNode

    This is like hou.node_ but takes multiple paths and returns multiple
    node objects. See hou.node_ for more information.

    > paths = [\\"/obj/geo1\\", \\"/obj/geo2\\", \\"/obj/geo3\\"]
    > nodes = hou.nodes(paths)

    This is the equivalent of:

    > nodes = [hou.node(path) for path in paths]

    RELATED

      * hou.item

      * hou.items

      * hou.node

      * hou.pwd

      * hou.parent

      * hou.root


    '''
def items(paths: Sequence[str]) -> Tuple[NetworkMovableItem, ...]:
    '''

    hou.items

    Takes a sequence of node path strings and returns a tuple of
    NetworkMovableItem objects.

    USAGE
      item(path_tuple) -> tuple of hou.NetworkMovableItem or None

    This is like hou.items but takes multiple paths and returns multiple
    item objects. See hou.item for more information.

    > paths = [\\"/obj/geo1\\", \\"/obj/geo2\\", \\"/obj/geo3\\"]
    > items = hou.items(paths)

    This is the equivalent of:

    > items = [hou.item(path) for path in paths]

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.node_

      * hou.nodes

      * hou.item

      * hou.pwd

      * hou.parent

      * hou.root


    '''
def nodeBySessionId(session_id: int) -> Optional[Node]:
    """

    hou.nodeBySessionId

    Given a node's session id, return a Node object. Return None if the id
    does not correspond to a valid node (e.g. if the node was deleted).

    USAGE
      nodeBySessionId(session_id) -> hou.Node or None

    See hou.Node.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.node_

      * hou.Node.sessionId


    """
def networkBoxBySessionId(session_id: int) -> Optional[NetworkBox]:
    """

    hou.networkBoxBySessionId

    Given a network box's session id, return a NetworkBox object. Return
    None if the id does not correspond to a valid network box.

    USAGE
      networkBoxBySessionId(session_id) -> hou.NetworkBox or None

    See hou.NetworkBox.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.NetworkBox.sessionId


    """
def stickyNoteBySessionId(session_id: int) -> Optional[StickyNote]:
    """

    hou.stickyNoteBySessionId

    Given a sticky note's session id, return a StickyNote object. Return
    None if the id does not correspond to a valid sticky note.

    USAGE
      stickyNoteBySessionId(session_id) -> hou.StickyNote or None

    See hou.StickyNote.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.StickyNote.sessionId


    """
def subnetIndirectInputBySessionId(session_id: int) -> Optional[SubnetIndirectInput]:
    """

    hou.subnetIndirectInputBySessionId

    Given a subnet input's session id, return a SubnetIndirectInput object.
    Return None if the id does not correspond to a valid subnet input (e.g.
    if the subnet containing the input was deleted).

    USAGE
      subnetIndirectInputBySessionId(session_id) -> hou.SubnetIndirectInput
      or None

    See hou.SubnetIndirectInput.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.SubnetIndirectInput.sessionId


    """
def networkDotBySessionId(session_id: int) -> Optional[NetworkDot]:
    """

    hou.networkDotBySessionId

    Given a dot's session id, return a NetworkDot object. Return None if the
    id does not correspond to a valid dot (e.g. if the dot was deleted).

    USAGE
      networkDotBySessionId(session_id) -> hou.NetworkDot or None

    See hou.NetworkDot.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.NetworkDot.sessionId


    """
def itemBySessionId(item_type: EnumValue, session_id: int) -> Optional[NetworkMovableItem]:
    """

    hou.itemBySessionId

    Given an item's session id and an item type, return a NetworkMovableItem
    object. Return None if the id does not correspond to a valid item.

    This function is equivalent to a series of if statements checking the
    item_type enum value, and calling the more specific session id functions
    such as hou.nodeBySessionId. It allows network items to be treated in a
    uniform manner by code that is expected to handle a variety of network
    item types.

    The item_type parameter should be one of the hou.networkItemType enum
    values, except hou.networkItemType.Connection, which doesn't support
    lookup using a single session id value.

    USAGE
      itemBySessionId(item_type, session_id) -> hou.NetworkMovableItem or
      None

    See hou.NetworkMovableItem.sessionId for more information.

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.item

      * hou.networkBoxBySessionId

      * hou.networkDotBySessionId

      * hou.nodeBySessionId

      * hou.stickyNoteBySessionId

      * hou.subnetIndirectInputBySessionId

      * hou.NetworkMovableItem.sessionId


    """
def nodeConnectionBySessionId(session_id: int, input_index: int) -> Optional[NodeConnection]:
    """

    hou.nodeConnectionBySessionId

    Given a node's session id and an input index, return a NodeConnection
    object. Return None if the id does not correspond to a valid node (e.g.
    if the node was deleted), or the specified input index is not connected.

    USAGE
      nodeConnectionBySessionId(session_id, input_index) ->
      hou.NodeConnection or None

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.nodeBySessionId

      * hou.Node.sessionId


    """
def createApexRootNode() -> ApexNode:
    """

    hou.createApexRootNode

    Creates a new APEX session graph and returns its root node.

    USAGE
      createApexRootNode() -> hou.ApexNode

    RELATED

      * hou.apexNodeBySessionId

      * hou.ApexNode


    """
def apexNodeBySessionId(session_id: int) -> Optional[ApexNode]:
    """

    hou.apexNodeBySessionId

    Given an APEX node's session ID, return an ApexNode object. Returns None
    if the ID does not correspond to a valid APEX node (e.g. if the node was
    deleted).

    USAGE
      apexNodeBySessionId(session_id) -> hou.ApexNode or None

    Returns an APEX node given its ID in the current Houdini session. See
    hou.ApexNode.sessionId for more information.

    > 
    > >>> apex_node = hou.apexNodeBySessionId(1)
    > >>> apex_node.sessionId()
    > 1

    RELATED

      * hou.createApexRootNode

      * hou.ApexNode


    """
def apexNodeConnectionBySessionId(session_id: int) -> Optional[ApexNodeConnection]:
    """

    hou.apexNodeConnectionBySessionId

    Given an APEX wire's session ID, return an ApexNodeConnection object.
    Returns None if the ID does not correspond to a valid APEX wire
    connection (e.g. if the wire was deleted).

    USAGE
      apexNodeConnectionBySessionId(session_id) -> hou.ApexNodeConnection or
      None

    Returns an APEX node wire connection given its ID in the current Houdini
    session. See hou.ApexNodeConnection.sessionId for more information.

    > 
    > >>> apex_wire = hou.apexNodeConnectionBySessionId(1)
    > >>> apex_wire.sessionId()
    > 1

    RELATED

      * hou.ApexNodeConnection


    """
def apexStickyNoteBySessionId(session_id: int) -> Optional[ApexStickyNote]:
    """

    hou.apexStickyNoteBySessionId

    Given an APEX node's session ID, return an ApexStickyNote object.
    Returns None if the ID does not correspond to a valid APEX sticky note
    (e.g. if the note was deleted).

    USAGE
      apexStickyNoteBySessionId(session_id) -> hou.ApexStickyNote or None

    Returns an APEX sticky note given its ID in the current Houdini session.
    See hou.ApexStickyNote.sessionId for more information.

    > 
    > >>> apex_note = hou.apexStickyNoteBySessionId(1)
    > >>> apex_note.sessionId()
    > 1

    RELATED

      * hou.ApexStickyNote


    """
def defaultColor(color_item: EnumValue) -> Color:
    """

    hou.defaultColor

    Return the default color for a particular network element.

    USAGE
      defaultColor(color_item) -> hou.Color

    Returns the default color that will be used for new network elements
    such as network boxes and sticky notes. Node default colors are
    controlled with methods on the hou.NodeType.

    RELATED

      * hou.colorItemType

      * hou.NodeType.defaultColor

      * hou.setDefaultColor


    """
def setDefaultColor(color_item: EnumValue, color: Color) -> None:
    """

    hou.setDefaultColor

    Return the setDefault color for a particular network element.

    USAGE
      setDefaultColor(color_item, color)

    Sets the default color that will be used for new network elements such
    as network boxes and sticky notes. Node default colors are controlled
    with methods on the hou.NodeType for each node type.

    The color parameter can either be a hou.Color or None, in which case the
    default color is cleared, and the standard default colors are used.

    RELATED

      * hou.colorItemType

      * hou.defaultColor

      * hou.NodeType.setDefaultColor


    """
def selectedNodes(include_hidden: bool = False) -> Tuple[Node, ...]:
    '''

    hou.selectedNodes

    Return a list of all selected nodes.

    USAGE
      selectedNodes(include_hidden=False) -> tuple of hou.OpNode

    Returns a sequence of hou.OpNode objects representing the nodes that are
    currently selected.

    > print(\\"The following nodes are currently selected:\\")
    > for node in hou.selectedNodes():
    >     print(node.path())

    The last selected item has special meaning in Houdini: it controls what
    network unpinned panes focus on.

    > selected = hou.selectedNodes()
    > # In Python, a negative index counts from the end
    > print(\\"Following:\\", selected[-1])

    include_hidden
        Normally, hidden nodes will not be included in the results, even if
        they are selected. Use include_hidden=True to get the selected
        hidden nodes as well. See hou.OpNode.isHidden for more information
        about hidden nodes.


    '''
def selectedItems(include_hidden: bool = False) -> Tuple[NetworkMovableItem, ...]:
    """

    hou.selectedItems

    Return a list of all selected nodes, network boxes, sticky notes, subnet
    indirect inputs, and network dots.


    selectedItems(include_hidden=False) -> tuple of hou.NetworkMovableItem

    If include_hidden is False, hidden nodes will not in the result, even if
    they are selected. See hou.Node.isHidden for more information about
    hidden nodes. Other item types do not support hiding and so are
    unaffected by the value of this parameter.

    The following example will print the positions of all selected items:

    > for n in hou.selectedItems():
    >     print n.position()

    """
def selectedConnections() -> Tuple[NodeConnection, ...]:
    """

    hou.selectedConnections

    Return a list of all selected node connections.


    selectedConnections() -> tuple of hou.NodeConnection

    The following example will print the name of the input node for all
    selected connections:

    > for conn in hou.selectedConnections():
    >     print conn.inputNode().name()

    """
def clearAllSelected() -> None:
    """

    hou.clearAllSelected

    Clears the selected state for all nodes, network boxes, and other
    subclasses of hou.NetworkMovableItem in the Houdini session.

    USAGE
      clearAllSelected()

    This function is equivalent to traversing the node hierarchy and calling
    setSelected(False) on every hou.NetworkMovableItem in the scene, but
    operates much much faster.

    This function will raise hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.NetworkBoxItem.isSelected

      * hou.NetworkBoxItem.setSelected


    """
def copyNodesToClipboard(nodes: Sequence[Node]) -> None:
    """

    hou.copyNodesToClipboard

    Copies a list of nodes to the clipboard.

    USAGE
      copyNodesToClipboard(nodes)

    The nodes argument should be a sequence of hou.OpNode objects that have
    the same parent. Copying nodes from different networks at the same time
    is currently not supported.


    TIP
        The copyItemsToClipboard() and pasteItemsFromClipboard() methods of
        hou.OpNode (called on the parent node) provide a more general way of
        copying and pasting. They work with all types of network items (for
        example, sticky notes and grouping boxes), not just nodes.

    RELATED

      * hou.pasteNodesFromClipboard

      * hou.OpNode.copyItemsToClipboard

      * hou.OpNode.pasteItemsFromClipboard


    """
def pasteNodesFromClipboard(destination_node: Node) -> None:
    """

    hou.pasteNodesFromClipboard

    Paste previously copied nodes to a given network.

    USAGE
      pasteNodesFromClipboard(destination_node)

    This function pastes nodes from clipboard into the destination network.

    RELATED

      * hou.copyNodesToClipboard

      * hou.OpNode.copyItemsToClipboard() and
        hou.OpNode.pasteItemsFromClipboard().


    """
def parm(path: str) -> Optional[Parm]:
    '''

    hou.parm

    Given a path string, return a Parm object. Return None if the path does
    not refer to a parameter.

    USAGE
      parm(path) -> hou.Parm or None

    If the path starts with a /, Houdini will look for a parameter with that
    exact path. Otherwise, the Houdini searches relative to the current node
    path. For each occurrence of .. in the path, Houdini will move up one
    node from the current node location.

    > >>> node = hou.node(\\"/obj\\").createNode(\\"geo\\")
    > >>> node.path()
    > \'/obj/geo1\'
    > >>> hou.parmTuple(\\"/obj/geo1/t\\")
    > <hou.ParmTuple t in /obj/geo1>
    > >>> hou.parmTuple(\\"/obj/geo1/t\\")[0]
    > <hou.Parm tx in /obj/geo1>
    > >>> hou.parm(\\"/obj/geo1/tx\\")
    > <hou.Parm tx in /obj/geo1>
    > >>> hou.setPwd(node)
    > >>> hou.parm(\\"t\\")
    > <hou.Parm tx in /obj/geo1>

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.Parm

      * hou.evalParm

      * hou.parmTuple_


    '''
def parmTuple(path: str) -> Optional[ParmTuple]:
    '''

    hou.parmTuple

    Given a path string, return a ParmTuple object. Return None if the path
    does not refer to a parameter tuple.

    USAGE
      parmTuple(path) -> hou.ParmTuple or None

    If the path starts with a /, Houdini will look for a parameter tuple
    with that exact path. Otherwise, the Houdini searches relative to the
    current node path. For each occurrence of .. in the path, Houdini will
    move up one node from the current node location.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.parmTuple() can be used inside expressions to perform
    relative parameter references.

    > >>> node = hou.node(\\"/obj\\").createNode(\\"geo\\")
    > >>> node.path()
    > \'/obj/geo1\'
    > >>> hou.parmTuple(\\"/obj/geo1/t\\")
    > <hou.ParmTuple t in /obj/geo1>
    > >>> hou.setPwd(node)
    > >>> hou.parmTuple(\\"tx\\")
    > <hou.ParmTuple t in /obj/geo1>

    Raises hou.NotAvailable if you call it from MPlay.

    RELATED

      * hou.ParmTuple

      * hou.evalParmTuple

      * hou.parm_


    '''
def evaluatingParm() -> Optional[Parm]:
    """

    hou.evaluatingParm

    Return the parameter that is currently evaluating.

    USAGE
      evaluatingParm() -> hou.Parm

    You can call this function from a parameter expression to determine
    which parameter is currently evaluating. This function provides the
    Python equivalent of Hscript's $CH variable.

    RELATED

      * hou.ScriptEvalContext


    """
def parmClipboardContents() -> Tuple[dict[str, str], ...]:
    """

    hou.parmClipboardContents

    Returns the contents of the parameter clipboard as a tuple of copied
    parameter dictionaries.

    USAGE
      parmClipboardContents() -> tuple of dictionaries

    Returns a tuple of dictionaries, one per copied hou.Parm. Each
    dictionary has the following keys.


    path
        The path of hou.Parm parameter when it was copied.

    value
        The evaluated value of the parameter when it was copied as a string.

    expression
        The expression of the parameter when it was copied as a string.

    expressionLanguage
        The expression language of the parameter when it was copied. This is
        a string. To convert to a hou.exprLanguage object, use
        getattr(hou.exprLanguage, expr_language_str).

    RELATED

      * hou.Parm.copyToParmClipboard

      * hou.ParmTuple.copyToParmClipboard


    """
def evalParm(path: str) -> ParmReturnType:
    """

    hou.evalParm

    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parm(path).eval().

    USAGE
      evalParm(path) -> int, float, or string

    The return type will depend on the type of the parameter.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParm() can be used inside expressions to perform
    relative parameter references.

    This function throws a hou.NotAvailable exception if you call it from
    MPlay.

    RELATED

      * hou.evalParmTuple

      * hou.Parm

      * hou.ParmTuple


    """
def evalParmTuple(path: str) -> ParmTupleReturnType:
    """

    hou.evalParmTuple

    Evaluate a parameter, given either an absolute or a relative path to it.
    Relative path searches are done from the node returned by . This
    function is a shortcut for hou.parmTuple(path).eval().

    USAGE
      evalParmTuple(path) -> tuple of int, float, or str, or hou.Ramp

    The return type will depend on the type of the parameter.

    When a parameter is evaluating, hou.pwd returns the node containing that
    parameter, so hou.evalParmTuple() can be used inside expressions to
    perform relative parameter references.

    This function throws a hou.NotAvailable exception if you call it from
    MPlay.

    RELATED

      * hou.evalParm

      * hou.Parm

      * hou.ParmTuple


    """
def ch(path: str) -> ParmArgType:
    """

    hou.ch

    The same as evalParm(). Provided for backward compatibility.

    USAGE
      ch(path) -> int, float, or string

    RELATED

      * hou.evalParm

      * hou.evalParmTuple

      * hou.chsop

      * hou.chsoplist

      * hou.parm

      * hou.parmTuple


    """
def hscriptExpression(expression: str) -> float|str|Tuple[float,...]|Tuple[str,...]:
    '''

    hou.hscriptExpression

    Evaluate an Hscript expression.

    USAGE
      hscriptExpression(expression_string) -> float, str, or tuple

    Given an expression string, this function evaluates it as though it was
    an HScript expression on a parameter. The return type depends on the
    expression.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    > >>> hou.hscriptExpression(\\"$HIP\\")
    > \'/path/to/hip/directory\'
    > >>> hou.hscriptExpression(\\"$F\\")
    > 1.0
    > >>> hou.hscriptExpression(\'vector(\\"[1, 2, 3]\\")\')
    > (1.0, 2.0, 3.0)
    > >>> hou.hscriptExpression(\'matrix(\\"[[1, 2][3, 4]]\\")\')
    > ((1.0, 2.0), (3.0, 4.0))
    > >>> hou.hscriptExpression(\\"hello\\")
    > \'hello\'
    > >>> hou.hscriptExpression(\\"\'hello\'\\")
    > \'hello\'
    > >>> hou.hscriptExpression(\\"\'hello\' + \' world\'\\")
    > \'hello world\'
    > >>> hou.hscriptExpression(\'\\"$F\\"\')
    > \'1\'
    > >>> hou.hscriptExpression(\\"\'$F\'\\")
    > \'$F\'

    This function is somewhat similar to hou.expandString, however,
    expandString will replace the portions of the string containing
    variables, leaving the rest of the string unchanged. If the variable is
    unknown, it will not do any expansion.

    > >>> hou.expandString(\\"$HOME\\")
    > \'/home/me\'
    > >>> hou.expandString(\\"HOME is $HOME\\")
    > \'HOME is /home/me\'
    > >>> hou.hscriptExpression(\\"HOME is $HOME\\")
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Syntax error - extra tokens detected in expression
    > >>> hou.expandString(\\"$F\\")
    > \'1\'
    > >>> hou.expandString(\'\\"$F\\"\')
    > \'\\"1\\"\'
    > >>> hou.hscriptExpression(\\"$GARBAGE\\")
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Undefined variable
    > >>> hou.expandString(\\"$GARBAGE\\")
    > \'$GARBAGE\'
    > >>> hou.hscript(\\"echo -n $GARBAGE\\")[0]
    > \'\'
    > >>> hou.expandString(\\"\\")
    > \'\'
    > >>> hou.hscriptExpression(\\"\\")
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 19331, in hscriptExpression
    >     return _hou.hscriptExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Invalid expression

    RELATED

      * hou.hscriptFloatExpression

      * hou.hscriptStringExpression

      * hou.hscriptVectorExpression

      * hou.hscriptMatrixExpression

      * hou.expandString

      * hou.expandStringAtFrame


    '''
def expressionGlobals() -> Any:
    '''

    hou.expressionGlobals

    Return the globals dictionary used by the parameter expression
    evaluation namespace.

    USAGE
      expressionGlobals() -> dict

    When Houdini evaluates a Python expression inside a parameter, it uses a
    separate namespace. This way, Houdini can run from hou import * and from
    hou.session import * in that namespace, allowing you to drop the hou.
    and hou.session. prefixes in your expressions, and the global namespace
    does not get polluted.

    In Python, namespaces are stored as dictionaries. This function returns
    the dictionary for the Python parameter expression namespace. It is
    analogous to the builtin globals function, which returns you the
    dictionary for the current namespace.

    You might use this function from the pythonrc.py file to set up Python
    functions that can be called from any Python parameter expression. For
    example, if you put your functions in a module called expr, you might
    put the following in pythonrc.py:

    > import expr
    > hou.expressionGlobals()[\'expr\'] = expr

    Then, from a Python expression, you could write expr.foo(), where foo is
    a function defined in your expr module.

    You can also use this dictionary with Python\'s exec statement. The
    following example also imports the expr module into the both the global
    and expression namespaces:

    > code = compile(\\"import expr\\", \\"<generated_code>\\", \\"exec\\")
    > exec code
    > exec code in hou.expressionGlobals()

    See Python Parameter Expressions for more information on using Python
    expressions in parameters. See startup scripts for more information
    about pythonrc.py.


    '''
def lvar(name: str) -> float|str:
    '''

    hou.lvar

    Return the value of a node\'s local variable. Call this function from
    expressions inside node parameters.

    USAGE
      lvar(name) -> float or string

    Many node algorithms involve iterating over a series of points (or
    primitives or vertices, but we\'ll use points for the examples). These
    nodes evaluate their parameters for each point, setting a variable that
    you can access from an expression in that parameter to a value specific
    to that point. For example, the TX variable is set to evaluate to the X
    value of the position of the current point. These variables are called
    local variables because they are local to the expressions inside
    parameters in the node.

    In the Hscript expression language, you use $ to evaluate local
    variables, just like how you evaluate global variables. In Python, you
    use the lvar function. So, the Python equivalent of $TX is lvar(\\"TX\\").


    TIP
        Inside a parameter expression you can drop the hou. prefix from the
        call to lvar, since Houdini implicitly runs from hou import * when
        it evaluates expressions.

    If you call this function from outside a parameter expression it will
    raise hou.NotAvailable. If you call it with an invalid variable name, it
    will raise hou.OperationFailed. Note that you cannot use this function
    to evaluate Houdini global variables; instead use hou.expandString.

    Note that hou.SopNode.curPoint and similar methods on the hou.SopNode
    class return the current point that the node is iterating over. Using
    the point, you can evaluate attributes, etc, to perform the equivalent
    of a local variable. You can also access information that may not be
    accessible through local variables.

    RELATED

      * hou.SopNode.curPoint

      * hou.SopNode.curPoint2

      * hou.SopNode.curPrim

      * hou.SopNode.curPrim2

      * hou.SopNode.curVertex

      * hou.SopNode.curVertex2

      * hou.expandString


    '''
def contextOption(opt: str) -> float|str:
    """

    hou.contextOption

    Returns the value of a cook context option.

    USAGE
      contextOption(option) -> float or str

    The return type will depend on the type of data used to set the option
    value.

    Retrieves the current value of a cook context option. This may have been
    set by a node requesting data from another node, or from the global
    default context option values stored in the hip file. A number of
    context options are also set and maintained automatically by Houdini.
    See hou.isAutoContextOption for a list of these automatic options.

    RELATED

      * hou.contextOptionNames

      * hou.hasContextOption

      * hou.isAutoContextOption

      * hou.setContextOption


    """
def loadCPIODataFromString(data: bytes) -> Tuple[Tuple[str, bytes],...]:
    """

    hou.loadCPIODataFromString

    Given a binary string containing data in CPIO data format, decode the
    data and return a sequence of (name, value) pairs representing the data.

    USAGE
      loadCPIODataFromString(data) -> tuple of (str, str)

    CPIO data format stores an ordered sequence of (name, value) pairs. The
    same name may occur multiple times. Is most commonly used to store hip
    files and contents sections inside assets. The other common file format
    used in Houdini is index file format.

    The data must be a bytes object in Python 3 and a str object in Python
    2. See HOM binary data for more information.

    If the data is not in CPIO data format, this function returns an empty
    tuple.

    The inverse of this function is hou.saveCPIODataToString.

    RELATED

      * hou.saveCPIODataToString

      * hou.loadIndexDataFromString

      * hou.saveIndexDataToString


    """
def loadIndexDataFromString(data: bytes) -> dict[str, bytes]:
    """

    hou.loadIndexDataFromString

    Given a binary string containing data in index data format, decode the
    data and return a dictionary representing the data.

    USAGE
      loadIndexDataFromString(data) -> dict

    Index data format stores an unordered mapping of (key, value) pairs
    where keys are str objects and the values are str objects or binary
    strings. Binary strings are str objects in Python 2 and bytes objects in
    Python 3 (see HOM binary data for more information). Is used to store
    otl files and asset definition sections, preset files, icon archives,
    and other files in Houdini. The other common file format used in Houdini
    is CPIO.

    If the data is not in index data format, this function returns an empty
    dictionary.

    The inverse of this function is hou.saveIndexDataToString.

    RELATED

      * hou.saveIndexDataToString

      * hou.loadIndexDataFromFile

      * hou.saveIndexDataToFile

      * hou.loadCPIODataFromString

      * hou.saveCPIODataToString


    """
def addContextOptionChangeCallback(callback: Callable[[str], None]) -> None:
    """

    hou.addContextOptionChangeCallback

    Adds a callback to be executed when a default context option is changed.

    USAGE
      addContextOptionChangeCallback(callback)

    Adds a callback that is run every time a global context option is
    changed. This refers to context options set in the Edit -> Context
    Options window. The callback is not run when a context option value is
    modified by a node, such as the Edit Context Options LOP.

    The callback is run whenever the value a context option changes, when a
    new context option is added, the UI description of a context option is
    changed, or when a context option is removed. In all cases, the name of
    the modified context option is passed as a string to the callback
    function.

    RELATED

      * hou.contextOptionChangeCallbacks

      * hou.removeContextOptionChangeCallback

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
def removeContextOptionChangeCallback(callback: Callable[[str], None]) -> None:
    """

    hou.removeContextOptionChangeCallback

    Stops a callback from being executed when a default context option is
    changed.

    USAGE
      removeContextOptionChangeCallback(callback)

    Removes a callback that was previously registered with
    hou.addContextOptionChangeCallback. If the supplied callback is not
    currently registered, a hou.OperationFaile exception is raised.

    RELATED

      * hou.addContextOptionChangeCallback

      * hou.contextOptionChangeCallbacks

      * hou.removeAllContextOptionChangeCallbacks

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
def contextOptionChangeCallbacks() -> Tuple[Callable[[str], None],...]:
    """

    hou.contextOptionChangeCallbacks

    Returns all callbacks registered to be called when a default context
    option is changed.

    USAGE
      contextOptionChangeCallbacks()

    Returns all callbacks that have been registered with
    hou.addContextOptionChangeCallback.

    RELATED

      * hou.addContextOptionChangeCallback

      * hou.removeAllContextOptionChangeCallbacks

      * hou.removeContextOptionChangeCallback

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
def hscriptFloatExpression(expression: str) -> float:
    '''

    hou.hscriptFloatExpression

    Evaluate an Hscript expression as a float.

    USAGE
      hscriptFloatExpression(expression) -> float

    This function will force the return type to be a float.

    Most of the time, you want to use hou.hscriptExpression over this
    function. See it for more examples.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    If the expression contains variables, Houdini will attempt to evaluate
    them as floats, and use the value 0.0 if they cannot be converted to
    floats. However, if the expression definitely evaluates to a string that
    does not start with a number, this function raises hou.OperationFailed.

    > >>> hou.hscriptFloatExpression(\\"3\\")
    > 3.0
    > >>> hou.hscriptFloatExpression(\\"\'3\'\\")
    > 3.0
    > >>> hou.hscriptFloatExpression(\\"\'3X\'\\")
    > 3.0
    > >>> hou.hscriptFloatExpression(\\"\'X3\'\\")
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    > >>> hou.hscriptFloatExpression(\\"3X\\")
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Syntax error - extra tokens detected in expression
    > >>> hou.hscriptFloatExpression(\\"$F\\")
    > 1.0
    > >>> hou.hscriptFloatExpression(\'\\"$F\\"\')
    > 1.0
    > >>> hou.hscriptFloatExpression(\\"$HOME\\")
    > 0.0
    > >>> hou.hscriptFloatExpression(\'\\"$HOME\\"\')
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation
    > >>> hou.hscriptFloatExpression(\\"\'$F\'\\")
    > Traceback (most recent call last):
    >   File \\"<console>\\", line 1, in <module>
    >   File \\"/opt/hfs10.5/houdini/python2.5libs/hou.py\\", line 9359, in hscriptFloatExpression
    >     return _hou.hscriptFloatExpression(*args)
    > OperationFailed: The attempted operation failed.
    > Bad data type for function or operation

    RELATED

      * hou.hscriptExpression

      * hou.hscriptStringExpression

      * hou.hscriptVectorExpression

      * hou.hscriptMatrixExpression


    '''
def hscriptStringExpression(expression: str) -> str:
    '''

    hou.hscriptStringExpression

    Evaluate an Hscript expression as a string.

    USAGE
      hscriptStringExpression(expression) -> string

    This function will force the return type to be a string. If the
    expression does not evaluate to a string, this function returns its
    string representation.

    Most of the time, you want to use hou.hscriptExpression over this
    function. See it for more examples.

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    > >>> hou.hscriptStringExpression(\\"3\\")
    > \'3\'
    > >>> hou.hscriptStringExpression(\'\\"3\\"\')
    > \'3\'
    > >>> hou.hscriptStringExpression(\\"$F\\")
    > \'1\'
    > >>> hou.hscriptStringExpression(\'vector(\\"[1, 2, 3]\\")\')
    > \'[1,2,3]\'

    RELATED

      * hou.hscriptExpression

      * hou.hscriptFloatExpression

      * hou.hscriptVectorExpression

      * hou.hscriptMatrixExpression


    '''
def hscriptVectorExpression(expression: str) -> Tuple[float, ...]:
    '''

    hou.hscriptVectorExpression

    Evaluate an Hscript expression as a vector.

    USAGE
      hscriptVectorExpression(expression) -> tuple of floats

    This function will force the return type to be an Hscript vector.
    Because Hscript vectors can be be of different lengths, the value is
    returned as a tuple of floats. If you know the vector is a particular
    length, you can construct a Vector2/Vector3/Vector4 out of the return
    value.

    Most of the time, you want to use hou.hscriptExpression over this
    function.

    > vector = hou.Vector3(hou.hscriptVectorExpression(\'vtorigin(\\"/obj/geo1\\", \\"/obj/geo2\\")\'))
    > print vector.length()

    Raises hou.OperationFailed if the expression is invalid or generates an
    error occur during evaluation.

    RELATED

      * hou.hscriptExpression

      * hou.hscriptFloatExpression

      * hou.hscriptStringExpression

      * hou.hscriptMatrixExpression

      * hou.Vector2

      * hou.Vector3

      * hou.Vector4


    '''
def hscriptMatrixExpression(expression: str) -> Tuple[Tuple[float, ...], ...]:
    '''

    hou.hscriptMatrixExpression

    Evaluate an Hscript expression as a matrix.

    USAGE
      hscriptMatrixExpression(expression) -> tuple of tuple of floats

    This function will force the return type to be an Hscript matrix.
    Because Hscript matrices can be be of different sizes, the value is
    returned as a tuple of tuples of floats. If you know the matrix is a
    particular size, you can construct a Matrix3/Matrix4 out of the return
    value.

    Most of the time, you want to use hou.hscriptExpression over this
    function.

    > xform = hou.Matrix4(hou.hscriptMatrixExpression(\'doptransform(\\"/obj/dopnet1\\", \\"obj0\\", \\"Geometry\\")\'))

    Raises hou.OperationFailed if the expression is invalid or generates an
    error during evaluation.

    RELATED

      * hou.hscriptExpression

      * hou.hscriptFloatExpression

      * hou.hscriptStringExpression

      * hou.hscriptVectorExpression

      * hou.Matrix3

      * hou.Matrix4


    '''
def getEnvConfigValue(name: str, default_value: Optional[str] = None) -> Optional[str]:
    """

    hou.getEnvConfigValue

    Return the value of the specified Houdini environment variable as
    Houdini will treat it.

    USAGE
      getEnvConfigValue(name, default_value=None) -> str

    Return the value of the specified Houdini environment variable as
    Houdini will treat it. This is essentially a wrapper around hou.getenv
    that treats managed Houdini environment variables as a special case to
    return the default value that will be used by Houdini if the environment
    variable does not exist or a clamped value if it does exist but exceeds
    the allowed bounds. It will return default_value if the environment
    variable does not exist and is not a managed Houdini environment
    variable for which we have a known default.

    Note that for unset path variables this will not typically reflect the
    paths that Houdini will end up using in their place.

    RELATED

      * hou.getenv

      * hou.putenv

      * hou.unsetenv


    """
def getenv(name: str, default_value: Optional[str] = None) -> Optional[str]:
    """

    hou.getenv

    Return the value of the specified Houdini environment variable.

    USAGE
      getenv(name, default_value=None) -> str

    Return the value of the specified Houdini environment variable. Return
    default_value if the environment variable does not exist.

    Consider using hou.getEnvConfigValue instead for environment variables
    that Houdini recognizes and manages.

    RELATED

      * hou.getEnvConfigValue

      * hou.putenv

      * hou.unsetenv


    """
def putenv(name: str, value: str) -> None:
    """

    hou.putenv

    Set the value of the specified Houdini environment variable.

    USAGE
      putenv(name, value)

    Set the value of the specified Houdini environment variable.

    RELATED

      * hou.getenv

      * hou.unsetenv


    """
def unsetenv(name: str) -> None:
    """

    hou.unsetenv

    Unset the specified Houdini environment variable.

    USAGE
      unsetenv(name)

    Unset the specified Houdini environment variable.

    RELATED

      * hou.getenv

      * hou.putenv


    """
def allowEnvironmentToOverwriteVariable(name: str, onoff: bool) -> None:
    '''

    hou.allowEnvironmentToOverwriteVariable

    Allow (or disallow) an environment variable to overwrite the value of a
    global variable saved in a hip file.

    USAGE
      allowEnvironmentToOverwriteVariable(name, onoff)

    Note that you need to allow the variable to be overwritten from within
    Houdini/hython before loading in the hip file.

    For example, suppose you set the JOB environment variable to
    /home/john/dyproject and created a hip file in
    /home/john/myproject/hip/scene.hip. Your hip file could then reference
    files using a $JOB prefix. If you then moved your project to
    /mnt/projects/myproject you cannot simply change the JOB environment
    variable because Houdini saved the old value of $JOB to the hip file.
    This function lets you override the value of $JOB before you load the
    hip file, as follows:

    > import os
    > os.environ[\\"JOB\\"] = \\"/mnt/projects/myproject\\"
    > hou.allowEnvironmentToOverwriteVariable(\\"JOB\\", True)
    > hou.hipFile.load(os.path.expandvars(\\"$JOB/hip/scene.hip\\"))

    '''
def updateProgressAndCheckForInterrupt(percentage: int = -1) -> bool:
    """

    hou.updateProgressAndCheckForInterrupt

    Deprecated: Use InterruptableOperation.

    Check if the user pressed Escape to interrupt the current operation, and
    optionally update the completion progress.

    USAGE
      updateProgressAndCheckForInterrupt(percentage=-1) -> bool


    WARNING
        This is deprecated. Use hou.InterruptableOperation instead.

    Return True if the user pressed Escape and False otherwise.


    percentage
        An integer value containing the percentage complete to display in
        the taskbar. If the percentage is -1, the taskbar will not display
        the completion percentage.

    You would typically call this function from inside a Python SOP, to let
    the user of the SOP press escape to interrupt a long cook.

    See Define a new SOP type using Python for an example.


    """
def runVex(vex_file: str, inputs: Mapping[str, OptionType|OptionSequenceType], precision: Literal['32','64'] = ...) -> dict[str, Any]:
    '''

    hou.runVex

    Invokes the main function in a compiled VEX file, returning the exported
    values.

    USAGE
      runVex(vex_file, inputs, precision=\\"32\\") -> dict of str to values

    ARGUMENTS


        vex_file
            A string containing the path to a compiled VEX object file
            (.vex) on disk. This function does not accept VEX source code
            (.vfl), you must compile the source code first.

            Currently this function only works with functions in the cvex
            context.

            runVex currently raises an exception if the file path does not
            end with .vex.


            NOTE
                runVex always calls the main function in the compiled file
                (the function whose return type is the context type, cvex).
                It is not currently possible to call another function in the
                compiled file by name.

        inputs
            A dictionary mapping VEX input names to values.

          * If a value is a single number, string, hou.Vector3, hou.Vector4,
            hou.Matrix3, or hou.Matrix4, it is treated as a static value.

          * If a value is a sequence of values, it is treated as varying
            data the function will iterate over (possibly in parallel)
            automatically. This is the same as when, for example, a VEX
            snippet runs over all the points in a geometry. It is more
            efficient to call the function once with varying data than to
            call it separately for each of a list of different values.

          * If you supply multiple varying inputs, they must all be the same
            length and all values must be the same type. Houdini iterates
            over the corresponding values at each index of the varying
            sequences.

                For example, you might have two arguments corresponding to a
                point\'s color (Cd) and position (P) attributes:

              > runVex(\\"test.vex\\", {
              >     \\"Cd\\": [hou.Vector3(1.0, 0, 0), hou.Vector3(0, 1.0, 0), hou.Vector3(0, 0, 1.0)],
              >     \\"P\\": [hou.Vector3(1.0, 1.0, 1.0), hou.Vector3(2.0, 2.0, 2.0), hou.Vector3(3.0, 3.0, 3.0)]
              > })

                Houdini would zip the two lists together and iterate using
                the following values:

                1
                Vector3(1.0, 0, 0)

                Vector3(1.0, 1.0, 1.0)

                2
                Vector3(0, 1.0, 0)

                Vector3(2.0, 2.0, 2.0)

                3
                Vector3(0, 0, 1.0)

                Vector3(3.0, 3.0, 3.0)


            NOTE
                Because this function interprets a sequence as varying data,
                it is not currently possible for this function to call VEX
                with array arguments.

        precision
            Either \\"32\\" or \\"64\\". If you specify \\"64\\" Houdini will run the
            VEX snippet in 64-bit mode.

    RETURNS

        runVex() returns a dictionary mapping VEX output names to values.

        The main VEX function does not directly return values, it can only
        write to arguments marked export. This dictionary contains the
        output value of the exported arguments.

        If the input to the argument was static, the output will be a single
        value. If the input to the argument was varying, the output will be
        a tuple of values. If multiple arguments were varying, the output
        tuples will all be the same length.

    EXAMPLE

        For example, if you have the following code.vfl file and compile it
        to code.vex using vcc:

      > cvex add(float x=0; float y=0; export float out=0)
      > {
      >     out = x + y;
      > }

        You can then invoke it from Python using the following:

      > >>> hou.runVex(\\"code.vex\\", {\\"x\\":(1.0, 2.0, 3.0), \\"y\\":(7.1, 8.1, 9.1)})
      > {\\"out\\": (8.1, 10.1, 12.1)}
      > >>> hou.runVex(\\"code.vex\\", {\\"x\\":(1.0, 2.0, 3.0), \\"y\\":0.5})
      > {\\"out\\": (1.5, 2.5, 3.5)}
      > >>> hou.runVex(\\"code.vex\\", {\\"x\\":1.0, \\"y\\":0.5})
      > {\\"out\\": 1.5}
      > >>> hou.runVex(\\"code.vex\\", {\\"x\\":1.0, \\"y\\":0.5}, precision=\\"64\\")
      > {\\"out\\": 1.5}

    USING A VOP NETWORK

        The following code shows how you can write the VEX code created by a
        VOP network node (such as a CVEX VOP) to a file, for use with
        runVex:

      > import os
      > import tempfile
      > 
      > def runVexFromNode(vop_node, input_dict):
      >     handle, path = tempfile.mkstemp(prefix=vop_node.name(), suffix=\\".vex\\")
      >     vop_node.saveCompiledCookCodeToFile(path)
      >     os.close(handle)
      >     output_dict = hou.runVex(path, input_dict)
      >     os.remove(path)
      >     return output_dict


    '''
def saveImageDataToFile(color_and_alpha_data: Sequence[float]|bytes, width: int, height: int, file_name: str) -> None:
    '''

    hou.saveImageDataToFile

    Create an image file from color and alpha pixel data.

    USAGE
      saveImageDataToFile(color_and_alpha_data, width, height, file_name,
      flip_vertical=False)


    color_and_alpha_data
        Either a sequence of floats or a binary string containing the image
        data. The data must be in interleaved format, meaning that the first
        4 values are the red, green, blue, and alpha (RGBA) values for the
        first pixel, the next 4 are for the second pixel, and so on. The
        first row of pixels in the data corresponds to the top scanline in
        the image.

        The length of this sequence must be width * height * 4.

        If you are writing a .pic file, the file will store 32-bit float
        data if you pass in a sequence of floats and 8-bit unsigned data if
        you pass in a string.

        The binary string data must be a bytes object in Python 3 and a str
        object in Python 2. See HOM binary data for more information.

    width, height
        The width and height of the image to be written.

    file_name
        The name of the output image file to create. Houdini will
        automatically determine which type of file to create based on this
        file\'s extension.

    flip_vertical
        Whether or not the image should be flipped on the vertical axis.

    This function provides two features not provided by other imaging
    libraries:

      * It lets you create files in Houdini\'s .pic format.

      * It lets you save images with 32-bit float data.

    Raises hou.OperationFailed if the data is not the correct size, the
    output file could not be created, or the output file format is not
    supported by Houdini.

    The following example uses the Python imaging library (PIL) to read in a
    file and calls this function to write it out. Using the convertImage
    function below, you can convert any image that can be read by PIL into
    Houdini\'s .pic format.

    > import Image
    > 
    > def convertImage(input_image, output_image):
    >     im = Image.open(input_image)
    >     im.mode != \\"RGBA\\":
    >         raise ValueError(\\"The image must contain alpha information\\")
    >     hou.saveImageDataToFile(im.tostring(), im.size[0], im.size[1], output_image)
    > 
    > convertImage(\\"image.png\\", \\"image.pic\\")

    See also Writing a COP in Python.


    '''
def loadImageDataFromFile(file_name: str, arg: EnumValue = ...) -> bytes: ...
def imageResolution(image_file_name: str) -> Tuple[int, ...]:
    '''

    hou.imageResolution

    Return the resolution of an image in a file.

    USAGE
      imageResolution(image_file_name) -> tuple of int

    Returns the width and height of an image stored in a file.

    Another way to get the resolution of an image is to load it into a file
    cop and retrieve it. For example, this method could be approximately
    implemented as follows:

    > def imageResolution(image_file_name):
    >     file_cop = hou.node(\\"/img/comp1\\").createNode(\\"file\\")
    >     file_cop.setParm(\\"filename1\\", image_file_name)
    >     resolution = (file_cop.xRes(), file_cop.yRes())
    >     file_cop.destroy()
    >     return resolution

    Note, however, that this method is faster than loading the image into
    Houdini and retrieving the resolution because it is much less disk
    intensive. It does not load the image data from disk, and instead only
    loads as much as necessary to retrieve the resolution.

    Raises hou.OperationFailed if the image file does not exist or if it\'s
    not an image file type supported by Houdini.

    The following example retrieves the resolution of the default.pic file
    that ships with Houdini.

    > >>> hou.imageResolution(hou.findFile(\\"pic/default.pic\\"))
    > (512, 512)

    RELATED

      * hou.Cop2Node.xRes

      * hou.Cop2Node.yRes


    '''
def runCallbackAndCatchCrashes(callback: Callable) -> Optional[Any]: ...
def updateModeSetting() -> EnumValue:
    """

    hou.updateModeSetting

    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.

    USAGE
      updateModeSetting() -> hou.updateMode enum value

    Houdini's update mode determines when it will recook its nodes after you
    make parameter changes. When it is Auto Update, it will recook whenever
    any parameter changes. When it is On Mouse Up, it will not recook while
    you are tuning a parameter with a viewport or ladder handle until you
    release the mouse. When it is Manual, it will only recook when you press
    the update button in the status bar.

    Note that this function is named updateModeSetting because
    hou.updateMode refers to the submodule containing enumeration values.
    This function used to be in the hou.ui submodule, but it was moved into
    the main hou module because it also applies to a non-graphical Houdini.

    > >>> # Prevent Houdini from cooking any nodes.
    > >>> hou.setUpdateMode(hou.updateMode.Manual)
    > >>> hou.updateModeSetting()
    > hou.updateMode.Manual

    RELATED

      * hou.setUpdateMode

      * hou.ui.triggerUpdate.


    """
def setUpdateMode(mode: EnumValue) -> None:
    """

    hou.setUpdateMode

    Return Houdini's cook update mode (Auto Update/On Mouse Up/Manual) that
    is displayed in the status bar.

    USAGE
      updateModeSetting() -> hou.updateMode enum value

    Set Houdini's cook update mode to a hou.updateMode enumerated value. See
    hou.updateModeSetting for more information.


    """
def orboltURLHandler() -> Optional[OrboltURLHandler]: ...
def chsop(path: str) -> str:
    """

    hou.chsop

    Evaluate a parameter that references a node, and return the absolute
    path to the node.

    USAGE
      chsop(parameter_path) -> string

    RELATED

      * hou.evalParm

      * hou.chsoplist


    """
def chsoplist(path: str) -> str:
    """

    hou.chsoplist

    Evaluate a parameter that references a node path list, and return a
    space separated list of absolute node paths.

    USAGE
      chsoplist(parameter_path) -> string

    RELATED

      * hou.evalParm

      * hou.chsop


    """
def sortedNodePaths(paths: Sequence[str]) -> Tuple[str, ...]:
    '''

    hou.sortedNodePaths

    Given a tuple of path strings, return a tuple of path strings sorted in
    input/outputs order. Invalid node paths won\'t be part of the sorted
    list.

    USAGE
      sortedNodePaths(path_tuple) -> tuple of string

    Sorts nodes following the network traversal order. Root nodes appear
    first and leaf nodes come last.

    > >>> hou.node(\'/obj\').createNode(\'simplefemale\')
    > <hou.ObjNode of type simplefemale at /obj/simplefemale1>
    > >>> paths = [\\"/obj/simplefemale1/ctrl_master\\",\\"/obj/simplefemale1/ctrl_IK_wrist_right\\",\\"/obj/simplefemale1/ctrl_cog\\",\\"/obj/simplefemale1/ctrl_neck\\",\\"/obj/simplefemale1/ctrl_head\\",\\"/obj/simplefemale1/ctrl_FK_hand_right\\"]
    > >>> hou.sortedNodePaths(paths)
    > (\'/obj/simplefemale1/ctrl_master\', \'/obj/simplefemale1/ctrl_cog\', \'/obj/simplefemale1/ctrl_IK_wrist_right\', \'/obj/simplefemale1/ctrl_neck\', \'/obj/simplefemale1/ctrl
    > _head\', \'/obj/simplefemale1/ctrl_FK_hand_right\')

    RELATED

      * hou.node

      * hou.nodes

      * hou.OpNode

      * hou.sortedNodes


    '''
def sortedNodes(nodes: Sequence[Node]) -> Tuple[Node, ...]:
    '''

    hou.sortedNodes

    Given a tuple of hou.Node, return a tuple of hou.Node sorted in
    input/outputs order.

    USAGE
      sortedNodePaths(node_tuple) -> tuple of hou.Node

    Sorts nodes following the network traversal order. Root nodes appear
    first and leaf nodes come last.

    > >>> hou.node(\'/obj\').createNode(\'simplefemale\')
    > <hou.ObjNode of type simplefemale at /obj/simplefemale1>
    > >>> nodes = hou.nodes( [\\"/obj/simplefemale1/ctrl_master\\",\\"/obj/simplefemale1/ctrl_IK_wrist_right\\",\\"/obj/simplefemale1/ctrl_cog\\",\\"/obj/simplefemale1/ctrl_neck\\",\\"/obj/simplefemale1/ctrl_head\\",\\"/obj/simplefemale1/ctrl_FK_hand_right\\"] )
    > >>> hou.sortedNodes(nodes)
    > (\'/obj/simplefemale1/ctrl_master\', \'/obj/simplefemale1/ctrl_cog\', \'/obj/simplefemale1/ctrl_IK_wrist_right\', \'/obj/simplefemale1/ctrl_neck\', \'/obj/simplefemale1/ctrl
    > _head\', \'/obj/simplefemale1/ctrl_FK_hand_right\')

    RELATED

      * hou.node

      * hou.nodes

      * hou.Node

      * hou.sortedNodePaths


    '''
def patternMatch(pattern: str, str: str, ignore_case: bool = False, path_match: bool = False) -> int:
    """

    hou.patternMatch

    Deprecated, please use hou.text.patternMatch.


    """
def chopExportConflictResolutionPattern() -> str:
    """

    hou.chopExportConflictResolutionPattern

    Returns a CHOP node path pattern to take precedence when exporting to
    the same channel.

    USAGE
      chopExportConflictResolutionPattern() -> str

    Returns a pattern for matching CHOP node paths that should take
    precedence when there are other CHOPs that override the same channels
    thus leading to conflicts.


    """
def setChopExportConflictResolutionPattern(pattern: str) -> None:
    """

    hou.setChopExportConflictResolutionPattern

    Sets a CHOP node path pattern to take precedence when exporting to the
    same channel.

    USAGE
      setChopExportConflictResolutionPattern(string pattern) -> None

    Sets a pattern for matching CHOP node paths that should take precedence
    when there are other CHOPs that override the same channels thus leading
    to conflicts.


    """
def nodeType(category_or_name: NodeTypeCategory|str, internal_name: str|None = ...) -> NodeType|None:
    '''

    hou.nodeType

    Takes a category object and a name, or just a full name string, and
    returns the corresponding NodeType object.

    USAGES

        This function acts differently depending if you pass it one or two
        arguments.

        USAGES
          nodeType(category, internal_name) -> hou.NodeType or None
          Where category is a hou.NodeTypeCategory (not a string), and
          internal_name is a string containing the internal name of a node
          type, which may include a scope, namespace, and/or version.

          For example:

        > nodetype = hou.nodeType(hou.SopNodeTypeCategory(), \\"acme::rocketboots::2.0\\")
          nodeType(internal_name_with_category)
          Where internal_name_with_category is a string containing the
          internal name of a node type including the category, which may
          also include a scope, namespace, and/or version.

          For example:

        > nodetype = hou.nodeType(\\"acme::Sop/rocketboots::2.0\\")

    TIPS AND NOTES

      * Do not confuse hou.nodeType() (starts with a lower-case N, a
        function that returns a NodeType object) with NodeType (starts with
        an upper-case N, the class representing node types).

      * If you have a Node reference to a node in the network, you can get
        its type object by calling hou.Node.type.

      * Each node category has a corresponding function to returns its
        corresponding hou.NodeTypeCategory object. For example,
        hou.sopNodeTypeCategory, hou.objNodeTypeCategory,
        hou.lopNodeTypeCategory, and so on.

      * hou.nodeTypeCategories returns a dict mapping category names to
        NodeTypeCategory objects.

      * If you have a category object, hou.nodeTypeCategory.nodeType takes
        the internal name of a node type and returns the corresponding
        hou.NodeType object. hou.NodeTypeCategory.nodeTypes returns a dict
        mapping internal names to hou.NodeType objects.

      * To see the internal name of a node in the network editor, right
        click the node and choose Type Properties. The internal name
        (without the type category) is at the top of the window labelled
        Operator Type.

    EXAMPLES

      > # The following four ways of looking up the copy SOP\'s node type are equivalent:
      > >>> hou.nodeType(\\"Sop/copy\\")
      > <hou.SopNodeType for Sop copy>
      > 
      > >>> hou.nodeType(hou.sopNodeTypeCategory(), \\"copy\\")
      > <hou.SopNodeType for Sop copy>
      > 
      > >>> hou.nodeType(\\"acme::Sop/rocketboots::2.0\\")
      > <hou.SopNodeType for Sop acme::rocketboots::2.0>
      > 
      > >>> hou.nodeType(hou.sopNodeTypeCategory(), \\"acme::rocketboots::2.0\\")
      > <hou.SopNodeType for Sop acme::rocketboots::2.0>

    RELATED

      * hou.NodeType

      * hou.NodeTypeCategory

      * hou.NodeTypeCategory.nodeType

      * hou.NodeTypeCategory.nodeTypes

      * hou.nodeTypeCategories

      * hou.preferredNodeType


    '''
def preferredNodeType(name: str, parent_node: Optional[Node] = None) -> Optional[NodeType]:
    '''

    hou.preferredNodeType

    Given a node type name that includes the category and optionally a
    parent node, return the corresponding NodeType object after evaluating
    aliases. Return None if there is no such type with that name.

    USAGE
      preferredNodeType(name, parent_node=None) -> NodeType or None


    name
        The internal name of a node type including the category. To get the
        internal name of any node type in Houdini, right-click a node of
        that type and choose Type properties. The internal name is listed at
        the top of the type properties window beside Operator type. For
        example, the internal name of the Geometry object is geo.

    parent_node
        Optional. The node that will be the parent for this node type.

    EXAMPLES

      > >>> hou.preferredNodeType(\\"Shop/pyro\\")
      > <hou.ShopNodeType for Shop pyro::3.0>
      > 
      > >>> hou.preferredNodeType(\\"Shop/pyro\\", hou.node(\\"/shop\\"))
      > <hou.ShopNodeType for Shop pyro::3.0>

    RELATED

      * hou.NodeType

      * hou.nodeType

      * hou.nodeTypeCategories


    '''
def objNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.objNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini object nodes. For
    example, if /obj/model is an object then
    hou.node(/obj/model).type().category() is hou.objectNodeTypeCategory().

    USAGE
      objNodeTypeCategory() -> NodeTypeCategory


    """
def sopNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.sopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini geometry (sop) nodes.

    USAGE
      sopNodeTypeCategory() -> NodeTypeCategory


    """
def dopNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.dopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini dynamic (DOP) nodes.

    USAGE
      dopNodeTypeCategory() -> NodeTypeCategory


    """
def cop2NodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.cop2NodeTypeCategory

    Return the NodeTypeCategory instance for Houdini composite (cop2) nodes.


    WARNING
        As of Houdini 20.5, use Copernicus nodes instead of Compositing
        nodes. Though both networks still exist, the Compositing network is
        now designated as COP Network - Old. The Compositing network and its
        nodes will be deprecated and then removed in a future Houdini
        release.

    USAGE
      cop2NodeTypeCategory() -> NodeTypeCategory


    """
def copNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.copNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini composite (cop) nodes.

    USAGE
      copNodeTypeCategory() -> NodeTypeCategory


    """
def shopNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.shopNodeTypeCategory

    Return the NodeTypeCategory object corresponding to shader (SHOP) nodes.

    USAGE
      shopNodeTypeCategory() -> hou.NodeTypeCategory

    Be careful not to confuse this function with the class
    hou.ShopNodeTypeCategory.


    """
def vopNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.vopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini vex builder (VOP)
    nodes.

    USAGE
      vopNodeTypeCategory() -> NodeTypeCategory


    """
def ropNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.ropNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini output (rop) nodes.

    USAGE
      ropNodeTypeCategory() -> NodeTypeCategory


    """
def chopNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.chopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini channel (chop) nodes.

    USAGE
      chopNodeTypeCategory() -> NodeTypeCategory


    """
def cop2NetNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.cop2NetNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini composite container
    (cop2net) nodes.


    WARNING
        As of Houdini 20.5, use Copernicus nodes instead of Compositing
        nodes. Though both networks still exist, the Compositing network is
        now designated as COP Network - Old. The Compositing network and its
        nodes will be deprecated and then removed in a future Houdini
        release.

    USAGE
      cop2NetNodeTypeCategory() -> NodeTypeCategory


    """
def vopNetNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.vopNetNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini vex builder container
    (vopnet) nodes.

    USAGE
      vopNetNodeTypeCategory() -> NodeTypeCategory


    """
def chopNetNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.chopNetNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini channel container
    (chopnet) nodes.

    USAGE
      chopNetNodeTypeCategory() -> NodeTypeCategory


    """
def topNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.topNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini task (top) nodes.

    USAGE
      topNodeTypeCategory() -> NodeTypeCategory


    """
def lopNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.lopNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini lighting (lop) nodes.

    USAGE
      lopNodeTypeCategory() -> NodeTypeCategory


    """
def managerNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.managerNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini manager nodes. The
    manager nodes are /obj, /out, /part, /ch, /shop, /img, and /vex.

    USAGE
      managerNodeTypeCategory() -> NodeTypeCategory

    Note that some container node types, like the shop network node type,
    are called managers in Houdini. The node type category for an instance
    of those nodes will be the same as other nodes in that same network. For
    example, a shop network in objects will be in the objects node type
    category, while a shop network in a sop network will be in the geometry
    node type category.


    """
def rootNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.rootNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini root (/) node. There is
    only one instance of the root node, and it has its own node type
    category.

    USAGE
      rootNodeTypeCategory() -> NodeTypeCategory


    """
def dataNodeTypeCategory() -> OpNodeTypeCategory:
    """

    hou.dataNodeTypeCategory

    Return the NodeTypeCategory instance for Houdini data nodes. These nodes
    can never be instantiated, but exist to store namespaced data inside of
    HDAs that doesn't belong to a specific operator.

    USAGE
      dataNodeTypeCategory() -> NodeTypeCategory


    """
def nodeTypeCategories() -> dict[str, NodeTypeCategory]:
    """

    hou.nodeTypeCategories

    Return a dictionary where the keys are the category names (e.g. Object,
    Sop) and the values are hou.NodeTypeCategory objects.

    USAGE
      nodeTypeCategories() -> dict of str to hou.NodeTypeCategory


    """
def apexNodeTypeCategory() -> ApexNodeTypeCategory:
    """

    hou.apexNodeTypeCategory

    Return the NodeTypeCategory instance for APEX nodes.

    USAGE
      apexNodeTypeCategory() -> NodeTypeCategory


    """
def copyNodesTo(nodes: Sequence[Node], destination_node: Node) -> Tuple[Node, ...]:
    """

    hou.copyNodesTo

    Copy all given nodes to a new place in node hierarchy.

    USAGE
      copyNodesTo(nodes, destination_node) -> tuple of Nodes

    The nodes to be copied should be a sequence of hou.OpNode objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.

    This function returns a tuple of hou.OpNode objects corresponding to the
    copied nodes.

    Nodes will be copied to the destination in batches based on their
    parent. All the nodes in a batch will be copied at the same time. This
    way, any relative channel references between nodes with the same parent
    will be updated to reflect the copied node location. Batches themselves
    will be copied sequentially. Thus, channel references between nodes with
    different parents will not be updated in copies.

    For every copied node, if a node with the same name already exists at
    the destination, the copy will be renamed. Any relative channel
    references to the copy will be updated with the new copy name.

    This function will raise a hou.OperationFailed exception if any of the
    nodes to be copied are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node
    child type.

    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.

    All of the above issues with source and destination nodes will be
    reported before copying starts to avoid partial copy.

    After the function finishes execution, all the new nodes created by it
    will be selected.


    """
def moveNodesTo(nodes: Sequence[Node], destination_node: Node) -> Tuple[Node, ...]:
    """

    hou.moveNodesTo

    Move all given nodes to a new place in node hierarchy.

    USAGE
      moveNodesTo(nodes, destination_node) -> tuple of Nodes

    The nodes to be moved should be a sequence of hou.OpNode objects. The
    destination node will be the parent of new copied nodes. The type of all
    source nodes should match the destination node child type.

    This function returns a tuple of hou.OpNode objects corresponding to the
    nodes at their new locations. If you attempt to access the original
    hou.OpNode objects in the sequence you passed into this function, you
    will receive hou.ObjectWasDeleted exceptions.

    For every moved node, if a node with the same name already exists at the
    destination, the node will be renamed to a unique name.

    This function will raise a hou.OperationFailed exception if any of the
    nodes to be moved are of invalid type, the destination node cannot be
    copied into, or source node type does not match the destination node's
    child type.

    This function will raise hou.ObjectWasDeleted if any of source nodes or
    the destination node no longer exist in Houdini.

    All of the above issues with source and destination nodes will be
    reported before moving starts to avoid a partial move.

    After the function finishes execution, all the moved nodes by it will be
    selected.


    """
def addNodeBundle(name: Optional[str] = None) -> Bundle:
    """

    hou.addNodeBundle

    Create a new node bundle with the specified name.

    USAGE
      addNodeBundle(name = None) -> hou.NodeBundle

    See hou.NodeBundle for more information about node bundles.

    If name is None, a unique bundle name is generated automatically.

    Raises hou.OperationFailed if the name is not alphanumeric or a bundle
    with that name already exists.


    """
def nodeBundles() -> Tuple[Bundle, ...]:
    """

    hou.nodeBundles

    Return a tuple containing all the node bundles in the current session.

    USAGE
      nodeBundles() -> tuple of hou.NodeBundle

    See hou.NodeBundle for more information.


    """
def selectedNodeBundles() -> Tuple[Bundle, ...]:
    """

    hou.selectedNodeBundles

    Return a tuple containing all the node bundles that are selected in the
    bundle list pane.

    USAGE
      selectedNodeBundles() -> tuple of hou.NodeBundle

    This function is a shortcut for [bundle for bundle in hou.nodeBundles()
    if bundle.isSelected].

    See hou.NodeBundle for more information about bundles.


    """
def nodeBundle(name: str) -> Optional[Bundle]:
    """

    hou.nodeBundle

    Given a node bundle name, return the corresponding NodeBundle object, or
    None if there is not one with that name.

    USAGE
      nodeBundle(name) -> hou.NodeBundle or None

    See hou.NodeBundle for more information.


    """
def hdaDefinition(category: NodeTypeCategory, name: str, file_path: str) -> Optional[HDADefinition]:
    """

    hou.hdaDefinition

    Given a node type category, operator name and digital asset library
    path, return an HDADefinition object. Return None if no such installed
    digital asset definition matches the arguments.

    USAGE
      hdaDefinition(node_type_category, name, lib_path) -> hou.HDADefinition
      or None

    Be careful not to confuse this function with the class
    hou.HDADefinition.

    Example:

    > # Return the HDA definition for a SOP digital asset named 'foo'
    > # that is located in the '/tmp/bar.hda' library.
    > hou.hdaDefinition(hou.sopNodeTypeCategory(), 'foo', '/tmp/bar.hda')

    RELATED

      * hou.hda


    """
def time() -> float:
    """

    hou.time

    Return the playbar's current time, in seconds of playback.

    USAGE
      time() -> float

    Note that the time at frame 1 is 0s.

    RELATED

      * hou.setTime

      * hou.frame

      * hou.fps


    """
def setTime(time: float) -> None:
    """

    hou.setTime

    Set the playbar's time.

    USAGE
      setTime(time)

    RELATED

      * hou.time

      * hou.setFrame


    """
def frame(full_precision: bool = False) -> float:
    """

    hou.frame

    Return the playbar's current frame. Note that Houdini can be on a
    fractional frame if fractional frames are enabled.

    USAGE
      frame(full_precision=False) -> float

    Note that this function is equivalent to Hscript's $FF variable. If you
    want hscript's $F variable, use hou.intFrame, which rounds the frame to
    the nearest integer.

    To enable fractional frames, turn off the Integer Frame Values in the
    Global Animation Options dialog.

    This function rounds its output to 6 digits after the decimal point,
    just like Hscript's $FF variable does. To disable this rounding, pass
    True for the <full_precision> parameter. Note, though, that because a
    Python float may not be able to precisely represent a floating point
    value, and because Python does not round numbers when it displays them,
    the frame number might end with 9999999999999 or 0000000000001 when you
    print it to the Python shell. When you convert the number to a string,
    though, Python will round the value.

    > >>> 2.759
    > 2.7589999999999999
    > >>> 2.757
    > 2.7570000000000001
    > >>> str(2.759)
    > '2.759'

    If Houdini is on a fractional frame and you do not want the rounded
    value, use hou.timeToFrame(hou.time()).

    > >>> hou.setFrame(13.193)
    > >>> hou.frame()
    > 13.193
    > >>> hou.timeToFrame(hou.time())
    > 13.192999839782715
    > >>> hou.setFrame(2.759)
    > >>> hou.frame()
    > 2.7589999999999999
    > >>> int(hou.frame())
    > 2
    > >>> hou.intFrame()
    > 3

    RELATED

      * hou.intFrame

      * hou.setFrame

      * hou.time

      * hou.fps


    """
def intFrame() -> int:
    """

    hou.intFrame

    Return the playbar's current frame, rounded to the nearest integer.

    USAGE
      intFrame() -> int

    Note that this function is equivalent to Hscript's $F variable. If you
    want Hscript's $FF variable, use hou.frame.


    NOTE
        Due to floating point rounding, values near the half way point
        between two integers may round differently (for example 10.5 or
        32.5).

    RELATED

      * hou.frame

      * hou.setFrame

      * hou.time

      * hou.fps


    """
def setFrame(frame: float) -> None:
    """

    hou.setFrame

    Set the playbar's current frame. Note that the frame may be a fractional
    value.

    USAGE
      setFrame(frame)

    RELATED

      * hou.time

      * hou.setFrame


    """
def fps() -> float:
    """

    hou.fps

    Return the number of frames per second.

    USAGE
      fps() -> float

    This value is used when converting between frames and time.

    RELATED

      * hou.setFps

      * hou.frame

      * hou.time


    """
def setFps(fps: float, modify_frame_count: bool = True, preserve_keyframes: bool = False, preserve_frame_start: bool = False) -> None:
    """

    hou.setFps

    Set the number of frames per second.

    USAGE
      setFps(fps, modify_frame_count = True, preserve_keyframes = False,
      preserve_frame_start = False)


    fps
        Number of frames per second

    modify_frame_count
        Whether or not to adjust the number of frames to preserve the total
        time duration of the playback range.

    preserve_keyframes
        If true, keeps all keys on their current frames. Note that this will
        modify the speed of the animation.

    preserve_frame_start
        If true, adjusts the starting time of the playback in order to
        preserve the starting frame. The ending frame will also be preserved
        if modify_frame_count is False.

    RELATED

      * hou.fps


    """
def timeToFrame(time: float, full_precision: bool = False) -> float:
    """

    hou.timeToFrame

    Convert from a given time value to a frame value, rounding the result to
    a integer if it is close to an integer.

    USAGE
      timeToFrame(time, full_precision=False) -> float

    Calling this function is equivalent to evaluating time * hou.fps() +
    1.0. When <full_precision> is False, the result is rounded to 6 digits
    after the decimal point.

    RELATED

      * hou.fps

      * hou.frame

      * hou.time


    """
def frameToTime(frame: float) -> float:
    """

    hou.frameToTime

    Convert from a given frame value to a time value.

    USAGE
      frameToTime(frame) -> float

    Calling this function is the same as evaluating (frame - 1.0) /
    hou.fps(). Unlike hou.timeToFrame(), no rounding is performed.

    RELATED

      * hou.fps

      * hou.time

      * hou.frame


    """
def scaleToMKS(units: str) -> float:
    """

    hou.scaleToMKS

    Returns the scale factor from Meters-Kilograms-Seconds units into the
    Houdini session's current units.

    The provided dimensions specify the units and exponents of the units to
    convert from. These use the tokens kg, m, and s to provide the units of
    mass, distance, and time. Each unit should be suffixed by a floating
    point exponent.

    For example, area is m2 and acceleration is m1s-2, while volume density
    would be kg1m-3.

    USAGE
      scaleToMKS(dimensions) -> float


    """
def scaleFromMKS(units: str) -> float:
    """

    hou.scaleFromMKS

    Returns the scale factor from Meters-Kilograms-Seconds units into the
    Houdini session's current units.

    The provided dimensions specify the units and exponents of the units to
    convert from. These use the tokens kg, m, and s to provide the units of
    mass, distance, and time. Each unit should be suffixed by a floating
    point exponent.

    For example, area is m2 and acceleration is m1s-2, while volume density
    would be kg1m-3.

    USAGE
      scaleFromMKS(dimensions) -> float


    """
def bezier() -> float:
    """

    hou.bezier

    Evaluate a Bezier interpolation spline for an animated parameter using
    the left keyframe's outgoing value, tangent, and acceleration and the
    right keyframe's incoming value, tangent, and acceleration.

    USAGE
      bezier() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def constant() -> float:
    """

    hou.constant

    Evaluate an animation function for an animated parameter. The return
    value is always the left keyframe's outgoing value.

    USAGE
      constant() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def cubic() -> float:
    """

    hou.cubic

    Smooth curve between the left keyframe's outgoing slope and the right's
    incoming slope.

    USAGE
      cubic() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def cycle(start_frame: float, end_frame: float) -> float:
    """

    hou.cycle

    Repeats the motion between two times.

    USAGE
      cycle(start_frame, end_frame) -> float

    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffset() instead.

    This function is the same as hou.cyclet() except hou.cyclet() accepts
    times instead of frames.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cyclet

      * hou.cycleoffset

      * hou.cycleoffsett

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def cyclet(start_time: float, end_time: float) -> float:
    """

    hou.cyclet

    Repeats the motion between two times.

    USAGE
      cyclet(start_time, end_time) -> float

    The values within the range are repeated exactly. If you want to line up
    the values with the value of the previous keyframe, use
    hou.cycleoffsett() instead.

    This function is the same as hou.cycle() except hou.cycle() it accepts
    frames instead of times.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cycleoffset

      * hou.cycleoffsett

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def cycleoffset(start_time: float, end_time: float) -> float:
    """

    hou.cycleoffset

    Repeats the motion between two frames, lining up the first repeated
    value with the left keyframe's value.

    USAGE
      cycleoffset(start_frame, end_frame) -> float

    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.

    This function is the same as hou.cycleoffsett() except
    hou.cycleoffsett() accepts times instead of frames. If you want to
    repeat motion exactly, use the hou.cycle() function instead.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.cycleoffsett

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def cycleoffsett(start_time: float, end_time: float) -> float:
    """

    hou.cycleoffsett

    Repeats the motion between two times, lining up the repeated values with
    the left keyframe's value.

    USAGE
      cycleoffsett(start_time, end_time) -> float

    The repeated values are shifted so that each repeated portion has its
    first value set to the last value of the previous cycle. If the start
    frame is less than the end frame, the animation will cycle forwards.
    Otherwise, it will cycle backwards.

    This function is the same as hou.cycleoffset() except hou.cycleoffset()
    accepts frames instead of times. If you want to repeat motion exactly,
    use the hou.cyclet() function instead.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.cycleoffset

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def ease() -> float:
    """

    hou.ease

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    USAGE
      ease() -> float

    The tangents will be flat at both ends of the function, so the curve
    will slowly ease from the left value and, near the end of the function,
    slowly reduce the speed until it is at rest at the right value.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def easein() -> float:
    """

    hou.easein

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    USAGE
      easein() -> float

    The tangent will be flat at the left end of the function, so it will
    slowly ease from the outgoing value of the left keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def easeinp(ease_speed: float) -> float:
    """

    hou.easeinp

    Interpolates between the values of two keyframes.

    USAGE
      easeinp(ease_speed) -> float

    This function is like hou.easein, except it has an additional parameter
    to say how fast the curve should ease into the motion.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def easeout() -> float:
    """

    hou.easeout

    Interpolates between the left keyframe's outgoing value and the right
    keyframe's incoming value.

    USAGE
      easeout() -> float

    The tangent will be flat at the right end of the function, so it will
    slowly come to rest at the incoming value of the right keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def easeoutp(ease_speed: float) -> float:
    """

    hou.easeoutp

    Interpolates between the values of two keyframes.

    USAGE
      easeoutp(ease_speed) -> float

    This function is like hou.easeout, except it has an additional parameter
    to say how fast the curve should ease into the motion.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def easep(ease_bias: float) -> float:
    """

    hou.easep

    Interpolates between the values of two keyframes.

    USAGE
      easep(ease_bias) -> float

    An ease bias of less than one slow the animation near right keyframe,
    while an ease bias greater than one will slow it near the left keyframe.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def linear() -> float:
    """

    hou.linear

    Linearly interpolates between the left keyframe's outgoing value and the
    right keyframe's incoming value.

    USAGE
      linear() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def match() -> float:
    """

    hou.match

    Creates a smooth curve between the left keyframe's incoming slope and
    the right keyframe's outgoing slope.

    USAGE
      match() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def matchin() -> float:
    """

    hou.matchin

    Creates a straight line from the left keyframe's incoming value,
    matching the left keyframe's incoming slope.

    USAGE
      matchin() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def matchout() -> float:
    """

    hou.matchout

    Creates a straight line from the right keyframe's outgoing value,
    matching the right keyframe's outgoing slope.

    USAGE
      matchout() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def qlinear() -> float:
    """

    hou.qlinear

    Linearly interpolates between keyframes using quaternions.

    USAGE
      qlinear() -> float

    The neighboring parameters must also be animated; for example, if rx
    uses qlinear(), ry and rz should also use qlinear().

    Because the interpolation is done in quaternion spaces, the orientations
    will blend smoothly with no gimbal lock or unexpected spins. The Euler
    rotation values may appear to jump suddenly, but that's simply because
    different rotation values can represent the same orientation.

    Note that the graph editor will display a qlinear() segment as a dashed
    straight line. This line does not represent the actual intermediate
    channel values, but it does give an accurate visual feel for the
    behavior of the interpolation.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def quintic() -> float:
    """

    hou.quintic

    Evaluate an interpolation function for an animated parameter that gives
    a smooth curve between the left keyframe's outgoing value and the right
    keyframe's incoming value, using the left's outgoing slope and
    acceleration and the right's incoming slope and acceleration.

    USAGE
      quintic() -> float

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def repeat(start_frame: float, end_frame: float) -> float:
    """

    hou.repeat

    Repeats the motion between two times.

    USAGE
      repeat(start_frame, end_frame) -> float

    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cycle() instead.

    This function is the same as hou.repeatt() except hou.repeatt() accepts
    times instead of frames.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def repeatt(start_time: float, end_time: float) -> float:
    """

    hou.repeatt

    Repeats the motion between two times.

    USAGE
      repeatt(start_time, end_time) -> float

    The repeated values are repeated exactly. If you want to line up the
    values with the value of the previous keyframe, use hou.cyclet()
    instead.

    This function is the same as hou.repeat() except hou.repeat() it accepts
    frames instead of times.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cycleoffset

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.spline

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def spline() -> float:
    """

    hou.spline

    Fits a spline through consecutive keyframe values.

    USAGE
      spline() -> float

    The resulting spline interpolates the channel values at the keyframes,
    and slope values are not used.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.vmatch

      * hou.vmatchin

      * hou.vmatchout


    """
def vmatch() -> float:
    """

    hou.vmatch

    Matches the incoming and outgoing values and slopes.

    USAGE
      vmatch() -> float

    Unlike hou.match, this function will use its left keyframe's outgoing
    value and the right keyframe's incoming value, so hou.vmatch() can
    produce curves that are discontinuous with the previous segment.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatchin

      * hou.vmatchout


    """
def vmatchin() -> float:
    """

    hou.vmatchin

    Matches the left keyframe's incoming slope.

    USAGE
      vmatchin() -> float

    The curve will be a straight line from the left keyframe's outgoing
    value, and will not match the right keyframe's outgoing value. Unlike
    the hou.matchin() function, the left keyframe's outgoing value can
    differ from its incoming value, so so hou.vmatchin() can produce curves
    whose left tangent matches the left keyframe but whose left values do
    not line up.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchout


    """
def vmatchout() -> float:
    """

    hou.vmatchout

    Matches the right keyframe's outgoing slope.

    USAGE
      vmatchout() -> float

    The curve will be a straight line ending at the right keyframe's
    incoming value, and will not match the left keyframe's incoming value.
    Unlike the hou.matchout() function, the right keyframe's incoming value
    can differ from its outgoing value, so so hou.vmatchout() can produce
    curves whose right tangent matches the right keyframe but whose right
    values do not line up.

    This function is one of the special animation functions that use the
    current playbar time and information in the parameter's keyframes, such
    as in and out values, tangents, acceleration, etc., to evaluate
    themselves. Because the information needed to evaluate these functions
    comes from the keyframes, these functions take few or no parameters.

    Calling this function from outside a parameter's expression will raise a
    hou.NotAvailable exception.

    RELATED

      * hou.bezier

      * hou.constant

      * hou.cubic

      * hou.cycle

      * hou.cyclet

      * hou.ease

      * hou.easein

      * hou.easeinp

      * hou.easeout

      * hou.easeoutp

      * hou.easep

      * hou.linear

      * hou.match

      * hou.matchin

      * hou.matchout

      * hou.qlinear

      * hou.quintic

      * hou.repeat

      * hou.repeatt

      * hou.spline

      * hou.vmatch

      * hou.vmatchin


    """
def helpServerUrl() -> str:
    """

    hou.helpServerUrl

    Return the base URL for all Houdini help pages.

    USAGE
      helpServerUrl() -> string


    """
def hscriptCommandHelp(command_name: str) -> str:
    """

    hou.hscriptCommandHelp

    Return the text help of an hscript command. This function is used to
    help re-implement hscript commands in Python.

    USAGE
      hscriptCommandHelp(command_name) -> string


    """
def hscript(command: str) -> Tuple[str, ...]:
    """

    hou.hscript

    Executes an HScript command

    USAGE
      hscript(command) -> tuple of strings

    Returns a tuple of two strings: the regular output of the executed
    command, and the error output.

    You can specify multiple commands using ; or 
     as the separator.


    """
def almostEqual(x: float, y: float) -> bool:
    """

    hou.almostEqual

    Compares two numbers and returns True if they are almost equal in terms
    of how far apart they are when represented as floating point numbers.

    USAGE
      almostEqual(x, y) -> bool


    """
def fileReferences(project_dir_variable: str = ..., include_all_refs: bool = ...) -> Sequence[Tuple[Parm, str]]:
    '''

    hou.fileReferences

    USAGE
      fileReferences(project_dir_variable=\'HIP\', include_all_refs=true) ->
      tuple of hou.Parm and str tuples

    Returns a sequence of tuples representing all references to external
    files (such as textures, geometry files, and asset libraries) in the
    current scene.

    The first item in each tuple is a hou.Parm object representing the
    parameter containing the file reference, and the second item is the path
    string. (The second item is a convenience; you can get the same string
    by calling Parm.unexpandedString().)

    This can be useful when preflighting, to check that there are no
    references to files outside $HIP.

    > import os
    > 
    > hipdir = os.environ[\\"HIP\\"]
    > 
    > for parm, path in hou.fileReferences():
    >     # Assume you have a function to check if one path is the descendant
    >     # of another path
    >     if not is_inside(hipdir, path):
    >         print(\\"Problem: path %s is not inside the project dir %s\\" % (path, hipdir)

    (The sequence does not include default images and geometry files from
    inside Houdini\'s install location, for example default.bgeo in a File
    SOP.)


    project_dir_variable
        You can specify the name of an environment variable. If an asset
        path starts with the variable, it will be replaced with a variable
        reference in the path string returned by this function.

        For example, if $JOB is /mnt/projects/ and an asset is in
        /mnt/projects/tool.hda, if you call hou.fileReferences(\\"JOB\\"), it
        will return the path as $JOB/tool.hda.

    include_all_refs
        If this is True, then the function will return all the file
        references. If this is False, then the function will return only the
        selected file references.


    '''
def findFile(file_name: str) -> str:
    """

    hou.findFile

    Search the Houdini path for a specified file, returning the first match
    found. The filename specified should be relative to the Houdini
    directory.

    USAGE
      findFile(file_name) -> string

    If the file cannot be found in the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use hou.findDirectory
    instead.


    """
def findFiles(file_name: str) -> Tuple[str, ...]:
    """

    hou.findFiles

    Search the Houdini path for the specified file, returning a tuple of all
    the matches. The filename specified should be relative to the Houdini
    directory.

    USAGE
      findFiles(file_name) -> tuple of strings

    If the file cannot be found on the Houdini path, OperationFailed is
    raised. Directories are not found, for directories use
    hou.findDirectories instead.

    RELATED

      * hou.findFile

      * hou.findDirectory

      * hou.findDirectories

      * hou.houdiniPath


    """
def findFilesWithExtension(file_extension: str, subdirectory: Optional[str] = None) -> Tuple[str, ...]:
    """

    hou.findFilesWithExtension

    Search the Houdini path for files with a particular extension, returning
    a tuple of all the matches. A subdirectory can also be optionally
    provided which is appended to each entry in the Houdini path before
    looking for files.

    USAGE
      findFilesWithExtension(file_extension, subdirectory = None) -> tuple
      of strings

    Directories are not returned by this method.

    RELATED

      * hou.findFile

      * hou.findDirectory

      * hou.findDirectories

      * hou.houdiniPath


    """
def findDirectory(directory_name: str) -> str:
    """

    hou.findDirectory

    Search the Houdini path for a specified directory, returning the first
    match found. The directory name specified should be relative to the
    Houdini directory.

    USAGE
      findDirectory(directory_name) -> string

    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.

    RELATED

      * hou.findDirectories

      * hou.findFile

      * hou.findFiles

      * hou.houdiniPath


    """
def findDirectories(directory_name: str) -> Tuple[str, ...]:
    """

    hou.findDirectories

    Search the Houdini path for the specified directory, returning a tuple
    of all the matches. The directory name specified should be relative to
    the Houdini directory.

    USAGE
      findDirectories(directory_name) -> tuple of strings

    If the directory cannot be found in the Houdini path, OperationFailed is
    raised.

    RELATED

      * hou.findDirectory

      * hou.findFile

      * hou.findFiles

      * hou.houdiniPath


    """
def houdiniPath(pathvar: Optional[str] = None) -> Tuple[str, ...]:
    '''

    hou.houdiniPath

    Return the contents of the Houdini path as a tuple of strings.

    USAGE
      houdiniPath(path_variable = None) -> tuple of strings

    This method returns an ordered list of path components of the Houdini
    Path. The Houdini Path is used when searching for various files like
    otls, shelf tools, preferences, desktops, icons, etc. By adjusting the
    HOUDINI_PATH environment variable, you can add entries to the path that
    are specific to the current user, job, or studio.

    By default the components of the HOUDINI_PATH variable are returned. If
    the path_variable passed in refers to another well-known Houdini path,
    the components of that search path are returned instead. For example
    houdiniPath(\\"HOUDINI_OTLSCAN_PATH\\")

    See the output of hconfig -ap for more information on the current paths
    and their values.

    RELATED

      * hou.findFile

      * hou.findFiles

      * hou.findDirectory

      * hou.findDirectories


    '''
def homeHoudiniDirectory() -> str:
    """

    hou.homeHoudiniDirectory

    Return the path to the Houdini directory in your $HOME directory.

    USAGE
      homeHoudiniDirectory() -> str

    Return the directory in your $HOME directory where Houdini stores user-
    specific settings. On many platforms, this directory is
    $HOME/houdiniX.Y, where X is the Houdini major version and Y is the
    minor version. Note that on the Mac, though, this directory might be in
    a different location.

    See hou.houdiniPath for more information about how Houdini searches for
    files.

    RELATED

      * hou.houdiniPath

      * hou.applicationVersion

      * hou.findFile

      * hou.findFiles

      * hou.findDirectory

      * hou.findDirectories


    """
def readFile(file_path: str) -> str:
    """

    hou.readFile

    Read a file, returning the contents in a string. Supports regular files,
    opdef: and oplib: paths, and http URLs.

    USAGE
      readFile(file_path) -> str

    Opdef paths can be specified with the string opdef:/node?section (e.g.
    opdef:/Object/subnet1?my_section). Oplib paths can be specified with
    oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).

    If the file does not exist or an error occurs while reading, this
    function raises hou.OperationFailed.


    """
def readBinaryFile(file_path: str) -> bytes:
    """

    hou.readBinaryFile

    Read a binary file, returning the contents in a bytes object. Supports
    regular files, opdef: and oplib: paths, and http URLs.

    USAGE
      readBinaryFile(file_path) -> bytes

    Only available in Python 3.

    Opdef paths can be specified with the string opdef:/node?section (e.g.
    opdef:/Object/subnet1?my_section). Oplib paths can be specified with
    oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).

    If the file does not exist or an error occurs while reading, this
    function raises hou.OperationFailed.


    """
def saveCPIODataToString(data: typing.Iterable[Tuple[str, bytes]]) -> bytes:
    """

    hou.saveCPIODataToString

    Given a sequence of (name, value) string tuples, encode that data into a
    string in CPIO format.

    USAGE
      saveCPIODataToString(data_tuples) -> str

    The inverse of this function is hou.loadCPIODataFromString. See it for
    more information about CPIO data format.

    RELATED

      * hou.loadCPIODataFromString


    """
def loadIndexDataFromFile(file_path: str) -> dict[str, bytes]:
    """

    hou.loadIndexDataFromFile

    Given a file containing data in index data format, decode the data and
    return a dictionary representing the data.

    USAGE
      loadIndexDataFromFile(file_path) -> dict

    This function could be implemented as follows:

    > def loadIndexDataFromFile(file_path):
    >     hou.loadIndexDataFromString(hou.readFile(file_path))

    See hou.loadIndexDataFromString for more details.

    RELATED

      * hou.saveIndexDataToFile

      * hou.loadIndexDataFromString

      * hou.saveIndexDataToString


    """
def saveIndexDataToString(index_data: dict[str, bytes]) -> bytes:
    """

    hou.saveIndexDataToString

    Given a dictionary mapping strings to strings, encode that data into a
    string in index data format.

    USAGE
      saveIndexDataToString(data_dict) -> str

    The inverse of this function is hou.loadIndexDataFromString. See it for
    more information about index data format.

    RELATED

      * hou.loadIndexDataFromString

      * hou.loadIndexDataFromFile

      * hou.saveIndexDataToFile


    """
def saveIndexDataToFile(file_path: str, index_data: dict[str, bytes]) -> None:
    '''

    hou.saveIndexDataToFile

    Given a dictionary mapping strings to strings, encode that data in index
    data format and save it into a file.

    USAGE
      saveIndexDataToFile(file_path, index_data)

    This function could be implemented as follows:

    > def saveIndexDataToFile(file_path, index_data):
    >     with open(file_path, \\"wb\\") as open_file:
    >         open_file.write(hou.saveIndexDataToString(index_data))

    See hou.loadIndexDataFromString for more details.

    RELATED

      * hou.loadIndexDataFromFile

      * hou.loadIndexDataFromString

      * hou.saveIndexDataToString


    '''
def vexContexts() -> Tuple[VexContext, ...]:
    """

    hou.vexContexts

    USAGE
      vexContexts() -> tuple of VexContexts


    """
def vexContextForShaderType(shader_type: EnumValue) -> Optional[VexContext]:
    """

    hou.vexContextForShaderType

    NOTE
        This function is for internal use by Houdini and isn't usually
        necessary for scripting Houdini or creating tools.

    USAGE
      vexContextForShaderType(shader_type) -> hou.VexContext or None

    RELATED

      * VEX contexts

      * hou.vexContextForNodeTypeCategory


    """
def vexContextForNodeTypeCategory(node_type_category: NodeTypeCategory) -> Optional[VexContext]:
    '''

    hou.vexContextForNodeTypeCategory

    Takes a NodeTypeCategory object and returns a VexContext object
    representing the context of VOP networks the node would contain.


    NOTE
        This function is for internal use by Houdini and isn\'t usually
        necessary for scripting Houdini or creating tools.

    USAGE
      vexContextForNodeTypeCategory(node_type_category) -> hou.VexContext or
      None

    > >>> # Get a reference to a SOP node
    > >>> n = hou.node(\\"/obj/geo1/pointvop1\\")
    > >>> # Get its type category (SOPs)
    > >>> sops = n.type().category()
    > >>> # If a SOP contains a VOP network, what is its context?
    > >>> hou.vexContextForNodeTypeCategory(sops)
    > <hou.VexContext Sop>
    > >>> hou.vexContextForNodeTypeCategory(sops).name()
    > \'Sop\'
    See hou.VexContext.

    RELATED

      * VEX contexts

      * hou.vexContextForShaderType


    '''
def convertClipData(data: bytes, from_binary: bool, from_blosc_compression: bool, to_binary: bool, to_blosc_compression: bool) -> bytes:
    """

    hou.convertClipData

    USAGE
      convertClipData(data, from_binary, from_blosc_compression, to_binary,
      to_blosc_compression) -> str for Python 2, bytes for Python 3

    Converts the given clip <data> from the given format into the specified
    format.

    <from_binary> and <from_blosc_compression> specify the format of the
    given <data>.

      * If <from_binary> is True, the given data is binary clip data
        otherwise it is plain text (ASCII) clip data.

      * If <from_blosc_compression> is True, the given data contains blosc
        compressed binary clip data. This cannot be used with ASCII clip
        data.

    <to_binary> and <to_blosc_compression> specify the format the data
    should be converted to.

      * If <to_binary> is True, convert to a binary clip data otherwise
        convert to ASCII clip data.

      * If <to_blosc_compression> is True, convert to blosc compressed
        binary clip data. This cannot be used with ASCII clip data.

    The data passed into this function must be a bytes object in Python 3
    and a str object in Python 2. Similarly, the data returned by this
    function is a bytes object in Python 3 and a str object in Python 2. See
    HOM binary data for more information.

    Raises a hou.InvalidInput exception if from_binary = False and
    from_blosc_compression = True, or if to_binary = False and
    to_blosc_compression = True.

    Raises a hou.OperationFailed exception if the given <data> is invalid.


    """
def convertKeyframesToClipData(keyframe_map: dict[str, Sequence[Keyframe]], binary: bool = True, use_blosc_compression: bool = True) -> bytes:
    """

    hou.convertKeyframesToClipData

    USAGE
      convertKeyframesToClipData(keyframe_map, binary=True,
      use_blosc_compression=True) -> str

    Converts the given keyframes into clip data.


    keyframe_map
        A dictionary mapping parameter names (str) to a list of keyframes
        for the parameter (hou.Keyframe).

    <binary> and <use_blosc_compression> specify the format of the returned
    clip data.

      * If <binary> is True, the returned data is binary clip data.
        Otherwise it is plain text (ASCII) clip data.

      * If <use_blosc_compression> is True, the returned data is blosc
        compressed binary clip data. This cannot be used with ASCII clip
        data.

    Raises a hou.InvalidInput exception if binary = False and
    use_blosc_compression = True.

    Raises a hou.OperationFailed exception if the given <keyframe_map> is
    empty.


    """
def setSessionModuleSource(source: str) -> None:
    """

    hou.setSessionModuleSource

    Sets the contents of the hou.session module. The new contents is made
    available immediately. You do not have to re-import hou.session.

    USAGE
      setSessionModuleSource(source)

    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module. This can happen if the new contents has
    syntax errors.

    RELATED

      * hou.appendSessionModuleSource

      * hou.session

      * hou.setSessionModuleSource


    """
def appendSessionModuleSource(source: str) -> None:
    """

    hou.appendSessionModuleSource

    Appends the given source code to the hou.session module. The appended
    code is made available immediately. You do not have to re-import
    hou.session.

    USAGE
      appendSessionModuleSource(source)

    This function throws a hou.OperationFailed exception if it fails to
    update the hou.session module. This can happen if the appended source
    has syntax errors or if it conflicts with the existing contents of the
    module.

    RELATED

      * hou.session

      * hou.sessionModuleSource

      * hou.setSessionModuleSource


    """
def sessionModuleSource() -> str:
    """

    hou.sessionModuleSource

    Returns the contents of the hou.session module.

    USAGE
      sessionModuleSource() -> string

    RELATED

      * hou.appendSessionModuleSource

      * hou.session

      * hou.setSessionModuleSource


    """
def compareNode(path: str, dest: Optional[str] = None) -> bool: ...
def compareNodeBackup(path: str, index: int, dest: Optional[str] = None) -> bool: ...
def compareHDA(path_left: str, path_right: str, dest: Optional[str] = None) -> bool: ...
def compareHDABackup(path: str, index: int, dest: Optional[str] = None) -> bool: ...
def compareHip(dest: Optional[str] = None) -> bool: ...
def compareHipBackup(index: int, dest: Optional[str] = None) -> bool: ...
def hasContextOption(opt: str) -> bool:
    """

    hou.hasContextOption

    Returns True if the specified option exists in the current cook context.

    USAGE
      hasContextOption(option) -> bool

    This method tests for options that may have been set by a node
    requesting data from another node, or that are set in the default cook
    context options stored with the hip file.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.setContextOption


    """
def contextOptionNames() -> Tuple[str, ...]:
    """

    hou.contextOptionNames

    Returns the names of all available cook context options.

    USAGE
      contextOptionNames() -> tuple of str

    Retrieves the names of all options available in the current cook
    context. If this method is invoked outside a cook context, it will
    return the names of all the default cook context options stored in the
    hip file. It will also return all automatic context options

    RELATED

      * hou.contextOption

      * hou.hasContextOption

      * hou.setContextOption


    """
def setContextOption(option: str, value: str|float|None) -> None:
    """

    hou.setContextOption

    Sets the default value for a cook context option.

    USAGE
      setContextOption(option, value)

    If the named context option doesn't already exist, it is created as part
    of the set of default cook context options that are stored with the hip
    file. Passing a value of None will remove the named context option from
    the set of default options. The value may be either a string or a
    number.

    Note that the value for automatic context options can be overridden by
    this method, but setting them to None will not remove these context
    options. It will cause them to revert to their automatically generated
    values.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.hasContextOption


    """
def removeContextOption(opt: str) -> None:
    """

    hou.removeContextOption

    Removes the default value for a cook context option.

    USAGE
      removeContextOption(option)

    Removes the named context option from the set of default options.

    Note that automatic context options cannot be removed. Calling this
    method for an automatic context option will only remove any explicit
    overrides set with hou.setContextOption. The named context option will
    just revert to its automatically generated value.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.hasContextOption

      * hou.setContextOption


    """
def contextOptionConfig(opt: str) -> str:
    """

    hou.contextOptionConfig

    Returns the string that holds the UI configuration for the default value
    of a context option.

    USAGE
      contextOptionConfig(option) -> str

    Returns a string associated with a context option that describes the
    appearance of the UI for controlling the option's default value in the
    Default Context Options dialog.

    See hou.setContextOptionConfig for more information on the string
    format.

    RELATED

      * hou.setContextOptionConfig

      * hou.setContextOption


    """
def setContextOptionConfig(opt: str, config: str) -> None:
    """

    hou.setContextOptionConfig

    Sets a string to hold the UI configuration for the default value of a
    context option.

    USAGE
      setContextOptionConfig(option, config)

    Associates a configuration string string with the context option named
    option. This value is saved in the HIP file, similar to the context
    option's default value.

    The string content is interpreted by the built-in Context Option editor
    pane. If a user or studio create their own context option editor UI,
    they can store arbitrary configuration data in this string. However, in
    that case, you should avoid using the built-in editor because it will
    overwrite the string.


    WARNING
        While we provide API for getting and setting a config string, SideFX
        does not consider the actual format of the string, as written by the
        built-in context option editor pane, to be public API. The format
        may change without notice between versions. If you write rely on the
        config strings created by Houdini, you should understand that they
        may stop working someday.

    The current content is a JSON dictionary with the following keys:

    label
    str

    A human-readable label for the context option.

    type
    str

    This controls what type of interface the context option editor shows the
    user for editing the value. It only configures the user interface.
    Anyone can still set the option to any value through scripting.


    text
        A plain text field.

    number
        A text field that expects a number.

    file_path
        A text field with a button to open a file chooser.


        node_path
            A text field with a button to open a node chooser.

    float_slider
        A numeric text field with a slider. Other config keys below control
        the slider range.

    int_slider
        A numeric text field with a slider that snaps to integers. Other
        config keys below control the slider range.

    string_menu
        A pop-up menu that sets the option to a string value. See the
        menu_items key below.

    int_menu
        A pop-up menu that sets the option to an integer value. See the
        menu_items and autovalues keys below.

    py_menu
        A pop-up menu that runs a Python script to generate the menu item
        labels and values. See the menu_source key below.

    checkbox
        A checkbox. Sets the option value to 0 or 1.

    heading
        The option label is displayed as a heading without any editor. You
        can use this to organize the options into categories.

    order
    int

    The order in which the option appears in the editor view. Any time the
    user drag-reorders an option this number is overwritten.

    comment
    str

    A string explaining the purpose of the context option.

    menu_items
    array

    A list of [label_str, value] pairs, used for mene type editor UIs.

    autovalues
    bool

    Whether int_menu type options should use automatically generated values.
    If this is on, the values for the menu items are set to 0, 1, 2, etc.,
    ignoring the value part of the paris in menu_items.

    menu_source
    str

    For a py_menu type option, this is the Python source code for generating
    the menu. If this string is one line (that is, the string contains no
    newline characters), Houdini evaluates it as an expression. If this
    string has multiple lines, Houdini runs it as if it was the body of a
    function, so it should return the menu items. The result should be a
    list of (label_str, value) pairs.

    minimum
    int or float

    The low end of the slider for int_slider and float_slider types.

    min_locked
    bool

    If this is true, the UI doesn't let the user manually enter numbers
    smaller than minimum.

    maximum
    int or float

    The high end of the slider for int_slider and float_slider types.

    max_locked
    bool

    If this is true, the UI doesn't let the user manually enter numbers
    larger than maximum.

    RELATED

      * hou.contextOptionConfig

      * hou.setContextOption


    """
def isAutoContextOption(opt: str) -> bool:
    """

    hou.isAutoContextOption

    Indicate whether the given context option is an automatic option.

    USAGE
      isAutoContextOption(option) -> bool

    Return True if the specified context option is an automatic option,
    whose value is normally controlled by Houdini rather than set by the
    user. This does not necessarily indicate that the current value has been
    set automatically, as any context option can be overridden by a script
    or a node in the network. But if an automatic option is not being set by
    any other source, it will still be set to a value determined by the
    following rules:


    fend
        The last frame of the global Houdini frame range. Equivalent to
        theFEND global variable.

    finc
        The current playbar step size.

    fps
        The current playbar frames per second (FPS) setting.

    fstart
        The first frame of the global Houdini frame range. Equivalent to
        theFSTART global variable.

    rfend
        The last frame of the current playback range. Equivalent to theRFEND
        global variable.

    rfstart
        The first frame of the current playback range. Equivalent to
        theRFSTART global variable.

    ropcook
        An integer value that will be 1 while a ROP node is running,
        otherwise 0.

    ropend
        The last frame of the range being evaluated by the currently cooking
        ROP node. If no ROP node is cooking, it will be equal to the fend
        automatic option.

    ropinc
        The increment value of the frame range being evaluated by the
        currently cooking ROP node. If no ROP node is cooking, it will be
        equal to the finc automatic option.

    ropname
        A string set to the name of the ROP node that is currently running,
        otherwise an empty string.

    roppath
        A string set to the full path of the ROP node that is currently
        running, otherwise an empty string.

    ropstart
        The first frame of the range being evaluated by the currently
        cooking ROP node. If no ROP node is cooking, it will be equal to the
        fstart automatic option.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.isAutoContextOptionOverridden


    """
def isAutoContextOptionOverridden(opt: str) -> bool:
    """

    hou.isAutoContextOptionOverridden

    Indicate whether the given context option is an automatic option that is
    currently overridden from its automatic value.

    USAGE
      isAutoContextOptionOverridden(option) -> bool

    Return True if the specified context option is an automatic option, and
    that option has been overridden to replace the automatic value. This
    will be the case if an automatic option value is overwritten by a
    script, a node, or as a result of cooking a ROP. For a list of automatic
    context options, see hou.isAutoContextOption.

    RELATED

      * hou.contextOption

      * hou.contextOptionNames

      * hou.isAutoContextOption


    """
def removeAllContextOptionChangeCallbacks() -> None:
    """

    hou.removeAllContextOptionChangeCallbacks

    Stops all callbacks from being executed when a default context option is
    changed.

    USAGE
      removeAllContextOptionChangeCallbacks()

    Removes all callbacks that were previously registered with
    hou.addContextOptionChangeCallback.

    RELATED

      * hou.addContextOptionChangeCallback

      * hou.contextOptionChangeCallbacks

      * hou.removeContextOptionChangeCallback

      * hou.setContextOption

      * hou.setContextOptionConfig


    """
def getPreferenceNames() -> Tuple[str, ...]:
    """

    hou.getPreferenceNames

    Return all the preference names.

    USAGE
      getPreferenceNames() -> tuple of strings

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.addPreference

      * hou.refreshPreferences

      * hou.removePreference


    """
def getPreference(name: str, registry_name: Optional[str] = None) -> str:
    """

    hou.getPreference

    Return a preference value.

    USAGE
      getPreference(name, registry_name=None) -> string

    PARAMETERS

        name: The preference name.

        registry_name: The registry name, if the preference was created
        within a registry.

    RELATED

      * hou.addPreference

      * hou.createPreferenceRegistry

      * hou.getPreferenceNames

      * hou.loadPreferences

      * hou.refreshPreferences

      * hou.refreshPreferenceRegistry

      * hou.removePreference

      * hou.savePreferences

      * hou.setPreference


    """
def setPreference(name: str, value: str, registry_name: Optional[str] = None) -> bool:
    """

    hou.setPreference

    Sets a preference given a name and returns true on success.

    USAGE
      setPreference(name, value, registry_name=None) -> bool

    PARAMETERS

        name: The preference name.

        value: The preference value of type str.

        registry_name: The registry name, if the preference was created
        within a registry.

    RELATED

      * hou.addPreference

      * hou.createPreferenceRegistry

      * hou.getPreferenceNames

      * hou.loadPreferences

      * hou.refreshPreferences

      * hou.refreshPreferenceRegistry

      * hou.removePreference

      * hou.savePreferences

      * hou.setPreference


    """
def addPreference(name: str, value: str) -> bool:
    """

    hou.addPreference

    Add a user preference.

    Add a new user preference stored in the houdini.pref file.

    The preference won't appear in the Preferences user interface as this is
    meant for custom Python panels or scripts.

    Returns True if the preference was added successfully. Return False if
    the preference already existed or if it didn't start with custom..

    USAGE
      addPreference(name,value) -> bool


    name
        The preference name must start with 'custom.'.

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.removePreference

      * hou.getPreferenceNames

      * hou.refreshPreferences


    """
def removePreference(name: str) -> bool:
    """

    hou.removePreference

    Remove a user preference.

    Remove a user preference stored in the houdini.pref file.

    Returns True if the preference was removed successfully. Return False if
    the preference didn't exist or if it didn't start with custom..

    USAGE
      removePreference(name) -> bool


    name
        The preference name to remove. It must start with 'custom.'.

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.addPreference

      * hou.getPreferenceNames

      * hou.refreshPreferences


    """
def refreshPreferences() -> None:
    """

    hou.refreshPreferences

    Refresh all user preferences.

    Refresh all user preferences to ensure calls to hou.getPreference
    returns the current value.

    USAGE
      refreshPreferences()

    RELATED

      * hou.getPreference

      * hou.setPreference

      * hou.addPreference

      * hou.getPreferenceNames

      * hou.removePreference


    """
def savePreferences(registry_name: str) -> None:
    """

    hou.savePreferences

    Save the preferences of the specified registry to disk.

    USAGE
      savePreferences(registry_name)

    PARAMETERS


        registry_name
            The unique identifier of the registry to be saved.

    RELATED

      * hou.createPreferenceRegistry

      * hou.getPreference

      * hou.loadPreferences

      * hou.refreshPreferenceRegistry

      * hou.setPreference


    """
def loadPreferences(registry_name: str) -> None:
    """

    hou.loadPreferences

    Load the preferences of the specified registry from disk.

    USAGE
      loadPreferences(registry_name)

    Loads the registry from the user preference directory
    ($HOUDINI_USER_PREF_DIR). Once loaded, the updated preference values can
    be accessed using hou.getPreference.

    PARAMETERS


        registry_name
            The unique identifier of the registry to be loaded.

    RELATED

      * hou.createPreferenceRegistry

      * hou.getPreference

      * hou.refreshPreferenceRegistry

      * hou.savePreferences

      * hou.setPreference


    """
def createPreferenceRegistry(registry_name: str, file_name: str, prefs: dict[str, Any], prefix_name: Optional[str] = None, binary: bool = False) -> None:
    """

    hou.createPreferenceRegistry

    Creates a registry container to store preferences.

    USAGE
      createPreferenceRegistry(registry_name, file_name, prefs,
      prefix_name=None, binary=False)

    The created registry can be saved to disk in the user preference
    directory ($HOUDINI_USER_PREF_DIR) using hou.savePreferences.
    Preferences stored in the registry can be updated with hou.setPreference
    and accessed with hou.getPreference. To update preferences from disk,
    use hou.loadPreferences. Note that Houdini does not automatically load
    the registry on startup.

    PARAMETERS


        registry_name
            The unique identifier for the registry.

        file_name
            The base file name, including its extension. Supported
            extension: .pref (text format) and .json (JSON format).

        prefs
            A dictionary containing preference key-value pairs. Keys
            represent preference names, and values can be of type int,
            float, or str.

        prefix_name
            An optional prefix to prepend to preference names.

        binary
            If True, saves the registry as a binary JSON file. The flag is
            ignored for text files.

    RELATED

      * hou.createPreferenceRegistry

      * hou.loadPreferences

      * hou.refreshPreferenceRegistry

      * hou.savePreferences

      * hou.setPreference


    """
def refreshPreferenceRegistry(registry_name: str, prefs: dict[str, Any], clear_existing: bool = False) -> None:
    """

    hou.refreshPreferenceRegistry

    Updates a preference registry container.

    USAGE
      refreshPreferenceRegistry(registry_name, new_prefs,
      clear_existing=False)

    Updates the specified preference registry with new values and saves the
    changes to the user preference directory ($HOUDINI_USER_PREF_DIR).

    PARAMETERS


        registry_name
            The unique identifier of the preference registry to refresh.

        new_prefs
            A dictionary containing the updated preference values. See
            hou.createPreferenceRegistry for details.

        clear_existing
            If True, clears all existing preferences before applying
            new_prefs. If clear_existing is False, only the provided
            preferences are updated or added, while existing ones remain
            unchanged.

    RELATED

      * hou.createPreferenceRegistry

      * hou.getPreference

      * hou.loadPreferences

      * hou.savePreferences

      * hou.setPreference


    """
def startHoudiniEngineDebugger(portOrPipeName: int|str) -> None:
    '''

    hou.startHoudiniEngineDebugger

    Starts a Houdini Engine debugging session in Houdini if no session is
    currently active

    USAGE
      startHoudiniEngineDebugger(port) startHoudiniEngineDebugger(pipeName)


    port
        The port number that the debugging server should use

    pipeName
        The pipe name that the debugging server should use

    EXAMPLES

      > >hou.startHoudiniEngineDebugger(9090)
      > >hou.startHoudiniEngineDebugger(\\"hapi_debug_session\\")


    '''
def userName(alpha: bool = True) -> str:
    """

    hou.userName

    Returns the user name for the current Houdini session.

    This is the name that Houdini recognizes as the current user. This is
    saved into HDAs, .hip files, and similar places. The HOUDINI_AUTHOR can
    be used to override this.

    USAGE
      userName( alpha=True ) -> string


    alpha
        If True (default) the function returns the user name with alpha
        characters only. Blank characters are replaced with underscores (_).
        If False, the function returns the user name as is.

    RELATED

      * hou.machineName


    """
def machineName(alpha: bool = True) -> str:
    """

    hou.machineName

    Returns the name of the computer used with this Houdini session.

    This is the name that Houdini recognizes as the current machine. This is
    saved into HDAs, .hip files, and similar places. The HOUDINI_AUTHOR can
    be used to override this.

    USAGE
      machineName( alpha=True ) -> string


    alpha
        If True (default) the function returns the machine name with alpha
        characters only. Blank characters are replaced with underscores (_).
        If False, the function returns the machine name as is.

    RELATED

      * hou.userName


    """
def createAnimationLayers(path: str = ...) -> ChopNode:
    '''

    hou.createAnimationLayers

    Creates an Animation Layer Mixer from the parameters in the Channel
    List.

    USAGE
      createAnimationLayers( path=\\"\\" ) -> hou.ChopNode

    Returns the created node of a the existing one if it already exists.


    path
        A full path to the location of the Layer CHOP node to create. The
        parent CHOPnet will be created automatically. If path empty, the
        default animation layers path will be used.

    RELATED

      * hou.addAnimationLayer

      * hou.removeAnimationLayer

      * hou.createAnimationClip


    '''
def addAnimationLayer(layermixer: ChopNode, layername: str = ...) -> ChopNode:
    '''

    hou.addAnimationLayer

    Adds an Animation Layer to an existing Animation Layer Mixer.

    USAGE
      addAnimationLayer( layermixer, layername=\\"\\" ) -> hou.OpNode

    Returns the created CHOP Channel node.


    layermixer
        A Layer CHOP on which to add the animation layer. A new multi
        instance will be added, its name set to layername.

    layername
        The layer name of the new layer.

    RELATED

      * hou.createAnimationLayers

      * hou.removeAnimationLayer

      * hou.createAnimationClip


    '''
def removeAnimationLayer(layermixer: ChopNode, layername: str, merge_down: bool = ...) -> bool:
    """

    hou.removeAnimationLayer

    Removes an Animation Layer from an existing Animation Layer Mixer.

    USAGE
      removeAnimationLayer( layermixer, layername, mergedown=False ) -> bool

    Returns True if the animation layer was removed.


    layermixer
        A Layer CHOP from which to remove the animation layer.

    layername
        The layer name to remove.

    RELATED

      * hou.createAnimationLayers

      * hou.addAnimationLayer

      * hou.createAnimationClip


    """
def createAnimationClip(path: str = ..., set_export: bool = ...) -> ChopNode:
    '''

    hou.createAnimationClip

    Creates an Animation Clip Mixer from the parameters in the Channel List.

    USAGE
      createAnimationClip( path=\\"\\",set_export=False ) -> hou.ChopNode


    path
        A full path to the location of the Channel CHOP node to create. The
        parent CHOPnet will be created automatically. If path empty, the
        default animation clip path will be used. If a node already exists,
        a new node will still be created by with a numbered name.

    set_export
        Set the Export flag after creating the Channel CHOP.

    RELATED

      * hou.addAnimationLayer

      * hou.removeAnimationLayer

      * hou.createAnimationLayers


    '''
def registerOpdefPath(path: str, server_name: str, port: str = ...) -> None:
    '''

    hou.registerOpdefPath

    Tells Houdini\'s web server to use the specified prefix as a handler to
    serve opdef requests.

    USAGE
      registerOpdefPath(\\"/opdef\\", \\"server_name\\", port=\\"\\")

    When the server receives a request whose path starts with prefix, the
    server will respond with the corresponding opdef section data. The port
    can be optionally specified if the handler should run off a port other
    than the main server port.

    Call this function before you call , not from a URL handler.

    For example, if you do this:

    > hou.registerOpdefPath(\\"/opdef\\")

    ...and the client requests this server path:

    > /opdef/obj/geo?Help

    ...then the server will automatically serve the section Help from the
    geo node.


    NOTE
        If a URL handler has a URL more specific (matches more path parts)
        than the opdef path prefix, the server will use the handler instead
        of opdef lookup.

        For example, even if you registered the opdef from above, if the
        client requested /opdef/geo/foo.bgeo and you have a dynamic handler
        for /opdef/geo, the server would use the handler instead of using
        the opdef handler.

        This might be useful if you need a few dynamically generated opdef
        handlers mixed in with the static opdef handler. However, it\'s
        usually best to avoid the confusion and keep opdef resources
        separate from dynamic resources, such as by using the default /opdef
        prefix for opdef section requests.

    RELATED




    '''
def videoEncoders(driver: EnumValue, available: bool = False) -> Tuple[str, ...]:
    """

    hou.videoEncoders

    Returns the video encoders that are registered with a given driver and
    optionally, which encoders are available on the current platform and
    license type.

    USAGE
      videoEncoders(driver, available) -> tuple of str

    The driver parameter must be a hou.videoDriver. If available is True,
    only the encoders that are available on the current platform and license
    type are returned, otherwise all encoders are returned. If it is not
    specified, it is interpreted as False.

    > 
    > >>> ffmpeg_encoders = hou.videoEncoders(hou.videoDriver.FFmpeg)
    > >>> available_ffmpeg_encoders = hou.videoEncoders(hou.videoDriver.FFmpeg, True)

    RELATED

      * hou.videoDriver


    """
def refreshStartupPathCacheDirectory(dir_path: str) -> None:
    """

    hou.refreshStartupPathCacheDirectory

    Instructs the startup cache to refresh a given directory.

    USAGE
      refreshStartupPathCacheDirectory(dir_path)

    By default, Houdini caches search paths during startup to accelerate the
    startup process by reducing filesystem activity, however it makes
    Houdini's view of the filesystem effectively static during this time. If
    the filesystem is modified during startup, you should pass the directory
    to this method after you have finished your modifications so that the
    changes will

    > 
    > >>> hou.refreshStartupPathCacheDirectory('/the/path/to/a/directory')

    """

assertTrue: Incomplete
clipInfo: Incomplete
expandString: Incomplete
hscriptExpandString: Incomplete
expandStringAtFrame: Incomplete
incrementNumberedString: Incomplete
encode: Incomplete
decode: Incomplete
thirdPartyLibraryVersions: Incomplete
selectedItemsAsData: Incomplete
itemsAsData: Incomplete
createItemsFromData: Incomplete
parmTemplateFromData: Incomplete
hipExtension: Incomplete

# Missing classes added by stubgen

class _PointTupleGenerator:
    """Class added by stubgen"""
    def __getitem__(self, key: int) -> Point: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...

class _PrimTupleGenerator:
    """Class added by stubgen"""
    def __getitem__(self, key: int) -> Prim: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...

class _EdgeTupleGenerator:
    """Class added by stubgen"""
    def __getitem__(self, key: int) -> Edge: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...

class _VertexTupleGenerator:
    """Class added by stubgen"""
    def __getitem__(self, key: int) -> Vertex: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...

class data:
    """Class added by stubgen"""
    @staticmethod
    def clusterItemsAsData(items: Sequence[NetworkMovableItem], target_node: OpNode, frame_nodes: Sequence[NetworkMovableItem]=..., selected_nodes: Sequence[NetworkMovableItem]=..., current_node: NetworkMovableItem =..., flags: bool=True, nodes_only: bool=False, target_children: bool=False, children: bool=True, target_editables: bool=False, editables: bool=True, target_parms: Union[bool, Sequence[ParmTuple], Sequence[str]]=True, parms: bool=True, default_parmvalues: bool=False, evaluate_parmvalues: bool=False, parms_as_brief: bool=True, parmtemplates: str=..., metadata: bool=False, verbose: bool=False) -> dict[str, Any]: ...
    @staticmethod
    def createClusterItemsFromData(parent: OpNode, data: dict[str, Any], target_node: OpNode=..., clear_content=False, force_item_creation: bool=True, external_connections: bool=True, parms: bool=True, parmtemplates: bool=True, children: bool=True, editables: bool=True, offset_position: Vector2=..., skip_notes: bool=False) -> dict[str, NetworkMovableItem]: ...
    @staticmethod
    def createItemsFromData(parent: OpNode, data: dict[str, Any], clear_content: bool=False, force_item_creation: bool=True, offset_position: Vector2=..., external_connections: bool=True, parms: bool=True, parmtemplates: bool=True, children: bool=True, editables: bool=True, skip_notes: bool=False) -> dict[str, NetworkMovableItem]: ...
    @staticmethod
    def dataFromParms(parms: Sequence[ParmTuple], values: bool=True, evaluate_values: bool=False, locked: bool=True, brief: bool=True, multiparm_instances: bool=True, metadata: bool=False, verbose: bool=False) -> dict[str,Any]: ...
    @staticmethod
    def itemsAsData(items: Sequence[NetworkMovableItem], nodes_only: bool=False, children: bool=True, editables:bool=True, inputs: bool=True, position: bool=True, anchor_position: Vector2=..., flags: bool=True, parms: bool=True, parms_as_brief: bool=True, default_parmvalues: bool=False, evaluate_parmvalues: bool=False, parmtemplates: str=..., metadata: bool=False, verbose: bool=False) -> dict[str, Any]: ...
    @staticmethod
    def selectedItemsAsData(nodes_only: bool=False, children: bool=True, editables: bool=True, inputs: bool=True, position: bool=True, anchor_position: Vector2=..., flags: bool=True, parms: bool=True, parms_as_brief: bool=True, default_parmvalues: bool=False, evaluate_parmvalues: bool=False, parmtemplates: str=..., metadata: bool=False, verbose: bool=False) -> dict[str, Any]: ...
